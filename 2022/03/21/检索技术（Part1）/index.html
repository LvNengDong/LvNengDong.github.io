<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="01 | 线性结构检索：从数组和链表的原理初窥检索本质   学习目标：通过学习数组和链表这样的线性结构的检索过程，举一反三，深入理解检索的概念。  【问题】首先，我们来思考一个问题：什么是检索？ 从字面意义上来讲，检索就是将我们所需要的信息，从存储数据的地方高效取出的一种技术。通过对这句话的简单理解，我们可以大概猜想到：想要提高检索效率，那我们的关注点应该有两个：   存储数据的地方  取出数据的">
<meta property="og:type" content="article">
<meta property="og:title" content="检索技术（Part1）">
<meta property="og:url" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="01 | 线性结构检索：从数组和链表的原理初窥检索本质   学习目标：通过学习数组和链表这样的线性结构的检索过程，举一反三，深入理解检索的概念。  【问题】首先，我们来思考一个问题：什么是检索？ 从字面意义上来讲，检索就是将我们所需要的信息，从存储数据的地方高效取出的一种技术。通过对这句话的简单理解，我们可以大概猜想到：想要提高检索效率，那我们的关注点应该有两个：   存储数据的地方  取出数据的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321193427186.png">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321195720343.png">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321201525392.png">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321202554930.png">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/1859310bd112d5479eac9c097db8b946.jpeg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/2c61d26ed919411dd9be1a94cefb30ca.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/d274bfacd98b00d82746cfeb838ec1f4.jpeg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/bf8df69285c21e28b493bd2f7a0c1abb.jpeg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/4b5e88addf89120aba176671c53d25f1.jpeg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/8e602ab79d98380c8c258a30a1e2108b.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/2ccc78df6ebbd4d716318d5113fa090d.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/a377f626bbfc1de2f98f199ed0ad585f.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/c91ce2f3cff16b20b0cca52a57336b96.jpeg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/3ad283ed20ba36a8f5f8350ee4bd7d56.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/0e7ca7c9a2c9c373353ae5ec824f4f1e.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/0203a7cc903e3acf38e47a59ad3aa6b4.jpeg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/a994e93f2fdd38291998cba8149270eb.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/72499a6180cfb1ee7e3c33e6ca433b65.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/9ed9028cab65e6530966faae00d0d3d4.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/674115e7c61637e56791e001ea840af2.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/03af63ed8cd065743bd8b2bd812e5057.jpg">
<meta property="og:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/53fd14349369951706f53abd1eff560f.jpg">
<meta property="article:published_time" content="2022-03-21T11:16:27.000Z">
<meta property="article:modified_time" content="2022-04-05T06:05:53.601Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321193427186.png">


<link rel="canonical" href="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/","path":"2022/03/21/检索技术（Part1）/","title":"检索技术（Part1）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>检索技术（Part1） | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#01-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E6%A3%80%E7%B4%A2%EF%BC%9A%E4%BB%8E%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%9D%E7%AA%A5%E6%A3%80%E7%B4%A2%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.</span> <span class="nav-text">01 | 线性结构检索：从数组和链表的原理初窥检索本质</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">数组和链表有哪些优点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%90%E5%8D%87%E6%95%B0%E7%BB%84%E7%9A%84%E6%A3%80%E7%B4%A2%E6%95%88%E7%8E%87%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">如何使用二分查找提升数组的检索效率？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%9C%A8%E6%A3%80%E7%B4%A2%E5%92%8C%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E4%B8%8A%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">链表在检索和动态调整上的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%81%B5%E6%B4%BB%E6%94%B9%E9%80%A0%E9%93%BE%E8%A1%A8%E6%8F%90%E5%8D%87%E6%A3%80%E7%B4%A2%E6%95%88%E7%8E%87%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">如何灵活改造链表提升检索效率？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#02-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E6%A3%80%E7%B4%A2%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A2%91%E7%B9%81%E5%8F%98%E5%8C%96%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E6%A3%80%E7%B4%A2%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">02 | 非线性结构检索：数据频繁变化的情况下，如何高效检索？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">树结构是如何进行二分查找的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A3%80%E7%B4%A2%E6%A0%91%E7%9A%84%E7%A9%BA%E9%97%B4%E5%B9%B3%E8%A1%A1%E6%96%B9%E6%A1%88"><span class="nav-number">2.2.</span> <span class="nav-text">二叉检索树的空间平衡方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-%E7%8A%B6%E6%80%81%E6%A3%80%E7%B4%A2%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">04 | 状态检索：如何判断一个用户是否存在？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.0.1.</span> <span class="nav-text">如何使用数据的随机访问特性提高查询效率？

以新注册用户时查询用户 ID 是否存在为例，我们可以直接使用有序数组、二叉检索树或者哈希表来存储所有的用户 ID。
我们知道，无论是有序数组还是二叉检索树，它们都是使用二分查找的思想从中间元素开始查起的。所以，在查询用户 ID 是否存在时，它们的平均检索时间复杂度都是 O(log n)，而哈希表的平均检索时间复杂度是 O(1)。因此，如果我们希望能快速查询出元素是否存在，那哈希表无疑是最合适的选择。不过，如果从工程实现的角度来看的话，哈希表的查询过程还是可以继续优化的。
比如说，如果我们要查询的对象 ID 本身是正整数类型，且 ID 范围有上限的话。我们可以申请一个足够大的数组，让数组长度超过 ID 的上限。然后，把数组中所有位置的值都初始化为 0。对于存在的用户，我们直接将用户 ID 作为数组下标，将该位置对应的值从 0 设置为 1 就可以了。

05 | 倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？
  提出问题：

试想这样一个场景：假设你已经熟读唐诗300首了。这个时候，如果我给你一首诗的题目，相信你一定可以很快背出这首诗的内容。但是如果我问你，有哪些诗中同时包含了“极”和“客”字？很显然，第二个问题的难度比第一个问题大得多。
那么从程序设计的角度来看，这两个问题对应的检索过程又有什么不同呢？这就对应了两种非常常见且重要的检索技术：**正排索引 **和 倒排索引。
什么是倒排索引？

我们先来看看第一个问题：给出一首诗的题目，马上背出内容。这其实就是一个典型的键值查询场景。针对这个场景，我们可以给每首诗一个唯一的编号作为 ID，然后使用哈希表将诗的 ID 作为键（Key），把诗的内容作为键对应的值（Value）。这样，我们就能在 O(1) 的时间复杂度内，完成对指定 key 的检索。这样的以对象的唯一 ID 为 key 的哈希索引结构，叫做正排索引（Forward Index）。

一般来说，我们会遍历哈希表，遍历的时间复杂度是 O(n)。在遍历过程中，对于遇到的每一个元素对应着一首诗，如果我们想要判断这首诗中是否包含“极”字和“客”字，我们还需要遍历这首诗中的每一个字符。假设每首诗的平均长度是 k，那么遍历一首诗的时间代价就是 O(k)。所以，判断哪些诗中包含“极”字和“客”字的时间复杂度就是 O(n*k)。从分析中我们可以发现，这个检索过程全部都是遍历，因此时间复杂度非常高。对此，有什么优化方法吗？
我们首先来分析一下这两个场景。我们会发现，“根据题目查找内容”和“根据关键字查找题目”，这两个问题其实是完全相反的。既然完全相反，那我们能否“反着”建立一个哈希表来帮助我们查找呢？也就是说，如果我们以关键字作为 key 建立哈希表，是不是问题就解决了呢？接下来，我们试着操作一下。
我们将每个关键字当做 key，将包含了这个关键字的诗的列表当做存储的内容。这样，我们就建立了一个哈希表，根据关键字来查询这个哈希表，在 O(1) 的时间复杂度内，我们就能得到包含该关键字的文档列表。这种根据具体内容或者属性反过来索引文档标题的结构，就叫做倒排索引（Invert Index）。在倒排索引中，key 的集合叫做字典（Dictionary），一个 key 后面对应的记录集合叫做记录列表（Posting List）。

如何创建倒排索引？

前面我们介绍了倒排索引的概念，那创建一个倒排索引的过程究竟是怎么样的呢？我把这个过程总结成了以下步骤：

 给每个文档编号，作为其唯一标识，并且排好序，然后开始遍历文档（为什么要先排序，然后再遍历文档呢？你可以想一下，后面我们会解释）。
 解析当前文档中的每个关键字，生成 &lt;关键字, 文档ID, 关键字位置&gt; 这样的数据对象。为什么要记录关键字位置这个信息呢？因为在许多检索的场景中，都需要显示关键字前后的内容，比如，在组合查询时，我们要判断多个关键字之间是否足够接近。所以我们需要记录位置信息，以方便提取相应关键字的位置。
 每检测到一个关键字，就将关键字作为 key 插入哈希表，如果哈希表中已经有这个 key 了，我们就在对应的 posting list 后面追加节点，记录该文档 ID（关键字的位置信息如果需要，也可以一并记录在节点中）；如果哈希表中还没有这个 key，我们就直接插入该 key，并创建 posting list 和对应节点。
 重复第2步和第3步，处理完所有文档，完成倒排索引的创建。


如何查询同时含有“极”字和“客”字两个key的文档？

如果只是查询包含“极”或者“客”这样的单个字的文档，我们直接以查询的字作为 key 去倒排索引表中检索，得到的 posting list 就是结果了。但是，如果我们的目的是要查询同时包含“极”和“客”这两个字的文档，那我们该如何操作呢？
我们可以先分别用两个 key 去倒排索引中检索，这样会得到两个不同的 posting list：A 和 B。A 中的文档都包含了“极”字，B 中的文档都包含了“客”字。那么，如果一个文档既出现在 A 中，又出现在 B 中，它是不是就同时包含了这两个字呢？按照这个思路，我们只需查找出 A 和 B 的公共元素即可。
那么问题来了，我们该如何在 A 和 B 这两个链表中查找出公共元素呢？如果 A 和 B 都是无序链表，我们只能将 A 链表和 B 链表中的每个元素分别比对一次，这个时间复杂度时 O(m*n)。但是，如果两个链表是有序的，我们就可以用归并排序的方法来遍历 A 和 B 两个链表，时间复杂度会降低到 O(m+n)，其中 m 是链表 A 的长度，n 是链表 B 的长度。

  链表归并排序的步骤：

 使用指定 p1 和 p2 分别指向有序链表 A 和 B 的第一个元素。
对比 p1 和 p2 指向的节点是否相同，这时会出现三种情况：
  （1）两者的 id 相同，说明该节点为公共元素，直接将该节点加入归并结果。然后，p1 和 p2 要同时后移，指向下一个元素；
  （2）p1 元素的 id 小于 p2 元素的 id，p1 后移，指向 A 链表中的下一个元素；
  （3）p1 元素的 id 大于 p2 元素的 id，p2 后移，指向 B 链表中的下一个元素。


 重复第 2 步，直到 p1 或 p2 移动到链表尾为止。

  具体的操作步骤如下图所示：


那对于两个 key 的联合查询来说，除了有“同时存在”这样的场景以外，还有很多联合查询的实际例子。比如说，我们可以查询包含“极”或“客”的诗，也可以查询包含“极“且不包含”客”的诗。这些场景分别对应着交集、并集和差集等问题。具体的实现流程也和“同时存在”差不多，也是通过遍历链表对比的方式来完成的。
此外，在实际应用中，我们可能还需要对多个 key 进行联合查询，比如说，要查询同时包含“极“、”客“、”时“、”间” 四个字的诗，这个时候，我们利用多路归并的方法，同时遍历这四个关键字对应的 posting list 即可。实现过程如下图所示：

重点回顾

回顾上面讲的，你会发现，倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间复杂度内完成查询。
尽管倒排索引的原理并不复杂，但是倒排索引是很多搜索引擎的核心。比如说：数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。

06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？为什么需要磁盘数据检索技术？前面我们学习的那些检索相关的数据结构和技术，都是直接操作内存中的数据，但是有时候，系统要处理的数据量非常庞大，数据无法全部存储在内存中，这时我们就需要借助磁盘完成存储和检索。我们熟悉的关系型数据库，比如 MySQL 和 Oracle，就是这样的典型系统。
数据库中支持多种索引方式，比如：Hash索引、全文索引和B+树索引，其中B+树索引是使用最频繁的类型，下面我们就来聊一聊磁盘上的数据检索有什么特点，以及B+树索引为什么能对磁盘上的大规模数据进行高效索引。
磁盘和内存中数据的读写效率有什么不同？首先，我们来研究一下，存储在内存中和磁盘中的数据，在检索效率方面有什么不同。
内存是半导体元件。对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性，因此内存也叫随机访问存储器（Random Access Memory，即 RAM）。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。
而磁盘是机械硬件。磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取响应的数据。尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10~100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。为什么会这样呢？这就和磁盘的读写原理有关了。
磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 512 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 4K 个字节。操作系统会一次读写多个扇区，所以操作系统的最小读写单位是块（Block），也叫做簇（Cluster）。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
举个例子就是，在内存中读一个数据可能需要 0.01s，那么读 100 个数据就需要 1s。而在磁盘中，读一个数据需要 1s，假设这 100 个数据分布在不同的块中，那么读 100 个数据就需要 100s；而如果这 100 个数据分布在一个块中，那么同样只需要 1s 。所以说，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
现在我们已经了解磁盘的特点了，那我们可以来看一下，如果使用之前学过的检索技术来检索磁盘中的数据，检索效率回是怎样的呢？
假设一个有序数据存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘读到内存中，然后在内存中进行二分查找。如果下一步要读的元素在其它块中，则需要再将相应块从磁盘读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。
由于磁盘相对于内存而言，访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：对磁盘的访问次数要尽可能的少！
那么问题来了，我们应该如何减少磁盘的访问次数呢？将索引和数据分离就是一种常见的设计思路。
如何将索引和数据分离？我们以查询用户信息为例。我们知道，一个系统中的用户信息非常多，除了有唯一标识的ID以外，还有名字、邮箱、手机、兴趣爱好以及文章列表等各种信息。一个保存了所有用户信息的数组往往非常大，无法全部放在内存中，因此，我们会将它存储在磁盘中。

当我们以用户的ID进行检索时，这个检索过程其实并不是需要读取存储用户的具体信息。因此，我们可以生成一个只用于检索的有序索引数组。数组中的每个元素只存两个值，一个是用户ID，另一个是这个用户信息在磁盘上的位置，那么这个数组空间就会很小，也就可以放入内存中了。这种用有序数组做索引的方法，叫做线性索引（Linear Index）。

【有序数组的缺点：】在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。（数据频繁变化 -&gt; 写操作多 -&gt; 产生大量的新增&#x2F;删除&#x2F;修改操作 -&gt; 有序数组中元素的位置需要频繁变化）
【哈希表的缺点：】但是，哈希表由于缺乏范围检索的能力，在一些场合中也不适用。
【只剩下二叉检索树：】因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。那么，上图中的线性索引结构，就变成了下图这个样子。

【二叉检索树的缺点：】尽管二叉检索树可以解决数据动态修改的问题，但在索引数据很大的情况下，依然会存在数据无法全部加载到内存中的情况。这种情况下我们应该怎么办呢？
一个很自然的思路，就是将索引数据也存在磁盘中。那如果是树形索引，我们应该将哪些节点存入磁盘，又要如何从磁盘中读出这些数据进行检索呢？我们可以先自己想一想。然后再来看一下业界常用的解决方案 B+树是怎么做的。
如何理解B+树的数据结构？B+树是检索技术中非常重要的一个部分。这是为什么呢？因为B+树给出了树形索引的所有节点都存在磁盘上的高效检索方案，使得索引技术摆脱了内存空间的限制，得到了广泛的应用。
前面我们讲了，操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树形索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。B+树的一个关键设计就是，让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。
B+树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。尽管内部节点和叶子节点的数据结构是一样的，但存储的内容是不同的。
内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。通过这样的设计，B+树就能做到节点的空间利用率最大化。

此外，B+树还将同一层的所有节点串成了有序的双向链表，这样一来B+树就同时具备了良好的范围查询能力和灵活调整能力了。
因此，B+树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，就是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。

B+树是如何检索的？这样的结构，使得B+树可以作为一个完整的文件全部存储在磁盘中。当从根节点开始查询时，通过一次磁盘访问，我们就能将文件中的根节点这个数据块读出，然后在根节点的有序数组中进行二分查找。
具体的查找过程如下：

 我们先确认要查找的值，位于数组中哪两个相邻的元素之间，然后我们将第一个元素对应的指针读出，获得下一个block的位置。（该 block 保存了两个相邻元素间的所有数据的ID）
 读出下一个 block 的节点数据后，我们再对它做同样的处理。这样，B+树会逐层访问内部节点，直到读出叶子节点。对于叶子节点中的数组，直接使用二分查找算法，我们就可以判断查找的元素是否存在。如果存在，我们就可以得到该查询值对应的存储数据。如果这个数据是详细信息的指针，那我们还需要再访问磁盘一次，将详细信息读出。

我们前面说了，B+树是一棵完全平衡的 m 阶多叉树。所以，B+树的一个节点就能存储一个包含 m 个元素的数组，这样的话，一个只有 2~4 层的 B+ 树，就能索引数量级非常大的数据了，因此 B+ 树的层数往往很矮。比如说，一个 4K 的节点的内部可以存储 400 个元素，那么一个 4 层的 B+ 树最多能存储 400^4，也就是 256 亿个元素。（根节点存400个元素，第二层存 400*400 个元素，第三层存 400*400*400，第四层存 400*400*400*400 个元素，并且因为B+树只有叶子节点存储真实元素，所以说最多能存储 400^4 个元素）
不过，因为 B+ 树只有 4 层，这就意味着我们最多只需要读取 4 次就能到达叶子节点。并且，我们还可以通过将上面几层（非叶子节点层）的内部节点全部读取内存的方式，来降低磁盘读取的次数。
比如说，对于一个 4 层的 B+ 树，每个节点的大小是 4K，那么第一层根节点就是 4K，第二层最多有 400 个节点，一共就是 1.6M，第三层最多有 400^2 个节点，一共是 640M。对于现在常见的计算机来说，前三层的内部节点其实都可以存储在内存中，只有第四层的叶子节点才需要存储在磁盘中。这样一来，我们就只需要读取一次磁盘即可。这也是为什么，B+ 树要将内部节点和叶子节点区分开的原因。通过这种只让内部节点存储索引数据的设计，我们就可以更容易地把内部节点全部加载到内存中了。
B+树是如何动态调整的？现在，你已经知道 B+ 树的结构和原理了。那 B+ 树在“新增节点”和“删除节点”这样的动态变化场景中，又是怎样操作的呢？接下来，让我们一起来看一下。
首先，我们来看插入数据。由于具体的数据都是存储在叶子节点上的，因此，数据的插入也是从叶子节点开始的。以一个节点有 3 个元素的 B+ 树为例，如果我们要插入一个 ID&#x3D;6 的节点，首先要查询到对应的叶子节点，如果叶子节点的数组未满，那么就直接将该元素插入数组即可。具体过程如下图所示：

如果我们插入的是 ID&#x3D;10 的节点呢？按照之前的逻辑，我们应该插入到 ID9 后面，但是 ID9 所在的这个节点已经存满了 3 个节点，无法继续存入了。因此，我们需要将该叶子节点分裂。分裂的逻辑就是生成一个新的节点，并将数据在两个节点平分。

叶子节点分裂完成后，上一层的内部节点也需要修改。但如果上一层的父节点也是满的，那么上一层的父节点也需要分裂。

内部节点调整好了，下一步我们就要调整根节点了。由于根节点未满，因此我们不需要分裂，直接修改即可。

如果根节点满了，那我们就需要将根节点分裂，并生成新的根节点作为第一层。
删除数据也类似。如果节点数据较慢，直接删除，如果删除后数组有一般以上的空间为空，那为了提高节点的空间利用率，该节点需要将左右两边兄弟节点中的元素转移过来。可以成功转移的条件是，元素转移后该节点及其兄弟节点的空间必须都能维持在半满以上。如果无法满足这个条件，就说明兄弟节点其实也足够空闲，那我们直接将该节点的元素并入兄弟节点，然后删除该节点即可。
重点回顾通过这节内容，你会发现，即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销。
但是，B+ 树最大的优点在于，它提供了将索引数据存在磁盘中的高效检索方案。这让检索技术摆脱了内存的限制，得到了更广泛的使用。
另外，本节内容还有一个重要的设计思想就是：将索引和数据分离，通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在很多大规模系统中，都是使用这个设计思路来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一种实践。
</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#05-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BB%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%9F%A5%E5%87%BA%E5%90%8C%E6%97%B6%E5%B8%A6%E6%9C%89%E2%80%9C%E6%9E%81%E2%80%9C%E5%92%8C%E2%80%9D%E5%AE%A2%E2%80%9D%E7%9A%84%E5%94%90%E8%AF%97%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">05 | 倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">4.0.1.</span> <span class="nav-text">什么是倒排索引？

我们先来看看第一个问题：给出一首诗的题目，马上背出内容。这其实就是一个典型的键值查询场景。针对这个场景，我们可以给每首诗一个唯一的编号作为 ID，然后使用哈希表将诗的 ID 作为键（Key），把诗的内容作为键对应的值（Value）。这样，我们就能在 O(1) 的时间复杂度内，完成对指定 key 的检索。这样的以对象的唯一 ID 为 key 的哈希索引结构，叫做正排索引（Forward Index）。

一般来说，我们会遍历哈希表，遍历的时间复杂度是 O(n)。在遍历过程中，对于遇到的每一个元素对应着一首诗，如果我们想要判断这首诗中是否包含“极”字和“客”字，我们还需要遍历这首诗中的每一个字符。假设每首诗的平均长度是 k，那么遍历一首诗的时间代价就是 O(k)。所以，判断哪些诗中包含“极”字和“客”字的时间复杂度就是 O(n*k)。从分析中我们可以发现，这个检索过程全部都是遍历，因此时间复杂度非常高。对此，有什么优化方法吗？
我们首先来分析一下这两个场景。我们会发现，“根据题目查找内容”和“根据关键字查找题目”，这两个问题其实是完全相反的。既然完全相反，那我们能否“反着”建立一个哈希表来帮助我们查找呢？也就是说，如果我们以关键字作为 key 建立哈希表，是不是问题就解决了呢？接下来，我们试着操作一下。
我们将每个关键字当做 key，将包含了这个关键字的诗的列表当做存储的内容。这样，我们就建立了一个哈希表，根据关键字来查询这个哈希表，在 O(1) 的时间复杂度内，我们就能得到包含该关键字的文档列表。这种根据具体内容或者属性反过来索引文档标题的结构，就叫做倒排索引（Invert Index）。在倒排索引中，key 的集合叫做字典（Dictionary），一个 key 后面对应的记录集合叫做记录列表（Posting List）。

如何创建倒排索引？

前面我们介绍了倒排索引的概念，那创建一个倒排索引的过程究竟是怎么样的呢？我把这个过程总结成了以下步骤：

 给每个文档编号，作为其唯一标识，并且排好序，然后开始遍历文档（为什么要先排序，然后再遍历文档呢？你可以想一下，后面我们会解释）。
 解析当前文档中的每个关键字，生成 &lt;关键字, 文档ID, 关键字位置&gt; 这样的数据对象。为什么要记录关键字位置这个信息呢？因为在许多检索的场景中，都需要显示关键字前后的内容，比如，在组合查询时，我们要判断多个关键字之间是否足够接近。所以我们需要记录位置信息，以方便提取相应关键字的位置。
 每检测到一个关键字，就将关键字作为 key 插入哈希表，如果哈希表中已经有这个 key 了，我们就在对应的 posting list 后面追加节点，记录该文档 ID（关键字的位置信息如果需要，也可以一并记录在节点中）；如果哈希表中还没有这个 key，我们就直接插入该 key，并创建 posting list 和对应节点。
 重复第2步和第3步，处理完所有文档，完成倒排索引的创建。


如何查询同时含有“极”字和“客”字两个key的文档？

如果只是查询包含“极”或者“客”这样的单个字的文档，我们直接以查询的字作为 key 去倒排索引表中检索，得到的 posting list 就是结果了。但是，如果我们的目的是要查询同时包含“极”和“客”这两个字的文档，那我们该如何操作呢？
我们可以先分别用两个 key 去倒排索引中检索，这样会得到两个不同的 posting list：A 和 B。A 中的文档都包含了“极”字，B 中的文档都包含了“客”字。那么，如果一个文档既出现在 A 中，又出现在 B 中，它是不是就同时包含了这两个字呢？按照这个思路，我们只需查找出 A 和 B 的公共元素即可。
那么问题来了，我们该如何在 A 和 B 这两个链表中查找出公共元素呢？如果 A 和 B 都是无序链表，我们只能将 A 链表和 B 链表中的每个元素分别比对一次，这个时间复杂度时 O(m*n)。但是，如果两个链表是有序的，我们就可以用归并排序的方法来遍历 A 和 B 两个链表，时间复杂度会降低到 O(m+n)，其中 m 是链表 A 的长度，n 是链表 B 的长度。

  链表归并排序的步骤：

 使用指定 p1 和 p2 分别指向有序链表 A 和 B 的第一个元素。
对比 p1 和 p2 指向的节点是否相同，这时会出现三种情况：
  （1）两者的 id 相同，说明该节点为公共元素，直接将该节点加入归并结果。然后，p1 和 p2 要同时后移，指向下一个元素；
  （2）p1 元素的 id 小于 p2 元素的 id，p1 后移，指向 A 链表中的下一个元素；
  （3）p1 元素的 id 大于 p2 元素的 id，p2 后移，指向 B 链表中的下一个元素。


 重复第 2 步，直到 p1 或 p2 移动到链表尾为止。

  具体的操作步骤如下图所示：


那对于两个 key 的联合查询来说，除了有“同时存在”这样的场景以外，还有很多联合查询的实际例子。比如说，我们可以查询包含“极”或“客”的诗，也可以查询包含“极“且不包含”客”的诗。这些场景分别对应着交集、并集和差集等问题。具体的实现流程也和“同时存在”差不多，也是通过遍历链表对比的方式来完成的。
此外，在实际应用中，我们可能还需要对多个 key 进行联合查询，比如说，要查询同时包含“极“、”客“、”时“、”间” 四个字的诗，这个时候，我们利用多路归并的方法，同时遍历这四个关键字对应的 posting list 即可。实现过程如下图所示：

重点回顾

回顾上面讲的，你会发现，倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间复杂度内完成查询。
尽管倒排索引的原理并不复杂，但是倒排索引是很多搜索引擎的核心。比如说：数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。

06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？为什么需要磁盘数据检索技术？前面我们学习的那些检索相关的数据结构和技术，都是直接操作内存中的数据，但是有时候，系统要处理的数据量非常庞大，数据无法全部存储在内存中，这时我们就需要借助磁盘完成存储和检索。我们熟悉的关系型数据库，比如 MySQL 和 Oracle，就是这样的典型系统。
数据库中支持多种索引方式，比如：Hash索引、全文索引和B+树索引，其中B+树索引是使用最频繁的类型，下面我们就来聊一聊磁盘上的数据检索有什么特点，以及B+树索引为什么能对磁盘上的大规模数据进行高效索引。
磁盘和内存中数据的读写效率有什么不同？首先，我们来研究一下，存储在内存中和磁盘中的数据，在检索效率方面有什么不同。
内存是半导体元件。对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性，因此内存也叫随机访问存储器（Random Access Memory，即 RAM）。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。
而磁盘是机械硬件。磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取响应的数据。尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10~100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。为什么会这样呢？这就和磁盘的读写原理有关了。
磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 512 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 4K 个字节。操作系统会一次读写多个扇区，所以操作系统的最小读写单位是块（Block），也叫做簇（Cluster）。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
举个例子就是，在内存中读一个数据可能需要 0.01s，那么读 100 个数据就需要 1s。而在磁盘中，读一个数据需要 1s，假设这 100 个数据分布在不同的块中，那么读 100 个数据就需要 100s；而如果这 100 个数据分布在一个块中，那么同样只需要 1s 。所以说，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
现在我们已经了解磁盘的特点了，那我们可以来看一下，如果使用之前学过的检索技术来检索磁盘中的数据，检索效率回是怎样的呢？
假设一个有序数据存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘读到内存中，然后在内存中进行二分查找。如果下一步要读的元素在其它块中，则需要再将相应块从磁盘读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。
由于磁盘相对于内存而言，访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：对磁盘的访问次数要尽可能的少！
那么问题来了，我们应该如何减少磁盘的访问次数呢？将索引和数据分离就是一种常见的设计思路。
如何将索引和数据分离？我们以查询用户信息为例。我们知道，一个系统中的用户信息非常多，除了有唯一标识的ID以外，还有名字、邮箱、手机、兴趣爱好以及文章列表等各种信息。一个保存了所有用户信息的数组往往非常大，无法全部放在内存中，因此，我们会将它存储在磁盘中。

当我们以用户的ID进行检索时，这个检索过程其实并不是需要读取存储用户的具体信息。因此，我们可以生成一个只用于检索的有序索引数组。数组中的每个元素只存两个值，一个是用户ID，另一个是这个用户信息在磁盘上的位置，那么这个数组空间就会很小，也就可以放入内存中了。这种用有序数组做索引的方法，叫做线性索引（Linear Index）。

【有序数组的缺点：】在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。（数据频繁变化 -&gt; 写操作多 -&gt; 产生大量的新增&#x2F;删除&#x2F;修改操作 -&gt; 有序数组中元素的位置需要频繁变化）
【哈希表的缺点：】但是，哈希表由于缺乏范围检索的能力，在一些场合中也不适用。
【只剩下二叉检索树：】因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。那么，上图中的线性索引结构，就变成了下图这个样子。

【二叉检索树的缺点：】尽管二叉检索树可以解决数据动态修改的问题，但在索引数据很大的情况下，依然会存在数据无法全部加载到内存中的情况。这种情况下我们应该怎么办呢？
一个很自然的思路，就是将索引数据也存在磁盘中。那如果是树形索引，我们应该将哪些节点存入磁盘，又要如何从磁盘中读出这些数据进行检索呢？我们可以先自己想一想。然后再来看一下业界常用的解决方案 B+树是怎么做的。
如何理解B+树的数据结构？B+树是检索技术中非常重要的一个部分。这是为什么呢？因为B+树给出了树形索引的所有节点都存在磁盘上的高效检索方案，使得索引技术摆脱了内存空间的限制，得到了广泛的应用。
前面我们讲了，操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树形索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。B+树的一个关键设计就是，让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。
B+树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。尽管内部节点和叶子节点的数据结构是一样的，但存储的内容是不同的。
内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。通过这样的设计，B+树就能做到节点的空间利用率最大化。

此外，B+树还将同一层的所有节点串成了有序的双向链表，这样一来B+树就同时具备了良好的范围查询能力和灵活调整能力了。
因此，B+树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，就是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。

B+树是如何检索的？这样的结构，使得B+树可以作为一个完整的文件全部存储在磁盘中。当从根节点开始查询时，通过一次磁盘访问，我们就能将文件中的根节点这个数据块读出，然后在根节点的有序数组中进行二分查找。
具体的查找过程如下：

 我们先确认要查找的值，位于数组中哪两个相邻的元素之间，然后我们将第一个元素对应的指针读出，获得下一个block的位置。（该 block 保存了两个相邻元素间的所有数据的ID）
 读出下一个 block 的节点数据后，我们再对它做同样的处理。这样，B+树会逐层访问内部节点，直到读出叶子节点。对于叶子节点中的数组，直接使用二分查找算法，我们就可以判断查找的元素是否存在。如果存在，我们就可以得到该查询值对应的存储数据。如果这个数据是详细信息的指针，那我们还需要再访问磁盘一次，将详细信息读出。

我们前面说了，B+树是一棵完全平衡的 m 阶多叉树。所以，B+树的一个节点就能存储一个包含 m 个元素的数组，这样的话，一个只有 2~4 层的 B+ 树，就能索引数量级非常大的数据了，因此 B+ 树的层数往往很矮。比如说，一个 4K 的节点的内部可以存储 400 个元素，那么一个 4 层的 B+ 树最多能存储 400^4，也就是 256 亿个元素。（根节点存400个元素，第二层存 400*400 个元素，第三层存 400*400*400，第四层存 400*400*400*400 个元素，并且因为B+树只有叶子节点存储真实元素，所以说最多能存储 400^4 个元素）
不过，因为 B+ 树只有 4 层，这就意味着我们最多只需要读取 4 次就能到达叶子节点。并且，我们还可以通过将上面几层（非叶子节点层）的内部节点全部读取内存的方式，来降低磁盘读取的次数。
比如说，对于一个 4 层的 B+ 树，每个节点的大小是 4K，那么第一层根节点就是 4K，第二层最多有 400 个节点，一共就是 1.6M，第三层最多有 400^2 个节点，一共是 640M。对于现在常见的计算机来说，前三层的内部节点其实都可以存储在内存中，只有第四层的叶子节点才需要存储在磁盘中。这样一来，我们就只需要读取一次磁盘即可。这也是为什么，B+ 树要将内部节点和叶子节点区分开的原因。通过这种只让内部节点存储索引数据的设计，我们就可以更容易地把内部节点全部加载到内存中了。
B+树是如何动态调整的？现在，你已经知道 B+ 树的结构和原理了。那 B+ 树在“新增节点”和“删除节点”这样的动态变化场景中，又是怎样操作的呢？接下来，让我们一起来看一下。
首先，我们来看插入数据。由于具体的数据都是存储在叶子节点上的，因此，数据的插入也是从叶子节点开始的。以一个节点有 3 个元素的 B+ 树为例，如果我们要插入一个 ID&#x3D;6 的节点，首先要查询到对应的叶子节点，如果叶子节点的数组未满，那么就直接将该元素插入数组即可。具体过程如下图所示：

如果我们插入的是 ID&#x3D;10 的节点呢？按照之前的逻辑，我们应该插入到 ID9 后面，但是 ID9 所在的这个节点已经存满了 3 个节点，无法继续存入了。因此，我们需要将该叶子节点分裂。分裂的逻辑就是生成一个新的节点，并将数据在两个节点平分。

叶子节点分裂完成后，上一层的内部节点也需要修改。但如果上一层的父节点也是满的，那么上一层的父节点也需要分裂。

内部节点调整好了，下一步我们就要调整根节点了。由于根节点未满，因此我们不需要分裂，直接修改即可。

如果根节点满了，那我们就需要将根节点分裂，并生成新的根节点作为第一层。
删除数据也类似。如果节点数据较慢，直接删除，如果删除后数组有一般以上的空间为空，那为了提高节点的空间利用率，该节点需要将左右两边兄弟节点中的元素转移过来。可以成功转移的条件是，元素转移后该节点及其兄弟节点的空间必须都能维持在半满以上。如果无法满足这个条件，就说明兄弟节点其实也足够空闲，那我们直接将该节点的元素并入兄弟节点，然后删除该节点即可。
重点回顾通过这节内容，你会发现，即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销。
但是，B+ 树最大的优点在于，它提供了将索引数据存在磁盘中的高效检索方案。这让检索技术摆脱了内存的限制，得到了更广泛的使用。
另外，本节内容还有一个重要的设计思想就是：将索引和数据分离，通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在很多大规模系统中，都是使用这个设计思路来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一种实践。
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">4.0.2.</span> <span class="nav-text">如何创建倒排索引？

前面我们介绍了倒排索引的概念，那创建一个倒排索引的过程究竟是怎么样的呢？我把这个过程总结成了以下步骤：

 给每个文档编号，作为其唯一标识，并且排好序，然后开始遍历文档（为什么要先排序，然后再遍历文档呢？你可以想一下，后面我们会解释）。
 解析当前文档中的每个关键字，生成 &lt;关键字, 文档ID, 关键字位置&gt; 这样的数据对象。为什么要记录关键字位置这个信息呢？因为在许多检索的场景中，都需要显示关键字前后的内容，比如，在组合查询时，我们要判断多个关键字之间是否足够接近。所以我们需要记录位置信息，以方便提取相应关键字的位置。
 每检测到一个关键字，就将关键字作为 key 插入哈希表，如果哈希表中已经有这个 key 了，我们就在对应的 posting list 后面追加节点，记录该文档 ID（关键字的位置信息如果需要，也可以一并记录在节点中）；如果哈希表中还没有这个 key，我们就直接插入该 key，并创建 posting list 和对应节点。
 重复第2步和第3步，处理完所有文档，完成倒排索引的创建。


如何查询同时含有“极”字和“客”字两个key的文档？

如果只是查询包含“极”或者“客”这样的单个字的文档，我们直接以查询的字作为 key 去倒排索引表中检索，得到的 posting list 就是结果了。但是，如果我们的目的是要查询同时包含“极”和“客”这两个字的文档，那我们该如何操作呢？
我们可以先分别用两个 key 去倒排索引中检索，这样会得到两个不同的 posting list：A 和 B。A 中的文档都包含了“极”字，B 中的文档都包含了“客”字。那么，如果一个文档既出现在 A 中，又出现在 B 中，它是不是就同时包含了这两个字呢？按照这个思路，我们只需查找出 A 和 B 的公共元素即可。
那么问题来了，我们该如何在 A 和 B 这两个链表中查找出公共元素呢？如果 A 和 B 都是无序链表，我们只能将 A 链表和 B 链表中的每个元素分别比对一次，这个时间复杂度时 O(m*n)。但是，如果两个链表是有序的，我们就可以用归并排序的方法来遍历 A 和 B 两个链表，时间复杂度会降低到 O(m+n)，其中 m 是链表 A 的长度，n 是链表 B 的长度。

  链表归并排序的步骤：

 使用指定 p1 和 p2 分别指向有序链表 A 和 B 的第一个元素。
对比 p1 和 p2 指向的节点是否相同，这时会出现三种情况：
  （1）两者的 id 相同，说明该节点为公共元素，直接将该节点加入归并结果。然后，p1 和 p2 要同时后移，指向下一个元素；
  （2）p1 元素的 id 小于 p2 元素的 id，p1 后移，指向 A 链表中的下一个元素；
  （3）p1 元素的 id 大于 p2 元素的 id，p2 后移，指向 B 链表中的下一个元素。


 重复第 2 步，直到 p1 或 p2 移动到链表尾为止。

  具体的操作步骤如下图所示：


那对于两个 key 的联合查询来说，除了有“同时存在”这样的场景以外，还有很多联合查询的实际例子。比如说，我们可以查询包含“极”或“客”的诗，也可以查询包含“极“且不包含”客”的诗。这些场景分别对应着交集、并集和差集等问题。具体的实现流程也和“同时存在”差不多，也是通过遍历链表对比的方式来完成的。
此外，在实际应用中，我们可能还需要对多个 key 进行联合查询，比如说，要查询同时包含“极“、”客“、”时“、”间” 四个字的诗，这个时候，我们利用多路归并的方法，同时遍历这四个关键字对应的 posting list 即可。实现过程如下图所示：

重点回顾

回顾上面讲的，你会发现，倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间复杂度内完成查询。
尽管倒排索引的原理并不复杂，但是倒排索引是很多搜索引擎的核心。比如说：数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。

06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？为什么需要磁盘数据检索技术？前面我们学习的那些检索相关的数据结构和技术，都是直接操作内存中的数据，但是有时候，系统要处理的数据量非常庞大，数据无法全部存储在内存中，这时我们就需要借助磁盘完成存储和检索。我们熟悉的关系型数据库，比如 MySQL 和 Oracle，就是这样的典型系统。
数据库中支持多种索引方式，比如：Hash索引、全文索引和B+树索引，其中B+树索引是使用最频繁的类型，下面我们就来聊一聊磁盘上的数据检索有什么特点，以及B+树索引为什么能对磁盘上的大规模数据进行高效索引。
磁盘和内存中数据的读写效率有什么不同？首先，我们来研究一下，存储在内存中和磁盘中的数据，在检索效率方面有什么不同。
内存是半导体元件。对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性，因此内存也叫随机访问存储器（Random Access Memory，即 RAM）。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。
而磁盘是机械硬件。磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取响应的数据。尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10~100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。为什么会这样呢？这就和磁盘的读写原理有关了。
磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 512 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 4K 个字节。操作系统会一次读写多个扇区，所以操作系统的最小读写单位是块（Block），也叫做簇（Cluster）。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
举个例子就是，在内存中读一个数据可能需要 0.01s，那么读 100 个数据就需要 1s。而在磁盘中，读一个数据需要 1s，假设这 100 个数据分布在不同的块中，那么读 100 个数据就需要 100s；而如果这 100 个数据分布在一个块中，那么同样只需要 1s 。所以说，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
现在我们已经了解磁盘的特点了，那我们可以来看一下，如果使用之前学过的检索技术来检索磁盘中的数据，检索效率回是怎样的呢？
假设一个有序数据存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘读到内存中，然后在内存中进行二分查找。如果下一步要读的元素在其它块中，则需要再将相应块从磁盘读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。
由于磁盘相对于内存而言，访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：对磁盘的访问次数要尽可能的少！
那么问题来了，我们应该如何减少磁盘的访问次数呢？将索引和数据分离就是一种常见的设计思路。
如何将索引和数据分离？我们以查询用户信息为例。我们知道，一个系统中的用户信息非常多，除了有唯一标识的ID以外，还有名字、邮箱、手机、兴趣爱好以及文章列表等各种信息。一个保存了所有用户信息的数组往往非常大，无法全部放在内存中，因此，我们会将它存储在磁盘中。

当我们以用户的ID进行检索时，这个检索过程其实并不是需要读取存储用户的具体信息。因此，我们可以生成一个只用于检索的有序索引数组。数组中的每个元素只存两个值，一个是用户ID，另一个是这个用户信息在磁盘上的位置，那么这个数组空间就会很小，也就可以放入内存中了。这种用有序数组做索引的方法，叫做线性索引（Linear Index）。

【有序数组的缺点：】在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。（数据频繁变化 -&gt; 写操作多 -&gt; 产生大量的新增&#x2F;删除&#x2F;修改操作 -&gt; 有序数组中元素的位置需要频繁变化）
【哈希表的缺点：】但是，哈希表由于缺乏范围检索的能力，在一些场合中也不适用。
【只剩下二叉检索树：】因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。那么，上图中的线性索引结构，就变成了下图这个样子。

【二叉检索树的缺点：】尽管二叉检索树可以解决数据动态修改的问题，但在索引数据很大的情况下，依然会存在数据无法全部加载到内存中的情况。这种情况下我们应该怎么办呢？
一个很自然的思路，就是将索引数据也存在磁盘中。那如果是树形索引，我们应该将哪些节点存入磁盘，又要如何从磁盘中读出这些数据进行检索呢？我们可以先自己想一想。然后再来看一下业界常用的解决方案 B+树是怎么做的。
如何理解B+树的数据结构？B+树是检索技术中非常重要的一个部分。这是为什么呢？因为B+树给出了树形索引的所有节点都存在磁盘上的高效检索方案，使得索引技术摆脱了内存空间的限制，得到了广泛的应用。
前面我们讲了，操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树形索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。B+树的一个关键设计就是，让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。
B+树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。尽管内部节点和叶子节点的数据结构是一样的，但存储的内容是不同的。
内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。通过这样的设计，B+树就能做到节点的空间利用率最大化。

此外，B+树还将同一层的所有节点串成了有序的双向链表，这样一来B+树就同时具备了良好的范围查询能力和灵活调整能力了。
因此，B+树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，就是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。

B+树是如何检索的？这样的结构，使得B+树可以作为一个完整的文件全部存储在磁盘中。当从根节点开始查询时，通过一次磁盘访问，我们就能将文件中的根节点这个数据块读出，然后在根节点的有序数组中进行二分查找。
具体的查找过程如下：

 我们先确认要查找的值，位于数组中哪两个相邻的元素之间，然后我们将第一个元素对应的指针读出，获得下一个block的位置。（该 block 保存了两个相邻元素间的所有数据的ID）
 读出下一个 block 的节点数据后，我们再对它做同样的处理。这样，B+树会逐层访问内部节点，直到读出叶子节点。对于叶子节点中的数组，直接使用二分查找算法，我们就可以判断查找的元素是否存在。如果存在，我们就可以得到该查询值对应的存储数据。如果这个数据是详细信息的指针，那我们还需要再访问磁盘一次，将详细信息读出。

我们前面说了，B+树是一棵完全平衡的 m 阶多叉树。所以，B+树的一个节点就能存储一个包含 m 个元素的数组，这样的话，一个只有 2~4 层的 B+ 树，就能索引数量级非常大的数据了，因此 B+ 树的层数往往很矮。比如说，一个 4K 的节点的内部可以存储 400 个元素，那么一个 4 层的 B+ 树最多能存储 400^4，也就是 256 亿个元素。（根节点存400个元素，第二层存 400*400 个元素，第三层存 400*400*400，第四层存 400*400*400*400 个元素，并且因为B+树只有叶子节点存储真实元素，所以说最多能存储 400^4 个元素）
不过，因为 B+ 树只有 4 层，这就意味着我们最多只需要读取 4 次就能到达叶子节点。并且，我们还可以通过将上面几层（非叶子节点层）的内部节点全部读取内存的方式，来降低磁盘读取的次数。
比如说，对于一个 4 层的 B+ 树，每个节点的大小是 4K，那么第一层根节点就是 4K，第二层最多有 400 个节点，一共就是 1.6M，第三层最多有 400^2 个节点，一共是 640M。对于现在常见的计算机来说，前三层的内部节点其实都可以存储在内存中，只有第四层的叶子节点才需要存储在磁盘中。这样一来，我们就只需要读取一次磁盘即可。这也是为什么，B+ 树要将内部节点和叶子节点区分开的原因。通过这种只让内部节点存储索引数据的设计，我们就可以更容易地把内部节点全部加载到内存中了。
B+树是如何动态调整的？现在，你已经知道 B+ 树的结构和原理了。那 B+ 树在“新增节点”和“删除节点”这样的动态变化场景中，又是怎样操作的呢？接下来，让我们一起来看一下。
首先，我们来看插入数据。由于具体的数据都是存储在叶子节点上的，因此，数据的插入也是从叶子节点开始的。以一个节点有 3 个元素的 B+ 树为例，如果我们要插入一个 ID&#x3D;6 的节点，首先要查询到对应的叶子节点，如果叶子节点的数组未满，那么就直接将该元素插入数组即可。具体过程如下图所示：

如果我们插入的是 ID&#x3D;10 的节点呢？按照之前的逻辑，我们应该插入到 ID9 后面，但是 ID9 所在的这个节点已经存满了 3 个节点，无法继续存入了。因此，我们需要将该叶子节点分裂。分裂的逻辑就是生成一个新的节点，并将数据在两个节点平分。

叶子节点分裂完成后，上一层的内部节点也需要修改。但如果上一层的父节点也是满的，那么上一层的父节点也需要分裂。

内部节点调整好了，下一步我们就要调整根节点了。由于根节点未满，因此我们不需要分裂，直接修改即可。

如果根节点满了，那我们就需要将根节点分裂，并生成新的根节点作为第一层。
删除数据也类似。如果节点数据较慢，直接删除，如果删除后数组有一般以上的空间为空，那为了提高节点的空间利用率，该节点需要将左右两边兄弟节点中的元素转移过来。可以成功转移的条件是，元素转移后该节点及其兄弟节点的空间必须都能维持在半满以上。如果无法满足这个条件，就说明兄弟节点其实也足够空闲，那我们直接将该节点的元素并入兄弟节点，然后删除该节点即可。
重点回顾通过这节内容，你会发现，即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销。
但是，B+ 树最大的优点在于，它提供了将索引数据存在磁盘中的高效检索方案。这让检索技术摆脱了内存的限制，得到了更广泛的使用。
另外，本节内容还有一个重要的设计思想就是：将索引和数据分离，通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在很多大规模系统中，都是使用这个设计思路来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一种实践。
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">4.0.3.</span> <span class="nav-text">如何查询同时含有“极”字和“客”字两个key的文档？

如果只是查询包含“极”或者“客”这样的单个字的文档，我们直接以查询的字作为 key 去倒排索引表中检索，得到的 posting list 就是结果了。但是，如果我们的目的是要查询同时包含“极”和“客”这两个字的文档，那我们该如何操作呢？
我们可以先分别用两个 key 去倒排索引中检索，这样会得到两个不同的 posting list：A 和 B。A 中的文档都包含了“极”字，B 中的文档都包含了“客”字。那么，如果一个文档既出现在 A 中，又出现在 B 中，它是不是就同时包含了这两个字呢？按照这个思路，我们只需查找出 A 和 B 的公共元素即可。
那么问题来了，我们该如何在 A 和 B 这两个链表中查找出公共元素呢？如果 A 和 B 都是无序链表，我们只能将 A 链表和 B 链表中的每个元素分别比对一次，这个时间复杂度时 O(m*n)。但是，如果两个链表是有序的，我们就可以用归并排序的方法来遍历 A 和 B 两个链表，时间复杂度会降低到 O(m+n)，其中 m 是链表 A 的长度，n 是链表 B 的长度。

  链表归并排序的步骤：

 使用指定 p1 和 p2 分别指向有序链表 A 和 B 的第一个元素。
对比 p1 和 p2 指向的节点是否相同，这时会出现三种情况：
  （1）两者的 id 相同，说明该节点为公共元素，直接将该节点加入归并结果。然后，p1 和 p2 要同时后移，指向下一个元素；
  （2）p1 元素的 id 小于 p2 元素的 id，p1 后移，指向 A 链表中的下一个元素；
  （3）p1 元素的 id 大于 p2 元素的 id，p2 后移，指向 B 链表中的下一个元素。


 重复第 2 步，直到 p1 或 p2 移动到链表尾为止。

  具体的操作步骤如下图所示：


那对于两个 key 的联合查询来说，除了有“同时存在”这样的场景以外，还有很多联合查询的实际例子。比如说，我们可以查询包含“极”或“客”的诗，也可以查询包含“极“且不包含”客”的诗。这些场景分别对应着交集、并集和差集等问题。具体的实现流程也和“同时存在”差不多，也是通过遍历链表对比的方式来完成的。
此外，在实际应用中，我们可能还需要对多个 key 进行联合查询，比如说，要查询同时包含“极“、”客“、”时“、”间” 四个字的诗，这个时候，我们利用多路归并的方法，同时遍历这四个关键字对应的 posting list 即可。实现过程如下图所示：

重点回顾

回顾上面讲的，你会发现，倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间复杂度内完成查询。
尽管倒排索引的原理并不复杂，但是倒排索引是很多搜索引擎的核心。比如说：数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。

06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？为什么需要磁盘数据检索技术？前面我们学习的那些检索相关的数据结构和技术，都是直接操作内存中的数据，但是有时候，系统要处理的数据量非常庞大，数据无法全部存储在内存中，这时我们就需要借助磁盘完成存储和检索。我们熟悉的关系型数据库，比如 MySQL 和 Oracle，就是这样的典型系统。
数据库中支持多种索引方式，比如：Hash索引、全文索引和B+树索引，其中B+树索引是使用最频繁的类型，下面我们就来聊一聊磁盘上的数据检索有什么特点，以及B+树索引为什么能对磁盘上的大规模数据进行高效索引。
磁盘和内存中数据的读写效率有什么不同？首先，我们来研究一下，存储在内存中和磁盘中的数据，在检索效率方面有什么不同。
内存是半导体元件。对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性，因此内存也叫随机访问存储器（Random Access Memory，即 RAM）。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。
而磁盘是机械硬件。磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取响应的数据。尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10~100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。为什么会这样呢？这就和磁盘的读写原理有关了。
磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 512 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 4K 个字节。操作系统会一次读写多个扇区，所以操作系统的最小读写单位是块（Block），也叫做簇（Cluster）。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
举个例子就是，在内存中读一个数据可能需要 0.01s，那么读 100 个数据就需要 1s。而在磁盘中，读一个数据需要 1s，假设这 100 个数据分布在不同的块中，那么读 100 个数据就需要 100s；而如果这 100 个数据分布在一个块中，那么同样只需要 1s 。所以说，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
现在我们已经了解磁盘的特点了，那我们可以来看一下，如果使用之前学过的检索技术来检索磁盘中的数据，检索效率回是怎样的呢？
假设一个有序数据存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘读到内存中，然后在内存中进行二分查找。如果下一步要读的元素在其它块中，则需要再将相应块从磁盘读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。
由于磁盘相对于内存而言，访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：对磁盘的访问次数要尽可能的少！
那么问题来了，我们应该如何减少磁盘的访问次数呢？将索引和数据分离就是一种常见的设计思路。
如何将索引和数据分离？我们以查询用户信息为例。我们知道，一个系统中的用户信息非常多，除了有唯一标识的ID以外，还有名字、邮箱、手机、兴趣爱好以及文章列表等各种信息。一个保存了所有用户信息的数组往往非常大，无法全部放在内存中，因此，我们会将它存储在磁盘中。

当我们以用户的ID进行检索时，这个检索过程其实并不是需要读取存储用户的具体信息。因此，我们可以生成一个只用于检索的有序索引数组。数组中的每个元素只存两个值，一个是用户ID，另一个是这个用户信息在磁盘上的位置，那么这个数组空间就会很小，也就可以放入内存中了。这种用有序数组做索引的方法，叫做线性索引（Linear Index）。

【有序数组的缺点：】在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。（数据频繁变化 -&gt; 写操作多 -&gt; 产生大量的新增&#x2F;删除&#x2F;修改操作 -&gt; 有序数组中元素的位置需要频繁变化）
【哈希表的缺点：】但是，哈希表由于缺乏范围检索的能力，在一些场合中也不适用。
【只剩下二叉检索树：】因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。那么，上图中的线性索引结构，就变成了下图这个样子。

【二叉检索树的缺点：】尽管二叉检索树可以解决数据动态修改的问题，但在索引数据很大的情况下，依然会存在数据无法全部加载到内存中的情况。这种情况下我们应该怎么办呢？
一个很自然的思路，就是将索引数据也存在磁盘中。那如果是树形索引，我们应该将哪些节点存入磁盘，又要如何从磁盘中读出这些数据进行检索呢？我们可以先自己想一想。然后再来看一下业界常用的解决方案 B+树是怎么做的。
如何理解B+树的数据结构？B+树是检索技术中非常重要的一个部分。这是为什么呢？因为B+树给出了树形索引的所有节点都存在磁盘上的高效检索方案，使得索引技术摆脱了内存空间的限制，得到了广泛的应用。
前面我们讲了，操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树形索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。B+树的一个关键设计就是，让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。
B+树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。尽管内部节点和叶子节点的数据结构是一样的，但存储的内容是不同的。
内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。通过这样的设计，B+树就能做到节点的空间利用率最大化。

此外，B+树还将同一层的所有节点串成了有序的双向链表，这样一来B+树就同时具备了良好的范围查询能力和灵活调整能力了。
因此，B+树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，就是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。

B+树是如何检索的？这样的结构，使得B+树可以作为一个完整的文件全部存储在磁盘中。当从根节点开始查询时，通过一次磁盘访问，我们就能将文件中的根节点这个数据块读出，然后在根节点的有序数组中进行二分查找。
具体的查找过程如下：

 我们先确认要查找的值，位于数组中哪两个相邻的元素之间，然后我们将第一个元素对应的指针读出，获得下一个block的位置。（该 block 保存了两个相邻元素间的所有数据的ID）
 读出下一个 block 的节点数据后，我们再对它做同样的处理。这样，B+树会逐层访问内部节点，直到读出叶子节点。对于叶子节点中的数组，直接使用二分查找算法，我们就可以判断查找的元素是否存在。如果存在，我们就可以得到该查询值对应的存储数据。如果这个数据是详细信息的指针，那我们还需要再访问磁盘一次，将详细信息读出。

我们前面说了，B+树是一棵完全平衡的 m 阶多叉树。所以，B+树的一个节点就能存储一个包含 m 个元素的数组，这样的话，一个只有 2~4 层的 B+ 树，就能索引数量级非常大的数据了，因此 B+ 树的层数往往很矮。比如说，一个 4K 的节点的内部可以存储 400 个元素，那么一个 4 层的 B+ 树最多能存储 400^4，也就是 256 亿个元素。（根节点存400个元素，第二层存 400*400 个元素，第三层存 400*400*400，第四层存 400*400*400*400 个元素，并且因为B+树只有叶子节点存储真实元素，所以说最多能存储 400^4 个元素）
不过，因为 B+ 树只有 4 层，这就意味着我们最多只需要读取 4 次就能到达叶子节点。并且，我们还可以通过将上面几层（非叶子节点层）的内部节点全部读取内存的方式，来降低磁盘读取的次数。
比如说，对于一个 4 层的 B+ 树，每个节点的大小是 4K，那么第一层根节点就是 4K，第二层最多有 400 个节点，一共就是 1.6M，第三层最多有 400^2 个节点，一共是 640M。对于现在常见的计算机来说，前三层的内部节点其实都可以存储在内存中，只有第四层的叶子节点才需要存储在磁盘中。这样一来，我们就只需要读取一次磁盘即可。这也是为什么，B+ 树要将内部节点和叶子节点区分开的原因。通过这种只让内部节点存储索引数据的设计，我们就可以更容易地把内部节点全部加载到内存中了。
B+树是如何动态调整的？现在，你已经知道 B+ 树的结构和原理了。那 B+ 树在“新增节点”和“删除节点”这样的动态变化场景中，又是怎样操作的呢？接下来，让我们一起来看一下。
首先，我们来看插入数据。由于具体的数据都是存储在叶子节点上的，因此，数据的插入也是从叶子节点开始的。以一个节点有 3 个元素的 B+ 树为例，如果我们要插入一个 ID&#x3D;6 的节点，首先要查询到对应的叶子节点，如果叶子节点的数组未满，那么就直接将该元素插入数组即可。具体过程如下图所示：

如果我们插入的是 ID&#x3D;10 的节点呢？按照之前的逻辑，我们应该插入到 ID9 后面，但是 ID9 所在的这个节点已经存满了 3 个节点，无法继续存入了。因此，我们需要将该叶子节点分裂。分裂的逻辑就是生成一个新的节点，并将数据在两个节点平分。

叶子节点分裂完成后，上一层的内部节点也需要修改。但如果上一层的父节点也是满的，那么上一层的父节点也需要分裂。

内部节点调整好了，下一步我们就要调整根节点了。由于根节点未满，因此我们不需要分裂，直接修改即可。

如果根节点满了，那我们就需要将根节点分裂，并生成新的根节点作为第一层。
删除数据也类似。如果节点数据较慢，直接删除，如果删除后数组有一般以上的空间为空，那为了提高节点的空间利用率，该节点需要将左右两边兄弟节点中的元素转移过来。可以成功转移的条件是，元素转移后该节点及其兄弟节点的空间必须都能维持在半满以上。如果无法满足这个条件，就说明兄弟节点其实也足够空闲，那我们直接将该节点的元素并入兄弟节点，然后删除该节点即可。
重点回顾通过这节内容，你会发现，即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销。
但是，B+ 树最大的优点在于，它提供了将索引数据存在磁盘中的高效检索方案。这让检索技术摆脱了内存的限制，得到了更广泛的使用。
另外，本节内容还有一个重要的设计思想就是：将索引和数据分离，通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在很多大规模系统中，都是使用这个设计思路来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一种实践。
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">4.0.4.</span> <span class="nav-text">重点回顾

回顾上面讲的，你会发现，倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间复杂度内完成查询。
尽管倒排索引的原理并不复杂，但是倒排索引是很多搜索引擎的核心。比如说：数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。

06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？为什么需要磁盘数据检索技术？前面我们学习的那些检索相关的数据结构和技术，都是直接操作内存中的数据，但是有时候，系统要处理的数据量非常庞大，数据无法全部存储在内存中，这时我们就需要借助磁盘完成存储和检索。我们熟悉的关系型数据库，比如 MySQL 和 Oracle，就是这样的典型系统。
数据库中支持多种索引方式，比如：Hash索引、全文索引和B+树索引，其中B+树索引是使用最频繁的类型，下面我们就来聊一聊磁盘上的数据检索有什么特点，以及B+树索引为什么能对磁盘上的大规模数据进行高效索引。
磁盘和内存中数据的读写效率有什么不同？首先，我们来研究一下，存储在内存中和磁盘中的数据，在检索效率方面有什么不同。
内存是半导体元件。对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性，因此内存也叫随机访问存储器（Random Access Memory，即 RAM）。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。
而磁盘是机械硬件。磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取响应的数据。尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10~100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。为什么会这样呢？这就和磁盘的读写原理有关了。
磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 512 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 4K 个字节。操作系统会一次读写多个扇区，所以操作系统的最小读写单位是块（Block），也叫做簇（Cluster）。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
举个例子就是，在内存中读一个数据可能需要 0.01s，那么读 100 个数据就需要 1s。而在磁盘中，读一个数据需要 1s，假设这 100 个数据分布在不同的块中，那么读 100 个数据就需要 100s；而如果这 100 个数据分布在一个块中，那么同样只需要 1s 。所以说，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。
现在我们已经了解磁盘的特点了，那我们可以来看一下，如果使用之前学过的检索技术来检索磁盘中的数据，检索效率回是怎样的呢？
假设一个有序数据存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘读到内存中，然后在内存中进行二分查找。如果下一步要读的元素在其它块中，则需要再将相应块从磁盘读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。
由于磁盘相对于内存而言，访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：对磁盘的访问次数要尽可能的少！
那么问题来了，我们应该如何减少磁盘的访问次数呢？将索引和数据分离就是一种常见的设计思路。
如何将索引和数据分离？我们以查询用户信息为例。我们知道，一个系统中的用户信息非常多，除了有唯一标识的ID以外，还有名字、邮箱、手机、兴趣爱好以及文章列表等各种信息。一个保存了所有用户信息的数组往往非常大，无法全部放在内存中，因此，我们会将它存储在磁盘中。

当我们以用户的ID进行检索时，这个检索过程其实并不是需要读取存储用户的具体信息。因此，我们可以生成一个只用于检索的有序索引数组。数组中的每个元素只存两个值，一个是用户ID，另一个是这个用户信息在磁盘上的位置，那么这个数组空间就会很小，也就可以放入内存中了。这种用有序数组做索引的方法，叫做线性索引（Linear Index）。

【有序数组的缺点：】在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。（数据频繁变化 -&gt; 写操作多 -&gt; 产生大量的新增&#x2F;删除&#x2F;修改操作 -&gt; 有序数组中元素的位置需要频繁变化）
【哈希表的缺点：】但是，哈希表由于缺乏范围检索的能力，在一些场合中也不适用。
【只剩下二叉检索树：】因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。那么，上图中的线性索引结构，就变成了下图这个样子。

【二叉检索树的缺点：】尽管二叉检索树可以解决数据动态修改的问题，但在索引数据很大的情况下，依然会存在数据无法全部加载到内存中的情况。这种情况下我们应该怎么办呢？
一个很自然的思路，就是将索引数据也存在磁盘中。那如果是树形索引，我们应该将哪些节点存入磁盘，又要如何从磁盘中读出这些数据进行检索呢？我们可以先自己想一想。然后再来看一下业界常用的解决方案 B+树是怎么做的。
如何理解B+树的数据结构？B+树是检索技术中非常重要的一个部分。这是为什么呢？因为B+树给出了树形索引的所有节点都存在磁盘上的高效检索方案，使得索引技术摆脱了内存空间的限制，得到了广泛的应用。
前面我们讲了，操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树形索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。B+树的一个关键设计就是，让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。
B+树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。尽管内部节点和叶子节点的数据结构是一样的，但存储的内容是不同的。
内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。通过这样的设计，B+树就能做到节点的空间利用率最大化。

此外，B+树还将同一层的所有节点串成了有序的双向链表，这样一来B+树就同时具备了良好的范围查询能力和灵活调整能力了。
因此，B+树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，就是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。

B+树是如何检索的？这样的结构，使得B+树可以作为一个完整的文件全部存储在磁盘中。当从根节点开始查询时，通过一次磁盘访问，我们就能将文件中的根节点这个数据块读出，然后在根节点的有序数组中进行二分查找。
具体的查找过程如下：

 我们先确认要查找的值，位于数组中哪两个相邻的元素之间，然后我们将第一个元素对应的指针读出，获得下一个block的位置。（该 block 保存了两个相邻元素间的所有数据的ID）
 读出下一个 block 的节点数据后，我们再对它做同样的处理。这样，B+树会逐层访问内部节点，直到读出叶子节点。对于叶子节点中的数组，直接使用二分查找算法，我们就可以判断查找的元素是否存在。如果存在，我们就可以得到该查询值对应的存储数据。如果这个数据是详细信息的指针，那我们还需要再访问磁盘一次，将详细信息读出。

我们前面说了，B+树是一棵完全平衡的 m 阶多叉树。所以，B+树的一个节点就能存储一个包含 m 个元素的数组，这样的话，一个只有 2~4 层的 B+ 树，就能索引数量级非常大的数据了，因此 B+ 树的层数往往很矮。比如说，一个 4K 的节点的内部可以存储 400 个元素，那么一个 4 层的 B+ 树最多能存储 400^4，也就是 256 亿个元素。（根节点存400个元素，第二层存 400*400 个元素，第三层存 400*400*400，第四层存 400*400*400*400 个元素，并且因为B+树只有叶子节点存储真实元素，所以说最多能存储 400^4 个元素）
不过，因为 B+ 树只有 4 层，这就意味着我们最多只需要读取 4 次就能到达叶子节点。并且，我们还可以通过将上面几层（非叶子节点层）的内部节点全部读取内存的方式，来降低磁盘读取的次数。
比如说，对于一个 4 层的 B+ 树，每个节点的大小是 4K，那么第一层根节点就是 4K，第二层最多有 400 个节点，一共就是 1.6M，第三层最多有 400^2 个节点，一共是 640M。对于现在常见的计算机来说，前三层的内部节点其实都可以存储在内存中，只有第四层的叶子节点才需要存储在磁盘中。这样一来，我们就只需要读取一次磁盘即可。这也是为什么，B+ 树要将内部节点和叶子节点区分开的原因。通过这种只让内部节点存储索引数据的设计，我们就可以更容易地把内部节点全部加载到内存中了。
B+树是如何动态调整的？现在，你已经知道 B+ 树的结构和原理了。那 B+ 树在“新增节点”和“删除节点”这样的动态变化场景中，又是怎样操作的呢？接下来，让我们一起来看一下。
首先，我们来看插入数据。由于具体的数据都是存储在叶子节点上的，因此，数据的插入也是从叶子节点开始的。以一个节点有 3 个元素的 B+ 树为例，如果我们要插入一个 ID&#x3D;6 的节点，首先要查询到对应的叶子节点，如果叶子节点的数组未满，那么就直接将该元素插入数组即可。具体过程如下图所示：

如果我们插入的是 ID&#x3D;10 的节点呢？按照之前的逻辑，我们应该插入到 ID9 后面，但是 ID9 所在的这个节点已经存满了 3 个节点，无法继续存入了。因此，我们需要将该叶子节点分裂。分裂的逻辑就是生成一个新的节点，并将数据在两个节点平分。

叶子节点分裂完成后，上一层的内部节点也需要修改。但如果上一层的父节点也是满的，那么上一层的父节点也需要分裂。

内部节点调整好了，下一步我们就要调整根节点了。由于根节点未满，因此我们不需要分裂，直接修改即可。

如果根节点满了，那我们就需要将根节点分裂，并生成新的根节点作为第一层。
删除数据也类似。如果节点数据较慢，直接删除，如果删除后数组有一般以上的空间为空，那为了提高节点的空间利用率，该节点需要将左右两边兄弟节点中的元素转移过来。可以成功转移的条件是，元素转移后该节点及其兄弟节点的空间必须都能维持在半满以上。如果无法满足这个条件，就说明兄弟节点其实也足够空闲，那我们直接将该节点的元素并入兄弟节点，然后删除该节点即可。
重点回顾通过这节内容，你会发现，即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销。
但是，B+ 树最大的优点在于，它提供了将索引数据存在磁盘中的高效检索方案。这让检索技术摆脱了内存的限制，得到了更广泛的使用。
另外，本节内容还有一个重要的设计思想就是：将索引和数据分离，通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在很多大规模系统中，都是使用这个设计思路来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一种实践。
</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#06-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A3%80%E7%B4%A2%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8B-%E6%A0%91%E5%AF%B9%E6%B5%B7%E9%87%8F%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">为什么需要磁盘数据检索技术？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%92%8C%E5%86%85%E5%AD%98%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%88%E7%8E%87%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">磁盘和内存中数据的读写效率有什么不同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">如何将索引和数据分离？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3B-%E6%A0%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">5.4.</span> <span class="nav-text">如何理解B+树的数据结构？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E6%A3%80%E7%B4%A2%E7%9A%84%EF%BC%9F"><span class="nav-number">5.5.</span> <span class="nav-text">B+树是如何检索的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E7%9A%84%EF%BC%9F"><span class="nav-number">5.6.</span> <span class="nav-text">B+树是如何动态调整的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="nav-number">5.7.</span> <span class="nav-text">重点回顾</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="检索技术（Part1） | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          检索技术（Part1）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-21 19:16:27" itemprop="dateCreated datePublished" datetime="2022-03-21T19:16:27+08:00">2022-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-05 14:05:53" itemprop="dateModified" datetime="2022-04-05T14:05:53+08:00">2022-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">检索技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="01-线性结构检索：从数组和链表的原理初窥检索本质"><a href="#01-线性结构检索：从数组和链表的原理初窥检索本质" class="headerlink" title="01 | 线性结构检索：从数组和链表的原理初窥检索本质"></a>01 | 线性结构检索：从数组和链表的原理初窥检索本质</h1><blockquote>
<p>  <strong>学习目标</strong>：通过学习数组和链表这样的线性结构的检索过程，举一反三，深入理解检索的概念。</p>
</blockquote>
<p>【问题】首先，我们来思考一个问题：什么是检索？</p>
<p>从字面意义上来讲，<u>检索就是将我们所需要的信息，从存储数据的地方高效取出的一种技术。</u>通过对这句话的简单理解，我们可以大概猜想到：想要提高检索效率，那我们的关注点应该有两个：</p>
<ol>
<li> 存储数据的地方</li>
<li> 取出数据的方式</li>
</ol>
<p>实际上也是这样，数据不同的存储方式，会导致不同的检索效率。那么，到底什么样的数据存储方式检索快？什么样的数据存储方式检索慢呢？这其实并无一个标准的答案，因为并没有哪种数据存储方式的检索效率可以在所有使用场景下都具有优势，脱离实际的理论都是空谈，在不同的应用场景中我们要学会取舍，选择当前需求下最合适的存储方式来解决问题。</p>
<p>今天，我们首先从数组和链表的特点入手，先来看一下它们是如何进行检索的。</p>
<h2 id="数组和链表有哪些优点？"><a href="#数组和链表有哪些优点？" class="headerlink" title="数组和链表有哪些优点？"></a>数组和链表有哪些优点？</h2><p>相信有一定计算机基础的小伙伴儿对这个问题已不陌生了。数组就是用一块连续的内存来存储数据。那如果我申请不到连续的内存空间怎么办呢？这时候就可以派上用场了。链表可以申请不连续的空间，通过一个指针按顺序将这些空间串起来，形成一条链，链表也正是因此得名。不过，严格意义上来讲，这个叫做单链表。如果没有特别说明，下文我提到的链表，指的都是只有一个后续指针的单链表。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321193427186.png" alt="image-20220321193427186"></p>
<p>从图片中我们可以看出，<strong>数组和链表代表了连续空间和不连续空间最基础的存储方式，它们是线性表（Linked List）的典型代表。其它所有的数据结构，比如栈、队列、二叉树、B+树等，不外乎都是这两者的结合和变化。</strong>以栈为例，它本质就是一个限制了读写位置的数组，特点是只允许先进后出。</p>
<p>因此，<strong>我们只需要从最基础的数组和链表入手，结合实际应用中遇到的问题去思考解决方案，就能逐步学习和了解更过的数据结构和检索技术。</strong></p>
<p>那么，数组和链表这两种线性数据结构的检索效率究竟如何呢？我们来具体看一下。</p>
<h2 id="如何使用二分查找提升数组的检索效率？"><a href="#如何使用二分查找提升数组的检索效率？" class="headerlink" title="如何使用二分查找提升数组的检索效率？"></a>如何使用二分查找提升数组的检索效率？</h2><p>首先，如果是无序数组的话，不管是数组还是链表，想要查找一个指定元素是否存在，在缺乏数据分布信息的情况下，我们只能从头到尾遍历一遍，才能知道其是否存在。这样的检索效率就是 <code>O(n)</code>。当然，如果数据集不大的话，其实直接遍历速度也很快。但是如果数据集规模比较大的话，我们就需要考虑更高效的检索方式。</p>
<p>对于大规模的、可排序的数据集，我们往往是先将它通过排序算法转换为有序的数据集，如果数据不可排序，那我们可以先对其建立索引，通过对索引进行排序间接完成数据的有序存储。然后通过一些检索算法，比如二分查找法来完成高效的检索。</p>
<p>二分查找也叫折半查找，它的思路很直观，就是将有序数组二分为左右两个部分，通过只在半边进行查找来提升检索效率。下面是二分查找的的具体实现步骤：</p>
<blockquote>
<p>  我们会先从中间元素查起，这就会有三种查询结果。</p>
<ol>
<li>中间元素的值就是我们要查询的值。也就是说直接查到了，那直接返回即可。</li>
<li>如果中间元素的值小于我们想查询的值，因为数组是有序的，所以我们以中间元素为分隔，左半边的数组元素一定都小于中间元素，也就是小于我们想查询的值。因此，我们想查询的值只可能存在于右半边的数组中。对于右半边的数组，我们还是可以继续使用二分查找的思路，再从它的中间查起，重复上面的过程。这样不停地“二分”下去，每次的检索空间都能减少一半，整体的平均查询效率就是 O(log n)，远远小于遍历整个数组的代价 O(n)。</li>
<li>同理，如果中间元素的值大于我们想查询的值，那么我们就只在左边的数组元素查找即可。</li>
</ol>
</blockquote>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321195720343.png" alt="image-20220321195720343"></p>
<p>由此可见，合理地组织数据的存储可以提高检索效率。<strong>检索的核心思路，其实就是通过合理组织数据，尽可能地快速减少查询范围。</strong>我们见到的各种检索算法和技术，本质上都是通过灵活应用各种数据结构的特点来组织数据，从而达到快速减少查询范围的目的。</p>
<h2 id="链表在检索和动态调整上的优缺点"><a href="#链表在检索和动态调整上的优缺点" class="headerlink" title="链表在检索和动态调整上的优缺点"></a>链表在检索和动态调整上的优缺点</h2><p>前面我们说了，数据无序存储的话，数据和链表的检索效率都很低，都需要全盘扫描遍历。如果数据有序的话，采用数组存储数据可以通过二分查找大大提高检索效率。但你有没有发现一个问题，即便数据有序，链表好像也没法儿提高检索效率啊。</p>
<p>数组的“连续空间存储”带来了数据可随机访问的特点。在有序数组应用二分查找时，它能以 O(1) 的时间代价快速访问到位于中间的值，然后以中间点为分界线，只选择左边或右边继续查找，从而能快速缩小查询范围。</p>
<p>但是链表并不具备“随机访问”的特点。当链表想要访问中间的元素时，我们必须从链表头开始，沿着链一步一步遍历过去，才能访问到期望的数值。即如果想要访问链表中间的节点，我们就需要遍历一半的节点，时间代价已经是 O(n/2) 了。从这个方面来看，由于少了“随机访问”的特性，链表的检索能力是偏弱的。</p>
<p>但，凡事都有两面性，<strong>链表的检索能力偏弱，作为弥补，它在动态调整上会更容易</strong>。我们可以以 O(1) 的时间代价完成节点的插入和删除，这是“连续空间”的数组难以做到的。毕竟如果我们要在有序数组中插入一个元素，为了保证“数组有序”，我们就必须将数组中排在这个元素后面的元素，全部顺序后移一位，这其实是一个 O(n) 的时间代价了。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321201525392.png" alt="image-20220321201525392"></p>
<p>因此，<u>在一些需要频繁插入删除数据的场合，有序数组不见得是最合适的选择。另一方面，在数据量非常大的场合，我们也很难保证能申请到连续空间来构建有序数组。</u>因此，学会高效合理地使用链表，也是非常重要的。</p>
<h2 id="如何灵活改造链表提升检索效率？"><a href="#如何灵活改造链表提升检索效率？" class="headerlink" title="如何灵活改造链表提升检索效率？"></a>如何灵活改造链表提升检索效率？</h2><p><u><strong>本质上，我们学习链表，就是在学习“非连续存储空间”的组织方案。</strong>我们知道，对于“非连续空间”，可以用指针将它串联成一个整体。只要掌握了这个思想，我们就可以在不同的应用场景中，设计出适用的数据结构，而不需要拘泥于链表自身的结构限制。</u></p>
<p>我们可以来看一个简单的例子。</p>
<p>比如说，如果我们觉得链表一个节点一个节点地遍历太慢，那么我们是不是可以对其进行简单改造，让链表的每个节点不再只是存储一个元素，而是存储一个小的数组。这样我们就能大幅减少节点的数量，从而减少依次遍历节点带来的“低寻址效率”。</p>
<p>如下图所示，我的链表里就只有两个节点，每个节点都存储了一个小的有序数组。这样在检索的时候，我可以用二分查找的思想，先查询第一个节点存储的数组中的末尾元素，看看是否是我们想要的数字。如果不是，我们要么在第一个节点的数组中继续二分查找，要么在第二个节点的数组中继续二分查找。这样的结构就能同时兼顾数组和链表的特点了，而且时间代价也是 O(log n)。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321202554930.png" alt="image-20220321202554930"></p>
<p>可见，尽管常规的链表只能遍历检索，但是只要我们掌握了“非连续存储空间可以灵活调整”的特性，就可以设计更高效的数据结构和检索算法了。</p>
<hr>
<h1 id="02-非线性结构检索：数据频繁变化的情况下，如何高效检索？"><a href="#02-非线性结构检索：数据频繁变化的情况下，如何高效检索？" class="headerlink" title="02 | 非线性结构检索：数据频繁变化的情况下，如何高效检索？"></a>02 | 非线性结构检索：数据频繁变化的情况下，如何高效检索？</h1><p>当我们在电脑中查文件的时候，我们一般习惯先打开相应的磁盘，再打开文件夹及子文件夹，最后找到我们需要的文件。这其实就是一个检索路径。如果把所有的文件展开，这个查找路径其实是一种树状结构，即是一种非线性结构，而不是一个所有文件平铺排列的线性结构。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/1859310bd112d5479eac9c097db8b946.jpeg" alt="img"></p>
<p>我们都知道，<u>有层次的文件组织肯定比散乱平铺的文件更容易找到。这样一个熟悉的场景，是否是能给我们一个启发：对于零散的数据，非线性的树状结构是否可以帮助我们提高检索效率呢？</u></p>
<p>另一方面，我们也知道，在数据频繁更新的场景中，连续存储的有序数组并不是最合适的存储方案。因为数组为了保持有序必须不停地重建和排序，系统的检索性能就会急剧下滑。但是，非连续存储的有序链表倒是具有高效插入新数据的能力。因此，我们能否结合上面的例子，使用非线性的树状结构来改造有序链表，让链表也具有二分查找的能力呢？并且，如果成功的话，还是一种适用于写多读少场景的二分查找能力。</p>
<h2 id="树结构是如何进行二分查找的？"><a href="#树结构是如何进行二分查找的？" class="headerlink" title="树结构是如何进行二分查找的？"></a>树结构是如何进行二分查找的？</h2><p>上一节我们说过，因为链表不具备“随机访问”的特点，所以二分查找无法生效。当链表想要访问中间的元素时，我们必须从链表头开始，沿着指针一步一步遍历，需要遍历一半的节点才能到达中间节点，时间代价是 O(n/2)。而有序数组由于可以“随机访问”，因此只需要 O(1) 的时间代价就可以访问到中间节点了。</p>
<p>那如果我们能在链表中以 O(1) 的时间代价快速访问到中间的节点，是不是就可以和有序数组一样使用二分查找了？</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/2c61d26ed919411dd9be1a94cefb30ca.jpg" alt="img"></p>
<p>既然我们希望能以 O(1) 的时间代价访问中间节点，那直接将这个节点记录下来是不是就可以了？因此，如果我们已经把中间节点 M 拎出来单独记录了，那我们的第一步操作就是直接访问这个中间节点，然后判断这个节点和要查找的元素是否相等。如果相等，则返回查询结果。如果节点元素大于要查找的元素，那我们就道左边的部分继续查找；反之，则到右边的部分继续查找。</p>
<p>对于左边或者右边的部分，我们可以将它们视为两个独立的子链表，依然沿用这个逻辑。如果想用 O(1) 的时间代价就能访问这两个子链表的中间节点，我们就应该把左边部分的中间节点 L 和右边部分的中间节点 R 单独拎出来记录。</p>
<p>并且，由于我们是在访问完了 M 节点后，才决定接下来该去访问左边的 L 还是右边的 R。所以，我们还需要将 M 和 L，M 和 R 连接起来。我们可以让 M 带有两个指针，一个左指针指向 L，一个右指针指向 R。这样，在访问 M 以后，一旦发现 M 不是我们要查找的节点，那么我们接下来就可以通过指针快速访问到 L 或者 R 了。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/d274bfacd98b00d82746cfeb838ec1f4.jpeg" alt="img"></p>
<p>对于其余的节点，我们也可以进行同样的处理。下面这个结构，你是不是很熟悉，没错，这就是我们常见的二叉树。你再来观察一下，这个二叉树和普通的二叉树有什么不一样？</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/bf8df69285c21e28b493bd2f7a0c1abb.jpeg" alt="img"></p>
<p>没错，这个二叉树是有序的。它的左子树的所有节点的值都小于根节点，同时右子树所有节点的值都大于等于根节点。这样的有序结构，使得它能使用二分查找法，快速地过滤掉一半的数据。具备了这样特点的树，就是<strong>二叉检索树（Binary Search Tree）</strong>，或叫<strong>二叉排序树（Binary Sorted Tree）</strong>。</p>
<p>现在我们就可以简单对比一下。<strong>尽管有序数组和二叉检索树，在数据形态上看起来差异很大，但是在提高检索效率上，它们的核心原理都是一样的。</strong>那么，它们是如何提高检索效率的呢？核心原理又一致在哪里呢？下面我们从两个方面总结一下：</p>
<ul>
<li>  将数据有序化，并且根据数据存储的特点进行不同的组织。对于连续存储空间的数组而言，由于它具有“随机访问”的特性，因此直接存储即可；对于非连续存储空间的有序链表而言，由于它不具备“随机访问”的特性，因此，需要将它改造成可以快速访问到中间节点的树形结构。</li>
<li>  在进行检索的时候，它们都是通过二分查找的思想从中间节点开始查起。如果不命中，会快速缩小一半的查询空间。这样不停迭代的查询方式，让检索的时间代价能达到 O(log n) 这个级别。</li>
</ul>
<p>当然，如果你有一定的数据结构基础，就应该知道，二叉检索树的时间复杂度并不一定永远是 O(log n)。</p>
<h2 id="二叉检索树的空间平衡方案"><a href="#二叉检索树的空间平衡方案" class="headerlink" title="二叉检索树的空间平衡方案"></a>二叉检索树的空间平衡方案</h2><br>

<br>

<br>

<hr>
<h1 id="04-状态检索：如何判断一个用户是否存在？"><a href="#04-状态检索：如何判断一个用户是否存在？" class="headerlink" title="04 | 状态检索：如何判断一个用户是否存在？"></a>04 | 状态检索：如何判断一个用户是否存在？</h1><p>在实际工作中，我们经常需要判断一个对象是否存在。比如说，在注册新用户的时候，我们需要先快速判断这个用户 ID 是否被注册过；再比如说，在爬虫系统抓取网页之前，我们要判断一个 URL 是否已经被抓取过，从而避免无谓的、重复的抓取工作。</p>
<p>那么，对于这一类是否存在的状态检索需求，如果直接使用前面讲过的检索技术，如有序数组、二叉检索树以及哈希表来实现的话，它们的检索性能如何？是否有优化的方案呢？今天，我们就一起来讨论一下这些问题。</p>
<h3>如何使用数据的随机访问特性提高查询效率？

<p>以新注册用户时查询用户 ID 是否存在为例，我们可以直接使用有序数组、二叉检索树或者哈希表来存储所有的用户 ID。</p>
<p>我们知道，无论是有序数组还是二叉检索树，它们都是使用二分查找的思想从中间元素开始查起的。所以，在查询用户 ID 是否存在时，它们的平均检索时间复杂度都是 O(log n)，而哈希表的平均检索时间复杂度是 O(1)。因此，如果我们希望能快速查询出元素是否存在，那哈希表无疑是最合适的选择。不过，如果从工程实现的角度来看的话，哈希表的查询过程还是可以继续优化的。</p>
<p>比如说，如果我们要查询的对象 ID 本身是正整数类型，且 ID 范围有上限的话。我们可以申请一个足够大的数组，让数组长度超过 ID 的上限。然后，把数组中所有位置的值都初始化为 0。对于存在的用户，我们<strong>直接将用户 ID 作为数组下标</strong>，将该位置对应的值从 0 设置为 1 就可以了。</p>
<hr>
<h1 id="05-倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？"><a href="#05-倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？" class="headerlink" title="05 | 倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？"></a>05 | 倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？</h1><blockquote>
<p>  <strong>提出问题：</strong></p>
</blockquote>
<p>试想这样一个场景：假设你已经熟读唐诗300首了。这个时候，如果我给你一首诗的题目，相信你一定可以很快背出这首诗的内容。但是如果我问你，有哪些诗中同时包含了“极”和“客”字？很显然，第二个问题的难度比第一个问题大得多。</p>
<p>那么从程序设计的角度来看，这两个问题对应的检索过程又有什么不同呢？这就对应了两种非常常见且重要的检索技术：**正排索引 **和 <strong>倒排索引</strong>。</p>
<h3>什么是倒排索引？

<p>我们先来看看第一个问题：给出一首诗的题目，马上背出内容。这其实就是一个典型的键值查询场景。针对这个场景，我们可以给每首诗一个唯一的编号作为 ID，然后使用哈希表将诗的 ID 作为键（Key），把诗的内容作为键对应的值（Value）。这样，我们就能在 O(1) 的时间复杂度内，完成对指定 key 的检索。这样的以对象的唯一 ID 为 key 的哈希索引结构，叫做<strong>正排索引（Forward Index）</strong>。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/4b5e88addf89120aba176671c53d25f1.jpeg" alt="img"></p>
<p>一般来说，我们会遍历哈希表，遍历的时间复杂度是 O(n)。在遍历过程中，对于遇到的每一个元素对应着一首诗，如果我们想要判断这首诗中是否包含“极”字和“客”字，我们还需要遍历这首诗中的每一个字符。假设每首诗的平均长度是 k，那么遍历一首诗的时间代价就是 O(k)。所以，判断哪些诗中包含“极”字和“客”字的时间复杂度就是 O(n*k)。从分析中我们可以发现，这个检索过程全部都是遍历，因此时间复杂度非常高。对此，有什么优化方法吗？</p>
<p>我们首先来分析一下这两个场景。我们会发现，“根据题目查找内容”和“根据关键字查找题目”，这两个问题其实是完全相反的。既然完全相反，那我们能否“反着”建立一个哈希表来帮助我们查找呢？也就是说，如果我们以关键字作为 key 建立哈希表，是不是问题就解决了呢？接下来，我们试着操作一下。</p>
<p>我们将每个关键字当做 key，将包含了这个关键字的诗的列表当做存储的内容。这样，我们就建立了一个哈希表，根据关键字来查询这个哈希表，在 O(1) 的时间复杂度内，我们就能得到包含该关键字的文档列表。这种根据具体内容或者属性反过来索引文档标题的结构，就叫做<strong>倒排索引（Invert Index）</strong>。在倒排索引中，key 的集合叫做<strong>字典（Dictionary）</strong>，一个 key 后面对应的记录集合叫做<strong>记录列表（Posting List）</strong>。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/8e602ab79d98380c8c258a30a1e2108b.jpg" alt="img"></p>
<h3>如何创建倒排索引？

<p>前面我们介绍了倒排索引的概念，那创建一个倒排索引的过程究竟是怎么样的呢？我把这个过程总结成了以下步骤：</p>
<ol>
<li> 给每个文档编号，作为其唯一标识，<u>并且排好序</u>，然后开始遍历文档（为什么要先排序，然后再遍历文档呢？你可以想一下，后面我们会解释）。</li>
<li> 解析当前文档中的每个关键字，生成 <code>&lt;关键字, 文档ID, 关键字位置&gt;</code> 这样的数据对象。为什么要记录关键字位置这个信息呢？因为在许多检索的场景中，都需要显示关键字前后的内容，比如，在组合查询时，我们要判断多个关键字之间是否足够接近。所以我们需要记录位置信息，以方便提取相应关键字的位置。</li>
<li> 每检测到一个关键字，就将关键字作为 key 插入哈希表，如果哈希表中已经有这个 key 了，我们就在对应的 posting list 后面追加节点，记录该文档 ID（关键字的位置信息如果需要，也可以一并记录在节点中）；如果哈希表中还没有这个 key，我们就直接插入该 key，并创建 posting list 和对应节点。</li>
<li> 重复第2步和第3步，处理完所有文档，完成倒排索引的创建。</li>
</ol>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/2ccc78df6ebbd4d716318d5113fa090d.jpg" alt="img"></p>
<h3>如何查询同时含有“极”字和“客”字两个key的文档？

<p>如果只是查询包含“极”或者“客”这样的单个字的文档，我们直接以查询的字作为 key 去倒排索引表中检索，得到的 posting list 就是结果了。但是，如果我们的目的是要查询同时包含“极”和“客”这两个字的文档，那我们该如何操作呢？</p>
<p>我们可以先分别用两个 key 去倒排索引中检索，这样会得到两个不同的 posting list：A 和 B。A 中的文档都包含了“极”字，B 中的文档都包含了“客”字。那么，如果一个文档既出现在 A 中，又出现在 B 中，它是不是就同时包含了这两个字呢？按照这个思路，我们只需查找出 A 和 B 的公共元素即可。</p>
<p>那么问题来了，<u>我们该如何在 A 和 B 这两个链表中查找出公共元素呢？</u>如果 A 和 B 都是无序链表，我们只能将 A 链表和 B 链表中的每个元素分别比对一次，这个时间复杂度时 O(m*n)。但是，如果两个链表是有序的，我们就可以用归并排序的方法来遍历 A 和 B 两个链表，时间复杂度会降低到 O(m+n)，其中 m 是链表 A 的长度，n 是链表 B 的长度。</p>
<blockquote>
<p>  链表归并排序的步骤：</p>
<ol>
<li> 使用指定 p1 和 p2 分别指向有序链表 A 和 B 的第一个元素。</li>
<li>对比 p1 和 p2 指向的节点是否相同，这时会出现三种情况：<ul>
<li>  （1）两者的 id 相同，说明该节点为公共元素，直接将该节点加入归并结果。然后，p1 和 p2 要同时后移，指向下一个元素；</li>
<li>  （2）p1 元素的 id 小于 p2 元素的 id，p1 后移，指向 A 链表中的下一个元素；</li>
<li>  （3）p1 元素的 id 大于 p2 元素的 id，p2 后移，指向 B 链表中的下一个元素。</li>
</ul>
</li>
<li> 重复第 2 步，直到 p1 或 p2 移动到链表尾为止。</li>
</ol>
<p>  具体的操作步骤如下图所示：</p>
</blockquote>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/a377f626bbfc1de2f98f199ed0ad585f.jpg" alt="img"></p>
<p>那对于<strong>两个 key</strong> 的联合查询来说，除了有“<strong>同时存在</strong>”这样的场景以外，还有很多联合查询的实际例子。比如说，我们可以查询包含“极”<strong>或</strong>“客”的诗，也可以查询包含“极“<strong>且不包含</strong>”客”的诗。这些场景分别对应着交集、并集和差集等问题。具体的实现流程也和“同时存在”差不多，也是通过遍历链表对比的方式来完成的。</p>
<p>此外，在实际应用中，我们可能还需要对<strong>多个 key</strong> 进行联合查询，比如说，要查询同时包含“极“、”客“、”时“、”间” 四个字的诗，这个时候，我们利用多路归并的方法，同时遍历这四个关键字对应的 posting list 即可。实现过程如下图所示：</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/c91ce2f3cff16b20b0cca52a57336b96.jpeg" alt="img"></p>
<h3>重点回顾

<p>回顾上面讲的，你会发现，<u>倒排索引的核心其实并不复杂，它的具体实现其实是哈希表</u>，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间复杂度内完成查询。</p>
<p>尽管倒排索引的原理并不复杂，但是倒排索引是很多搜索引擎的核心。比如说：数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。</p>
<hr>
<h1 id="06-数据库检索：如何使用B-树对海量磁盘数据建立索引？"><a href="#06-数据库检索：如何使用B-树对海量磁盘数据建立索引？" class="headerlink" title="06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？"></a>06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？</h1><h2 id="为什么需要磁盘数据检索技术？"><a href="#为什么需要磁盘数据检索技术？" class="headerlink" title="为什么需要磁盘数据检索技术？"></a>为什么需要磁盘数据检索技术？</h2><p>前面我们学习的那些检索相关的数据结构和技术，都是直接操作内存中的数据，但是有时候，系统要处理的数据量非常庞大，数据无法全部存储在内存中，这时我们就需要借助磁盘完成存储和检索。我们熟悉的关系型数据库，比如 MySQL 和 Oracle，就是这样的典型系统。</p>
<p>数据库中支持多种索引方式，比如：Hash索引、全文索引和B+树索引，其中B+树索引是使用最频繁的类型，下面我们就来聊一聊磁盘上的数据检索有什么特点，以及B+树索引为什么能对磁盘上的大规模数据进行高效索引。</p>
<h2 id="磁盘和内存中数据的读写效率有什么不同？"><a href="#磁盘和内存中数据的读写效率有什么不同？" class="headerlink" title="磁盘和内存中数据的读写效率有什么不同？"></a>磁盘和内存中数据的读写效率有什么不同？</h2><p>首先，我们来研究一下，存储在内存中和磁盘中的数据，在检索效率方面有什么不同。</p>
<p>内存是半导体元件。<u>对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性</u>，因此内存也叫<strong>随机访问存储器（Random Access Memory，即 RAM）</strong>。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。</p>
<p>而磁盘是机械硬件。<u>磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取响应的数据。</u>尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10~100 万倍左右的差距。<u>但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的</u>。为什么会这样呢？这就和磁盘的读写原理有关了。</p>
<p>磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 512 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 4K 个字节。操作系统会一次读写多个扇区，所以<u>操作系统的最小读写单位是<strong>块（Block）</strong>，也叫做<strong>簇（Cluster）</strong>。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来</u>。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。</p>
<p>举个例子就是，在内存中读一个数据可能需要 0.01s，那么读 100 个数据就需要 1s。而在磁盘中，读一个数据需要 1s，假设这 100 个数据分布在不同的块中，那么读 100 个数据就需要 100s；而如果这 100 个数据分布在一个块中，那么同样只需要 1s 。所以说，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。</p>
<p>现在我们已经了解磁盘的特点了，那我们可以来看一下，如果使用之前学过的检索技术来检索磁盘中的数据，检索效率回是怎样的呢？</p>
<p>假设一个有序数据存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘读到内存中，然后在内存中进行二分查找。如果下一步要读的元素在其它块中，则需要再将相应块从磁盘读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。</p>
<p>由于磁盘相对于内存而言，访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：<strong>对磁盘的访问次数要尽可能的少！</strong></p>
<p>那么问题来了，我们应该如何减少磁盘的访问次数呢？将索引和数据分离就是一种常见的设计思路。</p>
<h2 id="如何将索引和数据分离？"><a href="#如何将索引和数据分离？" class="headerlink" title="如何将索引和数据分离？"></a>如何将索引和数据分离？</h2><p>我们以查询用户信息为例。我们知道，一个系统中的用户信息非常多，除了有唯一标识的ID以外，还有名字、邮箱、手机、兴趣爱好以及文章列表等各种信息。一个保存了所有用户信息的数组往往非常大，无法全部放在内存中，因此，我们会将它存储在磁盘中。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/3ad283ed20ba36a8f5f8350ee4bd7d56.jpg" alt="img"></p>
<p>当我们以用户的ID进行检索时，这个检索过程其实并不是需要读取存储用户的具体信息。因此，我们可以生成一个只用于检索的有序索引数组。数组中的每个元素只存两个值，一个是用户ID，另一个是这个用户信息在磁盘上的位置，那么这个数组空间就会很小，也就可以放入内存中了。这种用有序数组做索引的方法，叫做<strong>线性索引</strong>（Linear Index）。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/0e7ca7c9a2c9c373353ae5ec824f4f1e.jpg" alt="img"></p>
<p>【有序数组的缺点：】在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。（数据频繁变化 -&gt; 写操作多 -&gt; 产生大量的新增/删除/修改操作 -&gt; 有序数组中元素的位置需要频繁变化）</p>
<p>【哈希表的缺点：】但是，哈希表由于缺乏范围检索的能力，在一些场合中也不适用。</p>
<p>【只剩下二叉检索树：】因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。那么，上图中的线性索引结构，就变成了下图这个样子。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/0203a7cc903e3acf38e47a59ad3aa6b4.jpeg" alt="img"></p>
<p>【二叉检索树的缺点：】尽管二叉检索树可以解决数据动态修改的问题，但<u>在索引数据很大的情况下，依然会存在数据无法全部加载到内存中的情况。</u>这种情况下我们应该怎么办呢？</p>
<p>一个很自然的思路，就是将索引数据也存在磁盘中。那如果是树形索引，我们应该将哪些节点存入磁盘，又要如何从磁盘中读出这些数据进行检索呢？我们可以先自己想一想。然后再来看一下业界常用的解决方案 B+树是怎么做的。</p>
<h2 id="如何理解B-树的数据结构？"><a href="#如何理解B-树的数据结构？" class="headerlink" title="如何理解B+树的数据结构？"></a>如何理解B+树的数据结构？</h2><p>B+树是检索技术中非常重要的一个部分。这是为什么呢？因为<strong>B+树给出了树形索引的所有节点都存在磁盘上的高效检索方案，</strong>使得索引技术摆脱了内存空间的限制，得到了广泛的应用。</p>
<p>前面我们讲了，操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树形索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。<strong>B+树的一个关键设计就是，让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。</strong>这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。</p>
<p>B+树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。尽管内部节点和叶子节点的数据结构是一样的，但存储的内容是不同的。</p>
<p><u>内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。</u>这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而<u>叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。</u>通过这样的设计，B+树就能做到节点的空间利用率最大化。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/a994e93f2fdd38291998cba8149270eb.jpg" alt="img"></p>
<p>此外，<u>B+树还将同一层的所有节点串成了有序的双向链表，这样一来B+树就同时具备了良好的范围查询能力和灵活调整能力了。</u></p>
<p>因此，B+树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，就是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/72499a6180cfb1ee7e3c33e6ca433b65.jpg" alt="img"></p>
<h2 id="B-树是如何检索的？"><a href="#B-树是如何检索的？" class="headerlink" title="B+树是如何检索的？"></a>B+树是如何检索的？</h2><p>这样的结构，使得B+树可以作为一个完整的文件全部存储在磁盘中。当从根节点开始查询时，通过一次磁盘访问，我们就能将文件中的根节点这个数据块读出，然后在根节点的有序数组中进行二分查找。</p>
<p>具体的查找过程如下：</p>
<ol>
<li> 我们先确认要查找的值，位于数组中哪两个相邻的元素之间，然后我们将第一个元素对应的指针读出，获得下一个block的位置。（该 block 保存了两个相邻元素间的所有数据的ID）</li>
<li> 读出下一个 block 的节点数据后，我们再对它做同样的处理。这样，B+树会逐层访问内部节点，直到读出叶子节点。对于叶子节点中的数组，直接使用二分查找算法，我们就可以判断查找的元素是否存在。如果存在，我们就可以得到该查询值对应的存储数据。如果这个数据是详细信息的指针，那我们还需要再访问磁盘一次，将详细信息读出。</li>
</ol>
<p>我们前面说了，B+树是一棵完全平衡的 m 阶多叉树。所以，B+树的一个节点就能存储一个包含 m 个元素的数组，这样的话，一个只有 2~4 层的 B+ 树，就能索引数量级非常大的数据了，因此 B+ 树的层数往往很矮。比如说，一个 4K 的节点的内部可以存储 400 个元素，那么一个 4 层的 B+ 树最多能存储 400^4，也就是 256 亿个元素。（根节点存400个元素，第二层存 <code>400*400</code> 个元素，第三层存 <code>400*400*400</code>，第四层存 <code>400*400*400*400</code> 个元素，并且因为B+树只有叶子节点存储真实元素，所以说最多能存储 400^4 个元素）</p>
<p>不过，因为 B+ 树只有 4 层，这就意味着我们最多只需要读取 4 次就能到达叶子节点。并且，我们还可以通过将上面几层（非叶子节点层）的内部节点全部读取内存的方式，来降低磁盘读取的次数。</p>
<p>比如说，对于一个 4 层的 B+ 树，每个节点的大小是 4K，那么第一层根节点就是 4K，第二层最多有 400 个节点，一共就是 1.6M，第三层最多有 400^2 个节点，一共是 640M。对于现在常见的计算机来说，前三层的内部节点其实都可以存储在内存中，只有第四层的叶子节点才需要存储在磁盘中。这样一来，我们就只需要读取一次磁盘即可。这也是为什么，B+ 树要将内部节点和叶子节点区分开的原因。通过这种只让内部节点存储索引数据的设计，我们就可以更容易地把内部节点全部加载到内存中了。</p>
<h2 id="B-树是如何动态调整的？"><a href="#B-树是如何动态调整的？" class="headerlink" title="B+树是如何动态调整的？"></a>B+树是如何动态调整的？</h2><p>现在，你已经知道 B+ 树的结构和原理了。那 B+ 树在“新增节点”和“删除节点”这样的动态变化场景中，又是怎样操作的呢？接下来，让我们一起来看一下。</p>
<p>首先，我们来看插入数据。由于具体的数据都是存储在叶子节点上的，因此，数据的插入也是从叶子节点开始的。以一个节点有 3 个元素的 B+ 树为例，如果我们要插入一个 ID=6 的节点，首先要查询到对应的叶子节点，如果叶子节点的数组未满，那么就直接将该元素插入数组即可。具体过程如下图所示：</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/9ed9028cab65e6530966faae00d0d3d4.jpg" alt="img"></p>
<p>如果我们插入的是 ID=10 的节点呢？按照之前的逻辑，我们应该插入到 ID9 后面，但是 ID9 所在的这个节点已经存满了 3 个节点，无法继续存入了。因此，我们需要将该叶子节点<strong>分裂</strong>。<u>分裂的逻辑就是生成一个新的节点，并将数据在两个节点平分。</u></p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/674115e7c61637e56791e001ea840af2.jpg" alt="img"></p>
<p>叶子节点分裂完成后，上一层的内部节点也需要修改。但如果上一层的父节点也是满的，那么上一层的父节点也需要分裂。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/03af63ed8cd065743bd8b2bd812e5057.jpg" alt="img"></p>
<p>内部节点调整好了，下一步我们就要调整根节点了。由于根节点未满，因此我们不需要分裂，直接修改即可。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/53fd14349369951706f53abd1eff560f.jpg" alt="img"></p>
<p>如果根节点满了，那我们就需要将根节点分裂，并生成新的根节点作为第一层。</p>
<p>删除数据也类似。如果节点数据较慢，直接删除，如果删除后数组有一般以上的空间为空，那为了提高节点的空间利用率，该节点需要将左右两边兄弟节点中的元素转移过来。可以成功转移的条件是，元素转移后该节点及其兄弟节点的空间必须都能维持在半满以上。如果无法满足这个条件，就说明兄弟节点其实也足够空闲，那我们直接将该节点的元素并入兄弟节点，然后删除该节点即可。</p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>通过这节内容，你会发现，即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 <u>B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销</u>。</p>
<p><u>但是，B+ 树最大的优点在于，它提供了将索引数据存在磁盘中的高效检索方案。这让检索技术摆脱了内存的限制，</u>得到了更广泛的使用。</p>
<p>另外，本节内容还有一个重要的设计思想就是：将索引和数据分离，通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在很多大规模系统中，都是使用这个设计思路来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一种实践。</p>
</h3></h3></h3></h3></h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/" rel="prev" title="设计模式之美（Part2）">
                  <i class="fa fa-chevron-left"></i> 设计模式之美（Part2）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/" rel="next" title="Vue组件化开发">
                  Vue组件化开发 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
