<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？想要具备编写高质量代码的能力，首先要学习一些编程方法论，主要包含：    面向对象（可以视为一种设计思想）  设计原则  设计模式  编程规范  重构技巧  …   这部分基础方法论的内容就相当于一个全局性大纲，你可以把学到的具体内容填充到这个大纲中，不断完善自己的知识结构体系。 面向对象目前主流的编程风格有三种，分别是：">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式之美（Part1）">
<meta property="og:url" content="http://example.com/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？想要具备编写高质量代码的能力，首先要学习一些编程方法论，主要包含：    面向对象（可以视为一种设计思想）  设计原则  设计模式  编程规范  重构技巧  …   这部分基础方法论的内容就相当于一个全局性大纲，你可以把学到的具体内容填充到这个大纲中，不断完善自己的知识结构体系。 面向对象目前主流的编程风格有三种，分别是：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/image-20220320110025182.png">
<meta property="article:published_time" content="2022-03-14T04:02:18.000Z">
<meta property="article:modified_time" content="2022-03-20T05:50:39.349Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/image-20220320110025182.png">


<link rel="canonical" href="http://example.com/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/","path":"2022/03/14/设计模式之美（Part1）/","title":"设计模式之美（Part1）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>设计模式之美（Part1） | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E3%80%81%E9%87%8D%E6%9E%84%EF%BC%8C%E8%BF%99%E4%BA%94%E8%80%85%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.2.</span> <span class="nav-text">设计原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83"><span class="nav-number">1.4.</span> <span class="nav-text">编程规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7"><span class="nav-number">1.5.</span> <span class="nav-text">重构技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">1.6.</span> <span class="nav-text">五者之间的联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.</span> <span class="nav-text">小总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-%E7%90%86%E8%AE%BA%E4%B8%80%EF%BC%9A%E5%BD%93%E8%B0%88%E8%AE%BA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%88%E8%AE%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">什么是面向对象编程和面向对象编程语言？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%9F%90%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%98%AF%E5%90%A6%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">如何判断某种编程语言是否是面向对象编程语言？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">什么是面向对象分析和面向对象设计？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#05-%E7%90%86%E8%AE%BA%E4%BA%8C%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E5%88%86%E5%88%AB%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%EF%BC%88Encapsulation%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">封装（Encapsulation）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">上面讲了封装的定义，那么封装的意义是什么呢？它又能解决什么编程问题？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%EF%BC%88Abstraction%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">抽象（Abstraction）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">上面讲了抽象的定义，那么抽象的意义是什么？它又能解决什么编程问题呢？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">继承（Inheritance）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.3.0.1.</span> <span class="nav-text">继承的定义讲完了，那么，继承存在的意义是什么？它又能解决什么编程问题呢？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%EF%BC%88Polymorphism%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">多态（Polymorphism）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.4.0.1.</span> <span class="nav-text">多态特性讲完了，那么多态存在的意义是什么？它能解决什么编程问题？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#06%EF%BC%8C07-%E7%90%86%E8%AE%BA%E4%B8%89%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9C%9F%E7%9A%84%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">06，07 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">什么是面向过程编程与面向过程编程语言？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9B%B8%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">面向对象编程相比面向过程编程有哪些优势？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">4.2.0.1.</span> <span class="nav-text">1、OOP更加能够应对大规模复杂程序的开发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">4.2.0.2.</span> <span class="nav-text">2、OOP风格的代码更易复用、易扩展、易维护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">4.2.0.3.</span> <span class="nav-text">3、OOP语言更加人性化、更加高级、更加智能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E7%9C%8B%E4%BC%BC%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E9%99%85%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E9%A3%8E%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">有哪些看似是面向对象实际是面向过程风格的代码？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">4.3.0.1.</span> <span class="nav-text">1、滥用 getter、setter 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">4.3.0.2.</span> <span class="nav-text">2、滥用全局变量和全局方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">4.3.0.3.</span> <span class="nav-text">3、定义数据和方法分离的类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E6%98%93%E5%86%99%E5%87%BA%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E9%A3%8E%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="nav-number">4.4.</span> <span class="nav-text">在面向对象编程中，为什么容易写出面向过程风格的代码？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9C%9F%E7%9A%84%E6%97%A0%E7%94%A8%E6%AD%A6%E4%B9%8B%E5%9C%B0%E4%BA%86%E5%90%97%EF%BC%9F"><span class="nav-number">4.5.</span> <span class="nav-text">面向过程编程和面向过程 编程语言真的无用武之地了吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#08-%E7%90%86%E8%AE%BA%E4%BA%94%EF%BC%9A%E6%8E%A5%E5%8F%A3-vs-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%A8%E6%99%AE%E9%80%9A%E7%9A%84%E7%B1%BB%E6%A8%A1%E6%8B%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%EF%BC%9F%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">什么是抽象类和接口？区别在哪里？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.1.0.1.</span> <span class="nav-text">Java中的抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.1.0.2.</span> <span class="nav-text">Java中的接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">抽象类和接口能解决什么问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.2.0.1.</span> <span class="nav-text">首先，我们来看一下，为什么需要抽象类？它能解决什么编程问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.2.0.2.</span> <span class="nav-text">其次，我们再来看一下，我们为什么要需要使用接口？它能解决什么编程问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.2.0.2.1.</span> <span class="nav-text">
    如何模拟抽象类和接口两个语法概念？
</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E8%AF%A5%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%BF%98%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">如何决定该用接口还是抽象类？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#09-%E7%90%86%E8%AE%BA%E5%85%AD%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B%EF%BC%9F%E6%9C%89%E5%BF%85%E8%A6%81%E4%B8%BA%E6%AF%8F%E4%B8%AA%E7%B1%BB%E9%83%BD%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8E%9F%E5%88%99%E4%B8%AD%E7%9A%84%E2%80%9C%E6%8E%A5%E5%8F%A3%E2%80%9D%E4%BA%8C%E5%AD%97%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">如何理解原则中的“接口”二字？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E8%BF%99%E6%9D%A1%E5%8E%9F%E5%88%99%E5%BA%94%E7%94%A8%E5%88%B0%E5%AE%9E%E6%88%98%E4%B8%AD%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">如何将这条原则应用到实战中？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E8%A6%81%E4%B8%BA%E6%AF%8F%E4%B8%AA%E7%B1%BB%E9%83%BD%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">6.3.</span> <span class="nav-text">是否要为每个类都定义接口？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-number">6.4.</span> <span class="nav-text">课后问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E7%90%86%E8%AE%BA%E4%B8%83%EF%BC%9A%E4%B8%BA%E5%92%8C%E8%AF%B4%E8%A6%81%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF%EF%BC%9F%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E8%AF%A5%E7%94%A8%E7%BB%84%E5%90%88%E8%BF%98%E6%98%AF%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">10 | 理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">为什么不推荐使用继承？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%9B%B8%E6%AF%94%E7%BB%A7%E6%89%BF%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">组合相比继承有哪些优势？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%AF%A5%E7%94%A8%E7%BB%84%E5%90%88%E8%BF%98%E6%98%AF%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="nav-number">7.3.</span> <span class="nav-text">如何判断该用组合还是继承？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="设计模式之美（Part1） | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式之美（Part1）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-14 12:02:18" itemprop="dateCreated datePublished" datetime="2022-03-14T12:02:18+08:00">2022-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-20 13:50:39" itemprop="dateModified" datetime="2022-03-20T13:50:39+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="03-面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"><a href="#03-面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？" class="headerlink" title="03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"></a>03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</h1><p>想要具备编写高质量代码的能力，首先要学习一些编程方法论，主要包含：</p>
<blockquote>
<ol>
<li> 面向对象（可以视为一种设计思想）</li>
<li> 设计原则</li>
<li> 设计模式</li>
<li> 编程规范</li>
<li> 重构技巧</li>
<li> …</li>
</ol>
</blockquote>
<p>这部分基础方法论的内容就相当于一个全局性大纲，你可以把学到的具体内容填充到这个大纲中，不断完善自己的知识结构体系。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>目前主流的编程风格有三种，分别是：</p>
<ol>
<li> 面向过程；</li>
<li> 面向对象；</li>
<li> 函数式编程。</li>
</ol>
<p>其中，面向对象编程又是其中最主流的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以较容易地实现很多复杂的设计思路，是很多设计原则，设计模式编码实现的基础。</p>
<p>在面向对象编程中，需要重点关注的知识点有以下7个：</p>
<ol>
<li> 面向对象的四大特性</li>
<li> 面向对象编程与面向过程编程的区别</li>
<li> 面向对象分析、面向对象设计、面向对象编程</li>
<li> 接口和抽象类的区别及各自应用的场景</li>
<li> 基于接口编程而非基于实现编程的思想</li>
<li> 多用组合少用继承的设计思想</li>
<li> 面向过程的贫血模型和面向对象的充血模型</li>
</ol>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计原则是指导我们代码设计的一些经验总结。这些原则听起来都非常抽象，定义描述比较模糊，不同的人会有不同的解读，所以，单纯的记忆定义意义不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活地应用这些原则。</p>
<p>一些常用的设计原则有：</p>
<ul>
<li>  SOLID原则——SRP单一职责原则</li>
<li>  SOLID原则——OCP开闭原则</li>
<li>  SOLID原则——LSP里氏替换原则</li>
<li>  SOLID原则——ISP接口隔离原则</li>
<li>  SOLID原则——DIP依赖倒置原则</li>
<li>  DRY原则</li>
<li>  KISS原则</li>
<li>  YAGNI原则</li>
<li>  LOD原则</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>​    设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或叫设计思路。大部分的设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，大部分都不难理解，代码实现也并不复杂。这部分的学习目标主要是：（1）了解它们都能解决哪些问题；（2）掌握典型的应用场景，并懂得不过度使用。</p>
<p>​    经典的设计模式共有23种，随着编程语言的演进，一些设计模式也随之过时，甚至成了反模式，一些则被内置在编程语言中（如Iterator），另外也有一些新的模式诞生。</p>
<p>​    这23中经典设计模式，又可分为三大类：（1）创建型、（2）行为型、（3）结构性。按照类型和是否常用，划分如下：</p>
<ol>
<li>创建型<ul>
<li>  常用：单例模式、工厂模式（工厂方法+抽象工厂）、建造者模式</li>
<li>  不常用：原型模式</li>
</ul>
</li>
<li>结构性<ul>
<li>  常用：代理模式、桥接模式、装饰者模式、适配器模式</li>
<li>  不常用：门面模式、组合模式、享元模式</li>
</ul>
</li>
<li>行为型<ul>
<li>  常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式</li>
<li>  不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式</li>
</ul>
</li>
</ol>
<h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><p>​    编程规范主要用于解决代码的可读性问题。相对于设计原则、设计模式，更加具体，更加偏重代码细节。</p>
<h2 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h2><p>​    在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必然会存在这样那样的问题。针对这些问题，代码重构是不可避免的。</p>
<p>​    而重构的工具就是前面罗列的哪些面向对象的设计思想、设计原则、设计模式、编码规范。</p>
<h2 id="五者之间的联系"><a href="#五者之间的联系" class="headerlink" title="五者之间的联系"></a>五者之间的联系</h2><p>​    面向对象编程因为其具有丰富的特性（封装、继承、抽象、多态），可以实现很多复杂的设计思路，因此是很多设计原则、设计模式等思路编程实现的基础。</p>
<p>​    实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这件事的。当我们看清这个本质后，很多选择怎么选就清楚了。比如，在某个场景下，该不该用这个设计模式，那就取决于能不能提高代码的可扩展性；要不要重构，那就取决于代码是否存在可读性，可维护性问题等。</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><hr>
<h1 id="04-理论一：当谈论面向对象的时候，我们到底在谈论什么？"><a href="#04-理论一：当谈论面向对象的时候，我们到底在谈论什么？" class="headerlink" title="04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？"></a>04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？</h1><h2 id="什么是面向对象编程和面向对象编程语言？"><a href="#什么是面向对象编程和面向对象编程语言？" class="headerlink" title="什么是面向对象编程和面向对象编程语言？"></a>什么是面向对象编程和面向对象编程语言？</h2><blockquote>
<p>  面向对象编程（OOP）：Object Oriented Programming</p>
<p>  面向对象编程语言（OOPL）：Object Oriented Programming Language</p>
</blockquote>
<p>​    面向对象编程有两个非常重要的概念，那就是类（class）和对象（object）。这两个概念最早出现在1960年，在Simula这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在Smalltalk这种编程语言中，Smalltalk被认为是第一个真正意义上的面向对象编程语言。</p>
<p>​    1980年左右，C++的出现，带动了面向对象编程的流行，也使得面向对象编程被越来越多的人认可。直到今天，如果不按照严格的定义来说，大部分的编程语言都是面向对象的编程语言，比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Scala、PHP、Perl 等。除此之外，大部分程序员在开发项目的时候，都是基于面向对象编程语言进行的面向对象编程。</p>
<p>​    以上是面向对象编程的大概发展历史，在上面的描述中，提到了两个相似的概念，“面向对象编程”和“面向对象编程语言”，那么究竟什么是面向对象编程，什么是面向对象编程语言呢？</p>
<ul>
<li>  面向对象编程是一种编程风格。它以类或对象作为组织代码的基本单元，并将封装、继承、抽象、多态四个特性，作为代码设计和实现的基石。</li>
<li>  面向对象编程语言是支持类或对象的语法机制，并提供了现成的语法机制，能方便地实现面向对象编程四大特性的编程语法。</li>
</ul>
<p>​    一般来讲，面向对象编程都是通过面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即使我们使用了面向对象编程语言，写出来的代码也不一定是面向对象编程风格的。</p>
<h2 id="如何判断某种编程语言是否是面向对象编程语言？"><a href="#如何判断某种编程语言是否是面向对象编程语言？" class="headerlink" title="如何判断某种编程语言是否是面向对象编程语言？"></a>如何判断某种编程语言是否是面向对象编程语言？</h2><p>​    在上一节中我提到了“如果不按照严格的定义来说，大部分的编程语言都是面向对象的编程语言”。但实际上，什么是“面向对象编程”，什么是“面向对象编程语言”并没有一个统一的官方定义，并且这两个概念从诞生到现在一直是变化的，无法给出一个明确的定义。当然也没有必要给出一个明确的定义。比如，按照上一节我给出的定义，JavaScript并不支持封装和继承特性，按照严格的定义，那么它就不算是一种面向对象编程语言，但是大多是时候我们都会把它看做一种面向对象编程语言。那么：到底如何判断一个编程语言是否是面向对象的编程语言呢？</p>
<p>​    实际上，面向对象编程从字面上，按照最简单的方式理解，就是将对象或类作为代码组织的基本单元来进行编程的一种编程风格，并不一定需要有封装、抽象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结发现，有了这四大特性后，我们就能更容易地实现各种面向对象的代码设计思路。</p>
<p>​    比如，我们在面向对象编程过程中，经常会遇到 is-a 这种类关系（比如狗是一种动物），而继承这个特性就能很好地支持这种 is-a 的代码设计思路，并解决代码复用的问题，所以，继承就成了面向对象编程的四大特性之一。但是，随着编程语言的不断迭代、演化，人们又发现继承这种特性容易造成层次不清、代码混乱，所以，很多编程语言在设计的时候就开始摒弃继承特性，比如 Go 语言。但是，我们不能因为它摒弃了继承特性，就一刀切地认为它不是面向对象的编程语言了。</p>
<p>​    实际上，我个人觉得，只要某种编程语言支持类或对象的语言概念，并以此作为组织代码的基本单元，那么就可以被粗略地认为是一种面向对象编程语言了。至于是否有现成的语法机制支持面向四大特性，是否对四大特性有所取舍和优化，可以不作为判断的标准。因为即使不直接支持四大特性，也可以手动通过编程手段复现出与四大特性类似的效果。基于此，我们才说“<strong>如果按照严格的定义，很多语言都不算是面向对象编程语言；但是不按照严格的定义来讲，现在流行的大多数语言都是面向对象编程语言</strong>。”</p>
<h2 id="什么是面向对象分析和面向对象设计？"><a href="#什么是面向对象分析和面向对象设计？" class="headerlink" title="什么是面向对象分析和面向对象设计？"></a>什么是面向对象分析和面向对象设计？</h2><p>​    前面我们讲了面向对象编程（OOP）和面向对象编程语言（OOPL），实际上跟OOP经常放到一块儿讲的还有另外两个概念：</p>
<blockquote>
<p>  面向对象分析（OOA）：Object Oriented Analysis</p>
<p>  面向对象设计（OOD）：Object Oriented Design</p>
</blockquote>
<p>OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、实现（编程），正好是面向对象软件开发要经历的三个阶段。</p>
<p>​    面向对象分析与设计中的“分析”与“设计”可简单类比与软件开发中的需求分析与系统设计。那么为什么要在前面加一个修饰词“面向对象”呢？</p>
<p>​    之所以在前面加“面向对象”这几个字，是因为我们是围绕着“对象或类”来进行需求分析和设计的。分析和设计两个阶段最终的产出就是类的设计，包括程序被拆解为哪些类，每个类有哪些属性、方法，类与类之间如何交互等。它比需求分析更贴近编码，更容易过渡到面向对象编程环节。</p>
<p>​    那么，面向对象分析、设计、编程到底负责哪些工作呢？简单来讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的结果翻译成代码的过程。</p>
<hr>
<h1 id="05-理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"><a href="#05-理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？" class="headerlink" title="05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"></a>05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？</h1><p>​    理解面向对象编程和面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。</p>
<h2 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h2><p>​    封装可以看做是一种信息隐藏，一种数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的函数来访问内部数据。</p>
<p>​    下面这段代码是金融系统中一个简化版的虚拟钱包代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录我们在系统中的虚拟货币数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/14 21:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> balanceLastModifiedTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wallet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = IdGenerator.getInstance().generate();</span><br><span class="line">        <span class="built_in">this</span>.createTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.balance = BigDecimal.ZERO;</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBalanceLastModifiedTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balanceLastModifiedTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 充值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> increaseAmount 充值金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseBalance</span><span class="params">(BigDecimal increaseAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (increaseAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;充值金额不能小于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.add(increaseAmount);</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> decreaseAmount 消费金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseBalance</span><span class="params">(BigDecimal decreaseAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (decreaseAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;消费金额不能小于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (decreaseAmount.compareTo(<span class="built_in">this</span>.balance) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientAmountException</span>(<span class="string">&quot;当前账户余额不足，请充值&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.subtract(decreaseAmount);</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    由代码知，Wallet类主要有四个属性，其中，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示钱包余额上次变更的时间。</p>
<p>​    我们参照封装特性，对钱包这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或修改钱包里的数据。</p>
<ul>
<li>  String getId()</li>
<li>  long getCreateTime()</li>
<li>  BigDecimal getBalance()</li>
<li>  long getBalanceLastModifiedTime()</li>
<li>  void increaseBalance(BigDecimal increaseAmount)</li>
<li>  void decreaseBalance(BigDecimal decreaseAmount)</li>
</ul>
<p>之所以这样设计，是因为：从业务的角度来讲，</p>
<p>（1）id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的修改方法，比如 set 方法。</p>
<p>（2）而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化好，而不是通过构造函数的入参来进行外部赋值。</p>
<p>（3）对于钱包余额 balance 这个属性，从业务的角度来讲，只能增或者减，不会被重新设置。所以，我们在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法。</p>
<p>（4）对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 和 decreaseBalance() 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。</p>
<p>​    对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是<strong>访问权限控制</strong>。如 Java 中的 private、public 等。如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那么任意代码都可以通过类型 <code>wallet.id=123;</code> 这样的方式直接访问、修改属性，那么也就没办法达到隐藏信息和保护数据的目的了，自然也就无法支持封装特性了。</p>
<h4>上面讲了封装的定义，那么封装的意义是什么呢？它又能解决什么编程问题？</h4>

<p>​    如果我们对类中属性的访问不做限制，那么任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但是从另一方面来说，过度灵活业意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如，某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 wallet 中的 balanceLastModifiedTime 属性，就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。</p>
<p>​    除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把所有的类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就必须要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就少很多。【多说多错，少说少错】</p>
<p>​    这就好比，如果一个冰箱有很多按钮，你就必须研究很长时间，还不一定能正确操作。相反，如果只有几个必要的按钮，如开、关、加减温度，你一眼就知道该如何操作，而且操作出错的概率也会降低很多。</p>
<h2 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h2><p>​    封装主要讲的是“如何隐藏信息，保护数据”，而抽象讲的是“如何隐藏方法的具体实现，让调用者只需要关心提供了哪些功能，并不需要知道这些功能是如何实现的”。</p>
<p>​    在面向对象编程中，我们常借助编程语言提供的接口或者抽象类（如Java中的 interface 和 abstract 关键字）这两种语法机制，来实现抽象这一特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPictureStorage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span>;</span><br><span class="line"></span><br><span class="line">    Image <span class="title function_">getPicture</span><span class="params">(String pictureId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deletePicture</span><span class="params">(String pictureId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PictureStorage</span> <span class="keyword">implements</span> <span class="title class_">IPictureStorage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 保存图片</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">getPicture</span><span class="params">(String pictureId)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 获取图片</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePicture</span><span class="params">(String pictureId)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 删除图片</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 修改元数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在上面的这段代码中，我们利用 Interface 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口中暴露的方法提供的功能就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑。</p>
<p>​    实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口或抽象类这些特殊的语法机制来支持。换句话说就是，并不是一定要为实现类抽象出接口（Interface）或抽象类（abstract）才叫做抽象。即使不编写 IPictureStorage 接口，单纯的 PictureStorage 本身就满足抽象特性。</p>
<p>​    之所以这么说，是因为，类中的方法是通过编程语言中的“函数”这一语法机制来实现的，通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或文档，了解其提供了什么功能，就可以直接使用了。比如，我们在调用某个具体实现方法 <code>new ArrayList().add()</code> 的时候，并不需要了解它的底层代码是怎么实现的。</p>
<p>​    需要注意的是，抽象有时候会被排除在“面向对象特性”之外，即面向对象只有三大特性（封装、继承、多态）。这是因为，抽象这个概念是一个非常通用的思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个性质也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，所以，它没有很强的“特异性”，有时并不被看做是面向对象编程的特性之一。【抽象：不够特殊】</p>
<h4>上面讲了抽象的定义，那么抽象的意义是什么？它又能解决什么编程问题呢？</h4>

<p>​    实际上，如果上升一个层面考虑的话，抽象及前面讲的封装都是<u>人类处理复杂性的有效手段</u>。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好可以帮我们的大脑过滤掉许多非必要的信息。</p>
<p>​    除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想。比如基于接口编程而非实现编程、开闭原则（对扩展开发，对修改关闭）、代码解耦（降低代码的耦合性）等。</p>
<p>​    <u>换一个角度来考虑，我们在定义（或者叫命名）类中的方法时，也要有抽象思维，不要在方法名定义中暴露太多的实现细节，以保证在未来某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。</u> 举个例子，比如 <code>getAliyunPictureUrl()</code> 就不是一个具有抽象思维的命名，因为如果有一天我们不再把图片存储在阿里云上，而是存储在腾讯云上，那么这个命名也要随之修改。相反，如果我们定义一个比较抽象的函数，比如叫做 <code>getPictureUrl()</code> ，那即使内部的存储方式修改了，我们也不需要修改这个函数名。</p>
<h2 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h2><p>​    继承用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上将，继承可分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。比如猫既是哺乳动物，又是爬行动物。</p>
<p>​    为了实现“继承”这一特性，编程语言需要提供特殊的语法机制来支持。比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : class A），Python 使用 paraentheses()。不过，有些编程语言只支持单继承，不支持多继承，比如 Java、PHP、C# 等，而有些编程语言支持多继承，如 C++、Python 等。</p>
<h4>继承的定义讲完了，那么，继承存在的意义是什么？它又能解决什么编程问题呢？</h4>

<p>​    继承最大的一个好处就是<strong>代码复用</strong>。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并非继承所独有的，我们也可以通过其它方式来解决代码复用的问题，比如使用组合关系而不是继承关系。</p>
<p>​    如果上升到思维层面，去思考继承这一特性，可以这么理解：我们的代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，这是一种 is-a 关系。我们通过继承来关联两个类，反映真实世界中的这种关系，非常符合人类的认知。而且，从设计的角度来讲，也有一种结构美感。</p>
<p>​    继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不经需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。</p>
<p>​    所以，继承这一特性非常有争议，很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。而是使用“组合”来代替。</p>
<h2 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h2><p>​    多态是指“<strong>子类可以替换父类</strong>”，在编码时使用父类，在实际的代码运行过程中，调用子类的方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 10:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">protected</span> Integer[] elements = <span class="keyword">new</span> <span class="title class_">Integer</span>[DEFAULT_CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 如果数组满了就扩容，代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortedDynamicArray</span> <span class="keyword">extends</span> <span class="title class_">DynamicArray</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//保证数组中的元素有序</span></span><br><span class="line">            <span class="keyword">if</span> (elements[i] &gt; e)&#123;</span><br><span class="line">                elements[i+<span class="number">1</span>] = elements[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elements[i+<span class="number">1</span>] = e;</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(DynamicArray dynamicArray)</span>&#123;</span><br><span class="line">        dynamicArray.add(<span class="number">5</span>);</span><br><span class="line">        dynamicArray.add(<span class="number">1</span>);</span><br><span class="line">        dynamicArray.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dynamicArray.size; i++) &#123;</span><br><span class="line">            System.out.println(dynamicArray.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DynamicArray</span> <span class="variable">dynamicArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortedDynamicArray</span>();</span><br><span class="line">        test(dynamicArray); <span class="comment">// 打印结果：1，3，5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。</p>
<ul>
<li>  第一个语法机制是编程语言要支持父类对象可以引用子类对象。也就是可以将 SortedDynamicArray 传递给 DynamicArray。</li>
<li>  第二个语法机制使编程语言支持继承，也就是 SortedDynamicArray  继承了 DynamicArray，才能将 SortedDynamicArray  传递给 DynamicArray。</li>
<li>  第三个语法机制使编程语言要支持子类可以重写（Override）父类中的方法，也就是 SortedDynamicArray  重写了 DynamicArray 中的 add() 方法。</li>
</ul>
<p>通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类  SortedDynamicArray  替换父类 DynamicArray，执行子类  SortedDynamicArray  中的 add() 方法，也就是实现了多态特性。</p>
<p>​    对于多态特性的实现方式，除了利用“继承+方法重写”这种方式外，我们还有其它两种比较常见的实现方式，一个是利用“接口+方法重写”方式，另一个是利用“duck-typing”语法。不过，并不是每种编程语言都支持接口或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。</p>
<p>​    对于如何利用“接口+方法重写”实现多态特性。我们可以看下面这段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 11:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Iterator iterator)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">arrayIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        print(arrayIterator);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">linkedListIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        print(linkedListIterator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，Iterator 是一个接口，定义了一个可以遍历集合数据的迭代器，Array 和 LinkedList 都实现了接口 Iterator。我们通过传递不同类型的实现类（Array/LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hashNext() 方法实现。</p>
<p>​    具体点讲就是，当我们向 print(Iterator iterator) 函数传递 Array 类型的对象时，print(Iterator iterator) 函数就会调用 Array 的 next()、hashNext() 的实现逻辑；当我们向 print(Iterator iterator) 函数传递 LinkedList 类型的对象时，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hashNext() 的实现逻辑。</p>
<p>​    上面的代码是在 Java 中用接口来实现多态特性。现在我们在来看一下在 Python 中如何用 duck-typing 来实现多态特性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I write a log into file.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I insert data into db.&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">recorder</span>):</span><br><span class="line">    recorder.record()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    logger = Logger();</span><br><span class="line">    db = DB()</span><br><span class="line">    test(logger)</span><br><span class="line">    test(db)</span><br></pre></td></tr></table></figure>

<p>​    从这段代码中，我们发现，duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是它们都定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法。</p>
<p>​    也就是说，只要两个类具有相同（同名、同参、同返回值）的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这种静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系；通过接口实现多态特性，类必须实现对应的接口。</p>
<h4>多态特性讲完了，那么多态存在的意义是什么？它能解决什么编程问题？</h4>

<p>​    <strong>多态特性能够提高代码的可扩展性和复用性</strong>。我们回过头去看以下多态特性中的第二个例子（Iterator例子），在那个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array/LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需要让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。</p>
<p>​    如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator)函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如对于 Array，我们要实现 print(Array array) 函数，对于 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性和可扩展性。</p>
<p>​    除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如：策略模式、基于接口编程而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的 if-else 语句等。</p>
<hr>
<h1 id="06，07-理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"><a href="#06，07-理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？" class="headerlink" title="06，07 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"></a>06，07 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？</h1><p>​    很多人编程的一个误区就是：以为使用面向对象的编程语言来做开发就是在面向对象编程了。而实际上，他们往往只是在用面向对象的编程语言，编程面向过程风格的代码而已，并没有发挥面向对象编程的优势。这相当于手握一把屠龙刀，却只是把它当做一把普通刀剑来用。想要搞清楚面向过程和面向对象这两种编程风格，首先要厘清下面这些问题：</p>
<blockquote>
<ol>
<li> 什么是面向过程编程与面向过程编程语言？</li>
<li> 面向对象编程相比面向过程编程有哪些优势？</li>
<li> 为什么说面向对象编程语言比面向过程编程语言更加高级？</li>
<li> 有哪些看似是面向对象实际是面向过程风格的代码？</li>
<li> 在面向对象编程中，为什么容易写出面向过程风格的代码？</li>
<li> 面向过程编程和面向过程 编程语言真的无用武之地了吗？</li>
</ol>
</blockquote>
<h2 id="什么是面向过程编程与面向过程编程语言？"><a href="#什么是面向过程编程与面向过程编程语言？" class="headerlink" title="什么是面向过程编程与面向过程编程语言？"></a>什么是面向过程编程与面向过程编程语言？</h2><p>​    通过前面的学习，我们可以类比面向对象编程和面向对象编程语言这两个概念来理解面向过程编程与面向过程编程语言。关于面向对象编程和面向对象编程语言的概念如下：</p>
<ul>
<li>  面向对象编程是一种编程风格，它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性作为代码设计和实现的基石。</li>
<li>  面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</li>
</ul>
<p>​    类比面向对象编程与面向对象编程语言的定义，对于面向过程编程和面向过程编程语言这两个概念，可以给出如下定义：</p>
<ul>
<li>  面向过程编程也是一种编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以<strong>数据</strong>（可以理解为成员变量、属性）<strong>与方法相离</strong>为最主要的特点。面向过程风格是一种流程化的编程风格，通过凭借一组顺序执行的方法来操作数据完成一项功能。</li>
<li>  面向过程编程语言首先是一种编程语言，它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、封装、多态），仅支持面向过程编程。</li>
</ul>
<p>​    不过，就像我们之间讲到的面向对象编程和面向对象编程语言并没有官方的定义一样，这里我们给出的面向过程编程和面向过程编程语言的定义，也并不是严格的官方定义。</p>
<p>​    定义比较抽象，所以，我们用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件 users.txt，没行文本的格式时 name&amp;age&amp;gender（比如：张三&amp;23&amp;男）。我们希望写一个程序。从 users.txt 文件中逐行读取用户信息，然后格式化成 <code>name\tage\tgender</code>（其中，<code>\t</code> 是分隔符） 这种文本格式，并且按照 age 从小到大排序之后，重新写入到另一个文本文件 formatted_users.txt 中。针对这样一个程序的开发，我们来看一下，用面向过程和面向对象两种风格，写出来的代码有何不同。</p>
<p>​    首先，我们先来看，用面向过程编程风格写出来的代码是什么样子的。注：下面这段代码使用C语言这种面向过程的编程语言编写的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> User <span class="title function_">parse_to_user</span><span class="params">(<span class="type">char</span>* text)</span>&#123;</span><br><span class="line">    <span class="comment">// 将 text(&quot;张三&amp;23&amp;男&quot;) 解析成结构体 struct user</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">format_to_text</span><span class="params">(<span class="keyword">struct</span> User user)</span>&#123;</span><br><span class="line">    <span class="comment">// 将结构体 struct User 格式化成文本(“张三\t23\t男”)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_users_by_age</span><span class="params">(<span class="keyword">struct</span> User users[])</span>&#123;</span><br><span class="line">    <span class="comment">// 按照年龄从小到大排序users</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">format_user_file</span><span class="params">(<span class="type">char</span>* origin_file_path, <span class="type">char</span>* new_file_path)</span>&#123;</span><br><span class="line">    <span class="comment">// open files...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">users</span>[1024];</span> <span class="comment">// 假设最大1024个用户</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">// read util the file is empty</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span> =</span> parse_to_user(line);</span><br><span class="line">        users[count++] = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort_users_by_age(users);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">        <span class="comment">// 逐行格式化</span></span><br><span class="line">        <span class="type">char</span>* formated_user_text = format_to_text(users[i]);</span><br><span class="line">        <span class="comment">// write to new file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close files</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    format_user_file(<span class="string">&quot;/tmp/users.txt&quot;</span>, <span class="string">&quot;/tmp/formatted_users.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后，我们再来看用面向对象这种编程风格写出来的代码是什么样子的。注：下面这段代码是使用Java这种面向对象的编程语言来编写的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 17:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">parseForm</span><span class="params">(String userInfoText)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 将 text(&quot;张三&amp;23&amp;男&quot;) 解析成User类对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">formatToText</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 将 User对象格式化成文本 (&quot;张三\t23\t男&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFileFormatter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(String userFile, String formattedUserFile)</span>&#123;</span><br><span class="line">        <span class="comment">// Open files...</span></span><br><span class="line">        ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123; <span class="comment">// read util the file is empty</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.parseForm(userFile);</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort users by age</span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">formattedUserText</span> <span class="operator">=</span> user.formatToText();</span><br><span class="line">            <span class="comment">// write to new file</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close files...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainApplication</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserFileFormatter</span> <span class="variable">userFileFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserFileFormatter</span>();</span><br><span class="line">        userFileFormatter.format(<span class="string">&quot;/tmp/users.txt&quot;</span>, <span class="string">&quot;/tmp/formatted_users.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    从上面的代码中，我们可以看出，面向过程和面向对象最明显的区别就是，代码的组织方式不同。<strong>面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的</strong>。面向对象风格的代码被组织成一组类，方法和数据结构被绑定在一起，定义在类中。</p>
<p>​    除了这个最明显的特点，两种风格的区别还有什么呢？我们继续往下看。</p>
<h2 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h2><p>​    上面我们介绍了面向过程编程及面向过程编程语言的定义，并跟面向对象编程及面向对象编程语言做了一个简单的对比。接下来，我们再来看一下，为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式的原因。</p>
<h4>1、OOP更加能够应对大规模复杂程序的开发</h4>

<p>​    单单从上面那个格式化文本文件的例子，你可能发现两种编程风格实现的代码貌似差不多呀，只是代码的组织方式有些区别，没有感觉到面向对象编程有什么明显的优势呀。之所以有这种感觉，主要是这个例子程序比较简单，不够复杂。</p>
<p>​    对于简单程序的开发来说，不管是用面向过程的编程风格，还是用面向对象的编程风格，差别确实不会很大，甚至有的时候，面向过程编程反倒更有优势。因为需求足够简单，整个程序的处理流程就只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程编程这种面条式的编程风格来实现。</p>
<p>​    但对于大规模复杂程序程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个流程的处理流程图画出来的话，会是一个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。</p>
<p>​    面向对象编程是以类为思考对象，在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</p>
<p>​    除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可定要定义数百个函数，数百个数据结构（struct），那么如何分门别类地组织这些函数和数据结构，才能不至于看起来比较混乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。</p>
<p>​    你可能想到，像C语言这种面向过程的编程语言，我们也可以按照功能不同，把函数和数据结构放到不同的文件中，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。这样当然也可以，只不过面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求。这也算是面向对象编程相对于面向过程编程的一个微创新吧。</p>
<p>​    实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过比直接用面向对象的编程语言可能需要付出的代价更高一些。而且，面向过程编程和面向对象编程并非完全对立的，很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。</p>
<h4>2、OOP风格的代码更易复用、易扩展、易维护</h4>

<p>​    在上一节的例子中，因为代码比较简单，所以只用到了类、对象这两个最基本的面向对象概念，并没有用到更加高级的四大特性，封装、抽象、继承、多态。因此，面向对象的优势其实并没有发挥出来。</p>
<p>​    面向过程编程是一种非常简单的编程风格，并没有向面向对象编程那样提供丰富的特性，而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。</p>
<p>​    首先，来看封装特性。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会向<strong>面向过程编程那样，数据可以被任意的方法随意修改</strong>。因此，面向对象提供的封装特性更有利于提高代码的已维护性。【对于调用者来说，知道的越少，需要维护的也就越少】</p>
<p>​    其次，对于抽象特性。我们知道，函数本身就是一种抽象，它隐藏了具体的实现。我们在使用函数的时候，只需要了解函数的功能，而不需要了解它是怎么实现的。从这一点上，不管是面向对象编程还是面向过程编程，都支持抽象特性。不过，面向对象编程还提供了其它抽象特性的实现方式。这些实现方式是面向过程编程所不具有的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性，提高了代码的可扩展性。【当然，这其实还用到了面向对象的多态特性】</p>
<p>​    再次，对于继承特性。继承特性时面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的属性和方法，抽取到父类中，让两个子类继承父类，这样两个子类就可以复用父类中的代码，避免代码冲虚写多遍，提高了代码的复用性。</p>
<p>​    最后，对于多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际代码的运行中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭，对扩展开放”的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码复用性。</p>
<p>​    所以说，基于这四大特性，利用面向对象编程，我们可以更轻松地写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些。</p>
<h4>3、OOP语言更加人性化、更加高级、更加智能</h4>









<h2 id="有哪些看似是面向对象实际是面向过程风格的代码？"><a href="#有哪些看似是面向对象实际是面向过程风格的代码？" class="headerlink" title="有哪些看似是面向对象实际是面向过程风格的代码？"></a>有哪些看似是面向对象实际是面向过程风格的代码？</h2><p>​    现如今，大部分的编程语言都是面向对象编程语言，大部分软件都是基于面向对象这种编程范式来开发的。不过，在实际开发中，很多开发者对面向对象编程都有误解，总是以为把所有代码都塞到类里面，自认为就是在进行面向对象编程了。实际上这样的认知是不正确的，有时候表面上看似是面向对象编程风格的代码 ，本质上却是面向过程风格的。</p>
<p>​    使用面向编程语言编写面向过程风格的代码，有时候是有意为之，并无不妥；而有些却是无意为之，会影响到代码质量。下面我们将通过三个典型的代码案例来具体展示一下，什么样的代码看似是面向对象风格，实际上是面向过程风格的。</p>
<h4>1、滥用 getter、setter 方法</h4>

<p>​    在很多项目开发中，一些开发者在定义完类的属性后，就顺手把这些属性的 getter、setter 方法都定义上，更有甚者直接用 Lombok 插件自动生成所有属性的 setter、getter 方法。这一行为的理由往往是：为了以后可能会用到，现在事先定义好，之后用起来就更加方便，而且即使用不到这些 getter、setter 方法，定义它们也无伤大雅。</p>
<p>​    实际上，这样的做法其实在一些大公司是非常不推荐的。<u>它违反了面向对象的封装特性</u>，相当于将面向对象编程风格退化为面向过程编程风格。我们通过一个例子来理解一下这句话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 21:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> itemsCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> totalPrice;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ShoppingCartItem&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemsCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItemsCount</span><span class="params">(<span class="type">int</span> itemsCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.itemsCount = itemsCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalPrice</span><span class="params">(<span class="type">double</span> totalPrice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.totalPrice = totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(ShoppingCartItem item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.add(item);</span><br><span class="line">        itemsCount++;</span><br><span class="line">        totalPrice += item.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其它方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，ShoppingCart 是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。对于 itemsCount、totalPrice 两个属性，我们定义了它的 getter、setter 方法，对于 items 属性，我们定义了它的 getter 方法和 addItem() 方法。代码很简单，理解起来不难。那么其中存在哪些问题呢？</p>
<p>​    首先我们来看前两个属性， itemsCount 和 totalPrice，虽然我们将它定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性完全没什么两样了。外部可以通过 setter 方法随意修改这两个属性的值。任意代码都可以随意调用 setter 方法，来重设 itemsCount、totalPrice 属性的值，这就会导致其跟 items 属性的值不一致。</p>
<p>​    而面向对象封装特性的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p>
<p>​    看完前两个属性，我们再来看看 items 这个属性，对于 items 这个属性，我们定义了它的 getter 方法和 addItem() 方法，并没有定义它的 setter 方法。这样的设计貌似看起来没有什么问题，但实际上不是。</p>
<p>​    对于 itemsCount 和 totalPrice 这两个属性来说，定义一个public 的 getter 方法，确实无伤大雅，毕竟 getter 方法不会修改数据。但是，对于 items 属性就不一样了，这是因为 items 属性的 getter 方法，返回的是一个 List 集合容器。外部调用者在拿到这个容器后，是可以在不改变容器地址的情况下操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据。比如像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">...</span><br><span class="line">cart.getItems.clear(); <span class="comment">// 清空购物车</span></span><br></pre></td></tr></table></figure>

<p>​    你可能会觉得，清空购物车这样的功能需求看上去合情合理呀。没错，这个需求是合理的，但是上面这种写法会导致 itemsCount、totalPrice、items 三者数据不一致。我们不应该将情况购物车的业务逻辑暴露给上层调用者。正确的做法应该是，在 ShoppingCart 类中定义一个 clear() 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart 类的 clear() 方法的具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">	<span class="comment">// 省略其它代码...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        items.clear();</span><br><span class="line">        <span class="built_in">this</span>.itemsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.totalPrice = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    你可能还会说，我有一个需求，就是要查看购物车中都买了哪些商品，那这个时候，ShoppingCart 类就不得不提供 items 属性的 getter 方法了，那又该怎么办才好呢？</p>
<p>​    在Java中，我们可以通过 <code>Collections.unmodifiableList()</code> 让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，这个容器类中重写了 List 容器中与修改数据相关的方法，如 add()、clear() 等。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改。具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(<span class="built_in">this</span>.items);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnmodifiableList 部分源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnmodifiableList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">UnmodifiableCollection</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">        List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line">        items.clear(); <span class="comment">// 抛出 UnsupportedOperationException 异常  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不过，这样的实现思路还是有一些问题。因为当调用者通过 ShoppingCart 的 getItems() 获取到 items 之后，虽然无法直接在容器层面修改数据，但是我们仍然可以从容器中单个对象的层面，修改每个对象（ShoppingCartItem ）的数据。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">    List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line">    <span class="type">ShoppingCartItem</span> <span class="variable">item</span> <span class="operator">=</span> items.get(<span class="number">0</span>);</span><br><span class="line">    item.setPrice(<span class="number">10.0</span>); <span class="comment">// 这里修改了 item 的价格属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题的解决方案就要用到之后的设计模式了。</p>
<p>​    总的来说，在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防备集合内部数据被修改的风险。</p>
<h4>2、滥用全局变量和全局方法</h4>

<p>​    我们再来看看，另一个违反面向对象编程的例子，那就是滥用全局变量和全局方法。</p>
<p>​    在C语言这种面向过程编程的语言中，全局变量、全局方法到处可见，但是在Java这种面向对象的编程语言中，全局变量和全局方法就比较少见了。</p>
<p>​    在面向对象编程中，常见的全局变量有：单例对象、静态成员变量、常量等；常见的全局方法有静态方法。单例对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。静态方法一般用来操作静态变量或外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程编程风格。【比如，Utils类中往往只包含方法，方法需要的数据都是从其它类中获取到的，数据结构与方法分离】</p>
<p>​    在刚刚介绍了全局变量和全局方法中，Constants类和Utils类最长用到。现在我们集合这两个类来深入探讨一下全局变量和全局方法的利与弊。</p>
<p>​    我们先来看一下，一种常见的 Constants 类的定义方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/16 10:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_ADDR_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_addr&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_DB_NAME_KEY</span> <span class="operator">=</span> <span class="string">&quot;db_name&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_USERNAME_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_username&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_PASSWORD_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_DEFAULT_ADDR</span> <span class="operator">=</span> <span class="string">&quot;192.168.1.101:6379&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_DEFAULT_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;rt:&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略更多的常量定义</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，我们把程序中用到的所有常量，都集中地放到这个 Constant 类中。不过，这样一个大而全的 Constants 类，并不是一种很好的设计思路。</p>
<p>​    首先，这样设计会<strong>影响代码的可维护性</strong>。如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类中添加常量，那么这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。</p>
<p>​    其次，这样的设计还会<strong>增加代码的编译时间</strong>。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那么每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。而对于一个非常大的项目来说，编译一次项目花费的时间可能是几分钟，甚至十几分钟。而在我们的开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就可能会影响到我们的开发效率。【单元测试编译过程是增量编译，只对发生修改的类重新编译，依赖 Constants 的类越多，修改 Constants 后重新编译的时间就越长】 </p>
<p>​    最后，这样的设计还会<strong>影响代码的复用性</strong>。如果我们要在另一个项目中复用本项目开发的某个类，而这个类又依赖于 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中。</p>
<p>​    那么如何改进 Constants 类的设计呢？下面有两种思路可以借鉴。</p>
<p>​    第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们就放到 MySqlConstants 类中，跟 Redis 配置相关的常量，我们就放到 RedisConstants 类中。另一种是更加面向对象的思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了哪个常量，我们就直接把这个常量定义在这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，我们就把这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。</p>
<p>​    讲完了 Constants 类，我们再来讨论一下 Utils 类。首先，我们应该思考一下：为什么需要 Utils 类？</p>
<p>​    实际上，Utils 类出现的背景是基于这样一个问题：如果我们有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复开发，我们不应该在两个类中，将这个相同的功能逻辑重复实现两遍。这个时候应该怎么办呢？</p>
<p>​    首先，你应该想到可以使用面向对象的继承特性。利用继承特性，我们可以把相同的属性和方法抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有时候，从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。如果仅仅为了代码复用，硬生生抽象出一个父类来，会影响代码的可读性。</p>
<p>​    既然继承解决不了这个问题，我们可以定义一个新的类，实现 URL 拼接和分割的方法。而<u>拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性</u>，这个时候，我们就可以把它定义为只包含静态方法的 Utils 类了。</p>
<p>​    实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，他在软件开发中还是挺有用的，能解决代码复用问题。所以，我们并不是说完全不能用 Utils 类，而是要尽量避免滥用，不要不加思考地随意去定义 Utils 类。</p>
<p>​    在定义 Utils 类之前，你要问一下自己，你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其它类中呢？如果在考虑完这些问题后，还是觉得有必要去定义这样一个 Utils 类，那么就大胆地去定义吧。因为在面向对象编程中，也并不是完全排斥面向过程风格的代码、只要它能为我们写出好的代码共享力量，我们就可以适度地去使用。【A需要，B需要，但A与B无关】</p>
<p>​    除此之外，类比 Constants 类的设计，我们设计 Utils 类的时候，最好也细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUitls、StringUtils、UrlUtils 等，不要设计一个大而全的 Utils 类。</p>
<h4>3、定义数据和方法分离的类</h4>

<p>​    我们再来看一下最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是“<strong>数据定义在一个类中，方法定义在另一个类中</strong>”。并且，这个问题在基于 MVC 三层架构做 Web 后端开发的代码中普遍存在。</p>
<p>​    传统的 MVC 结构分为 Model 层、Controller 层、View 层三层。不过，在前后端分离之后，三层结构在后端开发中调整为  Controller、Service、Mapper 三层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑处理，Mapper  层负责数据读写。而在每一次层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Mapper 类中。这就是典型的面向过程的编程风格。</p>
<p>​    实际上，这种开发模式叫做<strong>基于贫血模型的开发模式</strong>，也是现在非常常用的一种 Web 项目的开发模式。那么，既然这种开发模式明显违背了面向对象的编程风格，那么为什么大部分的 Web 项目都是基于这种开发模式来开发的呢？这个问题的答案，参见：TODO</p>
<h2 id="在面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#在面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="在面向对象编程中，为什么容易写出面向过程风格的代码？"></a>在面向对象编程中，为什么容易写出面向过程风格的代码？</h2><p>​    我们在进行面向对象编程的时候，很容易就不由自主地写出了面向过程编程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？</p>
<p>​    你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步步顺序执行一系列操作，最终完成整个任务。面向过程编程风格恰恰符合人的这种流程化的思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。这样的思考路径比较适合复杂程序的开发，但并不符合人类的思考习惯。</p>
<p>​    如果将类类比成角色，可以这么理解，张三是个产品经理，他会设计产品；李四是个UI，他可以根据原型图画出漂亮的界面；王五是个程序员，他会设计架构和敲代码。现在甲方提出需要一个网上购物平台，按照面向过程的思维就是，我得先去学产品设计，再学UI，最后学代码，全部学会之后我就可以把系统做出来了。而在面向对象的思维中，可能是这样，我什么都不会，但是我认识很多人，我知道有人会，我去沟通张三、李四、王五，我先让张三设计原型图，我拿到原型图之后再去找李四让他给我设计页面，最后我拿着李四设计的页面让王五去给我实现，这样系统也就做好了。</p>
<p>​    在这个例子中，总共就三个流程，张三、李四、王五每人只使用了一门手艺，看起来面向对象和面向过程在复杂度上并无太大的差距。但是把这个问题发散一下，完成某个任务需要三百个流程，并且这些流程互相调用呈网状结构，如果按照面向过程思维，确实十分复杂。而使用面向对象思维，我们可以使用三十个人，每人只要会十门手艺，并且让这些人能相互联系，这样程序的复杂度就能大大降低。</p>
<p>​    【面向对象编程就是粒度更大的编程，面向过程以函数和数据结构为基本单位，在函数或数据结构数量达到几百几千之后就变得不容易管理。而面向对象则是以类和对象为基本单位，将数据结构和函数归属于类内部，每个类包含多个数据结构和函数，这样就可以将面向过程的几百几千个函数按照一定规则减少到几十个，更加容易管理，更适合复杂系统】</p>
<p>​    除此之外，面向对象编程要比面向过程编程更难一些。在面向对象编程中，类的设计还是挺需要技巧和设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的交互关系等等诸多问题。</p>
<p>​    所以，基于这两点原因，很多程序员在开发的时候，更倾向于不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。</p>
<h2 id="面向过程编程和面向过程-编程语言真的无用武之地了吗？"><a href="#面向过程编程和面向过程-编程语言真的无用武之地了吗？" class="headerlink" title="面向过程编程和面向过程 编程语言真的无用武之地了吗？"></a>面向过程编程和面向过程 编程语言真的无用武之地了吗？</h2><hr>
<h1 id="08-理论五：接口-vs-抽象类的区别？如何用普通的类模拟抽象类和接口？"><a href="#08-理论五：接口-vs-抽象类的区别？如何用普通的类模拟抽象类和接口？" class="headerlink" title="08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？"></a>08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？</h1><p>​    在面向对象编程中，抽象类和接口是两个经常要用到的语句，是面向对象四大特性、以及很多设计模式、设计思想、设计原则编程实现的基础。比如，我们可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等等。</p>
<p>​    不过，并非所有的面向对象编程语言都支持这两个语法概念，比如，C++就只支持抽象类，不支持接口；Python既不支持接口，也不支持抽象类。尽管这些编程语言没有提供现成的语法来支持接口和抽象类，但是我们仍然可以通过一些手段来模拟实现这两个语法概念。在Java中，既支持抽象类，也支持接口。</p>
<h2 id="什么是抽象类和接口？区别在哪里？"><a href="#什么是抽象类和接口？区别在哪里？" class="headerlink" title="什么是抽象类和接口？区别在哪里？"></a>什么是抽象类和接口？区别在哪里？</h2><h4>Java中的抽象类</h4>

<p>​    下面这段代码是一个比较典型的抽象类的使用场景（模板设计模式）。Logger类是一个记录日志的抽象类，FileLogger和MessageQueueLogger继承Logger，分别实现两种不同的日志记录方式，记录到日志文件中和记录到消息队列中。FileLogger和MessageQueueLogger复用了父类Logger中的name、enabled、minPermittedLevel属性和log()方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的 doLog() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/16 11:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel; <span class="comment">// 日志的最小级别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">        <span class="keyword">if</span> (!loggable) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        doLog(level, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到消息中间件（如Kafka）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient messageQueueClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, MessageQueueClient messageQueueClient)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient = messageQueueClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到消息中间件</span></span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient.send(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这个例子，我们来总结一下，抽象类具有哪些特性：</p>
<ul>
<li>  抽象类不允许被实例化。</li>
<li>  抽象类可以包含属性和方法，方法既可以有实现（比如Logger中 log() 方法），也可以不包含实现（比如Logger中的 doLog() 方法）。不包含代码实现的方法叫做抽象方法。</li>
<li>  子类继承抽象类，必须实现抽象类中的所有抽象方法或继续声明为抽象类。对应到例子中就是，所有继承Logger抽象类的子类，都必须重写 doLog() 方法。</li>
</ul>
<h4>Java中的接口</h4>

<p>上面讲了Java中如何定义抽象类，我们再来看一下Java中如何定义接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/19 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthenticationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 鉴权逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 限流逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器使用demo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">    <span class="comment">// filters.add(new AuthenticationFilter())</span></span><br><span class="line">    <span class="comment">// filters.add(new RateLimitFilter())</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRpcRequest</span><span class="params">(RpcRequest req)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">                filter.doFilter(req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RpcException e)&#123;</span><br><span class="line">            <span class="comment">// 处理过滤结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略其它处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面这段代码是一个比较典型的接口的使用场景。我们通过 interface 关键字定义了一个 Filter 接口，AuthenticationFilter 和 RateLimitFilter 是接口的两个实现类，分别实现了对 RPC 请求鉴权和限流的过滤功能。</p>
<p>通过这个例子，我们再来总结以下，接口有哪些特性：</p>
<ol>
<li> 接口不能包含属性（也就是成员变量）。</li>
<li> 接口只能声明方法，方法不能包含代码实现。</li>
<li> 实现接口的时候，必须实现接口中声明的所有方法。</li>
</ol>
<p>​    前面我们讲了抽象类和接口的定义，以及各自的语法特性。从语法特性上比，这两者有较大的区别，但这种区别并不是绝对的，在不同的JDK版本中部分语法特性可能略有区别。我们今天主要的目的是要从设计的角度进行这两者的比较。</p>
<p>​    从设计角度来看，抽象类实际上实际上就是类，这种类不能被实例化成对象，只能被子类继承。我们知道，继承是一种 is-a 关系，那么抽象类既然属于类，也表示一种 is-a 的关系。相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是<strong>协议（contract）</strong>。</p>
<h2 id="抽象类和接口能解决什么问题？"><a href="#抽象类和接口能解决什么问题？" class="headerlink" title="抽象类和接口能解决什么问题？"></a>抽象类和接口能解决什么问题？</h2><p>​    上面我们学习了抽象类和接口的定义和区别，现在我们再来学习一下，抽象类和接口存在的意义。</p>
<h4>首先，我们来看一下，为什么需要抽象类？它能解决什么编程问题？</h4>

<p>​    刚刚我们讲到，抽象类不能被实例化，只能被<u>继承</u>。而在前面的章节中，我们还讲过<u>继承</u>能解决代码复用的问题。以此类推，抽象类也是用来解决代码复用问题的。多个子类可以继承抽象类中定义的共有属性和方法，避免在子类中，重复编写相同的代码。</p>
<p>​    【问题】不过，既然继承本身就能达到代码复用的目的，而继承也并不要求父类一定是抽象类，那么我们不使用抽象类，照样也可以实现继承和复用。从这个角度上讲，我们貌似并不需要抽象类这种语法呀。那么抽象类除了解决代码复用的问题，还有什么其它存在的意义吗？</p>
<p>​    我们还是拿之前那个打印日志的例子来讲，在改造之后的代码中，Logger不再是抽象类，只是一个普通的父类，删除了 Logger 中的 log()、doLog() 方法，新增了 isLoggable() 方法。FileLogger 和 MessageQueueLogger 还是继承 Logger 父类，已达到代码复用的目的。具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类，非抽象类，删除了log()、doLog()方法，新增了isLoggable()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel; <span class="comment">// 日志的最小级别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoggable</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level level)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">        <span class="keyword">return</span> loggable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：输出日志到消息中间件（如Kafka）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient messageQueueClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, MessageQueueClient messageQueueClient)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient = messageQueueClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到消息中间件</span></span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient.send(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设计虽然也能达到代码复用的目的，但是却无法使用多态特性了。像下面这种代码，就会出现编译错误，因为 Logger 中没有定义 log() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(<span class="string">&quot;access-log&quot;</span>, <span class="literal">true</span>, Level.WARN, <span class="string">&quot;/tmp/logFile&quot;</span>);</span><br><span class="line">logger.log(Level.ERROR, <span class="string">&quot;This is a test log message&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>你可能会说，这个问题解决起来很简单啊。我们在 Logger 父类中，定义一个空的 log() 方法，让子类重写父类的 log() 方法，实现自己记录日志的逻辑，不就可以了么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">		<span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">	<span class="comment">// 省略部分代码...   </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">	<span class="comment">// 省略部分代码...   </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到消息中间件</span></span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient.send(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实，这种设计思路是可以实现我们的目的的。但是，它显然没有之前通过抽象类的实现思路优雅。为什么这么说呢？主要有以下几点原因。</p>
<ul>
<li>  <strong>更优雅</strong>。在 Logger 中定义一个空的方法，会影响代码的可读性。如果我们不熟悉 Logger 背后的设计思想，代码注释又不怎么给力，我们在阅读 Logger 代码的时候，就可能会对为什么定义一个空的 log() 方法而感到疑惑，需要查看 Logger、FileLogger、MessageQueueLogger 之间的继承关系，才能明白其设计意图。</li>
<li>  <strong>更强制</strong>。当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记实现 log() 方法。而基于抽象类的设计思路，编译器会强制要求子类重写 log() 方法，否则会报编译错误。</li>
<li>  <strong>更安全</strong>。若使用非抽象类，则 Logger 类可以被实例化，我们可以 new 一个 Logger 对象出来，并且调用空的 log() 方法，这显然增加了类被误用的风险。当然，这个问题可以通过手动设置私有构造函数的方式来解决。不过，显然没有使用抽象类来得优雅。</li>
</ul>
<h4>其次，我们再来看一下，我们为什么要需要使用接口？它能解决什么编程问题？</h4>

<p>​    抽象类更多是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或契约。你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体实现，具体的实现代码对调用者透明。通过接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p>
<p>​    实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常听到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。</p>
<h5>
    如何模拟抽象类和接口两个语法概念？
</h5>

<p>​    【问题】在前面的例子中，我们使用的 Java 语言默认提供了抽象类和接口两种实现标准。不过，如果你使用的语言是 C++ 这种没有提供接口语法的编程语言，那从代码实现的角度上来讲，是不是就无法实现 Filter 过滤器的思路了呢？</p>
<p>​    实际上，我们可以通过抽象类来模拟接口。怎么模拟呢？我们先来回忆一下接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，其实现类必须实现接口中的所有方法。只要满足这几点，从设计的角度上来说，我们就可以把它叫做接口。实际上，要满足这些语法特性并不难。下面这段C++代码中，我们就用抽象类模拟了一个接口（下面这段代码实际上是策略模式中的一段代码）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>&#123; <span class="comment">// 用抽象类模拟接口</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	~<span class="built_in">Strategy</span>();</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">alhorithm</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="built_in">Strategy</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>抽象类 Strategy 中没有定义任何属性，并且所有的方法都声明为 virtual 抽象类型，这样，所有的方法都不能有代码实现，并且继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于是一个接口。</p>
<p>​    【问题】不过，如果你使用是类似 Python 这种既没有接口，又没有抽象类的编程语言，那该如何实现上面讲到的 Filter、Logger 的设计思路呢？实际上，除了使用抽象类来模拟接口之外，我们还可以用普通类来模拟接口。具体的 Java 代码实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mockInterface</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">mockInterface</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodUnSupportedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们知道方法必须包含实现，这不符合接口的定义。但是<u>我们可以让类中的方法抛出 MethodUnSupportedException 异常来模拟不包含实现类的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常</u>。那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为 private 访问权限就可以了。</p>
<p>​    实际上，对于动态编程语言，还有一种对接口支持的策略，那就是 duck-typing。这点在之前的章节中讲过。</p>
<h2 id="如何决定该用接口还是抽象类？"><a href="#如何决定该用接口还是抽象类？" class="headerlink" title="如何决定该用接口还是抽象类？"></a>如何决定该用接口还是抽象类？</h2><p>​    上面讲的都是一些方法论，那么，在实际设计、开发的时候，什么时候该用抽象类？什么时候该用接口呢？</p>
<p>​    实际上，判断的标准很简单。<strong>如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 的关系，，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</strong></p>
<p>​    <u>从类的继承层次来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象出上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计私立，我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</u></p>
<hr>
<h1 id="09-理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#09-理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h1><p>​    在平时的开发中我们经常会听到并用到“基于接口而非实现编程”，这是一种非常有效的提高代码质量的手段。但是并非每个人都能用好这一准则，不用或过度使用都会使你编写的代码不够优雅。为了让你理解透彻这条原则，接下来我们会结合一个图片存储的实战案例来讲解，告诉你如何权衡，怎样恰到好处地应用这条原则。</p>
<h2 id="如何理解原则中的“接口”二字？"><a href="#如何理解原则中的“接口”二字？" class="headerlink" title="如何理解原则中的“接口”二字？"></a>如何理解原则中的“接口”二字？</h2><p>​    我们在理解“基于接口而非实现编程”这条原则时，千万不要一开始就与某种具体的编程语言挂钩，局限在某种语言的“接口”语法中（比如Java中的interface接口语法）。要知道，这条原则最早出现在1994年GoF《设计模式》这本书中，它比很多编程语言（如Java）诞生得都要早，因此不可能是为了迎合某种编程语言而创建的概念，你需要把它提到的“接口”理解成一种比较抽象、泛化的概念。</p>
<p>​    实际上，理解这条原则的关键就在于“接口”二字。我们在上一节中说过，从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，前后端联调的“接口”，类库提供的“接口”。刚刚对“接口”的理解，都是比较偏上层、偏抽象的，如果落实到具体的编码，“基于接口编程而非实现编程”这条原则中的接口，可以理解为编程语言中的接口或者抽象类。</p>
<p>​    前面我们说过，这条原则能非常有效地提高代码质量，之所以这么说是因为，应用这条原则，可以将接口和实现相分离，封装（隐藏）不稳定的实现，暴露稳定的接口。<u>上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本不需要做改动，</u>以此来降低耦合性（一方的改变不强制要求另一方改变），提高扩展性。</p>
<p>​    <u>实际上，“基于接口而非实现编程”这条原则的另一个表示方式是“基于抽象而非实现编程”</u>。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍能够在不破坏原有代码设计的情况下灵活应对。</strong>而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p>
<h2 id="如何将这条原则应用到实战中？"><a href="#如何将这条原则应用到实战中？" class="headerlink" title="如何将这条原则应用到实战中？"></a>如何将这条原则应用到实战中？</h2><p>​    对于这条原则，我们结合一个具体的实战案例来进一步讲解一下。</p>
<p>​    假设我们的系统中有很多涉及图片处理和存储的相关业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/19 20:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> &#123;</span><br><span class="line">    <span class="comment">// 省略属性、构造函数等...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">// 失败会抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 根据accesskey/secretkey等生成access token...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadToAliyun</span><span class="params">(Image image, String bucketName, String accessToken)</span>&#123;</span><br><span class="line">        <span class="comment">// 上传图片到阿里云...</span></span><br><span class="line">        <span class="comment">// 返回图片存储在阿里云上的地址（url）...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">downloadFromAliyun</span><span class="params">(String url, String accessToken)</span>&#123;</span><br><span class="line">        <span class="comment">// 从阿里云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunImageStore类的使用案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;my_image_bucket&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">// 处理图片，并封装成Image对象</span></span><br><span class="line">        <span class="type">AliyunImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliyunImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> imageStore.generateAccessToken();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> imageStore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    整个上传流程包含三个步骤：创建 bucket、生成 accessToken 访问凭证、携带 accessToken 上传图片到指定的 bucket 中。代码实现非常简单，用起来也很清晰，乍一看没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p>
<p>​    不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到私有云上。为了满足这样一个需求的变化，我们应该如何修改代码呢？</p>
<p>​    我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说。“细节是魔鬼”，这句话在软件开发中尤其适用。实际上，刚刚设计的实现方式，就隐藏了很多容易出问题的“坏味道”，我们一起来看看都有哪些。</p>
<p>​    新的 PrivateImageStore 类需要设计哪些方法，才能在尽量<u>最小化代码修改</u>的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，主要有以下两点。</p>
<ul>
<li>  首先，AliyunImageStore 类中的有些函数名暴露了实现细节，比如 uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中对这些方法重新命名，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码的修改量就可能回很大。</li>
<li>  其次，将图片存储到阿里云的流程，可能并不是完全一致的，比如，阿里云在图片上传和下载过程中，需要携带 accessToken，而私有云则不需要。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法就不再适合照抄到 PrivateImageStore 类中了；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</li>
</ul>
<p>那这两个问题应该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则。具体来讲，我们要落实到以下3点：</p>
<ol>
<li> 函数的命名不应该暴露任何实现细节。比如，前面使用的 uploadToAliyun() 就不符合要求，应该改为更抽象的命名方式，比如 upload()。</li>
<li> 封装具体的实现细节。比如，跟阿里云相关的特殊流程（如获取accessToken）不应该暴露给调用者。我们应该将其封装到通用流程（上传和下载）中，只对调用者暴露通用流程。</li>
<li> 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>
</ol>
<p>我们照着这个思路，把代码重构以下。重构后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.lnd.designPrincipes._09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/19 20:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImageStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String url)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createBucketIfNotExisting(bucketName);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.generateAccessToken();</span><br><span class="line">        <span class="comment">// 上传图片到阿里云...</span></span><br><span class="line">        <span class="comment">// 返回图片存储在阿里云上的地址（url）...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.generateAccessToken();</span><br><span class="line">        <span class="comment">// 从阿里云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">// 失败会抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 根据accesskey/secretkey等生成access token...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createBucketIfNotExisting(bucketName);</span><br><span class="line">        <span class="comment">// 上传图片到私有云...</span></span><br><span class="line">        <span class="comment">// 返回图片存储在私有云上的地址（url）...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="comment">// 从私有云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">// 失败会抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageStore测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;my_image_bucket&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">// 处理图片，并封装成Image对象</span></span><br><span class="line">        <span class="type">ImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> imageStore.upload(image, BUCKET_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    除此之外，<u>很多人在定义接口的时候，希望能够通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。</u>这样的接口设计就没有意义了。不过，如果你觉得这种思维方式更为顺畅，那也没问题，只是将实现类的方法转移到接口定义中的时候，要有选择性的转移，不要将具体的实现相关的方法转移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。</p>
<p>​    总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。<u>接口的定义只表明做什么，而不是怎么做</u>。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够坐到在替换具体的接口实现的时候，不需要对接口的定义做任何改动。</p>
<h2 id="是否要为每个类都定义接口？"><a href="#是否要为每个类都定义接口？" class="headerlink" title="是否要为每个类都定义接口？"></a>是否要为每个类都定义接口？</h2><p>​    任何事情都要讲究一个“度”，同样，如果过度使用“面向接口而不是实现”这条原则，非得给每个类都定义接口，接口漫天飞，也会导致不必要的开发负担。至于什么时候，改为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</p>
<p>​    前面我们也提到，这条原则的设计初衷是，<u>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口</u>。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当代码发生变化的时候，上游系统的代码基本需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</p>
<p>​    从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其它实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程了，直接使用实现类就可以了。</p>
<p>​    除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性投入不必要的开发时间。</p>
<h2 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h2><p>​    在本节的代码例子中，尽管我们通过使用接口来隔离了两个具体实现。但是，在项目中很多地方，我们都是通过下面第7行代码的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片的存储方式，还是需要修改很多类似第7行那样的代码。这样的设计还是不够完美，对此，你有更好的思路吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageStore测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;my_image_bucket&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">// 处理图片，并封装成Image对象</span></span><br><span class="line">        <span class="type">ImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> imageStore.upload(image, BUCKET_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="10-理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？"><a href="#10-理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？" class="headerlink" title="10 | 理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？"></a>10 | 理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？</h1><p>在面向对象编程中，有一条非常经典的设计原则，那就是：<strong>组合优于继承，多用组合少用继承。</strong></p>
<blockquote>
<ul>
<li>  为什么不推荐使用继承？【继承的缺点】</li>
<li>  组合相比于继承有哪些优势？【组合的优点】</li>
<li>  如何判断该用组合还是继承？【如何抉择】</li>
</ul>
</blockquote>
<p>本节我们就围绕着这三个问题，来讨论一下这条设计原则。</p>
<h2 id="为什么不推荐使用继承？"><a href="#为什么不推荐使用继承？" class="headerlink" title="为什么不推荐使用继承？"></a>为什么不推荐使用继承？</h2><p>​    继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可读性、可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议，很多人觉得继承是一种反模式，应该尽量少用甚至不用。至于为什么会有这样的争议，我们通过一个例子来解释一下。</p>
<p>​    假设我们要设计一个“鸟类“。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子等，都继承这个类。</p>
<p>​    我们知道，大部分的鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分的鸟都会飞，但也有特例，比如鸵鸟就不会飞。如果鸵鸟继承具有 fly() 方法的父类，那鸵鸟就凭空出现了“飞”这样的行为，这显然不符合我们对现实世界中事物的认知。当然，你可能会说，我可以在鸵鸟这个子类中重写 fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractBird</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 鸟会飞...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">AbstractBird</span>&#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnSupportedMethodException</span>(<span class="string">&quot;I can&#x27;t fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这种设计思路虽然可以解决问题，但是不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法并抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了“最小知识原则（Least Knowledge Principe，也叫迪米特法则）”，暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p>
<p>​    你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、鸽子这些会飞的鸟继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟都继承 AbstractUnFlyableBird，不就可以了么。  </p>
<p><img src="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/image-20220320110025182.png" alt="image-20220320110025182"></p>
<p>​    从图中我们可以看出，继承关系变成了三层。不过，从整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度，在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p>
<p>​    是否会飞？是否会叫？两个行为搭配起来会产生四种行为：会飞会叫、会飞不会叫、不会飞会叫、不会飞不会叫。如果我们继续沿用刚才的思路，那就需要再定义四个抽象类：AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird。此时继承关系就变成了四层。</p>
<p>​    如果我们还要考虑“是否会下蛋”这一行为，那估计就要组合爆炸了。类的继承层次会越来深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码…一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装，将父类的实现细节暴露给了子类【从父类命名中就可以看出父类的实现细节】。子类依赖父类实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</p>
<p>​    总之，<u>继承最大的问题就在于：继承的层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。</u>这也是我们为什么不推荐使用继承的原因。那刚刚例子中的继承存在的问题，我们又该如何来解决呢？</p>
<h2 id="组合相比继承有哪些优势？"><a href="#组合相比继承有哪些优势？" class="headerlink" title="组合相比继承有哪些优势？"></a>组合相比继承有哪些优势？</h2><p>​    实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿解决刚刚继承存在的问题。</p>
<p>​    我们前面讲接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸵鸟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable&#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 麻雀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Tweetable, EggLayable&#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p>
<p>​    我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类，实现了 tweet() 方法的 TweetAbility 类，实现了 lagEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除重复。具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyAbility</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TweetAbility</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EggLayAbility</span> <span class="keyword">implements</span> <span class="title class_">EggLayable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸵鸟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TweetAbility</span> <span class="variable">tweetAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TweetAbility</span>(); <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EggLayAbility</span> <span class="variable">eggLayAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EggLayAbility</span>(); <span class="comment">// 组合</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其它技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来代替；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上来讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或少用继承关系，特别是一些复杂的继承关系。</p>
<h2 id="如何判断该用组合还是继承？"><a href="#如何判断该用组合还是继承？" class="headerlink" title="如何判断该用组合还是继承？"></a>如何判断该用组合还是继承？</h2><p>​    尽管我们鼓励多用组合少用继承，但组合也并非是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加了代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</p>
<p>​    如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来代替继承。</p>
<p>​    除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰器模式、策略模式、组合模式等都使用了组合关系，而模板模式使用了继承关系。</p>
<p>​    前面我们讲到了继承可以实现代码复用。利用继承特性，我们把相同的属性和方法抽取出来，定义到父类中，子类复用父类中的属性和方法，达到代码复用的目的，但是，有时候从业务含以上讲，A类和B类并不一定具有继承关系，比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。如果仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这种情况下，使用组合就更加合理、更加灵活。具体的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">    <span class="comment">// 省略属性和方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crawler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Url url; <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Crawler</span><span class="params">(Url url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = <span class="keyword">new</span> <span class="title class_">Url</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageAnalyzer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Url url; <span class="comment">// 组合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageAnalyzer</span><span class="params">(Url url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = <span class="keyword">new</span> <span class="title class_">Url</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采取继承实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们就只能采用继承来实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClient</span> &#123; <span class="comment">// FeignClient框架代码</span></span><br><span class="line">    <span class="comment">// 省略属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(String url)</span>&#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoFunction</span><span class="params">(FeignClient feignClient)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    feignClient.encode();</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomizedFeignClient</span> <span class="keyword">extends</span> <span class="title class_">FeignClient</span> &#123; <span class="comment">// FeignClient框架代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(String url)</span>&#123;</span><br><span class="line">        <span class="comment">// 重写encode的实现...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="type">FeignClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomizedFeignClient</span>();</span><br><span class="line">demoFunction(client);</span><br></pre></td></tr></table></figure>

<p>​    尽管有些人说，要杜绝继承，100%使用组合代替继承，但这种观点多少有点极端。之所以“多用组合少用继承”这句口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也并非一无是处。只要我们控制好它的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，才是我们追求的最终目标。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="prev" title="HTTP实验环境搭建">
                  <i class="fa fa-chevron-left"></i> HTTP实验环境搭建
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/" rel="next" title="重学MySQL（Part1）">
                  重学MySQL（Part1） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
