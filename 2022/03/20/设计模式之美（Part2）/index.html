<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？​    我们都知道，很多业务系统都是基于MVC三层架构来开发的。实际上，更确切点讲，这是一种基于贫血模型的MVC三层架构开发模式。 ​    虽然这种开发模式已经成为标准的Web项目的开发模式，但它却违反了面向对象风格，是一种彻彻底底的面向过程编程风格，因而被有些人称为反模式。特别是领域驱动设计（Domain Drive">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式之美（Part2）">
<meta property="og:url" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？​    我们都知道，很多业务系统都是基于MVC三层架构来开发的。实际上，更确切点讲，这是一种基于贫血模型的MVC三层架构开发模式。 ​    虽然这种开发模式已经成为标准的Web项目的开发模式，但它却违反了面向对象风格，是一种彻彻底底的面向过程编程风格，因而被有些人称为反模式。特别是领域驱动设计（Domain Drive">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/9e91377602ef154eaf866c7e9263a64a.jpg">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/3915a6544403854d35678c81fe65f014.jpg">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322101917924.png">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/66ede1de93d29b86a9194ea0f80d1e43.jpg">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/60d3cfec73986b52e3a6ef4fe147e562.jpg">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/d1a9aeb6642404f80a62293ab2e45630.jpg">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/38b56bd1981d8b40ececa4d638e4a968.jpg">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322102527802.png">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322102706010.png">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322125659233.png">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322155801827.png">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322171228516.png">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322174037460.png">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322174247140.png">
<meta property="og:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322185107325.png">
<meta property="article:published_time" content="2022-03-20T05:48:14.000Z">
<meta property="article:modified_time" content="2022-03-25T12:25:27.673Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/9e91377602ef154eaf866c7e9263a64a.jpg">


<link rel="canonical" href="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/","path":"2022/03/20/设计模式之美（Part2）/","title":"设计模式之美（Part2）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>设计模式之美（Part2） | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%AE%9E%E6%88%98%E4%B8%80%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E4%BA%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84MVC%E6%9E%B6%E6%9E%84%E8%BF%9D%E8%83%8COOP%E5%90%97%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">什么是基于贫血模型的传统开发模式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">什么是基于充血模型的DDD开发模式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%A6%82%E6%AD%A4%E5%8F%97%E6%AC%A2%E8%BF%8E%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">为什么基于贫血模型的传统开发模式如此受欢迎？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E9%A1%B9%E7%9B%AE%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">什么项目应该考虑使用基于充血模型的DDD开发模式？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%AE%9E%E6%88%98%E4%B8%80%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E9%92%B1%E5%8C%85%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%B1%E5%8C%85%E4%B8%9A%E5%8A%A1%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">钱包业务背景介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%85%85%E5%80%BC"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、充值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%94%AF%E4%BB%98"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、支付</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%8F%90%E7%8E%B0"><span class="nav-number">2.1.3.</span> <span class="nav-text">3、提现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%9F%A5%E8%AF%A2%E4%BD%99%E9%A2%9D"><span class="nav-number">2.1.4.</span> <span class="nav-text">4、查询余额</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%9F%A5%E8%AF%A2%E4%BA%A4%E6%98%93%E6%B5%81%E6%B0%B4"><span class="nav-number">2.1.5.</span> <span class="nav-text">5、查询交易流水</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%B1%E5%8C%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-number">2.2.</span> <span class="nav-text">钱包系统的设计思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">基于贫血模型的传统开发模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">基于充血模型的DDD开发模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%A9%E8%AF%81%E6%80%9D%E8%80%83%E4%B8%8E%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="nav-number">2.5.</span> <span class="nav-text">辩证思考与灵活应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E5%AE%9E%E6%88%98%E4%BA%8C%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AF%B9%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E5%81%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%9A%BE%E7%82%B9%E5%89%96%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">案例介绍和难点剖析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%A1%88%E4%BE%8B%E8%BF%9B%E8%A1%8C%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">对案例进行需求分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="nav-number">3.2.1.</span> <span class="nav-text">1、第一轮需求分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%AC%AC%E4%BA%8C%E8%BD%AE%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96"><span class="nav-number">3.2.2.</span> <span class="nav-text">2、第二轮分析优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%AC%AC%E4%B8%89%E8%BD%AE%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96"><span class="nav-number">3.2.3.</span> <span class="nav-text">3、第三轮分析优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%AC%AC%E5%9B%9B%E8%BD%AE%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96"><span class="nav-number">3.2.4.</span> <span class="nav-text">4、第四轮分析优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%9C%80%E7%BB%88%E7%A1%AE%E5%AE%9A%E9%9C%80%E6%B1%82"><span class="nav-number">3.2.5.</span> <span class="nav-text">5、最终确定需求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E5%AE%9E%E6%88%98%E4%BA%8C%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">如何进行面向对象设计？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%88%92%E5%88%86%E8%81%8C%E8%B4%A3%E8%BF%9B%E8%80%8C%E8%AF%86%E5%88%AB%E5%87%BA%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB"><span class="nav-number">4.1.1.</span> <span class="nav-text">1、划分职责进而识别出有哪些类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">2、定义类及其属性和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="nav-number">4.1.3.</span> <span class="nav-text">3、定义类与类之间的交互关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%B0%86%E7%B1%BB%E7%BB%84%E8%A3%85%E8%B5%B7%E6%9D%A5%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%89%A7%E8%A1%8C%E5%85%A5%E5%8F%A3"><span class="nav-number">4.1.4.</span> <span class="nav-text">4、将类组装起来并提供执行入口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E7%90%86%E8%AE%BA%E4%B8%80%EF%BC%9A%E5%AF%B9%E4%BA%8E%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%B6%B3%E5%A4%9F%E2%80%9C%E5%8D%95%E4%B8%80%E2%80%9D%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">15 | 理论一：对于单一职责原则，如何判断某个类的职责是否足够“单一”？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88SRP%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">如何理解单一职责原则（SRP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E5%A4%9F%E5%8D%95%E4%B8%80%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">如何判断类的职责是否够单一？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%AE%BE%E8%AE%A1%E5%BE%97%E8%B6%8A%E5%8D%95%E4%B8%80%E8%B6%8A%E5%A5%BD%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">类的职责是否设计得越单一越好？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-%E7%90%86%E8%AE%BA%E4%BA%8C%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E2%80%9C%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%E3%80%81%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD%E2%80%9D%EF%BC%9F%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9%E5%90%84%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9C%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD%E2%80%9D%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">如何理解“对扩展开放，修改关闭”？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-%E7%90%86%E8%AE%BA%E4%B8%89%EF%BC%9A%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%EF%BC%88LSP%EF%BC%89%E8%B7%9F%E5%A4%9A%E6%80%81%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%9D%E8%83%8C%E4%BA%86LSP%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">17 | 理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9C%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E2%80%9D%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">如何理解“里氏替换原则”？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E6%98%8E%E6%98%BE%E8%BF%9D%E8%83%8C%E4%BA%86LSP%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">哪些代码明显违背了LSP？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">7.2.1.</span> <span class="nav-text">
    1、子类违背父类声明要实现的功能
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">7.2.2.</span> <span class="nav-text">
    2、子类违背父类对输入、输出、异常的约定
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">7.2.3.</span> <span class="nav-text">
    3、子类违背父类注释中所罗列的任何特殊说明
</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-%E7%90%86%E8%AE%BA%E5%9B%9B%EF%BC%9A%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%B8%89%E7%A7%8D%E5%BA%94%E7%94%A8%EF%BC%9F%E5%8E%9F%E5%88%99%E4%B8%AD%E7%9A%84%E2%80%9C%E6%8E%A5%E5%8F%A3%E2%80%9D%E8%AF%A5%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">8.0.1.</span> <span class="nav-text">如何理解接口隔离原则？

理解接口原则的关键在于理解其中的“接口”二字。实际上，“接口”这个名词可以用在很多场合中，在软件开发中，我们既可以把它看做是一组抽象的约定，也可以具体指系统与系统之间的 API 接口，还可以特指 OOPL 中的接口等。
在这条原则中，我们可以把“接口”理解成下面三样东西：

  一组 API 接口集合
  单个 API 接口或函数
  OOP 中接口的概念

接下来，我们就按照这三种理解方式来详细讲一下，在不同的场景下，这条原则是如何解读和应用的。
 把“接口”理解为一组 API 接口集合

我们通过一个例子来讲解。微服务用户系统提供了一组跟用户相关的 API 给其它系统使用，比如：注册、登录、获取用户信息等。具体代码如下：
12345678910public interface UserService {    boolean register(String cellphone, String password);    boolean login(String cellphone, String password);    UserInfo getUserInfoById(long id);    UserInfo getUserInfoByCellphone(String cellphone);}public class UserServiceImpl implements UserService {    &#x2F;&#x2F; ...}

现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户功能的接口。
当然，这个需求很简单。我们只需要在 UserService 接口中添加一个 deleteUserById() 或 deleteUserByCellphone() 方法就可以了。这的确可以解决问题，但是这样的添加方式也隐藏了一些安全隐患，不知道你发现了没有？
删除用户是一个非常慎重的操作，一般情况下，我们只希望通过后台管理系统来执行这个操作，所以这个接口最好只限定于给后台管理系统使用。如果我们把删除用户的方法放在 UserService 中，那所有使用到 UserService 的系统就都可以调用这个接口了，即使除了后台管理系统，其它系统本来就不需要这个接口。如果不加限制地被其它业务系统调用，就会导致误删用户的概率大大提高。
当然，最好的解决方案是从架构设计的层面，通过鉴权的方式来限制接口的调用。不过，我们还可以继续从代码设计的层面，来尽量避免接口被误用的概率，达到多重防护的效果。
我们参照接口隔离原则，调用者不应该被强迫依赖它不需要的接口（其实在这个例子中说的接口就是方法），将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只提供给后台管理系统来使用。
123456789101112131415public interface UserService {    boolean register(String cellphone, String password);    boolean login(String cellphone, String password);    UserInfo getUserInfoById(long id);    UserInfo getUserInfoByCellphone(String cellphone);}public interface RestrictedUserService {    boolean deleteUserById();    boolean deleteUserByCellphone();}public class UserServiceImpl implements UserService, RestrictedUserService {    &#x2F;&#x2F; ...}

在刚刚的这个例子中，我们把 ISP 中的“接口”理解为一组接口（或者叫函数）集合。它可以是某个微服务的接口，也可以是某个类库的接口。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其它调用者也依赖这部分不会被用到的接口。
把“接口”理解成单个 API 接口或函数

现在我们再换一种理解方式，把接口理解为单个接口或函数（为了方便讲解，下面将都简称为“函数”）。
那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。
其实可以想到的是，函数的功能越复杂，其复用性就越差，因为不会有很多地方都要使用特别复杂的功能。一般而言，复杂功能都是通过简单功能堆叠实现的，而不是直接实现一个非常复杂的功能。所以，你如果在某一个小单元内写了一段非常复杂的代码，实现了很多功能，但是每次调用的时候可能只是使用了其中一个或很少几个功能，那大多数的功能是用不到的，这也就相当于调用者 Client 虽然没用到，但是这个小单元内的程序确确实实要从头走到尾，这就相当于是一种强买强卖，是违反 ISP 的。
我们通过一个例子来理解一下。
12345678910111213public class Statistics {    private long max;    private long min;    private long avg;    private long sum;    &#x2F;&#x2F; 省略 getter&#x2F;setter&#x2F;constructor}public Statistics count(Collection&lt;Long&gt; dataSet){    Statistics statistics &#x3D; new Statistics();    &#x2F;&#x2F; 省略计算逻辑    return statistics;}





接口隔离原则跟单一职责原则还有点类似，它们的区别和联系是什么？
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">8.0.2.</span> <span class="nav-text"> 把“接口”理解为一组 API 接口集合

我们通过一个例子来讲解。微服务用户系统提供了一组跟用户相关的 API 给其它系统使用，比如：注册、登录、获取用户信息等。具体代码如下：
12345678910public interface UserService {    boolean register(String cellphone, String password);    boolean login(String cellphone, String password);    UserInfo getUserInfoById(long id);    UserInfo getUserInfoByCellphone(String cellphone);}public class UserServiceImpl implements UserService {    &#x2F;&#x2F; ...}

现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户功能的接口。
当然，这个需求很简单。我们只需要在 UserService 接口中添加一个 deleteUserById() 或 deleteUserByCellphone() 方法就可以了。这的确可以解决问题，但是这样的添加方式也隐藏了一些安全隐患，不知道你发现了没有？
删除用户是一个非常慎重的操作，一般情况下，我们只希望通过后台管理系统来执行这个操作，所以这个接口最好只限定于给后台管理系统使用。如果我们把删除用户的方法放在 UserService 中，那所有使用到 UserService 的系统就都可以调用这个接口了，即使除了后台管理系统，其它系统本来就不需要这个接口。如果不加限制地被其它业务系统调用，就会导致误删用户的概率大大提高。
当然，最好的解决方案是从架构设计的层面，通过鉴权的方式来限制接口的调用。不过，我们还可以继续从代码设计的层面，来尽量避免接口被误用的概率，达到多重防护的效果。
我们参照接口隔离原则，调用者不应该被强迫依赖它不需要的接口（其实在这个例子中说的接口就是方法），将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只提供给后台管理系统来使用。
123456789101112131415public interface UserService {    boolean register(String cellphone, String password);    boolean login(String cellphone, String password);    UserInfo getUserInfoById(long id);    UserInfo getUserInfoByCellphone(String cellphone);}public interface RestrictedUserService {    boolean deleteUserById();    boolean deleteUserByCellphone();}public class UserServiceImpl implements UserService, RestrictedUserService {    &#x2F;&#x2F; ...}

在刚刚的这个例子中，我们把 ISP 中的“接口”理解为一组接口（或者叫函数）集合。它可以是某个微服务的接口，也可以是某个类库的接口。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其它调用者也依赖这部分不会被用到的接口。
把“接口”理解成单个 API 接口或函数

现在我们再换一种理解方式，把接口理解为单个接口或函数（为了方便讲解，下面将都简称为“函数”）。
那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。
其实可以想到的是，函数的功能越复杂，其复用性就越差，因为不会有很多地方都要使用特别复杂的功能。一般而言，复杂功能都是通过简单功能堆叠实现的，而不是直接实现一个非常复杂的功能。所以，你如果在某一个小单元内写了一段非常复杂的代码，实现了很多功能，但是每次调用的时候可能只是使用了其中一个或很少几个功能，那大多数的功能是用不到的，这也就相当于调用者 Client 虽然没用到，但是这个小单元内的程序确确实实要从头走到尾，这就相当于是一种强买强卖，是违反 ISP 的。
我们通过一个例子来理解一下。
12345678910111213public class Statistics {    private long max;    private long min;    private long avg;    private long sum;    &#x2F;&#x2F; 省略 getter&#x2F;setter&#x2F;constructor}public Statistics count(Collection&lt;Long&gt; dataSet){    Statistics statistics &#x3D; new Statistics();    &#x2F;&#x2F; 省略计算逻辑    return statistics;}





接口隔离原则跟单一职责原则还有点类似，它们的区别和联系是什么？
</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">8.0.3.</span> <span class="nav-text">把“接口”理解成单个 API 接口或函数

现在我们再换一种理解方式，把接口理解为单个接口或函数（为了方便讲解，下面将都简称为“函数”）。
那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。
其实可以想到的是，函数的功能越复杂，其复用性就越差，因为不会有很多地方都要使用特别复杂的功能。一般而言，复杂功能都是通过简单功能堆叠实现的，而不是直接实现一个非常复杂的功能。所以，你如果在某一个小单元内写了一段非常复杂的代码，实现了很多功能，但是每次调用的时候可能只是使用了其中一个或很少几个功能，那大多数的功能是用不到的，这也就相当于调用者 Client 虽然没用到，但是这个小单元内的程序确确实实要从头走到尾，这就相当于是一种强买强卖，是违反 ISP 的。
我们通过一个例子来理解一下。
12345678910111213public class Statistics {    private long max;    private long min;    private long avg;    private long sum;    &#x2F;&#x2F; 省略 getter&#x2F;setter&#x2F;constructor}public Statistics count(Collection&lt;Long&gt; dataSet){    Statistics statistics &#x3D; new Statistics();    &#x2F;&#x2F; 省略计算逻辑    return statistics;}





接口隔离原则跟单一职责原则还有点类似，它们的区别和联系是什么？
</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="设计模式之美（Part2） | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式之美（Part2）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-20 13:48:14" itemprop="dateCreated datePublished" datetime="2022-03-20T13:48:14+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-25 20:25:27" itemprop="dateModified" datetime="2022-03-25T20:25:27+08:00">2022-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="11-实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"><a href="#11-实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？" class="headerlink" title="11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"></a>11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</h1><p>​    我们都知道，很多业务系统都是基于MVC三层架构来开发的。实际上，更确切点讲，<u>这是一种基于贫血模型的MVC三层架构开发模式。</u></p>
<p>​    虽然这种开发模式已经成为标准的Web项目的开发模式，但它却违反了面向对象风格，是一种彻彻底底的面向过程编程风格，因而被有些人称为反模式。特别是<strong>领域驱动设计（Domain Driven Design，DDD）</strong>盛行之后，这种基于贫血模型的传统开发模式就更加被人诟病。而基于充血模型的DDD开发模式越来越被人提倡。所以，接下来我们将结合一个虚拟钱包系统的开发案例，带你彻底搞懂这两种开发模式。</p>
<p>在正式进入实战项目之前，我们先要搞清楚下面几个问题：</p>
<blockquote>
<ul>
<li>  什么是贫血模型？什么是充血模型？</li>
<li>  为什么说基于贫血模型的传统开发模式违反OOP？</li>
<li>  基于贫血模型的传统开发模式既然违反OOP，那为什么又如此流行？</li>
<li>  什么情况下我们应该考虑使用基于充血模型的DDD开发模式？</li>
</ul>
</blockquote>
<h2 id="什么是基于贫血模型的传统开发模式？"><a href="#什么是基于贫血模型的传统开发模式？" class="headerlink" title="什么是基于贫血模型的传统开发模式？"></a>什么是基于贫血模型的传统开发模式？</h2><p>​    MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层，展示层、逻辑层、数据层。MVC三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会100%遵从MVC固定的分层模式，而是会根据具体的项目需求，做适当的调整。</p>
<p>​    比如，现在很多项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为Repository层、Service层、Controller层。其中，Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目，不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的Web项目，基本的分层思路都大差不差。</p>
<p>​    上面我们简单介绍了MVC三层开发架构。现在，我们再来看一下，什么是贫血模型？</p>
<p>​    实际上，你可能一直在用贫血模型做开发，只是自己不知道而已。不夸张地讲，目前几乎所有的业务后端系统，都是基于贫血模型的。我们来看一个简单的例子来具体理解一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Controller+VO（View Object）   //</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserBo <span class="title function_">getUserById</span><span class="params">(Long userId)</span>&#123;</span><br><span class="line">        <span class="type">UserBo</span> <span class="variable">userBo</span> <span class="operator">=</span> userService.getUserById(userId);</span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> [...convert userBo to userVo...];</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVo</span> &#123; <span class="comment">// 省略其它属性、get/set/construct方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      Service+BO（Business Object）   //</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserBo <span class="title function_">getUserById</span><span class="params">(Long userId)</span>&#123;</span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">userEntity</span> <span class="operator">=</span> userRepository.getUserById(userId);</span><br><span class="line">        <span class="type">UserBo</span> <span class="variable">userBo</span> <span class="operator">=</span> [...convert userEntity to userBo...];</span><br><span class="line">        <span class="keyword">return</span> userBo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBo</span> &#123; <span class="comment">// 省略其它属性、get/set/construct方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      Repository+Entity    //</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserEntity <span class="title function_">getUserById</span><span class="params">(Long userId)</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEntity</span> &#123; <span class="comment">// 省略其它属性、get/set/construct方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cellphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们平时开发Web后端项目的时候，基本上都是这么组织代码的。其中，UserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层。</p>
<p>​    从代码中，我们可以发现，UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话说，Service 层的数据和业务逻辑，被分割到 BO 和 Service 两个类中。像 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫做<strong>贫血模型（Anemic Domain Model）</strong>。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据和操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p>
<h2 id="什么是基于充血模型的DDD开发模式？"><a href="#什么是基于充血模型的DDD开发模式？" class="headerlink" title="什么是基于充血模型的DDD开发模式？"></a>什么是基于充血模型的DDD开发模式？</h2><p>​    上面讲了基于贫血模型的传统开发模式。现在我们再来了解一下，另一种目前更为推崇的开发模式：基于充血模型的DDD开发模式。</p>
<p><strong>首先，我们来了解一下，什么是充血模型？</strong></p>
<p>​    在贫血模型中，数据和业务逻辑被分割到不同的类中。<strong>充血模型（Rich Domain Model）</strong>正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象封装的特性，是典型的面向对象的编程风格。</p>
<p><strong>接下来，我们再来了解一下，什么是领域驱动设计（DDD）？</strong></p>
<p>​    领域驱动设计（DDD），主要用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，早在2004年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是“微服务”。</p>
<p>​    我们知道，除了监控、调用链路追踪、API网关等服务治理系统的开发之外，<u>微服务还有一个更重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。</u>所以说，微服务加速了领域驱动设计的盛行。</p>
<p>​    不过，我个人觉得，领域驱动设计有点儿类似于敏捷开发、SOA、PAAS等概念，听起来很高大上，但实际上只值“五分钱”。即便你没有听说过领域驱动设计，对这个概念一无所知，只要你开发过业务系统，就或多或少的用过它。做好领域驱动设计的关键是，看你对自己所做的业务的熟悉程度，而并不是你对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动设计搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计。所以，不要把领域驱动设计当成银弹，不要花太多的时间去过度研究它。</p>
<p>​    实际上，基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的。Controller层还是负责暴露接口，Repository层还是负责数据存取，Service层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的主要区别主要在Service层。</p>
<p>​    在基于贫血模型的传统开发模式中，Service层包含Service类和BO类两部分，BO是贫血模型，只包含数据，不包含具体的业务逻辑，业务逻辑集中在Service类中。在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain类就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而Service类变得非常轻薄。总结一下就是。<u>基于贫血模型的传统开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain</u>。</p>
<h2 id="为什么基于贫血模型的传统开发模式如此受欢迎？"><a href="#为什么基于贫血模型的传统开发模式如此受欢迎？" class="headerlink" title="为什么基于贫血模型的传统开发模式如此受欢迎？"></a>为什么基于贫血模型的传统开发模式如此受欢迎？</h2><p>​    前面我们讲过，基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了OOP的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的Web项目，都是基于这种贫血模型的开发模式，甚至连Spring框架的官方demo，都是按照这种开发模式来编写的。</p>
<p>​    我们前面也讲过，面向过程编程风格有种种弊端，比如：数据和操作分离之后，数据本身的操作就不受限制了，任何代码在任何位置都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个原因，我总结了以下三点原因。</p>
<ol>
<li> 大部分情况下，我们开发的业务系统可能都比较简单，简单到就是基于SQL的CRUD操作，所以我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单的业务开发工作。除此之外，因为业务比较简单，即使我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。</li>
<li> 充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始设计就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑，而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在Service层定义什么操作，不需要实现做太多设计。</li>
<li> 思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深入人心、习以为常。你随便问旁边一个大龄同事，基本上他参与过的所有Web项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事的。</li>
</ol>
<h2 id="什么项目应该考虑使用基于充血模型的DDD开发模式？"><a href="#什么项目应该考虑使用基于充血模型的DDD开发模式？" class="headerlink" title="什么项目应该考虑使用基于充血模型的DDD开发模式？"></a>什么项目应该考虑使用基于充血模型的DDD开发模式？</h2><p>​    既然基于贫血模型的开发模式已经成为了一种约定俗成的开发习惯，那什么样的项目应该考虑使用基于充血模型的DDD开发模式呢？</p>
<p>​    刚刚我们讲到，基于贫血模型的传统开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的DDD开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p>
<p>​    你可能会有一些疑问，这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到Service类中，一个将业务逻辑放到Domain领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的DDD开发模式就可以呢？</p>
<p>​    实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到Service层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的DDD开发模式的开发流程，在应对复杂业务系统开发的时候更有优势。为什么这么说呢？我们先来回忆一下，我们平时基于贫血模型的传统开发模式是怎么实现一个需求的。</p>
<p>​    不夸张的讲，我们平时的开发，大部分都是SQL驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中需要哪几张表，然后思考如何编写SQL语句来获取数据。之后就是定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码。</p>
<p>​    业务逻辑包裹在一个大的SQL中，而Service层可以做的事情很少。SQL都是针对特定的业务功能编写的，复用性差。当我们要开发另一个业务功能的时候，只能重新写条满足需求的SQL语句，这就可能导致各种长得差不多、区别很小的SQL语句满天飞。</p>
<p>​    所以，在这个过程中，很少有人会应用领域模型、OOP的概念，也很少有代码复用意识。对简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。</p>
<p>​    如果我们在项目中，应用了基于充血模型的DDD开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都是基于之前定义好的这些领域模型来完成。</p>
<p>​    我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的DDD开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。</p>
<hr>
<h1 id="12-实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"><a href="#12-实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？" class="headerlink" title="12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"></a>12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？</h1><h2 id="钱包业务背景介绍"><a href="#钱包业务背景介绍" class="headerlink" title="钱包业务背景介绍"></a>钱包业务背景介绍</h2><p>​    很多具有支付、购买功能的应用（如淘宝、滴滴、极客时间等）都支持虚拟钱包功能。应用会为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转增、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面，你可以直观地感受一下。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/9e91377602ef154eaf866c7e9263a64a.jpg" alt="img"></p>
<p>​    一般来说，每个虚拟钱包账户都会对应用户的一个真实的支付账户，可能是银行卡账户，也有可能是第三方支付账户（比如支付宝、微信钱包）。为了方便后续的讲解，我们限定钱包暂时只支持充值、提现、查询余额、查询交易流水这五个核心功能，其它如冻结、透支、转增等不常用的功能暂不考虑。接下来，我们首先来看一下这五个核心功能的业务实现流程。</p>
<h3 id="1、充值"><a href="#1、充值" class="headerlink" title="1、充值"></a>1、充值</h3><p>​    用户通过第三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。整个过程我们可以分解为三个阶段：第一阶段是从用户的银行卡账户转账到应用的公共银行卡账户；第二个阶段是将用户充值的金额加到用户的虚拟钱包余额上；第三阶段是记录刚刚这笔交易流水。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/3915a6544403854d35678c81fe65f014.jpg" alt="img"></p>
<h3 id="2、支付"><a href="#2、支付" class="headerlink" title="2、支付"></a>2、支付</h3><p>​    用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户转钱到商家的虚拟钱包账户上，然后触发真正的银行转账操作，从应用的公共银行账户转钱到商家的银行账户（注意，这里并不是从用户的银行账户转钱到商家的银行账户）。除此之外，我们也需要记录这笔支付的交易流水信息。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322101917924.png" alt="image-20220322101917924"></p>
<h3 id="3、提现"><a href="#3、提现" class="headerlink" title="3、提现"></a>3、提现</h3><p>​    除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/66ede1de93d29b86a9194ea0f80d1e43.jpg" alt="img"></p>
<h3 id="4、查询余额"><a href="#4、查询余额" class="headerlink" title="4、查询余额"></a>4、查询余额</h3><p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p>
<h3 id="5、查询交易流水"><a href="#5、查询交易流水" class="headerlink" title="5、查询交易流水"></a>5、查询交易流水</h3><p>​    查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会生成记录响应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p>
<h2 id="钱包系统的设计思路"><a href="#钱包系统的设计思路" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h2><p>​    根据刚刚讲的业务实现流程和数据流转图，我们可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。基于这样一个业务划分，我们可以将系统解耦、拆分成两个子系统：虚拟钱包系统和第三方支付系统。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/60d3cfec73986b52e3a6ef4fe147e562.jpg" alt="img"></p>
<p>而我们接下来将只聚焦于虚拟钱包系统的设计与实现。</p>
<p><strong>现在我们来看一下，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。</strong>下面这张图列出了这五个功能都会对应虚拟钱包的哪些操作。注意，交易流水的记录和查询，我暂时在图中打了个问号，因为这块比较特殊，我们在用到的时候再讲。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/d1a9aeb6642404f80a62293ab2e45630.jpg" alt="img"></p>
<p>从图中我们可以看出，虚拟钱包系统要支持的操作非常简单，就是余额的加加减减。其中，充值、提现、查询余额三个功能，只涉及一个账户余额的加减操作，而支付功能涉及两个账户余额的加减操作：一个账户加余额，另一个账户减余额。</p>
<p><strong>现在，我们再来看一下图中的问号部分，即交易流水应该如何记录和查询？</strong>我们先来看一下，交易流水都需要包含哪些信息。我觉得下面这几个信息是必需的。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/38b56bd1981d8b40ececa4d638e4a968.jpg" alt="img"></p>
<p>从图中我们可以发现，交易流水的数据格式包含两个钱包账号，一个是入账钱包账号，一个是出账钱包账号。为什么要有两个账号信息呢？这主要是为了兼容支付这种涉及两个账户的交易类型。不过，对于充值、提现这两种交易类型来说，我们只需要记录一个钱包账户信息就够了，所以，这样的交易流水数据格式的设计稍微有点浪费存储空间。</p>
<p>实际上，我们还有另外一种交易流水数据格式的设计思路，可以解决这个问题。我们把“支付”这个交易类型拆分为两个子类型：支付和被支付。支付单纯表示出账，余额扣减，被支付单纯表示入账，余额增加。这样我们在设计交易流水数据格式的时候，只需要记录一个账户信息即可。我画了一张两种交易流水数据格式的对比图，你可以看一下。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322102527802.png" alt="image-20220322102527802"></p>
<p><strong>那以上两种交易流水数据格式的设计思路，你觉得哪一个更好呢？</strong></p>
<p>答案是第一种设计思路更好一些。因为交易流水有两个功能：一个是业务功能，比如，提供用户查询交易流水信息；另一个是非业务功能，保证数据的一致性。这里主要指支付操作数据的一致性。</p>
<p>支付实际上就是一个转账的操作，在一个账户上加上一定的金额，在另一个账户上减去相应的金额。我们需要保证加金额和减金额这两个操作，要么都成功，要么都失败。如果一个成功，一个失败，就会导致数据的不一致，一个账户明明减掉了钱，另一个账户却没有收到钱。</p>
<p>保证数据一致性的方法有很多，比如，依赖数据库事务的原子性，将两个操作放在同一个事务中执行。但是，这样的做法不够灵活，因为我们有可能做了分库分表，支付涉及的两个账户存储在不同的库中，无法直接利用数据库本身的事务特性，在一个事务中执行两个账户的操作。当然，我们还有一些支持分布式事务的开源框架，但是，为了保证数据的强一致性，它们的实现逻辑一般比较复杂、本身的性能也不高，会影响业务的执行时间。所以，<u>更加权衡的一种做法就是，不保证数据的强一致性。只实现数据的最终一致性。</u></p>
<p>对于支付这样的类似转账的操作，我们在操作两个钱包账户余额之前，先记录交易流水，并且标记为“待执行”，当两个钱包的加减金额都完成之后，我们再回过头来，将交易流水标记为“成功”。在给两个钱包加减金额的过程中，如果有任意一个操作失败，我们就将交易记录的状态标记为“失败”。我们通过后台补漏Job，拉取状态为“失败”或者长时间处于“待执行”状态的交易记录，重新执行或者人工介入处理。</p>
<p>如果选择第二种交易流水的设计思路，使用两条交易流水来记录支付操作，那记录两条交易流水本身又存在数据一致性问题，有可能入账的交易流水记录成功，出账的交易流水信息记录失败。所以，权衡利弊，我们选择第一种稍微有些冗余的数据格式设计思路。</p>
<p><strong>现在，我们再思考这样一个问题：充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？换句话说，我们是否应该在虚拟钱包系统的交易流水中记录这三种类型？</strong></p>
<p>答案是否定的。虚拟钱包系统不应该感知具体的业务交易类型。我们前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务的概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。</p>
<p>但是，<strong>如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水时，如何显示每条交易流水的交易类型呢？</strong></p>
<p>从系统设计的角度，我们不应该在虚拟钱包系统的交易流水中记录交易类型。从产品需求的角度来说，我们又必须记录交易流水的交易类型。听起来比较矛盾，这个问题该如何解决呢？</p>
<p>我们可以通过记录两条交易流水信息来解决。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和第三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以我们在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。</p>
<p>为了让你更好地理解刚刚的设计思路，我画了一张图，可以对比着讲解一块儿来看。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322102706010.png" alt="image-20220322102706010"></p>
<p>我们通过查询上层钱包系统的交易流水信息，去满足用户查询交易流水的功能需求，而虚拟钱包中的交易流水就只是用来解决数据一致性问题。实际上，它的作用还有很多，比如用来对账等。</p>
<p>整个虚拟钱包系统的设计思路到此讲完了。接下来，我们来看一下，如何分别用基于贫血模型的传统开发模式和基于充血模型的DDD开发模式，来实现这样的一个虚拟钱包系统？</p>
<h2 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h2><p>设计采用典型的Web后端项目三层架构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法。在这里省略了具体的代码实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line">    <span class="keyword">private</span> VirtualWalletService virtualWalletService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">(Long walletId)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 查询余额</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 出账</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 入账</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 转账</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。Repository 这一层的代码实现比较简单，不是我们讲解的重点，所以我也省略掉了。Service 层的代码如下所示。注意，这里我省略了一些不重要的代码校验，比如，对 amount 是否小于0、钱包是否存在的校验等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletBo</span> &#123; <span class="comment">// 省略getter/setter/constructor方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TransactionType</span> &#123;</span><br><span class="line">    DEBIT,  <span class="comment">// 出账</span></span><br><span class="line">    CREDIT, <span class="comment">// 入账</span></span><br><span class="line">    TRANSFER <span class="comment">// 交易</span></span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line">    <span class="keyword">private</span> VirtualWalletRepository walletRepo; </span><br><span class="line">    <span class="keyword">private</span> VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> VirtualWalletBo <span class="title function_">getVirtualWallet</span><span class="params">(Long walletId)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">wallerEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">VirtualWalletBo</span> <span class="variable">walletBo</span> <span class="operator">=</span> convert(wallerEntity);</span><br><span class="line">        <span class="keyword">return</span> walletBo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">(Long walletId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> walletRepo.getBalance(walletId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> walletEntity.getBalance();</span><br><span class="line">        <span class="keyword">if</span> (balance.compareTo(amount) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSufficientBalanceException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        walletRepo.updateBalance(walletId, balance.subtract(amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> walletEntity.getBalance();</span><br><span class="line">        walletRepo.updateBalance(walletId, balance.add(amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录交易流水（含交易类型）</span></span><br><span class="line">        <span class="type">VirtualWalletTransactionEntity</span> <span class="variable">transactionEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualWalletTransactionEntity</span>();</span><br><span class="line">        transactionEntity.setAmount(amount);</span><br><span class="line">        transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">        transactionEntity.setType(TransactionType.TRANSFER);</span><br><span class="line">        transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">        transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">        transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行账户出/入账操作</span></span><br><span class="line">        debit(fromWalletId, amount);</span><br><span class="line">        credit(toWalletId, amount);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是利用基于贫血模型的传统开发模式实现的虚拟钱包系统，尽管我们对代码稍微做了一些简化，但整体的业务逻辑是类似的。并且代码逻辑都非常简单，理解起来没有难度。</p>
<h2 id="基于充血模型的DDD开发模式"><a href="#基于充血模型的DDD开发模式" class="headerlink" title="基于充血模型的DDD开发模式"></a>基于充血模型的DDD开发模式</h2><p>刚刚讲了如何利用基于贫血模型的传统开发模式来实现虚拟钱包系统，现在，我们再来看一下，如何利用基于充血模型的DDD开发模式来实现这个模式。</p>
<p>在上一节中我们讲过，基于充血模型的DDD开发模式，跟基于贫血模型的传统开发模式的主要区别就在Service层，Controller层和Repository层的代码基本上相同。所以，我们重点看一下，Service层按照基于充血模型的DDD开发模式该如何来实现。</p>
<p>在这种开发模式下，我们把虚拟钱包 VirtualWallet 类设计成一个 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的依赖 VirtualWallet 类。具体的实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWallet</span> &#123; <span class="comment">// Domain领域模型（充血模型）</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">createTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VirtualWallet</span><span class="params">(Long preAllocatedId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = preAllocatedId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance.compareTo(amount) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSufficientBalanceException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.add(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line">    <span class="keyword">private</span> VirtualWalletRepository walletRepo;</span><br><span class="line">    <span class="keyword">private</span> VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> VirtualWallet <span class="title function_">getVirtualWallet</span><span class="params">(Long walletId)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">wallerEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">VirtualWallet</span> <span class="variable">wallet</span> <span class="operator">=</span> convert(wallerEntity);</span><br><span class="line">        <span class="keyword">return</span> wallet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">(Long walletId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> walletRepo.getBalance(walletId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">VirtualWallet</span> <span class="variable">wallet</span> <span class="operator">=</span> convert(wallerEntity);</span><br><span class="line">        wallet.debit(amount);</span><br><span class="line">        walletRepo.updateBalance(walletId, wallet.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">VirtualWallet</span> <span class="variable">wallet</span> <span class="operator">=</span> convert(wallerEntity);</span><br><span class="line">        wallet.credit(amount);</span><br><span class="line">        walletRepo.updateBalance(walletId, wallet.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录交易信息</span></span><br><span class="line">        <span class="type">VirtualWalletTransactionEntity</span> <span class="variable">transactionEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualWalletTransactionEntity</span>();</span><br><span class="line">        transactionEntity.setAmount(amount);</span><br><span class="line">        transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">        transactionEntity.setType(TransactionType.TRANSFER);</span><br><span class="line">        transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">        transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">        transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行账户出/入账操作</span></span><br><span class="line">        debit(fromWalletId, amount);</span><br><span class="line">        credit(toWalletId, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    看了上面的代码，你应该会发现，在领域模型 VirtualWallet 类也并没有很丰满，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大的优势。你想的没错！这也正是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这时候，我们重新来看一下 VirtualWallet 类的实现代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWallet</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">createTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isAllowedOverdraft</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 是否允许透支</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">overdraftAmount</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">frozenAmount</span> <span class="operator">=</span> BigDecimal.ZERO; <span class="comment">// 冻结金额</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VirtualWallet</span><span class="params">(Long preAllocatedId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = preAllocatedId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">freeze</span><span class="params">()</span> (BigDecimal amount)&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfreeze</span><span class="params">()</span> (BigDecimal amount)&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseOverdraftAmount</span><span class="params">()</span> (BigDecimal amount)&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseOverdraftAmount</span><span class="params">()</span> (BigDecimal amount)&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeOverdraft</span><span class="params">()</span> ()&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openOverdraft</span><span class="params">()</span> ()&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getAvailableBalance</span><span class="params">()</span>&#123; <span class="comment">// 获取可用余额</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalAvailableBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance.subtract(frozenAmount);</span><br><span class="line">        <span class="keyword">if</span> (isAllowedOverdraft)&#123;</span><br><span class="line">            totalAvailableBalance += <span class="built_in">this</span>.overdraftAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalAvailableBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance.compareTo(amount) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSufficientBalanceException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.add(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>领域模型 VirtualWallet 类添加了简单的冻结和透支逻辑之后，功能就看起来丰富了很多，代码也没有那么单薄了。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号自动生成的逻辑（而不是通过构造函数从外部传入ID，而是通过分布式ID算法来自动生成ID）等等。VirtualWallet 类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。</p>
<h2 id="辩证思考与灵活应用"><a href="#辩证思考与灵活应用" class="headerlink" title="辩证思考与灵活应用"></a>辩证思考与灵活应用</h2><p>对于虚拟钱包系统设计的两种开发模式的代码实现，相信你应该已经有一个比较清晰的了解了。不过，我觉得还有两个问题值得讨论一下。</p>
<p><strong>【问题一】在居于充血模型的DDD开发模式中，将业务逻辑移动到Domain中，Service类就会变得很单薄，但在我们的代码设计与实现中，并没有完全将Service类去掉，这是为什么？或者说，Service类在这种情况下担当的职责是神？哪些功能逻辑会放到Service类中？</strong></p>
<p>区别于 Domain 的职责，Service 类主要有下面这样几个职责。</p>
<ol>
<li><p>Service 类负责与 Repository 交流。在我的设计与代码实现中，VirtualWalletService 负责与 Repository 层打交道，调用 Repository 类的方法，获取数据库中的数据，转换成领域模型 VirtualWallet，然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用 Repository 类的方法，将数据存回数据库。</p>
<p> 之所以让 VirtualWalletService 类域 Repository 层打交道，而不是让领域模型 VirtualWallet 直接与 Repository 打交道，那是因为我们想保持领域模型的独立性，不与任何其它层的代码（Repository 层的代码）或开发框架（比如Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从DB中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。</p>
</li>
<li><p> Service 类负责跨领域模型的业务聚合功能。VirtualWalletService 类中的 transfer() 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，我们暂且把转账业务放到 VirtualWalletService 类中了。当然，随着功能演进，使得转账业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型。</p>
</li>
<li><p> Service 类负责一些非功能性及与第三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其它系统的 RPC 接口等，都可以放到 Service 类中。</p>
</li>
</ol>
<p><strong>【问题二】在基于充血模型的DDD开发模式中，尽管Service层被改造成了充血模型，但是Controller层和Repository层还是贫血模型，是否有必要也进行充血领域建模呢？</strong></p>
<p>答案是没有必要。Controller层主要负责接口的暴露，Repository层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没有必要做充血模型，即使设计成充血模型，类也非常单薄，看起来也很奇怪。</p>
<p>尽管这样的设计是一种面向过程的编程风格，但是只要我们控制好面向过程编程的副作用，照样可以开发出优秀的软件。那这里的副作用怎么控制呢？</p>
<p>就拿Repository的Entity来说，即便它被设计成贫血模型，违反面向对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。一般来讲，我们把它传递到 Service 层之后，就会转换成 BO 或 Domain 来继续后面的业务逻辑。Entity 的生命周期到此就结束了，所以也并不会被导出任意修改。</p>
<p>我们再来说说 Controller 层的 VO。实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输载体，将数据发送给其它系统，从功能上来讲，它不应该包含业务逻辑，只包含数据。所以，我们将它设计成贫血模型也是比较合理的。</p>
<hr>
<h1 id="13-实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析"><a href="#13-实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析" class="headerlink" title="13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析"></a>13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析</h1><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。在前面的章节中，我们主要介绍了这三者相关的方法论，目的是为了能让你先有一个宏观的了解，知道什么是 OOA、OOD、OOP。不过，光直到“是什么”是不够的，我们更重要的还是要知道“如何做”，也就是，如何进行面向对象分析、设计与编程。</p>
<p>大部分的初级开发工程师，本身并没有太多的项目经验，或者参与的项目都是基于框架填写 CRUD 模板似的代码，导致分析、设计能力比较欠缺。当他们拿到一个比较笼统的开发需求的时候，往往不知道从何入手。</p>
<p>对于“如何做需求分析，如何做职责划分？需要定义哪些类？每个类应该具有哪些属性、方法？类与类之间应该如何交互？如何组装类成为一个可执行的程序？”等等诸多问题，都没有清晰的思路，更别提利用成熟的设计原则、思想或者设计模式，开发出具有高内聚低耦合、易扩展、易读等优秀特性的代码了。</p>
<p>所以，接下来的两节课时间，我们将结合一个真实的开发案例，从基础的需求分析、职责划分、类的定义、交互、组装运行讲起，将最基础的面向对象分析、设计、编程的套路给你讲清楚，为后面学习设计原则、设计模式打好基础。</p>
<h2 id="案例介绍和难点剖析"><a href="#案例介绍和难点剖析" class="headerlink" title="案例介绍和难点剖析"></a>案例介绍和难点剖析</h2><p>假设，你正在参与开发一个微服务。微服务通过HTTP协议暴露接口给其它系统调用，也就是其它系统通过 URL 来调用微服务的接口。某天，你的 Leader 找到你说：为了保证接口调用的安全性，我们希望设计一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。</p>
<p>Leader 丢下这句话就走了。这个时候，你该如何来做呢？是不是脑子里一团浆糊，一时间无从下手。为什么会有这种感觉呢？我个人觉得主要有以下两点原因。</p>
<ol>
<li> <strong>需求不明确</strong></li>
</ol>
<p>Leader 给的需求过于模糊、笼统、不够具体、细化，离落地到设计、编码还有一定的距离。而人的大脑不擅长思考这种过于抽象的问题。这也是真实软件开发区别于应试教育的地方。应试教育中的考试题目，一般都是一个非常具体的问题，我们去解答就好了。而真实的软件开发中，需求几乎都不明确。</p>
<p>我们前面讲过，面向对象分析主要分析的对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”。实际上，不管是需求分析还是面向对象分析，我们首先要做的就是将笼统的需求细化到足够清晰、可执行。我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑的。</p>
<ol start="2">
<li> <strong>缺少锻炼</strong></li>
</ol>
<p>相比于单纯的业务CRUD开发，鉴权这个开发任务，要更有难度。鉴权作为一个跟具体业务无关的功能，我们完全可以把它开发成一个独立的框架，集成到很多业务系统中。而作为被很多系统复用的通用框架，比起普通的业务代码，我们对框架的代码质量要求更高。</p>
<p>开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力、甚至罗辑思维能力的要求，都是比较高的。如果你平时做的都是简单的 CRUD 业务开发，一旦遇到这种开发需求，很容易因为缺少锻炼，不知道从何入手，完全没有思路。</p>
<h2 id="对案例进行需求分析"><a href="#对案例进行需求分析" class="headerlink" title="对案例进行需求分析"></a>对案例进行需求分析</h2><p>实际上，需求分析的工作很琐碎，也没有太多固定的章法可寻，所以，我们不打算在这里讲很多那些听着有用、实际没用的方法论，而是希望通过鉴权这个例子，来给你展示一下，面对需求分析的时候，我的完整的思考路径是什么样的。希望你能自己去体会，举一反三地类比应用到其它项目的需求分析中。</p>
<p>尽管针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求，但这不代表我们就可以脱离具体的应用场景，闷头拍脑袋做分析。多跟业务团队沟通，甚至自己去参与几个业务系统的开发，只有这样，我们才能真正知道业务系统的痛点，才能分析出最有价值的需求。不对，针对鉴权这一功能的开发，最大的需求方还是我们自己，所以，我们也可以先从满足我们自己系统的需求开始，然后再迭代优化。</p>
<p>现在，我们来看一下，针对鉴权这个功能的开发，我们应该如何做需求分析？</p>
<p>实际上，这跟做算法题一样，先从简单的方案想起，然后再优化。所以，我把整个分析过程分为了循序渐进的四轮。每一轮都是对上一轮的迭代优化，最终形成一个可执行、可落地的需求列表。</p>
<h3 id="1、第一轮需求分析"><a href="#1、第一轮需求分析" class="headerlink" title="1、第一轮需求分析"></a>1、第一轮需求分析</h3><p>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过“用户名+密码”来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。如果一致，说明请求成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<h3 id="2、第二轮分析优化"><a href="#2、第二轮分析优化" class="headerlink" title="2、第二轮分析优化"></a>2、第二轮分析优化</h3><p>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。那如果我们借助加密算法（比如SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？实际上，这样也是不安全的，因为加密之后的密码和 AppID，照样可以被未认证系统（或者说黑客）截获，未认证系统就可以携带这个加密之后的密码以及对应的 AppID，伪装成已认证系统来访问我们的所有接口。这就是典型的“<strong>重放攻击</strong>”。</p>
<p>提出问题，然后再解决问题，这是一个非常好的迭代优化方法。对于刚刚这个问题，我们可以借助 OAuth 的验证思路来解决。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后再进行加密，生成一个 token。调用方在进行接口请求的时候，将这个 token 及 AppID，随 URL 一起传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法用 URL、AppID、密码生成另外一个 token。用这个新生成的 token 跟调用方传递过来的 token 进行比对。如果一致，则运行接口调用请求，否则，就拒绝接口调用请求。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322125659233.png" alt="image-20220322125659233"></p>
<h3 id="3、第三轮分析优化"><a href="#3、第三轮分析优化" class="headerlink" title="3、第三轮分析优化"></a>3、第三轮分析优化</h3><p>不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个 URL 拼接上 AppID、密码后生成的 token 都是固定的。未认证系统截获到 URL、AppID 和 token 之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个 URL <strong>对应</strong>的接口。 只不过此时未认证系统不能像之前一样在获取到 AppID 和密码后，一次性访问微服务端的所有接口罢了。但它还是可以通过多次拦截、记录，最终获取到所有接口的访问权限。</p>
<p>为了解决这个问题，我们可以进一步优化 token 生成算法，引入一个随机变量，让每次接口请求生成的 token 都不一样。我们可以选择时间戳作为随机变量。原来的 token 是对 URL、AppID、密码三者进行加密生成的，现在我们将 URL、AppID、密码、时间戳四者进行加密来生成 token。调用方在进行接口请求的时候，将 token、AppID、时间戳、随 URL 一并传递给微服务端。</p>
<p>微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过一分钟，则判定 token 过期，拒绝接口请求。如果没有超过一分钟，则说明 token 没有过期，就再通过同样的 token 算法，在服务端生成新的 token，与调用方的传递过来的 token 比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<p>优化之后的认证流程如下图所示：</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322155801827.png" alt="image-20220322155801827"></p>
<h3 id="4、第四轮分析优化"><a href="#4、第四轮分析优化" class="headerlink" title="4、第四轮分析优化"></a>4、第四轮分析优化</h3><p>不过，你可能还会说，这样还是不够安全啊。未认证系统还是可以在这一分钟的 token 失效窗口内，通过截获请求、重放请求，来调用我们的接口啊。</p>
<p>你说的没错。不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。</p>
<p>实际上，还有一个细节我们没有考虑到，那就是，如何在微服务端存储每个授权调用方的 AppID 和密码。当然，这个问题并不难。最容易想到的方案就是存储到数据库里，比如 MySQL。不过，开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。</p>
<p>针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。<u>我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</u></p>
<h3 id="5、最终确定需求"><a href="#5、最终确定需求" class="headerlink" title="5、最终确定需求"></a>5、最终确定需求</h3><p>到此，需求已经足够细化和具体了。现在，我们按照鉴权的流程，对需求再重新描述一下。如果你熟悉 UML，也可以用时序图、流程图来描述。不过，用什么描述不是重点，描述清楚才是最重要的。下面我会给出一个文字版本的流程描述。</p>
<ol>
<li> 调用方法进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。</li>
<li> 微服务端在接收到调用方的接口请求后，从请求中拆解出 token、AppID、时间戳。</li>
<li> 微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li>
<li> 如果 token 验证没有过期，微服务端再从自己的存储中，取出与 AppID 对应的密码。通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配。如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</li>
</ol>
<p>这就是我们需求分析的整个思考过程，从最粗糙、最模糊的需求开始，通过“提出问题-解决问题”的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。</p>
<h1 id="14-实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"><a href="#14-实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？" class="headerlink" title="14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"></a>14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？</h1><p>在上一节课中，针对接口鉴权功能的开发，我们讲了如何进行面向对象分析（OOA），也就是需求分析。实际上，需求定义清楚之后，这个问题就已经解决一大半了。今天，我们再来看一下，针对面向对象分析产出的需求，如何来进行面向对象设计（OOD）和面向对象编程（OOP）。</p>
<h2 id="如何进行面向对象设计？"><a href="#如何进行面向对象设计？" class="headerlink" title="如何进行面向对象设计？"></a>如何进行面向对象设计？</h2><p>我们知道，<u>面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。</u>在面向对象设计环节，我们将需求描述转换为具体的类的设计。我们把这一环节拆解以下，主要包含以下几个部分：</p>
<ul>
<li>  划分职责进而识别出有哪些类；</li>
<li>  定义类及其属性和方法；</li>
<li>  定义类与类之间的交互关系；</li>
<li>  将类组装起来并提供执行入口。</li>
</ul>
<h3 id="1、划分职责进而识别出有哪些类"><a href="#1、划分职责进而识别出有哪些类" class="headerlink" title="1、划分职责进而识别出有哪些类"></a>1、划分职责进而识别出有哪些类</h3><p>在面向对象有关的书籍中经常讲到，类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都能与现实世界中的事务一一对应。对于一些抽象的概念，我们是无法通过映射现实世界中的事物的方式来定义类的。</p>
<p>所以，大多数面向对象的书籍中，还会讲到另一种识别类的方法，<u>那就是把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。</u>对于没有经验的初学者来说，这个方法比较简单、明确，可以直接照着做。</p>
<p>不过，我更喜欢另一个方法，那就是根据需求的描述，把其中涉及的功能点，一个一个罗列出来，然后再去查看哪些功能点的职责相近，操作同样的属性，是否应该归为同一个类。我们来看一下，针对鉴权这个例子，具体应该如何来做。</p>
<p>在上一节课中，我们已经做出了详细的需求描述，具体描述如下：</p>
<blockquote>
<ol>
<li> 调用方法进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。</li>
<li> 微服务端在接收到调用方的接口请求后，从请求中拆解出 token、AppID、时间戳。</li>
<li> 微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li>
<li> 如果 token 验证没有过期，微服务端再从自己的存储中，取出与 AppID 对应的密码。通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配。如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</li>
</ol>
</blockquote>
<p>首先，我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能要尽可能的小。每个功能只负责做一件很小的事情，符合单一职责原则。下面是我逐句拆解上述需求描述之后，得到的功能点列表。</p>
<ol>
<li> 把 AppID、密码、时间戳、URL 拼接成一个字符串；</li>
<li> 对字符串进行加密生成 token；</li>
<li> 将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li>
<li> 解析 URL，得到 token、AppID、时间戳等信息；</li>
<li> 校验 token 是否失效</li>
<li> 从存储中取出 AppID 和对应的密码</li>
<li> 验证两个 token 是否匹配。</li>
</ol>
<p>从上面的功能列表中，我们发现，1、2、5、7 都跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略的得到三个核心类：AuthToken、Url、CredentialStorage。</p>
<p>当然，这是一个初步的类的划分，其它一些不重要的、边边角角的类，我们可能暂时没办法一下子想全，但这也没有关系，面向对象分析、设计、编程本来就是一个循环迭代、不断优化的过程。根据需求，我们先给出一个粗糙版本的设计方案，然后基于这样一个基础，再去迭代优化，会更容易一些，思路也会更加清晰一些。</p>
<p>不过，我还要再强调一点，接口调用鉴权这个开发需求比较简单，所以，需求对应的面向对象设计并不复杂，识别出来的类也并不多。但如果我们面对的是更加大型的软件开发、更加复杂的需求开发，涉及的功能点可能会很多，对应的类也会比较多，像刚刚那样根据需求逐句罗列功能点的方法，最后会得到一个长长的列表，就会优点凌乱、没有规律。针对这种复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路。</p>
<h3 id="2、定义类及其属性和方法"><a href="#2、定义类及其属性和方法" class="headerlink" title="2、定义类及其属性和方法"></a>2、定义类及其属性和方法</h3><p>刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是 AuthToken、Url 和 CredentialStorage。现在我们来看下，每个类都有哪些属性和方法。</p>
<p><strong>AuthToken 类相关的功能点有四个：</strong></p>
<ul>
<li>  把 AppID、密码、时间戳、URL 拼接成一个字符串；</li>
<li>  对字符串进行加密生成 token；</li>
<li>  校验 token 是否失效；</li>
<li>  验证两个 token 是否匹配。</li>
</ul>
<p>对于方法的识别，很多面向对象的书籍中一般都是这么讲的，<u>识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。</u>类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。</p>
<p>借用这个思路，根据功能点描述，识别出来 AuthToken 类的属性和方法如下图所示。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322171228516.png" alt="image-20220322171228516"></p>
<p>从上面的类图中，我们可以发现这样几个小细节：</p>
<ol>
<li> 并不是所有的名字都被定义为了类的属性，比如 URL、AppID、密码、时间戳这几个名词，我们把它作为了方法的参数。</li>
<li> 我们还需要挖掘一些没有出现在功能点描述中的属性，比如 createTime，expireTimeInterval，它用在 isExpired() 函数中，用于判定 token 是否过期。</li>
<li> 我们还给 AuthToken 类添加了一个功能点描述中没有提到的方法 getToken()。</li>
</ol>
<p>第一个细节告诉我们，从业务模型上来说，不该属于这个类的属性和方法，不应该被放到这个类里。比如 URL、AppID 这些信息，从业务模型上来说，不应该属于 AuthToken，所以我们不应该放到这个类中。</p>
<p>第二、三个细节告诉我们，在设计类具有哪些属性和方法时，不能单纯地依赖当下的需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证类定义的完整性，另一方面不仅为当下的需求还为未来的需求做准备。</p>
<p><strong>Url 类相关的功能点有两个</strong></p>
<ul>
<li>  将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li>
<li>  解析 URL，得到 token、AppID、时间戳等信息；</li>
</ul>
<p>虽然需求描述中，我们都是以 URL 来代指接口请求，但是，接口请求并不一定是以 URL 的形式表达，还有可能是 Dubbo RPC 等其它形式。为了让这个类更加通用，命名更加贴切，我们把它命名为 ApiRequest。下面是我根据功能点设计的 ApiRequest 类。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322174037460.png" alt="image-20220322174037460"></p>
<p><strong>CredentialStorage 类相关的功能点只有一个：</strong></p>
<ul>
<li>  从存储中取出 AppID 和对应的密码</li>
</ul>
<p>CredentialStorage 类非常简单，类图如下所示。为了做到抽象封装具体的存储方式，我将 CredentialStorage 设计成了接口，基于接口编程而非具体的实现编程。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322174247140.png" alt="image-20220322174247140"></p>
<h3 id="3、定义类与类之间的交互关系"><a href="#3、定义类与类之间的交互关系" class="headerlink" title="3、定义类与类之间的交互关系"></a>3、定义类与类之间的交互关系</h3><p>类与类之间存在哪些交互关系呢？UML统一建模语言中定义了六种类之间的关系。分别是：泛化、实现、关联、聚合、组合、依赖。关系比较多，而且有些还比较相近，比如聚合和组合，下面我们逐一讲解一下。</p>
<ul>
<li>  <strong>泛化（Generalization）</strong>可以简单理解为继承关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>实现（Realization）</strong>一般是指接口和实现类之间的关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>聚合（Aggregation）</strong>是一种包含关系，A类对象包含B类对象，B类对象的生命周期可以不依赖A类对象的生命周期，也就是说可以单独销毁A类对象而不影响B类对象。比如课程和学生之间的关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>组合（Composition）</strong>也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖于A类对象的生命周期，B类对象不可单独存在，比如鸟与翅膀的关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>关联（Association）</strong>是一种非常弱的关系。包含聚合、组合两种关系。具体到代码层面，如果B类对象是A类的成员变量，那B类和A类就是关联关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>依赖（Dependency）</strong>是一种比关联关系更加弱的关系，包含关联关系。不管B类对象是A类对象的成员变量，还是A类的方法使用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，我们都称它们有依赖关系。具体到Java代码中就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(B b)</span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于UML六种关系的详细介绍，我个人觉得这样拆分有点太细，增加了学习成本，对于指导编程开发没有太大意义。所以，我们从更加贴近编程的角度，对类与类之间的关系做了调整，只保留了四个关系：泛化、实现、组合、依赖。</p>
<p>其中，泛化、实现、依赖的定义不变，组合关系替代UML中的组合和聚合两个概念。之所以这样重新命名，是为了跟我们前面讲的“多用组合少用继承”设计原则中的“组合”统一含义。只要B类是对象是A类对象的成员变量，那我们就称，A类跟B类是组合关系。</p>
<p>理论的东西讲完了，让我们来看一下，刚刚我们定义的类之间都有哪些关系呢？因为目前只有三个核心的类，所以只用到了实现关系，也即 CredentialStorage 和 MysqlCredentialStorage 之间的关系。接下里讲到组装类的时候，我们还会用到依赖关系、组合关系，但是泛化关系暂时没有用到。</p>
<h3 id="4、将类组装起来并提供执行入口"><a href="#4、将类组装起来并提供执行入口" class="headerlink" title="4、将类组装起来并提供执行入口"></a>4、将类组装起来并提供执行入口</h3><p>类定义好了，类之间必要的交互关系也设计好了，接下来我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p>
<p>接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件。所以，我们封装所有的实现细节，设计了一个最顶层的 ApiAuthencator 接口类，暴露一组给外部调用者使用的 API 接口，作为触发执行鉴权逻辑的入口。具体的类的设计如下所示：</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322185107325.png" alt="image-20220322185107325"></p>
<hr>
<h1 id="15-理论一：对于单一职责原则，如何判断某个类的职责是否足够“单一”？"><a href="#15-理论一：对于单一职责原则，如何判断某个类的职责是否足够“单一”？" class="headerlink" title="15 | 理论一：对于单一职责原则，如何判断某个类的职责是否足够“单一”？"></a>15 | 理论一：对于单一职责原则，如何判断某个类的职责是否足够“单一”？</h1><p>前面几节课，我们介绍了面向对象相关的知识。从今天起，我们开始学习一些经典的设计原则，其中包括，SOLID、KISS、YAGNI、DRY、LOD 等。</p>
<p>对于这些设计原则，三句话总结就是：一看就懂，一学就会，一用就懵。</p>
<p>这些原则从字面上理解都不难，但真正用到项目中的时候，你会发现，“看懂”和“会用”是两回事，而“用好”更是难上加难。如果对这些原则理解得不够透彻，会在使用的时候过于教条主义，拿原则当真理，生搬硬套，反而会适得其反。</p>
<p>所以，在接下来的学习中，我们的目的不仅仅是记住这些原则的定义，更重要的是要理解这些原则设计的初衷，能解决哪些问题，有哪些应用场景等。要知其然亦知其所以然，做到真正的活学活用。</p>
<h2 id="如何理解单一职责原则（SRP）"><a href="#如何理解单一职责原则（SRP）" class="headerlink" title="如何理解单一职责原则（SRP）"></a>如何理解单一职责原则（SRP）</h2><p>上面提到的 SOLID 原则，实际上是5个设计原则的合称。它们分别是：</p>
<blockquote>
<ul>
<li>  S：单一职责原则；Single Repository Principe；SRP</li>
<li>  O：开闭原则；Open Closed Principe；OCP</li>
<li>  L：里氏替换原则；L Substitution Principe；LSP</li>
<li>  I：接口隔离原则：Interface Segregation Principe</li>
<li>  D：依赖反转原则；</li>
</ul>
</blockquote>
<p>SRP 的英文描述是“A class or module should have a single reponsibility”，翻译过来就是“一个类或模块应该只负责完成一个功能”。</p>
<p>注意，原文中描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念，你其实可以把模块理解成比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。为了方便你理解，接下来我们将只从“类”设计的角度，来讲解如何应用这个设计原则，你可以类比着引申到“模块”中。</p>
<p>单一职责原则的定义描述非常简单，一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p>
<p>我们举个例子来解释一下，比如：一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。为了满足单一职责原则，我们需要将这个类拆分成两个粒度更细、功能更加单一的两个类：订单类和用户类。</p>
<h2 id="如何判断类的职责是否够单一？"><a href="#如何判断类的职责是否够单一？" class="headerlink" title="如何判断类的职责是否够单一？"></a>如何判断类的职责是否够单一？</h2><p>从刚刚这个例子来看，单一职责原则看似不难应用。那是因为我举的这个例子比较简单，一眼就能看出订单和用户毫不相关。但是大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。在真实的软件开发中，对于一个类是否职责单一的判定，是很难界定的。</p>
<p>比如，在一个社交产品中，我们用下面的 UserInfo 来记录用户的信息。你觉得 UserInfo 类的设计是否满足单一职责原则呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lastLoginTime;</span><br><span class="line">    <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">    <span class="keyword">private</span> String provinceOfAddress;</span><br><span class="line">    <span class="keyword">private</span> String cityOfAddress;</span><br><span class="line">    <span class="keyword">private</span> String regionOfAddress;</span><br><span class="line">    <span class="keyword">private</span> String detailedAddress;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个问题，有两种不同的观点。一种观点是：UserInfo 类包含的都是用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则。另一种观点是：地址信息在 UserInfo 类中所占的比重较高，可以继续拆分成独立的 UserAddress 类，UserInfo 只保留除 Address 之外的其它信息，拆分之后两个类的职责更加单一。</p>
<p>哪种观点更对呢？实际上，要从中作出选择，我们不能脱离具体的应用场景。如果在这个社交产品中，用户的地址信息跟其它信息一样，只是单纯地用来展示，那 UserInfo 现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从 UserInfo 中拆分出来，独立成用户物流信息（或叫地址信息、收货信息等）。</p>
<p>我们再进一步延伸一下。如果这个做社交产品的公司发展的越来越好，公司内部又开发出了许多其它产品。公司希望支持统一账号系统，也就是用户一个账号可以登录公司研发的所有产品。这个时候，我们就需要继续对 UserInfo 进行拆分，将跟用户身份认证相关的信息（比如 email、telephone等）抽取成独立的类。</p>
<p>从刚刚这个例子，我们可以总结出，不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。在某种应用场景下或者当前的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或者在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。</p>
<p>除此之外，从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。比如，例子中的 UserInfo 类。如果我们从“用户”这个业务层面来看，UserInfo 包含的信息都属于用户，满足单一职责原则。如果我们从更加细分的“用户展示信息”、“地址信息”、“登录认证信息”等等这些更细粒度的业务层面来看，那 UserInfo 就应该继续拆分。</p>
<p>综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、见仁见智的事情。实际上，在真正的软件开发中，我们也没有必要过于未雨绸缪，过度设计。所以，<strong>我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。</strong></p>
<p>讲到这里，那你可能又有点儿懵了。这个原则如此含糊不清，模棱两可，那到底该如何把握呢？下面我将介绍一些常用的小技巧，可以帮助你从侧面上判定一个类的职责是否足够单一。下面这几条原则，比起主观地去思考类是否职责单一，要更有指导意义、更具有可执行性。</p>
<ul>
<li>  如果类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分。</li>
<li>  类依赖的其它类过多，或者依赖类继续依赖的其它类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分。</li>
<li>  私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性。</li>
<li>  比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰。</li>
<li>  类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。</li>
</ul>
<h2 id="类的职责是否设计得越单一越好？"><a href="#类的职责是否设计得越单一越好？" class="headerlink" title="类的职责是否设计得越单一越好？"></a>类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细越好呢？答案是否定的。我们还是通过一个例子来说明。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Serialization</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">textBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">        textBuilder.append(gson.toJson(object));</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">deserialize</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING))&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gsonStr</span> <span class="operator">=</span> text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(gsonStr, Map.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想让类的职责更加单一，我们对 Serialization 类进一步拆分，拆分成一个只负责序列化工作的 Serializer 类和另一个只负责反序列化工作的 Deserializer 类。拆分后的具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Serialization</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">textBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">        textBuilder.append(gson.toJson(object));</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deserializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Serialization</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">deserialize</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING))&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gsonStr</span> <span class="operator">=</span> text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(gsonStr, Map.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，虽然经过拆分后，Serializer 类和 Deserializer 类的职责更加单一了，但也随之带来了新的问题。如果我们修改了协议的格式，数据表示从 “UEUEUE” 改为 “DFDFDF”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来的 Serialization 类高了。而且，如果我们仅仅对 Serializer 类做了协议修改，而忘记修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。</p>
<p>实际上，不管是设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个具体的设计原则是否合理的时候，也可以以此作为最终的考量标准。</p>
<hr>
<h1 id="16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h1><p>今天我们继续来学习 SLOID 中的第二个原则：开闭原则。可以说，开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。</p>
<p>之所以说这条原则难理解，那是因为：</p>
<blockquote>
<ul>
<li>  怎样的代码改动才被定义为“扩展”’？</li>
<li>  怎样的代码改动才被定义为“修改”？</li>
<li>  怎么才算满足或违反“开闭原则”？</li>
<li>  修改代码就一定意味着违反“开闭原则”吗？</li>
</ul>
</blockquote>
<p>等等这些问题，都比较难理解。</p>
<p>之所以说这条原则难掌握，那是因为：</p>
<blockquote>
<ul>
<li>  如何做到“对扩展开放、修改关闭”？</li>
<li>  如何在项目中灵活地应用“开闭原则”，以免在追求扩展性的同时影响到代码可读性？</li>
</ul>
</blockquote>
<p>等等这些问题，都比较难掌握。</p>
<p>之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。</p>
<p>所以说，学好“开闭原则”非常重要。</p>
<h2 id="如何理解“对扩展开放，修改关闭”？"><a href="#如何理解“对扩展开放，修改关闭”？" class="headerlink" title="如何理解“对扩展开放，修改关闭”？"></a>如何理解“对扩展开放，修改关闭”？</h2><p>开闭原则，Open Closed Principe（OCP），它的英文描述是：software entities（modules，classes，functions，etc.） should be open for extension，but closed for modification。翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p>
<p>这个描述比较简单。如果我们详细</p>
<hr>
<h1 id="17-理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？"><a href="#17-理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？" class="headerlink" title="17 | 理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？"></a>17 | 理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？</h1><p>今天，我们继续学习“SOLID ”中的“L”，即里氏替换原则。整体上来讲，这个设计原则是比较简单的。但是这条原则从定义上来看，跟“多态”有点类似，所以我们学习的重点是通过一些例子，将它跟多态区分开来。</p>
<h2 id="如何理解“里氏替换原则”？"><a href="#如何理解“里氏替换原则”？" class="headerlink" title="如何理解“里氏替换原则”？"></a>如何理解“里氏替换原则”？</h2><p>里氏替换原则是由 Liskov 提出的，并冠以他自己的名字，Liskov Substitution Principe（LSP）。这条原则的英文描述是：</p>
<blockquote>
<p>  If S is subtype of T，then objects of type T may be replaced with objects of type S, without breaking the program。</p>
</blockquote>
<p>翻译过来就是：在不破坏原来程序逻辑的情况下，子类对象需要能够在程序中的任何地方替换父类对象。</p>
<p>这么说比较抽象，我们继续通过一个例子来理解一下。如下代码中，父类 Transporter 使用 HttpClient 来传输网络数据。子类 SecurityTransporter 继承父类 Transporter，增加了额外的功能，支持传输 appId 和 appToken 安全认证信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(HttpClient httpClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.httpClient = httpClient;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span>&#123;</span><br><span class="line">        <span class="comment">// use httpClient to send request...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="keyword">private</span> String appToken;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(httpClient);</span><br><span class="line">        <span class="built_in">this</span>.appId = appId;</span><br><span class="line">        <span class="built_in">this</span>.appToken = appToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果request中不含appId和appToken，该方法与父类sendRequest方法的功能完全一样</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken))&#123;</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Transporter transporter)</span> &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>();</span><br><span class="line">        <span class="comment">// 省略设置request中数据值的代码</span></span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> transporter.sendRequest(request);</span><br><span class="line">        <span class="comment">// 省略其它逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LSP原则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    demo.fun(<span class="keyword">new</span> <span class="title class_">SecurityTransporter</span>(<span class="comment">/*省略参数*/</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，子类 SecurityTransporter 的设计完全符合 LSP 原则，子类对象可以替换父类出现的任何位置，并且原来代码的逻辑行为不变，正确性也没有被破坏。</p>
<p>【问题】不过，你可能会有这样的疑问，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里氏替换说的是不是一回事呢？从刚刚的例子和定义描述来看，它们的确很相似，但究其本质，它们完全是两回事。为什么这么说呢？</p>
<p>我们沿用上面的例子来解释一下。我们先对 SecurityTransporter 类中的 sendRequest() 方法简单改造一下。改造前，如果请求消息中没有设置 appId 或者 appToken，我们就不做校验；改造后，如果请求消息中没有设置 appId 或者 appToken，则直接抛出 NoAuthorizationRuntimeException 未授权异常。改造前后的代码对比如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造前：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span>&#123;</span><br><span class="line">	<span class="comment">// 省略其它代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken))&#123;</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span>&#123;</span><br><span class="line">	<span class="comment">// 省略其它代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(appId) &amp;&amp; StringUtils.isBlank(appToken))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoAuthorizationRuntimeException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">        request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在改造之后的代码中，如果传递进 fun() 函数的是父类 Transporter 对象，那 fun() 函数并不会有异常抛出， 但如果传递给 fun() 函数的是子类 SecurityTransporter 对象，那 fun() 就<u>有可能</u>有异常抛出。尽管代码中抛出的是运行时异常，我们可以不在代码中显式地捕获处理，但子类替换父类传递进 fun() 函数之后，整个程序的逻辑行为就发生了变化。</p>
<p>虽然改造之后的代码仍然可以使用 Java 的多态语法，动态地调用子类 SecurityTransporter 来替换父类 Transporter，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，SecurityTransporter 的设计是不符合 LSP 原则的。</p>
<p><strong>总结：</strong>虽然从定义描述和代码实现上来看，多态和里氏替换有点类似，但它们关注的角度是不一样的。多态是 OOP 的一大特性，也是一种 OOPL，它是一种代码实现的思路。而<u>LSP 是一种设计原则，是用来指导继承关系中子类该如何设计的原则。</u>子类的设计要保证在替换父类的时候，不改变原有程序（即父类程序）的逻辑以及不破坏原有程序的正确性。</p>
<h2 id="哪些代码明显违背了LSP？"><a href="#哪些代码明显违背了LSP？" class="headerlink" title="哪些代码明显违背了LSP？"></a>哪些代码明显违背了LSP？</h2><p>实际上，LSP 还有一个更加能落地、更具指导意义的描述，那就是“Design By Contract”，翻译成中文就是“按照协议来设计”。</p>
<p>白话一点就是：子类在设计的时候，要遵守父类的行为约定（或叫协议）。对于父类中函数定义好的行为约定，子类可以通过重写改变父类中函数的内部逻辑实现，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类的之间的关系，也可以替换成接口和实现类的关系。【比如在接口的抽象方法中，可以进行功能描述，那其实现类就应该按描述去实现这个功能。但毕竟设计原则只是一种原则，即便你不遵循也不会有语法上的错误。】</p>
<p>一句话总结就是，父类方法中说要做的（抽象方法）和已经做了的（非抽象方法）子类都得有，我不管里子一不一样，但面子必须一样。在这个基础上，子类才可以添加自己的实现逻辑。</p>
<p>下面我们来举几个违反 LSP 的例子来加深一下理解。</p>
<h3>
    1、子类违背父类声明要实现的功能
</h3>

<p>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个函数后，是按照创建日期来给订单排序的。那子类的设计就违背了 LSP。</p>
<h3>
    2、子类违背父类对输入、输出、异常的约定
</h3>

<p>在父类中，某个函数约定：运行出错时返回 null；获取数据为空时返回空集合（empty collection）。而子类重写函数后，实现变成了：运行出错返回异常（Exception），获取不到数据时返回 null。那子类的设计就违背了 LSP。</p>
<h3>
    3、子类违背父类注释中所罗列的任何特殊说明
</h3>

<p>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额”，而子类重写 withdraw() 函数之后，针对 VIP 账户实现了透支提现的功能，也就是提现金额可以大于账户金额，那这个子类的设计也是不符合 LSP 的。</p>
<p>但是，如果你把父类中 withdraw() 方法注释修改为“提现”，不加任何限制，在子类中除了提供父类原有的功能外，新增实现了关于 VIP 用户的透支提现功能，那这是符合 LSP 的。</p>
<p>事实上，你有没有发现，LSP 这个原则是非常宽松的。一般情况下，我们写的代码都不怎么会违背它。所以，只要你能看懂上面讲的这些，这个原则就不难掌握，也不难应用。</p>
<hr>
<h1 id="18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"><a href="#18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？" class="headerlink" title="18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"></a>18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</h1><p>接口隔离原则对应 SOLID 中的“I”，Interface Segregation Principe（ISP）。它的一种英文定义是这样的</p>
<blockquote>
<p>  Clients should not be forced to depend upon interfaces that they do not use。</p>
</blockquote>
<p>翻译过来就是：客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，我们可以理解成接口调用者。</p>
<h3>如何理解接口隔离原则？

<p>理解接口原则的关键在于理解其中的“接口”二字。实际上，“接口”这个名词可以用在很多场合中，在软件开发中，我们既可以把它看做是一组抽象的约定，也可以具体指系统与系统之间的 API 接口，还可以特指 OOPL 中的接口等。</p>
<p>在这条原则中，我们可以把“接口”理解成下面三样东西：</p>
<ul>
<li>  一组 API 接口集合</li>
<li>  单个 API 接口或函数</li>
<li>  OOP 中接口的概念</li>
</ul>
<p>接下来，我们就按照这三种理解方式来详细讲一下，在不同的场景下，这条原则是如何解读和应用的。</p>
<h3> 把“接口”理解为一组 API 接口集合

<p>我们通过一个例子来讲解。微服务用户系统提供了一组跟用户相关的 API 给其它系统使用，比如：注册、登录、获取用户信息等。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户功能的接口。</p>
<p>当然，这个需求很简单。我们只需要在 UserService 接口中添加一个 deleteUserById() 或 deleteUserByCellphone() 方法就可以了。这的确可以解决问题，但是这样的添加方式也隐藏了一些安全隐患，不知道你发现了没有？</p>
<p>删除用户是一个非常慎重的操作，一般情况下，我们只希望通过后台管理系统来执行这个操作，所以这个接口最好只限定于给后台管理系统使用。如果我们把删除用户的方法放在 UserService 中，那所有使用到 UserService 的系统就都可以调用这个接口了，即使除了后台管理系统，其它系统本来就不需要这个接口。如果不加限制地被其它业务系统调用，就会导致误删用户的概率大大提高。</p>
<p>当然，最好的解决方案是从架构设计的层面，通过鉴权的方式来限制接口的调用。不过，我们还可以继续从代码设计的层面，来尽量避免接口被误用的概率，达到多重防护的效果。</p>
<p>我们参照接口隔离原则，调用者不应该被强迫依赖它不需要的接口（其实在这个例子中说的接口就是方法），将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只提供给后台管理系统来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RestrictedUserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUserById</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUserByCellphone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>, RestrictedUserService &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚刚的这个例子中，我们把 ISP 中的“接口”理解为一组接口（或者叫函数）集合。它可以是某个微服务的接口，也可以是某个类库的接口。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其它调用者也依赖这部分不会被用到的接口。</p>
<h3>把“接口”理解成单个 API 接口或函数

<p>现在我们再换一种理解方式，把接口理解为单个接口或函数（为了方便讲解，下面将都简称为“函数”）。</p>
<p>那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。</p>
<p>其实可以想到的是，函数的功能越复杂，其复用性就越差，因为不会有很多地方都要使用特别复杂的功能。一般而言，复杂功能都是通过简单功能堆叠实现的，而不是直接实现一个非常复杂的功能。所以，你如果在某一个小单元内写了一段非常复杂的代码，实现了很多功能，但是每次调用的时候可能只是使用了其中一个或很少几个功能，那大多数的功能是用不到的，这也就相当于调用者 Client 虽然没用到，但是这个小单元内的程序确确实实要从头走到尾，这就相当于是一种强买强卖，是违反 ISP 的。</p>
<p>我们通过一个例子来理解一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Statistics</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> min;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> avg;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sum;</span><br><span class="line">    <span class="comment">// 省略 getter/setter/constructor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Statistics <span class="title function_">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span>&#123;</span><br><span class="line">    <span class="type">Statistics</span> <span class="variable">statistics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Statistics</span>();</span><br><span class="line">    <span class="comment">// 省略计算逻辑</span></span><br><span class="line">    <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>接口隔离原则跟单一职责原则还有点类似，它们的区别和联系是什么？</p>
</h3></h3></h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/16/%E4%B8%AD%E5%8F%B0%E5%AD%A6%E4%B9%A0%EF%BC%88Part1%EF%BC%89/" rel="prev" title="中台学习（Part1）">
                  <i class="fa fa-chevron-left"></i> 中台学习（Part1）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/" rel="next" title="检索技术（Part1）">
                  检索技术（Part1） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
