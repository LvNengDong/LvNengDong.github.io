<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="计算机体系结构冯诺伊曼体系概念将程序指令和数据一起存储的计算机。 冯诺依曼体系诞生的背景1234&gt;&gt; 早期计算机仅含固定用途程序&gt;&gt; 改变程序得更改结构、重新设计电路&gt;&gt; 把程序存储起来并设计通用电路&gt;&gt; 存储程序指令，设计通用电路   早期的计算机仅能运行固定用途程序（程序由硬件决定）。也就是说，一台计算机能执行什么功能在它出厂时就已经确定了，一台">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理">
<meta property="og:url" content="http://example.com/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="计算机体系结构冯诺伊曼体系概念将程序指令和数据一起存储的计算机。 冯诺依曼体系诞生的背景1234&gt;&gt; 早期计算机仅含固定用途程序&gt;&gt; 改变程序得更改结构、重新设计电路&gt;&gt; 把程序存储起来并设计通用电路&gt;&gt; 存储程序指令，设计通用电路   早期的计算机仅能运行固定用途程序（程序由硬件决定）。也就是说，一台计算机能执行什么功能在它出厂时就已经确定了，一台">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911224816690.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911225714328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911230701008.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911231021606.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911233008017.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912004341651.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912010432326.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912012557727.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912012900633.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912014543563.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912014832192.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912015528776.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912015737767.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912020902697.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912021319208.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912022344587.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912022404523.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912023255855.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912153148820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912155759946.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912161843335.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912161918767.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912162811913.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912163305685.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912164137379.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913214628968.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913215812034.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913215847990.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913220238225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913220816598.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913225611387.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913230009309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913230819040.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913231746532.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913232300660.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913233114057.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913233210844.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913235659272.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914000224896.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914000615931.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914000758266.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914234102144.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914235904462.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220915001916422.png">
<meta property="article:published_time" content="2022-09-11T14:29:53.000Z">
<meta property="article:modified_time" content="2022-09-14T16:30:10.978Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911224816690.png">


<link rel="canonical" href="http://example.com/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","path":"2022/09/11/计算机组成原理/","title":"计算机组成原理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>计算机组成原理 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">计算机体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E4%BD%93%E7%B3%BB"><span class="nav-number">1.1.</span> <span class="nav-text">冯诺伊曼体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E8%AF%9E%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.2.</span> <span class="nav-text">冯诺依曼体系诞生的背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">冯诺依曼体系架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%93%B6%E9%A2%88"><span class="nav-number">1.1.4.</span> <span class="nav-text">冯诺依曼瓶颈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">现代计算机的结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B1%82%E6%AC%A1%E4%B8%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">计算机的层次与编程语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E9%80%BB%E8%BE%91%E5%B1%82"><span class="nav-number">2.1.</span> <span class="nav-text">硬件逻辑层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%9C%BA%E5%99%A8%E5%B1%82"><span class="nav-number">2.2.</span> <span class="nav-text">微程序机器层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%9C%BA%E5%99%A8%E5%B1%82"><span class="nav-number">2.3.</span> <span class="nav-text">传统机器层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="nav-number">2.4.</span> <span class="nav-text">操作系统层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%B1%82"><span class="nav-number">2.5.</span> <span class="nav-text">汇编语言层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%B1%82"><span class="nav-number">2.6.</span> <span class="nav-text">高级语言层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">2.7.</span> <span class="nav-text">应用层</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%AE%A1%E7%AE%97%E5%8D%95%E4%BD%8D"><span class="nav-number">3.</span> <span class="nav-text">计算机的计算单位</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E9%87%8F%E5%8D%95%E4%BD%8D"><span class="nav-number">3.1.</span> <span class="nav-text">容量单位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9F%E5%BA%A6%E5%8D%95%E4%BD%8D"><span class="nav-number">3.2.</span> <span class="nav-text">速度单位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%8E%E7%BC%96%E7%A0%81%E9%9B%86"><span class="nav-number">4.</span> <span class="nav-text">计算机的字符与编码集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%9B%86%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="nav-number">4.1.</span> <span class="nav-text">字符编码集的历史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ASCII%E7%A0%81"><span class="nav-number">4.1.1.</span> <span class="nav-text">ASCII码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extended-ASCII%E7%A0%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">Extended ASCII码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%9B%86%E7%9A%84%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">4.1.3.</span> <span class="nav-text">字符编码集的国际化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%9B%86"><span class="nav-number">4.2.</span> <span class="nav-text">中文编码集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E5%85%A8%E7%90%83%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%9AUnicode"><span class="nav-number">4.3.</span> <span class="nav-text">兼容全球的字符集：Unicode</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA%E7%BB%84%E6%88%90%E7%AF%87"><span class="nav-number">5.</span> <span class="nav-text">计算机概论组成篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%A0%E8%8A%82%E5%AF%BC%E5%AD%A6"><span class="nav-number">5.1.</span> <span class="nav-text">章节导学</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF"><span class="nav-number">6.</span> <span class="nav-text">总线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-number">6.0.1.</span> <span class="nav-text">总线的概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">6.0.1.1.</span> <span class="nav-text">是什么？有什么用？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">6.0.2.</span> <span class="nav-text">总线的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%87%E5%86%85%E6%80%BB%E7%BA%BF"><span class="nav-number">6.0.2.1.</span> <span class="nav-text">片内总线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF"><span class="nav-number">6.0.2.2.</span> <span class="nav-text">系统总线</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E4%BB%B2%E8%A3%81"><span class="nav-number">6.0.3.</span> <span class="nav-text">总线的仲裁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81"><span class="nav-number">6.0.3.1.</span> <span class="nav-text">为什么需要总线仲裁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">6.0.3.2.</span> <span class="nav-text">总线仲裁的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.0.3.2.1.</span> <span class="nav-text">链式查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.0.3.2.2.</span> <span class="nav-text">计时器定时查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82"><span class="nav-number">6.0.3.2.3.</span> <span class="nav-text">独立请求</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="nav-number">7.</span> <span class="nav-text">计算机的输入输出设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="nav-number">7.1.</span> <span class="nav-text">常见的输入输出设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.2.</span> <span class="nav-text">输入输出接口的通用设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BA%BF"><span class="nav-number">7.2.1.</span> <span class="nav-text">数据线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%BA%BF"><span class="nav-number">7.2.2.</span> <span class="nav-text">状态线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E7%BA%BF"><span class="nav-number">7.2.3.</span> <span class="nav-text">命令线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%80%89%E6%8B%A9%E7%BA%BF"><span class="nav-number">7.2.4.</span> <span class="nav-text">设备选择线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E4%B8%8EIO%E8%AE%BE%E5%A4%87%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">7.3.</span> <span class="nav-text">CPU与IO设备的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD"><span class="nav-number">7.3.1.</span> <span class="nav-text">程序中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA%EF%BC%88%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="nav-number">7.3.2.</span> <span class="nav-text">DMA（直接存储器访问）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%A7%88"><span class="nav-number">8.</span> <span class="nav-text">计算机存储器概览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">8.1.</span> <span class="nav-text">存储器的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">8.2.</span> <span class="nav-text">存储器的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="nav-number">8.2.1.</span> <span class="nav-text">存储器的评价指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-1"><span class="nav-number">8.2.2.</span> <span class="nav-text">存储器的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98-%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1"><span class="nav-number">8.2.2.1.</span> <span class="nav-text">缓存-主存层次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98-%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1"><span class="nav-number">8.2.2.2.</span> <span class="nav-text">主存-辅存层次</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">8.3.</span> <span class="nav-text">计算机的主存储器与辅助存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E2%80%94%E2%80%94%E5%86%85%E5%AD%98"><span class="nav-number">8.3.1.</span> <span class="nav-text">主存储器——内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98"><span class="nav-number">8.3.2.</span> <span class="nav-text">辅助存储器——磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">磁盘的物理结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">磁盘的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.2.2.1.</span> <span class="nav-text">先来先服务算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.2.2.2.</span> <span class="nav-text">最短寻道时间优先算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">8.3.2.2.3.</span> <span class="nav-text">扫描算法（电梯算法）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.2.2.4.</span> <span class="nav-text">循环扫描算法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">8.4.</span> <span class="nav-text">计算机的高速缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">8.4.1.</span> <span class="nav-text">高速缓存的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="nav-number">8.4.2.</span> <span class="nav-text">高速缓存的替换策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="nav-number">9.</span> <span class="nav-text">计算机的指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-number">9.1.</span> <span class="nav-text">机器指令的形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.2.</span> <span class="nav-text">机器指令的操作类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9A"><span class="nav-number">9.2.1.</span> <span class="nav-text">数据传输：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="nav-number">9.2.2.</span> <span class="nav-text">算术逻辑操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">9.2.3.</span> <span class="nav-text">移位操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">9.2.4.</span> <span class="nav-text">控制指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">9.3.</span> <span class="nav-text">机器指令的寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="nav-number">9.3.1.</span> <span class="nav-text">指令寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="nav-number">9.3.2.</span> <span class="nav-text">数据寻址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88CPU%E7%BB%84%E4%BB%B6%E4%B9%8B%E4%B8%80%EF%BC%89"><span class="nav-number">10.</span> <span class="nav-text">计算机的控制器（CPU组件之一）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E5%99%A8%EF%BC%88CPU%E7%BB%84%E4%BB%B6%E4%B9%8B%E4%B8%80%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">计算机的运算器（CPU组件之一）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">计算机指令的执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">12.1.</span> <span class="nav-text">指令执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%BE%E8%AE%A1"><span class="nav-number">12.2.</span> <span class="nav-text">CPU的流水线设计</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="计算机组成原理 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机组成原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-11 22:29:53" itemprop="dateCreated datePublished" datetime="2022-09-11T22:29:53+08:00">2022-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-09-15 00:30:10" itemprop="dateModified" datetime="2022-09-15T00:30:10+08:00">2022-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="冯诺伊曼体系"><a href="#冯诺伊曼体系" class="headerlink" title="冯诺伊曼体系"></a>冯诺伊曼体系</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>将<strong>程序指令</strong>和<strong>数据</strong>一起存储的计算机。</p>
<h3 id="冯诺依曼体系诞生的背景"><a href="#冯诺依曼体系诞生的背景" class="headerlink" title="冯诺依曼体系诞生的背景"></a>冯诺依曼体系诞生的背景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 早期计算机仅含固定用途程序</span><br><span class="line">&gt;&gt; 改变程序得更改结构、重新设计电路</span><br><span class="line">&gt;&gt; 把程序存储起来并设计通用电路</span><br><span class="line">&gt;&gt; 存储程序指令，设计通用电路</span><br></pre></td></tr></table></figure>

<ol>
<li>早期的计算机仅能运行固定用途程序（程序由硬件决定）。也就是说，一台计算机能执行什么功能在它出厂时就已经确定了，一台设计用来做数学运算的计算机只能用于执行出厂时初始化好的数学运算程序，不能做一些文本编辑功能，也不能用来打游戏。这就是“程序指令被写死了”，是刻在硬件上的。【数据是灵活的，程序是写死的】</li>
<li>如果想要让计算机具备其它功能，就必须更改电路，重新设计机器（硬件）。</li>
<li>为了改变这一现状，冯诺依曼的想法是——把程序存储起来，并设计通用电路。让程序决定电路的走向，进而实现不同的功能。【数据是灵活的，程序也是灵活的】</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911224816690.png" alt="image-20220911224816690"></p>
<h3 id="冯诺依曼体系架构"><a href="#冯诺依曼体系架构" class="headerlink" title="冯诺依曼体系架构"></a>冯诺依曼体系架构</h3><p><strong>体系架构</strong></p>
<ul>
<li>必须有一个存储器：存储程序和程序运行所需的数据</li>
<li>必须有一个控制器：控制程序的流转</li>
<li>必须有一个运算器</li>
<li>必须有输入设备</li>
<li>必须有输出设备</li>
</ul>
<p><strong>冯诺依曼机能够完成的功能</strong></p>
<ul>
<li>能够把需要的程序和数据送至计算机中</li>
<li>能够长期记忆程序、数据、中间结果及最终运算结果的能力</li>
<li>能够具备算术、逻辑运算和数据传送等数据加工处理的能力</li>
<li>能够按照要求将处理结果输出给用户</li>
</ul>
<blockquote>
<p>现代计算机都是冯诺依曼机</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911225714328.png" alt="image-20220911225714328"></p>
<p>图解：</p>
<ul>
<li>运算器协同存储器、控制器完成数据的处理，把处理结果给到输出设备；</li>
<li>控制器不仅控制了运算器和存储器，还控制了输入、输出设备，控制器是至关重要的一环。</li>
</ul>
<h3 id="冯诺依曼瓶颈"><a href="#冯诺依曼瓶颈" class="headerlink" title="冯诺依曼瓶颈"></a>冯诺依曼瓶颈</h3><p>上图就是一个早期的冯诺依曼计算机体系结构的示意图。可以看到，存储器和CPU是分开的。实际上，将存储器和CPU分开并不是一个好的结构，这也是冯诺依曼结构的瓶颈所在——<strong>CPU和存储器之间的速率问题无法调和</strong>。</p>
<p>一般而言，CPU速率是要远快于存储器的，这也就导致了CPU经常空转等待数据传输，这时非常浪费CPU资源的。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911230701008.png" alt="image-20220911230701008"></p>
<h2 id="现代计算机的结构"><a href="#现代计算机的结构" class="headerlink" title="现代计算机的结构"></a>现代计算机的结构</h2><p>现代计算机结构本质上还属于冯诺依曼体系，不过它在冯诺依曼体系结构的基础上进行了一定程度的修改，用于解决 CPU与存储设备之间的性能差异问题。</p>
<p>现代计算机的体系结构如下图，它将存储器也纳入了CPU的范围。当然，这里的存储器主要是指围绕CPU构建的高速存储设备，比如 CPU的寄存器、内存等等。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911231021606.png" alt="image-20220911231021606"></p>
<h1 id="计算机的层次与编程语言"><a href="#计算机的层次与编程语言" class="headerlink" title="计算机的层次与编程语言"></a>计算机的层次与编程语言</h1><p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911233008017.png" alt="image-20220911233008017"></p>
<h2 id="硬件逻辑层"><a href="#硬件逻辑层" class="headerlink" title="硬件逻辑层"></a>硬件逻辑层</h2><ul>
<li>门、触发器等逻辑电路组成</li>
</ul>
<h2 id="微程序机器层"><a href="#微程序机器层" class="headerlink" title="微程序机器层"></a>微程序机器层</h2><ul>
<li>编程语言是<strong>微指令集</strong></li>
<li><strong>微指令</strong>所组成的<strong>微程序</strong>直接交由硬件执行。</li>
</ul>
<blockquote>
<p>微指令是直接操控计算机硬件的指令，计算机在出厂时已经定义好了各种各样的微指令，组成了所谓的“微指令集”。上层程序将多个微指令组成微程序，直接交由计算机硬件调度。</p>
</blockquote>
<h2 id="传统机器层"><a href="#传统机器层" class="headerlink" title="传统机器层"></a>传统机器层</h2><ul>
<li>编程语言是 CPU 指令集（机器指令）</li>
<li>编程语言和硬件是直接相关</li>
<li>不同架构的 CPU 使用不同的 CPU 指令集</li>
</ul>
<blockquote>
<p>传统机器层的编程语言是CPU指令集，这一层提供了各种各样的CPU指令（机器指令），通过机器指令操作硬件。程序员可以直接编写机器指令来操作计算机硬件。</p>
<p>不同架构的CPU使用的机器指令集是不一样的。比如 Inter 和 AMD 这两种 CPU 就使用两套不同的指令集，除了不同厂商，同一厂商也会生产不同指令集的CPU，比如 x86 和 x86-64 也使用了不同的指令集，所以它们之间是无法相互兼容的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912004341651.png" alt="image-20220912004341651"></p>
<h2 id="操作系统层"><a href="#操作系统层" class="headerlink" title="操作系统层"></a>操作系统层</h2><ul>
<li>向上提供了简易的操作界面</li>
<li>向下对接了指令系统，管理硬件资源</li>
<li>操作系统层是在软件和硬件之间的适配层</li>
</ul>
<h2 id="汇编语言层"><a href="#汇编语言层" class="headerlink" title="汇编语言层"></a>汇编语言层</h2><ul>
<li>编程语言是汇编语言</li>
<li>汇编语言可以<strong>翻译</strong>成可直接执行的机器语言</li>
<li>完成翻译的过程的程序就是汇编器</li>
</ul>
<p>汇编语言的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 把DS放入堆或栈</span><br><span class="line">PUSH DS</span><br><span class="line">PUSH AX</span><br><span class="line"># 移动 AX 到 <span class="number">0040</span></span><br><span class="line">MOV AX,<span class="number">0040</span></span><br><span class="line">MOV DS,AX</span><br></pre></td></tr></table></figure>



<h2 id="高级语言层"><a href="#高级语言层" class="headerlink" title="高级语言层"></a>高级语言层</h2><ul>
<li>Java、C、…</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul>
<li>Office、WPS、…</li>
</ul>
<hr>
<h1 id="计算机的计算单位"><a href="#计算机的计算单位" class="headerlink" title="计算机的计算单位"></a>计算机的计算单位</h1><h2 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a>容量单位</h2><p>TODO</p>
<h2 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a>速度单位</h2><p>TODO</p>
<hr>
<h1 id="计算机的字符与编码集"><a href="#计算机的字符与编码集" class="headerlink" title="计算机的字符与编码集"></a>计算机的字符与编码集</h1><h2 id="字符编码集的历史"><a href="#字符编码集的历史" class="headerlink" title="字符编码集的历史"></a>字符编码集的历史</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><ul>
<li>ASCII 可以理解为一个美版或英版的 GBK。</li>
<li>ASCII码包含 95 个可打印字符，</li>
<li>33 个不可打印字符（包括控制字符）</li>
<li>使用 7 个 bits 就可以完全表示 ASCII 码</li>
</ul>
<p>$$<br>𝟑𝟑+𝟗𝟓=𝟏𝟐𝟖=𝟐^𝟕<br>$$</p>
<blockquote>
<p>计算机早期的主要在美、英等英语母语国家使用，因此 ASCII 码已经足以满足日常使用了。但是随着一些非英语母语国家引入计算机，ASCII 就开始无法描述这些国家的语言了。比如一些数学符号 “÷ ≠ ≥ ≈” 等。因此，就有了第一次对 ASCII 码的扩充，从7bits 扩充到了 8bits，原来的128个字符就扩充到了256个字符，对应的是 Extended ASCII 码。</p>
</blockquote>
<h3 id="Extended-ASCII码"><a href="#Extended-ASCII码" class="headerlink" title="Extended ASCII码"></a>Extended ASCII码</h3><p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912010432326.png" alt="image-20220912010432326"></p>
<h3 id="字符编码集的国际化"><a href="#字符编码集的国际化" class="headerlink" title="字符编码集的国际化"></a>字符编码集的国际化</h3><ul>
<li>欧洲、中亚、东亚、拉丁美洲国家的语言多样性</li>
<li>语言体系不一样，不以有限字符组合的语言。<ul>
<li>不以有限字符组合：英文是以有限个字符进行组合的，无论有多少个单词，始终都基于这个26个字母；而中文则不以有限个字符进行组合。</li>
</ul>
</li>
<li>中国、韩国、日本等的语言最为复杂。</li>
</ul>
<h2 id="中文编码集"><a href="#中文编码集" class="headerlink" title="中文编码集"></a>中文编码集</h2><p>GBK：收录了 21003 个汉字，支持全部中日韩汉字。</p>
<blockquote>
<p>GBK 是一个比较完备的中文字符编码集，但同时它也只是一个<strong>本地化的编码集</strong>。也就是说，它用于汉字和01机器码之间的转换，这套编码对于安装了GBK编码集的机器使用是完全没问题的，但是如果在国外一台没有安装GBK编码的机器上，显然会出现大问题。</p>
<p>比如，国内的一个纯中文的网站，被美国一台电脑浏览，这台电脑没有安装GBK编码，那么这个网页在电脑中的显示就是乱码的。</p>
<p>所以，我们不仅要有本地化的编码，还要有全世界统一的规范。</p>
</blockquote>
<h2 id="兼容全球的字符集：Unicode"><a href="#兼容全球的字符集：Unicode" class="headerlink" title="兼容全球的字符集：Unicode"></a>兼容全球的字符集：Unicode</h2><ul>
<li>Unicode ：统一码、万国码、单一码</li>
<li>Unicode 定义了世界通用的符号集， <code>UTF-*</code> 实现了编码</li>
<li><code>UTF-8</code> 以字节为单位对 Unicode 进行编码</li>
</ul>
<blockquote>
<ul>
<li>中文版的 Windows 系统默认使用 GBK 编码</li>
<li>编程推荐使用 UTF-8 编码</li>
</ul>
</blockquote>
<h1 id="计算机概论组成篇"><a href="#计算机概论组成篇" class="headerlink" title="计算机概论组成篇"></a>计算机概论组成篇</h1><h2 id="章节导学"><a href="#章节导学" class="headerlink" title="章节导学"></a>章节导学</h2><p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912012557727.png" alt="image-20220912012557727"></p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912012900633.png" alt="image-20220912012900633"></p>
<h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><h3 id="总线的概述"><a href="#总线的概述" class="headerlink" title="总线的概述"></a>总线的概述</h3><p>解决不同设备之间的通信问题。</p>
<h4 id="是什么？有什么用？"><a href="#是什么？有什么用？" class="headerlink" title="是什么？有什么用？"></a>是什么？有什么用？</h4><p><strong>USB总线</strong></p>
<p>USB 的全称是 Universal Serial Bus，它也是一条总线，中文名叫“通用串行总线”。USB 总线的作用有以下几个：</p>
<ul>
<li>提供了计算机对外的连接接口。鼠标、键盘等外设可以通过USB连接到计算机上。</li>
<li>规定了连接的标准，促使外围设备接口的统一。</li>
</ul>
<p>类似的，除了 USB总线，计算机中还有 PCI总线（用来连接外置显卡）、ISA总线等等。总结以下就是：总线是为了解决不同设备之间的通信问题而存在的。</p>
<p><strong>有什么用</strong></p>
<p>没有总线（没有统一的连接标准）之前，每个输入设备需要分别连接到存储器、运算器、控制器上，一旦输入设备多了的话，连接线就会越来越多，连接就会比较乱。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912014543563.png" alt="image-20220912014543563"></p>
<p>有了总线之后（以IO总线为例），外围设备连接只需要连接到总线上，由总线进行转发，对外暴露的结构非常简单。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912014832192.png" alt="image-20220912014832192"></p>
<h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><h4 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h4><p>片内总线：芯片（CPU）内部的总线。高集成度芯片内部的信息传输线。</p>
<ul>
<li>寄存器与寄存器之间</li>
<li>寄存器与控制器、运算器之间</li>
<li>高集成度芯片内部的信息传输线</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912015528776.png" alt="image-20220912015528776"></p>
<h4 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h4><p>系统总线：连接计算机各种外围设备的总线。外围设备包括：硬盘、IO设备、USB插槽、PCI插槽、显卡、声卡等。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912015737767.png" alt="image-20220912015737767"></p>
<p>整体而言，系统总线可分为以下三类：</p>
<ul>
<li>数据总线</li>
<li>地址总线</li>
<li>控制总线</li>
</ul>
<blockquote>
<p>系统总线：CPU、主内存、 IO设备、各组件之间的信息传输线。</p>
</blockquote>
<p><strong>数据总线：</strong></p>
<ul>
<li>双向传输各个部件的数据信息</li>
<li>数据总线的位数（总线宽度）是数据总线的重要参数，一般与CPU位数相同（32/64位）。</li>
<li>对于32位的总线，单次可以传输32bit（4byte）的数据。</li>
</ul>
<p><strong>地址总线：</strong></p>
<ul>
<li>地址总线的作用是：用于传输数据的地址（寻址），即指定源数据或目的数据在内存中的地址</li>
<li>地址总线的位数与存储单元有关</li>
<li>如果 <code>地址总线位数=n</code>，那么它的寻址范围就是 <code>0~ 𝟐^𝒏</code>。</li>
</ul>
<p><strong>控制总线：</strong></p>
<ul>
<li>控制总线是用来发出各种控制信号的传输线</li>
<li>控制信号经由控制总线从一个组件发给另外一个组件，比如从<code>CPU-&gt;磁盘</code></li>
<li>控制总线可以监视不同组件之间的状态（就绪/未就绪）</li>
</ul>
<h3 id="总线的仲裁"><a href="#总线的仲裁" class="headerlink" title="总线的仲裁"></a>总线的仲裁</h3><h4 id="为什么需要总线仲裁"><a href="#为什么需要总线仲裁" class="headerlink" title="为什么需要总线仲裁"></a>为什么需要总线仲裁</h4><p>为什么需要总线仲裁：为了解决总线使用权的冲突问题。</p>
<p>假设计算机中，主存需要和硬盘和IO设备交换数据，此时硬盘和IO设备都已经就绪了，那么“总线”该由硬盘来使用呢还是IO设备来使用呢？</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912020902697.png" alt="image-20220912020902697"></p>
<p><strong>总线仲裁</strong>就是用于解决不用设备使用总线的优先级策略，</p>
<h4 id="总线仲裁的方法"><a href="#总线仲裁的方法" class="headerlink" title="总线仲裁的方法"></a>总线仲裁的方法</h4><h5 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h5><p>现有设备1、2、3通过总线与计算机内组件通信，仲裁控制器通过仲裁控制线与设备1、2、3通信。对于<strong>链式查询</strong>而言，会将多个设备按优先排成一个链条。如果设备2希望使用总线，需要先通过仲裁控制线向仲裁控制器发送仲裁请求，仲裁控制器按照1、2、3的顺序发送仲裁结果，所以仲裁结果一定会先到达设备1，如果设备1此时不需要使用总线，则将使用权继续转发到设备2，如果设备1此时正好也需要使用总线，那么优先得到总线的使用权，设备2此时得不到总线的使用权。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912021319208.png" alt="image-20220912021319208"></p>
<ul>
<li>好处：电路复杂度低，仲裁方式简单</li>
<li>坏处：<ul>
<li>优先级低的设备难以获得总线使用权</li>
<li>对电路故障敏感，出现故障后会影响后面所有节点的设备</li>
</ul>
</li>
</ul>
<h5 id="计时器定时查询"><a href="#计时器定时查询" class="headerlink" title="计时器定时查询"></a>计时器定时查询</h5><ul>
<li>仲裁控制器对设备编号并使用计数器累计计数</li>
<li>接收到仲裁信号后，往所有设备发出计数值</li>
<li>计数值与设备编号一致则获得总线使用权</li>
</ul>
<p>仲裁控制器通过仲裁控制线与设备1、2、3通信，并且仲裁控制器内部会维护一个计数器，计数器值枚举了所有的设备编号。某个设备（以设备2为例）需要使用总线时，会先向仲裁控制器发送请求，仲裁控制器向所有的设备发送计时器的值，比如第一次发送了1，设备1收到1后不会使用总线（因为它没有使用总线的需求），设备2收到1后不能使用总线（因为计时器的值不对应）。如果设备2没有获得总线的使用权，每隔一段时间都会想仲裁控制器发送总线的使用请求，直至能够获取到。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912022344587.png" alt="image-20220912022344587"></p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912022404523.png" alt="image-20220912022404523"></p>
<h5 id="独立请求"><a href="#独立请求" class="headerlink" title="独立请求"></a>独立请求</h5><ul>
<li>每个设备均有总线独立连接仲裁器</li>
<li>设备可单独向仲裁器发送请求和接收请求</li>
<li>当同时收到多个请求信号，仲裁器有权按优先级分配使用权</li>
</ul>
<p>设备1、2、3可独立地向仲裁控制器发出仲裁请求以及接收仲裁控制发出的允许使用总线的信号。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912023255855.png" alt="image-20220912023255855"></p>
<ul>
<li>好处：响应速度快，优先顺序可动态改变</li>
<li>缺点：独立请求会导致设备连线多，总线控制复杂</li>
</ul>
<h1 id="计算机的输入输出设备"><a href="#计算机的输入输出设备" class="headerlink" title="计算机的输入输出设备"></a>计算机的输入输出设备</h1><h2 id="常见的输入输出设备"><a href="#常见的输入输出设备" class="headerlink" title="常见的输入输出设备"></a>常见的输入输出设备</h2><p>常见输入设备：</p>
<ul>
<li>字符输入设备：键盘</li>
<li>图像输入设备：鼠标、数位板、扫描仪</li>
</ul>
<p>图像输出设备：显示器、打印机、投影仪</p>
<h2 id="输入输出接口的通用设计"><a href="#输入输出接口的通用设计" class="headerlink" title="输入输出接口的通用设计"></a>输入输出接口的通用设计</h2><p>按照一般的设计思维，输入输出接口首先要有<strong>读写设备数据</strong>的功能，即计算机既可以读取输入设备的数据，也可以向输出设备中写数据；其次，计算机应该有<strong>感知设备是否被占用</strong>的功能，因为有些输入输出设备是独占式的，计算机必须感知到设备是否可用，进而设计不同情况下的处理策略；第三，接口应该被设计为可以<strong>判断设备是否已经连接成功</strong>的功能；第四，接口应该具备<strong>判断设备是否已经启动</strong>的功能。</p>
<h3 id="数据线"><a href="#数据线" class="headerlink" title="数据线"></a>数据线</h3><p>数据线是I/O设备与主机之间进行数据交换的传送线。根据IO设备的不同，数据线可分为：单向传输数据线和双向传输数据线。</p>
<h3 id="状态线"><a href="#状态线" class="headerlink" title="状态线"></a>状态线</h3><p>状态线是IO设备向主机报告自身状态的信号线。通过状态线，主机就可以查询设备是否已经正常连接并就绪，或查询设备是否已经被其它进程占用了。</p>
<h3 id="命令线"><a href="#命令线" class="headerlink" title="命令线"></a>命令线</h3><p>命令线是CPU向IO设备发送命令的信号线。比如发送读写信号，发送启动/停止信号。</p>
<p>以CPU读取磁盘上某个区域的数据为例，CPU首先会向磁盘设备发送读数据的信号。以光驱为例，CPU会向光驱设备发送启动/停止信号，以此来启动/停止光驱的马达。</p>
<h3 id="设备选择线"><a href="#设备选择线" class="headerlink" title="设备选择线"></a>设备选择线</h3><p>设备选择线是主机选择与某个I/O设备进行交互的信号线。通过设备选择线，主机就可以对连在总线上的I/O设备进行选择。</p>
<p>假设在USB总线上连接了3个U盘，此时，计算机对某个U盘的读写操作就是通过设备选择线来选择具体的U盘进行操作的。</p>
<h2 id="CPU与IO设备的通信"><a href="#CPU与IO设备的通信" class="headerlink" title="CPU与IO设备的通信"></a>CPU与IO设备的通信</h2><p>CPU速度与IO设备速度不一致。</p>
<h3 id="程序中断"><a href="#程序中断" class="headerlink" title="程序中断"></a>程序中断</h3><p>当外围的IO设备就绪时，就会向CPU发出中断信号，CPU内部有专门的电路来响应中断信号。当CPU收到中断信号后，就会暂停当前正在执行的工作，转为执行外围IO设备的工作。直到外围IO设备的工作执行完毕后，CPU才会继续执行之前暂停的工作。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912153148820.png" alt="image-20220912153148820"></p>
<p><code>发送中断（IO设备） -&gt; 响应中断（CPU） -&gt; 中断返回（CPU）</code> 的例子</p>
<p>以上图为例，</p>
<ul>
<li>在时间点1，CPU正在执行主程序，打印机处于待机状态；</li>
<li>在时间点2，CPU向打印机发送了一条“启动打印机”的命令，然后在时间点3切换任务重新回去执行主程序。打印机在收到命令后，开始做启动打印机的准备工作，当然，这个时间段相对较长一些；</li>
<li>在时间点4，当打印机准备就绪后，就会给CPU发送一个<strong>“程序中断”</strong>信号，CPU在收到这个信号后，就会发送这次中断，暂停正在执行的主程序，转而处理打印机的任务——向打印机发送要打印的数据。需要注意的是：CPU响应中断不一定是立即发生的，可能会有一定时延，比如有一个任务优先级非常高，那么此时这个打印机发送的中断就不会被立即响应。这里为了简化理解，我们省略了一些细节。</li>
<li>时间点4到时间点5之间就是CPU与打印机数据交换的过程，CPU发送数据，打印机接收数据。</li>
<li>在时间点5之后，打印机发送完数据后就切换任务重新去执行主程序了，而打印机接收完数据后就开始执行打印数据的过程了。</li>
</ul>
<p><strong>总结：</strong></p>
<p><code>程序中断提供了低速设备通知CPU的一种异步的方式，CPU可以高速运转同时兼顾低速设备的响应。</code></p>
<p><strong>不足：</strong></p>
<p>虽然通过“程序中断”，CPU可以高速运转同时兼顾低速设备的响应，但是外围设备频繁地打断CPU并不是一个很好的方式，因为CPU频繁切换线程会降低CPU的使用效率。因此，计算机内部还有一种不需要CPU参与的数据访问方式——DMA（直接存储器访问）。</p>
<h3 id="DMA（直接存储器访问）"><a href="#DMA（直接存储器访问）" class="headerlink" title="DMA（直接存储器访问）"></a>DMA（直接存储器访问）</h3><ul>
<li>DMA 也是一种硬件设备；</li>
<li>它直接连接主存与 IO 设备；</li>
<li>工作时不需要 CPU 的参与。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912155759946.png" alt="image-20220912155759946"></p>
<p>我们平时使用的硬盘、外置显卡等硬件中都有DMA这一设备。</p>
<hr>
<h1 id="计算机存储器概览"><a href="#计算机存储器概览" class="headerlink" title="计算机存储器概览"></a>计算机存储器概览</h1><h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><p><strong>按存储介质分类</strong></p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912161843335.png" alt="image-20220912161843335"></p>
<p><strong>按存取方式分类</strong></p>
<ul>
<li>随机存储器（RAM）：可读可写，存储器的任何一个单元随时都能被读（随机读取），但写不是随机的。</li>
<li>串行存储器：可读可写，但读取数据的时候需要按照数据写入的顺序从头开始查找。</li>
<li>只读存储器（ROM）：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912161918767.png" alt="image-20220912161918767"></p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="存储器的评价指标"><a href="#存储器的评价指标" class="headerlink" title="存储器的评价指标"></a>存储器的评价指标</h3><ul>
<li>读写速度：5400转、7200转</li>
<li>存储容量：2T、4G</li>
<li>价格</li>
</ul>
<p>存储器的这些评价指标是影响存取器层级结构的关键因素。</p>
<h3 id="存储器的层次结构-1"><a href="#存储器的层次结构-1" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p>位价是衡量存储器的指标，它综合考量了读写速度、存储容量及价格在内的一系列因素。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912162811913.png" alt="image-20220912162811913"></p>
<ul>
<li>缓存指CPU中的寄存器及高速缓存；</li>
<li>主存指计算机的内存；</li>
<li>辅存指计算机的一些外部存储设备，比如磁盘、U盘、硬盘等。</li>
</ul>
<h4 id="缓存-主存层次"><a href="#缓存-主存层次" class="headerlink" title="缓存-主存层次"></a>缓存-主存层次</h4><ul>
<li>原理：局部性原理</li>
<li>实现：在CPU与主存之间增加一层速度快（容量小）的 Cache</li>
<li><strong>目的：解决主存速度不足的问题。</strong></li>
</ul>
<p>因为有高速缓存的存在，所以让CPU尽可能多地区访问高速缓存而非主存，所以高速缓存中最好保存的都是一些热点数据，以此来提交CPU访问数据的命中率，进而提高CPU的利用率。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912163305685.png" alt="image-20220912163305685"></p>
<p><strong>局部性原理：</strong></p>
<blockquote>
<p>局部性原理是指CPU访问存储器时，无论是<code>存/取指令</code>还是<code>存/取数据</code>，所访问的存储单元都 <code>趋于聚集在一个较小的连续区域中 </code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912164137379.png" alt="image-20220912164137379"></p>
<h4 id="主存-辅存层次"><a href="#主存-辅存层次" class="headerlink" title="主存-辅存层次"></a>主存-辅存层次</h4><ul>
<li>原理：局部性原理</li>
<li>实现：主存之外增加辅助存储器（磁盘、 SD 卡、 U 盘等）</li>
<li><strong>目的：解决主存容量不足的问题</strong></li>
</ul>
<p>假设你在电脑上装了一个30G的游戏，而你的电脑只有8G内存，那游戏是怎么跑起来的呢？这其实利用了局部性原理，电脑会将当前正在使用的数据加载到内存中，而对于一大部分不使用的数据则存放到辅存中去，通过主存和辅存频繁的数据交换来保证游戏的正常运行。这也是为什么我们在游戏中切换场景时会需要长时间 loading 的原因，因为切换场景需要交换的数据一般是比较多的，所以等待时间比较长。</p>
<h2 id="计算机的主存储器与辅助存储器"><a href="#计算机的主存储器与辅助存储器" class="headerlink" title="计算机的主存储器与辅助存储器"></a>计算机的主存储器与辅助存储器</h2><p>两个问题：</p>
<ul>
<li>为什么断电后，计算机内存中的数据会丢失？</li>
<li>为什么断电后，磁盘中的数据不会丢失？</li>
</ul>
<h3 id="主存储器——内存"><a href="#主存储器——内存" class="headerlink" title="主存储器——内存"></a>主存储器——内存</h3><ul>
<li>内存是一种RAM （随机存取存储器 Random Access Memory）</li>
<li>为什么断电后，主存中的数据会丢失：RAM 是通过<strong>电容</strong>来存储数据，必须隔一段时间刷新一次，刷新时必须连接点断；如果断电后，电容中的电子将会丢失，那么一段时间后将丢失所有数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913214628968.png" alt="image-20220913214628968"></p>
<p>主存储器由半导体存储体、驱动器、译码器、读写电路和控制电路组成。</p>
<p>主存如何与CPU进行交互：对于CPU而言，其内部有一个<code>主存数据寄存器（MDR）</code>，它会通过数据总线与读写电路进行连接，同时在CPU中还有一个<code>主存地址寄存器（MAR）</code>，它会通过地址总线与内存进行连接。有了数据总线和地址总线后，CPU 可以通过地址总线来指定将要读写内存中的哪一块数据，同时通过数据总线进行相关数据的传输。</p>
<p>主存与操作系统的位数也有一定的关系，我们平时所说的32位系统和64位系统，不同位数的系统对内存的要求也是不一样的，比如32位系统，最多只能支持4GB的内存，因为32位系统的地址总线最多只有 2^32 位，所以它的寻址范围最大只有4GB。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913215812034.png" alt="image-20220913215812034"></p>
<h3 id="辅助存储器——磁盘"><a href="#辅助存储器——磁盘" class="headerlink" title="辅助存储器——磁盘"></a>辅助存储器——磁盘</h3><h4 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h4><ul>
<li>表面是可磁化的硬磁特性材料</li>
<li>移动磁头读取磁道信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913215847990.png" alt="image-20220913215847990"></p>
<p>对于辅助存储器，它由<code>盘片</code>和<code>磁头</code>组成。盘片利用磁材料存储数据，磁头通过左右移动来读取盘片上存储的数据。</p>
<p><code>磁道</code>是指磁盘上某一圈存储的内容。</p>
<p><code>盘片</code>的一个平面结构如下：它会包含很多<code>磁道</code>，每条磁道又由多个<code>扇区</code>组成。通过<code>磁头位置</code>来描述磁头目前正处于哪一条磁道，通过<code>磁头方向</code>来描述磁头的旋转方向（顺时针/逆时针）</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913220238225.png" alt="image-20220913220238225"></p>
<h4 id="磁盘的调度算法"><a href="#磁盘的调度算法" class="headerlink" title="磁盘的调度算法"></a>磁盘的调度算法</h4><ul>
<li>先来先服务算法</li>
<li>最短寻道时间优先</li>
<li>扫描算法（电梯算法）</li>
<li>循环扫描算法</li>
</ul>
<img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913220816598.png" alt="image-20220913220816598" style="zoom: 50%;">

<p>假设最外圈磁道为磁道1，最内圈磁道为磁道5。假设磁头当前位于磁道4，并且磁头方向向外，现在CPU接到几个读取磁盘的任务，要求分别读取位置在 <code>1 4 2 3 1 5</code> 磁道上的数据。</p>
<h5 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h5><blockquote>
<p>按顺序访问进程的磁道读写需求</p>
</blockquote>
<p>对于<strong>FIFO</strong>算法，它会依次读取 1、4、2、3、1、5 磁道上的数据，平平无奇。</p>
<h5 id="最短寻道时间优先算法"><a href="#最短寻道时间优先算法" class="headerlink" title="最短寻道时间优先算法"></a>最短寻道时间优先算法</h5><blockquote>
<p>与磁头当前位置有关</p>
<p>优先访问离磁头最近的磁道</p>
</blockquote>
<p>对于<code>最短寻道时间优先算法</code>，我们可以先对磁道离磁头的距离做一个排序，分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">磁道4：0</span><br><span class="line">磁道3：1</span><br><span class="line">磁道2：2</span><br><span class="line">磁道1：3</span><br><span class="line">磁道5：1</span><br></pre></td></tr></table></figure>

<p>所以，CPU会依次读取4、5、3、2、1、1磁道上的数据。这里有一个问题是，磁道5和磁道3距离磁道4的距离都是1，至于它会先读取哪个磁道，我也没有看过具体的调度策略。</p>
<h5 id="扫描算法（电梯算法）"><a href="#扫描算法（电梯算法）" class="headerlink" title="扫描算法（电梯算法）"></a>扫描算法（电梯算法）</h5><ul>
<li>每次只往一个方向移动</li>
<li>到达一个方向需要服务的尽头再反方向移动</li>
</ul>
<p>因为当前磁头的运动方向是向外的，所以CPU最终访问磁盘的顺序是：4、3、2、1、1、5</p>
<h5 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h5><p>可以想象成把扫描算法的首尾连成了一个环。</p>
<p>因为当前磁头的运动方向是向外的，所以CPU最终访问磁盘的顺序是：4、3、2、1、1、5</p>
<hr>
<h2 id="计算机的高速缓存"><a href="#计算机的高速缓存" class="headerlink" title="计算机的高速缓存"></a>计算机的高速缓存</h2><p><code>CPU &lt;-&gt; 高速缓存 &lt;-&gt; 主存</code></p>
<p>高速缓存是CPU与主存之间的中间层，是为了解决CPU与主存速度不匹配而存在的。</p>
<h3 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h3><p><strong>字</strong>：是指存放在一个存储单元中的二进制代码组合<br><strong>字块</strong>：存储在<code>连续的</code>存储单元中而被看作是一个单元的一组字</p>
<p>假设一个字为32位，一个字块共B个字，那么<code>B*M</code>就是主存的总字数，<code>B*M*32</code>就是主存的总容量。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913225611387.png" alt="image-20220913225611387"></p>
<ul>
<li>字的地址包含两个部分</li>
<li>前m位指定字块的地址</li>
<li>后b位指定指定字在字块中的地址</li>
</ul>
<p>知道<strong>字</strong>与<strong>字块</strong>的概念有助于了解寻址的过程，对于<code>字的寻址</code>，首先会找到所在字块的地址，然后在字块中根据字的地址进行定位。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913230009309.png" alt="image-20220913230009309"></p>
<p>对于高速缓存中的数据而言，只存在两种情况，命中和未命中：</p>
<ul>
<li>CPU需要的数据在缓存里；</li>
<li>CPU需要的数据不在缓存里；-&gt;不在缓存中的数据需要去主存拿</li>
</ul>
<p>命中率：命中率是衡量缓存的重要性能指标。理论上 CPU 每次都能从高速缓存取数据的时候，命中率为 1。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913230819040.png" alt="image-20220913230819040"></p>
<blockquote>
<p>访问高速缓存的次数占访问总次数的比例。</p>
</blockquote>
<h3 id="高速缓存的替换策略"><a href="#高速缓存的替换策略" class="headerlink" title="高速缓存的替换策略"></a>高速缓存的替换策略</h3><p>为了保证缓存的利用率尽可能高，需要在不同场景下使用不同的缓存替换策略。</p>
<p><strong>高速缓存的替换时机：</strong>当CPU不能从高速缓存中获得所需的数据时，就需要从主存中载入所需数据，这时候就会执行数据的替换策略。</p>
<ul>
<li>随机算法</li>
<li>先进先出算法</li>
<li>最不经常使用算法 </li>
<li>最近最少使用算法</li>
</ul>
<hr>
<h1 id="计算机的指令系统"><a href="#计算机的指令系统" class="headerlink" title="计算机的指令系统"></a>计算机的指令系统</h1><h2 id="机器指令的形式"><a href="#机器指令的形式" class="headerlink" title="机器指令的形式"></a>机器指令的形式</h2><p>机器指令主要由两部分组成：操作码 + 地址码</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913231746532.png" alt="image-20220913231746532"></p>
<ul>
<li>操作码指明指令所要完成的操作。操作码的位数反映了机器的操作种类，比如对于8位的操作码，它的操作方式最多就只有<code>2^8=256</code>种。</li>
<li>地址码直接给出操作数或者操作数的地址。因为指令要服务于数据，CPU可以根据数据或数据地址进行相关运算。而地址码就是指向数据或数据的地址。地址码分三地址指令、二地址指令和一地址指令。三地址码指令指的是地址码中包含3个数据或数据地址，其它两个也类似。</li>
</ul>
<p><strong>三地址指令</strong></p>
<p>三地址码指令常见的操作如下，假设 Operation 为加法操作，常见的操作是：把addr1上的数据加到addr2上，并将最终结果写到addr3。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913232300660.png" alt="image-20220913232300660"></p>
<p><strong>二地址指令</strong></p>
<p>二地址指令常见的操作是 addr1+addr2，最后把结果存入 addr1 或者 addr2。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913233114057.png" alt="image-20220913233114057"></p>
<p><strong>一地址指令</strong></p>
<p>一地址指令就是自己对自己操作，最终把自己写入当前地址。常见的有自增、自减操作等。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913233210844.png" alt="image-20220913233210844"></p>
<p><strong>零地址指令</strong></p>
<p>零地址指令指没有地址码部分的机器指令。通过是一些不需要操作数据的指令，比如空操作、停机操作、中断返回操作等。</p>
<h2 id="机器指令的操作类型"><a href="#机器指令的操作类型" class="headerlink" title="机器指令的操作类型"></a>机器指令的操作类型</h2><h3 id="数据传输："><a href="#数据传输：" class="headerlink" title="数据传输："></a>数据传输：</h3><ul>
<li>数据传输发生在寄存器之间、寄存器与存储单元之间、存储单元之间<ul>
<li>存储单元包括：高速缓存、主存、辅存等一系列硬件设施，</li>
</ul>
</li>
<li>数据传输包括：数据读写、交换地址数据、清零置一等操作</li>
</ul>
<h3 id="算术逻辑操作"><a href="#算术逻辑操作" class="headerlink" title="算术逻辑操作"></a>算术逻辑操作</h3><ul>
<li>操作数之间的加减乘除运算</li>
<li>操作数的与或非等逻辑位运算</li>
</ul>
<h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><ul>
<li>数据左移（乘2）</li>
<li>数据右移（除2）</li>
</ul>
<h3 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h3><p>控制指令主要包括：等待指令、停机指令、空操作指令、中断指令等</p>
<h2 id="机器指令的寻址方式"><a href="#机器指令的寻址方式" class="headerlink" title="机器指令的寻址方式"></a>机器指令的寻址方式</h2><p>机器指令是怎样找到相关数据的！</p>
<p>首先要找到如何操作数据的指令，接着要找到待操作的数据。</p>
<h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><ul>
<li><p><strong>顺序寻址</strong></p>
</li>
<li><p><strong>跳跃寻址</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913235659272.png" alt="image-20220913235659272"></p>
<p>以上图为例，指令101~105是按顺序执行的，这就叫做顺序寻址；但是地址105的指令内容是跳到102地址，这就是一个跳跃寻址。</p>
<h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><ul>
<li>立即寻址</li>
<li>直接寻址</li>
<li>间接寻址</li>
</ul>
<p><strong>立即寻址</strong></p>
<p>通过指令可以直接获得操作数的方式叫<strong>立即寻址</strong>，也就是说，在指令的地址码部分直接包含了需要操作的数据。这种情况下，运行指令的时候就无需访问存储器，直接从指令中获得操作数即可。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914000224896.png" alt="image-20220914000224896"></p>
<p><strong>直接寻址</strong></p>
<p>直接寻址是指，机器指令的地址码部分直接给出了操作数在主存中的地址，直接通过这个地址就可以访问到操作数，无需计算操作数的地址。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914000615931.png" alt="image-20220914000615931"></p>
<p><strong>间接寻址</strong></p>
<p>间接寻址是指指令中的地址码给出的是操作数地址的地址，我们需要访问一次或多次主存来获取操作数。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914000758266.png" alt="image-20220914000758266"></p>
<p><strong>三种寻址方式的比较</strong></p>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>立即寻址</td>
<td>速度快</td>
<td>地址码位数限制操作数表示范围</td>
</tr>
<tr>
<td>直接寻址</td>
<td>寻找操作数简单</td>
<td>地址码位数限制操作数寻址范围</td>
</tr>
<tr>
<td>间接寻址</td>
<td>操作数寻址范围大</td>
<td>速度较慢</td>
</tr>
</tbody></table>
<h1 id="计算机的控制器（CPU组件之一）"><a href="#计算机的控制器（CPU组件之一）" class="headerlink" title="计算机的控制器（CPU组件之一）"></a>计算机的控制器（CPU组件之一）</h1><p>计算机的控制器是协调和控制计算机运行的。</p>
<p>计算机的控制器主要包含以下组件：</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914234102144.png" alt="image-20220914234102144"></p>
<p><strong>程序计数器</strong>：</p>
<p>程序计数器用于存储下一条要执行的指令的地址。当CPU工作时，会循环不断地从程序计数器中拿出指令的地址，进而找打指令并执行，当这个地址被拿出时，程序计数器会指向下一条指令的地址。</p>
<p>所以说，程序计数器是用于提供给其它控制单元，当前要执行的指令的地址的。</p>
<p><strong>时序发生器</strong></p>
<ul>
<li>电气工程领域，用于发送时序脉冲。</li>
<li>CPU依据不同的时序脉冲有节奏的进行工作。</li>
</ul>
<p><strong>指令译码器</strong></p>
<ul>
<li>指令译码器是控制器的主要部件之一。</li>
<li>前面我们讲过了，计算机指令由操作码和地址码两部分组成。</li>
<li>指令译码器的工作就是将操作码或地址码翻译成对应的操作，以及控制传输地址码对应的数据。</li>
</ul>
<p><strong>指令寄存器</strong></p>
<ul>
<li>指令寄存器也是控制器的主要部件之一</li>
<li>它的作用是从主存或者高速缓存中取计算机指令，这样CPU就可以直接从指令寄存器中拿到指令并运算了，速度更快。</li>
</ul>
<p><strong>主存地址寄存器</strong></p>
<ul>
<li>保存当前CPU正要访问的内存单元的地址</li>
<li>使用地址总线与主存通信。</li>
</ul>
<p><strong>主存数据寄存器</strong></p>
<ul>
<li>保存当前CPU正要读或者些的主存数据</li>
<li>使用数据总线与主存通信。</li>
</ul>
<p><strong>通用寄存器</strong></p>
<ul>
<li>用于暂时存放或传送数据或指令</li>
<li>可保存ALU运算的中间结果</li>
<li>容量比一般专用寄存器要大</li>
</ul>
<h1 id="计算机的运算器（CPU组件之一）"><a href="#计算机的运算器（CPU组件之一）" class="headerlink" title="计算机的运算器（CPU组件之一）"></a>计算机的运算器（CPU组件之一）</h1><p>运算器使用来进行数据运算加工的。</p>
<p>主要由数据缓冲器、ALU、通用寄存器、状态字寄存器组成。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914235904462.png" alt="image-20220914235904462"></p>
<p><strong>数据缓冲器</strong>：数据缓冲器分为输入缓冲和输出缓冲。输入缓冲用于暂时存放外设传送过来的数据；输出缓冲用于暂时存放发往外设的数据。也就是说，ALU在运算时下一个数据是从缓冲区中获取的，同样，ALU在运算完毕时会先将数据保存在输出缓冲中，等待控制器下一步的命令，把它送到相应的位置。</p>
<p><strong>ALU</strong></p>
<ul>
<li>ALU：算术逻辑单元，是运算器的重要组成部分</li>
<li>可以完成常见的位运算（左右位移、与或非等）</li>
<li>完成算术运算（加减乘除）</li>
</ul>
<p><strong>状态字寄存器</strong></p>
<p>状态寄存器主要存放一些运算中的状态，比如：条件码、进位、溢出、结果正负等；</p>
<p>同时它也可以存放一些运算控制信息（比如调试跟踪标记位、允许中断位等）</p>
<p><strong>通用寄存器</strong></p>
<ul>
<li>用于暂时存放或传送数据或指令</li>
<li>可以保存ALU的运算中间结果</li>
<li>容量一般比专用寄存器要大</li>
</ul>
<h1 id="计算机指令的执行过程"><a href="#计算机指令的执行过程" class="headerlink" title="计算机指令的执行过程"></a>计算机指令的执行过程</h1><h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p>整体来说，指令执行的过程可分为3步：<code>取指令 -&gt; 分析指令 -&gt; 执行指令</code></p>
<p>指令执行过程中涉及到的一些设备：</p>
<ul>
<li>数据缓存器</li>
<li>指令缓存器</li>
<li>运算器（ALU）</li>
<li>寄存器<ul>
<li>数据缓存器</li>
<li>状态字寄存器</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220915001916422.png" alt="image-20220915001916422"></p>
<h2 id="CPU的流水线设计"><a href="#CPU的流水线设计" class="headerlink" title="CPU的流水线设计"></a>CPU的流水线设计</h2>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/09/10/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" rel="prev" title="git常用操作">
                  <i class="fa fa-chevron-left"></i> git常用操作
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
