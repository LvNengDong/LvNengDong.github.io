<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="声明   本文所有内容均参考自Guava官方文档，是在对官方文档汉化的基础上形成的。  Guava 工程是Google公司开发的一个类库，它被广泛应用在Google公司开发的Java项目中，其中包含了对：    集合[collections]   缓存[chahing]   原生类型支持[primitives support]   并发库[concurrency libraries]   通">
<meta property="og:type" content="article">
<meta property="og:title" content="Guava">
<meta property="og:url" content="http://example.com/2022/06/14/Guava/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="声明   本文所有内容均参考自Guava官方文档，是在对官方文档汉化的基础上形成的。  Guava 工程是Google公司开发的一个类库，它被广泛应用在Google公司开发的Java项目中，其中包含了对：    集合[collections]   缓存[chahing]   原生类型支持[primitives support]   并发库[concurrency libraries]   通">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://processon.com/chart_image/62a88f780e3e747c5c433c56.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220627185355351.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220620220652695.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220620223152644.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220621123921407.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220621125041695.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220618182414129.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220618201827157.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220618203756169.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220618204633138.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220621181533957.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220626213840626.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220626215615258.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220621210614019.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220621212601535.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220620213131901.png">
<meta property="og:image" content="http://example.com/2022/06/14/Guava/image-20220620214807393.png">
<meta property="article:published_time" content="2022-06-14T13:28:16.000Z">
<meta property="article:modified_time" content="2022-07-08T05:32:24.536Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://processon.com/chart_image/62a88f780e3e747c5c433c56.png">


<link rel="canonical" href="http://example.com/2022/06/14/Guava/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/06/14/Guava/","path":"2022/06/14/Guava/","title":"Guava"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Guava | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE-%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">目  录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7-Basic-utilities"><span class="nav-number">1.1.</span> <span class="nav-text">1.基本工具[Basic utilities]</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7-Basic-utilities"><span class="nav-number">2.</span> <span class="nav-text">基本工具[Basic utilities]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%81%BF%E5%85%8D%E5%92%8C%E4%BD%BF%E7%94%A8null"><span class="nav-number">2.1.</span> <span class="nav-text">1 避免和使用null</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8null%EF%BC%9F"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 为什么要避免使用null？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AF%B9null%E8%BF%9B%E8%A1%8C%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%9AOptional"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 对null进行的优化：Optional</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-Optional%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">1.2.1 Optional快速入门</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAOptional%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">1.2.2 创建一个Optional对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-Optional%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">1.2.3 Optional实例方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Java%E4%B8%AD%E7%9A%84Optional"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.3 Java中的Optional</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BC%98%E9%9B%85%E7%9A%84%E6%A3%80%E9%AA%8C%E5%8F%82%E6%95%B0-Preconditions"><span class="nav-number">2.2.</span> <span class="nav-text">2 优雅的检验参数[Preconditions]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84Object%E6%96%B9%E6%B3%95-Objects"><span class="nav-number">2.3.</span> <span class="nav-text">3. 常见的Object方法[Objects]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#compareTo"><span class="nav-number">2.3.1.</span> <span class="nav-text">compareTo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8-Ordering"><span class="nav-number">2.4.</span> <span class="nav-text">4. 强大的比较器(Ordering)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88-Collections"><span class="nav-number">3.</span> <span class="nav-text">集合[Collections]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88-Immutable-Collections"><span class="nav-number">3.1.</span> <span class="nav-text">不可变集合[Immutable Collections]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%EF%BC%9F"><span class="nav-number">3.1.1.</span> <span class="nav-text">为什么要使用不可变集合？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.2.</span> <span class="nav-text">创建一个不可变集合对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="nav-number">3.1.3.</span> <span class="nav-text">使用不可变集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#asList-%E8%A7%86%E5%9B%BE"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">asList 视图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-number">3.1.4.</span> <span class="nav-text">可变集合与不可变集合的对应关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-New-Collection-Types"><span class="nav-number">3.2.</span> <span class="nav-text">新的集合类型[New Collection Types]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Multiset"><span class="nav-number">3.2.1.</span> <span class="nav-text">Multiset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Multiset%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">Multiset初体验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multiset%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%86%E8%A7%92"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">Multiset的两种视角</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multiset-%E4%B8%8D%E6%98%AF-Map"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">Multiset 不是 Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multiset-%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">Multiset 的各种实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SortedMultiset"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">SortedMultiset</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multimap"><span class="nav-number">3.2.2.</span> <span class="nav-text">Multimap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-Multimap"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">修改 Multimap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multimap%E7%9A%84%E8%A7%86%E5%9B%BE"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">Multimap的视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multimap%E4%B8%8D%E6%98%AFMap"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">Multimap不是Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multimap%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">Multimap的各种实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BiMap"><span class="nav-number">3.2.3.</span> <span class="nav-text">BiMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BiMap%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">BiMap的各种实现类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Table"><span class="nav-number">3.2.4.</span> <span class="nav-text">Table</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Table%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">Table的实现类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassToInstanceMap"><span class="nav-number">3.2.5.</span> <span class="nav-text">ClassToInstanceMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ClassToInstanceMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">ClassToInstanceMap的实现类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RangeSet"><span class="nav-number">3.2.6.</span> <span class="nav-text">RangeSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RangeMap"><span class="nav-number">3.2.7.</span> <span class="nav-text">RangeMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E5%A4%A7%E7%9A%84%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">3.3.</span> <span class="nav-text">强大的集合工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Lists%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%93%8D%E4%BD%9CList%E9%9B%86%E5%90%88"><span class="nav-number">3.3.1.</span> <span class="nav-text">使用Lists工具类操作List集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Sets%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%93%8D%E4%BD%9CSet%E9%9B%86%E5%90%88"><span class="nav-number">3.3.2.</span> <span class="nav-text">使用Sets工具类操作Set集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.3.</span> <span class="nav-text">静态工厂方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterables"><span class="nav-number">3.3.4.</span> <span class="nav-text">Iterables</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A5%E5%85%B7"><span class="nav-number">4.</span> <span class="nav-text">字符串工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8-Joiner"><span class="nav-number">4.1.</span> <span class="nav-text">连接器[Joiner]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="nav-number">4.1.1.</span> <span class="nav-text">静态方法(连接器工厂)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">普通方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BBMapJoiner"><span class="nav-number">4.1.3.</span> <span class="nav-text">内部类MapJoiner</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E5%99%A8-Splitter"><span class="nav-number">4.2.</span> <span class="nav-text">拆分器[Splitter]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E6%8B%86%E5%88%86%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="nav-number">4.2.1.</span> <span class="nav-text">静态方法(拆分器工厂)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95-1"><span class="nav-number">4.2.2.</span> <span class="nav-text">普通方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E5%99%A8%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">拆分器修饰方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E5%99%A8%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">拆分器执行方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BBMapSplitter"><span class="nav-number">4.2.3.</span> <span class="nav-text">内部类MapSplitter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%99%A8-CharMatcher"><span class="nav-number">4.3.</span> <span class="nav-text">字符串匹配器(CharMatcher)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text">获取字符串匹配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">使用字符串匹配器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86-Charsets"><span class="nav-number">4.4.</span> <span class="nav-text">字符集(Charsets)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E6%A0%BC%E5%BC%8F-CaseFormat"><span class="nav-number">4.5.</span> <span class="nav-text">大小写格式(CaseFormat)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Strings%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">4.6.</span> <span class="nav-text">Strings工具类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Guava%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-Functional"><span class="nav-number">5.</span> <span class="nav-text">Guava的函数式编程[Functional]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Predicate"><span class="nav-number">5.1.</span> <span class="nav-text">Predicate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function"><span class="nav-number">5.2.</span> <span class="nav-text">Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Supplier"><span class="nav-number">5.3.</span> <span class="nav-text">Supplier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Functional"><span class="nav-number">5.4.</span> <span class="nav-text">Functional</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Guava%E4%B9%8BI-O"><span class="nav-number">6.</span> <span class="nav-text">Guava之I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E5%AD%97%E8%8A%82%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">为字节流&#x2F;字符流提供的工具类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%EF%BC%88Source%EF%BC%89%E4%B8%8E%E6%B1%87%EF%BC%88Sink%EF%BC%89%EF%BC%9A%E5%AF%B9I-O%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="nav-number">6.2.</span> <span class="nav-text">源（Source）与汇（Sink）：对I&#x2F;O进一步的抽象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">6.3.</span> <span class="nav-text">实战案例：文件操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Files"><span class="nav-number">6.4.</span> <span class="nav-text">Files</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%AA%E6%96%87%E5%90%9BCollections"><span class="nav-number">7.</span> <span class="nav-text">汪文君Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FluentIterable"><span class="nav-number">7.1.</span> <span class="nav-text">FluentIterable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.1.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95-2"><span class="nav-number">7.1.2.</span> <span class="nav-text">普通方法</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/14/Guava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Guava | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Guava
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-14 21:28:16" itemprop="dateCreated datePublished" datetime="2022-06-14T21:28:16+08:00">2022-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-08 13:32:24" itemprop="dateModified" datetime="2022-07-08T13:32:24+08:00">2022-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaExt/" itemprop="url" rel="index"><span itemprop="name">JavaExt</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>  <strong>声明</strong></p>
<p>  本文所有内容均参考自<a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki">Guava官方文档</a>，是在对官方文档汉化的基础上形成的。</p>
</blockquote>
<p>Guava 工程是Google公司开发的一个类库，它被广泛应用在Google公司开发的Java项目中，其中包含了对：</p>
<ul>
<li>  集合[collections]</li>
<li>  缓存[chahing]</li>
<li>  原生类型支持[primitives support]</li>
<li>  并发库[concurrency libraries]</li>
<li>  通用注释[common annotations]</li>
<li>  字符串处理[string processing]</li>
<li>  I/O</li>
<li>  ……</li>
</ul>
<p>等多个模块的支持。所有这些工具每天都被Google工程师应用在产品服务中。</p>
<p><img src="http://processon.com/chart_image/62a88f780e3e747c5c433c56.png"></p>
<p>Guava依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="目-录"><a href="#目-录" class="headerlink" title="目  录"></a>目  录</h1><h2 id="1-基本工具-Basic-utilities"><a href="#1-基本工具-Basic-utilities" class="headerlink" title="1.基本工具[Basic utilities]"></a>1.基本工具[Basic utilities]</h2><p>让使用Java语言变得更舒适。</p>
<ol>
<li> 避免使用null：null是模棱两可的，过度使用null会引起不必要的错误。因此很多Guava工具类都不会使用null值代表失败。</li>
<li> 参数检查：让方法中的条件检查更简单。</li>
<li> 常见Object方法：简化Object方法的实现，如hashCode()和toString()</li>
<li> 排序：Guava强大的流畅风格比较器</li>
<li> Throwables：简化了异常和错误的传播与检查。</li>
</ol>
<h1 id="基本工具-Basic-utilities"><a href="#基本工具-Basic-utilities" class="headerlink" title="基本工具[Basic utilities]"></a>基本工具[Basic utilities]</h1><h2 id="1-避免和使用null"><a href="#1-避免和使用null" class="headerlink" title="1 避免和使用null"></a>1 避免和使用null</h2><h3 id="1-1-为什么要避免使用null？"><a href="#1-1-为什么要避免使用null？" class="headerlink" title="1.1 为什么要避免使用null？"></a>1.1 为什么要避免使用null？</h3><blockquote>
<p><strong>使用 null 的缺点：</strong></p>
</blockquote>
<p>null 代表不确定的对象，是一个很模糊的概念，非常容易产生歧义。</p>
<p>大多数情况下，使用 null 是为了表示<strong>某种缺失</strong>情况，但这并非是绝对的，还有一种情况是：就是想给某个对象赋值为 null。这种情况下就会产生歧义。比如：</p>
<blockquote>
<p><strong>问题：</strong></p>
</blockquote>
<p>如果 <code>Map.get(key)</code> 返回的 value 为 null，其代表的含义可能是该 key 指向的 value 是 null，也可能是该 key 在 map 中不存在。</p>
<blockquote>
<p><strong>优点：</strong></p>
</blockquote>
<p>当然，使用 null 也并非一无是处，null 本身不是对象（不是 Object 实例）。从内存消耗和效率方面来看，使用 null 是更为廉价的。</p>
<h3 id="1-2-对null进行的优化：Optional"><a href="#1-2-对null进行的优化：Optional" class="headerlink" title="1.2 对null进行的优化：Optional"></a>1.2 对null进行的优化：Optional</h3><p>为了解决使用 null 存在的种种弊端，Guava 引入了 <code>Optional&lt;T&gt;</code> 作为对 null 的上位替代。</p>
<p>Guava 中的 <code>Optional&lt;T&gt;</code> 表示了一种<strong>可能为null</strong>的 T 类型对象的引用。Optional 实例中可能包含对非 null 对象的引用（<em>引用存在</em>），也可能什么也不包括（<strong>引用缺失</strong>）。</p>
<h4 id="1-2-1-Optional快速入门"><a href="#1-2-1-Optional快速入门" class="headerlink" title="1.2.1 Optional快速入门"></a>1.2.1 Optional快速入门</h4><ul>
<li>API 所在包：<code>com.google.common.base.Optional</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; possible = Optional.fromNullable(t); <span class="comment">// 将一个T类型的实例包装成一个Optional对象（t可以为null）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">present</span> <span class="operator">=</span> possible.isPresent(); <span class="comment">// 若Optional包含的T实例不为null，则返回true；否则返回false</span></span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> possible.get(); <span class="comment">// 返回Optional包含T的实例，该T实例必须不为空，否则会抛出一个IllegalStateException异常</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-创建一个Optional对象"><a href="#1-2-2-创建一个Optional对象" class="headerlink" title="1.2.2 创建一个Optional对象"></a>1.2.2 创建一个Optional对象</h4><p>Guava 没有提供对 Optional 类公开的构造方法，而是使用工厂模式通过 Optional 类提供了3个创建 Optional 对象的静态方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td><code>Optional&lt;T&gt; fromNullable(T nullableReference)</code></td>
<td>T对象可以为null，也可以不为null</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; of(T reference)</code></td>
<td>T对象不能为null</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; absent()</code></td>
<td>得到的<code>Optional&lt;T&gt;</code>实例内的T实例一定为null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; optional1 = Optional.of(t); <span class="comment">//将一个T类型的实例转换为Optional对象（t不可以为null）</span></span><br><span class="line">Optional&lt;Object&gt; optional2 = Optional.absent(); <span class="comment">// 获得一个Optional对象，其内部为null</span></span><br><span class="line">Optional&lt;T&gt; optional3 = Optional.fromNullable(t); <span class="comment">// 将一个T类型的实例转换为Optional对象，实例t可以不为空，也可以为空</span></span><br><span class="line"><span class="comment">// Optional.fromNullable(null) 等同于 Optional.absent()</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-Optional实例方法"><a href="#1-2-3-Optional实例方法" class="headerlink" title="1.2.3 Optional实例方法"></a>1.2.3 Optional实例方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isPresent()</td>
<td>若Optional包含的T实例不为null，返回true；否则，返回false。</td>
</tr>
<tr>
<td>T get()</td>
<td>若Optional包含的T实例不为null，返回T；否则，抛出IllegalStateException</td>
</tr>
<tr>
<td>T or(T t)</td>
<td>若Optional包含的T实例不为null，返回T；否则，返回参数输入的T实例。</td>
</tr>
<tr>
<td>T orNull()</td>
<td>若Optional包含的T实例不为null，返回T；否则，返回null。</td>
</tr>
</tbody></table>
<h3 id="1-3-Java中的Optional"><a href="#1-3-Java中的Optional" class="headerlink" title="1.3 Java中的Optional"></a>1.3 Java中的Optional</h3><p>正是受到 Guava 的启发，Java8 将 Optional 类作为一个新特性引入自身的类库。所以在大多数时候，我们可以直接使用 Java8 的 Optional 类，以减少对外部 jar 包的依赖。</p>
<blockquote>
<p><strong>链接：<a href>Java8中的Optional新特性</a></strong></p>
<ul>
<li>TODO</li>
</ul>
</blockquote>
<hr>
<h2 id="2-优雅的检验参数-Preconditions"><a href="#2-优雅的检验参数-Preconditions" class="headerlink" title="2 优雅的检验参数[Preconditions]"></a>2 优雅的检验参数[Preconditions]</h2><p><strong>问题：</strong></p>
<p>当对外暴露的接口方法中的参数过多时，需要对参数进行必要的检查，以便将预期外的请求快速驳回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">someMethod</span><span class="params">(<span class="type">int</span> arg1, String arg2, String arg3, Object arg4)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg1&gt;<span class="number">0</span> &amp;&amp; isNotEmpty(arg2) &amp;&amp; isNotEmpty(arg3) &amp;&amp; arg4!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// maybe需要将具体的错误类型告诉调用方</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方案：</strong></p>
<p><code>com.google.common.base.Preconditions</code></p>
<table>
<thead>
<tr>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>checkArgument(boolean expression, String errorMessageTemplate, Object… errorMessageArgs)</td>
</tr>
<tr>
<td>checkNotNull(T reference, String errorMessageTemplate, Object… errorMessageArgs)</td>
</tr>
<tr>
<td>checkState(boolean expression, String errorMessageTemplate, Object… errorMessageArgs)</td>
</tr>
<tr>
<td>checkElementIndex(int index, int size, String desc);</td>
</tr>
<tr>
<td>checkPositionIndex(int index, int size, String desc);</td>
</tr>
<tr>
<td>checkPositionIndexes(int start, int end, int size)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查 boolean 类型的 expression 值是否为 true，</span></span><br><span class="line"><span class="comment"> * 失败时(值为false)抛出IllegalArgumentException并携带错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkArgument(<span class="type">boolean</span> expression, String errorMessageTemplate, Object... errorMessageArgs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查reference对象是否为null，失败时抛出NullPointerException并携带错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkNotNull(T reference, String errorMessageTemplate, Object... errorMessageArgs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查 expression 是否为 true，失败时抛出IllegalStateException并携带错误信息</span></span><br><span class="line"><span class="comment"> * 相比于checkArgument，该方法在某些场景下更有语义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkState(<span class="type">boolean</span> expression, String errorMessageTemplate, Object... errorMessageArgs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查index是否在合法范围 [0,size) 内(不包含size)，若不在合法范围内，</span></span><br><span class="line"><span class="comment"> * 则抛出IndexOutOfBoundsException并携带错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkElementIndex(<span class="type">int</span> index, <span class="type">int</span> size, String desc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查index是否在合法范围 [0,size] 内(包含size)，若不在合法范围内，</span></span><br><span class="line"><span class="comment"> * 则抛出IndexOutOfBoundsException并携带错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkPositionIndex(<span class="type">int</span> index, <span class="type">int</span> size, String desc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查[start, end)是否在 (0, size) 集合的合法子集范围内</span></span><br><span class="line"><span class="comment"> * 失败时抛出IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkPositionIndexes(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> size);</span><br></pre></td></tr></table></figure>

<p>上述六个方法是 Preconditions 类中的主要方法，当然，Preconditions 还提供了这些类不同参数的重载方法。</p>
<p>以 checkNotNull 为例，它的基本使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/21 16:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreconditionsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            checkNotNull(<span class="literal">null</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           System.out.println(e); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">           System.out.println(e.getMessage()); <span class="comment">// null</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkNotNullWithErrorMessage(<span class="literal">null</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">            System.out.println(e.getMessage()); <span class="comment">// list不能为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkNotNullWithFormatErrorMessage(<span class="literal">null</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">            System.out.println(e.getMessage()); <span class="comment">// list不能为空，errorCode为 9528</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查参数是否为null，若为null则抛出NullPointerException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkNotNull</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        Preconditions.checkNotNull(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查参数是否为null，若为null则抛出NullPointerException，</span></span><br><span class="line"><span class="comment">     * 并将 errorMessage 设置到 NullPointerException 对象的 message 中。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkNotNullWithErrorMessage</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(list, <span class="string">&quot;list不能为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查参数是否为null，若为null则抛出NullPointerException，</span></span><br><span class="line"><span class="comment">     * 并将 errorMessage 设置到 NullPointerException 对象的 message 中；</span></span><br><span class="line"><span class="comment">     * 还提供对 errorMessage 进行格式化的功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkNotNullWithFormatErrorMessage</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(list, <span class="string">&quot;list不能为空，errorCode为 %s&quot;</span>, <span class="number">9528</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>checkArgument</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_checkArgument</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">arg1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Preconditions.checkArgument(arg1.equals(<span class="string">&quot;World&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(e); <span class="comment">// java.lang.IllegalArgumentException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>checkElementIndex</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  现有一空数组，容量为 0。</span></span><br><span class="line"><span class="comment"> *  欲取数组中下标为 10 的位置上的元素，必然会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_checkElementIndex</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Preconditions.checkElementIndex(<span class="number">10</span>, list.size());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(e); <span class="comment">// java.lang.IndexOutOfBoundsException: index (10) must be less than size (0)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>checkPositionIndexes(int start, int end, int size)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preconditions.checkPositionIndexes(<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>); <span class="comment">//OK。size为10，[0,5) 在[0,10)的范围内</span></span><br><span class="line">Preconditions.checkPositionIndexes(<span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>); <span class="comment">//OK</span></span><br><span class="line">Preconditions.checkPositionIndexes(<span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// java.lang.IndexOutOfBoundsException: end index (5) must not be greater than size (4)</span></span><br><span class="line"><span class="comment">// size为4，[0,5) 不在[0,4) 的范围内</span></span><br></pre></td></tr></table></figure>







<hr>
<h2 id="3-常见的Object方法-Objects"><a href="#3-常见的Object方法-Objects" class="headerlink" title="3. 常见的Object方法[Objects]"></a>3. 常见的Object方法[Objects]</h2><p>帮助简化对象的 equals、hashCode、toString、compare、compareTo 等方法的编写。</p>
<h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h3><ul>
<li>实现 Comparable 接口；</li>
<li>重写 compareTo 方法，使用 ComparisonChain 简化比较过程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.ComparisonChain;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/17 0:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;User&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ComparisonChain.start()</span><br><span class="line">                .compare(<span class="built_in">this</span>.name, user.name)</span><br><span class="line">                .compare(<span class="built_in">this</span>.age, user.age)</span><br><span class="line">                .result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="4-强大的比较器-Ordering"><a href="#4-强大的比较器-Ordering" class="headerlink" title="4. 强大的比较器(Ordering)"></a>4. 强大的比较器(Ordering)</h2><p>Ordering 是 Guava 类库提供的一个强大的比较器工具。和 JDK 中的 Comparator 相比，Guava 中的 Ordering 功能更强，它非常容易扩展，可以很轻松地构造复杂的 Comparator。用于在容器中进行比较、排序等操作。</p>
<p><strong>常用静态方法：</strong></p>
<p><code>com.google.common.collect.Ordering</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ordering.natural(); <span class="comment">//使用Comparable类型的自然排序。比如：整数从小到大，字符串按字典顺序排序。</span></span><br><span class="line">Ordering.usingToString(); <span class="comment">//使用toString()返回的字符串按字典顺序进行排序</span></span><br><span class="line">Ordering.;</span><br><span class="line">Ordering.;</span><br><span class="line">Ordering.;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="集合-Collections"><a href="#集合-Collections" class="headerlink" title="集合[Collections]"></a>集合[Collections]</h1><p>Guava 中最成熟和为人所知的部分就是对 JDK 中集合的扩展。主要包括以下几部分：</p>
<ul>
<li>  <strong>不可变集合</strong></li>
<li>  <strong>新的集合类型</strong></li>
<li>  <strong>强大的集合工具类</strong></li>
<li>  <strong>扩展工具类</strong></li>
</ul>
<h2 id="不可变集合-Immutable-Collections"><a href="#不可变集合-Immutable-Collections" class="headerlink" title="不可变集合[Immutable Collections]"></a>不可变集合[Immutable Collections]</h2><h3 id="为什么要使用不可变集合？"><a href="#为什么要使用不可变集合？" class="headerlink" title="为什么要使用不可变集合？"></a>为什么要使用不可变集合？</h3><p>创建对象的<strong>不可变拷贝</strong>是一项很好的<strong>防御性编程</strong>技巧。因此，Guava 为所有 <strong>JDK标准集合</strong> 类型和 <strong>Guava新集合</strong> 类型都提供了简单易用的不可变版本。</p>
<p><strong>不可变对象的优点：</strong></p>
<ul>
<li>  当对象被不被信任的库调用时，不可变形式是安全的。</li>
<li>  不可变对象同时被多个线程调用时，不存在线程安全问题。</li>
<li>  不可变集合不需要考虑变化，因此可以节省时间和空间。</li>
<li>  不可变对象因为固定不变，可以作为常量来安全使用。</li>
</ul>
<p><strong>JDK中不可变集合的缺点：</strong></p>
<p>当然，JDK 的 Collections 工具类也为我们提供了诸多 <code>unmodifiableXxx()</code> 方法用于把集合包装为不可变形式。但相比 Guava 中的不可变集合存在如下缺点：</p>
<ul>
<li>  <strong>笨重而且累赘</strong>：不能舒适地用在所有想做防御性拷贝的场景；</li>
<li>  <strong>不安全</strong>：JDK 中的不可变集合是在原有集合的基础上进行包装产生的。如果原有集合被改变了，那么不可变集合也会随着改变。所以在使用时要保证没人通过原集合的引用进行修改，返回的集合才是真正不可变的。</li>
<li>  <strong>低效</strong>：包装过的集合仍然保有可变集合的开销，比如并发修改的检查、散列表的额外空间，等等。</li>
</ul>
<p>如果你没有修改某个集合的需求，或者希望某个集合保持不变时，把它防御性地拷贝到不可变集合是个很好的实践。</p>
<blockquote>
<p>  <strong>Tip</strong></p>
<p>  <em>所有Guava不可变集合的实现都不接受null值。我们对Google内部的代码库做过详细研究，发现只有5%的情况需要在集合中允许null元素，剩下的95%场景都是遇到null值就快速失败。如果你需要在不可变集合中使用null，请使用JDK中的Collections.unmodifiableXXX方法。</em></p>
</blockquote>
<h3 id="创建一个不可变集合对象"><a href="#创建一个不可变集合对象" class="headerlink" title="创建一个不可变集合对象"></a>创建一个不可变集合对象</h3><p>不可变集合可以通过如下多种方式创建：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>copyOf 方法</td>
<td>根据已存在的集合创建不可变集合</td>
</tr>
<tr>
<td>of 方法</td>
<td>直接通过多个值来创建不可变集合</td>
</tr>
<tr>
<td>Builder 工具</td>
<td>通过链式编程来创建不可变集合（灵活度高）</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何创建不可变集合？</span></span><br><span class="line"><span class="comment"> *  1、copyOf 方法</span></span><br><span class="line"><span class="comment"> *  2、of 方法</span></span><br><span class="line"><span class="comment"> *  3、Builder 工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 方式一：copyOf()</span></span><br><span class="line">    ImmutableList&lt;Integer&gt; USERS = ImmutableList.copyOf(Arrays.asList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：of()</span></span><br><span class="line">    <span class="keyword">final</span> ImmutableSet&lt;String&gt; COLOR_NAMES = ImmutableSet.of(</span><br><span class="line">            <span class="string">&quot;red&quot;</span>,</span><br><span class="line">            <span class="string">&quot;green&quot;</span>,</span><br><span class="line">            <span class="string">&quot;purple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式三：Builder</span></span><br><span class="line">    ImmutableSet&lt;String&gt; NEW_COLOR_NAMES = ImmutableSet.&lt;String&gt;builder()</span><br><span class="line">            .addAll(COLOR_NAMES)</span><br><span class="line">            .add(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用不可变集合"><a href="#使用不可变集合" class="headerlink" title="使用不可变集合"></a>使用不可变集合</h3><p>Guava 很好的兼容了 Java 原生的集合类型，除了对集合的写操作，原先对 Java 中集合的操作都可以用在 Guava 中的不可变集合对象上。</p>
<p><img src="/2022/06/14/Guava/image-20220627185355351.png" alt="image-20220627185355351"></p>
<p>从图中可以看出所有写操作涉及的 API 都是不被支持的。</p>
<h4 id="asList-视图"><a href="#asList-视图" class="headerlink" title="asList 视图"></a>asList 视图</h4><p>所有的不可变集合都有一个 asList() 方法，用于提供 ImmutableList 视图，来帮助你用列表的形式方便地读取集合中的元素。</p>
<p>例如，你可以使用 <code>sortedSet.asList().get(k)</code> 从 ImmutableSortedSet 中读取第 k 个最小的元素。</p>
<h3 id="可变集合与不可变集合的对应关系"><a href="#可变集合与不可变集合的对应关系" class="headerlink" title="可变集合与不可变集合的对应关系"></a>可变集合与不可变集合的对应关系</h3><table>
<thead>
<tr>
<th>可变集合接口</th>
<th>属于JDK还是Guava？</th>
<th>不可变版本</th>
</tr>
</thead>
<tbody><tr>
<td>Collection</td>
<td>JDK</td>
<td>ImmutableCollection</td>
</tr>
<tr>
<td>List</td>
<td>JDK</td>
<td>ImmutableList</td>
</tr>
<tr>
<td>Set</td>
<td>JDK</td>
<td>ImmutableSet</td>
</tr>
<tr>
<td>SortedSet/NavigableSet</td>
<td>JDK</td>
<td>ImmutableSortedSet</td>
</tr>
<tr>
<td>Map</td>
<td>JDK</td>
<td>ImmutableMap</td>
</tr>
<tr>
<td>SortedMap</td>
<td>JDK</td>
<td>ImmutableSortedMap</td>
</tr>
<tr>
<td>Multiset</td>
<td>Guava</td>
<td>ImmutableMultiset</td>
</tr>
<tr>
<td>SortedMultiset</td>
<td>Guava</td>
<td>ImmutableSortedMultiset</td>
</tr>
<tr>
<td>Multimap</td>
<td>Guava</td>
<td>ImmutableMultimap</td>
</tr>
<tr>
<td>ListMultimap</td>
<td>Guava</td>
<td>ImmutableListMultimap</td>
</tr>
<tr>
<td>SetMultimap</td>
<td>Guava</td>
<td>ImmutableSetMultimap</td>
</tr>
<tr>
<td>BiMap</td>
<td>Guava</td>
<td>ImmutableBiMap</td>
</tr>
<tr>
<td>ClassToInstanceMap</td>
<td>Guava</td>
<td>ImmutableClassToInstanceMap</td>
</tr>
<tr>
<td>Table</td>
<td>Guava</td>
<td>ImmutableTable</td>
</tr>
</tbody></table>
<hr>
<h2 id="新的集合类型-New-Collection-Types"><a href="#新的集合类型-New-Collection-Types" class="headerlink" title="新的集合类型[New Collection Types]"></a>新的集合类型[New Collection Types]</h2><p>Guava 引入了很多 JDK 没有的，但在开发中很有用的新的集合类型。这些新集合类型的底层依然是 JDK 中的集合类型，并没有向 JDK 集合抽象中强加一些其它概念。</p>
<h3 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h3><p>Set 是一个无序的、其内元素不能重复的集合。</p>
<p>List 是一个有序的、其内元素可以重复的集合。</p>
<p>Multiset 集合了两者的特点。首先，其内的元素是无序的；其次，其内的元素是可以重复的。</p>
<h4 id="Multiset初体验"><a href="#Multiset初体验" class="headerlink" title="Multiset初体验"></a>Multiset初体验</h4><p>统计一个词在文档中出现了多少次，传统的做法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 统计一个词在文档中出现了多少次。</span></span><br><span class="line"><span class="comment">    *      1、传统做法、</span></span><br><span class="line"><span class="comment">    *      2、使用Multiset实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">statWordCount</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;A big black bug bit a big black bear and made the big black bear bleed blood&quot;</span>;</span><br><span class="line">       <span class="comment">// 将 text 按空格划分为多个单词</span></span><br><span class="line">       Iterable&lt;String&gt; words = Splitter.on(<span class="string">&quot; &quot;</span>).split(text);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 传统做法</span></span><br><span class="line">       Map&lt;String, Integer&gt; wordCountMap = oldStatWordCount(words);</span><br><span class="line">       System.out.println(wordCountMap);</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用Multiset实现</span></span><br><span class="line">       Multiset&lt;String&gt; wordCount = newStatWordCount(words);</span><br><span class="line">       System.out.println(wordCount);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">oldStatWordCount</span><span class="params">(Iterable&lt;String&gt; words)</span>&#123;</span><br><span class="line">       HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(word);</span><br><span class="line">           <span class="keyword">if</span> (count == <span class="literal">null</span>)&#123;</span><br><span class="line">               map.put(word, <span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(word, count+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">       <span class="comment">// &#123;the=1, A=1, big=3, a=1, bug=1, and=1, made=1, black=3, bear=2, bit=1, bleed=1, blood=1&#125;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Multiset&lt;String&gt; <span class="title function_">newStatWordCount</span><span class="params">(Iterable&lt;String&gt; words)</span> &#123;</span><br><span class="line">       HashMultiset&lt;String&gt; multiset = HashMultiset.create();</span><br><span class="line">       <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">           multiset.add(word);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> multiset;</span><br><span class="line">       <span class="comment">// [the, A, big x 3, a, bug, and, made, black x 3, bear x 2, bit, bleed, blood]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这种写法很笨拙，也很容易出错，并且不支持同时收集多种统计信息，如：总词数。</p>
<p>Guava 提供了一个新的集合类型 <strong>Multiset</strong>，它支持多次添加相同的元素。</p>
<p>维基百科从数学的角度这样定义 Multiset：</p>
<blockquote>
<p>  Multiset 是 Set 概念的延伸，其内的元素可以重复出现。与 Set 相同而与 Tuple(元组) 相反的是，Multiset 中元素的顺序是无关紧要的，<code>Multiset&#123;a,a,b&#125;</code> 和 <code>Multiset&#123;a,b,a&#125;</code> 是相等的。</p>
</blockquote>
<h4 id="Multiset的两种视角"><a href="#Multiset的两种视角" class="headerlink" title="Multiset的两种视角"></a>Multiset的两种视角</h4><p>可以从两个角度来理解 Multiset：</p>
<ol>
<li><p>**无序的 <code>ArrayList&lt;E&gt;</code>**。比如：</p>
<ul>
<li>它可以通过 add(E) 方法向集合中添加单个给定元素。</li>
<li>通过 iterator() 方法返回一个迭代器，包含 Multiset 中的全部元素（包含重复元素）。</li>
<li>通过 size() 方法返回所有元素的总个数（包括重复元素）</li>
<li>……</li>
</ul>
</li>
<li><p><strong><code>Map&lt;E, Integer&gt;</code>，键为元素，值为元素的个数。</strong>比如：</p>
<ul>
<li><p>它可以通过 count(Object) 方法返回给定元素的计数。</p>
</li>
<li><p>通过 entrySet() 方法返回 <code>Set&lt;Multiset.Entry&lt;E&gt;&gt;</code>，这和 Map 的 entrySet() 方法类似。</p>
</li>
<li><p>通过 elementSet() 方法返回所有不重复元素的 <code>Set&lt;E&gt;</code>，和 Map 的 keySet() 方法类似。</p>
</li>
<li><p>……</p>
</li>
</ul>
</li>
</ol>
<p>值得注意的是，除了极少数情况，Multiset 和 JDK 中原生的 Collection 接口的约定完全一致。具体来说，TreeMultiset 在判断元素是否相等时，与 TreeSet 一样用 compare() 方法，而不是 Object.equals() 方法。</p>
<p>另外特别注意，<code>Multiset.addAll(Collection)</code> 可以向一个 Multiset 中添加 Collection 中的所有元素并进行计数，这比用 for 循环向 Map 中添加元素和计数方便多了。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>count(E)</td>
<td>统计指定元素在Multiset中的数量</td>
</tr>
<tr>
<td>elementSet()</td>
<td>Multiset中不重复元素的集合，类型为<code>Set&lt;E&gt;</code></td>
</tr>
<tr>
<td>entrySet()</td>
<td></td>
</tr>
<tr>
<td>add(E, int)</td>
<td>增加指定元素在Multiset中的数量</td>
</tr>
<tr>
<td>remove(E, int)</td>
<td>减少指定元素在Multiset中的数量</td>
</tr>
<tr>
<td>setCount(E, int)</td>
<td>设置指定元素在Multiset中的数量，不可以为负数。</td>
</tr>
<tr>
<td>size()</td>
<td>返回集合元素总个数(包括重复的元素)</td>
</tr>
</tbody></table>
<h4 id="Multiset-不是-Map"><a href="#Multiset-不是-Map" class="headerlink" title="Multiset 不是 Map"></a>Multiset 不是 Map</h4><p>值得注意的是，<code>Multiset&lt;E&gt;</code> 不是 <code>Map&lt;E, Integer&gt;</code>。虽然 Map 可能是某些 Multiset 实现的一部分。</p>
<p>准确地来说，Multiset 是一种 Collection 类型，它实现了 Collection 接口的相关约定。</p>
<p>关于 Multiset 和 Map 的区别还包括：</p>
<ul>
<li>  Multiset 中元素的计数只能是正数（不能是负数或者0）。</li>
<li>  multiset.size() 返回集合的大小，等同于所有元素数量的总和。对于不重复元素的个数，应该使用 <code>elementSet.size()</code> 方法。</li>
<li>  multiset.iterator() 方法会迭代重复元素，因此迭代长度等于 multiset.size()。</li>
<li>  Multiset 支持直接增加、减少或设置元素的数量。setCount(elem, 0) 等同于移出所有的 elem。</li>
<li>  对 multiset 中没有的元素，multiset.count(elem) 始终返回0。而 Map 则返回 null。</li>
</ul>
<h4 id="Multiset-的各种实现"><a href="#Multiset-的各种实现" class="headerlink" title="Multiset 的各种实现"></a>Multiset 的各种实现</h4><p>Multiset 是一个接口，Guava 提供了多种 Multiset 的实现，大致对应 JDK 中 Map 的各种实现。</p>
<table>
<thead>
<tr>
<th>Map</th>
<th>对应的Multiset</th>
<th>是否支持Null元素</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>HashMultiset</td>
<td>是</td>
</tr>
<tr>
<td>TreeMap</td>
<td>TreeMultiset</td>
<td>是(如果comparator支持的话)</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>LinkedHashMultiset</td>
<td>是</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>ConcurrentHashMultiset</td>
<td>否</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMultiset</td>
<td>否</td>
</tr>
</tbody></table>
<h4 id="SortedMultiset"><a href="#SortedMultiset" class="headerlink" title="SortedMultiset"></a>SortedMultiset</h4><p>…</p>
<h3 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h3><p>一个有经验的 Java 程序员或多或少都在某个项目中编写过类似 <code>Map&lt;K, List&lt;V&gt;&gt;</code> 或 <code>Map&lt;K, Set&lt;V&gt;&gt;</code> 这种笨拙的结构。</p>
<p>而 Guava 的 Multimap 可以很容易地让一个键映射多个值。</p>
<p>从两个角度理解 Multimap 的设计理念：</p>
<ul>
<li><p>“键-单个值映射”的集合</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;1</span><br><span class="line">a-&gt;2</span><br><span class="line">a-&gt;4</span><br><span class="line">b-&gt;3</span><br><span class="line">c-&gt;5</span><br></pre></td></tr></table></figure></li>
<li><p>或者是 “键-值集合的映射”</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;[1,2,4]</span><br><span class="line">b-&gt;3</span><br><span class="line">c-&gt;5</span><br></pre></td></tr></table></figure></li>
</ul>
<p>一般来说，Multimap 接口应该以第一种方式来看待，但 <code>asMap()</code> 方法返回的视图为 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 格式，让我们可以从另一种角度来看待 Multimap。</p>
<p>重要的是，不会有任何键映射到空集合。一个键要么至少一个值，要么就根本不在 Multimap 中。</p>
<p>Multimap 是一个顶级接口，很少被直接使用，更多的时候我们会使用它的子接口 ListMultimap 或 SetMultimap，它们分别把键映射到 List 和 Set。</p>
<h4 id="修改-Multimap"><a href="#修改-Multimap" class="headerlink" title="修改 Multimap"></a>修改 Multimap</h4><p><code>Multimap.get(key)</code> 会以集合的形式返回键所对应的值的视图。即使没有任何的返回值，也会返回空集合。</p>
<ul>
<li>  ListMultimap.get(key) 返回 List 集合；</li>
<li>  SetMultimap.get(key) 返回 Set 集合。</li>
</ul>
<p>对值视图集合进行的修改最终都会反映到底层的 Multimap。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Person&gt; aliceChildren = childrenMultimap.get(alice);</span><br><span class="line">aliceChildren.clear();</span><br><span class="line">aliceChildren.add(bob);</span><br><span class="line">aliceChildren.add(carol);</span><br></pre></td></tr></table></figure>

<p>其它(更直接地)修改 Multimap 的方法还有：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>等价表达</th>
</tr>
</thead>
<tbody><tr>
<td><code>put(K, V)</code></td>
<td>添加单个值到键映射的集合</td>
<td>multimap.get(key).add(value)</td>
</tr>
<tr>
<td><code>putAll(K, Iterable&lt;V&gt;)</code></td>
<td>添加多个值到键映射的集合</td>
<td></td>
</tr>
<tr>
<td><code>remove(K, V)</code></td>
<td>移除键到值的映射，如果有这样的映射并移除成功，返回true。</td>
<td></td>
</tr>
<tr>
<td><code>removeAll(K)</code></td>
<td>清空键对应的所有值，返回的集合包含了所有之前映射到K的值，但删除之后修改这个集合就不会影响Multimap了。</td>
<td>multimap.get(key).clear()</td>
</tr>
<tr>
<td><code>replaceValues(K, Iterable&lt;V&gt;)</code></td>
<td>清除键对应的所有值，并重新把key关联到Iterable中的每个元素，返回的集合包含所有之前映射到K的值。</td>
<td>multimap.get(key).clear();<br>Iterables.addAll(multimap.get(key), values)</td>
</tr>
</tbody></table>
<p>​    </p>
<h4 id="Multimap的视图"><a href="#Multimap的视图" class="headerlink" title="Multimap的视图"></a>Multimap的视图</h4><p>Multimap 还支持若干强大的视图：</p>
<ul>
<li><p><strong>asMap()</strong> 为 <code>Multimap&lt;K, V&gt;</code> 提供 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 形式的视图。</p>
<ul>
<li>  返回的 Map 支持 remove 操作，并且会反映到底层的 Multimap，但不支持 put 和 putAll 操作。</li>
<li>  如果你想为 Multimap 中不存在的键返回 null，而不是一个空集合，你就可以使用 <code>asMap().get(key)</code>。</li>
<li>Java 类型系统不允许 ListMultimap 直接为 asMap().get(key) 返回 List。所以如果有需求，你需要手动把 asMap.get(key) 返回的结果转换为和是的集合类型。比如：<ul>
<li>  将 SetMultimap.asMap().get(key) 返回的结果转为 Set 类型；</li>
<li>  将 ListMultimap.asMap().get(key) 返回的结果转为 List 类型；</li>
<li>  也可以用 Multimaps 工具类中的静态方法 asMap() 帮你完成类型的转换。</li>
</ul>
</li>
</ul>
</li>
<li><p>**entries()**：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Map.Entry&lt;K, V&gt;&gt; entries();</span><br></pre></td></tr></table></figure>

<p>  用 <code>Collection&lt;Map.Entry&lt;K, V&gt;&gt;</code> 返回 Multimap 中所有 “键-单个值映射” (包括重复键)。</p>
</li>
<li><p>**keySet()**：用 Set 表示 Multimap 中所有不同的键</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>keys()</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Multiset&lt;K&gt; <span class="title function_">keys</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>  用 Multiset 表示 Multimap 中所有的键，每个键重复出现的次数等于它映射的值的个数。</li>
<li>  可以从这个 Multiset 中移除元素，但不能做添加操作。移除操作会反映到底层的 Multimap。</li>
</ul>
</li>
<li><p><strong>values()</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>  用一个“扁平”的 <code>Collection&lt;V&gt;</code> 包含 Multimap 中的所有值。这一点类似于 <code>Iterables.concat(multimap.asMap().values())</code>，但它直接返回了单个的 Collection，而不像 <code>multimap.asMap().values()</code> 那样是分开的 Collection。</li>
</ul>
</li>
</ul>
<h4 id="Multimap不是Map"><a href="#Multimap不是Map" class="headerlink" title="Multimap不是Map"></a>Multimap不是Map</h4><p><code>Multimap&lt;K, V&gt;</code> 不是 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code>，虽然某些 Multimap 的具体实现使用了 map。它们之间的显著区别有：</p>
<ul>
<li><code>Multimap.get(key)</code> 总是返回非 null，但可能是空的集合。<ul>
<li>  这并不意味着 Multimap 为相应的键花费内存创建了集合，而是……</li>
<li>  如果你更喜欢像 Map 那样，为 Multimap 中没有的键返回 null，请使用 asMap() 方法获取一个 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code>。或者使用静态方法 <code>Multimaps.asMap()</code> 为 ListMultimap 返回一个 <code>Map&lt;K, List&lt;V&gt;&gt;</code>。对于 SetMultimap 和 SortedSetMultimap，也有类似的静态方法存在。</li>
</ul>
</li>
<li>当且仅当有 value 映射到 key 时，Multimap.containsKey(key) 才会返回 true。<ul>
<li>  需要注意的是：如果 key 之间映射过一个或多个值，但它们都被移出后，Multimap.containsKey(key) 返回 false。</li>
</ul>
</li>
<li>Multimap.entries() 返回 Multimap 中所有的 “键-单个值映射”，包括重复键。<ul>
<li>  如果你想要得到所有的 “键-值集合映射”，请使用 asMap.entrySet()。</li>
</ul>
</li>
<li>Multimap.size() 返回所有 “键-单个值映射” 的个数，而非不同键的个数。<ul>
<li>  要想获得不同键的个数，请使用 Multimap.keySet().size()。</li>
</ul>
</li>
</ul>
<h4 id="Multimap的各种实现"><a href="#Multimap的各种实现" class="headerlink" title="Multimap的各种实现"></a>Multimap的各种实现</h4><p>Multimap 提供了多种形式的实现，在大多数要使用 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 的地方，你都可以使用它们。</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>键类型</th>
<th>值类型</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayListMultimap</td>
<td></td>
<td>ArrayList</td>
</tr>
<tr>
<td>LinkedListMultimap</td>
<td></td>
<td>LinkedList</td>
</tr>
<tr>
<td>HashMultimap</td>
<td></td>
<td>HashSet</td>
</tr>
<tr>
<td>LinkedHashMultimap</td>
<td></td>
<td>LinkedHashMap</td>
</tr>
<tr>
<td>TreeMultimap</td>
<td></td>
<td>TreeSet</td>
</tr>
<tr>
<td>ImmutableListMultimap</td>
<td></td>
<td>ImmutableList</td>
</tr>
<tr>
<td>ImmutableSetMultimap</td>
<td></td>
<td>ImmutableSet</td>
</tr>
</tbody></table>
<p>除了两个不可变形式的实现，其它所有实现都支持 null 键和 null 值。</p>
<h3 id="BiMap"><a href="#BiMap" class="headerlink" title="BiMap"></a>BiMap</h3><p>在 JDK 中，实现键值对的双向映射(即既可以通过key找到value，也可以通过value找到key)需要维护两个单独的 map，并保持它们之间的同步。</p>
<p>但这种方式很容易出错，特别是对于值已经在 map 中的情况，会变得非常混乱。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; kToV = Maps.newHashMap();</span><br><span class="line">    HashMap&lt;Integer, String&gt; vToK = Maps.newHashMap();</span><br><span class="line">    kToV.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">42</span>);</span><br><span class="line">    vToK.put(<span class="number">42</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果 &quot;Bob&quot; 和 42 已经在 map 中了，会发生什么？</span></span><br><span class="line">    <span class="comment">// 如果我们忘了同步两个map，则会有新的bug产生。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BiMap&lt;K,V&gt;</code> 是特殊的 Map：</p>
<ul>
<li>  可以用 <code>inverse()</code> 反转 <code>BiMap&lt;K, V&gt;</code> 的键值映射；</li>
<li>  可以保证值是唯一的，因此 <code>values()</code> 返回 Set 而不是普通的 Collection。</li>
</ul>
<p>在 BiMap 中，如果你想把键映射到已经存在的值，会抛出 IllegalArgumentException 异常。如果对特定值，你想要强制替换它的键，可以使用 <code>BiMap.forcePut(key, value)</code>。</p>
<h4 id="BiMap的各种实现类"><a href="#BiMap的各种实现类" class="headerlink" title="BiMap的各种实现类"></a>BiMap的各种实现类</h4><table>
<thead>
<tr>
<th>键-值 实现</th>
<th>值-键 实现</th>
<th>对应的BiMap实现</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>HashMap</td>
<td>HashBiMap</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMap</td>
<td>ImmutableBiMap</td>
</tr>
<tr>
<td>EnumMap</td>
<td>EnumMap</td>
<td>EnumBiMap</td>
</tr>
<tr>
<td>EnumMap</td>
<td>HashMap</td>
<td>EnumHashBiMap</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注</strong>：Map 类中还有一些诸如 synchronizedBiMap 的 BiMap 工具方法。</p>
</blockquote>
<h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><p>通常来说，当你想用多个键做索引时，你可能会使用类似 <code>Map&lt;FirstName, Map&lt;LastName， Person&gt;&gt;</code> 的结构来实现。这种方式很丑陋，使用上也不太友好。</p>
<p>为此，Guava 提供了新的集合类型 Table，它有两个键：“行”和“列”，通过这两个键唯一映射到一个值。</p>
<p>Table 提供了多种视图，以便你从各种角度去理解它。</p>
<ul>
<li>**rowMap()**：用 <code>Map&lt;R, Map&lt;C, V&gt;&gt;</code> 表现 <code>Table&lt;R, C, V&gt;</code>。<ul>
<li>同样的，<strong>rowKeySet()</strong> 返回“行”的集合 <code>Set&lt;R&gt;</code>。</li>
</ul>
</li>
<li>**row(r)**：返回给定“行”的所有列，返回值格式为 <code>Map&lt;C, V&gt;</code>。<ul>
<li>注意：对这个 map 进行的写操作也将反映到 Table 中。</li>
</ul>
</li>
<li>类似的“列”的访问方法：<strong>columnMap()<strong>、</strong>columnKeySet()<strong>、</strong>column(c)</strong><ul>
<li>基于“列”的访问会比基于“行”的访问效率略低。</li>
</ul>
</li>
<li>**cellSet()**：用元素类型为 <code>Table.Cell&lt;R, C, V&gt;</code> 的 Set 表现 <code>Table&lt;R, C, V&gt;</code>。Cell 类似于 Map.Entry，但它是用行和列两个键进行划分的。</li>
</ul>
<h4 id="Table的实现类"><a href="#Table的实现类" class="headerlink" title="Table的实现类"></a>Table的实现类</h4><ul>
<li><strong>HashBasedTable</strong>：底层使用 <code>HashMap&lt;R, HashMap&lt;C, V&gt;&gt;</code> 实现。</li>
<li><strong>TreeBasedTable</strong>：底层使用 <code>TreeMap&lt;R, TreeMap&lt;C, V&gt;&gt;</code> 实现。</li>
<li><strong>ImmutableTable</strong>：底层使用 <code>ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt;</code> 实现。<ul>
<li>注：ImmutableTable 对稀疏或密集的数据集都有优化。</li>
</ul>
</li>
<li><strong>ArrayTable</strong>：要求在构造时就指定行和列的大小，本质上由一个二维数组实现，以提升访问速度和密集 Table 的内存利用率。</li>
</ul>
<h3 id="ClassToInstanceMap"><a href="#ClassToInstanceMap" class="headerlink" title="ClassToInstanceMap"></a>ClassToInstanceMap</h3><p>ClassToInstanceMap 是一种特殊的 Map：它的键是类型，而值是符合所指类型的对象实例。</p>
<p>为了扩展 Map 接口，ClassToInstance 额外声明了两个方法：</p>
<ul>
<li><code>getInstance(Class&lt;T&gt;)</code></li>
<li><code>T putInstance(Class&lt;T&gt;, T)</code></li>
</ul>
<p>从而避免强制类型转换，同时保证了类型安全。</p>
<p>ClassToInstanceMap 有唯一的泛型参数，通常称为 B，代表 Map 支持的所有类型的上界。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassToInstanceMap&lt;Number&gt; numberDefaults = MutableClassToInstanceMap.create();</span><br><span class="line">numberDefaults.putInstance(Integer.class, Integer.valueOf(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>从技术上讲，<code>ClassToInstanceMap&lt;B&gt;</code> 实现了 <code>Map&lt;Class&lt;? extends B&gt;, B&gt;</code>。或者换句话说就是：一个映射 B 的子类类型到对应实例的 Map。B 始终是 Map 所支持类型的上限，默认 B 就是 Object。</p>
<h4 id="ClassToInstanceMap的实现类"><a href="#ClassToInstanceMap的实现类" class="headerlink" title="ClassToInstanceMap的实现类"></a>ClassToInstanceMap的实现类</h4><ul>
<li>MutableClassToInstanceMap</li>
<li>ImmutableClassToInstanceMap</li>
</ul>
<h3 id="RangeSet"><a href="#RangeSet" class="headerlink" title="RangeSet"></a>RangeSet</h3><p>RangeSet 描述了一组不相连的、非空的区间。</p>
<p>当把一个区间添加到可变的 RangeSet 时，所有相连的区间会被合并，空区间会被忽略。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create();</span><br><span class="line">rangeSet.add(Range.closed(<span class="number">1</span>, <span class="number">10</span>)); <span class="comment">// [1.10]，前闭后闭</span></span><br><span class="line">rangeSet.add(Range.closedOpen(<span class="number">11</span>, <span class="number">15</span>)); <span class="comment">// [11,15)，前开后闭</span></span><br><span class="line"><span class="comment">// 不相连区间 ==&gt; &#123; [1.10], [11,15) &#125;</span></span><br><span class="line">rangeSet.add(Range.closedOpen(<span class="number">15</span>, <span class="number">20</span>)); <span class="comment">// [15,20)</span></span><br><span class="line"><span class="comment">// 相连区间 ==&gt; &#123; [1.10], [11,20) &#125;</span></span><br><span class="line">rangeSet.add(Range.openClosed(<span class="number">0</span> ,<span class="number">0</span>)); <span class="comment">// 空区间</span></span><br><span class="line"><span class="comment">// &#123; [1.10], [11,20) &#125;</span></span><br><span class="line"><span class="comment">// 删除区间</span></span><br><span class="line">rangeSet.remove(Range.open(<span class="number">5</span>, <span class="number">10</span>)); <span class="comment">// (5, 10)</span></span><br><span class="line"><span class="comment">// &#123; [1, 5], [10, 10], [11,20) &#125;</span></span><br><span class="line">System.out.println(rangeSet); <span class="comment">// [[1..5], [10..10], [11..20)]</span></span><br></pre></td></tr></table></figure>

<p>请注意：要合并 <code>Range.closed(1, 10)</code> 和 <code>Range.closedOpen(11, 15)</code> 这样的区间，你需要首先用 <strong>Range.canonical(DiscreteDomain)</strong> 对区间进行预处理。例如：<code>DiscreteDomain.integers()</code>。</p>
<blockquote>
<p>  <strong>注意</strong></p>
<p>  RangeSet 不支持 GWT，也不支持 JDK5 和更早版本。因为，RangeSet 需要充分利用 JDK6 中的 NavigableMap 的特性。</p>
</blockquote>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </p>
<h3 id="RangeMap"><a href="#RangeMap" class="headerlink" title="RangeMap"></a>RangeMap</h3><h2 id="强大的集合工具类"><a href="#强大的集合工具类" class="headerlink" title="强大的集合工具类"></a>强大的集合工具类</h2><p>JDK 在 <code>java.util.Collections</code> 包中提供了很多对 Collection 进行操作的静态方法。Guava 沿着这些路线提供了更多的工具方法，这也是 Guava 最流行和最成熟的部分之一。</p>
<p>常见的工具类与集合接口的对应关系归纳如下：</p>
<table>
<thead>
<tr>
<th>集合接口</th>
<th>属于JDK还是Guava</th>
<th>对应的Guava工具类</th>
</tr>
</thead>
<tbody><tr>
<td>Collection</td>
<td>JDK</td>
<td>Collections2(不要和<code>java.util.Collections</code>混淆)</td>
</tr>
<tr>
<td>List</td>
<td>JDK</td>
<td>Lists</td>
</tr>
<tr>
<td>Set</td>
<td>JDK</td>
<td>Sets</td>
</tr>
<tr>
<td>SortedSet</td>
<td>JDK</td>
<td>Sets</td>
</tr>
<tr>
<td>Map</td>
<td>JDK</td>
<td>Maps</td>
</tr>
<tr>
<td>SortedMap</td>
<td>JDK</td>
<td>Maps</td>
</tr>
<tr>
<td>Queue</td>
<td>JDK</td>
<td>Queues</td>
</tr>
<tr>
<td>Multiset</td>
<td>Guava</td>
<td>Multisets</td>
</tr>
<tr>
<td>Multimap</td>
<td>Guava</td>
<td>Multimaps</td>
</tr>
<tr>
<td>BiMap</td>
<td>Guava</td>
<td>Maps</td>
</tr>
<tr>
<td>Table</td>
<td>Guava</td>
<td>Tables</td>
</tr>
</tbody></table>
<h3 id="使用Lists工具类操作List集合"><a href="#使用Lists工具类操作List集合" class="headerlink" title="使用Lists工具类操作List集合"></a>使用Lists工具类操作List集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lists 工具类的常用方法</span></span><br><span class="line"><span class="comment"> *      1、对集合进行 反转 / 拆分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLists</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拆分：将list集合拆分为每3个为一组</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; listList = Lists.partition(list, <span class="number">3</span>);</span><br><span class="line">    System.out.println(JSON.toJSONString(listList));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">            [1,2,3],</span></span><br><span class="line"><span class="comment">            [4,5,6],</span></span><br><span class="line"><span class="comment">            [7]</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转</span></span><br><span class="line">    List&lt;Integer&gt; reverseList = Lists.reverse(list);</span><br><span class="line">    System.out.println(reverseList); <span class="comment">// [7, 6, 5, 4, 3, 2, 1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用Sets工具类操作Set集合"><a href="#使用Sets工具类操作Set集合" class="headerlink" title="使用Sets工具类操作Set集合"></a>使用Sets工具类操作Set集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets 工具类的常用方法</span></span><br><span class="line"><span class="comment"> *      1、取两个集合的 并集 / 交集 / 差集（标准差集 &amp; 对称差集）</span></span><br><span class="line"><span class="comment"> *      2、将一个集合拆解为其所有可能的子集</span></span><br><span class="line"><span class="comment"> *      3、求两个集合的笛卡尔积</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSets</span><span class="params">()</span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = Sets.newHashSet(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = Sets.newHashSet(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并集</span></span><br><span class="line">    Sets.SetView&lt;Integer&gt; union = Sets.union(set1, set2);</span><br><span class="line">    System.out.println(union); <span class="comment">// [1, 2, 3, 4, 5, 8, 6, 7]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    Sets.SetView&lt;Integer&gt; intersection = Sets.intersection(set1, set2);</span><br><span class="line">    System.out.println(intersection); <span class="comment">// [4, 5]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准差集</span></span><br><span class="line">    Sets.SetView&lt;Integer&gt; difference1 = Sets.difference(set1, set2);</span><br><span class="line">    Sets.SetView&lt;Integer&gt; difference2 = Sets.difference(set2, set1);</span><br><span class="line">    System.out.println(difference1); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    System.out.println(difference2); <span class="comment">// [8, 6, 7]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称差集</span></span><br><span class="line">    Sets.SetView&lt;Integer&gt; difference = Sets.symmetricDifference(set1, set2);</span><br><span class="line">    System.out.println(difference); <span class="comment">// [1, 2, 3, 8, 6, 7]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个集合拆解为其所有可能的子集</span></span><br><span class="line">    HashSet&lt;String&gt; set = Sets.newHashSet(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    Set&lt;Set&lt;String&gt;&gt; setSet = Sets.powerSet(set);</span><br><span class="line">    System.out.println(JSON.toJSONString(setSet));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">            [],</span></span><br><span class="line"><span class="comment">            [&quot;a&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;b&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;a&quot;,&quot;b&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;c&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;a&quot;,&quot;c&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;b&quot;,&quot;c&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个集合的笛卡尔积</span></span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; listSet = Sets.cartesianProduct(</span><br><span class="line">            Sets.newHashSet(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            Sets.newHashSet(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    );</span><br><span class="line">    System.out.println(JSON.toJSONString(listSet));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">            [1,4],</span></span><br><span class="line"><span class="comment">            [1,3],</span></span><br><span class="line"><span class="comment">            [2,4],</span></span><br><span class="line"><span class="comment">            [2,3]</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><p>在 JDK7 之前，构造新的集合时要反复地声明泛型类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line"><span class="comment">// JDK7之前，在等号左边和右边都需要显式地声明泛型类型，否则编译时就会报错</span></span><br></pre></td></tr></table></figure>

<p>尽管从 JDK7 开始，钻石操作符 <code>&lt;&gt;</code> 已经做出了一些优化，我们可以只在 “=” 左边声明泛型的类型，右边的泛型类型通过自动推断得出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>但是如果你正在操作一个使用 JDK6 甚至更早的项目，显然反复地声明泛型类型是非常麻烦的。为此，Guava 提供了能够推断泛型的静态工厂方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;User&gt; list = Lists.newArrayList();</span><br><span class="line">LinkedHashMap&lt;String, User&gt; map = Maps.newLinkedHashMap();</span><br></pre></td></tr></table></figure>

<p>但是 Guava 的静态工厂方法远不止这么简答。使用工厂方法，我们可以方便地在初始化集合时指定初始元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; copySet = Sets.newHashSet(elements);</span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此外，通过工厂方法的名称，可以提高集合初始化大小时的可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Type&gt; exactly100 = Lists.newArrayListWithCapacity(<span class="number">100</span>);</span><br><span class="line">ArrayList&lt;Type&gt; approx100 = Lists.newArrayListWithExpectedSize(<span class="number">100</span>);</span><br><span class="line">HashSet&lt;Type&gt; approx100Set = Sets.newHashSetWithExpectedSize(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：对于 Guava 中引入的新集合类型，在创建其实例时并没有暴露原始的构造器，也没有在 <code>Collections2</code> 工具类中提供初始化方法，而是直接在集合类中提供了静态工厂方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMultiset&lt;String&gt; multiset = HashMultiset.create();</span><br></pre></td></tr></table></figure>





<h3 id="Iterables"><a href="#Iterables" class="headerlink" title="Iterables"></a>Iterables</h3><p>在条件允许的情况下，Guava 提供的工具方法更偏向于接受 Iterable 类型而不是 Collection 类型。</p>
<p>在 Google 公司，对于不存放在主存中的数据集，比如从数据库或其他数据中心收集到的结果集，因为其实际上还没有攫取全部数据，这类结果集都不能支持类似 size() 的操作，所以通常都不会用 Collection 类型来表示。</p>
<p>因此，很多你期望的支持所有集合的操作都保存在 Iterables 类中。</p>
<p>截至 Guava1.2 版本，Iterables 使用 FluentIterable 类进行了补充，它包装了一个 Iterable 实例，并对许多操作提供了 “fluent”(链式调用)语法。</p>
<p>下面列出了一些最常用的工具方法，但更多 Iterables 的函数式方法将在对应的“函数式编程”章节讨论。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>frequency(Iterable, Object)</td>
<td>返回Object对象在Iterable中出现的次数</td>
<td></td>
</tr>
<tr>
<td>partition(Iterable, int)</td>
<td>把iterable按指定大小分割，得到的子集都不能进行修改操作</td>
<td></td>
</tr>
<tr>
<td>getFirst(Iterable, T default)</td>
<td>返回iterable中的第一个元素，若iterable为空则返回默认值。</td>
<td></td>
</tr>
<tr>
<td>getLast(Iterable)</td>
<td>返回iterable中的最后一个元素，若iterable为空则抛出NoSuchElementException。</td>
<td></td>
</tr>
<tr>
<td>elementsEqual(Iterable, Iterable)</td>
<td>如果两个iterable中的所有元素相等且顺序一致，返回true</td>
<td></td>
</tr>
<tr>
<td>unmodifableIterable(Iterable)</td>
<td>返回iterable的不可变视图。</td>
<td></td>
</tr>
<tr>
<td>limit(Iterable, int)</td>
<td>限制iterable的元素个数，限制给定值</td>
<td></td>
</tr>
<tr>
<td>getOnlyElement(Iterable)</td>
<td>获取iterable中唯一的元素。如果iterable为空或有多个元素，则快速失败。</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h1 id="字符串工具"><a href="#字符串工具" class="headerlink" title="字符串工具"></a>字符串工具</h1><h2 id="连接器-Joiner"><a href="#连接器-Joiner" class="headerlink" title="连接器[Joiner]"></a>连接器[Joiner]</h2><p>Joiner 是一个字符串处理工具，它的作用就是：用一个分隔符把多个字符串连接起来，并且如果字符串序列中含有 <code>null</code> 也能够很好的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个连接器，这个连接器使用&quot;$&quot;作为连接符，并且会自动跳过null值 </span></span><br><span class="line"><span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;$&quot;</span>).skipNulls();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> joiner.join(<span class="string">&quot;Harry&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Ron&quot;</span>, <span class="string">&quot;Hermione&quot;</span>);</span><br><span class="line">System.out.println(s); <span class="comment">//Harry$Ron$Hermione</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>useForNull(String)</code> 方法可以用某个给定的字符串来替换 null，而不像 <code>skipNulls()</code> 方法那样直接忽略 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;$&quot;</span>).useForNull(<span class="string">&quot;Empty&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> joiner.join(<span class="string">&quot;Harry&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Ron&quot;</span>, <span class="string">&quot;Hermione&quot;</span>);</span><br><span class="line">System.out.println(s); Harry$Empty$Ron$Hermione</span><br></pre></td></tr></table></figure>

<p>joiner 也可以用来连接 Object 类型，这种情况下，它会将 Object 的 toString() 值连接起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">13</span>),</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">24</span>)</span><br><span class="line">);</span><br><span class="line"><span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;^_^&quot;</span>).skipNulls();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> joiner.join(userList);</span><br><span class="line">System.out.println(s); <span class="comment">//User(name=张三, age=13)^_^User(name=李四, age=24)^_^User(name=王五, age=35)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>Tip</strong></p>
<p>  joiner 实例一旦创建是不可变的。每次执行定义 Joiner 的语句得到的都是一个新的 joiner 实例，这使得 joiner 实例都是安全的，所以你可以将其定义为 static final 常量。</p>
</blockquote>
<h3 id="静态方法-连接器工厂"><a href="#静态方法-连接器工厂" class="headerlink" title="静态方法(连接器工厂)"></a>静态方法(连接器工厂)</h3><p>Joiner 类只有两个静态方法，分别是：</p>
<ul>
<li><code>Joiner on(String separator)</code></li>
<li><code>Joiner on(char separator)</code></li>
</ul>
<p>这两个方法都是用于创建一个连接器实例 joiner，并在创建时指定要以哪种分隔符对字符串进行拼接。只不过一个使用 String 类型的分隔符，另一个使用 char 类型的分隔符。</p>
<p>我们可以将 Splitter 类理解为一个连接器工厂，它的作用就是创建 splitter 连接器实例。</p>
<h3 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h3><p><img src="/2022/06/14/Guava/image-20220620220652695.png" alt="image-20220620220652695"></p>
<p>与 JDK8 中的流式操作类似，joiner 中的方法也可以分为 **中间操作方法 **和 <strong>终止操作方法</strong> 两大类。</p>
<ul>
<li>中间操作方法主要用于设置 joiner 连接器的属性，主要包括 skipNulls、useForNull、withKeyValueSeparator 等等。中间操作仅仅只是用于设置对字符串的处理规则，并没有真正的执行处理字符串的过程。</li>
<li>而终止操作则是把待处理的数据交给 joiner 实例，让其真正地去处理数据。常见的终止操作方法有 join 和 appendTo 两个。<ul>
<li><code>String join(...)</code>：join 方法的返回值是一个字符串，表示它会将 joiner 处理后的数据写到 String 类型的字符串中。</li>
<li><code>&lt;A extends Appendable&gt; A appendTo()</code>：appendTo 方法的返回值是 Appendable 类型的对象，它比较灵活多变，常见的我们可以把处理后的数据写到 StringBuffer 或 StringBuilder 中，或者是写到 Writer 中(这些都是 Appendable  接口的子类对象)，进而写出到磁盘上。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>join()</strong></p>
</blockquote>
<p>join 方法有三种变式：</p>
<ul>
<li><code>String join(Iterable&lt;?&gt; parts)</code></li>
<li><code>String join(Iterator&lt;?&gt; parts)</code></li>
<li><code>String join(Object first, Object second, Object... rest)</code></li>
</ul>
<p>前两种方法接收一个集合类型，返回值是 String，就是把集合类型中的所有元素拼接成一个字符串。如果集合的泛型是 Object 类型，返回的结果就是集合中每个元素的 toString() 方法返回值拼接的结果。</p>
<blockquote>
<p><strong>appendTo()</strong></p>
</blockquote>
<p>appendTo() 方法的作用将 joiner 处理后的数据写到一个 Appendable 类型的对象中。</p>
<p>该方法的第一个参数要求是 Appendable 类型的对象(StringBuffer 和 StringBuilder 都是 Appendable 接口的子类)；其余参数可以是 Object 类型，此时会将其 toString() 方法的返回值当做要追加的数据；也可以是 Iterable 或 Iterator 类型；或者是多个 Object 对象。</p>
<p>该方法设计的逻辑就是：对于 joiner 处理过的字符串，我们可能会在某个地方用到它，所以我们需要先找个地方把这个处理结果暂存起来。这个地方可以是 StringBuffer、也可以是本地磁盘。     </p>
<p><img src="/2022/06/14/Guava/image-20220620223152644.png" alt="image-20220620223152644"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/20 22:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; stringList = Lists.newArrayList(</span><br><span class="line">            <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Golang&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; stringListWithNullValue = Lists.newArrayList(</span><br><span class="line">            <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Golang&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res1</span> <span class="operator">=</span> joiner.join(stringList);</span><br><span class="line">        System.out.println(res1); <span class="comment">// Java#Python#C#Golang</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果集合中含有null值，直接使用join()拼接集合中的元素，会抛出 NullPointerException</span></span><br><span class="line">        <span class="comment">//String res2 = joiner.join(stringListWithNullValue); // NullPointerException</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了解决这个问题，可以为连接器实例 joiner 设置自动跳过 null 值的功能</span></span><br><span class="line">        <span class="type">Joiner</span> <span class="variable">joiner2</span> <span class="operator">=</span> joiner.skipNulls();</span><br><span class="line">        <span class="type">String</span> <span class="variable">res2</span> <span class="operator">=</span> joiner2.join(stringListWithNullValue);</span><br><span class="line">        System.out.println(res2); <span class="comment">// Java#Python#Golang</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于null值，如果我们不想直接跳过，而是使用一个Default值替换Null，可以使用useForNull()方法</span></span><br><span class="line">        <span class="type">Joiner</span> <span class="variable">joiner3</span> <span class="operator">=</span> joiner.useForNull(<span class="string">&quot;Empty&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res3</span> <span class="operator">=</span> joiner3.join(stringListWithNullValue);</span><br><span class="line">        System.out.println(res3); <span class="comment">// Java#Python#Empty#Golang</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAppendToStringBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> joiner.skipNulls().appendTo(stringBuffer, stringListWithNullValue);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 它的一个执行流程是，先用joiner对象处理集合中的数据。</span></span><br><span class="line"><span class="comment">         * 最后把处理后的结果数据写到目的地(这里是写到sb中)</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        System.out.println(res.toString()); <span class="comment">// Java$Python$Golang</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并且 res 和 stringBuffer 是同一个 StringBuffer 实例</span></span><br><span class="line">        System.out.println(stringBuffer == res); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAppendToWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// Writer 也实现了 Appendable 接口</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 将 joiner 处理后得到的字符串写出到 Writer 中，最终写入磁盘上</span></span><br><span class="line">        Joiner.on(<span class="string">&quot;$&quot;</span>).skipNulls().appendTo(fileWriter, stringListWithNullValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="内部类MapJoiner"><a href="#内部类MapJoiner" class="headerlink" title="内部类MapJoiner"></a>内部类MapJoiner</h3><p>MapJoiner 是 Joiner 的内部类，它主要用来处理 Map 集合中的字符串数据，它可以先将 Map 中每个 Entry 的 key 和 value 用一个连接符连接起来，再用另一个连接符连接每一个 Entry。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/20 22:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = ImmutableMap.of(</span><br><span class="line">            <span class="string">&quot;23&quot;</span>, <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">            <span class="string">&quot;24&quot;</span>, <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">            <span class="string">&quot;25&quot;</span>, <span class="string">&quot;王五&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMapJoiner</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Joiner.<span class="type">MapJoiner</span> <span class="variable">mapJoiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot; $ &quot;</span>)</span><br><span class="line">                .withKeyValueSeparator(<span class="string">&#x27;=&#x27;</span>)  <span class="comment">// key和value的分隔符</span></span><br><span class="line">                .useForNull(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// join 和 appendTo 是终止操作方法。join是把结果写到字符串中；appendTo则比较灵活多变</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> mapJoiner.join(map);</span><br><span class="line">        System.out.println(res); <span class="comment">// 23=张三 $ 24=李四 $ 25=王五</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> mapJoiner.appendTo(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(), map);</span><br><span class="line">        System.out.println(buffer.toString()); <span class="comment">// 23=张三 $ 24=李四 $ 25=王五</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="拆分器-Splitter"><a href="#拆分器-Splitter" class="headerlink" title="拆分器[Splitter]"></a>拆分器[Splitter]</h2><p>与 Joiner 相反，Splitter 的作用是把一个字符串根据给定的分隔符进行分割。</p>
<p>JDK 内置的字符串拆分工具有一些奇怪的特性。比如，<code>String.split()</code> 方法会悄悄丢掉尾部的分隔符。</p>
<blockquote>
<p>  问题：</p>
<ul>
<li><code>&quot;,a,b,&quot;.split(&quot;,&quot;)</code> 会返回什么？<ol>
<li> <code>&quot;&quot;,&quot;a&quot;,&quot;b&quot;,&quot;&quot;</code></li>
<li> <code>null,&quot;a&quot;,&quot;b&quot;,null</code></li>
<li> <code>&quot;a&quot;,null,&quot;b&quot;</code></li>
<li> <code>&quot;a&quot;,&quot;b&quot;</code></li>
<li> 以上都不对</li>
</ol>
</li>
</ul>
</blockquote>
<p>正确答案是5。真正的结果是：<code>&quot;&quot;,&quot;a&quot;,&quot;b&quot;</code>，只有尾部的空字符串被忽略了，首部的空字符串没有被忽略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = <span class="string">&quot;,a,b,&quot;</span>.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">System.out.println(strings.length); <span class="comment">// 3</span></span><br><span class="line">System.out.println(Arrays.toString(strings)); <span class="comment">// [, a, b]</span></span><br></pre></td></tr></table></figure>

<p>而 Guava 中的 <strong>Splitter</strong> 使用了令人放心的、直白流畅的 API 对这些混乱的特性做了优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterable&lt;String&gt; strings = Splitter.on(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    .trimResults()</span><br><span class="line">    .omitEmptyStrings() <span class="comment">//省略空字符串</span></span><br><span class="line">    .split(<span class="string">&quot;foo,bar,,    qux&quot;</span>);</span><br><span class="line">System.out.println(Iterables.toString(strings)); <span class="comment">// [foo, bar, qux]</span></span><br></pre></td></tr></table></figure>

<p>上述代码返回 <code>Iterable&lt;String&gt;</code> 类型的对象，其中包含 “foo”、“bar”和“qux”。</p>
<p>Splitter 可以被设置为按照任何模式、字符、字符串或者字符匹配器拆分。</p>
<h3 id="静态方法-拆分器工厂"><a href="#静态方法-拆分器工厂" class="headerlink" title="静态方法(拆分器工厂)"></a>静态方法(拆分器工厂)</h3><p>与 Joiner 类似，Splitter 中的静态方法也被用于创建 splitter 实例，并在创建时指定字符串拆分的规则。</p>
<p>我们可以将 Splitter 类理解为一个拆分器工厂，它的作用就是创建 splitter 拆分器。</p>
<p><img src="/2022/06/14/Guava/image-20220621123921407.png" alt="image-20220621123921407"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Splitter.on(char)</td>
<td>按单个字符拆分</td>
<td>Splitter.on(‘;’)</td>
</tr>
<tr>
<td>Splitter.on(CharMatcher)</td>
<td>按字符匹配器拆分</td>
<td>Splitter.on(CharMatcher.BREAKING_WHITESPACE)</td>
</tr>
<tr>
<td>Splitter.on(String)</td>
<td>按字符串拆分</td>
<td>Splitter.on(“,”)</td>
</tr>
<tr>
<td>Splitter.on(Pattern)<br>Splitter.onPattern(String)</td>
<td>按正则表达式拆分</td>
<td>Splitter.onPattern(“\r?\n”)</td>
</tr>
<tr>
<td>Splitter.fixedLength(int)</td>
<td>按固定长度拆分(最后一段可能比给定长度短)</td>
<td>Splitter.fixedLength(3)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_Splitter_onPattern</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;好$好$学$习$天$天$向$上&quot;</span>;</span><br><span class="line">    <span class="comment">// 正则表达式：通过&quot;$&quot;进行分割</span></span><br><span class="line">    List&lt;String&gt; dstList1 = Splitter.onPattern(<span class="string">&quot;\\$&quot;</span>).splitToList(srcStr);</span><br><span class="line">    List&lt;String&gt; dstList2 = Splitter.on(Pattern.compile(<span class="string">&quot;\\$&quot;</span>)).splitToList(srcStr);</span><br><span class="line">    System.out.println(dstList1.toString()); <span class="comment">// [好, 好, 学, 习, 天, 天, 向, 上]</span></span><br><span class="line">    System.out.println(dstList2.toString()); <span class="comment">// [好, 好, 学, 习, 天, 天, 向, 上]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以客户端发送报文给服务器为例。规定每4个长度为一组。</span></span><br><span class="line"><span class="comment"> * 现客户端发送了一串报文为：010010XR8764YTE3</span></span><br><span class="line"><span class="comment"> * 服务器端接收到报文后需要解析这串报文。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_Splitter_fixedLength</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;010010XR8764YTE3&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建一个以字符长度为拆分依据的 splitter 实例</span></span><br><span class="line">    <span class="type">Splitter</span> <span class="variable">splitter</span> <span class="operator">=</span> Splitter.fixedLength(<span class="number">4</span>);</span><br><span class="line">    List&lt;String&gt; dstList = splitter.splitToList(srcStr);</span><br><span class="line">    System.out.println(dstList.toString()); <span class="comment">// [0100, 10XR, 8764, YTE3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="普通方法-1"><a href="#普通方法-1" class="headerlink" title="普通方法"></a>普通方法</h3><p>与 joiner 类似，splitter 实例可以调用的方法也可分为两类：<strong>拆分器修饰方法</strong> 和 <strong>拆分器执行方法</strong>。</p>
<ul>
<li>拆分器修饰方法主要用来定义 splitter 实例的执行规则，常见的有：trimResults、omitEmptyStrings、limit、withKeyValueSeparator 等等，这些方法仅仅是对 splitter 的修饰，并没有真正执行数据的处理流程。</li>
<li>拆分器执行方法则是通过连接到真正的数据源，使用 joiner 对数据源数据进行处理。常见的有 split() 和 splitToList()。</li>
</ul>
<p><img src="/2022/06/14/Guava/image-20220621125041695.png" alt="image-20220621125041695"></p>
<h4 id="拆分器修饰方法"><a href="#拆分器修饰方法" class="headerlink" title="拆分器修饰方法"></a>拆分器修饰方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>omitEmptyStrings()</td>
<td>省略结果字符串中的空白元素</td>
<td>a,,c<code>-&gt;</code>a,c</td>
</tr>
<tr>
<td>trimResults()</td>
<td>移除结果字符串中的头部空白和尾部空白</td>
<td></td>
</tr>
<tr>
<td>trimResults(charMatcher)</td>
<td>给定匹配器，移除结果字符串的头部匹配字符和尾部匹配字符</td>
<td></td>
</tr>
<tr>
<td>limit(int)</td>
<td>限制拆分出的元素数量</td>
<td></td>
</tr>
</tbody></table>
<h4 id="拆分器执行方法"><a href="#拆分器执行方法" class="headerlink" title="拆分器执行方法"></a>拆分器执行方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>split(CharSequence sequence)</td>
<td>使用splitter实例对sequence数据进行拆分</td>
</tr>
<tr>
<td>splitToList(CharSequence sequence)</td>
<td>使用splitter实例对sequence数据进行拆分，并将拆分结果写到List中</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;阿福,成龙   ,,,小玉,    老爹&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建 splitter 实例</span></span><br><span class="line">    <span class="type">Splitter</span> <span class="variable">splitter</span> <span class="operator">=</span> Splitter.on(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、修饰 splitter 实例</span></span><br><span class="line">    <span class="comment">// 2.1 omitEmptyStrings</span></span><br><span class="line">    <span class="type">Splitter</span> <span class="variable">splitter1</span> <span class="operator">=</span> splitter.omitEmptyStrings(); <span class="comment">// 忽略空字符</span></span><br><span class="line">    <span class="comment">/*  &quot;阿福,成龙   ,,,小玉,    老爹&quot; --&gt; [阿福, 成龙   , 小玉,     老爹]  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 trimResults</span></span><br><span class="line">    <span class="type">Splitter</span> <span class="variable">splitter2</span> <span class="operator">=</span> splitter.trimResults(); <span class="comment">// 忽略单个元素前面和后面的空白</span></span><br><span class="line">    <span class="comment">/*  &quot;阿福,成龙   ,,,小玉,    老爹&quot; --&gt; [阿福,成龙,,,小玉,老爹]  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、执行拆分</span></span><br><span class="line">    <span class="comment">// 将处理的结果写到Iterable类型的对象中</span></span><br><span class="line">    Iterable&lt;String&gt; iterable = splitter1.split(srcStr);</span><br><span class="line">    System.out.println(Iterables.toString(iterable));</span><br><span class="line">    <span class="comment">// 将处理的结果写到List类型的对象中</span></span><br><span class="line">    List&lt;String&gt; list = splitter2.splitToList(srcStr);</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_splitter_limit</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;好$好$学$习$天$天$向$上&quot;</span>;</span><br><span class="line">    List&lt;String&gt; dstList = Splitter.on(<span class="string">&#x27;$&#x27;</span>).limit(<span class="number">4</span>).splitToList(srcStr);</span><br><span class="line">    System.out.println(dstList.size()); <span class="comment">// 4。拆分的结果只有4部分</span></span><br><span class="line">    System.out.println(dstList.toString()); <span class="comment">// [好, 好, 学, 习$天$天$向$上]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="内部类MapSplitter"><a href="#内部类MapSplitter" class="headerlink" title="内部类MapSplitter"></a>内部类MapSplitter</h3><p>MapSplitter 是 Splitter 的内部类，它是专门用于处理 KV 形式的字符串，并且会把处理后的字符串写到一个 Map 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_Splitter_withKeyValueSeparator</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;科比=24;乔丹=24;库里=30&quot;</span>;</span><br><span class="line">    Map&lt;String, String&gt; map = Splitter.on(<span class="string">&#x27;;&#x27;</span>).withKeyValueSeparator(<span class="string">&#x27;=&#x27;</span>).split(srcStr);</span><br><span class="line">    System.out.println(map.toString()); <span class="comment">// &#123;科比=24, 乔丹=24, 库里=30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>Tip</strong></p>
<p>  Splitter 实例总是不可变的。每次执行 Splitter 的定义语句返回的都是一个新的 splitter 实例。这保证了 splitter 实例都是线程安全的，你可以将其定义为 static final 常量。</p>
</blockquote>
<h2 id="字符串匹配器-CharMatcher"><a href="#字符串匹配器-CharMatcher" class="headerlink" title="字符串匹配器(CharMatcher)"></a>字符串匹配器(CharMatcher)</h2><p>在 Guava 早期的版本中，为了处理字符串，在 StringUtil 类中添加了很多处理字符串的方法。如 allSacii、collapse、collapseControlChars、collapseWhitespace、indexOfChars、lastIndexNotOf、numSharedChars、removeChars、removeCrLf、replaceChars、retainAllChars、strip、stripAndCollapse、stripNonDigits 等等。</p>
<p>但是归根结底，所有的字符串处理方法都只为了解决两个问题：</p>
<ul>
<li>如何匹配字符串？</li>
<li>如何处理匹配成功的字符串？</li>
</ul>
<p>为了解决这个难题，Guava 提供了 CharMatcher 工具类。</p>
<p>你可以简单地认为一个 CharMatcher 实例代表着某一<strong>类</strong>字符，如数字类、空白字符类、大写字符类、小写字符类等等。实际上，CharMatcher 实例就是对字符串中的每个字符进行布尔判断，判断其是否属于某一类。</p>
<p>CharMatcher 底层通过实现 <code>Predicate&lt;Character&gt;</code> 接口来实现断言功能（判断某个字符是否属于某一类）。</p>
<blockquote>
<p>  <code>public abstract class CharMatcher implements Predicate&lt;Character&gt; &#123;</code></p>
</blockquote>
<p>使用 CharMatcher 的好处在于它还提供了一系列方法，让你可以对字符串作特定的操作(如何处理匹配成功的字符串)，包括了：</p>
<ul>
<li>  修剪(trim)</li>
<li>  折叠(collapse)</li>
<li>  移除(remove)</li>
<li>  保留(retain)</li>
<li>  ……</li>
</ul>
<p>使用 CharMatcher 主要分为两步：</p>
<ul>
<li>  step1：匹配字符串；</li>
<li>  step2：对匹配成功的字符串执行特定的操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只保留数字字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_digit_retain</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;control 1 control 2 control 3&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> CharMatcher</span><br><span class="line">            .digit() <span class="comment">//匹配数字</span></span><br><span class="line">            .retainFrom(str); <span class="comment">//执行“保留”操作</span></span><br><span class="line">    System.out.println(resStr); <span class="comment">//123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去掉两端的空格，并把中间的连续空格替换成字符 &#x27;*&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWHITESPACE</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;  好好学习，    天天向上！  &quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> CharMatcher</span><br><span class="line">            .whitespace() <span class="comment">//匹配空格</span></span><br><span class="line">            .trimAndCollapseFrom(str, <span class="string">&#x27;*&#x27;</span>); <span class="comment">//匹配到3组空格后：1.移除头部和尾部的2组空格；2.压缩中间一组空格，并使用*代替空格</span></span><br><span class="line">    System.out.println(resStr); <span class="comment">//好好学习，*天天向上！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJAVA_DIGIT</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;不3不4；3妻4妾；7上8下&quot;</span>;</span><br><span class="line">    <span class="comment">// 用 &#x27;*&#x27; 替换所有数字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> CharMatcher</span><br><span class="line">            .javaDigit() <span class="comment">//匹配数字</span></span><br><span class="line">            .replaceFrom(str, <span class="string">&#x27;*&#x27;</span>); <span class="comment">// 执行“替换”操作</span></span><br><span class="line">    System.out.println(resStr); <span class="comment">//不*不*；*妻*妾；*上*下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 只保留数字和小写字母</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,I am 23 years!&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> CharMatcher.javaDigit() <span class="comment">//匹配数字</span></span><br><span class="line">            .or(CharMatcher.javaLowerCase()) <span class="comment">//匹配大写字母</span></span><br><span class="line">            .retainFrom(str); <span class="comment">//执行“保留”操作</span></span><br><span class="line">    System.out.println(resStr); <span class="comment">//elloam23years</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取字符串匹配器"><a href="#获取字符串匹配器" class="headerlink" title="获取字符串匹配器"></a>获取字符串匹配器</h3><p>如下图所示，CharMatcher 提供了很多方法可以满足日常使用中的大多数字符串匹配的需求。</p>
<p><img src="/2022/06/14/Guava/image-20220618182414129.png" alt="image-20220618182414129"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>any()</td>
<td>匹配全部字符</td>
<td></td>
</tr>
<tr>
<td>none()</td>
<td>所有字符都不匹配</td>
<td></td>
</tr>
<tr>
<td>anyof()</td>
<td>？</td>
<td></td>
</tr>
<tr>
<td>ascii()</td>
<td>判断字符是否为ASCII</td>
<td></td>
</tr>
<tr>
<td>breakingWhitespace()</td>
<td>匹配字符串中的空格。</td>
<td></td>
</tr>
<tr>
<td>digit()</td>
<td>根据Unicode确定字符是否为数字。</td>
<td></td>
</tr>
<tr>
<td>inRange(char, char)</td>
<td>给定字符范围匹配。</td>
<td></td>
</tr>
<tr>
<td>invisible()</td>
<td>确定字符是否不可见(根据字符的Unicode类别确定)</td>
<td></td>
</tr>
<tr>
<td>is(char match)</td>
<td>匹配单个字符</td>
<td></td>
</tr>
<tr>
<td>isNot(char match)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>javaDigit()</td>
<td>根据Java的定义确定字符是否为数字。</td>
<td></td>
</tr>
<tr>
<td>javaLetter()</td>
<td>根据Java的定义确定字符是否为字母。</td>
<td></td>
</tr>
<tr>
<td>javaLetterOrDigit()</td>
<td>根据Java的定义确定字符是字母或数字。</td>
<td></td>
</tr>
<tr>
<td>javaLowerCase</td>
<td>根据Java的定义确定字符是否为小写字母。</td>
<td></td>
</tr>
<tr>
<td>javaUpperCase</td>
<td>根据Java的定义确定字符是否为大写字母。</td>
<td></td>
</tr>
<tr>
<td>noneOf()</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>singleWidth()</td>
<td>判断字符是否为单字节宽度</td>
<td>汉字总是大于一个字节，可以根据这个特性区分出英文和中文</td>
</tr>
<tr>
<td>whitespace()</td>
<td>根据最新的Unicode标准确定字符是否为空格，</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>CharMatcher breakingWhitespace()</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_breakingWhitespace</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CharMatcher.breakingWhitespace().removeFrom(<span class="string">&quot;啊，   我爱你  中国&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> CharMatcher.breakingWhitespace().replaceFrom(<span class="string">&quot;啊，   我爱你  中国&quot;</span>, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">    System.out.println(s); <span class="comment">// 啊，我爱你中国</span></span><br><span class="line">    System.out.println(s1); <span class="comment">// 啊，啊，___我爱你__中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>is(char match)/isNot(char match)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CharMatcher.is(<span class="string">&#x27;a&#x27;</span>).removeFrom(<span class="string">&quot;abc_abc_abc&quot;</span>);</span><br><span class="line">System.out.println(s); <span class="comment">//bc_bc_bc</span></span><br></pre></td></tr></table></figure>

<p><strong>inRange(char, char)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CharMatcher.inRange(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>).removeFrom(<span class="string">&quot;ABC_abc_123&quot;</span>);</span><br><span class="line">System.out.println(s); <span class="comment">//ABC__123</span></span><br></pre></td></tr></table></figure>



<h3 id="使用字符串匹配器"><a href="#使用字符串匹配器" class="headerlink" title="使用字符串匹配器"></a>使用字符串匹配器</h3><p>CharMatcher 提供了多种方法操作匹配到的字符。其中最常见的如下：</p>
<p><img src="/2022/06/14/Guava/image-20220618201827157.png" alt="image-20220618201827157"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String retainFrom(CharSequence sequence)</td>
<td>在字符序列中保留匹配到的字符，移出其它字符。</td>
</tr>
<tr>
<td>String removeFrom(CharSequence sequence)</td>
<td>从字符序列中移除所有匹配到的字符</td>
</tr>
<tr>
<td>String replaceFrom(CharSequence sequence, CharSequence replacement)</td>
<td>用特定的字符序列代替匹配到的字符</td>
</tr>
<tr>
<td>String trimFrom(CharSequence sequence)</td>
<td>移除字符序列的头部匹配字符和尾部匹配字符</td>
</tr>
<tr>
<td>String collapseFrom(CharSequence sequence, char replacement)</td>
<td>把匹配到的每组连续字符首先压缩为单个字符，再替换为指定字符。</td>
</tr>
<tr>
<td>boolean matchesAllOf(CharSequence sequence)</td>
<td>判断是否字符序列中的所有字符都匹配成功</td>
</tr>
<tr>
<td>boolean matches(char c)</td>
<td>判断某个字符是否匹配成功</td>
</tr>
<tr>
<td>int countIn(CharSequence sequence)</td>
<td>统计sequence中有多少个符合条件的字符</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>matches(char c)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_matches</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 判断字符&#x27;5&#x27;是否是Java中的数字类型</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> CharMatcher.javaDigit().matches(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">    System.out.println(b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断字符&#x27;a&#x27;是否是Java中的数字类型</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> CharMatcher.javaDigit().matches(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    System.out.println(b1); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>int countIn(CharSequence sequence)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_countIn</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 统计 content 中有多少个 &#x27;a&#x27; 字符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;A big black bear sat on a big black bug&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> CharMatcher.is(<span class="string">&#x27;a&#x27;</span>).countIn(content);</span><br><span class="line">    System.out.println(count); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>String collapseFrom(CharSequence sequence, char replacement)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_collapseFrom</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1、首先通过 breakingWhitespace 匹配到所有的空格</span></span><br><span class="line"><span class="comment">    * 2、压缩，如果存在多个空格，就压缩为一个空格</span></span><br><span class="line"><span class="comment">    * 3、替换空格为&#x27;!&#x27;</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CharMatcher.breakingWhitespace().collapseFrom(<span class="string">&quot;啊   我爱你   中国&quot;</span>, <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    System.out.println(s); <span class="comment">// 啊!我爱你!中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="字符集-Charsets"><a href="#字符集-Charsets" class="headerlink" title="字符集(Charsets)"></a>字符集(Charsets)</h2><p>Charsets 针对所有 Java 平台都会使用的6种字符集提供了常量引用。并建议我们在项目中使用这些常量引用，而不是通过字面量名称获取字符集实例。</p>
<ul>
<li><p>不要这样做字符集处理：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用字符串“UTF-8”指定字符串编码格式</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="string">&quot;Hello world&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>试试这样写：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="string">&quot;Hello world&quot;</span>.getBytes(Charsets.UTF_8);</span><br></pre></td></tr></table></figure>
<ul>
<li>避免因手动输出失误，导致 UnsupportedEncodingException 异常</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/14/Guava/image-20220618203756169.png" alt="image-20220618203756169"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Charset</span> <span class="variable">charset</span> <span class="operator">=</span> Charsets.UTF_8;</span><br><span class="line">    <span class="type">Charset</span> <span class="variable">charset1</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(charset.equals(charset1)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Charsets.UTF_8 源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">UTF_8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="大小写格式-CaseFormat"><a href="#大小写格式-CaseFormat" class="headerlink" title="大小写格式(CaseFormat)"></a>大小写格式(CaseFormat)</h2><p>CaseFormat 被用来进行字符串在各种书写格式之间进行转换。比如：大小写、驼峰等等。</p>
<p>CaseFormat 支持的格式如下：</p>
<p><img src="/2022/06/14/Guava/image-20220618204633138.png" alt="image-20220618204633138"></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>LOWER_CAMEL</td>
<td>helloWorld</td>
</tr>
<tr>
<td>LOWER_HYPHEN</td>
<td>hello-world</td>
</tr>
<tr>
<td>LOWER_UNDERSCORE</td>
<td>hello_world</td>
</tr>
<tr>
<td>UPPER_CAMEL</td>
<td>HelloWorld</td>
</tr>
<tr>
<td>UPPER_UNDERSCORE</td>
<td>HELLO_WORLD</td>
</tr>
</tbody></table>
<p>CaseFormat 的用法非常直接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 LOWER_CAMEL 格式的 helloWorld 转为 UPPER_UNDERSCORE 格式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, <span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">System.out.println(s); <span class="comment">//HELLO_WORLD</span></span><br></pre></td></tr></table></figure>







<h2 id="Strings工具类"><a href="#Strings工具类" class="headerlink" title="Strings工具类"></a>Strings工具类</h2><p>我们首先来看一下 Strings 工具类提供的一些静态方法。</p>
<p><img src="/2022/06/14/Guava/image-20220621181533957.png" alt="image-20220621181533957"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String emptyToNull(String string)</td>
<td>将空字符串转换为NULL</td>
</tr>
<tr>
<td>String nullToEmpty(String string)</td>
<td>将NULL转换为空字符串</td>
</tr>
<tr>
<td>String commonPrefix(CharSequence a, CharSequence b)</td>
<td>返回两个字符串的公共前缀</td>
</tr>
<tr>
<td>String commonSuffix(CharSequence a, CharSequence b)</td>
<td>返回两个字符串的公共后缀</td>
</tr>
<tr>
<td>String repeat(String string, int count)</td>
<td>返回由<code>输入字符串*特定数量</code>的连接组成的字符串</td>
</tr>
<tr>
<td>boolean isNullOrEmpty(String string)</td>
<td></td>
</tr>
<tr>
<td>String padStart(String string, int minLength, char padChar)</td>
<td>判断字符串是否满足给定的最小长度，若不<br>满足则使用指定字符填充到最小要求长度。</td>
</tr>
<tr>
<td>String padEnd(String string, int minLength, char padChar)</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>emptyToNull</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Strings;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/21 18:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_emptyToNull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1、emptyToNull</span></span><br><span class="line">        <span class="comment">// 如果一个字符串是空串，就可以调用 emptyToNull 方法把它转换成一个 NULL 值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Strings.emptyToNull(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(s == <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：&quot;空格&quot; 不是空字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Strings.emptyToNull(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(s1 == <span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、nullToEmpty</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> Strings.nullToEmpty(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===&quot;</span> + s2 + <span class="string">&quot;===&quot;</span>); <span class="comment">// ======</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：如果传入的参数不是NULL，则将字符串原样返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> Strings.nullToEmpty(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(s3); <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、commonPrefix：返回两个字符串的公共前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> Strings.commonPrefix(<span class="string">&quot;张三风&quot;</span>, <span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        System.out.println(s4); <span class="comment">// 张三</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：如果两个字符串没有公共的前缀，则返回空字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> Strings.commonPrefix(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(s5.equals(<span class="string">&quot;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、commonPrefix：返回两个字符串的公共后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> Strings.commonSuffix(<span class="string">&quot;龙傲天&quot;</span>, <span class="string">&quot;帝释天&quot;</span>);</span><br><span class="line">        System.out.println(s6); <span class="comment">// 天</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、repeat</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> Strings.repeat(<span class="string">&quot;嗨 &quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(s7); <span class="comment">// 嗨 嗨 嗨</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、isNullOrEmpty</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Strings.isNullOrEmpty(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> Strings.isNullOrEmpty(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(b1 + <span class="string">&quot;;&quot;</span> + b2); <span class="comment">// true;true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9、padStart/padEnd：判断字符串是否满足给定的最小长度，若不满足则填充到最小要求长度</span></span><br><span class="line">        <span class="comment">// 在原字符串的头部 padStart 填充</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> Strings.padStart(<span class="string">&quot;hello&quot;</span>, <span class="number">9</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        System.out.println(s9); <span class="comment">// xxxxhello</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在原字符串的尾部填充</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s10</span> <span class="operator">=</span> Strings.padEnd(<span class="string">&quot;hello&quot;</span>, <span class="number">9</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        System.out.println(s10); <span class="comment">// xxxxhello</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果字符串长度大于要求的最小长度，则无需填充</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> Strings.padStart(<span class="string">&quot;hello&quot;</span>, <span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        System.out.println(s8); <span class="comment">// helloxxxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="Guava的函数式编程-Functional"><a href="#Guava的函数式编程-Functional" class="headerlink" title="Guava的函数式编程[Functional]"></a>Guava的函数式编程[Functional]</h1><p>Guava 的函数式编程与 JDK8 的函数式编程非常类似，但是通过引入 Guava 可以在更早的 JDK 版本中使用函数式编程。</p>
<h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p>一个 <code>&lt;X&gt; input</code>，一个 <code>boolean output</code></p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>一个 <code>&lt;X&gt; input</code>，一个 <code>&lt;Y&gt; output</code></p>
<h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h2><p>没有 input，有一个 <code>&lt;Y&gt; output</code></p>
<h2 id="Functional"><a href="#Functional" class="headerlink" title="Functional"></a>Functional</h2><h1 id="Guava之I-O"><a href="#Guava之I-O" class="headerlink" title="Guava之I/O"></a>Guava之I/O</h1><p>同类产品：Apache commons-io</p>
<h2 id="为字节流-字符流提供的工具类"><a href="#为字节流-字符流提供的工具类" class="headerlink" title="为字节流/字符流提供的工具类"></a>为字节流/字符流提供的工具类</h2><ul>
<li>ByteStreams：提供对 InputStream/OutputStream 的操作。</li>
<li>CharStreams：提供对 Reader/Writer 的操作。</li>
</ul>
<p>在已创建流的基础上，可以使用 ByteStreams 和 CharStreams 对已创建的流进行操作。</p>
<p>注意：在使用完这两个工具类之后，一定要记得手动关闭已创建的流，因为流对象并不是这两个工具类创建的，它们只是对流对象进行了各项操作，所以它们并不能自动关闭流。</p>
<h2 id="源（Source）与汇（Sink）：对I-O进一步的抽象"><a href="#源（Source）与汇（Sink）：对I-O进一步的抽象" class="headerlink" title="源（Source）与汇（Sink）：对I/O进一步的抽象"></a>源（Source）与汇（Sink）：对I/O进一步的抽象</h2><p>源（Source）与汇（Sink）是 Guava 对 IO 的进一步抽象。</p>
<blockquote>
<p>I/O 指的是：InputStream、OutputStream、Reader、Writer 四大基类及其各种子实现类</p>
</blockquote>
<ul>
<li><strong>源（Source）：可读的数据流</strong></li>
<li><strong>汇（Sink）：可写的数据流</strong></li>
</ul>
<p>创建流对象的源头可能是不同的，比如：</p>
<ul>
<li>数据源是一个网络资源(URL)</li>
<li>或者数据源是一个文件</li>
</ul>
<p>但是通过这些不同的数据源创建出来的流对象本质上是一致的。所以 Guava 在此基础上提出了<strong>源（Source）</strong>和<strong>汇（Sink）</strong>的抽象。</p>
<ul>
<li>源是可读的，</li>
<li>汇是可写的，</li>
</ul>
<p>对于不同的数据类型，源又分为：</p>
<ul>
<li>ByteSource</li>
<li>CharSource</li>
</ul>
<p>汇被分为：</p>
<ul>
<li>ByteSink</li>
<li>CharSink</li>
</ul>
<p>通过这两个概念，我们在使用时可以屏蔽掉流是如何创建的。通过统一的一组 API 就可以操作由不同的源创建出来的流。并且由于它（Source 和 Sink）还是流的创建者，所以在使用完毕后还会负责将流关闭。</p>
<blockquote>
<p>比如，之前在使用流时我们会创建 FileInputStream 表示源来自于文件，HttpInputStream 表示数据来源于 HTTP 消息，PipeInputStream 表示数据来源于管道。但是我们又没办法不使用具体的实现类，因为基类 InputStream 中只提供了很少的可供使用的公共方法。</p>
</blockquote>
<h2 id="实战案例：文件操作"><a href="#实战案例：文件操作" class="headerlink" title="实战案例：文件操作"></a>实战案例：文件操作</h2><blockquote>
<p>利用 Guava 提供的相关工具类，实现对文件的常见操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableList;</span><br><span class="line"><span class="keyword">import</span> com.google.common.io.CharSink;</span><br><span class="line"><span class="keyword">import</span> com.google.common.io.CharSource;</span><br><span class="line"><span class="keyword">import</span> com.google.common.io.Files;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/26 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用源（Source）与汇（Sink）对文件进行操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建对应的 Source 和 Sink</span></span><br><span class="line">        <span class="type">CharSource</span> <span class="variable">charSource</span> <span class="operator">=</span> Files.asCharSource(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;data.txt&quot;</span>), Charsets.UTF_8);</span><br><span class="line">        <span class="type">CharSink</span> <span class="variable">charSink</span> <span class="operator">=</span> Files.asCharSink(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;data_backup.txt&quot;</span>), Charsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、文件拷贝：将源数据写入汇中</span></span><br><span class="line">        charSource.copyTo(charSink);</span><br><span class="line">        ImmutableList&lt;String&gt; strings = charSource.readLines();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>charSource 对象中的常用方法</p>
<p><img src="/2022/06/14/Guava/image-20220626213840626.png" alt="image-20220626213840626"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将文件中的全部数据读到 String 类型的字符串中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件中的第一行数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readFirstLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行读取文件中的数据，并将读到的数据保存到不可变集合 ImmutableList 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ImmutableList&lt;String&gt; <span class="title function_">readLines</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐行读取文件中的数据，并对每一行数据都使用行处理器 LineProcessor 进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readLines</span><span class="params">(LineProcessor&lt;T&gt; processor)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行形成一个Stream流对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Stream&lt;String&gt; <span class="title function_">lines</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>charSink 对象中的常用方法</p>
<p><img src="/2022/06/14/Guava/image-20220626215615258.png" alt="image-20220626215615258"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 charSequence 中的数据写入“汇”（charSink对象）中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(CharSequence charSequence)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Readable 对象中的数据写入“汇”（charSink对象）中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeFrom</span><span class="params">(Readable readable)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行写入。数据来源于已划分好元素的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLines</span><span class="params">(Iterable&lt;? extends CharSequence&gt; lines)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行写入。对每行元素还可以通过 lineSeparator 进一步划分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLines</span><span class="params">(Iterable&lt;? extends CharSequence&gt; lines, String lineSeparator)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行写入。数据来源于 Stream 流对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLines</span><span class="params">(Stream&lt;? extends CharSequence&gt; lines)</span></span><br></pre></td></tr></table></figure>







<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>拷贝文件</p>
<p><img src="/2022/06/14/Guava/image-20220621210614019.png" alt="image-20220621210614019"></p>
<p>移动文件</p>
<p><img src="/2022/06/14/Guava/image-20220621212601535.png" alt="image-20220621212601535"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建流与汇对象</p>
<p>创建临时文件</p>
<p>创建文件的父级目录</p>
<p>判断文件</p>
<p>CharSource</p>
<p>CharSink</p>
<p>CharStreams</p>
<p>ByteSource</p>
<p>ByteSink</p>
<p>ByteStreams</p>
<p>Closer</p>
<p>BaseEncoding</p>
<hr>
<h1 id="汪文君Collections"><a href="#汪文君Collections" class="headerlink" title="汪文君Collections"></a><strong>汪文君Collections</strong></h1><h2 id="FluentIterable"><a href="#FluentIterable" class="headerlink" title="FluentIterable"></a><strong>FluentIterable</strong></h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h3><p><strong>FluentIterable 是一个工具类，提供了如下静态方法：</strong></p>
<p><strong><img src="/2022/06/14/Guava/image-20220620213131901.png" alt="image-20220620213131901"></strong></p>
<ul>
<li><p><strong>from()：从数组类型 <code>E[]</code> 或 Iterable 类型的容器中取出数据放入 FluentIterable 集合中。</strong></p>
<ul>
<li><strong><code>FluentIterable&lt;E&gt; from(E[] elements)</code></strong></li>
<li><strong><code>FluentIterable&lt;E&gt; from(FluentIterable&lt;E&gt; iterable)</code></strong></li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> FluentIterable <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; nameList = Lists.newArrayList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    FluentIterable&lt;String&gt; fluentIterable = FluentIterable.from(nameList);</span><br><span class="line">    <span class="keyword">for</span> (String s : fluentIterable) &#123;</span><br><span class="line">        System.out.print(s); <span class="comment">// 张三 李四 王五</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fluentIterable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>concat()</code> 将数据拼接起来</strong></p>
</li>
<li><p><strong><code>of()</code> 0 个元素</strong></p>
</li>
<li><p><strong><code>of(E element, E... elements)</code> 1到多个元素。可变长度的 elements 可以为 0 个，但 element 必须有一个。</strong></p>
</li>
</ul>
<h3 id="普通方法-2"><a href="#普通方法-2" class="headerlink" title="普通方法"></a><strong>普通方法</strong></h3><p><strong>通过构造一个 FluentIterable 实例，我们看到它可以调用如下普通方法。</strong></p>
<p><strong><img src="/2022/06/14/Guava/image-20220620214807393.png" alt="image-20220620214807393"></strong></p>
<blockquote>
<p><strong><code>transformAndConcat(Function&lt;? super E, ? extends Iterable&lt;? extends T&gt;&gt; function)</code></strong></p>
</blockquote>
<p><strong>转换和连接</strong></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/03/Activiti7/" rel="prev" title="Activiti7">
                  <i class="fa fa-chevron-left"></i> Activiti7
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/06/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" rel="next" title="网络编程理论基础">
                  网络编程理论基础 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
