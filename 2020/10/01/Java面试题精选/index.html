<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1、JavaSE Java中创建对象的5种方式    创建方式 是否调用构造函数     1 使用new关键字 是    2 使用Class类的newInstance()方法 是    3 使用Constructor类的newInstance() 是    4 使用clone()方法 否    5 使用反序列化 否     第2种和第3种方式都利用了反射机制。  Java当中的四种引用 强引用&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题精选">
<meta property="og:url" content="http://example.com/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1、JavaSE Java中创建对象的5种方式    创建方式 是否调用构造函数     1 使用new关键字 是    2 使用Class类的newInstance()方法 是    3 使用Constructor类的newInstance() 是    4 使用clone()方法 否    5 使用反序列化 否     第2种和第3种方式都利用了反射机制。  Java当中的四种引用 强引用&amp;g">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/image-20200927103816987.png">
<meta property="og:image" content="http://example.com/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/image-20200927104116199.png">
<meta property="article:published_time" content="2020-10-01T02:15:19.000Z">
<meta property="article:modified_time" content="2020-12-03T03:35:44.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/image-20200927103816987.png">


<link rel="canonical" href="http://example.com/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/","path":"2020/10/01/Java面试题精选/","title":"Java面试题精选"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java面试题精选 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1%E3%80%81JavaSE"><span class="nav-number">1.</span> <span class="nav-text">1、JavaSE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">Java中创建对象的5种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%BD%93%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">Java当中的四种引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">为什么要有不同的引用类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD-%E5%92%8Cequals-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Fequals-%E5%92%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">Java中&#x3D;&#x3D;和equals()的区别？equals()和hashCode的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81"><span class="nav-number">1.4.1.</span> <span class="nav-text">1、&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81equals"><span class="nav-number">1.4.2.</span> <span class="nav-text">2、equals()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81hashCode"><span class="nav-number">1.4.3.</span> <span class="nav-text">3、hashCode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E5%9C%A8hashCode%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E5%90%97%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">可以在hashCode中使用随机数字吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-0-1-0-3%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">3*0.1&#x3D;&#x3D;0.3返回值是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">1.7.</span> <span class="nav-text">+&#x3D;符号的扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-number">1.8.</span> <span class="nav-text">常量和变量的运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.9.</span> <span class="nav-text">数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.9.1.</span> <span class="nav-text">1、自动转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.9.2.</span> <span class="nav-text">2、强制转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">1.10.</span> <span class="nav-text">数据类型相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%8164%E4%BD%8D%E7%9A%84JVM%E4%B8%AD%EF%BC%8Cint%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%95%BF%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-number">1.10.1.</span> <span class="nav-text">1、64位的JVM中，int类型的长度是多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.2.</span> <span class="nav-text">2、int和Integer的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81int%E5%92%8CInteger%E8%B0%81%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%9B%B4%E5%A4%9A%EF%BC%9F"><span class="nav-number">1.10.3.</span> <span class="nav-text">3、int和Integer谁占用的内存更多？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81String%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.4.</span> <span class="nav-text">4、String、StringBuffer和StringBuilder的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="nav-number">1.10.5.</span> <span class="nav-text">5、什么是编译期常量？使用它有什么风险？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.11.</span> <span class="nav-text">关于垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.11.1.</span> <span class="nav-text">1、你知道哪些垃圾回收算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2%E3%80%81JavaWeb"><span class="nav-number">2.</span> <span class="nav-text">2、JavaWeb</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java面试题精选 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java面试题精选
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-01 10:15:19" itemprop="dateCreated datePublished" datetime="2020-10-01T10:15:19+08:00">2020-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2020-12-03 11:35:44" itemprop="dateModified" datetime="2020-12-03T11:35:44+08:00">2020-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1、JavaSE"><a href="#1、JavaSE" class="headerlink" title="1、JavaSE"></a>1、JavaSE</h1><hr>
<h2 id="Java中创建对象的5种方式"><a href="#Java中创建对象的5种方式" class="headerlink" title="Java中创建对象的5种方式"></a>Java中创建对象的5种方式</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">创建方式</th>
<th align="center">是否调用构造函数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">使用<code>new</code>关键字</td>
<td align="center">是</td>
<td></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">使用Class类的<code>newInstance()</code>方法</td>
<td align="center">是</td>
<td></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">使用Constructor类的<code>newInstance()</code></td>
<td align="center">是</td>
<td></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">使用<code>clone()</code>方法</td>
<td align="center">否</td>
<td></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">使用反序列化</td>
<td align="center">否</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>第2种和第3种方式都利用了反射机制。</p>
</blockquote>
<h2 id="Java当中的四种引用"><a href="#Java当中的四种引用" class="headerlink" title="Java当中的四种引用"></a>Java当中的四种引用</h2><ul>
<li><p><code>强引用&gt; 软引用&gt; 弱引用&gt; 虚引用</code>。    不同的引用类型主要体现在<strong>GC</strong>上。</p>
<ol>
<li><p>强引用：</p>
<p>​    如果一个对象具有强引用，他就不会被垃圾回收器回收，即使当前内存空间不足，JVM也不会回收它，而是抛出<code>OutOfMemoryError</code>错误，使程序因出现异常而终止。    </p>
<p>​    如果想中断强引用和某个对象之间的关联，可以显式的将引用值赋为<code>null</code>，这样一来的话，JVM就会在合适的时间回收该对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;	<span class="comment">// 强引用[，不可变对象]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;		<span class="comment">// 取消强引用 </span></span><br></pre></td></tr></table></figure></li>
<li><p>软引用：</p>
<p>​    在使用软引用时，如果内存空间足够，软引用就能继续被使用，而不会被垃圾回收器回收。只有内存不足时，软应用才会被垃圾回收器回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SoftReference</span> <span class="variable">softName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="string">&quot;张三&quot;</span>)；</span><br></pre></td></tr></table></figure></li>
<li><p>弱引用</p>
<p>​    具有弱引用的对象的拥有的生命周期更短暂。    因为当JVM进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。    不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WeakReference</span> <span class="variable">weakName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>虚引用</p>
<p>​    顾名思义，就是形同虚设。如果一个对象仅持有虚引用，那么它相当于没有引用，任何时候都可能被垃圾回收器回收。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="为什么要有不同的引用类型？"><a href="#为什么要有不同的引用类型？" class="headerlink" title="为什么要有不同的引用类型？"></a>为什么要有不同的引用类型？</h2><p>​    在C语言中，我们可以完全手动控制内存的申请和释放。    而在Java中有时候我们需要适当的控制对象的回收时机，因此就诞生了不同的引用类型。可以说不同的引用类型实际上是对GC机制的一种衍生。</p>
<p>​    有以下几个场景可以充分的说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 利用软引用和弱引用解决OOM（Out Of Memory）问题：</span><br><span class="line">    用一个HashMap来保存图片的路径和相应的图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 通过软引用实现Java对象的高速缓存：</span><br><span class="line">    比如我们创建了一个Person的类，如果每次查询一个人的信息时都需要重新构建一个实例，哪怕是几秒钟之前刚刚查询过的，这将引起大量Person对象的消耗，并且由于这些对象生命周期较短，会引起多次GC影响性能。此时，通过软引用和HashMap的结合可以构建高速缓存，提高性能。【？？？】</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Java中-和equals-的区别？equals-和hashCode的区别？"><a href="#Java中-和equals-的区别？equals-和hashCode的区别？" class="headerlink" title="Java中==和equals()的区别？equals()和hashCode的区别？"></a>Java中<code>==</code>和<code>equals()</code>的区别？<code>equals()</code>和<code>hashCode</code>的区别？</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、=="></a>1、==</h3><ol>
<li><p><code>==</code>比较的是两个对象的内存地址。    但是我们又常常碰到这样一个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(x==y);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(s1==s2);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(s1==s3);     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>既然<code>==</code>比较的是地址，那么<code>int、String</code>等数据类型的地址是怎样的呢？</p>
<p>​    对于基本数据类型（<code>byte、char、short、int、long、float、double、boolean</code>）来说，它们是作为常量在方法区中的常量池中以HashSet策略存储起来的。在常量池中，一个常量只会对应一个地址，因此不管再多的<code>123、&quot;123&quot;</code>这样的数据都保存在某一个地址中，即它们的引用指向的是内存中的同一块地址，因此基本类型和String类型的常量是可以通过<code>==</code>来直接比较其是否相等的。</p>
</li>
<li><p>另外，对于基本数据的包装类型（除了Float和Double），其它6种都是实现了常量池的，因此对于这些数据类型而言，我们<strong>一般</strong>以可以直接通过<code>==</code>来判断是否相等。</p>
</li>
<li><p>特殊情况如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.println(i1==i2);     <span class="comment">// true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i3==i4);     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>​    因为Integer在常量池中的存储范围是<code>[-128, 127]</code>，127在范围内，因此是直接存储在常量池中的，而128不在范围内，所以会在堆内存中创建一个新的对象来保存这个值，所以<code>i3、i4</code>分别指向了两个不同的内存地址，所以导致了不相等。</p>
</li>
</ul>
</li>
</ol>
<h3 id="2、equals"><a href="#2、equals" class="headerlink" title="2、equals()"></a>2、equals()</h3><ul>
<li><code>equals()</code>是超类<code>Object</code>类中的方法，用于比较两个对象是否相等。<ol>
<li>默认按两个对象的地址比较，此时和<code>==</code>的结果一样。</li>
<li>如果需要按对象的内容比较，需要重写<code>equals()</code>方法。</li>
</ol>
</li>
</ul>
<h3 id="3、hashCode"><a href="#3、hashCode" class="headerlink" title="3、hashCode"></a>3、hashCode</h3><ol>
<li><p>哈希表：</p>
<p>​    Hash表是一种数据结构，在JDK1.8之前，Hash表底层采用<code>数组+链表</code>实现，即使用链表处理冲突，同一Hash值的对象都存储在一个链表里。    但是当位于一个桶中的元素较多，即Hash值相等的元素较多时，通过key值依次查找的效率较低。    而在JDK1.8中，Hash表存储采用了<code>数组+链表+红黑树</code>实现，当链表长度超过阀值（默认为8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p><img src="/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/image-20200927103816987.png"></p>
<p><img src="/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/image-20200927104116199.png"></p>
</li>
<li><p><code>hashCode()</code>是<code>Object</code>类的一个方法，返回一个<code>int</code>类型的整数，从方法名上就可以看出，其作用就是生成一个Hash码（散列码）。    所有的Hash函数都有如下一个基本特性：</p>
<ul>
<li>如果<code>a=b</code>，则<code>h(a)=h(b)</code>；</li>
<li>如果<code>a!=b</code>，则<code>h(a)</code>与<code>h(b)</code>可能得到相同的hash值。</li>
</ul>
</li>
<li><p>HashCode的作用：</p>
<p>​    要想明白HashCode的作用，必须先知道Java中的集合。    总的来说，Java中的集合（Collection）分为两类，一类是List，另一类是Set。List集合中的元素时有序的，可以重复。<strong>Set</strong>集合中元素是无序的，不可以重复。</p>
<p>​    那么两个元素是否重复应该根据什么依据来判断呢？    显然我们可以使用<code>Object.equals()</code>方法。但是，如果每增加一个元素就检查一次，如果集合中现在已经有1000个元素，那么第1001个元素加入的时候，它就要调用1000次<code>equals()</code>方法，这显然效率非常低。于是，Java采取了Hash表的原理。</p>
<p>​    此时，当集合要添加新元素时，首先调用这个元素的<code>HashCode()</code>方法，就能一下子定位到它本应该存放的位置上。如果这个位置上没有元素，他就可以直接存储在这个位置上。    如果这个位置上已经有元素了，就调用该元素的<code>equals()</code>方法与新元素进行比较，相同的话就不存储新元素，不相同的话就存储在该位置的链表(或红黑树)上。这样一来实际调用<code>equals()</code>方法的次数就大大降低了。</p>
</li>
</ol>
<h2 id="可以在hashCode中使用随机数字吗？"><a href="#可以在hashCode中使用随机数字吗？" class="headerlink" title="可以在hashCode中使用随机数字吗？"></a>可以在hashCode中使用随机数字吗？</h2><ul>
<li>不行，为了保证同一对象的hashCode值必须相同。</li>
</ul>
<h2 id="3-0-1-0-3返回值是什么？"><a href="#3-0-1-0-3返回值是什么？" class="headerlink" title="3*0.1==0.3返回值是什么？"></a>3*0.1==0.3返回值是什么？</h2><ul>
<li>false，因为有些浮点数不能完全精确的表示出来。</li>
</ul>
<h2 id="符号的扩展"><a href="#符号的扩展" class="headerlink" title="+=符号的扩展"></a>+=符号的扩展</h2><p>​    <code>+=</code>操作符会进行隐式的自动类型转换。    如<code>a+=b</code>会先计算出<code>a+b</code>的结果，再将得到的结果强转为与<code>a</code>相同的类型并赋值给<code>a</code>，而<code>a=a+b</code>则不会进行自动类型转换。如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    s+=<span class="number">1</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	s+=1逻辑上看作是s=s+1，计算结果被提升为int类型，再想short类型赋值时发生错误，因为不能将取值范围大的类型赋值给取值范围小的类型。	</span></span><br><span class="line"><span class="comment">	但是，s=s+1实际上进行2次运算，而s+=1只进行1此运算，并带有强制转换的特点，也就是说s+=1等价于s=(short)(s+1)，因此程序可以正常运行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="常量和变量的运算"><a href="#常量和变量的运算" class="headerlink" title="常量和变量的运算"></a>常量和变量的运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">byte</span> b1=<span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> b2=<span class="number">2</span>;</span><br><span class="line">    <span class="type">byte</span> b3=<span class="number">1</span> + <span class="number">2</span>;		<span class="comment">// ok</span></span><br><span class="line">    <span class="type">byte</span> b4=b1 + b2;	<span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>b3=1 + 2</code>，1和2是常量，为固定不变的数据，在编译的时候，已经确定了<code>1+2</code>的结果并没有超过<code>byte</code>类型的取值范围，可以赋值给变量<code>b3</code>，因此<code>b3=1 + 2</code>是正确的。</li>
<li><code>b3=b2 + b3</code>，<code>b2</code>和<code>b3</code>是变量，变量的值是可能变化的，在编译的时候，编译器不能确定<code>b2+b3</code>的结果是什么，因此会将结果以<code>int</code>类型进行处理，所以<code>int</code>类型不能赋值给<code>byte</code>l类型，因此编译失败。</li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>​    Java程序要求参与计算的数据的类型必须一致，如果数据类型不一致将发生数据类型的转换。</p>
<h3 id="1、自动转换"><a href="#1、自动转换" class="headerlink" title="1、自动转换"></a>1、自动转换</h3><ul>
<li><p>自动转换：将取值范围小的类型自动提升为取值范围大的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// byte x = b + i; // 报错</span></span><br><span class="line">    <span class="comment">//int类型和byte类型运算，首先会将byte类型转换为int类型数据，所以结果是int类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b + i;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2、强制转换"><a href="#2、强制转换" class="headerlink" title="2、强制转换"></a>2、强制转换</h3><ul>
<li>强制类型转换：将取值范围的类型强制转换为取值范围小的类型。<ol>
<li>浮点数转换为整数，直接取消小数点，可能造成数据损失精确度。</li>
<li><code>int</code>强制转换成<code>short</code>，砍掉2个字节，可能造成数据丢失。</li>
</ol>
</li>
</ul>
<h2 id="数据类型相关"><a href="#数据类型相关" class="headerlink" title="数据类型相关"></a>数据类型相关</h2><h3 id="1、64位的JVM中，int类型的长度是多少？"><a href="#1、64位的JVM中，int类型的长度是多少？" class="headerlink" title="1、64位的JVM中，int类型的长度是多少？"></a>1、64位的JVM中，int类型的长度是多少？</h3><ul>
<li>Java中，<code>int</code>类型变量的长度是一个固定值，与平台无关，都是32位。    也就是说，在32为和64位的Java虚拟机中，<code>int</code>类型的长度是相同的。</li>
</ul>
<h3 id="2、int和Integer的区别"><a href="#2、int和Integer的区别" class="headerlink" title="2、int和Integer的区别"></a>2、int和Integer的区别</h3><ul>
<li><code>Integer</code>是<code>int</code>的包装类型，在拆箱和装箱过程中，二者自动转换。<code>int</code>是基本类型，直接存数值，而<code>Integer</code>是对象，用一个引用指向这个对象。</li>
</ul>
<h3 id="3、int和Integer谁占用的内存更多？"><a href="#3、int和Integer谁占用的内存更多？" class="headerlink" title="3、int和Integer谁占用的内存更多？"></a>3、int和Integer谁占用的内存更多？</h3><ul>
<li><code>int</code>占用4个字节，存放在栈里面；而<code>Integer</code>占用16个字节存放在堆中。</li>
</ul>
<h3 id="4、String、StringBuffer和StringBuilder的区别"><a href="#4、String、StringBuffer和StringBuilder的区别" class="headerlink" title="4、String、StringBuffer和StringBuilder的区别"></a>4、String、StringBuffer和StringBuilder的区别</h3><ul>
<li><p><code>String</code>是字符串常量，<code>final</code>修饰；</p>
<p>​    <code>String</code>和<code>StringBuffer</code>主要区别是性能，<code>String</code>是不可变对象，每次对<code>String</code>类型进行操作就相当于产生了一个新的<code>String</code>对象，然后指向新的<code>String</code>对象。所以尽量不要对<code>String</code>进行大量的拼接操作，否则会产生很多临时对象，导致<code>GC</code>开始工作，影响系统性能。</p>
</li>
<li><p><code>StringBuffer</code>是字符串变量（线程安全）；</p>
<p>​    <code>StringBuffer</code>是对对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用<code>StringBuffer</code>。</p>
<p>​    注意：<code>JVM</code>会对<code>String</code>拼接做一定的优化，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;This is a&quot;</span> + <span class="string">&quot;simple&quot;</span> + <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="comment">// 会被JVM直接优化成：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;This is a simple test&quot;</span>;</span><br><span class="line"><span class="comment">// 此时就不存在拼接过程</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>StringBuilder</code>是字符串变量（线程不安全）。</p>
<p>​    <code>StringBuffer</code>是线程安全的可变字符串，其内部实现是可变数组。<code>StringBuilder</code>是<code>JDK1.5</code>新增的，其功能和<code>StringBuffer</code>相似，但是非线程安全。因此，在没有多线程问题的前提下，使用<code>StringBuilder</code>会取得更好的性能。</p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 线程安全和线程不安全：</span></span><br><span class="line"><span class="bullet">1.</span> 线程安全</span><br><span class="line"><span class="code">	线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时进行保护，其它线程不能访问直到该线程读取完，其它线程才可以使用。不会出现数据不一致或者数据污染。</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">2. 线程不安全</span></span><br><span class="line"><span class="code">	线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据，造成所得到的数据时脏数据。</span></span><br></pre></td></tr></table></figure>





<h3 id="5、什么是编译期常量？使用它有什么风险？"><a href="#5、什么是编译期常量？使用它有什么风险？" class="headerlink" title="5、什么是编译期常量？使用它有什么风险？"></a>5、什么是编译期常量？使用它有什么风险？</h3><ol>
<li><p>编译期常量 vs. 运行时常量</p>
<p>​    在Java程序中，常量用关键字**<code>static final</code>**修饰，常量又分为：<code>1.编译期常量</code>；<code>2.运行期常量</code>。</p>
<ul>
<li><p>编译期常量的特点就是：它的值在编译期就可以确定。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">99</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>对于运行时常量，它的值虽然在运行时初始化后不再发生变化，但它的初始值必须等到运行时才能确定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> rand.nextInt(<span class="number">20</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	虽然ii的值在程序初始化后就不会再发生变化，但是编译器无法在编译时确定它的值。[编译期只是做了一个翻译的工作，即将程序员编写的代码转化成机器能够识别的二进制代码]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>编译期常量不依赖类，不会引起类的初始化；而运行期常量依赖类，会引起类的初始化。</strong></p>
</li>
<li><p>公共静态不可变变量<code>[public] static final</code>也就是我们常说的编译器常量。</p>
</li>
</ul>
</li>
<li><p>编译期常量使用的风险</p>
<p>​    由于在编译时，常量会被替换为字面量，这是<code>JVM</code>提高运行效率优化代码的一种方式。但有时也会带来一定的麻烦。</p>
<p>​    如果我们的项目过大，项目整个编译一次特别耗费时间，那么我们有可能只编译代码修改的部分，此时如果我们一旦修改了常量A，且没有重新编译所有引用A常量的部分，那么未编译的部分代码仍会继续使用A的旧值，将会导致程序出错。</p>
</li>
</ol>
<h2 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h2><h3 id="1、你知道哪些垃圾回收算法"><a href="#1、你知道哪些垃圾回收算法" class="headerlink" title="1、你知道哪些垃圾回收算法"></a>1、你知道哪些垃圾回收算法</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 标记-清除</span><br><span class="line"><span class="bullet">2.</span> 标记-复制</span><br><span class="line"><span class="bullet">3.</span> 标记-整理</span><br><span class="line"><span class="bullet">4.</span> 分代回收</span><br></pre></td></tr></table></figure>





<h1 id="2、JavaWeb"><a href="#2、JavaWeb" class="headerlink" title="2、JavaWeb"></a>2、JavaWeb</h1>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/09/20/SpringBoot/" rel="prev" title="SpringBoot">
                  <i class="fa fa-chevron-left"></i> SpringBoot
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/10/07/SpringCloud/" rel="next" title="SpringCould">
                  SpringCould <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
