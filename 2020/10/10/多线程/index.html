<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1    程序 &amp; 线程 &amp; 进程 &amp; 并发 &amp; 并行1.1    进程、线程产生的背景   单指令操作系统   最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在输入的时候，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。    批处理（指令）操作系统   后来有了批处理操作系统，把一系列需要操作的指令写下来">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1    程序 &amp; 线程 &amp; 进程 &amp; 并发 &amp; 并行1.1    进程、线程产生的背景   单指令操作系统   最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在输入的时候，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。    批处理（指令）操作系统   后来有了批处理操作系统，把一系列需要操作的指令写下来">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/7462071-955b1ef86b257315.png">
<meta property="og:image" content="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB.png">
<meta property="og:image" content="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012170616241.png">
<meta property="og:image" content="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012171420707.png">
<meta property="og:image" content="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012165955497.png">
<meta property="article:published_time" content="2020-10-10T13:35:12.000Z">
<meta property="article:modified_time" content="2021-09-27T13:08:59.229Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.png">


<link rel="canonical" href="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","path":"2020/10/10/多线程/","title":"多线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>多线程 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F-amp-%E7%BA%BF%E7%A8%8B-amp-%E8%BF%9B%E7%A8%8B-amp-%E5%B9%B6%E5%8F%91-amp-%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.</span> <span class="nav-text">1    程序 &amp; 线程 &amp; 进程 &amp; 并发 &amp; 并行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">1.1    进程、线程产生的背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">1.2    进程和线程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">1.3.</span> <span class="nav-text">1.3    上下文切换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">1.3.1.</span> <span class="nav-text">线程调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%B9%B6%E5%8F%91-amp-%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.4.</span> <span class="nav-text">1.4    并发 &amp; 并行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">2    Java中创建线程的4种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Thread-%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">2.1    Thread 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Runnable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.</span> <span class="nav-text">2.2    Runnable 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Thread-vs-Runnable"><span class="nav-number">2.3.</span> <span class="nav-text">2.3    Thread vs. Runnable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Callable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.4.</span> <span class="nav-text">2.4    Callable 接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Thread-%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">3    Thread 类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">3.1    概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">3.2    方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1    构造方法（部分）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2    常用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Thread-%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.3.</span> <span class="nav-text">3.3    Thread 类构造方法源码分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">4.</span> <span class="nav-text">4    线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BA%94%E6%80%81"><span class="nav-number">4.1.</span> <span class="nav-text">4.1    操作系统中的线程五态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Java-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%85%AD%E6%80%81"><span class="nav-number">4.2.</span> <span class="nav-text">4.2    Java 中的线程六态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-NEW"><span class="nav-number">4.3.</span> <span class="nav-text">4.3    NEW</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-RUNNABLE"><span class="nav-number">4.4.</span> <span class="nav-text">4.4    RUNNABLE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-BLOCKED"><span class="nav-number">4.5.</span> <span class="nav-text">4.5    BLOCKED</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-WAITING"><span class="nav-number">4.6.</span> <span class="nav-text">4.6    WAITING</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E4%BB%A5%E4%B8%8B-3-%E4%B8%AA%E6%96%B9%E6%B3%95%E4%BC%9A%E4%BD%BF%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="nav-number">4.6.1.</span> <span class="nav-text">调用以下 3 个方法会使线程进入等待状态：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-TIMED-WAITING"><span class="nav-number">4.7.</span> <span class="nav-text">4.7    TIMED_WAITING</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%A6%82%E4%B8%8B%E6%96%B9%E6%B3%95%E4%BC%9A%E4%BD%BF%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="nav-number">4.7.1.</span> <span class="nav-text">调用如下方法会使线程进入超时等待状态：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-TERMINATED"><span class="nav-number">4.8.</span> <span class="nav-text">4.8    TERMINATED</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-9-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="nav-number">4.9.</span> <span class="nav-text">4.9    线程中断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">5.</span> <span class="nav-text">5    线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">5.1.</span> <span class="nav-text">5.1    线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="nav-number">5.2.</span> <span class="nav-text">5.2    案例演示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">5.3.</span> <span class="nav-text">5.3    线程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">5.4.</span> <span class="nav-text">5.3    同步代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.4.0.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">5.5.</span> <span class="nav-text">5.4    同步方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">5.5.0.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3%E3%80%81Lock%E9%94%81%EF%BC%88%E5%90%8C%E6%AD%A5%E9%94%81%EF%BC%89"><span class="nav-number">5.5.1.</span> <span class="nav-text">4.2.3、Lock锁（同步锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">Lock类介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.5.1.2.</span> <span class="nav-text">Lock接口中常用的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">5.5.1.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AD%89%E5%BE%85-%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">6    线程间通信（等待&#x2F;唤醒机制）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">6.1    概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-wait-notify-%E6%9C%BA%E5%88%B6"><span class="nav-number">6.2.</span> <span class="nav-text">6.2    wait&#x2F;notify 机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="nav-number">6.3.</span> <span class="nav-text">6.3    代码演示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">7    Java内存模型（JMM）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">8.</span> <span class="nav-text">8    线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="nav-number">8.1.</span> <span class="nav-text">7.1、概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">8.1.1.</span> <span class="nav-text">使用线程池的好处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.2.</span> <span class="nav-text">7.2、线程池的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">8.2.1.</span> <span class="nav-text">使用线程池对象的步骤</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="多线程 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          多线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-10 21:35:12" itemprop="dateCreated datePublished" datetime="2020-10-10T21:35:12+08:00">2020-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-27 21:08:59" itemprop="dateModified" datetime="2021-09-27T21:08:59+08:00">2021-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-程序-amp-线程-amp-进程-amp-并发-amp-并行"><a href="#1-程序-amp-线程-amp-进程-amp-并发-amp-并行" class="headerlink" title="1    程序 &amp; 线程 &amp; 进程 &amp; 并发 &amp; 并行"></a>1    程序 &amp; 线程 &amp; 进程 &amp; 并发 &amp; 并行</h1><h2 id="1-1-进程、线程产生的背景"><a href="#1-1-进程、线程产生的背景" class="headerlink" title="1.1    进程、线程产生的背景"></a>1.1    进程、线程产生的背景</h2><blockquote>
<ol>
<li> <strong>单指令操作系统</strong></li>
</ol>
</blockquote>
<p>最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在输入的时候，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。</p>
<blockquote>
<ol start="2">
<li> <strong>批处理（指令）操作系统</strong></li>
</ol>
</blockquote>
<p>后来有了批处理操作系统，把一系列需要操作的指令写下来，形成一个清单，一次性交给计算机。用户将多条需要执行的指令写在磁带上，然后交由计算机去读取并逐个执行这些指令，并将输出结果写在另一个磁带上。</p>
<p>批处理操作系统由于可一次不间断地执行多条指令，解决了用户输入速度对执行效率的桎梏，在一定程度上提高了计算机的效率，但是由于批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一条指令在运行，后⾯的指令需要等待前面的指令执行完成后才能开始执行，而前面的指令操作可能会由于 I/O 操作、网络等原因阻塞，所以批处理操作效率也不高。</p>
<p><strong>Tip：</strong></p>
<ul>
<li>  I/O 操作（或网络操作）导致阻塞：当执行某一条指令（比如指令A）时，这条指令要求去访问磁盘上的（或网络中的）资源，那么 CPU 就会去获取磁盘（或网络）中的资源，由于只有一个 CPU，当 I/O（或者网络）操作被阻塞时，CPU 就会一直死等从磁盘（或网络）中获取资源完成，所以就不会去执行指令A之后的指令，所以指令A之后的指令就全部被阻塞了。</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>进程的提出</strong></li>
</ol>
</blockquote>
<ul>
<li>  人们对于计算机的性能要求越来越高，而<strong>批处理操作系统的瓶颈在于内存中只能同时运行一个程序</strong>，那么内存中能不能存在多个程序呢？</li>
<li>  于是，科学家们提出了进程的概念。</li>
<li>  <strong>进程就是正在运行着的程序</strong>，多个进程可“同时”运行，各个进程之间互不⼲扰。</li>
<li>  此时，CPU 采用时间片轮转的方式运行进程：CPU 为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并将 CPU 分配给另一个进程（这个过程叫做<strong>上下文切换</strong>）。<strong>如果进程在时间片结束前阻塞或结束，则CPU 立即进行切换，不用等待时间片用完。</strong></li>
<li>  当进程暂停时，它会保存当前进程的状态，在下一次切换回来时根据之前保存的状态进行恢复，接着继续行。</li>
<li>  使用 <code>进程 + CPU时间片</code> 轮转方式的操作系统，在宏观上看起来同一时间段执行多个任务，换句话说，进程让操作系统的并发成为了可能。虽然并发从宏观上看有多个任务在执行，但在事实上，对于单核CPU来说，任意具体时刻都只有一个任务在占用 CPU 资源。</li>
</ul>
<blockquote>
<p>  <strong>程序：</strong></p>
</blockquote>
<p>程序是指用某种编程语言（Java / Python等）编写，能够完成一定任务或者功能的代码集合，是指令和数据的有序集合，是一段静态代码。</p>
<blockquote>
<ol start="4">
<li> <strong>对操作系统的要求进一步提高</strong></li>
</ol>
</blockquote>
<p>虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，<strong>人们并不满足一个进程在一段时间只能做一件事情</strong>，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。</p>
<p>比如杀毒软件在检测用户电脑时，如果在某一项检测中卡住了，那么后面的检测项也无法进行下去。或者说当你使用杀毒软件中的扫描病毒功能时，在扫描病毒结束之前，无法使用杀毒软件中清理垃圾的功能，这显然无法满足人们的要求。</p>
<blockquote>
<ol start="5">
<li> <strong>线程的提出</strong></li>
</ol>
</blockquote>
<p>为了让同一线程的子任务可以同时执行，于是人们⼜提出了线程的概念，让<strong>一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p>
<p>在有了线程之后，当用户使用扫描病毒功能时，就让扫描病毒这个线程去执行。同时，如果用户又想使用清理垃圾功能，那么可以先<br>暂停扫描病毒线程，先响应用户的清理垃圾的操作，让清理垃圾这个线程去执行。响应完后再切换回来，接着执行扫描病毒线程。</p>
<hr>
<h2 id="1-2-进程和线程的区别"><a href="#1-2-进程和线程的区别" class="headerlink" title="1.2    进程和线程的区别"></a>1.2    进程和线程的区别</h2><blockquote>
<ol>
<li> <strong>进程</strong></li>
</ol>
</blockquote>
<ul>
<li>运行中的应用程序，每个进程都有一个独立的内存空间；</li>
<li>系统运行一个程序即是一个进程从创建、运行、到消亡的过程。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>线程</strong></li>
</ol>
</blockquote>
<ul>
<li>线程是进程中的一个执行单元，负责当前线程任务（进程中的子任务）的执行；</li>
<li>一个进程中至少有一个线程；</li>
<li>一个进程中是可以有多个线程的，这样的程序被称为多线程程序。</li>
</ul>
<p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.png"></p>
<p>一个程序从创建到死亡的过程就是一个进程的生命周期，所以说进程就是运行中的程序。</p>
<p>那么线程又是什么呢？在上图的谷歌浏览器中，我们看一看到运行这一进程我们使用了4个线程，这4个线程或者是并行或者是并发运行，可以充分利用计算机的性能。再举一个简单的例子就是IDM下载器，我们使用了多线程下载来提高下载速度，每个线程只负责一部分的下载任务。多线程是可选的，因为我们执行一个进程最少情况下一个线程也能完成，但是为了提高效率、防止阻塞等原因，我们往往使用多线程来完成。</p>
<p>其实，<strong>多线程程序并不能够提高程序的运行速度，但能够提高程序运行效率，让 CPU 的利用率更高，最常见的就是当某个线程发生 IO 或网络操作时切换到其它线程去利用 CPU 而不是让 CPU 处于空闲等待状态</strong>。</p>
<blockquote>
<ol start="3">
<li> <strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></li>
</ol>
</blockquote>
<p>多进程方式确实可以实现并发，在某些场景下也确实是使用多进程来实现并发的，但使用多线程主要有以下几个好处：</p>
<ol>
<li> 进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，如果我们需要使用共享资源，这些资源在线程间的通信比较容易实现。</li>
<li> 进程是重量级的，而线程是轻量级的。故多线程的创建、销毁开销、上下文切换开销要小于多进程。</li>
</ol>
<blockquote>
<ol start="3">
<li> <strong>进程和线程的区别：</strong></li>
</ol>
</blockquote>
<p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。<strong>它们两个本质的区别是是否单独占有内存空间及其它系统资源（比如I/O）</strong>：</p>
<ul>
<li>  单个进程占有独立的内存空间，所以<strong>进程间存在内存隔离</strong>，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程的内存空间和资源，数据共享简单，但是同步复杂。</li>
<li>  由于进程占有独立的内存空间，一个进程出现问题不会影响其他进程，可靠性高；而一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li>
<li>  进程占有单独的内存空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要进行对分配资源的回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li>
<li>  另一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即 CPU 分配时间的单位 。</strong></li>
</ul>
<hr>
<h2 id="1-3-上下文切换"><a href="#1-3-上下文切换" class="headerlink" title="1.3    上下文切换"></a>1.3    上下文切换</h2><blockquote>
<p>  <strong>概念：</strong></p>
</blockquote>
<p><strong>上下文切换是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。</strong>上下文是指某一时间点 CPU 寄存器和程序计数器<br>的内容。</p>
<blockquote>
<p>  寄存器是 CPU 内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。</p>
<p>  <strong>程序计数器是一个专用的寄存器</strong>，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。</p>
<p>  举例说明：线程 A -&gt; B</p>
<ol>
<li> 先挂起线程 A，将其在 CPU 中的状态保存在内存中。（就是保存当前线程A执行到了哪一条指令了）</li>
<li> 在内存中检索下一个线程 B 的上下文并将其在 CPU 的寄存器中恢复，执行 B 线程。</li>
<li> 当 B 执行完，根据程序计数器中指向的位置恢复线程 A。</li>
</ol>
</blockquote>
<p>CPU 通过为每个线程分配时间片来实现多线程机制。CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p>
<p>但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以继续从上次任务断开的地方继续执行这个任务。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换会消耗⼤量的 CPU 时间，故线程也不是越多越好。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ol>
<li><strong>分时调度</strong>：所有线程轮流使用 CPU ，平均分配每个线程占用 CPU 的时间。</li>
<li><strong>抢占式调度</strong>：优先让优先级高的线程使用 CPU。如果线程的优先级相同，那么会随机选择一个使用CPU。</li>
</ol>
<hr>
<h2 id="1-4-并发-amp-并行"><a href="#1-4-并发-amp-并行" class="headerlink" title="1.4    并发 &amp; 并行"></a>1.4    并发 &amp; 并行</h2><blockquote>
<p>  <strong>并发：</strong></p>
</blockquote>
<ul>
<li>  指两个或多个事件在<strong>同一个时间段</strong>内发生。</li>
<li>  一个 CPU（采用时间片）同时执行多个任务。</li>
</ul>
<blockquote>
<p>  <strong>并行</strong></p>
</blockquote>
<ul>
<li>  指两个或多个事件在<strong>同一时刻</strong>发生。（同时发生）</li>
<li>  即多个 CPU 同时执行多个任务。</li>
</ul>
<hr>
<h1 id="2-Java中创建线程的4种方法"><a href="#2-Java中创建线程的4种方法" class="headerlink" title="2    Java中创建线程的4种方法"></a>2    Java中创建线程的4种方法</h1><blockquote>
<ol>
<li> <strong>继承 Thread 类</strong></li>
<li> <strong>实现 Runnable 接口</strong></li>
<li> <strong>实现 Callable 接口</strong></li>
<li> <strong>线程池</strong></li>
</ol>
</blockquote>
<h2 id="2-1-Thread-类"><a href="#2-1-Thread-类" class="headerlink" title="2.1    Thread 类"></a>2.1    Thread 类</h2><blockquote>
<p>  <strong>步骤：</strong></p>
</blockquote>
<ol>
<li> 创建一个继承于 Thread 类的子类；</li>
<li> 重写 Thread 类中的 <code>run()</code> 方法，在方法中声明此线程要执行的任务；</li>
<li> 创建 Thread 类的子类的对象；</li>
<li> 调用子类对象的 <code>start()</code> 方法。</li>
</ol>
<blockquote>
<p>   <strong>代码实现</strong></p>
</blockquote>
<ol>
<li> 定义 Thread 类的子类 MyThread</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1正在执行任务A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ol>
<li>我们启动一个新线程，必须调用 <code>start()</code>，不能通过调用 <code>run()</code> 的方式启动线程。<ul>
<li>  <strong>我们在程序中调用了 <code>start()</code> 方法后，虚拟机会先为我们创建一个新的线程，然后等到这个线程第一次得到时间片时再调用 <code>run()</code> 方法。</strong></li>
<li>  注意不可多次调用 <code>start()</code> 方法。在第一次调用 <code>start()</code> 方法后，再次调用 <code>start()</code> 方法会<strong>抛出异常</strong>。</li>
</ul>
</li>
<li> 如果再启动一个线程，必须重新创建一个 Thread 子类的对象，调用此对象的 <code>start()</code></li>
</ol>
<hr>
<h2 id="2-2-Runnable-接口"><a href="#2-2-Runnable-接口" class="headerlink" title="2.2    Runnable 接口"></a>2.2    Runnable 接口</h2><blockquote>
<p>  <strong>实现步骤：</strong></p>
</blockquote>
<ol>
<li>定义 Runnable 接口的实现类，重写接口中的 <code>run()</code> 方法，在方法中声明此线程要执行的任务；</li>
<li>创建实现类的实例对象，并将此对象传递到 Thread 类的构造器中，创建 Thread 类实例对象；</li>
<li>通过 Thread 类的实例对象的<code>start()</code>方法启动线程。</li>
</ol>
<blockquote>
<p>  <strong>代码实现</strong></p>
</blockquote>
<ol>
<li> 定义 Runnable 接口的实现类 RunnableImpl</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行体，子线程1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.开启子线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Runnable 接口(JDK 1.8 +)</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Runnable 是一个函数式接口，这意味着我们可以使用 Java8 的函数式编程来简化代码。</p>
<hr>
<h2 id="2-3-Thread-vs-Runnable"><a href="#2-3-Thread-vs-Runnable" class="headerlink" title="2.3    Thread vs. Runnable"></a>2.3    Thread vs. Runnable</h2><blockquote>
<p>  <strong>联系：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>所以本质上，Thread 类中的 run() 也是从 Runnable 接口中继承过来然后重写的。而我们通过继承 Thread 类创建线程对象时又重写了 Thread 类中的 run() 方法</strong></li>
</ul>
<blockquote>
<p>  <strong>相同点：</strong></p>
</blockquote>
<ul>
<li>  两种方式都需要重写 <code>run()</code>，将新线程要执行的任务声明在 <code>run()</code> 中。</li>
<li>  实际上所有的多线程代码都是通过 <code>Thread</code> 类的 <code>start()</code> 方法来运行的。因此，不管是通过继承 <code>Thread</code> 类还是实现 <code>Runnable</code> 接口来实现多线程，最终都要通过<code>Thread</code>类的实例对象来开启线程的。</li>
</ul>
<blockquote>
<p>  <strong>使用：</strong></p>
</blockquote>
<ul>
<li>  开发时，在这两者之中，优先选择实现 Runnable 接口的方式；</li>
<li>  实际开发中，用的最多的还是通过线程池创建线程的方式。而且使用的线程池也不是 JDK 提供的线程的线程池，一般都是使用自定义的线程池。【阿里巴巴开发手册】</li>
</ul>
<blockquote>
<p>  <strong>继承 Thread 类的线程存在的缺陷（实现 Runnable 的线程的优势）：</strong></p>
</blockquote>
<ol>
<li> <strong>类单继承的局限性</strong>：由于单继承的局限性，如果一个类继承了<code>Thread</code>，就不能再继承其它父类了；换句话说，如果一个类已经继承了其它父类，就不能再通过继承 Thread 来实现多线程了，这时候就只能通过实现接口的方式来实现多线程。</li>
<li> <strong>Runnable 接口降低了线程对象和线程任务的耦合性，任务可被多个线程共享</strong>：实现 <code>Runnable</code> 接口的方式，任务和线程独立，任务可被多个线程共享。如果通过继承 Thread 的方式，线程和任务是绑定的，如果某个任务需要被多个线程执行的话就要声明多次。</li>
<li> <strong>线程池只能放入 Runnable 或 Callable 类型的线程，不能直接放入继承 Thread 类型的线程</strong>。</li>
<li> <strong>Runnable 接口更轻量级</strong>，如果使用线程时不需要使用 Thread 类中的诸多方法，显然使用 Runnable 接口更为轻量。</li>
</ol>
<hr>
<h2 id="2-4-Callable-接口"><a href="#2-4-Callable-接口" class="headerlink" title="2.4    Callable 接口"></a>2.4    Callable 接口</h2><ul>
<li>  <code>Callable</code> 与 <code>Runnable</code> 类似，同样是只有一个抽象方法的函数式接口。</li>
<li>  不同的是， <code>Callable</code> 提供的方法是有返回值的，而且支持泛型。</li>
</ul>
<blockquote>
<p>  <strong>Callable 接口源码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>Callable</code> 一般是配合线程池工具 <strong>ExecutorService</strong> 来使用的。</li>
<li>  <code>ExecutorService</code> 可以使用 <code>submit()</code> 方法来执行 Callable 接口中的 <code>call()</code> 方法。【不可以使用 <code>execute()</code> 执行 Callable 类型的任务】</li>
<li>  它会返回一个 <strong>Future</strong> ，我们后续的程序可以通过这个 Future 的 <code>get()</code> 方法得到结果。</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⾃定义 Callable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟计算需要5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="comment">// 使用线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        System.out.println(result.get());	<span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 注意：调⽤get方法会阻塞当前线程，直到得到结果。【线程资源用于死等返回结果，而不会去处理下一行的代码逻辑】</span></span><br><span class="line">        <span class="comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阻塞结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="3-Thread-类"><a href="#3-Thread-类" class="headerlink" title="3    Thread 类"></a>3    Thread 类</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1    概述"></a>3.1    概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span> </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java 使用<code>java.lang.Thread</code> 类代表线程。</li>
<li>所有的线程对象必须是 Thread 类或其子类的实例对象。</li>
<li>每个线程的作用是完成一个<strong>任务</strong>。Java使用<strong>线程执行体</strong>来代表这个任务。</li>
</ul>
<h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2    方法"></a>3.2    方法</h2><h3 id="3-2-1-构造方法（部分）"><a href="#3-2-1-构造方法（部分）" class="headerlink" title="3.2.1    构造方法（部分）"></a>3.2.1    构造方法（部分）</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Thread()</code></td>
<td align="left">创建一个默认名字的新的线程对象</td>
</tr>
<tr>
<td align="left"><code>Thread(String name)</code></td>
<td align="left">分配一个指定名字的新的线程对象</td>
</tr>
<tr>
<td align="left"><code>Thread(Runnable target)</code></td>
<td align="left">分配一个带有指定目标的新的线程对象</td>
</tr>
<tr>
<td align="left"><code>Thread(Runnable target, String name)</code></td>
<td align="left">分配一个带有指定目标的新的线程对象并指定线程名字</td>
</tr>
</tbody></table>
<ul>
<li><code>Runnable target</code> 是一个接口类型，该参数实际使用时接收的是 Runnable 接口的实现类。</li>
<li><code>Runnable</code> 接口的实现类对象中包含了<code>run()</code> 方法作为线程执行体，而实际的线程对象依然是<code>Thread</code>实例，只是该<code>Thread</code>线程负责执行<code>target</code>对象(即<code>Runnable</code>接口的实现类)中的<code>run()</code>方法。</li>
</ul>
<hr>
<h3 id="3-2-2-常用方法"><a href="#3-2-2-常用方法" class="headerlink" title="3.2.2    常用方法"></a>3.2.2    常用方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>thread.getName()</code></td>
<td align="center"><code>String</code></td>
<td align="left">获取当前线程的名称</td>
</tr>
<tr>
<td align="left"><code>thread.start()</code></td>
<td align="center"><code>void</code></td>
<td align="left">创建一个新的线程，并在轮询到CPU资源后开始执行线程指定的任务</td>
</tr>
<tr>
<td align="left"><code>run()</code></td>
<td align="center"><code>void</code></td>
<td align="left">此线程要执行的任务代码</td>
</tr>
<tr>
<td align="left"><code>Thread.sleep(long millis)</code></td>
<td align="center"><code>void</code></td>
<td align="left">静态方法，使当前正在执行的线程暂停x毫秒</td>
</tr>
<tr>
<td align="left"><code>Thread.currentThread()</code></td>
<td align="center"><code>Thread</code></td>
<td align="left">静态方法，返回当前正在执行的线程对象的引用</td>
</tr>
<tr>
<td align="left"><code>Thread.yield()</code></td>
<td align="center"><code>void</code></td>
<td align="left"><code>static native</code>，当前线程愿意让出对当前处理器的占用</td>
</tr>
<tr>
<td align="left"><code>thread.join()</code></td>
<td align="center"><code>void</code></td>
<td align="left">当前线程等待另一个线程执行完毕之后再执行</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>yield</strong></p>
</blockquote>
<p>yield 在英语里有放弃的意思，同样，这里的 <code>yield()</code> 指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了 <code>yield()</code> 方法，程序在调度的时候，也还有可能继续运行这个线程的；</p>
<blockquote>
<p>  <strong>join</strong></p>
</blockquote>
<p><code>join()</code> 方法是通过一个 thread 对象实例来调用的，作用是让外部线程进入“等待”状态，直到调用 <code>join</code> 方法的线程执行完成后，再继续执行外部线程。内部是通过 Object 类的 <code>wait()</code> 方法实现的。</p>
<p>🌰：比如，在 main 线程中创建并启动了子线程 threadA，如果 threadA 中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。如果 main 线程想等到子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到 <code>join()</code> 方法了。<code>join()</code> 方法会暂停当前正在执行的线程（即 main 线程），直到 threadA 线程执行结束之后再继续执行 main 线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/27 12:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务耗时3s</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行成功&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        threadA.start();</span><br><span class="line">        </span><br><span class="line">        threadA.join(); <span class="comment">// 让threadA线程得以执行，但是不让外部的 main 线程执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阻塞结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>sleep 和 wait 方法的区别：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">sleep</th>
<th align="left">wait</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">Thread 对象中的方法</td>
<td align="left">Object 对象中的方法</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>sleep</code> 释放 CPU 资源，但是不释放锁</td>
<td align="left"><code>wait</code> 释放 CPU 资源，同时释放锁</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">不需要被唤醒（休眠之后退出阻塞）</td>
<td align="left">需要被唤醒（不指定时间时需要被唤醒）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>sleep</code> 可以在任意位置</td>
<td align="left"><code>wait</code> 必须放在同步块或同步方法中</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>sleep</code> 必须指定时间</td>
<td align="left"><code>wait</code> 可以指定时间，也可以不指定</td>
</tr>
</tbody></table>
<ul>
<li>  由于 <code>sleep</code> 方法不释放锁，所以当线程醒来之后直接进入 Runnable 状态，当轮询到 CPU 资源后直接可以执行；而 <code>wait</code> 方法释放锁对象，当线程醒来后处于 Blocked 状态，只有再次获得锁之后才会进入 Runnable 状态。</li>
</ul>
<hr>
<h2 id="3-3-Thread-类构造方法源码分析"><a href="#3-3-Thread-类构造方法源码分析" class="headerlink" title="3.3    Thread 类构造方法源码分析"></a>3.3    Thread 类构造方法源码分析</h2><ul>
<li>  Thread 类是 Runnable 接口的一个实现类。</li>
<li>  查看 Thread 类的构造方法，发现 Thread 类的多个重载方法底层都是通过调用了一个私有的 <strong>init</strong> 方法来实现初始化的。 </li>
<li>  init 方法也是一个重载方法，其中参数最多的一个如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段1：init 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                  <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> inheritThreadLocals)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段2：Thread类的构造函数调⽤init⽅法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">    init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段3：使用在init⽅法里初始化AccessControlContext类型的私有属性</span></span><br><span class="line"><span class="built_in">this</span>.inheritedAccessControlContext = acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段4：两个对用于支持ThreadLocal的私有属性</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>init 方法中的参数详解：</strong></p>
<ul>
<li><p>  <strong>ThreadGroup g</strong>：线程组，指定这个线程是在哪个线程组下；</p>
</li>
<li><p>  <strong>Runnable target</strong>：指定要执行的任务；</p>
</li>
<li><p>  <strong>String name</strong>：线程的名字，多个线程的名字是可以重复的。如果不指定名字，默认会自动生成一个名字，见片段2；</p>
</li>
<li><p><strong>AccessControlContext acc</strong>：见片段3，用于初始化私有变量 <code>inheritedAccessControlContext</code>。</p>
<blockquote>
<p>  它是一个私有变量，但是在 Thread 类里只有 <code>init</code> 方法会对它进行初始化，在 exit 方法中把它设为 null 。一般不会使用到它。</p>
</blockquote>
</li>
<li><p>  <strong>inheritThreadLocals：</strong>可继承的 ThreadLocal ，见片段4， Thread 类里面有两个私有属性来⽀持 ThreadLocal 。</p>
</li>
</ul>
</blockquote>
<hr>
<h1 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4    线程状态"></a>4    线程状态</h1><h2 id="4-1-操作系统中的线程五态"><a href="#4-1-操作系统中的线程五态" class="headerlink" title="4.1    操作系统中的线程五态"></a>4.1    操作系统中的线程五态</h2><p>在现代操作系统中，<strong>线程被视为轻量级的进程，所以操作系统线程的状态和操作系统进程的状态是一致的</strong>。</p>
<p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/7462071-955b1ef86b257315.png" alt="img"></p>
<p>操作系统线程主要有以下三个状态：</p>
<ul>
<li>  **就绪状态(ready)**：线程正在等待 CPU，获得 CPU 之后可进入 running 状态。</li>
<li>  **执行状态(running)**：线程正在使用 CPU。</li>
<li>  **等待状态(waiting)**：线程被等待事件的调用或者正在等待其他资源（如 I/O）。</li>
</ul>
<hr>
<h2 id="4-2-Java-中的线程六态"><a href="#4-2-Java-中的线程六态" class="headerlink" title="4.2    Java 中的线程六态"></a>4.2    Java 中的线程六态</h2><p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB.png"></p>
<blockquote>
<p>  <strong>Thread.State 源码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="left">线程状态</th>
<th align="left">发生的条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>New</code></td>
<td align="left">线程刚被创建，但是<strong>还没有调用<code>start()</code>方法</strong>。</td>
</tr>
<tr>
<td align="left"><code>Runnable</code></td>
<td align="left">线程可以在 Java 虚拟机中运行，但不一定正在运行，什么时候运行取决于底层的操作系统。</td>
</tr>
<tr>
<td align="left"><code>Blocked</code></td>
<td align="left">当一个线程试图获取一个锁对象，而该锁对象被其它线程持有，则该线程进入<code>Blocked</code>状态，当该线程持有锁时，该线程将变成<code>Runnable</code>状态。</td>
</tr>
<tr>
<td align="left"><code>Waiting</code></td>
<td align="left">一个线程在等待另一个线程执行唤醒动作时，该线程进入<code>Waiting</code>状态。进入这个状态时不能自动唤醒的，必须等待另一个线程调用<code>notify</code>或<code>notifyAll</code>方法才能唤醒。</td>
</tr>
<tr>
<td align="left"><code>TimedWaiting</code></td>
<td align="left">有几个方法有超时参数，调用它们将进入<code>TimedWaiting</code>状态，这一状态将一直保持到超时期满或者接收到唤醒通知。    常用的带有超时参数的方法有**<code>Thread.sleep()</code>、<code>Object.wait()</code>**</td>
</tr>
<tr>
<td align="left"><code>Teminated</code></td>
<td align="left">因<code>run()</code>方法的正常退出而死亡，或者因为没有捕获的异常终止了<code>run()</code>方法而死亡。</td>
</tr>
</tbody></table>
<ul>
<li>  阻塞是不持有锁资源，但可能占用 CPU 资源，比如一个线程一直在以自旋的方式尝试获取锁对象，这时它自身是没有锁对象的，但是使用了CPU资源，这就是一种阻塞的状态。并且阻塞状态到 Runnable 状态是不需要被唤醒的。</li>
<li>  等待则是既不持有锁资源，也不占用 CPU 资源。在 Java 中，等待则是长时间阻塞后的最终结果。比如：当一个线程自旋次数达到一定的阈值后，为了避免线程继续自旋浪费 CPU 资源，就会让线程进入 Waiting 状态，不再使用 CPU 资源。</li>
</ul>
<hr>
<h2 id="4-3-NEW"><a href="#4-3-NEW" class="headerlink" title="4.3    NEW"></a>4.3    NEW</h2><p>处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的 <code>start()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testStateNew</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;&#125;);</span><br><span class="line">    System.out.println(thread.getState()); <span class="comment">// NEW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，只是创建了线程而并没有调用 <code>start()</code> 方法，此时线程处于 NEW 状态。</p>
<h2 id="4-4-RUNNABLE"><a href="#4-4-RUNNABLE" class="headerlink" title="4.4    RUNNABLE"></a>4.4    RUNNABLE</h2><ul>
<li><code>Runnable</code> 是一种可运行的状态。表示线程可以在 Java 虚拟机中运行，但不一定正在运行。处于 RUNNABLE 状态的线程可能在 Java 虚拟机中运行，也有可能在等待 CPU 资源。</li>
<li>多线程的多个线程在没有进行到争夺同一锁对象之前都是<code>Runnable</code>状态，但是一旦涉及到争夺锁对象，就会分为<code>Runnable</code>和<code>Blocked</code>两种状态。</li>
</ul>
<blockquote>
<p>  <strong>Java 中线程的 RUNNABLE 状态：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread 源码里对 RUNNABLE 状态的定义：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Thread state for a runnable thread. A thread in the runnable</span></span><br><span class="line"><span class="comment">* state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">* be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">* such as processor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">翻译：处于Runnable状态下的线程可能正在Java虚拟机中执行，也有可能正在等待来自于操作系统的其它资源，比如处理器。</span><br></pre></td></tr></table></figure>

<p>显然，<strong>Java 线程的 RUNNABLE 状态其实是包括了传统操作系统线程的 ready 和 running 两个状态的</strong>。</p>
<h2 id="4-5-BLOCKED"><a href="#4-5-BLOCKED" class="headerlink" title="4.5    BLOCKED"></a>4.5    BLOCKED</h2><ul>
<li>阻塞状态。<ul>
<li>  处于 BLOCKED 状态的线程正等待锁的释放以进入同步区。</li>
<li>  处于 BLOCKED 状态的线程依然占用 CPU 资源。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>Blocked 线程状态图</strong></p>
</blockquote>
<ul>
<li>  当多个线程协作时，比如线程 A 和线程 B 争夺同一锁对象，如果线程 A 先获取到锁对象，那么线程 A 就进入到<code>Runnable</code>状态，而线程 B 进入到<code>Blocked</code><strong>锁阻塞</strong>状态，注意仅仅是锁阻塞，在自旋状态下线程B还会不停地尝试获取锁对象，直到进入 Waiting 状态后才释放对 CPU 的占用。</li>
</ul>
<p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012170616241.png" alt="image-20201012170616241"></p>
<h2 id="4-6-WAITING"><a href="#4-6-WAITING" class="headerlink" title="4.6    WAITING"></a>4.6    WAITING</h2><ul>
<li>等待状态。<ul>
<li>  处于等待状态的线程变成 RUNNABLE 状态需要通过其它线程唤醒[，而处于 BLOCKED 状态的线程变成 RUNNABLE 状态时不需要通过其它线程唤醒。]</li>
<li>  处于等待状态的线程既不占用 CPU 资源，也不持有锁对象。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>Waiting线程状态图</strong></p>
</blockquote>
<ul>
<li>当多个线程协作时，如果线程 A 在 <code>running</code> 状态下调用了 <strong>Object#wait()</strong> 方法，那么线程 A 就进入了<code>Waiting</code>状态，<strong>同时失去了锁对象（Tip：Thread#sleep() 方法不会释放锁对象）</strong>。<ul>
<li>  如果处于阻塞状态下的线程，在自旋次数达到了一个阈值之后，也会通过 <strong>LockSupport#lock()</strong> 方法进入阻塞状态。</li>
</ul>
</li>
<li>  如果此时线程 B 获取到了同一锁对象，并在 <code>running</code> 状态下调用了 <code>notify()</code> 方法，那么就会将<code>Waiting</code>状态的线程 A 唤醒。<strong>注意仅仅只是唤醒，如果线程 A 被唤醒后获取到了锁对象，那么就进入<code>Runnable</code>状态，如果没有获取到锁对象，则进入<code>Blocked</code>状态。</strong></li>
</ul>
<img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012171420707.png" alt="image-20201012171420707" style="zoom:80%;">



<h3 id="调用以下-3-个方法会使线程进入等待状态："><a href="#调用以下-3-个方法会使线程进入等待状态：" class="headerlink" title="调用以下 3 个方法会使线程进入等待状态："></a>调用以下 3 个方法会使线程进入等待状态：</h3><ul>
<li>  **Object.wait()**：使当前线程立即进入等待状态，直到另一个线程唤醒它；</li>
<li>  **Thread.join()**：是当前线程进入等待状态，直到调用 join 方法的线程中的任务执行完毕，底层调用的是 Object 实例的 wait 方法；</li>
<li>  **LockSupport.park()**：除非获得调用许可，否则禁用当前线程进行线程调度。</li>
</ul>
<blockquote>
<p>  <strong>Object.wait()</strong></p>
</blockquote>
<ul>
<li>  调用 <code>wait()</code> 方法前线程必须持有对象的锁。</li>
<li>  线程调用 <code>wait()</code> 方法时，会释放当前的锁，直到有其他线程调用 <code>notify()/notifyAll()</code> 方法唤醒等待锁的线程。</li>
<li>  <strong>需要注意的是，其他线程调用 <code>notify()</code> 方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用 <code>wait()</code> 方法的线程。</strong></li>
<li>  <strong>同样，调用 <code>notifyAll()</code> 方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</strong></li>
</ul>
<blockquote>
<p>  <strong>Thread.join()</strong></p>
</blockquote>
<ul>
<li>  调用 <code>join()</code> 方法不会立即释放锁，会一直等待当前线程执行完毕（转换为 TERMINATED 状态）。</li>
<li>  举例说明：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockedTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        testMethod();</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        testMethod();</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.start();</span><br><span class="line">    a.join();</span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">&quot;:&quot;</span> + a.getState()); </span><br><span class="line">    System.out.println(b.getName() + <span class="string">&quot;:&quot;</span> + b.getState()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法争夺锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  要是没有调用 <code>join()</code> 方法，main 线程不管 a 线程是否执行完毕都会继续往下走。</li>
<li>  a 线程启动之后马上调用了 <code>join()</code> 方法，这时 main 线程就会等到 a 线程执行完毕才能继续向下执行，所以这里 a 线程打印的状态固定是TERMIATED。</li>
<li>  至于 b 线程的状态，有可能打印 RUNNABLE（尚未进入同步方法），也有可能打印 TIMED_WAITING（进入了同步方法）。</li>
</ul>
<hr>
<h2 id="4-7-TIMED-WAITING"><a href="#4-7-TIMED-WAITING" class="headerlink" title="4.7    TIMED_WAITING"></a>4.7    TIMED_WAITING</h2><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<ul>
<li>进入<code>TimedWaiting</code>状态的一种方法是调用<code>Thread.sleep()</code>方法，单线程也可以调用。</li>
<li>为了让其它线程也有机会执行，可以将<code>Thread.sleep()</code>的调用放入线程执行体<code>run()</code>之内，这样才能保证该线程执行过程中会睡眠。[睡眠是在线程已经执行了一部分的情况下进入的，我们一般会把<code>sleep()</code>方法写在线程执行体的前面几行代码中，使当前线程进入睡眠]</li>
<li><code>sleep()</code>中指定的时间是线程不会运行的最短时间。因为 <code>sleep()</code> 方法在休眠时不会释放锁对象，所以该线程睡眠时间到期后没有重新争夺锁的过程，而是会直接进入<code>Runnable</code>状态。</li>
</ul>
<blockquote>
<p>  <strong>TimeWaiting 线程状态图</strong></p>
</blockquote>
<img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012165955497.png" alt="image-20201012165955497" style="zoom:80%;">



<h3 id="调用如下方法会使线程进入超时等待状态："><a href="#调用如下方法会使线程进入超时等待状态：" class="headerlink" title="调用如下方法会使线程进入超时等待状态："></a>调用如下方法会使线程进入超时等待状态：</h3><blockquote>
<ul>
<li>  <strong>Thread.sleep(long millis)</strong></li>
<li>  <strong>Object.wait(long timeout)</strong></li>
<li>  <strong>Thread.join(long millis)</strong></li>
<li>  <strong>LockSupport.parkNanos(long nanos)</strong></li>
<li>  <strong>LockSupport.parkUntil(long deadline)</strong></li>
</ul>
</blockquote>
<blockquote>
<p>  <strong>Thread.sleep(long millis)</strong></p>
</blockquote>
<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入 RUNNABLE 状态。</p>
<blockquote>
<p>  <strong>Object.wait(long timeout)</strong></p>
</blockquote>
<p>线程休眠指定时间，等待期间可以通过 <code>notify()/notifyAll()</code> 唤醒，被唤醒后重新拥有争夺锁的资格。</p>
<blockquote>
<p>  <strong>Thread.join(long millis)</strong></p>
</blockquote>
<p>使当前线程执行指定时间，如果 millis 为 0，则会一直执行。</p>
<ul>
<li>  修改一下刚才的示例:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockedTest</span><span class="params">()</span> &#123;</span><br><span class="line">    ······</span><br><span class="line">    a.start();</span><br><span class="line">    a.join(<span class="number">1000L</span>);</span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">&quot;:&quot;</span> + a.getState()); <span class="comment">// 输出 TIEMD_WAITING</span></span><br><span class="line">    System.out.println(b.getName() + <span class="string">&quot;:&quot;</span> + b.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  这里调用 <code>a.join(1000L)</code>，因为是指定了具体 a 线程执行的时间的，并且执行时间是小于 a 线程 sleep 的时间，所以 a 线程状态输出为 TIMED_WAITING。</li>
<li>  b 线程状态仍然不固定（RUNNABLE或BLOCKED）。</li>
</ul>
<hr>
<h2 id="4-8-TERMINATED"><a href="#4-8-TERMINATED" class="headerlink" title="4.8    TERMINATED"></a>4.8    TERMINATED</h2><p>终⽌状态。此时线程已执行完毕。</p>
<hr>
<h2 id="4-9-线程中断"><a href="#4-9-线程中断" class="headerlink" title="4.9    线程中断"></a>4.9    线程中断</h2><ul>
<li>  在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。</li>
<li>  目前在 Java 中还没有安全直接的方法来停止线程，但是 Java 提供了线程中断机制来处理需要中断线程的情况。</li>
<li>  线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。</li>
</ul>
<blockquote>
<p>  Thread 类中提供了几个关于线程中断的方法：</p>
</blockquote>
<ul>
<li>  **Thread.interrupt()**：中断线程。这里的中断线程并不会立即停止线程，⽽是设置线程的中断状态为 true（默认是flase）；</li>
<li>  **Thread.interrupted()**：测试当前线程是否被中断。线程的中断状态受这个方法的影响，调用一次会使线程中断状态设置为 true，连续调用两次会使得这个线程的中断状态重新转为 false；</li>
<li>  **Thread.isInterrupted()**：测试当前线程是否被中断。与上面放法不同的是调用这个方法并不会影响线程的中断状态。</li>
</ul>
<blockquote>
<p>  <strong>Tip：</strong></p>
</blockquote>
<p>在线程中断机制中，当其他线程通知需要被中断的线程后，线程中断的状态被设置为 true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己决定，可以在合适的实际处理中断请求，也可以完全不处理继续执行下去。</p>
<hr>
<h1 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5    线程安全"></a>5    线程安全</h1><h2 id="5-1-线程安全"><a href="#5-1-线程安全" class="headerlink" title="5.1    线程安全"></a>5.1    线程安全</h2><ul>
<li>  如果有多个线程在同时运行，而且这些线程可能会同时运行某段代码。<strong>如果多线程程序每次运行这段代码的结果和单线程运行的结果是一样的，而且其他变量的值也和预期的是一样的，就说线程是安全的。</strong></li>
<li>  <strong>线程安全问题都是由全局变量和静态变量引起的</strong>。    <em>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的</em>。    若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li>
</ul>
<h2 id="5-2-案例演示"><a href="#5-2-案例演示" class="headerlink" title="5.2    案例演示"></a>5.2    案例演示</h2><blockquote>
<p>  电影院卖票，假设共有100张票，多个窗口同时卖票。</p>
</blockquote>
<ol>
<li><p><code>Runnable</code>的实现类<code>RunnableImpl</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 模拟出票时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> tickets--;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;正在卖：&quot;</span>+now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>测试类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.总共有100张票</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.三个窗口同时卖票</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">win1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">win2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">win3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        win1.start();</span><br><span class="line">        win2.start();</span><br><span class="line">        win3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Thread[窗口1,5,main]正在卖：100</span></span><br><span class="line"><span class="comment">    Thread[窗口2,5,main]正在卖：99</span></span><br><span class="line"><span class="comment">    Thread[窗口3,5,main]正在卖：99</span></span><br><span class="line"><span class="comment">    Thread[窗口1,5,main]正在卖：98</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">    线程不安全</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-3-线程同步"><a href="#5-3-线程同步" class="headerlink" title="5.3    线程同步"></a>5.3    线程同步</h2><ul>
<li><p>  当我们使用多个线程访问同一资源，且存在多个线程对资源有写的操作时，就可能会出现线程安全问题。</p>
</li>
<li><p>要解决上述多线程的并发访问一个资源的安全性问题：也就是解决重复票与不存在票的问题，Java提供了<strong>同步机制（synchronize）</strong>来解决。</p>
<blockquote>
<ol>
<li> 窗口1线程执行卖票操作的时候，窗口2和窗口3线程只能在外面等着。 </li>
<li> 窗口1操作结束，窗口1、窗口2、和窗口3才有机会进入代码去执行卖票操作。</li>
<li> 也就是说某个线程在修改共享资源的时候，其它线程不能修改该资源，等待修改完毕资源同步之后，才能去抢夺 CPU 资源，完成对应的操作，保证了数据的同步性。解决了线程的不安全问题。</li>
</ol>
</blockquote>
</li>
<li><p>如何完成同步操作？3种方式</p>
<ol>
<li> <strong>同步代码块</strong></li>
<li> <strong>同步方法</strong></li>
<li> <strong>锁机制</strong></li>
</ol>
</li>
</ul>
<h2 id="5-3-同步代码块"><a href="#5-3-同步代码块" class="headerlink" title="5.3    同步代码块"></a>5.3    同步代码块</h2><ul>
<li><p>  <strong>同步代码块</strong>：<code>synchronized</code>关键字可以用于<code>run()</code>方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p>
</li>
<li><p>格式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    需要同步操作的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>同步锁</strong>：同步锁对象只是一个概念，可以想象为在对象上标记了一把锁。</p>
<ol>
<li> 锁对象，可以是任意类型。</li>
<li> 多个线程对象，要使用同一把锁<code>（--&gt;&gt;单例）可以是static或final修饰的对象</code>。</li>
<li> 在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其它线程只能在外面等着。<code>（--&gt;&gt;BLOCKED）</code></li>
</ol>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int tickets = 100;</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">            while (tickets&gt;0)&#123;</span><br><span class="line">                // 模拟出票时间</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    tickets--;</span><br><span class="line">                    System.out.println(Thread.currentThread()+&quot;正在卖：&quot;+tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    使用了同步代码块后，上述的线程安全问题就解决了。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>





<h2 id="5-4-同步方法"><a href="#5-4-同步方法" class="headerlink" title="5.4    同步方法"></a>5.4    同步方法</h2><ul>
<li><p>  同步方法：使用<code>synchronized</code>修饰的方法，就叫做同步方法，保证A线程执行该方法的时候，其它线程只能在方法外等着。</p>
</li>
<li><p>格式：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method()&#123;</span><br><span class="line">    // 可能会产生线程安全的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int tickets = 100;</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            sellTickets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     public synchronized void sellTickets()&#123;</span><br><span class="line">            if (tickets&gt;0)&#123;</span><br><span class="line">                // 模拟出票时间</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    tickets--;</span><br><span class="line">                    System.out.println(Thread.currentThread()+&quot;正在卖：&quot;+tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <em>同步方法中，隐藏了同步锁对象。如果同步方法是一个非静态方法，那么它的同步锁对象就是<code>this</code>对象；若果同步方法是静态方法，同步锁对象就是当前方法所在类的字节码对象。</em></p>
<h3 id="4-2-3、Lock锁（同步锁）"><a href="#4-2-3、Lock锁（同步锁）" class="headerlink" title="4.2.3、Lock锁（同步锁）"></a>4.2.3、Lock锁（同步锁）</h3><h4 id="Lock类介绍"><a href="#Lock类介绍" class="headerlink" title="Lock类介绍"></a>Lock类介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.Lock;</span><br><span class="line">public interface Lock;</span><br><span class="line">// 常用的实现类</span><br><span class="line">ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock </span><br></pre></td></tr></table></figure>

<p>​    <code>Lock接口</code>提供了比使用 <code>synchronized</code> 方法和代码块更广泛的锁定操作，同步代码块/同步方法具有的功能<code>Lock</code>都由，而且更加强大，更体现面向对象。</p>
<h4 id="Lock接口中常用的方法"><a href="#Lock接口中常用的方法" class="headerlink" title="Lock接口中常用的方法"></a>Lock接口中常用的方法</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public void lock()</code></td>
<td align="center">加同步锁</td>
</tr>
<tr>
<td align="center"><code>public void unlock()</code></td>
<td align="center">释放同步锁</td>
</tr>
</tbody></table>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 模拟出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    tickets--;</span><br><span class="line">                    System.out.println(Thread.currentThread()+<span class="string">&quot;正在卖：&quot;</span>+tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="6-线程间通信（等待-唤醒机制）"><a href="#6-线程间通信（等待-唤醒机制）" class="headerlink" title="6    线程间通信（等待/唤醒机制）"></a>6    线程间通信（等待/唤醒机制）</h1><h2 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1    概念"></a>6.1    概念</h2><blockquote>
<p>  <strong>什么是线程同步？</strong></p>
</blockquote>
<p>线程同步是线程之间按照<strong>一定的顺序</strong>执行。</p>
<blockquote>
<p>  <strong>为什么要处理线程间通信？</strong></p>
</blockquote>
<p>多个线程并发执行时，默认情况下 CPU 是随机切换线程的。当我们需要多个线程来共同完成一件任务，并且<strong>希望这些线程能有规律的执行</strong>，那么多个线程之间就需要进行通信来协调任务，以此来帮助我们达到多线程共同操作一份数据。</p>
<ul>
<li>  比如，线程A是生产包子的线程，线程B是消耗包子的线程，那么我们希望线程A每生产100个包子就通知线程B开始吃包子，线程B吃完包子后就通知线程A再开始生产包子，这时我们就必须通过线程通信来达到这一目的。    对于线程A，设置一个阀值，当包子数量达到阀值后线程A进入睡眠状态；此时线程B开始吃包子，当包子数量为0时线程B进入睡眠状态，并唤醒线程A让线程A继续生产包子。</li>
<li>  再比如，线程 A 和 B 的任务都是打印 1~100 之间的整数，但是要求线程 A 全部打印完毕后线程 B 才能开始打印，这也需要线程间通信来进行协调。</li>
</ul>
<blockquote>
<p>  <strong>如何保证线程间通信能有效利用资源？</strong></p>
</blockquote>
<ul>
<li>  多个线程在处理同一资源，并且任务不相同时，需要通过线程通信来帮助解决多个线程操作同一变量可能引发的冲突。</li>
<li>  如果是简单的基于“锁”的方式，在线程 A 持有锁对象，线程 B 进入阻塞而没有进入休眠，会不断地尝试去获取锁，这很消耗服务器资源；</li>
<li>  所以，我们一般采用的手段是——<strong>等待/唤醒机制</strong>。</li>
</ul>
<hr>
<h2 id="6-2-wait-notify-机制"><a href="#6-2-wait-notify-机制" class="headerlink" title="6.2    wait/notify 机制"></a>6.2    wait/notify 机制</h2><p>Java 多线程的 <strong>等待/通知机制</strong> 是基于 Object 类的 <code>wait()</code> 方法和 <code>notify()</code>、<code>notifyAll()</code> 方法来实现的。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Object#wait()</strong></td>
<td align="left">让当前线程进入等待队列中，<strong>并释放当前持有的锁对象</strong></td>
</tr>
<tr>
<td align="left"><strong>Object#notify()</strong></td>
<td align="left">随机唤醒等待队列中的一个线程，让其重新进入到调度队列中</td>
</tr>
<tr>
<td align="left"><strong>Object#notifyAll()</strong></td>
<td align="left">唤醒等待队列中的全部线程</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>调用wait()和notify()方法需要注意的细节</strong></p>
</blockquote>
<ol>
<li><code>wait()</code>和<code>notify()</code>方法必须要由同一个对象（即锁对象）调用。只有锁对象的<code>notify()</code>方法才能唤醒由该锁对象调用<code>wait()</code>方法后挂起的线程。</li>
<li><code>wait()</code>和<code>notify()</code>方法是属于<code>Object</code>类的方法。因此，锁对象可以是任意对象。</li>
<li><code>wait()</code>和<code>notify()</code>方法必须要在同步代码块或同步函数中使用。因为，必须通过锁对象调用这2个方法。</li>
</ol>
<h2 id="6-3-代码演示"><a href="#6-3-代码演示" class="headerlink" title="6.3    代码演示"></a>6.3    代码演示</h2><ul>
<li><p>  假如线程A现在持有了一个锁 lock 并开始执行，它可以使用 <code>lock.wait()</code> 让自己进入等待状态。这个时候， lock 这个锁是被释放了的。</p>
</li>
<li><p>这时，线程B获得了 lock 这个锁并开始执行，它可以在某一时刻，使用 <code>lock.notify()</code> ，通知之前持有 lock 锁并进入等待状态的线程A，说“线程A你不用等了，可以往下执行了”。</p>
<blockquote>
<p>  <strong>需要注意的是，这个时候线程B并没有释放锁 lock ，除非线程B这个时候使用 <code>lock.wait()</code> 释放锁，或者线程B执行结束自行释放锁，线程A才能得到 lock 锁。</strong></p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitAndNotify</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadA: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadB: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadA</span>()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadB</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">ThreadA: <span class="number">0</span></span><br><span class="line">ThreadB: <span class="number">0</span></span><br><span class="line">ThreadA: <span class="number">1</span></span><br><span class="line">ThreadB: <span class="number">1</span></span><br><span class="line">ThreadA: <span class="number">2</span></span><br><span class="line">ThreadB: <span class="number">2</span></span><br><span class="line">ThreadA: <span class="number">3</span></span><br><span class="line">ThreadB: <span class="number">3</span></span><br><span class="line">ThreadA: <span class="number">4</span></span><br><span class="line">ThreadB: <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>​    </p>
<hr>
<h1 id="7-Java内存模型（JMM）"><a href="#7-Java内存模型（JMM）" class="headerlink" title="7    Java内存模型（JMM）"></a>7    Java内存模型（JMM）</h1><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/08/JMM/">超链接：JMM</a></li>
</ul>
<hr>
<h1 id="8-线程池"><a href="#8-线程池" class="headerlink" title="8    线程池"></a>8    线程池</h1><p><a href>超链接</a></p>
<h2 id="7-1、概念"><a href="#7-1、概念" class="headerlink" title="7.1、概念"></a>7.1、概念</h2><ul>
<li><strong>线程池：</strong>一个可以容纳多个线程对象的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程对象而消耗过多的资源。</li>
</ul>
<h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ol>
<li><p>降低资源消耗。</p>
<p>​    减少了创建和销毁线程的次数，每个线程都可以被反复利用。</p>
</li>
<li><p>提高响应速度。</p>
<p>​    当任务到达时，任务可以不需要等待线程的创建就能立即执行。[直接从线程池中调用线程对象]</p>
</li>
<li><p>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线程的数据，防止因为消耗过多的内存而导致服务器奔溃。(每个线程大约需要1MB的内存，线程开的越多，消耗的内存也就越大，最后死机)</p>
<p><em>线程池会事先设置好该池内会有多少个线程，假设某一时刻线程池中的线程全部处于运行状态，这时如果还有新的任务需要申请新的线程，该任务不会创建新的线程，而是进入等待状态，直到线程池中的某个线程处于空闲状态，再调用该线程去执行任务。</em></p>
</li>
</ol>
<h2 id="7-2、线程池的使用"><a href="#7-2、线程池的使用" class="headerlink" title="7.2、线程池的使用"></a>7.2、线程池的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executor;	<span class="comment">// 线程池的顶级接口</span></span><br><span class="line">java.util.concurrent.ExecutorService；	<span class="comment">// 真正的线程池接口</span></span><br><span class="line">java.util.concurrent.Executors	<span class="comment">// 线程工厂类，提供了一些静态方法用于生成常用的线程池</span></span><br></pre></td></tr></table></figure>

<p>Java中线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而是一个线程池执行工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，因此官方提供了一个工具类<code>java.util.concurrent.Executors</code>线程工厂类，里面提供了一些静态工厂，生成一些常用的线程池。</p>
<ul>
<li><p><strong>Executors类中创建线程池的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个可重用的固定线程数的线程池对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>线程池对象ExecutorService中的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取线程池中某一个线程对象，并执行</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task)</span><br><span class="line">    <span class="comment">// Future接口：用来记录线程任务执行完毕后产生的结果。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用线程池对象的步骤"><a href="#使用线程池对象的步骤" class="headerlink" title="使用线程池对象的步骤"></a>使用线程池对象的步骤</h3><ol>
<li>创建线程池对象；</li>
<li>创建Runnable接口的子类对象。(task)</li>
<li>提交Runnable接口子类对象。</li>
<li>关闭线程池。(一般不做)</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/" rel="prev" title="MySQL基础">
                  <i class="fa fa-chevron-left"></i> MySQL基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/" rel="next" title="IO流">
                  IO流 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
