<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Redis 是一款高性能的 NOSQL 非关系型数据库。 Redis 是用 C 语言开发的一个开源的高性能键值对 &lt;K, V&gt; 内存数据库！ 比 SQL 数据库具有更快的读写速度和高并发处理能力！   下载安装 官网 官方中文网   Windows   下载得到一个压缩文件，解压直接可以使用。文件中包含：  redis.windows.conf：配置文件 redis-cli.exe">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2020/11/21/Redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis 是一款高性能的 NOSQL 非关系型数据库。 Redis 是用 C 语言开发的一个开源的高性能键值对 &lt;K, V&gt; 内存数据库！ 比 SQL 数据库具有更快的读写速度和高并发处理能力！   下载安装 官网 官方中文网   Windows   下载得到一个压缩文件，解压直接可以使用。文件中包含：  redis.windows.conf：配置文件 redis-cli.exe">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210809100102082.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210809100735411.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210809101749283.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210809102642290.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210809175349825.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/watch.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810151248584.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810151819939.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810151900331.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810151913759.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810152048413.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810152122261.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810152243500.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810152453011.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810152631660.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810153112350.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810153916067.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810153935273.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810154249590.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810155315761.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810160117746.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810160314929.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810160420195.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810160748119.png">
<meta property="og:image" content="http://example.com/2020/11/21/Redis/image-20210810161028961.png">
<meta property="article:published_time" content="2020-11-21T11:03:59.000Z">
<meta property="article:modified_time" content="2022-02-22T08:31:36.066Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/11/21/Redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="http://example.com/2020/11/21/Redis/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2020/11/21/Redis/","path":"2020/11/21/Redis/","title":"Redis"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85"><span class="nav-number">1.</span> <span class="nav-text">下载安装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%BC%80%E6%BA%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7"><span class="nav-number">2.</span> <span class="nav-text">Redis开源客户端工具</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">Redis中的数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">4.</span> <span class="nav-text">Redis 常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%88String%EF%BC%89"><span class="nav-number">4.0.1.</span> <span class="nav-text">3.1    字符串类型（String）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B%EF%BC%88Hash%EF%BC%89"><span class="nav-number">4.0.2.</span> <span class="nav-text">3.2    哈希类型（Hash）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%EF%BC%88List%EF%BC%89"><span class="nav-number">4.0.3.</span> <span class="nav-text">3.3    列表类型（List）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88Set%EF%BC%89"><span class="nav-number">4.0.4.</span> <span class="nav-text">3.4    集合类型（Set）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88SortedSet%EF%BC%89"><span class="nav-number">4.0.5.</span> <span class="nav-text">3.5    有序集合类型（SortedSet）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">4.0.6.</span> <span class="nav-text">3.6    通用命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">持久化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RDB"><span class="nav-number">5.1.</span> <span class="nav-text">1    RDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-AOF"><span class="nav-number">5.2.</span> <span class="nav-text">2    AOF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">3    如何选择合适的持久化方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Redis-%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.</span> <span class="nav-text">5    Redis 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8"><span class="nav-number">6.2.</span> <span class="nav-text">怎么用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">6.2.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Case1%EF%BC%9A%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C"><span class="nav-number">6.2.2.</span> <span class="nav-text">Case1：正常执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Case2%EF%BC%9A%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.2.3.</span> <span class="nav-text">Case2：放弃事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Case3%EF%BC%9A%E5%85%A8%E4%BD%93%E8%BF%9E%E5%9D%90"><span class="nav-number">6.2.4.</span> <span class="nav-text">Case3：全体连坐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Case4%EF%BC%9A%E5%86%A4%E5%A4%B4%E5%80%BA%E4%B8%BB"><span class="nav-number">6.2.5.</span> <span class="nav-text">Case4：冤头债主</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Case5%EF%BC%9Awatch-%E7%9B%91%E6%8E%A7"><span class="nav-number">6.2.6.</span> <span class="nav-text">Case5：watch 监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Case6%EF%BC%9Aunwatch-%E5%8F%96%E6%B6%88%E7%9B%91%E6%8E%A7"><span class="nav-number">6.2.7.</span> <span class="nav-text">Case6：unwatch 取消监控</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.</span> <span class="nav-text">事务冲突问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-CAS"><span class="nav-number">6.3.1.</span> <span class="nav-text">乐观锁 + CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">6.3.2.</span> <span class="nav-text">悲观锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">6.4.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5"><span class="nav-number">6.4.1.</span> <span class="nav-text">三阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%89%B9%E6%80%A7"><span class="nav-number">6.4.2.</span> <span class="nav-text">三特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Redis-%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="nav-number">7.</span> <span class="nav-text">6    Redis 的发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="nav-number">7.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-number">7.2.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">7.3.</span> <span class="nav-text">案例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%88Master-Slave%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">7    Redis 主从复制（Master&#x2F;Slave）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="nav-number">8.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">8.2.</span> <span class="nav-text">有什么用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%89"><span class="nav-number">8.3.</span> <span class="nav-text">怎么用（主从复制）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%86%E8%8A%82"><span class="nav-number">8.3.1.</span> <span class="nav-text">修改配置文件细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%93%8D"><span class="nav-number">8.3.2.</span> <span class="nav-text">实操</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">1、修改配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%90%AF%E5%8A%A8%E4%B8%89%E5%8F%B0redis%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">2、启动三台redis服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%9F%A5%E7%9C%8B%E4%B8%89%E5%8F%B0%E4%B8%BB%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><span class="nav-number">8.3.2.3.</span> <span class="nav-text">3、查看三台主机运行情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E9%85%8D%E4%BB%8E-%E5%BA%93-%E4%B8%8D%E9%85%8D%E4%B8%BB-%E5%BA%93"><span class="nav-number">8.3.2.4.</span> <span class="nav-text">4、配从(库)不配主(库)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A83%E6%8B%9B%EF%BC%88%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AD%96%E7%95%A5%EF%BC%89"><span class="nav-number">8.4.</span> <span class="nav-text">常用3招（常用的配置策略）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%86"><span class="nav-number">8.4.1.</span> <span class="nav-text">一主二仆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="nav-number">8.4.2.</span> <span class="nav-text">薪火相传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="nav-number">8.4.3.</span> <span class="nav-text">反客为主</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">8.5.</span> <span class="nav-text">复制原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88sentinel%EF%BC%89"><span class="nav-number">8.6.</span> <span class="nav-text">哨兵模式（sentinel）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="nav-number">8.6.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-1"><span class="nav-number">8.6.2.</span> <span class="nav-text">怎么用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">8.7.</span> <span class="nav-text">复制的缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%BC%93%E5%AD%98"><span class="nav-number">9.</span> <span class="nav-text">Redis 缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis-%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">9.1.</span> <span class="nav-text">1    Redis 过期键的删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-number">9.1.1.</span> <span class="nav-text">1.1    惰性删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-number">9.1.2.</span> <span class="nav-text">1.2    定期删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4"><span class="nav-number">9.1.3.</span> <span class="nav-text">1.3    定时删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">9.2.</span> <span class="nav-text">2    Redis 内存淘汰策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Redis%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">10.</span> <span class="nav-text">8    Redis的应用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Jedis"><span class="nav-number">11.</span> <span class="nav-text">Jedis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Jedis-%E5%85%A5%E9%97%A8"><span class="nav-number">11.1.</span> <span class="nav-text">1    Jedis 入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Jedis-%E6%93%8D%E4%BD%9C-Redis-%E5%B8%B8%E7%94%A8%E7%9A%84-API"><span class="nav-number">11.2.</span> <span class="nav-text">2    Jedis 操作 Redis 常用的 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%88String%EF%BC%89"><span class="nav-number">11.2.1.</span> <span class="nav-text">2.1    字符串类型（String）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B%EF%BC%88Hash%EF%BC%89"><span class="nav-number">11.2.2.</span> <span class="nav-text">2.2    哈希类型（Hash）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%EF%BC%88List%EF%BC%89"><span class="nav-number">11.2.3.</span> <span class="nav-text">2.3    列表类型（List）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88Set%EF%BC%89"><span class="nav-number">11.2.4.</span> <span class="nav-text">2.4    集合类型（Set）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88SortedSet%EF%BC%89"><span class="nav-number">11.2.5.</span> <span class="nav-text">2.5    有序集合类型（SortedSet）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Jedis-%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">11.3.</span> <span class="nav-text">3    Jedis 连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.3.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">11.3.2.</span> <span class="nav-text">代码优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">11.3.3.</span> <span class="nav-text">Redis中常见的配置信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="nav-number">12.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringBoot-%E6%95%B4%E5%90%88-Redis"><span class="nav-number">13.</span> <span class="nav-text">SpringBoot 整合 Redis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E4%BC%A0%E7%BB%9F%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%90%BD%E5%9C%B0%E5%BA%94%E7%94%A8"><span class="nav-number">14.1.</span> <span class="nav-text">Redis 传统五大数据类型的落地应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9FRedis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">14.2.</span> <span class="nav-text">分布式锁？Redis 分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">14.3.</span> <span class="nav-text">Redis 缓存过期淘汰策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%9A%84-LRU-%E7%AE%97%E6%B3%95"><span class="nav-number">14.4.</span> <span class="nav-text">Redis 的 LRU 算法</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-21 19:03:59" itemprop="dateCreated datePublished" datetime="2020-11-21T19:03:59+08:00">2020-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-22 16:31:36" itemprop="dateModified" datetime="2022-02-22T16:31:36+08:00">2022-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<ul>
<li>Redis 是一款高性能的 NOSQL 非关系型数据库。</li>
<li>Redis 是用 C 语言开发的一个开源的高性能键值对 <code>&lt;K, V&gt;</code> 内存数据库！</li>
<li><strong>比 SQL 数据库具有更快的读写速度和高并发处理能力！</strong></li>
</ul>
</blockquote>
<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">官网</a></li>
<li><a target="_blank" rel="noopener" href="http://www.redis.net.cn/">官方中文网</a></li>
</ul>
<blockquote>
<p>Windows </p>
</blockquote>
<p>下载得到一个压缩文件，解压直接可以使用。文件中包含：</p>
<ul>
<li><code>redis.windows.conf</code>：配置文件</li>
<li><code>redis-cli.exe</code>：redis的客户端</li>
<li><code>redis-server.exe</code>：redis服务器端</li>
<li>……</li>
</ul>
<blockquote>
<p>Linux</p>
</blockquote>
<p>直接使用宝塔面板安装即可！</p>
<blockquote>
<p><strong>Redis服务器端的默认端口号是：6379</strong></p>
</blockquote>
<h1 id="Redis开源客户端工具"><a href="#Redis开源客户端工具" class="headerlink" title="Redis开源客户端工具"></a>Redis开源客户端工具</h1><p><strong>QuickRedis 下载地址：</strong></p>
<blockquote>
<ul>
<li>  Github：<a target="_blank" rel="noopener" href="https://github.com/quick123official/quick_redis_blog/releases">https://github.com/quick123official/quick_redis_blog/releases</a></li>
<li>  Gitee：<a target="_blank" rel="noopener" href="https://gitee.com/quick123official/quick_redis_blog/releases">https://gitee.com/quick123official/quick_redis_blog/releases</a></li>
</ul>
</blockquote>
<p><strong>Another Redis Desktop Manager 下载地址：</strong></p>
<blockquote>
<ul>
<li>  Github：<a target="_blank" rel="noopener" href="https://github.com/qishibo/AnotherRedisDesktopManager/releases">https://github.com/qishibo/AnotherRedisDesktopManager/releases</a></li>
<li>  Gitee：<a target="_blank" rel="noopener" href="https://gitee.com/qishibo/AnotherRedisDesktopManager/releases">https://gitee.com/qishibo/AnotherRedisDesktopManager/releases</a></li>
</ul>
</blockquote>
<h1 id="Redis中的数据类型"><a href="#Redis中的数据类型" class="headerlink" title="Redis中的数据类型"></a>Redis中的数据类型</h1><p>Redis在内存中以键值对的形式存储数据。其中所有<code>键（key）</code>都是String类型，而<code>值（value）</code>有 <strong>5 种不同的数据类型</strong>，我们常说的 Redis 的数据类型其实是指 Redis 键值对中<code>值（value）</code>的数据类型。</p>
<blockquote>
<ol>
<li>字符串类型 <code>String</code></li>
<li>哈希类型 <code>hash</code> ： Map格式</li>
<li>列表类型 <code>list</code> ： LinkedList格式，支持重复元素</li>
<li>集合类型 <code>set</code> ： LinkedList格式，不允许重复元素</li>
<li>有序集合类型 <code>sortedset</code> ： LinkedList格式，不允许重复元素，且元素有序。</li>
</ol>
</blockquote>
<p><img src="/2020/11/21/Redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p>
<h1 id="Redis-常用命令"><a href="#Redis-常用命令" class="headerlink" title="Redis 常用命令"></a>Redis 常用命令</h1><blockquote>
<p>  <strong>备注</strong></p>
</blockquote>
<ul>
<li>  Redis 的命令是不区分大小写的，而 key 是区分大小写的。</li>
</ul>
<h3 id="3-1-字符串类型（String）"><a href="#3-1-字符串类型（String）" class="headerlink" title="3.1    字符串类型（String）"></a>3.1    字符串类型（String）</h3><ol>
<li><p>存储：<code>set key value</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set name zhangsan</span><br><span class="line"># 多次为同一个key赋值会覆盖之前的值</span><br><span class="line"></span><br><span class="line"># 一次设置多个值[m；more]</span><br><span class="line">mset k1 v1 k2 v2 k3 v3</span><br></pre></td></tr></table></figure></li>
<li><p>获取：<code>get key</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> name</span><br><span class="line"></span><br><span class="line"># 一次获取多个值</span><br><span class="line">mget k1 k2 k3</span><br></pre></td></tr></table></figure></li>
<li><p>删除：<code>del key</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-2-哈希类型（Hash）"><a href="#3-2-哈希类型（Hash）" class="headerlink" title="3.2    哈希类型（Hash）"></a>3.2    哈希类型（Hash）</h3><ol>
<li><p>存储：<code>hset key field value</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hset person name zhangsan</span><br><span class="line">hset person age <span class="number">23</span></span><br><span class="line"><span class="comment">-- 等价于 </span></span><br><span class="line">hset person name zhangsan age <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在添加 Hash 类型数据时，HashMap 中可以只有一个键值对，也可以包含多个键值对</span></span><br><span class="line"><span class="comment">-- 如果 HashMap 中只包含一个键值对，且多次添加 HashMap ，这时 Redis 会先判断 HashMap 中 key 的值，如果key不同，即为追加操作；如果key相同，会直接报错</span></span><br><span class="line"><span class="comment">-- 添加的 HashMap 中可以包含多个键值对，只要 key 不同，也是符合 Redis 的语法规则的！</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取：</p>
<ul>
<li>获取 Hash 中指定 key 的值：<code>hget key hashKey</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hget person name</span><br><span class="line">hget person age</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 Hash 中的所有键值对：<code>hgetall key</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall person</span><br></pre></td></tr></table></figure></li>
<li><p>删除：<code>hdel key hashKey</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel person name</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-3-列表类型（List）"><a href="#3-3-列表类型（List）" class="headerlink" title="3.3    列表类型（List）"></a>3.3    列表类型（List）</h3><ol>
<li><p>添加：可以添加一个元素到列表的头部（左边）或尾部（右边）</p>
<ul>
<li><code>lpush key value</code>：将元素加入列表左边</li>
<li><code>rpush key value</code>：将元素加入列表右边</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lpush mylist a</span><br><span class="line">lpush mylist b</span><br><span class="line">lpush mylist c</span><br><span class="line"></span><br><span class="line">rpush mylist a</span><br><span class="line">rpush mylist b</span><br><span class="line">rpush mylist c</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最终得到的列表是： [c b a   a b c]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>List和String的区别是：当key相同时存储元素，String类型是覆盖，而List是追加</strong></p>
</blockquote>
</li>
<li><p>获取：<code>lrange key start end</code>，根据范围获取。<code>0 -1</code>表示获取全部元素。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange mylist <span class="number">0</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>下标从 0 开始取，左右都是闭区间，也就是说 <code>lrange mylist 0 0</code> 也能取到第一个元素</strong></li>
<li><strong>没有<code>rrange</code>这个命令</strong></li>
</ul>
</blockquote>
</li>
<li><p>删除：</p>
<ul>
<li><code>lpop key</code>：删除列表最左边的元素，并将元素返回</li>
<li><code>rpop key</code>：删除列表最右边的元素，并将元素返回</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop mylist</span><br><span class="line">rpop mylist</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-4-集合类型（Set）"><a href="#3-4-集合类型（Set）" class="headerlink" title="3.4    集合类型（Set）"></a>3.4    集合类型（Set）</h3><blockquote>
<p>不允许重复元素</p>
</blockquote>
<ol>
<li><p>存储：<code>sadd key value</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd myset a</span><br><span class="line">sadd myset a</span><br><span class="line">sadd myset b</span><br><span class="line"></span><br><span class="line"><span class="comment">-- set集合中的有效元素只有2个。[a b]</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取集合中的所有元素：<code>smembers key</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers myset</span><br></pre></td></tr></table></figure></li>
<li><p>删除集合中的某个元素：<code>srem key value</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem myset b</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-5-有序集合类型（SortedSet）"><a href="#3-5-有序集合类型（SortedSet）" class="headerlink" title="3.5    有序集合类型（SortedSet）"></a>3.5    有序集合类型（SortedSet）</h3><blockquote>
<p>不允许重复元素，且元素有序，每个元素都会关联一个double类型的<code>分数（score）</code>，Redis 通过<code>分数（score）</code>来为集合中的成员<strong>从小到大</strong>排序。</p>
</blockquote>
<ol>
<li><p>存储：<code>zadd key score value</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zadd mysort <span class="number">60</span> english</span><br><span class="line">zadd mysort <span class="number">90</span> chinese</span><br><span class="line">zadd mysort <span class="number">80</span> math</span><br></pre></td></tr></table></figure></li>
<li><p>获取：</p>
<ul>
<li><code>zrange key start end</code>：按分数从小到大的顺序获取<code>value</code></li>
<li><code>zrange key start end withscores</code>：按分数从小到大的顺序获取<code>value</code>和<code>score</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrange mysort <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">zrange mysort <span class="number">0</span> <span class="number">-1</span> withscores</span><br></pre></td></tr></table></figure></li>
<li><p>删除：<code>zrem key value</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem mysort english</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-6-通用命令"><a href="#3-6-通用命令" class="headerlink" title="3.6    通用命令"></a>3.6    通用命令</h3><blockquote>
<p>  查看 Redis 版本</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis- server -v</span><br></pre></td></tr></table></figure>

<ol>
<li>查询所有的键：<code>keys *</code></li>
<li>获取指定键<code>key</code>对应的值<code>value</code>的数据类型：<code>type key</code></li>
<li>删除指定的键值对：<code>del key</code></li>
</ol>
<hr>
<h1 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h1><p>Redis 是一个<strong>内存数据库</strong>，当 Redis 服务器重启后内存中的数据就会丢失。为了解决这个问题，我们可以将 Redis 内存中的数据持久化保存到磁盘中。</p>
<p><strong>Redis 的持久化机制（2种）</strong></p>
<ol>
<li>RDB（Redis DataBase）：默认方式【快照】</li>
<li>AOF（Append Only File）：【只追加文件】</li>
</ol>
<h2 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1    RDB"></a>1    RDB</h2><p><strong>工作流程：</strong></p>
<ul>
<li>  在指定的时间间隔内将内存中的数据集快照（Snapshot）写到磁盘中，它恢复时是直接将快照文件读到内存中。</li>
</ul>
<p><strong>RDB 优缺点：</strong></p>
<ul>
<li>  <strong>优点</strong>：</li>
<li>  <strong>缺点</strong>：在一定时间间隔后才会进行一次备份，所以如果 Redis 服务器在两个备份的时间点之间宕机的话，就会丢失掉最后一次快照之后所有的修改。</li>
</ul>
<p><strong>RDB 原理</strong>：</p>
<ul>
<li>  Redis 存在一个后台线程，这个线程的会监控两个参数，一个是时间间隔（单位：s），一个是发生变化的 key 的个数。在一定的时间间隔后，检测 key 的变化情况，如果满足持久化条件就进行一次数据持久化到磁盘中。</li>
</ul>
<p><strong>RDB 配置</strong></p>
<ul>
<li>  在<code>redis.windows.conf</code>文件中，有如下几行数据：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60  10000</span><br><span class="line"></span><br><span class="line">其含义分别是：</span><br><span class="line">#	after 900 sec (15 min) if at least 1 key changed	900s之后至少有1个key发生变化则持久化数据</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed	300s之后至少有10个key发生变化则持久化数据</span><br><span class="line">#   after 60 sec if at least 10000 keys changed		60s之后至少有10000个key发生变化则持久化数据</span><br></pre></td></tr></table></figure>



<ul>
<li>  如果想要自定义间隔时间和发生变化的 key 的数量，直接修改配置文件即可。但注意修改配置文件后，需重启 Redis 服务器，并在启动时指定要加载的配置文件名称。</li>
</ul>
<blockquote>
<p>在服务器目录下进入 CMD 命令行窗口界面，输入以下命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf	</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务器 + 并加载指定配置文件</span></span><br></pre></td></tr></table></figure>







<h2 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2    AOF"></a>2    AOF</h2><p><strong>工作流程：</strong></p>
<ul>
<li>  以日志的形式来记录每个写操作，将 Redis 执行过的所有写操作指令记录下来（读操作不记录），只允许追加日志文件但不允许修改日志文件。</li>
<li>  Redis 重启后就会读取该文件的内容将所有的写操作的指令从头到尾执行一遍以完成数据恢复的工作。</li>
<li>  AOF 采用文件追加的方式，日志文件只会越来越大，为了避免这种情况，新增了重写机制，当 AOF 日志文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。</li>
</ul>
<blockquote>
<p>  什么叫可以恢复数据的最小指令集？</p>
</blockquote>
<p>所谓可以恢复数据的最小指令集，就是可以恢复 Redis 中数据的最少指令集。正常情况下，所有写操作都会被保存到日志文件中，那么显然，假如有一个 val 值，先对 val 进行 +1 操作，再对 val 进行 -1 操作，那么这就是两条指令，虽然执行完这两条指令后 val 的值没有任何变换，但是日志文件的大小却增加了，而日志文件压缩就是把可以互相抵消的指令抵消掉，只留下可以保证 Redis 数据完整性的最少指令集。</p>
<p><strong>AOF原理：</strong></p>
<ul>
<li>  AOF（Append Only File），即只依赖配置文件的方式。通过配置文件设置的方式持久化 Redis 缓存中的数据。</li>
</ul>
<p><strong>AOF优缺点</strong></p>
<ul>
<li><strong>优点：</strong><ol>
<li> 每次修改同步（<code>appendfsync always</code> ），每次发生数据变化会被立即记录到磁盘，性能较差但是数据完整性较好。</li>
<li> 每秒同步（<code>appendfsync everysec</code>） ： 每秒进行一次持久化，如果一秒内宕机，会有数据丢失。</li>
<li> 从不同步（<code>appendfsync no</code>） </li>
</ol>
</li>
<li><strong>缺点：</strong><ol>
<li> AOF 日志文件往往要大于 RDB 快照文件，一方面磁盘占用较大，另一方面恢复速度要慢于 RDB。【RDB 是按照数据恢复，而 AOF 则是按照操作恢复】</li>
</ol>
</li>
</ul>
<p><strong>AOF 配置：</strong></p>
<ol>
<li><p>编辑<code>redis.windows.conf</code>文件，设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly no	# 关闭AOF</span><br><span class="line">appendonly yes 	# 开启AOF</span><br></pre></td></tr></table></figure>

<blockquote>
<p>详细参数：</p>
<ul>
<li><code>appendfsync always</code> ： 每一次操作都进行持久化</li>
<li><code>appendfsync everysec</code> ： 每隔一秒进行一次持久化</li>
<li><code>appendfsync no</code>     ： 不进行持久化</li>
</ul>
</blockquote>
</li>
<li><p>修改配置文件后，需重启Redis服务器，启动时需要指定配置文件名称。</p>
</li>
</ol>
<h2 id="3-如何选择合适的持久化方式"><a href="#3-如何选择合适的持久化方式" class="headerlink" title="3    如何选择合适的持久化方式"></a>3    如何选择合适的持久化方式</h2><ol>
<li> <strong>如果数据不敏感，</strong>并且数据丢失后可以从其它地方找补回来，那么就可以关闭持久化。</li>
<li> <strong>如果数据比较重要，但是可以承受数分钟内的数据丢失</strong>，那么可以只使用 RDB。</li>
</ol>
<hr>
<h1 id="5-Redis-事务"><a href="#5-Redis-事务" class="headerlink" title="5    Redis 事务"></a>5    Redis 事务</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul>
<li>  之前我们使用的 Redis 命令都是输入一条指令，得到一个结果。</li>
<li>  而<strong>Redis 事务</strong>可以一次执行多条命令，本质上就是一组命令的集合。</li>
<li>  一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令加塞。</li>
<li>  Redis 事务的主要作用就是串联多个命令防止别的命令插队。</li>
</ul>
<hr>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><ul>
<li>  <strong>MULTI</strong> 命令用于开启一个事务，它总是返回 OK 。</li>
<li>  <strong>MULTI</strong> 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 <strong>EXEC</strong> 命令被调用时， 一次性执行队列中的所有命令。</li>
<li>  在 EXEC 命令执行之前，通过调用 <strong>DISCARD</strong>， 客户端可以清空事务队列， 并放弃执行事务。</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><blockquote>
<p>  <strong>Redis 事务命令</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DISCARD</strong></td>
<td>取消事务，并清空事务块内所有命令</td>
</tr>
<tr>
<td><strong>EXEC</strong></td>
<td>执行事务块内的所有命令</td>
</tr>
<tr>
<td><strong>MULTI</strong></td>
<td>标记一个事务块的开始</td>
</tr>
<tr>
<td><strong>UNWATCH</strong></td>
<td>取消 WATCH 命令对所有 key 的监视</td>
</tr>
<tr>
<td><strong>WATCH key [key…]</strong></td>
<td>监视一个（或多个key），如果在事务执行之前这个（或这些）key 被其它命令所改动，那么事务将被打断。</td>
</tr>
</tbody></table>
<h3 id="Case1：正常执行"><a href="#Case1：正常执行" class="headerlink" title="Case1：正常执行"></a>Case1：正常执行</h3><ol>
<li> 从 <strong>MULTI 开始</strong>，标记一个事务块的开始，并创建一个命令队列用于保存命令的集合；</li>
<li> 在遇到 <strong>EXEC 之前</strong>，所有正确的命令都会被添加到命令队列中；</li>
<li> 直到遇到 <strong>EXEC 命令后</strong>，立即执行队列中的所有命令。 </li>
</ol>
<img src="/2020/11/21/Redis/image-20210809100102082.png" alt="image-20210809100102082" style="zoom:80%;">



<hr>
<h3 id="Case2：放弃事务"><a href="#Case2：放弃事务" class="headerlink" title="Case2：放弃事务"></a>Case2：放弃事务</h3><ol>
<li> 从 <strong>MULTI 开始</strong>，标记一个事务块的开始，并创建一个命令队列用于保存命令的集合；</li>
<li> 所有正确的命令都会被添加到命令队列中；</li>
<li> 但是遇到 <strong>DISCARD</strong> 命令后，会删除命令队列并放弃队列中所有命令的执行。</li>
<li> 在这之后，我们通过 <code>get k1</code> 试图查找 Redis 中是否存在键为 k1 的值，发现不存在，这就证明该事务内的所有命令都没有被执行。</li>
</ol>
<img src="/2020/11/21/Redis/image-20210809100735411.png" alt="image-20210809100735411" style="zoom:80%;">



<hr>
<h3 id="Case3：全体连坐"><a href="#Case3：全体连坐" class="headerlink" title="Case3：全体连坐"></a>Case3：全体连坐</h3><ol>
<li> 从 <strong>MULTI 开始</strong>，标记一个事务块的开始，并创建一个命令队列用于保存命令的集合；</li>
<li> 所有命令都会被添加到命令队列中；</li>
<li> 在执行 <code>gte k2</code> 命令时，由于操作人员的疏忽，命令打错了；并继续添加命令 <code>set k3 v3</code>；</li>
<li> 直到遇到 <strong>EXEC 命令后</strong>，立即执行队列中的所有命令。</li>
<li> 但是<strong>由于此时队列中存在一个错误的命令，这条命令执行失败了，并且连带着整个事务中所有的命令都执行失败了</strong>。 </li>
<li> 在这之后，执行 <code>get k1</code> 操作，发现没有对应的 value，这也从侧面验证了事务块中所有的命令都没有执行成功。</li>
<li> 这就是 Redis 的事务性。</li>
</ol>
<img src="/2020/11/21/Redis/image-20210809101749283.png" alt="image-20210809101749283" style="zoom:80%;">



<hr>
<h3 id="Case4：冤头债主"><a href="#Case4：冤头债主" class="headerlink" title="Case4：冤头债主"></a>Case4：冤头债主</h3><ol>
<li> 从 <strong>MULTI 开始</strong>，标记一个事务块的开始，并创建一个命令队列用于保存命令的集合；</li>
<li> 所有命令都会被添加到命令队列中；</li>
<li> 在执行 <code>incr k1</code> 命令时，由于 <code>k1</code> 位置上存储的值 <code>v1</code> 是一个字符串，且不能转型成为对应的 <code>Integer</code> 类型，所以这条命令在真实执行时会报错，但在编译时不会报错，因为命令是正确的。</li>
<li> 直到遇到 <strong>EXEC 命令后</strong>，立即执行队列中的所有命令。</li>
<li> <strong>由于 <code>incr k1</code> 命令在执行时会报错，所以这条命令执行失败。但是与上面不同的是，此时事务中的其它正确的命令还是可以正常被执行。</strong></li>
<li> 在这之后，执行 <code>get k2</code> 操作，发现可以找到对应的 value，这也从侧面验证了事务块中其它正确的命令都执行成功了。</li>
<li> 这就是 Redis 的非事务性。</li>
</ol>
<p><strong>Incr</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis Incr 命令将 key 中储存的数字值 +<span class="number">1</span>。</span><br><span class="line">如果 key 不存在，那么 key 的值会先被初始化为 <span class="number">0</span> ，然后再执行 INCR 操作。</span><br><span class="line">如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/21/Redis/image-20210809102642290.png" alt="image-20210809102642290"></p>
<blockquote>
<p>  <strong>二者的区别：</strong></p>
</blockquote>
<ul>
<li>  我们发现，在 Case3 和 Case4 中，同样都出现了某条命令执行失败，但 Case3 中整个事务都回滚了，在 Case4 中却只是对应错误命令执行失败，而事务中的其它命令依然可以正常执行成功。那么这两者有什么区别呢？</li>
<li>  这就有点类似于 Java 中的编译时异常和运行时异常了。</li>
<li>  在 Case3 中出现的错误是非常明显的语法错误，Redis 的编译器在我们敲下回车的那一刻就会直接返回 Error 错误信息提示我们该条命令是有问题的。发生这类错误时是需要回滚整个事务的。类比于 Java 中的编译时错误，当我们的代码写错的那一刹那，IDE 的编译器就会用红色的下划线提醒我们代码错了。</li>
<li>  而在 Case4 中出现的错误，它是语法正确，但在执行过程中由于类型不匹配而导致的错误，这种错误在编译时不会报错，在执行中出现错误以后也无需回滚整个事务。类比于 Java 中的运行时错误，比如我们在 Java 代码中插入一行 <code>int i = 10/2;</code>，这行代码在编译时是没有问题的，因为它符合语法规范，但在运行时由于除数不能为0而会抛出异常。</li>
<li>  简而言之就是：<strong>开启事务后，如果在添加命令的过程中，Redis 的编译器没有报错，那么即使程序在执行过程中出现了错误，也只是某条错误命令执行失败了，而不会影响到事务中的其它命令。如果在添加命令的过程中，某条命令在编译后直接报错，那么在执行过程中出错后会回滚整个事务中的所有命令。</strong></li>
</ul>
<hr>
<h3 id="Case5：watch-监控"><a href="#Case5：watch-监控" class="headerlink" title="Case5：watch 监控"></a>Case5：watch 监控</h3><ul>
<li>  <strong>watch 监控：在执行 <code>multi</code> 之前，先执行 <code>watch key1 [key2]</code>，可以监视一个或多个 key，如果在事务执行之前这个（或这些）key 被其它命令所改动，那么事务将被打断。</strong></li>
<li>  watch 监控用于多个 Session 并发操作时保证数据的一致性。在事务开始之前监控一个关键值属性，如果在事务还未执行之前该关键值被另一个 Session 改变，则当前连接的事务一定不会执行成功。</li>
</ul>
<blockquote>
<p>  先模拟一个场景，假设某用户花呗额度为 100 元，在淘宝上购买某本书需要 40 元。通过花呗买书的一个事务为：花呗余额减到 60 元，待还款金额增加到 40 元。</p>
</blockquote>
<ol>
<li><p>初始化数据：花呗余额100，欠款 0</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Connecting...</span><br><span class="line">已连接。</span><br><span class="line">Tencent_Redis:0&gt;set balance 100</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">Tencent_Redis:0&gt;set debt 0</span><br><span class="line">&quot;OK&quot;</span><br></pre></td></tr></table></figure></li>
<li><p> 先监控一个属性 balance</p>
</li>
<li><p> 再开启事务</p>
</li>
<li><p>如果在事务执行之前，没有其它命令修改 balance 这个属性，正常结果为：</p>
<p> <img src="/2020/11/21/Redis/image-20210809175349825.png" alt="image-20210809175349825"></p>
</li>
<li><p>如果在事务执行之前，存在另一个线程修改了 balance 这个属性，则这个事务将被打断，所有数据会回滚到事务执行之前。</p>
<p> <img src="/2020/11/21/Redis/watch.png" alt="watch"></p>
</li>
<li><p> 最后通过 <code>get balance</code> 命令查看发现，Session1 中的事务并没有执行成功。</p>
</li>
</ol>
<h3 id="Case6：unwatch-取消监控"><a href="#Case6：unwatch-取消监控" class="headerlink" title="Case6：unwatch 取消监控"></a>Case6：unwatch 取消监控</h3><blockquote>
<p>  <strong>UNWATCH 在什么时候使用？</strong></p>
</blockquote>
<ul>
<li>  在执行 WATCH 命令监控某个字段后，如果在下一个命令还没有执行之前就知道被监控的字段被另一个 Session 修改了，那么此时可以直接 UNWATCH 取消原有的监控；重新监控该字段的最新值，重写编写命令。</li>
<li>  如果在执行了 WATCH 命令后，EXEC 或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。因为一旦执行了 EXEC 或 DISCARD 后，事务一定会结束（可能成功也可能失败），之前监控的关键值字段也就自然失效了。</li>
</ul>
<hr>
<h2 id="事务冲突问题"><a href="#事务冲突问题" class="headerlink" title="事务冲突问题"></a>事务冲突问题</h2><blockquote>
<ul>
<li>  乐观锁 + CAS</li>
<li>  悲观锁</li>
</ul>
</blockquote>
<h3 id="乐观锁-CAS"><a href="#乐观锁-CAS" class="headerlink" title="乐观锁 + CAS"></a>乐观锁 + CAS</h3><p><strong>乐观锁不会真正的对某一数据上锁，但是对数据进行写操作时，为了保证多个 Session 间数据的一致性要用到 CAS 机制。</strong></p>
<blockquote>
<p>  <strong>乐观锁（Optimistic Lock）</strong></p>
</blockquote>
<ul>
<li>  顾名思义，就是很乐观，想的贼好，每次在操作数据时都认为别人不会修改，所以不会上锁。</li>
<li>  但是如果不上锁的话，在线程 A 操作数据期间线程 B 也同时操作了数据，这时候就会发生数据冲突了。</li>
<li>  所以，对乐观锁而言，在更新数据的时候会判断一下在此期间别人有没有去更新这个数据，如果没有其它线程操作过这个数据则可以更新成功，如果有线程操作过这个数据则会重新读取最新的数据进行更新，直到更新成功。</li>
<li>  如果判断某一段时间内是否有其它线程更新过某个数据用到了 <strong>CAS</strong> 机制，常见的有版本号等机制。</li>
<li>  乐观锁适用于多读的应用类型，这样可以提高吞吐量，</li>
</ul>
<blockquote>
<p>  <strong>CAS（Check And Set）</strong></p>
</blockquote>
<ul>
<li>  CAS 最常见的机制就是版本号机制。</li>
<li>  所谓版本号机制，就是每个线程在得到操作共享数据的时候，同时会得到该数据的版本号，在完成数据操作想要覆盖原数据时，首先会判断线程中保存的版本号与共享数据的版本号是否一致，如果版本号一致则更新成功，并将共享数据的版本号 +1；若线程中保存的版本号与共享数据的版本号不一致的话，则不能更新成功。需要重新拉取最新的共享数据（包括最新的版本号），重新更新数据，直到更新成功为止。</li>
</ul>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote>
<p>  <strong>悲观锁（Pessimistic Lock）</strong></p>
</blockquote>
<p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会被阻塞知道它拿到锁。传统的关系型数据库中很多地方都用到了这个锁机制，比如行锁、表锁、读锁、写锁等，都是在做操作之前先上锁。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="三阶段"><a href="#三阶段" class="headerlink" title="三阶段"></a>三阶段</h3><ol>
<li> <strong>开启</strong>：以 <strong>MULTI</strong> 开启一个事务；</li>
<li> <strong>入队</strong>：将多个命令入队到事务中，接到这些命令并不会立即执行，而是加入到待执行的事务队列中；</li>
<li> <strong>执行</strong>：由 <strong>EXEC</strong> 命令触发事务执行。</li>
</ol>
<h3 id="三特性"><a href="#三特性" class="headerlink" title="三特性"></a>三特性</h3><blockquote>
<p>  <strong>单独的隔离操作</strong></p>
</blockquote>
<ul>
<li>  事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其它客户端发送来的命令请求所打断。</li>
</ul>
<blockquote>
<p>  <strong>没有隔离级别的概念</strong></p>
</blockquote>
<ul>
<li>  与传统的 SQL 数据库不同，Redis 中没有事务的隔离级别这一概念。</li>
<li>  因为 Redis 的事务在执行 EXEC 命令前，只是把事务队列中的命令序列化，并不会真正地被执行。自然也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头疼的问题。</li>
</ul>
<blockquote>
<p>  <strong>不保证原子性</strong></p>
</blockquote>
<ul>
<li>  Redis 中同一个事务如果有一条命令执行失败，其后的命令仍然可能会被执行，而不进行回滚。这个要分情况讨论。</li>
</ul>
<hr>
<h1 id="6-Redis-的发布订阅"><a href="#6-Redis-的发布订阅" class="headerlink" title="6    Redis 的发布订阅"></a>6    Redis 的发布订阅</h1><p>Redis 的发布订阅类似于 MQ 中的发布订阅，不过我们在企业级开发中一般不太使用 Redis 作为消息队列，而是采用更专业的消息中间件，如  ActiveMQ、RabbitMQ 或者 Kafka 等。</p>
<h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>发布订阅是进程间的一种通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p>
<ul>
<li>  类似于微信公众号，只要你关注了某个公众号，当公众号再发布消息的时候，就会通知到你的微信上。</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>psubscribe pattern [pattern]</td>
<td>订阅一个或多个符合给定模式的频道</td>
</tr>
<tr>
<td>pubsub subcommand [argument [argument…]]</td>
<td>查看订阅与发布系统状态</td>
</tr>
<tr>
<td>publish channel message</td>
<td>将信息发送到指定的频道</td>
</tr>
<tr>
<td>punsubscribe [pattern [pattern …]]</td>
<td>退订所有给定模式的频道</td>
</tr>
<tr>
<td>unsubscribe [channel [channel…]]</td>
<td>退订指定的频道</td>
</tr>
</tbody></table>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>先订阅后发布才能收到消息</p>
<ol>
<li> 可以一次性订阅多个；<code>subscribe c1 c2 c3</code></li>
<li> 消息发布；<code>publish c2 hello-redis</code></li>
<li> 一次性订阅多个（以通配符的形式）：<code>psubscribe hell*</code></li>
</ol>
<h1 id="7-Redis-主从复制（Master-Slave）"><a href="#7-Redis-主从复制（Master-Slave）" class="headerlink" title="7    Redis 主从复制（Master/Slave）"></a>7    Redis 主从复制（Master/Slave）</h1><h2 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>  <strong>主从复制</strong></p>
</blockquote>
<p>主机数据更新后根据配置和策略，自动同步到从机的 Master/Slave 机制，<strong>Master 以写为主，Slave 以读为主</strong>。</p>
<img src="/2020/11/21/Redis/image-20210810151248584.png" alt="image-20210810151248584" style="zoom:200%;">



<h2 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h2><ul>
<li>  读写分离，性能扩展</li>
<li>  容灾快速恢复</li>
</ul>
<h2 id="怎么用（主从复制）"><a href="#怎么用（主从复制）" class="headerlink" title="怎么用（主从复制）"></a>怎么用（主从复制）</h2><h3 id="修改配置文件细节"><a href="#修改配置文件细节" class="headerlink" title="修改配置文件细节"></a>修改配置文件细节</h3><ol>
<li> 拷贝多个 <code>redis.conf</code> 文件，分别用作多台服务器的配置文件；</li>
<li> 开启 <code>daemonize yes</code>；</li>
<li> 修改 Pid 文件名字；</li>
<li> 为每台服务器指定端口；</li>
<li> 修改 Log 文件名字；</li>
<li> 修改 Dump.rab 名字；</li>
<li> Appendonly 关掉或者修改名字</li>
</ol>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h4 id="1、修改配置文件"><a href="#1、修改配置文件" class="headerlink" title="1、修改配置文件"></a>1、修改配置文件</h4><ol>
<li><p>新建 <code>redis6379.conf</code>，填写以下内容</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis_6379.pid</span><br><span class="line">port <span class="number">6379</span></span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure>

 <img src="/2020/11/21/Redis/image-20210810151819939.png" alt="image-20210810151819939" style="zoom: 150%;"></li>
<li><p>新建 <code>redis6380.conf</code>，填写以下内容</p>
 <img src="/2020/11/21/Redis/image-20210810151900331.png" alt="image-20210810151900331" style="zoom:150%;"></li>
<li><p>新建 <code>redis6381.conf</code>，填写以下内容</p>
 <img src="/2020/11/21/Redis/image-20210810151913759.png" alt="image-20210810151913759" style="zoom:150%;"></li>
</ol>
<p>​                               </p>
<h4 id="2、启动三台redis服务器"><a href="#2、启动三台redis服务器" class="headerlink" title="2、启动三台redis服务器"></a>2、启动三台redis服务器</h4><img src="/2020/11/21/Redis/image-20210810152048413.png" alt="image-20210810152048413" style="zoom:150%;">





<blockquote>
<p>  <strong>查看系统进程，看看三台服务器是否启动</strong></p>
</blockquote>
<img src="/2020/11/21/Redis/image-20210810152122261.png" alt="image-20210810152122261" style="zoom:150%;">





<h4 id="3、查看三台主机运行情况"><a href="#3、查看三台主机运行情况" class="headerlink" title="3、查看三台主机运行情况"></a>3、查看三台主机运行情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印主从复制的相关信息</span></span><br><span class="line">info replication	</span><br></pre></td></tr></table></figure>

<img src="/2020/11/21/Redis/image-20210810152243500.png" alt="image-20210810152243500" style="zoom:150%;">

 



<h4 id="4、配从-库-不配主-库"><a href="#4、配从-库-不配主-库" class="headerlink" title="4、配从(库)不配主(库)"></a>4、配从(库)不配主(库)</h4><ul>
<li>  主库使用默认的 6379 端口号，使用默认的配置信息即可；</li>
<li>  主要修改从库的端口号及配置信息；</li>
<li>  当然如果你非要改主库的配置信息也可以。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">成为某个实例的从服务器</span></span><br><span class="line">slaveof &lt;ip&gt; &lt;port&gt;</span><br><span class="line"></span><br><span class="line">SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在 6380 和 6381 上执行: <code>slaveof 127.0.0.1 6379</code>，成为 6379 的备机。</p>
 <img src="/2020/11/21/Redis/image-20210810152453011.png" alt="image-20210810152453011" style="zoom: 150%;"></li>
<li><p><strong>在主机上写，从机上可以读取数据；[在从机上写数据报错]</strong></p>
 <img src="/2020/11/21/Redis/image-20210810152631660.png" alt="image-20210810152631660" style="zoom:150%;"></li>
<li><p><strong>主机挂掉，重启就行，一切如初；</strong></p>
<blockquote>
<p>  <strong>注解：</strong>主机宕机后，两个从机不会顶替主机称为新的 Master，而是依然安心当一个 Slave。当原来的 Master 重新启动后，依然会是这两台服务器的主机。</p>
</blockquote>
</li>
<li><p>从机重启后需重设：<code>slaveof 127.0.0.1 6379</code></p>
<blockquote>
<p>  <strong>注解：</strong>从机宕机后重启，默认情况下不会自动称为某个 Master 的备机，必须重新调用 <code>Slaveof</code> 命令才能让其成为某台 Master 的 Slave。但是可以将这条命令增加到配置文件中，从机启动时会加载配置文件，这样就可以实现从机启动后直接自动绑定某一台 Master。</p>
<p>  <img src="/2020/11/21/Redis/image-20210810153112350.png" alt="image-20210810153112350"></p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="常用3招（常用的配置策略）"><a href="#常用3招（常用的配置策略）" class="headerlink" title="常用3招（常用的配置策略）"></a>常用3招（常用的配置策略）</h2><blockquote>
<ul>
<li>  一主二仆</li>
<li>  薪火相传</li>
<li>  反客为主</li>
</ul>
</blockquote>
<h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><ul>
<li>  一主二仆就是上文中演示的一个 Master 两个 Slave 的形态。</li>
</ul>
<img src="/2020/11/21/Redis/image-20210810153916067.png" alt="image-20210810153916067" style="zoom:150%;">

<hr>
<h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><img src="/2020/11/21/Redis/image-20210810153935273.png" alt="image-20210810153935273" style="zoom:150%;">

<blockquote>
<p>  <strong>为什么有？</strong></p>
</blockquote>
<p>如果一个 Redis 集群中只有一台 Master，那么每次 Master 中的数据发生变化时，其余所有的 Slave 都需要从这台 Master 中备份数据，假设有 100 台甚至更多台的 Slave 存在，Master 可能就会因为承受不了这么大的流量而宕机。为了解决这种问题，我们可以采用“薪火相传”的策略。</p>
<blockquote>
<p>  <strong>是什么？</strong></p>
</blockquote>
<p>“薪火相传”的策略就是：上一个 Slave 可以是下一个 Slave 的 Master ，Slave 同样可以接受其它 Slaves 的连接和同步请求，那么该 Slave 作为链条中一个的 Master，可以有效减轻 Master  的压力。</p>
<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li><p>  <strong>中间机器的角色仍然是一个 Slave ，但是它可以有自己的 Slave。</strong></p>
</li>
<li><p>  中间机器的 Slave 虽然可以承担了部分 Master 的功能，但是并不能进行数据的写操作。</p>
</li>
<li><p>  Master 挂了，Slave 还是从机，无法写数据了。</p>
</li>
<li><p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p>
<blockquote>
<p>  注解：假设 6381 一开始的 Master 是 6379，中途使用 <code>slaveof 127.0.0.1 6380</code> 将 Master 变更为 6380，那么这是需要先清除掉从 6379 中得到的数据，重新拉取 6380 中最新的数据。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong></p>
</blockquote>
<ol>
<li> <strong>数据失真</strong>。数据传递的过程中可能会发生数据丢失，传递的次数越多，数据丢失的概率就越大。最严重的情况是：一旦某个 slave 宕机，后面的 slave 都无法备份。</li>
<li> <strong>传输延时</strong>。由于数据是链式的逐个向后备份，所以存在较严重的数据延时。</li>
</ol>
<blockquote>
<p>  <strong>使用方法：</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Slaveof 新主库IP 新主库端口</span></span><br><span class="line">Slaveof &lt;ip&gt; &lt;port&gt;</span><br><span class="line"></span><br><span class="line">slaveof 127.0.0.1 6380</span><br></pre></td></tr></table></figure>

<img src="/2020/11/21/Redis/image-20210810154249590.png" alt="image-20210810154249590" style="zoom: 200%;">







<h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><blockquote>
<p>  <strong>是什么？</strong></p>
</blockquote>
<ul>
<li>主机宕机后，从机上位</li>
<li>当一个 Master 宕机后，后面的 Slave 可以立刻升为 Master，其后面的 Slave 不用做任何修改。</li>
<li>从机上位：Slaveof no one</li>
<li>另外的从机有两种选择：<ol>
<li> 另外的从机改换门庭：<code>Slaveof 127.0.0.1 6380</code></li>
<li> 另外的从机忠贞不屈：死等</li>
</ol>
</li>
</ul>
<blockquote>
<p>  <strong>怎么用？</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让当前从机变为主机</span></span><br><span class="line">Slaveof no one </span><br></pre></td></tr></table></figure>

<img src="/2020/11/21/Redis/image-20210810155315761.png" alt="image-20210810155315761" style="zoom:150%;">







<hr>
<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><blockquote>
<ul>
<li>  <strong>全量复制</strong></li>
<li>  <strong>增量复制</strong></li>
</ul>
</blockquote>
<ol>
<li> Slave 在连接到 Master 后首先会发送一个同步（sync）命令；</li>
<li> Master 接到命令后，启动后台的存盘进程，同时收集所有接收到的修改数据的命令，在后台进程执行完毕之后，Master 将传送整个数据文件到 Slave，完成一次<strong>完全同步</strong>。</li>
<li> <strong>全量复制</strong>：Slave 在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li> <strong>增量复制</strong>：Master 继续将新的所有收集到的命令依次传递给 Slave ，完成同步</li>
<li> 但是只要是重新连接 Master，一次完全同步（全量复制）将被自动执行。</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>  Slave 启动时，必先进行一次全量复制；</li>
<li>  在 Slave 启动期间，Master 中的数据发生变化时，Slave 只需要进行增量复制即可。</li>
</ul>
<img src="/2020/11/21/Redis/image-20210810160117746.png" alt="image-20210810160117746" style="zoom:150%;">





<h2 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>  <strong>反客为主的自动版</strong>。</li>
<li>  能够在后台监控 Master 是否故障，如果出现故障了所有 Slave 进行投票，根据票选结果自动将从机转换为新的主机。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</span></span><br><span class="line">slave-priority 10</span><br></pre></td></tr></table></figure>

<img src="/2020/11/21/Redis/image-20210810160314929.png" alt="image-20210810160314929" style="zoom:150%;">





<h3 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h3><blockquote>
<ol>
<li> 初始化结构：一主二仆，6379 带着 6380、6381</li>
</ol>
</blockquote>
<img src="/2020/11/21/Redis/image-20210810160420195.png" alt="image-20210810160420195" style="zoom:150%;">



<blockquote>
<ol start="2">
<li> 自定义的配置文件 <code>/myredis</code>目录下新建 <strong>sentinel.conf</strong> 文件。名字绝不能错。配置文件内容。</li>
</ol>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中mymaster是为监控对象起的服务器名称； 1 表示至少有多少个哨兵同意迁移的数量。</span></span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6379</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>



<blockquote>
<ol start="3">
<li> 启动哨兵</li>
</ol>
</blockquote>
<ul>
<li>  执行 <code>redis-sentinel /myredis/sentinel.conf</code></li>
</ul>
<img src="/2020/11/21/Redis/image-20210810160748119.png" alt="image-20210810160748119" style="zoom: 150%;">



<blockquote>
<ol start="4">
<li> 当主机挂掉后，会从备机选举中产生新的主机。</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li> 原主机重启后会自动变为从机。</li>
</ol>
</blockquote>
<img src="/2020/11/21/Redis/image-20210810161028961.png" alt="image-20210810161028961" style="zoom:150%;">



<p><strong>注意</strong></p>
<ul>
<li>  一组 Sentinel 能同时监控多个 Master</li>
</ul>
<h2 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h2><blockquote>
<p>  <strong>复制延时</strong></p>
</blockquote>
<p>由于写操作都是在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重</p>
<h1 id="Redis-缓存"><a href="#Redis-缓存" class="headerlink" title="Redis 缓存"></a>Redis 缓存</h1><h2 id="1-Redis-过期键的删除策略"><a href="#1-Redis-过期键的删除策略" class="headerlink" title="1    Redis 过期键的删除策略"></a>1    Redis 过期键的删除策略</h2><h3 id="1-1-惰性删除"><a href="#1-1-惰性删除" class="headerlink" title="1.1    惰性删除"></a>1.1    惰性删除</h3><p><strong>是什么：</strong></p>
<ul>
<li>  惰性删除不会主动去删除 Redis 中的数据，而是在有请求访问数据的时候，再检查当前键值是否过期，如果过期则执行删除并返回 null 给客户端，如果没有过期则返回正常信息给客户端。</li>
<li>  也就是说，设置完某个 key 的过期时间后，我们不去管它，当需要该 key 时，我们在检查其是否过期，如果过期，我们就删掉它，反之正常返回该 key。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>  对 CPU 友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的 key 不用浪费 CPU 时间片进行过期检查。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。</li>
</ul>
<h3 id="1-2-定期删除"><a href="#1-2-定期删除" class="headerlink" title="1.2    定期删除"></a>1.2    定期删除</h3><p><strong>是什么：</strong></p>
<p>每隔一段时间 Redis 就会随机对一批设置了过期时间的 key 进行检查，并删除里面已过期的 key。</p>
<p><strong>优点：</strong></p>
<ul>
<li>  定期删除，能有效释放过期键占用的内存。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  难以确定删除操作执行的频率，如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。如果执行的太少，那又和惰性删除一样了，对内存不友好。</li>
<li>  另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，直接导致业务错误。</li>
</ul>
<h3 id="1-3-定时删除"><a href="#1-3-定时删除" class="headerlink" title="1.3    定时删除"></a>1.3    定时删除</h3><p><strong>是什么：</strong></p>
<p>在设置某个 key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。</p>
<p><strong>优点：</strong></p>
<ul>
<li>  定时删除对内存是最友好的，能够保存内存中的 key 一旦过期就能立即从内存中删除。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  对 CPU 最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。</li>
</ul>
<h2 id="2-Redis-内存淘汰策略"><a href="#2-Redis-内存淘汰策略" class="headerlink" title="2    Redis 内存淘汰策略"></a>2    Redis 内存淘汰策略</h2><p><strong>是什么：</strong></p>
<p>虽然 Redis 会不断地删除一些过期的数据，但是在 Redis 中还有很多数据没有设置过期时间，对于这些数据，在 Redis 内存足够时不会执行回收处理，但是一旦当 Redis 内存不够用的时候，就会触发内存淘汰策略来进行回收。<br>所谓的 Redis 内存淘汰策略，就是指当 Redis 的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的数据，以保证 Redis 服务器能正常运行。</p>
<p><strong>常见的内存淘汰策略：</strong>【3类8种】</p>
<blockquote>
<p>  <strong>禁止内存淘汰</strong></p>
</blockquote>
<ol>
<li> <code>no-eviction</code>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<blockquote>
<p>  <strong>对设置了过期时间的 key 进行回收</strong></p>
</blockquote>
<ol start="2">
<li> <code>volatile-lru</code>：LRU（Least Recently Used），删除最近使用最少的 key。利用 LRU 算法移除设置过过期时间的 key。 </li>
<li> <code>volatile-lfu</code>：LFU（Least Frequently Used），删除从 Redis 启动到当前时间使用最少的 key。从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。</li>
<li> <code>volatile-ttl</code>：从已设置过期时间的数据集中挑选将要过期的数据进行淘汰。</li>
<li> <code>volatile-random</code>：从已设置过期时间的数据集中任意选择数据淘汰</li>
</ol>
<blockquote>
<p>  <strong>对所有key进行回收</strong></p>
</blockquote>
<ol start="6">
<li> <code>allkeys-lru</code>：在键空间中，移除最近最少使用的 key.</li>
<li> <code>allkeys-lfu</code>：在键空间中，移除最不经常使用的 key。</li>
<li> <code>allkeys-random</code>：从数据集中任意选择数据淘汰。</li>
</ol>
<p>内存淘汰策略可以通过配置文件来修改，<code>Redis.conf</code> 对应的配置项是 <code>maxmemory-policy</code>，修改对应的值就行，默认是 <code>noeviction</code>。</p>
<h1 id="8-Redis的应用场景"><a href="#8-Redis的应用场景" class="headerlink" title="8    Redis的应用场景"></a>8    Redis的应用场景</h1><blockquote>
<ul>
<li>缓存（数据查询、短连接、新闻内容、商品内容等等）</li>
<li>聊天室的在线好友列表</li>
<li>任务队列。（秒杀、抢购、12306等等）</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理（可以精确到毫秒）</li>
<li>分布式集群架构中的session分离</li>
</ul>
</blockquote>
<hr>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><blockquote>
<p><strong>Jedis</strong>：一款通过Java客户端操作Redis数据库的客户端工具。</p>
</blockquote>
<h2 id="1-Jedis-入门"><a href="#1-Jedis-入门" class="headerlink" title="1    Jedis 入门"></a>1    Jedis 入门</h2><ol>
<li><p>初始化项目并导入 Jedis 依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在代码中使用 <strong>Jdeis API</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建Redis的客户端连接对象并绑定Redis服务器的地址（如果使用无参构造器初始化，则Redis服务器地址的缺省值是：&quot;localhost&quot;,6379）</span></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);	 </span><br><span class="line"><span class="comment">// 2. 具体操作</span></span><br><span class="line">jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="comment">// 3. 关闭客户端与服务器的连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong><code>Jedis类</code>常用的构造函数</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public Jedis()</code></td>
<td align="center">创建Jedis实例对象，并连接到地址为<code>&quot;127.0.0.1&quot;, 6379</code>的服务器上</td>
</tr>
<tr>
<td align="center"><code>public Jedis(String host, int port)</code></td>
<td align="center">创建Jedis实例对象，并指定Redis服务器的地址</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-Jedis-操作-Redis-常用的-API"><a href="#2-Jedis-操作-Redis-常用的-API" class="headerlink" title="2    Jedis 操作 Redis 常用的 API"></a>2    Jedis 操作 Redis 常用的 API</h2><blockquote>
<p>在上面的demo中，创建客户端连接对象<code>Jdeis</code> 和 关闭<code>Jdeis</code>客户端与<code>Redis</code>服务器之间的连接是两个固定操作，真正操作 Redis 数据库的步骤是第2步的具体操作，我们常用的 API 如下：</p>
</blockquote>
<p>首先，我们将获取 Jedis 客户端对象 和 释放连接 的操作提取出来！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、建立与 Redis 服务器的连接并获得客户端对象Jedis</span></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、关闭与Redis服务器之间的连接</span></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-1-字符串类型（String）"><a href="#2-1-字符串类型（String）" class="headerlink" title="2.1    字符串类型（String）"></a>2.1    字符串类型（String）</h3><ol>
<li>存储：<code>set key value</code></li>
<li>获取：<code>get key</code></li>
<li>删除：<code>del key</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、操作String</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 存储</span></span><br><span class="line">    jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(username);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通删除</span></span><br><span class="line">    jedis.del(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定时删除。使用setex()方法存储可以指定过期时间。</span></span><br><span class="line">    <span class="comment">// 将&#123;activecode：6380&#125;键值对存入redis，并且20秒后自动删除该键值对</span></span><br><span class="line">    jedis.setex(<span class="string">&quot;activecode&quot;</span>,<span class="number">20</span>,<span class="string">&quot;6380&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="2-2-哈希类型（Hash）"><a href="#2-2-哈希类型（Hash）" class="headerlink" title="2.2    哈希类型（Hash）"></a>2.2    哈希类型（Hash）</h3><ol>
<li><p>存储：<code>hset key field value</code></p>
</li>
<li><p>获取：</p>
<ul>
<li><p>获取指定field对应的值：<code>hget key field</code></p>
</li>
<li><p>获取所有的filed和value：<code>hgetall key</code></p>
</li>
</ul>
</li>
<li><p>删除：<code>hdel key field</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、操作Hash</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 存储hash</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;person&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wangyi&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;person&quot;</span>,<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取hash</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取hash的所有map中的数据</span></span><br><span class="line">	Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="2-3-列表类型（List）"><a href="#2-3-列表类型（List）" class="headerlink" title="2.3    列表类型（List）"></a>2.3    列表类型（List）</h3><ol>
<li><p>添加：可以添加一个元素到列表的头部（左边）或尾部（右边）</p>
<ul>
<li><code>lpush key value</code>：将元素加入列表左边</li>
<li><code>rpush key value</code>：将元素加入列表右边</li>
</ul>
</li>
<li><p>获取：<code>lrange key start end</code>，根据范围获取。<code>0 -1</code>表示获取全部元素。</p>
</li>
<li><p>删除：</p>
<ul>
<li><code>lpop key</code>：删除列表最左边的元素，并将元素返回</li>
<li><code>rpop key</code>：删除列表最右边的元素，并将元素返回</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、操作List</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// list 存储</span></span><br><span class="line">    jedis.lpush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);	<span class="comment">//从左边存</span></span><br><span class="line">    jedis.rpush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);	<span class="comment">//从右边存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 范围获取</span></span><br><span class="line">    List&lt;String&gt; mylist = jedis.lrange(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 弹出</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">element1</span> <span class="operator">=</span> jedis.lpop(<span class="string">&quot;mylist&quot;</span>);	<span class="comment">//c</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">element2</span> <span class="operator">=</span> jedis.rpop(<span class="string">&quot;mylist&quot;</span>);	<span class="comment">//c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 范围获取</span></span><br><span class="line">    List&lt;String&gt; mylist2 = jedis.lrange(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="2-4-集合类型（Set）"><a href="#2-4-集合类型（Set）" class="headerlink" title="2.4    集合类型（Set）"></a>2.4    集合类型（Set）</h3><ol>
<li>存储：<code>sadd key value</code></li>
<li>获取集合中的所有元素：<code>smembers key</code></li>
<li>删除集合中的某个元素：<code>srem key value</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、操作Set</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set 存储</span></span><br><span class="line">    jedis.sadd(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;php&quot;</span>,<span class="string">&quot;c++&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set 获取</span></span><br><span class="line">    Set&lt;String&gt; myset = jedis.smembers(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="2-5-有序集合类型（SortedSet）"><a href="#2-5-有序集合类型（SortedSet）" class="headerlink" title="2.5    有序集合类型（SortedSet）"></a>2.5    有序集合类型（SortedSet）</h3><ol>
<li>存储：<code>zadd key score value</code></li>
<li>获取：<ul>
<li><code>zrange key start</code>：按<code>分数（score）</code>从小到大的顺序获取<code>value</code></li>
<li><code>zrange key start end withscores</code>：按<code>分数（score）</code>从小到大的顺序获取<code>value</code>和<code>score</code></li>
</ul>
</li>
<li>删除：<code>zrem key value</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、操作SortedSet</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sortedset 存储</span></span><br><span class="line">    jedis.zadd(<span class="string">&quot;mysortedset&quot;</span>,<span class="number">23</span>,<span class="string">&quot;詹姆斯&quot;</span>);</span><br><span class="line">    jedis.zadd(<span class="string">&quot;mysortedset&quot;</span>,<span class="number">07</span>,<span class="string">&quot;甜瓜&quot;</span>);</span><br><span class="line">    jedis.zadd(<span class="string">&quot;mysortedset&quot;</span>,<span class="number">77</span>,<span class="string">&quot;东契奇&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sortedset 获取</span></span><br><span class="line">    Set&lt;String&gt; mysortedset = jedis.zrange(<span class="string">&quot;mysortedset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(mysortedset);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="3-Jedis-连接池"><a href="#3-Jedis-连接池" class="headerlink" title="3    Jedis 连接池"></a>3    Jedis 连接池</h2><p>Jedis 依赖中有一个 Jdeis 的数据库连接池对象的类 <code>JedisPool</code>，我们可以直接创建对象使用。</p>
<blockquote>
<p>  <code>JedisPool</code> 类常用的构造函数</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>JedisPool()</code></td>
<td align="left">使用默认的服务器地址、端口号和配置信息创建JedisPool实例对象。</td>
</tr>
<tr>
<td align="left"><code>JedisPool(JedisPoolConfig config, String host, int port)</code></td>
<td align="left">创建JedisPool实例对象，并手动指定的服务器地址、端口号和配置信息。</td>
</tr>
</tbody></table>
<ul>
<li>  配置信息保存在<code>JedisPoolConfig接口</code>的实现类中。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<ol>
<li>创建JedisPoolConfig配置类对象。[可选，不设置时使用默认配置信息]</li>
<li>创建JedisPool连接池对象</li>
<li>调用方法 getResource()方法获取Jedis连接</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个配置对象</span></span><br><span class="line">    <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">    config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">    config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建Jedis连接池对象</span></span><br><span class="line">    <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config,<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取连接</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();</span><br><span class="line">    <span class="comment">//4. 使用</span></span><br><span class="line">    jedis.set(<span class="string">&quot;hehe&quot;</span>,<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">    <span class="comment">//5. 关闭 归还到连接池中</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><blockquote>
<ul>
<li>将配置信息保存在外部配置文件中</li>
<li>创建一个工具类封装重复操作的代码块</li>
</ul>
</blockquote>
<ol>
<li><p>创建<code>jedis.properties</code>文件保存配置信息</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">maxTotal</span>=<span class="string">50</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure></li>
<li><p>在<code>src/main/java/utils</code>包下创建一个<code>JedisPoolUtil类</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPoolUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 1、读取配置文件，并将配置文件输入流加载到Properties对象中</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> JedisPoolUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jedis.properties&quot;</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、将配置文件信息加载到内存中，并转换为对应的数据类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> (String) properties.get(<span class="string">&quot;host&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt((String) properties.get(<span class="string">&quot;port&quot;</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> Integer.parseInt((String) properties.get(<span class="string">&quot;maxTotal&quot;</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIdle</span> <span class="operator">=</span> Integer.parseInt((String) properties.get(<span class="string">&quot;maxIdle&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、初始化JedisPoolConfig对象</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        config.setMaxIdle(maxIdle);</span><br><span class="line">        config.setMaxTotal(maxTotal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、初始化JedisPool对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, host, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	工具类中的静态方法，作用是：获取Jedis对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();</span><br><span class="line">        <span class="keyword">return</span> jedis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPoolTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">// 1、获取Jedis连接对象 </span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisConfig.getJedis();</span><br><span class="line">		<span class="comment">// 2、使用</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wumeng&quot;</span>);</span><br><span class="line">        <span class="comment">// 3、归还到连接池中</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Redis中常见的配置信息"><a href="#Redis中常见的配置信息" class="headerlink" title="Redis中常见的配置信息"></a>Redis中常见的配置信息</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#最大活动对象数     </span></span><br><span class="line"><span class="attr">redis.pool.maxTotal</span>=<span class="string">1000    </span></span><br><span class="line"><span class="comment">#最大能够保持idel状态的对象数      </span></span><br><span class="line"><span class="attr">redis.pool.maxIdle</span>=<span class="string">100  </span></span><br><span class="line"><span class="comment">#最小能够保持idel状态的对象数   </span></span><br><span class="line"><span class="attr">redis.pool.minIdle</span>=<span class="string">50    </span></span><br><span class="line"><span class="comment">#当池内没有返回对象时，最大等待时间    </span></span><br><span class="line"><span class="attr">redis.pool.maxWaitMillis</span>=<span class="string">10000    </span></span><br><span class="line"><span class="comment">#当调用borrow Object方法时，是否进行有效性检查    </span></span><br><span class="line"><span class="attr">redis.pool.testOnBorrow</span>=<span class="string">true    </span></span><br><span class="line"><span class="comment">#当调用return Object方法时，是否进行有效性检查    </span></span><br><span class="line"><span class="attr">redis.pool.testOnReturn</span>=<span class="string">true  </span></span><br><span class="line"><span class="comment">#“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1.  </span></span><br><span class="line"><span class="attr">redis.pool.timeBetweenEvictionRunsMillis</span>=<span class="string">30000  </span></span><br><span class="line"><span class="comment">#向调用者输出“链接”对象时，是否检测它的空闲超时；  </span></span><br><span class="line"><span class="attr">redis.pool.testWhileIdle</span>=<span class="string">true  </span></span><br><span class="line"><span class="comment"># 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3.  </span></span><br><span class="line"><span class="attr">redis.pool.numTestsPerEvictionRun</span>=<span class="string">50  </span></span><br><span class="line"><span class="comment">#redis服务器的IP    </span></span><br><span class="line"><span class="attr">redis.ip</span>=<span class="string">xxxxxx  </span></span><br><span class="line"><span class="comment">#redis服务器的Port    </span></span><br><span class="line"><span class="attr">redis1.port</span>=<span class="string">6379   </span></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">案例需求：</span><br><span class="line">	1. 提供index.html页面，页面中有一个省份 下拉列表</span><br><span class="line">	2. 当 页面加载完成后 发送ajax请求，加载所有省份</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 注意：使用redis缓存一些不经常发生变化的数据。</span><br><span class="line">	* 数据库的数据一旦发生改变，则需要更新缓存。</span><br><span class="line">		* 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</span><br><span class="line">		* 在service对应的增删改方法中，将redis数据删除。</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="SpringBoot-整合-Redis"><a href="#SpringBoot-整合-Redis" class="headerlink" title="SpringBoot 整合 Redis"></a>SpringBoot 整合 Redis</h1><ul>
<li>  超链接：<a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/03/27/SpringBoot%E4%B8%8E%E7%BC%93%E5%AD%98/">https://lvnengdong.github.io/2021/03/27/SpringBoot%E4%B8%8E%E7%BC%93%E5%AD%98/</a></li>
</ul>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="Redis-传统五大数据类型的落地应用"><a href="#Redis-传统五大数据类型的落地应用" class="headerlink" title="Redis 传统五大数据类型的落地应用"></a>Redis 传统五大数据类型的落地应用</h2><p>除了上述5大数据类型，你还知道哪些 Redis 类型？（8 大数据类型）</p>
<blockquote>
<ol>
<li> String</li>
<li> Hash</li>
<li> Set</li>
<li> SortedSet</li>
<li> List</li>
<li> bitmap（位图）</li>
<li> HyperLogLog（统计）</li>
<li> GEO（地理）</li>
<li> ……</li>
</ol>
</blockquote>
<h2 id="分布式锁？Redis-分布式锁"><a href="#分布式锁？Redis-分布式锁" class="headerlink" title="分布式锁？Redis 分布式锁"></a>分布式锁？Redis 分布式锁</h2><h2 id="Redis-缓存过期淘汰策略"><a href="#Redis-缓存过期淘汰策略" class="headerlink" title="Redis 缓存过期淘汰策略"></a>Redis 缓存过期淘汰策略</h2><h2 id="Redis-的-LRU-算法"><a href="#Redis-的-LRU-算法" class="headerlink" title="Redis 的 LRU 算法"></a>Redis 的 LRU 算法</h2>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/20/Maven/" rel="prev" title="Maven">
                  <i class="fa fa-chevron-left"></i> Maven
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/22/Java%E4%B8%ADString%E5%92%8Cint%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/" rel="next" title="Java中String和int之间的相互转换">
                  Java中String和int之间的相互转换 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
