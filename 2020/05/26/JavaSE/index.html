<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1.    计算机基础知识1.1    进制 二进制二进制系统中，每一个0或1就是一个位，都代表一个 bit（比特）。 二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。 原码、反码、补码的说明：    正数：三码合一  负数：    原码：直接将一个数值转换成二进制数，最高位是符号位。   负数的反码：是对原码按位取反，只是最高位（符号位）确定为1.   负数的补码：对其反码加">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE">
<meta property="og:url" content="http://example.com/2020/05/26/JavaSE/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.    计算机基础知识1.1    进制 二进制二进制系统中，每一个0或1就是一个位，都代表一个 bit（比特）。 二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。 原码、反码、补码的说明：    正数：三码合一  负数：    原码：直接将一个数值转换成二进制数，最高位是符号位。   负数的反码：是对原码按位取反，只是最高位（符号位）确定为1.   负数的补码：对其反码加">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210723103449876.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730120058217.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730120129684.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210723103635390.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E5%AD%97%E8%8A%82.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E7%BC%96%E7%A0%81%E8%A1%A8.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210723095928287.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20200618234423180.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/Java%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%843%E4%B8%AA%E6%AD%A5%E9%AA%A4.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/20200625193023765.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210723102237987.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%886%E7%B1%BB%EF%BC%89.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E7%B1%BB.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E5%90%8C%E4%B8%80%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210723101625081.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730094044842.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E5%85%B3%E9%94%AE%E5%AD%97.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730094359137.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730094602848.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E9%9D%99%E6%80%81%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730173311690.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%90%8E%E6%88%90%E5%91%98%E7%9A%84%E7%89%B9%E7%82%B9.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730212054243.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210731003259648.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210731003735380.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730215015521.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730221022919.png">
<meta property="og:image" content="http://example.com/2020/05/26/JavaSE/image-20210730221227422.png">
<meta property="article:published_time" content="2020-05-26T14:12:58.000Z">
<meta property="article:modified_time" content="2021-08-13T09:13:28.121Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/05/26/JavaSE/image-20210723103449876.png">


<link rel="canonical" href="http://example.com/2020/05/26/JavaSE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2020/05/26/JavaSE/","path":"2020/05/26/JavaSE/","title":"JavaSE"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JavaSE | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">1.    计算机基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E8%BF%9B%E5%88%B6"><span class="nav-number">1.1.</span> <span class="nav-text">1.1    进制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">二进制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.2.</span> <span class="nav-text">进制转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%AD%97%E8%8A%82"><span class="nav-number">1.2.</span> <span class="nav-text">1.2    字节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">1.3    常见的编码表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-ASCII%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">1.4    ASCII编码表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.  编码表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Java%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-number">2.</span> <span class="nav-text">2.    Java语言开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94JVM"><span class="nav-number">2.1.</span> <span class="nav-text">2.1    Java虚拟机——JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1    JVM虚拟机的内存划分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">1、内存的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">2、JVM的内存划分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-JVM-amp-JRE-amp-JDK"><span class="nav-number">2.2.</span> <span class="nav-text">2.2    JVM &amp; JRE &amp; JDK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-JavaBean%E2%80%94%E2%80%94%E6%A0%87%E5%87%86%E4%BB%A3%E7%A0%81"><span class="nav-number">2.3.</span> <span class="nav-text">2.3    JavaBean——标准代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">3.    Java程序的执行原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Java%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%843%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.</span> <span class="nav-text">3.1.    Java程序执行的3个步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%BC%96%E8%AF%91-amp-%E8%A7%A3%E9%87%8A-amp-%E8%BF%90%E8%A1%8C"><span class="nav-number">3.2.</span> <span class="nav-text">3.2    编译 &amp; 解释 &amp; 运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-main-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">3.2    main() 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%85%B6%E5%AE%83"><span class="nav-number">3.4.</span> <span class="nav-text">3.4    其它</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">4.    变量的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%8C%89%E7%85%A7%E7%B1%BB%E5%88%AB%E5%88%92%E5%88%86"><span class="nav-number">4.1.</span> <span class="nav-text">4.1    按照类别划分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 、基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">字符型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2%E3%80%81%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2、引用数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-class%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">1.    class作为成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-interface%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">2.    interface作为成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-interface%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">3.    interface作为方法参数和返回值类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%8C%89%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%88%86%E7%B1%BB"><span class="nav-number">4.2.</span> <span class="nav-text">4.2    按声明的位置分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%8C%89%E7%85%A7%E6%98%AF%E5%90%A6%E5%8F%AF%E5%8F%98%E5%88%92%E5%88%86"><span class="nav-number">4.3.</span> <span class="nav-text">4.2    按照是否可变划分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1%E3%80%81%E5%B8%B8%E9%87%8F"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.2.1、常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-1-%E5%88%86%E7%B1%BB"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">4.2.2.1  分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2%E3%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.2.2、变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-1%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">4.2.2.1、变量的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.3.2.1.1.</span> <span class="nav-text">1.  格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%841%EF%BC%9A"><span class="nav-number">4.3.2.1.2.</span> <span class="nav-text">附1：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.4.</span> <span class="nav-text">4.3    数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%8F%AA%E6%B6%89%E5%8F%8A7%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%8D%E5%8C%85%E6%8B%ACBoolean%EF%BC%89"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.3.1    自动类型转换（只涉及7种基本数据类型，不包括Boolean）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2-%E5%8F%AA%E6%B6%89%E5%8F%8A7%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.3.2    强制转换(只涉及7种基本数据类型）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2-vs-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.4.3.</span> <span class="nav-text">4.3.3    自动转换 vs. 强制转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">5.    运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.1.</span> <span class="nav-text">5.1    算术运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.2.</span> <span class="nav-text">5.2    赋值运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.3.</span> <span class="nav-text">5.3    比较运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.4.</span> <span class="nav-text">5.4    逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.5.</span> <span class="nav-text">5.5    三元运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">6.    流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">6.1    顺序结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">6.2    分支结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if-else"><span class="nav-number">6.2.1.</span> <span class="nav-text">if-else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-case"><span class="nav-number">6.2.2.</span> <span class="nav-text">switch-case</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.</span> <span class="nav-text">6.3    循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-while"><span class="nav-number">6.3.1.</span> <span class="nav-text">1.    while</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-do%E2%80%A6while"><span class="nav-number">6.3.2.</span> <span class="nav-text">2.    do…while</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-for"><span class="nav-number">6.3.3.</span> <span class="nav-text">3.    for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-for-each"><span class="nav-number">6.3.4.</span> <span class="nav-text">4.    for-each</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">6.3.5.</span> <span class="nav-text">5.    知识点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E8%B7%B3%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.4.</span> <span class="nav-text">6.5    跳出语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E6%96%B9%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">7.    方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">7.1.</span> <span class="nav-text">7.1    方法的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-return"><span class="nav-number">7.1.1.</span> <span class="nav-text">关键字 return</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E4%B8%AA%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.2.</span> <span class="nav-text">可变形参个数的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.2.</span> <span class="nav-text">7.2    方法的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.2.1    方法的返回值类型、参数类型详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB"><span class="nav-number">7.3.</span> <span class="nav-text">7.3    方法分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E9%87%8D%E8%BD%BD"><span class="nav-number">7.4.</span> <span class="nav-text">7.4    重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E9%87%8D%E5%86%99"><span class="nav-number">7.5.</span> <span class="nav-text">7.5    重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E9%87%8D%E8%BD%BD-vs-%E9%87%8D%E5%86%99"><span class="nav-number">7.6.</span> <span class="nav-text">7.5 重载 vs.重写</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">8.    类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E7%B1%BB%E7%BB%93%E6%9E%84%EF%BC%884%E5%A4%A76%E5%B0%8F%E6%88%90%E5%91%98%EF%BC%89"><span class="nav-number">8.1.</span> <span class="nav-text">8.1    类结构（4大6小成员）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-%E5%B1%9E%E6%80%A7%EF%BC%88%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">8.1.1.</span> <span class="nav-text">8.1.1    属性（变量）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-vs-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">成员变量 vs. 局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F-amp-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">类变量 &amp; 实例变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-%E6%96%B9%E6%B3%95"><span class="nav-number">8.1.2.</span> <span class="nav-text">8.1.2    方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">8.1.2.1.</span> <span class="nav-text">1、构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">8.1.2.2.</span> <span class="nav-text">2、成员方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-3-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">8.1.3.</span> <span class="nav-text">8.1.3    代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-4-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">8.1.4.</span> <span class="nav-text">8.1.4    内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">8.1.4.1.</span> <span class="nav-text">成员内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">8.1.5.</span> <span class="nav-text">8.3.3    局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">8.1.6.</span> <span class="nav-text">8.3.4    匿名内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%89%8D%E6%8F%90"><span class="nav-number">8.1.6.1.</span> <span class="nav-text">1    前提</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.1.6.2.</span> <span class="nav-text">2  格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.2.</span> <span class="nav-text">8.2    初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.2.1.</span> <span class="nav-text">8.2.1    类的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.2.2.</span> <span class="nav-text">8.2.2    成员变量初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.2.3.</span> <span class="nav-text">8.2.3    构造器初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.</span> <span class="nav-text">9.    对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">9.1.</span> <span class="nav-text">9.1    对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="nav-number">9.2.</span> <span class="nav-text">9.2    对象的销毁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">9.3.</span> <span class="nav-text">9.3    对象的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">9.4.</span> <span class="nav-text">9.4    对象在内存中的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">9.4.1.</span> <span class="nav-text">1、一个对象，调用一个方法内存图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">9.4.2.</span> <span class="nav-text">2.    两个对象，调用一个方法内存图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.5.</span> <span class="nav-text">9.5    匿名对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">9.5.1.</span> <span class="nav-text">9.5.1.    应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">10.</span> <span class="nav-text">10    关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">10.1.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">10.2.</span> <span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">10.2.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%883%E4%B8%AA%EF%BC%89"><span class="nav-number">10.3.</span> <span class="nav-text">权限修饰符（3个）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-number">10.4.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">10.5.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extends"><span class="nav-number">10.6.</span> <span class="nav-text">extends</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implements"><span class="nav-number">10.7.</span> <span class="nav-text">implements</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#abstract"><span class="nav-number">10.8.</span> <span class="nav-text">abstract</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%B0%81%E8%A3%85"><span class="nav-number">11.</span> <span class="nav-text">11    封装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%B0%81%E8%A3%85%EF%BC%9F"><span class="nav-number">11.1.</span> <span class="nav-text">11.1    为什么要有封装？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8F%90%E7%8E%B0"><span class="nav-number">11.2.</span> <span class="nav-text">11.2    封装思想的代码提现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">11.3.</span> <span class="nav-text">11.3    权限修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-%E5%B0%81%E8%A3%85%E4%BC%98%E5%8C%96"><span class="nav-number">11.4.</span> <span class="nav-text">11.3    封装优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">11.4.1.</span> <span class="nav-text">1.    this关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">11.4.2.</span> <span class="nav-text">2.    构造方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E7%BB%A7%E6%89%BF"><span class="nav-number">12.</span> <span class="nav-text">12    继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">12.1.</span> <span class="nav-text">是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%EF%BC%9F"><span class="nav-number">12.2.</span> <span class="nav-text">为什么要有？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">12.3.</span> <span class="nav-text">继承后的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">12.3.1.</span> <span class="nav-text">1.    成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95"><span class="nav-number">12.3.2.</span> <span class="nav-text">2.    普通方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">12.3.3.</span> <span class="nav-text">3.    构造方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super-amp-this"><span class="nav-number">12.4.</span> <span class="nav-text">super &amp; this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">12.5.</span> <span class="nav-text">子类对象实例化全过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object"><span class="nav-number">12.6.</span> <span class="nav-text">Object</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">13.</span> <span class="nav-text">13    抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">13.1.</span> <span class="nav-text">13.1    概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-abstract"><span class="nav-number">13.2.</span> <span class="nav-text">13.2    abstract</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">13.2.1.</span> <span class="nav-text">抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="nav-number">13.2.1.1.</span> <span class="nav-text">抽象类结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">13.2.2.</span> <span class="nav-text">抽象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">13.2.3.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="nav-number">13.2.4.</span> <span class="nav-text">设计模式——模板方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E6%8E%A5%E5%8F%A3"><span class="nav-number">14.</span> <span class="nav-text">14    接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-number">14.1.</span> <span class="nav-text">14.1    接口中的成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E6%AF%94%E8%BE%83"><span class="nav-number">14.1.1.</span> <span class="nav-text">接口、普通类、抽象类中的成员比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-%E6%8E%A5%E5%8F%A3-vs-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">14.2.</span> <span class="nav-text">14.2    接口 vs.抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E8%AF%A6%E8%A7%A3"><span class="nav-number">14.3.</span> <span class="nav-text">14.3    接口中的成员详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">14.3.1.</span> <span class="nav-text">1    抽象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%EF%BC%88JDK8-%EF%BC%89"><span class="nav-number">14.3.2.</span> <span class="nav-text">2    默认方法（JDK8++）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88JDK8-%EF%BC%89"><span class="nav-number">14.3.3.</span> <span class="nav-text">3     静态方法（JDK8++）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">14.3.4.</span> <span class="nav-text">4    私有方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-4-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.4.</span> <span class="nav-text">14.4    接口的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%9D%9E%E6%8A%BD%E8%B1%A1%E5%AD%90%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">14.4.1.</span> <span class="nav-text">1  非抽象子类实现接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.4.2.</span> <span class="nav-text">2.    接口的多实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98"><span class="nav-number">14.4.2.1.</span> <span class="nav-text">优先级问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-5-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">14.5.</span> <span class="nav-text">14.5    接口的多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%841%EF%BC%9A-1"><span class="nav-number">14.5.0.1.</span> <span class="nav-text">附1：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-6-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">14.6.</span> <span class="nav-text">14.6    接口中的注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E5%A4%9A%E6%80%81"><span class="nav-number">15.</span> <span class="nav-text">15    多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">15.1.</span> <span class="nav-text">15.1    是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-amp-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">15.2.</span> <span class="nav-text">15.2    向上转型 &amp; 向下转型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="nav-number">15.2.1.</span> <span class="nav-text">1.    向上转型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">15.2.2.</span> <span class="nav-text">2.    向下转型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AF%B9%E6%AF%94"><span class="nav-number">15.2.3.</span> <span class="nav-text">3    对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-3-%E6%8E%A5%E5%8F%A3%E5%A4%9A%E6%80%81%E7%9A%84%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="nav-number">15.3.</span> <span class="nav-text">15.3    接口多态的综合案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91"><span class="nav-number">15.3.1.</span> <span class="nav-text">1.    笔记本电脑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">15.3.2.</span> <span class="nav-text">2.    案例分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">15.3.3.</span> <span class="nav-text">3.    案例实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">16.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">17.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO-%E6%B5%81"><span class="nav-number">18.</span> <span class="nav-text">IO 流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89"><span class="nav-number">19.</span> <span class="nav-text">容器（数组 + 集合）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">20.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">21.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">22.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">23.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object-%E7%B1%BB"><span class="nav-number">24.</span> <span class="nav-text">Object 类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">25.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">25.1.</span> <span class="nav-text">为什么要有包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">25.2.</span> <span class="nav-text">基本数据类型与对应的包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9A%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81String%EF%BC%89"><span class="nav-number">25.3.</span> <span class="nav-text">需要掌握的类型间的转换：（基本数据类型、包装类、String）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String"><span class="nav-number">26.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">27.</span> <span class="nav-text">Java 比较器</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/26/JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JavaSE | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaSE
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-05-26 22:12:58" itemprop="dateCreated datePublished" datetime="2020-05-26T22:12:58+08:00">2020-05-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-13 17:13:28" itemprop="dateModified" datetime="2021-08-13T17:13:28+08:00">2021-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-计算机基础知识"><a href="#1-计算机基础知识" class="headerlink" title="1.    计算机基础知识"></a>1.    计算机基础知识</h1><h2 id="1-1-进制"><a href="#1-1-进制" class="headerlink" title="1.1    进制"></a>1.1    进制</h2><p><img src="/2020/05/26/JavaSE/image-20210723103449876.png" alt="image-20210723103449876"></p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>二进制系统中，每一个0或1就是一个<strong>位</strong>，都代表一个 <strong>bit（比特）</strong>。</p>
<p><strong>二进制数据的存储方式</strong>：所有的数值，不管正负，底层都以补码的方式存储。</p>
<p><strong>原码、反码、补码的说明：</strong></p>
<ul>
<li><p>  <strong>正数</strong>：三码合一</p>
</li>
<li><p><strong>负数</strong>：</p>
<blockquote>
<p>  <strong>原码：</strong>直接将一个数值转换成二进制数，最高位是符号位。</p>
<p>  <strong>负数的反码：</strong>是对原码按位取反，只是最高位（符号位）确定为1.</p>
<p>  <strong>负数的补码：</strong>对其反码加 1。</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/05/26/JavaSE/image-20210730120058217.png" alt="image-20210730120058217"></p>
<p><img src="/2020/05/26/JavaSE/image-20210730120129684.png" alt="image-20210730120129684"></p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><img src="/2020/05/26/JavaSE/image-20210723103635390.png" alt="image-20210723103635390"></p>
<h2 id="1-2-字节"><a href="#1-2-字节" class="headerlink" title="1.2    字节"></a>1.2    字节</h2><ul>
<li>8个<code>bit</code>（比特）表示1个<strong>字节</strong>，写成 <strong>1B</strong> 或者 <strong>1byte</strong> 。</li>
<li><em>字节是我们常见的计算机中的最小存储单元</em>。</li>
<li>计算机存储任何数据，都是以字节的形式存储。</li>
<li>Java 中单个汉字的所占的 存储空间为 2~4 个字节不等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8bit = 1B</span><br><span class="line">1024B = 1KB</span><br><span class="line">1024KB = 1MB</span><br><span class="line">1024MB = 1GB</span><br><span class="line">1024GB = 1TB</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/26/JavaSE/%E5%AD%97%E8%8A%82.png" alt="字节"></p>
<h2 id="1-3-常见的编码表"><a href="#1-3-常见的编码表" class="headerlink" title="1.3    常见的编码表"></a>1.3    常见的编码表</h2><table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ASCII</strong></td>
<td>美国标准信息交换码。用一个字节的7位可以表示。</td>
</tr>
<tr>
<td><strong>ISO8859-1</strong></td>
<td>拉丁码表。欧洲码表。用一个字节的8位表示。</td>
</tr>
<tr>
<td><strong>GB2312</strong></td>
<td>中国的中文编码表。最多两个字节编码所有字符</td>
</tr>
<tr>
<td><strong>GBK</strong></td>
<td>中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</td>
</tr>
<tr>
<td><strong>Unicode</strong></td>
<td>国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</td>
</tr>
<tr>
<td><strong>UTF-8</strong></td>
<td>变长的编码方式，可用1-4个字节来表示一个字符。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-4-ASCII编码表"><a href="#1-4-ASCII编码表" class="headerlink" title="1.4    ASCII编码表"></a>1.4    ASCII编码表</h2><ul>
<li>计算机只能识别二进制的0或1，那如何用二进制数据表示人类的文字呢？这就用到了编码表！</li>
</ul>
<h3 id="1-编码表"><a href="#1-编码表" class="headerlink" title="1.  编码表"></a>1.  编码表</h3><ol>
<li><strong>概念：</strong><ul>
<li>就是将人类的文字（最初是英文）和一个十进制数字对应起来的一个表格。</li>
<li>十进制数字又可以进一步转换为二进制数字表示。</li>
<li>这样就实现了用二进制数表示人类的文字（英文、中文等）。</li>
</ul>
</li>
<li><strong>ASCII 编码表</strong><ul>
<li><em>将所有的英文字母、数字、符号都和十进制进行了对应，产生了世界上第一张编码表 ASCII</em></li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">48</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">57</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">97</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">122</td>
</tr>
</tbody></table>
<p><img src="/2020/05/26/JavaSE/%E7%BC%96%E7%A0%81%E8%A1%A8.png" alt="编码表"></p>
<hr>
<h1 id="2-Java语言开发环境"><a href="#2-Java语言开发环境" class="headerlink" title="2.    Java语言开发环境"></a>2.    Java语言开发环境</h1><h2 id="2-1-Java虚拟机——JVM"><a href="#2-1-Java虚拟机——JVM" class="headerlink" title="2.1    Java虚拟机——JVM"></a>2.1    Java虚拟机——JVM</h2><ul>
<li><strong>JVM</strong>（Java Virtual Machine）：Java虚拟机，简称JVM。</li>
<li>跨平台。</li>
</ul>
<h3 id="2-1-1-JVM虚拟机的内存划分"><a href="#2-1-1-JVM虚拟机的内存划分" class="headerlink" title="2.1.1    JVM虚拟机的内存划分"></a>2.1.1    JVM虚拟机的内存划分</h3><h4 id="1、内存的概念"><a href="#1、内存的概念" class="headerlink" title="1、内存的概念"></a>1、内存的概念</h4><blockquote>
<p>内存是用来<strong>存储临时数据</strong>的（即断电后数据消失），它主要负责：硬盘等硬件上的数据和CPU之间的数据交换处理，也起到缓存系统中的临时数据的作用。在计算机中，它直接和CPU交换数据。</p>
<p><a href>内存，外存和CPU的关系</a></p>
</blockquote>
<ul>
<li>我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须先加载进内存中，然后由CPU运行程序，运行完毕后会清空内存。</li>
<li>JVM虚拟机要运行程序，必须要对内存进行空间的分配和管理。</li>
</ul>
<h4 id="2、JVM的内存划分"><a href="#2、JVM的内存划分" class="headerlink" title="2、JVM的内存划分"></a>2、JVM的内存划分</h4><blockquote>
<p>为了提高运算效率，JVM对内存空间进行了不同区域的划分。每一片区域都有特定的处理数据方式和内存管理方式。</p>
</blockquote>
<p><strong>JVM的内存划分</strong>：</p>
<table>
<thead>
<tr>
<th align="center">区域名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器</td>
<td align="center">给CPU使用，与开发无关。运行速度最快</td>
</tr>
<tr>
<td align="center">本地方法栈</td>
<td align="center">JVM在操作系统功能时调用，与开发无关。</td>
</tr>
<tr>
<td align="center">方法区</td>
<td align="center">存储<code>1、Class对象</code>，<code>2、类中的成员方法</code>，<code>3、static修饰的一切</code></td>
</tr>
<tr>
<td align="center">堆内存</td>
<td align="center">用于存放所有的Java<code>对象</code>，<strong>new出来的，都存储在堆内存(包括String和数组)。</strong></td>
</tr>
<tr>
<td align="center">方法栈</td>
<td align="center"><code>方法</code>运行时使用的内存，比如main()方法运行，进入方法栈中执行。<code>对象引用</code>保存在栈中。</td>
</tr>
</tbody></table>
<ul>
<li><code>方法区</code>中有一块内存被称为<code>静态区</code>，所有被<code>static</code>修饰的内容（包括静态方法、静态变量、静态代码块）都位于静态区中。</li>
</ul>
<hr>
<h2 id="2-2-JVM-amp-JRE-amp-JDK"><a href="#2-2-JVM-amp-JRE-amp-JDK" class="headerlink" title="2.2    JVM &amp; JRE &amp; JDK"></a>2.2    JVM &amp; JRE &amp; JDK</h2><p><img src="/2020/05/26/JavaSE/image-20210723095928287.png" alt="image-20210723095928287"></p>
<ul>
<li><strong>JVM</strong>：字节码文件运行的平台</li>
<li><strong>JRE</strong>（Java Runtime Environment）：JVM + Java核心类库 + 其它【==&gt; 只能运行编译好的 <code>.class</code> 文件】</li>
<li><strong>JDK</strong>（Java Development Kit）：JRE + Javac编译器 + 其它【==&gt; 编译、运行一条龙服务】</li>
<li>三者关系：<strong>JDK &gt; JRE &gt; JVM</strong></li>
</ul>
<p><img src="/2020/05/26/JavaSE/image-20200618234423180.png" alt="image-20200618234423180"></p>
<hr>
<h2 id="2-3-JavaBean——标准代码"><a href="#2-3-JavaBean——标准代码" class="headerlink" title="2.3    JavaBean——标准代码"></a>2.3    JavaBean——标准代码</h2><ul>
<li><code>JavaBean</code>是Java语言编写类的一种标准规范。</li>
<li>符合<code>JavaBean</code>的类，要求类必须是<strong>具体的和公共的</strong>，并且<strong>具有无参的构造方法</strong>，提供用来操作成员变量的**<code>set</code>和<code>get</code>方法**。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// 无参构造方法【必须】</span></span><br><span class="line">    <span class="comment">// 有参构造方法【建议】</span></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="comment">// getXxx()</span></span><br><span class="line">    <span class="comment">// setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-Java程序的执行原理"><a href="#3-Java程序的执行原理" class="headerlink" title="3.    Java程序的执行原理"></a>3.    Java程序的执行原理</h1><h2 id="3-1-Java程序执行的3个步骤"><a href="#3-1-Java程序执行的3个步骤" class="headerlink" title="3.1.    Java程序执行的3个步骤"></a>3.1.    Java程序执行的3个步骤</h2><p><strong>编写 –&gt; 编译 –&gt; 运行</strong></p>
<p><img src="/2020/05/26/JavaSE/Java%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%843%E4%B8%AA%E6%AD%A5%E9%AA%A4.png"></p>
<blockquote>
<ol>
<li> <strong>编写</strong></li>
</ol>
</blockquote>
<ul>
<li>程序员编写的源程序是<code>.java</code>格式的，JVM 是看不懂这种格式的文件的，因此我们必须把编写好的 <code>.java</code>源文件编译为 JVM 可以识别的二进制字节码文件，即 <code>.class</code> 文件。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>编译</strong></li>
</ol>
</blockquote>
<ul>
<li><p>使用 <code>javac.exe</code> 命令编译我们的 java 源文件。</p>
</li>
<li><p>步骤：在DOS命令窗口中，进入java源文件所在的目录，使用<code>javac</code>命令进行编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac Java源文件名.后缀名</span><br><span class="line"></span><br><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>运行</strong></li>
</ol>
</blockquote>
<ul>
<li><p>使用 <code>java.exe</code> 命令解释运行我们的字节码文件。</p>
</li>
<li><p>步骤：在DOS命令窗口中，进入java源文件所在的目录，使用<code>java</code>命令进行编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java 类名</span><br><span class="line">    </span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-2-编译-amp-解释-amp-运行"><a href="#3-2-编译-amp-解释-amp-运行" class="headerlink" title="3.2    编译 &amp; 解释 &amp; 运行"></a>3.2    编译 &amp; 解释 &amp; 运行</h2><blockquote>
<p>  <strong>编译 &amp; 运行</strong></p>
</blockquote>
<ol>
<li><strong>编译</strong>：将 <code>.java</code> 源文件一次性翻译成 <code>.class</code> 字节码文件。</li>
<li><strong>运行</strong>：将<code>.class</code>文件交给<code>JVM</code>去执行。</li>
</ol>
<blockquote>
<p>  <strong>编译 &amp; 解释</strong></p>
</blockquote>
<ul>
<li><strong>编译</strong>：将源代码一次性转换成<code>二进制文件</code>的过程。</li>
<li><strong>解释</strong>：将源代码逐条转换成<code>二进制文件</code>的过程。</li>
</ul>
<p>Java 是一门半解释半编译型语言。</p>
<hr>
<h2 id="3-2-main-方法"><a href="#3-2-main-方法" class="headerlink" title="3.2    main() 方法"></a>3.2    main() 方法</h2><ol>
<li><p><code>main()</code>方法称为主方法，是一切程序的入口。</p>
</li>
<li><p><code>main()</code> 方法也是一个普通的静态方法。</p>
</li>
<li><p><code>main()</code> 方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</p>
</li>
<li><p>如何将控制台获取的数据传给形参：<code>String[] args</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在控制台上输入：</span></span><br><span class="line">java [类名] <span class="string">&quot;Tom&quot;</span> <span class="string">&quot;Jerry&quot;</span> <span class="string">&quot;123&quot;</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(args[<span class="number">0</span>]);	<span class="comment">// &quot;Tom&quot;</span></span><br><span class="line">        System.out.println(args[<span class="number">3</span>]);	<span class="comment">// &quot;true&quot;</span></span><br><span class="line">        System.out.println(args[<span class="number">4</span>]);	<span class="comment">// 异常，数组下标越界</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-4-其它"><a href="#3-4-其它" class="headerlink" title="3.4    其它"></a>3.4    其它</h2><blockquote>
<p>  <strong>在一个 java 源文件中可以声明几个 class ？</strong></p>
</blockquote>
<p>在一个 java 源文件中可以声明多个 class。但是，只能最多有一个类声明为 public 的。而且要求声明为 public 的类的类名必须与源文件名相同。</p>
<blockquote>
<p>  <strong>编译的过程</strong></p>
</blockquote>
<p>编译以后，一个 <code>.java</code> 源文件会生成<strong>一个或多个字节码文件</strong>（如果含有内部类就会生成多个字节码文件）。字节码文件的文件名与 java 源文件中的类名相同。</p>
<hr>
<h1 id="4-变量的分类"><a href="#4-变量的分类" class="headerlink" title="4.    变量的分类"></a>4.    变量的分类</h1><h2 id="4-1-按照类别划分"><a href="#4-1-按照类别划分" class="headerlink" title="4.1    按照类别划分"></a>4.1    按照类别划分</h2><img src="/2020/05/26/JavaSE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="数据类型" style="zoom:50%;">

<h3 id="4-1-1-、基本数据类型"><a href="#4-1-1-、基本数据类型" class="headerlink" title="4.1.1 、基本数据类型"></a>4.1.1 、基本数据类型</h3><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">内存占用</th>
<th align="center">取值范围</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节型</td>
<td align="center">byte</td>
<td align="center">1个字节</td>
<td align="center">-2^7^ ~ 2^7^-1【2^8^】</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2个字节</td>
<td align="center">-2^15^ ~ 2^15^-1【2^16^】</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">4个字节</td>
<td align="center">-2^31^ ~ 2^31^-1【2^32^】</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">长整形</td>
<td align="center">long</td>
<td align="center">8个字节</td>
<td align="center">-2^63^ ~ 2^63^-1【2^64^】</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">单精度浮点数</td>
<td align="center">float</td>
<td align="center">4个字节</td>
<td align="center"></td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">双精度浮点数</td>
<td align="center">double（默认）</td>
<td align="center">8个字节</td>
<td align="center"></td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">2个字节</td>
<td align="center">0~2^16^</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">布尔类型</td>
<td align="center">boolean</td>
<td align="center">1个字节</td>
<td align="center">true/ false</td>
<td align="center">false</td>
</tr>
</tbody></table>
<blockquote>
<p>  附：</p>
<ul>
<li>  long类型：建议数据后加L表示</li>
<li>  float类型：建议数据后加F表示</li>
</ul>
</blockquote>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><blockquote>
<p>  <strong>为什么4个字节的 float 表示数值的范围比8个字节的 long 还大？</strong></p>
</blockquote>
<p><img src="/2020/05/26/JavaSE/20200625193023765.png" alt="img"></p>
<p>整数在计算机底层采用补码的形式表示，除去首位的符号位，剩余的位数即表示数值的范围，也就是<strong>位数越多，范围越大</strong>。</p>
<p>而对于单精度浮点数 float 和双精度浮点数 double，它们底层的数据结构是由 <strong>符号位 + 指数位 + 尾数位</strong> 组成的，中间的8位是指数位，尾数位表示小数的范围。</p>
<p>指数位有 8 位，即最高取到 128，底数固定为 2，即最大范围约等于  <strong>2^-128^ ~ 2^128^</strong> 之间，显然大于 long 类型的数据。</p>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p><strong>表示方式</strong></p>
<ol>
<li> 显式地声明一个字符</li>
<li> 转义字符</li>
<li> 直接使用 Unicode 值来表示字符型常量</li>
</ol>
<hr>
<h3 id="4-1-2、引用数据类型"><a href="#4-1-2、引用数据类型" class="headerlink" title="4.1.2、引用数据类型"></a>4.1.2、引用数据类型</h3><ul>
<li>除了基本类型剩下的数据都是引用类型。</li>
<li>基本类型数据可以作为成员变量、作为方法的参数，作为方法的返回值，那么当然引用类型也是可以的。*[引用类型数据的使用范围大于等于基本类型数据]*</li>
</ul>
<h4 id="1-class作为成员变量"><a href="#1-class作为成员变量" class="headerlink" title="1.    class作为成员变量"></a>1.    class作为成员变量</h4><ul>
<li><p>定义一个类<code>Role</code>（游戏角色）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> blood;  <span class="comment">//生命值</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时<code>String</code>本身就是引用类型，由于使用的方式类似常量，所以往往忽略了他是引用类型的存在。如果我们继续丰富这个类的定义，给<code>Role</code>增加武器，穿戴装备等属性，将如何编写呢？</p>
</blockquote>
</li>
<li><p>定义武器类<code>Weapon</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123; <span class="comment">// 武器</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 武器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hurt;   <span class="comment">// 伤害值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义防具类<code>Armor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Armor</span> &#123;    <span class="comment">// 防具</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> protect;    <span class="comment">// 护甲/魔抗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义角色类<code>Role</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> blood;  <span class="comment">//生命值</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Weapon wp;  <span class="comment">// 添加武器属性</span></span><br><span class="line">    <span class="keyword">private</span> Armor ar;   <span class="comment">// 添加防具属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 攻击方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span>+wp.getName()+<span class="string">&quot;造成了&quot;</span>+wp.getHurt()+<span class="string">&quot;点伤害&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防御方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defense</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span>+ar.getName()+<span class="string">&quot;抵挡了&quot;</span>+ar.getProtect()+<span class="string">&quot;点伤害&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">wp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weapon</span>(<span class="string">&quot;终默之焉&quot;</span>, <span class="number">666</span>);</span><br><span class="line">        <span class="type">Armor</span> <span class="variable">ar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Armor</span>(<span class="string">&quot;新手盾牌&quot;</span>,<span class="number">999</span>);</span><br><span class="line">        <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Role</span>(<span class="number">7</span>, <span class="number">100</span>, <span class="string">&quot;执行者&quot;</span>, wp, ar);</span><br><span class="line"></span><br><span class="line">        role.attack();</span><br><span class="line">        role.defense();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出结果：</span></span><br><span class="line"><span class="comment">    ——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">            使用终默之焉造成了666点伤害</span></span><br><span class="line"><span class="comment">            使用新手盾牌抵挡了999点伤害</span></span><br><span class="line"><span class="comment">    ——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>类作为成员变量时，对它进行赋值的操作，实际上是<strong>赋给它该类的一个实例对象</strong>。</p>
</li>
</ul>
<hr>
<h4 id="2-interface作为成员变量"><a href="#2-interface作为成员变量" class="headerlink" title="2.    interface作为成员变量"></a>2.    interface作为成员变量</h4><ul>
<li>接口不能直接 new，但是可以接收一个子类对象。</li>
<li>接口作为成员变量时，对它进行赋值操作，实际上是 <strong>赋给它该接口的一个子类实例对象</strong>。</li>
</ul>
<h4 id="3-interface作为方法参数和返回值类型"><a href="#3-interface作为方法参数和返回值类型" class="headerlink" title="3.    interface作为方法参数和返回值类型"></a>3.    interface作为方法参数和返回值类型</h4><ul>
<li><strong>接口作为方法参数时，传递的是它的子类实例对象。</strong></li>
<li><strong>接口作为返回值类型时，返回的是它的子类实例对象。</strong></li>
</ul>
<hr>
<h2 id="4-2-按声明的位置分类"><a href="#4-2-按声明的位置分类" class="headerlink" title="4.2    按声明的位置分类"></a>4.2    按声明的位置分类</h2><p><img src="/2020/05/26/JavaSE/image-20210723102237987.png" alt="image-20210723102237987"></p>
<hr>
<h2 id="4-2-按照是否可变划分"><a href="#4-2-按照是否可变划分" class="headerlink" title="4.2    按照是否可变划分"></a>4.2    按照是否可变划分</h2><h3 id="4-2-1、常量"><a href="#4-2-1、常量" class="headerlink" title="4.2.1、常量"></a>4.2.1、常量</h3><ul>
<li><strong>常量：</strong>是指在 Java 程序中固定不变的数据。</li>
</ul>
<h4 id="4-2-2-1-分类"><a href="#4-2-2-1-分类" class="headerlink" title="4.2.2.1  分类"></a>4.2.2.1  分类</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数常量</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">小数常量</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">字符常量</td>
<td align="center"><strong>单引号</strong>引起来，只能写一个字符，必须有内容</td>
<td align="center">‘a’, ‘[空格]’, ‘好’</td>
</tr>
<tr>
<td align="center">字符串常量</td>
<td align="center"><strong>双引号</strong>引起来，可以写多个字符，也可以不写</td>
<td align="center">“A”, “Hello”, “你好”, “”</td>
</tr>
<tr>
<td align="center">布尔常量</td>
<td align="center"><code>false/true</code></td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">空常量</td>
<td align="center"><code>null</code></td>
<td align="center">–</td>
</tr>
</tbody></table>
<h3 id="4-2-2、变量"><a href="#4-2-2、变量" class="headerlink" title="4.2.2、变量"></a>4.2.2、变量</h3><ul>
<li><strong>变量：</strong>常量是固定不变的数据，那么在程序中可以变化的量称为变量。</li>
<li>Java 中要求每个变量每一次只能保存一个数据，且必须明确保存的数据类型。</li>
</ul>
<h4 id="4-2-2-1、变量的定义"><a href="#4-2-2-1、变量的定义" class="headerlink" title="4.2.2.1、变量的定义"></a>4.2.2.1、变量的定义</h4><h5 id="1-格式"><a href="#1-格式" class="headerlink" title="1.  格式"></a>1.  格式</h5><ul>
<li><p>变量定义的格式包括3个要素：</p>
<ol>
<li><strong>数据类型</strong></li>
<li><strong>变量名</strong></li>
<li><strong>数据值</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 数据值</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="附1："><a href="#附1：" class="headerlink" title="附1："></a>附1：</h5><ul>
<li>在同一个大括号范围内，变量的名字不可以相同。</li>
<li><strong>变量赋值：类中方法外的成员变量，有缺省值，不赋值可以使用。  类中方法中的值，无缺省值，不赋值不能使用。</strong></li>
</ul>
<hr>
<h2 id="4-3-数据类型转换"><a href="#4-3-数据类型转换" class="headerlink" title="4.3    数据类型转换"></a>4.3    数据类型转换</h2><blockquote>
<p><strong>Java程序中要求参与计算的数据的类型必须保持一致，如果数据类型不一致将发生类型的转换。</strong></p>
</blockquote>
<h3 id="4-3-1-自动类型转换（只涉及7种基本数据类型，不包括Boolean）"><a href="#4-3-1-自动类型转换（只涉及7种基本数据类型，不包括Boolean）" class="headerlink" title="4.3.1    自动类型转换（只涉及7种基本数据类型，不包括Boolean）"></a>4.3.1    自动类型转换（只涉及7种基本数据类型，不包括Boolean）</h3><p><strong>结论：</strong>当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p>
<p><strong>原理：</strong>Java 程序要求参与运算的数据类型必须一致，若不一致将被自动转换。当容量小的数据类型变量与容量大的数据类型变量进行运算时，将取值范围大的数据转换为取值范围小的数据可能会发生数据损失，所以 Java 程序会自动将取值范围小的数据类型转换为取值范围大的数据类型。</p>
<p><strong>转换规则：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> 、<span class="type">char</span> 、<span class="type">short</span> --&gt; <span class="type">int</span> --&gt; <span class="type">long</span> --&gt; <span class="type">float</span> --&gt; <span class="type">double</span> </span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>当 byte、char、short 三种类型的变量做运算时，结果为 int 型。</p>
<h3 id="4-3-2-强制转换-只涉及7种基本数据类型）"><a href="#4-3-2-强制转换-只涉及7种基本数据类型）" class="headerlink" title="4.3.2    强制转换(只涉及7种基本数据类型）"></a>4.3.2    强制转换(只涉及7种基本数据类型）</h3><p><strong>强制类型转换</strong>：将<code>取值范围大的类型</code>转换为<code>取值范围小的类型</code>。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = (数据类型)待转换数据值</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>强制类型转换，可能导致精度损失。</p>
<h3 id="4-3-3-自动转换-vs-强制转换"><a href="#4-3-3-自动转换-vs-强制转换" class="headerlink" title="4.3.3    自动转换 vs. 强制转换"></a>4.3.3    自动转换 vs. 强制转换</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">自动类型转换</th>
<th align="center">强制类型转换</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Java程序自动执行</td>
<td align="center">手动执行</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">不会出现数据的损失</td>
<td align="center">可能会出现数据的损失</td>
</tr>
</tbody></table>
<hr>
<h1 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5.    运算符"></a>5.    运算符</h1><img src="/2020/05/26/JavaSE/%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%886%E7%B1%BB%EF%BC%89.png" alt="运算符（6类）" style="zoom: 50%;">





<h2 id="5-1-算术运算符"><a href="#5-1-算术运算符" class="headerlink" title="5.1    算术运算符"></a>5.1    算术运算符</h2><blockquote>
<p>  <strong>取余运算结果的符号与被模数的符号相同！！！</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;	<span class="comment">// 被模数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">num11</span> <span class="operator">=</span> -<span class="number">12</span>;	<span class="comment">// 被模数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num22</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">       System.out.println(num1 % num2);    <span class="comment">// 12 % (-5) = 2</span></span><br><span class="line">       System.out.println(num11 % num2);   <span class="comment">// (-12) % (-5) = -2</span></span><br><span class="line">       System.out.println(num11 % num22);  <span class="comment">// (-12) % 5 = -2</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>在Java中，2个整数使用算术运算符，无论怎么计算，也不会得到小数</strong>。</p>
</blockquote>
<p>​        如：<code>5/2 = 2</code>。其原理是：Java要求参与运算的数据的数据类型必须保持一致，否则就会进行类型转换。2个<code>int</code>类型的数据进行运算，得到的结果如果正好是<code>int</code>类型，则可以得到准确的结果，如果运算的结果含有小数，那么Java程序就会强制浮点型数据转换为整型数据，即使结果损失了部分数据。</p>
<blockquote>
<p>  <strong><code>前++</code>和<code>后++</code>有什么区别？</strong></p>
</blockquote>
<ul>
<li>在只有一个变量的独立运算中，<code>前++</code>和<code>后++</code>没有区别。如<code>a++</code>就完全等价于<code>++a</code>；</li>
<li>如果运算包含多个变量且有赋值操作，<code>前++</code>和<code>后++</code>的到的结果则不同。如<code>b=a++</code>是先赋值再自增，而<code>b=++a</code>是先自增再赋值。</li>
</ul>
<blockquote>
<p>  <strong>+的含义？</strong></p>
</blockquote>
<ul>
<li>当<code>+</code>两边都为数值型变量时，表示数值运算；</li>
<li>当<code>+</code>两边存在字符串时，表示拼接字符串[只要存在一个字符串就表示拼接]。</li>
</ul>
<blockquote>
<p>  <strong>算术运算符需要注意优先级问题。</strong></p>
</blockquote>
<hr>
<h2 id="5-2-赋值运算符"><a href="#5-2-赋值运算符" class="headerlink" title="5.2    赋值运算符"></a>5.2    赋值运算符</h2><p>​        <code>=</code> 的意思是把<code>=</code>右边的值赋值给左边，右边的值可以是任何常数、变量或者表达式，但左边的值必须是一个明确的、已经定义好的变量。如<code>int a = 4</code>。</p>
<ol>
<li><p>对于对象来说，赋值的不是对象的值，而是对象的引用。</p>
</li>
<li><p><strong>所有的赋值运算符都被看作是一次运算，并带有强制转换的特点</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// s1 = s1 + 2;    // 编译失败</span></span><br><span class="line">    s += <span class="number">1</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	分析： s+=1 逻辑上看作是 s = s+1, 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能自动将取值范围大的类型赋值给取值范围小的类型。</span></span><br><span class="line"><span class="comment">	但是，s=s+1 进行了2步运算， 而 += 是一个运算符，只运算一次，并带有强制转换的特点，也就是说 s+=1 等价于s=(short)s+1，因此程序没有问题编译通过，运行结果是2.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>常量和变量的运算</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">2</span>;    <span class="comment">// OK</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">b4</span> <span class="operator">=</span> b1 + b2;      <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     分析：</span></span><br><span class="line"><span class="comment">         b3 = 1+2, 1和2是常量，为固定不变的数据，在编译(javac)的时候，就可以确定了1+2的结果并没有超过byte类型的取值范围，可以赋值给变量 byte b3， 因此 byte b3 = 1 + 2; 是正确的。</span></span><br><span class="line"><span class="comment">         反之， byte b4 = b1 + b2; b2 和 b3 是变量，变量的值可能是变化的，在编译的时候，编译器不能确定 b2+b3 的结果是否会超过byte的取值范围，因此会将结果以 int 类型处理，因为 int 类型不能赋值给 byte 类型，因此编译失败。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="5-3-比较运算符"><a href="#5-3-比较运算符" class="headerlink" title="5.3    比较运算符"></a>5.3    比较运算符</h2><p>比较运算符：是两个数据之间进行比较的运算。</p>
<ol>
<li> 比较运算符的结果是boolean类型</li>
<li> <code>&gt;  &lt;  &gt;=  &lt;=</code> 只能使用在数值类型的数据之间。</li>
<li> <code>==</code> 和 <code>!=</code> 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</li>
</ol>
<hr>
<h2 id="5-4-逻辑运算符"><a href="#5-4-逻辑运算符" class="headerlink" title="5.4    逻辑运算符"></a>5.4    逻辑运算符</h2><ul>
<li>逻辑运算符：是用来<strong>连接两个布尔类型</strong>结果的运算符，运行结果都是布尔值<code>true/false</code>。</li>
</ul>
<blockquote>
<p>  <strong>区分 <code>&amp;</code> 与  <code>&amp;&amp;</code></strong></p>
</blockquote>
<ul>
<li>  相同点1：<code>&amp;</code> 与 <code>&amp;&amp;</code> 的运算结果相同</li>
<li>  相同点2：当符号左边是 true 时，二者都会执行符号右边的运算</li>
<li>  不同点：当符号左边是 false 时，<code>&amp;</code> 继续执行符号右边的运算，<code>&amp;&amp;</code> 不再执行符号右边的运算。</li>
<li>  开发中，推荐使用&amp;&amp;</li>
</ul>
<blockquote>
<p>  <strong>区分：| 与 ||</strong> </p>
</blockquote>
<ul>
<li>  相同点1：<code>|</code> 与 <code>||</code> 的运算结果相同</li>
<li>  相同点2：当符号左边是 false 时，二者都会执行符号右边的运算</li>
<li>  不同点3：当符号左边是 true 时，<code>|</code> 继续执行符号右边的运算，而 <code>||</code> 不再执行符号右边的运算</li>
<li>  开发中，推荐使用 <code>||</code></li>
</ul>
<hr>
<h2 id="5-5-三元运算符"><a href="#5-5-三元运算符" class="headerlink" title="5.5    三元运算符"></a>5.5    三元运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 布尔类型表达式？结果<span class="number">1</span>：结果<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="number">1</span>==<span class="number">2</span> ? <span class="number">100</span> : <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>三元运算符可以嵌套使用</p>
<hr>
<h1 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6.    流程控制"></a>6.    流程控制</h1><img src="/2020/05/26/JavaSE/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="流程控制" style="zoom:50%;">

<h2 id="6-1-顺序结构"><a href="#6-1-顺序结构" class="headerlink" title="6.1    顺序结构"></a>6.1    顺序结构</h2><ul>
<li>默认情况下程序顺序执行。</li>
</ul>
<h2 id="6-2-分支结构"><a href="#6-2-分支结构" class="headerlink" title="6.2    分支结构"></a>6.2    分支结构</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><blockquote>
<p>  <strong>if</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	代码体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>if…else</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	代码体<span class="number">1</span>；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    代码体<span class="number">2</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>if…else  if…else</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">	代码体<span class="number">1</span>；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">    代码体<span class="number">2</span>；</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件n)&#123;</span><br><span class="line">    代码体n;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    代码体n+<span class="number">1</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">swich(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">    	语句体<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	执行流程：</span></span><br><span class="line"><span class="comment">	  1. 首先计算出表达式的值。</span></span><br><span class="line"><span class="comment">	  2. 其次，让表达式值与 case 依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。</span></span><br><span class="line"><span class="comment">	  3. 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后结束程序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li> 根据 <code>switch</code> 表达式中的值，依次匹配各个 <code>case</code> 中的常量。一旦匹配成功，则进入相应 <code>case</code> 中，调用其执行语句。当调用完执行语句以后，继续向下执行其它 <code>case</code> 结构中的执行语句，直到遇到 <code>break</code>关键字或此 <code>switch-case</code> 结构末尾结束为止。</li>
<li> <code>break</code> 可以使用在 <code>switch-case</code> 结构中，表示一旦执行到此关键字，就跳出 <code>switch-case</code> 结构。</li>
<li> <code>break</code> 关键字是可选的。</li>
<li><strong><code>switch</code>结构中的表达式，只能是如下的 6 种数据类型之一：</strong><ul>
<li>  数字类型：byte、short、char、int</li>
<li>  枚举类型(JDK5.0新增)</li>
<li>  String类型(JDK7.0新增)</li>
</ul>
</li>
<li> <strong><code>case</code> 之后只能声明常量，不能声明范围</strong>。</li>
<li> <code>default</code> 相当于 if-else 结构中的else。  </li>
<li> <code>default</code> 结构是可选的，而且位置是灵活的。</li>
</ol>
<p><strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断星期几</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (day)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期1&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期2&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期4&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期5&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期6&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期7&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;请重新输入&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-3-循环结构"><a href="#6-3-循环结构" class="headerlink" title="6.3    循环结构"></a>6.3    循环结构</h2><h3 id="1-while"><a href="#1-while" class="headerlink" title="1.    while"></a>1.    while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">初始表达式;</span><br><span class="line"><span class="keyword">while</span>(布尔表达式)&#123;</span><br><span class="line">	循环体;</span><br><span class="line">	步进表达式;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// while循环计算1~100之间的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-do…while"><a href="#2-do…while" class="headerlink" title="2.    do…while"></a>2.    do…while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">初始表达式;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">        循环体；</span><br><span class="line">        步进表达式；</span><br><span class="line">    &#125;<span class="keyword">while</span>(布尔表达式);</span><br><span class="line">        </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	do...while 循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出10次hello</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i&lt;=<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do...while 循环</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无条件执行一次&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-for"><a href="#3-for" class="headerlink" title="3.    for"></a>3.    for</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始表达式; 布尔表达式; 步进表达式)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用循环计算1~100之间的偶数和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> sum_even1();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> sum_even2();</span><br><span class="line">        System.out.println(sum1);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历1~100之间的所有数字，对这些数字再进行筛选，筛选出所有的偶数求和。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum_even2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只遍历啊1~100之间的偶数，设置步长为2，只求所有偶数的和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 1~100之间偶数之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum_even1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-for-each"><a href="#4-for-each" class="headerlink" title="4.    for-each"></a>4.    for-each</h3><blockquote>
<p>在JDK1.5++中引入了一种更加简洁的对数组和集合进行遍历的方法，即<code>for-each</code>语句。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> num: array)&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-知识点"><a href="#5-知识点" class="headerlink" title="5.    知识点"></a>5.    知识点</h3><blockquote>
<p>  <strong><code>if...else</code>语句可与<code>三元运算符</code>的关系？</strong></p>
</blockquote>
<p><code>if...else</code>语句可与<code>三元运算符</code>可互相替换。</p>
<blockquote>
<p>  <strong><code>switch</code>中case的穿透现象？</strong></p>
</blockquote>
<p>​        在switch语句中，如果case后面不写break，将出现穿透现象，也就是不会再判断下一个case的值，直接向后运行，直到到达下一个break，或者整体switch结束。</p>
<blockquote>
<p>  <strong>死循环的两种表现形式</strong></p>
</blockquote>
<p>死循环就是循环中的条件永远为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while死循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 死循环</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>如何结束一个循环结构？</strong></p>
</blockquote>
<ul>
<li>  方式一：当循环条件是false时</li>
<li>  方式二：在循环体中，执行break</li>
</ul>
<blockquote>
<p>  <strong>什么是嵌套循环？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 使用嵌套循环，打印5*8的矩形*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">8</span>; j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 内循环打印8个 *号 后，需要一次换行</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">__________________________________________________________________*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-5-跳出语句"><a href="#6-5-跳出语句" class="headerlink" title="6.5    跳出语句"></a>6.5    跳出语句</h2><blockquote>
<ol>
<li> <strong>break</strong></li>
</ol>
</blockquote>
<ul>
<li>使用场景：<ol>
<li>终止switch。</li>
<li>终止循环。</li>
</ol>
</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>continue</strong></li>
</ol>
</blockquote>
<ul>
<li>使用场景<ol>
<li>结束本次循环，继续下一次的循环。</li>
</ol>
</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>return</strong></li>
</ol>
</blockquote>
<p><strong>break和continue关键字的使用</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">使用范围</th>
<th align="center">循环中使用的作用(不同点)</th>
<th align="center">相同点</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>break</strong></td>
<td align="center">switch-case</td>
<td align="center">终止switch</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">循环结构中</td>
<td align="center">结束当前循环</td>
<td align="center">关键字后面不能声明执行语句</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>continue</strong></td>
<td align="center"></td>
<td align="center">结束当次循环</td>
<td align="center">关键字后面不能声明执行语句</td>
</tr>
</tbody></table>
<hr>
<h1 id="7-方法"><a href="#7-方法" class="headerlink" title="7.    方法"></a>7.    方法</h1><blockquote>
<p><strong>方法</strong>：方法就是函数，也就是做某些事的方式。</p>
</blockquote>
<img src="/2020/05/26/JavaSE/%E6%96%B9%E6%B3%95.png" style="zoom: 80%;">

<h2 id="7-1-方法的组成"><a href="#7-1-方法的组成" class="headerlink" title="7.1    方法的组成"></a>7.1    方法的组成</h2><ul>
<li>5部分</li>
</ul>
<h3 id="关键字-return"><a href="#关键字-return" class="headerlink" title="关键字 return"></a>关键字 return</h3><blockquote>
<p>  <strong>return关键字：</strong></p>
</blockquote>
<ol>
<li> <strong>使用范围</strong>：使用在方法体中</li>
<li> <strong>作用</strong>：① 结束方法  ② 针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</li>
<li> <strong>注意点</strong>：return关键字后面不可以声明执行语句。</li>
</ol>
<h3 id="可变形参个数的方法"><a href="#可变形参个数的方法" class="headerlink" title="可变形参个数的方法"></a>可变形参个数的方法</h3><p>JDK5 新增的内容。</p>
<blockquote>
<p>  <strong>使用说明：</strong></p>
</blockquote>
<ol>
<li> 可变个数形参的格式：<code>数据类型 ... 变量名</code></li>
<li> 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，…</li>
<li> 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li> <strong>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载</strong>。换句话说，二者不能共存。【因为可变形参的底层就是用数组实现的】</li>
<li> <strong>可变个数形参在方法的形参中，必须声明在末尾</strong></li>
<li> <strong>可变个数形参在方法的形参中,最多只能声明一个可变形参。</strong></li>
</ol>
<blockquote>
<p>  举例说明</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.shuzu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/30 18:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        test.show(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);	<span class="comment">// 调用方式一</span></span><br><span class="line">        test.show(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;);	<span class="comment">// 调用方式二</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">            System.out.print(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//    public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="7-2-方法的定义"><a href="#7-2-方法的定义" class="headerlink" title="7.2    方法的定义"></a>7.2    方法的定义</h2><p><strong>定义方法的范围：类中方法外</strong></p>
<ul>
<li>  一个方法不能在另一个方法中定义，但是可以在另一个方法中调用。</li>
<li>  方法可以定义在一个类中，也可以不定义在一个类中(比如：接口中)。</li>
<li>  不能在 return 后面写代码，return意味着方法结束，后面的所有代码永远不会执行，属于无效代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表）&#123;</span><br><span class="line">	方法体</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="7-2-1-方法的返回值类型、参数类型详解"><a href="#7-2-1-方法的返回值类型、参数类型详解" class="headerlink" title="7.2.1    方法的返回值类型、参数类型详解"></a>7.2.1    方法的返回值类型、参数类型详解</h3><p>方法的参数为基本类型时，传递的是数据值，方法的参数为引用类型时，传递的是地址值。</p>
<p><strong>特殊情况：String 要视情况考虑。[常量池]</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        System.out.println(a);      <span class="comment">// 1</span></span><br><span class="line">        System.out.println(b);      <span class="comment">// 2</span></span><br><span class="line">        change(a, b);</span><br><span class="line">        System.out.println(a);      <span class="comment">// 1</span></span><br><span class="line">        System.out.println(b);      <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        a = a+b;</span><br><span class="line">        b = b+a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法参数为基本类型，传递的是数据值。类似于深拷贝。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);     <span class="comment">// 5</span></span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);     <span class="comment">// 99</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法参数为引用类型，传递的是地址值。类似于浅拷贝。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="7-3-方法分类"><a href="#7-3-方法分类" class="headerlink" title="7.3    方法分类"></a>7.3    方法分类</h2><hr>
<h2 id="7-4-重载"><a href="#7-4-重载" class="headerlink" title="7.4    重载"></a>7.4    重载</h2><p>方法重载指<strong>在同一个类中，允许存在一个以上的同名方法</strong>，只要它们的<strong>参数列表不同</strong>即可，与修饰符和返回值类型无关。</p>
<blockquote>
<p>  <strong>方法重载的条件：</strong></p>
</blockquote>
<p>**”两同一不同”**：</p>
<ol>
<li> 同一个类</li>
<li> 相同方法名</li>
<li>参数列表不同<ul>
<li>  个数不同；</li>
<li>  数据类型不同；</li>
<li>  参数类型排列顺序不同。</li>
</ul>
</li>
<li> 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</li>
</ol>
<blockquote>
<p>  <strong>如何确定一个类中某一个方法的调用？</strong></p>
</blockquote>
<ul>
<li>  方法名 + 参数列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        println(<span class="number">10</span>);</span><br><span class="line">        println(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">        println(<span class="number">0</span>);</span><br><span class="line">        println(<span class="number">12.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String  a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">byte</span> a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-5-重写"><a href="#7-5-重写" class="headerlink" title="7.5    重写"></a>7.5    重写</h2><p>方法重写描述的是<code>子类和父类</code>之间的方法关系，而重载指的是同一类中方法的关系。</p>
<blockquote>
<p>  <strong>定义：</strong></p>
</blockquote>
<p>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。</p>
<p>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p>
<blockquote>
<p>  <strong>方法重写的原则：“两同两小一大”</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法的声明：</span></span><br><span class="line">权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>  子类重写方法的 <strong>方法名</strong> 和 <strong>形参列表</strong> 必须和父类被重写的方法的方法名和形参列表相同。【两同】</li>
<li>子类重写的方法的<strong>权限修饰符大于父类</strong>被重写的方法的权限修饰符。【一大】<ul>
<li>  特殊情况：子类不能重写父类中声明为 <code>private</code> 权限的方法【继承都继承不到，自然谈不上重写了】</li>
</ul>
</li>
<li>   返回值类型：    -   父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void；    -   父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)    -   父类被重写的方法的返回值类型是 A 类型，则<strong>子类重写的方法的返回值类型可以是 A 类或 A 类的子类</strong>（一小）</li>
<li>  子类重写的方法<strong>抛出的异常类型小于父类被重写的方法抛出的异常类型</strong>（两小）</li>
</ul>
<h2 id="7-5-重载-vs-重写"><a href="#7-5-重载-vs-重写" class="headerlink" title="7.5 重载 vs.重写"></a>7.5 重载 vs.重写</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">重载</th>
<th align="center">重写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">方法位于同一类中</td>
<td align="center">是父类和子类之间方法的关系</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">参数列表必须不同</td>
<td align="center">参数列表必须相同</td>
</tr>
</tbody></table>
<hr>
<h1 id="8-类"><a href="#8-类" class="headerlink" title="8.    类"></a>8.    类</h1><img src="/2020/05/26/JavaSE/%E7%B1%BB.png" alt="类" style="zoom:45%;">

<blockquote>
<p>  Java中，一切都是对象，类也是一种对象。</p>
</blockquote>
<h2 id="8-1-类结构（4大6小成员）"><a href="#8-1-类结构（4大6小成员）" class="headerlink" title="8.1    类结构（4大6小成员）"></a>8.1    类结构（4大6小成员）</h2><p>类的基本要素是<strong>属性</strong>和<strong>方法</strong>。</p>
<ul>
<li><strong>属性</strong>：属性也被称为字段、成员变量，属性可以是任意类型的对象，也可以是基本类型数据。</li>
<li><strong>方法</strong>：方法也被称为成员方法，其实就是函数，也就是做某些事的方式。包括：构造方法和普通方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">	<span class="comment">// 属性（字段）</span></span><br><span class="line">    <span class="comment">// 成员方法（构造方法+普通方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-1-1-属性（变量）"><a href="#8-1-1-属性（变量）" class="headerlink" title="8.1.1    属性（变量）"></a>8.1.1    属性（变量）</h3><h4 id="成员变量-vs-局部变量"><a href="#成员变量-vs-局部变量" class="headerlink" title="成员变量 vs. 局部变量"></a>成员变量 vs. 局部变量</h4><ul>
<li>  类中的直接属性（字段）也被称为<strong>成员变量</strong>；而类中的间接属性（类中方法中的变量）又被称为<strong>局部变量</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><br>在类中的位置不同</td>
<td align="center"><br>类中 &amp; 方法外</td>
<td align="center">方法中，方法形参<br>构造方法中，构造方法形参<br><strong>代码块内</strong></td>
</tr>
<tr>
<td align="center">作用范围不一样</td>
<td align="center">类中</td>
<td align="center">方法中</td>
</tr>
<tr>
<td align="center">初始化的值不同</td>
<td align="center">有默认值</td>
<td align="center">无默认值，必须赋值</td>
</tr>
<tr>
<td align="center">在内存中的位置不同</td>
<td align="center">堆内存</td>
<td align="center">栈内存</td>
</tr>
<tr>
<td align="center">生命周期不同</td>
<td align="center">随对象的创建而存在，随对象的消失而消失</td>
<td align="center">随方法的调用而存在，随方法的调用完毕而消失</td>
</tr>
<tr>
<td align="center">权限修饰符的不同</td>
<td align="center">private、public、缺省、protected</td>
<td align="center">不可以使用权限修饰符<br>（因为根本出不了当前类，出了作用范围就不可以被使用了）</td>
</tr>
</tbody></table>
<h4 id="类变量-amp-实例变量"><a href="#类变量-amp-实例变量" class="headerlink" title="类变量 &amp; 实例变量"></a>类变量 &amp; 实例变量</h4><ul>
<li>  静态变量：随着类的加载而加载，在内存中只会有一份</li>
<li>  实例变量：属于对象，在内存中创建几次对象就会有几份实例变量</li>
</ul>
<hr>
<h3 id="8-1-2-方法"><a href="#8-1-2-方法" class="headerlink" title="8.1.2    方法"></a>8.1.2    方法</h3><blockquote>
<p>  <strong>方法</strong>：描述类应该具备的功能。</p>
</blockquote>
<h4 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h4><blockquote>
<p>类中有一种特殊的方法被称为 <strong>构造方法</strong>，或者叫 <strong>构造器</strong>、<strong>构造函数</strong>。</p>
</blockquote>
<p><strong>构造器的作用</strong></p>
<ol>
<li> 创建对象</li>
<li> 初始化对象信息</li>
</ol>
<p><strong>构造器的格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  类名(形参列表)&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法比较特殊，</p>
<ol>
<li><em>它没有返回值；</em></li>
<li><em>它的名称要和类名一致；</em></li>
<li><em>构造方法可以有多个，彼此构成重载。</em></li>
</ol>
<p><strong>使用说明</strong></p>
<ol>
<li> 如果类中没有显式地定义构造方法的话，JVM 会自动生成一个默认的无参构造器。</li>
<li> 一旦我们显式地定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li> 构造器只在创建对象的时期调用一次，保证了对象的初始化的进行。</li>
<li> <strong>一个类中至少会有一个构造器，保证对象可以被创建出来</strong>。</li>
</ol>
<p><strong>属性赋值的先后顺序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-   ① 默认初始化</span><br><span class="line">-   ② 显式初始化</span><br><span class="line">-   ③ 构造器中初始化</span><br><span class="line">-   ④ 通过&quot;对象.方法&quot; 或 &quot;对象.属性&quot;的方式，赋值</span><br></pre></td></tr></table></figure>





<h4 id="2、成员方法"><a href="#2、成员方法" class="headerlink" title="2、成员方法"></a>2、成员方法</h4><ul>
<li>成员方法中的变量被称为局部变量。</li>
</ul>
<h3 id="8-1-3-代码块"><a href="#8-1-3-代码块" class="headerlink" title="8.1.3    代码块"></a>8.1.3    代码块</h3><blockquote>
<ol>
<li> <strong>代码块的作用</strong>：用来初始化类、对象的信息</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li> <strong>分类</strong></li>
</ol>
</blockquote>
<p>代码块要是使用修饰符，只能使用 <code>static</code>。</p>
<ul>
<li>  静态代码块</li>
<li>  非静态代码块</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>静态代码块</strong></li>
</ol>
</blockquote>
<ul>
<li>  内部可以输出语句；</li>
<li>  随着类的加载而执行，且只执行一次；</li>
<li>  作用：初始化类的信息；</li>
<li>  如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行；</li>
<li>  静态代码块的执行要优先于非静态代码块的执行；</li>
<li>  静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构。</li>
</ul>
<blockquote>
<ol start="4">
<li> <strong>非静态代码块</strong></li>
</ol>
</blockquote>
<ul>
<li>  内部可以输出语句；</li>
<li>  随着对象的创建而执行；</li>
<li>  每创建一个对象，就执行一次非静态代码块；</li>
<li>  作用：可以在创建对象时，对对象的属性等进行初始化；</li>
<li>  如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行；</li>
<li>  非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ul>
<blockquote>
<p>  <strong>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序</strong>：</p>
</blockquote>
<ul>
<li>  由父及子，静态先行。</li>
</ul>
<h3 id="8-1-4-内部类"><a href="#8-1-4-内部类" class="headerlink" title="8.1.4    内部类"></a>8.1.4    内部类</h3><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<p>将一个类 A 定义在另一个类 B 内部，则里面的类A就称为内部类，类B则称为外部类。</p>
<blockquote>
<p>  <strong>分类</strong></p>
</blockquote>
<ul>
<li>  成员内部类（静态、非静态）</li>
<li>  局部内部类(方法内、代码块内、构造器内)</li>
</ul>
<blockquote>
<p>  <strong>内部类特性：</strong></p>
</blockquote>
<ul>
<li>一个内部类对象可以直接访问它的外部类对象的所有内容，包括私有数据。</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性。</li>
<li>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的<code>.class</code>文件，但是前面冠以外部类的类名和<code>$</code>符号。【比如：<code>Person$Heart.class</code>】【这也证明了一个 <code>.java</code> 文件可以生成多个 <code>.class</code>文件】</li>
</ul>
<blockquote>
<p>  <strong>字节码文件格式：</strong></p>
</blockquote>
<p>成员内部类和局部内部类，在编译以后，都会生成字节码文件。</p>
<ul>
<li>  成员内部类：<code>外部类$内部类名.class</code></li>
<li>  局部内部类：<code>外部类$数字 内部类名.class</code></li>
</ul>
<hr>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><blockquote>
<p><strong>定义格式：</strong>定义在<strong>类中方法外</strong>的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 外部类&#123;</span><br><span class="line">    class 内部类&#123;</span><br><span class="line">        <span class="comment">// 代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>成员内部类特点：</strong></p>
</blockquote>
<ol>
<li>一方面，作为外部类的成员，它可以：<ul>
<li>  调用外部类的数据；</li>
<li>  可以被 <code>static</code> 修饰；</li>
<li>  可以被 4 种不同的权限修饰；</li>
</ul>
</li>
<li>另一方面，作为一个类：<ul>
<li>  类内可以定义属性、方法、构造器等；</li>
<li>  可以被 <code>final</code> 修饰，表示此类不能被继承。也就是说不使用 <code>final</code> 的话，内部类就可以被继承；</li>
<li>  可以被 <code>abstract</code> 修饰。</li>
</ul>
</li>
</ol>
<h3 id="8-3-3-局部内部类"><a href="#8-3-3-局部内部类" class="headerlink" title="8.3.3    局部内部类"></a>8.3.3    局部内部类</h3><blockquote>
<p><strong>定义：</strong>定义在类 A 的方法 <code>method()</code> 中的类 B 叫做局部内部类。</p>
</blockquote>
<ul>
<li>  方式一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getComparable() 方法的功能是返回一个实现了Comparable接口的子类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个实现了Comparable接口的类:局部内部类【类方法中的类】</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">MyComparable</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;  </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyComparable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  方式二：匿名局部内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<p>如果在局部内部类的方法中调用外部类的局部变量，那么要求此局部变量必须声明为 <code>final</code> 的。</p>
<ul>
<li>  JDK8 之前：要求此局部变量必须显式地声明为 <code>final</code> 的；</li>
<li>  从 JDK8 开始：可以省略 <code>final</code> 关键字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*final*/</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">12</span>;   <span class="comment">// 外部类的局部变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inner 是一个局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">innerA</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//                num = 21; // 编译异常，因为num被隐式地声明为final了，不能被更改</span></span><br><span class="line">                System.out.println(num);    <span class="comment">// OK，调用是OK的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="8-3-4-匿名内部类"><a href="#8-3-4-匿名内部类" class="headerlink" title="8.3.4    匿名内部类"></a>8.3.4    匿名内部类</h3><blockquote>
<p><strong>匿名内部类</strong>：是内部类的简化写法。</p>
<p>它的本质是一个 <code>带具体实现的</code>、<code>父类或者父接口</code>、<code>匿名的</code><strong>子类对象</strong>。</p>
<p>开发时，最常用到的内部类就是匿名内部类了。</p>
<p>以接口举例，当你使用一个接口时，你得做以下几步操作：</p>
</blockquote>
<ol>
<li>定义子类实现类；</li>
<li>重写接口中的抽象方法；</li>
<li>创建子类对象；</li>
<li>调用重写后的方法；</li>
</ol>
<p>我们的目的，最终只是为了调用方法，那么能不能简化以下，把以上4步合成一步呢？匿名内部类就是这样做的快捷方式。</p>
<h4 id="1-前提"><a href="#1-前提" class="headerlink" title="1    前提"></a>1    前提</h4><ul>
<li>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。也就是说，子类是父类的内部类。</li>
</ul>
<h4 id="2-格式"><a href="#2-格式" class="headerlink" title="2  格式"></a>2  格式</h4><ul>
<li><p><strong>内部类要实现的功能？</strong></p>
<ul>
<li><strong>答：通过外部类调用内部类的方法。</strong></li>
<li><strong>或：通过父类调用调用子类中的方法。</strong></li>
</ul>
</li>
<li><p>格式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或接口名()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-2-初始化"><a href="#8-2-初始化" class="headerlink" title="8.2    初始化"></a>8.2    初始化</h2><h3 id="8-2-1-类的初始化"><a href="#8-2-1-类的初始化" class="headerlink" title="8.2.1    类的初始化"></a>8.2.1    类的初始化</h3><blockquote>
<p><strong>类的初始化就是创建一个新的对象</strong>，我们在使用<code>new</code>关键字创建对象时，其实是调用了这个对象的构造方法进行的初始化。</p>
</blockquote>
<ul>
<li>详见<code>9.  对象</code></li>
</ul>
<h3 id="8-2-2-成员变量初始化"><a href="#8-2-2-成员变量初始化" class="headerlink" title="8.2.2    成员变量初始化"></a>8.2.2    成员变量初始化</h3><blockquote>
<ol>
<li> <strong>成员变量的赋值顺序</strong></li>
</ol>
</blockquote>
<p>JVM 会保证每个成员变量在使用前都会获得初始值，成员变量的赋值顺序可分为：</p>
<ol>
<li> 默认初始化（类加载阶段，默认赋零值）</li>
<li> 显式初始化/在代码块中赋值【先静态后非静态，先父后子】</li>
<li> 构造器中初始化</li>
<li> 有了对象以后，可以通过 <code>对象.属性</code> 或 <code>对象.方法</code> 的方式，进行赋值。</li>
</ol>
<p><strong>成员变量（属性）的默认值</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">数据类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本类型</td>
<td align="center">整型（byte，short，int，long）<br>浮点型（float，double）<br>布尔型（boolean）<br>字符型（char）</td>
<td align="center">0<br>0.0<br>false<br>‘\u0000’</td>
</tr>
<tr>
<td align="center">引用类型</td>
<td align="center">基本类型的包装类、String、数组，类，接口</td>
<td align="center">null</td>
</tr>
</tbody></table>
<ul>
<li></li>
</ul>
<h3 id="8-2-3-构造器初始化"><a href="#8-2-3-构造器初始化" class="headerlink" title="8.2.3    构造器初始化"></a>8.2.3    构造器初始化</h3><blockquote>
<p><strong>可以在<code>构造器</code>中对某些属性进行初始化，确定初始值。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// 未手动初始化，但有默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        i=<span class="number">11</span>;	<span class="comment">// 在构造器中对属性i进行初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<hr>
<h1 id="9-对象"><a href="#9-对象" class="headerlink" title="9.    对象"></a>9.    对象</h1><h2 id="9-1-对象的创建"><a href="#9-1-对象的创建" class="headerlink" title="9.1    对象的创建"></a>9.1    对象的创建</h2><blockquote>
<p>使用<code>new</code>关键字创建对象，但是实际调用的是<code>class</code>类中的构造方法。</p>
</blockquote>
<ul>
<li>创建对象就是类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>



<h2 id="9-2-对象的销毁"><a href="#9-2-对象的销毁" class="headerlink" title="9.2    对象的销毁"></a>9.2    对象的销毁</h2><blockquote>
<p>在Java中，我们不需要手动管理对象的销毁，它是由Java虚拟机（JVM）进行管理和销毁的。</p>
</blockquote>
<h2 id="9-3-对象的使用"><a href="#9-3-对象的使用" class="headerlink" title="9.3    对象的使用"></a>9.3    对象的使用</h2><ol>
<li><p>使用对象中的成员（包括方法和属性）</p>
<blockquote>
<ul>
<li>对象引用.成员变量</li>
<li>对象引用.成员方法</li>
</ul>
</blockquote>
</li>
<li><p>给对象中的属性赋值</p>
<blockquote>
<ul>
<li>对象名.成员变量 = “value”</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="9-4-对象在内存中的情况"><a href="#9-4-对象在内存中的情况" class="headerlink" title="9.4    对象在内存中的情况"></a>9.4    对象在内存中的情况</h2><h3 id="1、一个对象，调用一个方法内存图"><a href="#1、一个对象，调用一个方法内存图" class="headerlink" title="1、一个对象，调用一个方法内存图"></a>1、一个对象，调用一个方法内存图</h3><p><img src="/2020/05/26/JavaSE/%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
<ol>
<li>测试程序中的<code>main()</code>方法是程序执行的入口，<code>main()</code>方法首先进栈；</li>
<li>执行<code>创建p1对象</code>的语句，在堆内存中保存<code>p1对象</code>，<ul>
<li>将<code>p1对象的引用</code>保存在栈中，</li>
<li><code>p1对象的属性</code>保存在堆中；</li>
<li><code>p1对象的成员方法</code>保存在方法区中；</li>
<li><code>p1对象的成员方法的地址</code>保存在堆中；</li>
</ul>
</li>
<li>在测试程序中，通过<code>p1对象的引用</code>调用<code>p1对象中的方法</code>，<code>eat()</code>方法继续进栈执行；</li>
<li>问题：创建多个People对象时，如果每个对象中都保存一份成员方法的信息，那么多个对象就会有多份重复的成员方法信息<code>eat()</code>，这就非常浪费内存了，因为所有对象的方法信息都是一样的，那么如何解决这个问题呢？</li>
</ol>
<h3 id="2-两个对象，调用一个方法内存图"><a href="#2-两个对象，调用一个方法内存图" class="headerlink" title="2.    两个对象，调用一个方法内存图"></a>2.    两个对象，调用一个方法内存图</h3><p><img src="/2020/05/26/JavaSE/%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E5%90%8C%E4%B8%80%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
<ol>
<li>两个对象调用同一成员方法，该成员方法的数据不存储在堆内存中，只在堆内存中保存着一个<strong>方法标记</strong>。</li>
<li>方法真正的内容保存在方法区中。</li>
<li>通过堆内存的方法标记访问方法区的成员方法，来完成成员方法的调用。</li>
<li>可以实现，即便有多个对象，成员方法信息也只保存一份，节省内存空间。</li>
</ol>
<hr>
<h2 id="9-5-匿名对象"><a href="#9-5-匿名对象" class="headerlink" title="9.5    匿名对象"></a>9.5    匿名对象</h2><blockquote>
<p><strong>匿名对象</strong>：没有变量名的对象。</p>
<p>匿名对象是典型的多例的应用。</p>
</blockquote>
<p>定义</p>
<p>我们创建的对象，没显式的赋给一个变量名。即为匿名对象。</p>
<p>特点</p>
<p>匿名对象只能调用一次。（因为没有在栈中保存该对象的引用）</p>
<ul>
<li>创建对象时，只有创建对象的语句，却没有把对象的地址值赋值给某个变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名(参数列表)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>

<h3 id="9-5-1-应用场景"><a href="#9-5-1-应用场景" class="headerlink" title="9.5.1.    应用场景"></a>9.5.1.    应用场景</h3><ol>
<li><p>创建匿名对象并直接直接调用该对象的方法，不使用变量名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>一旦调用两次方法，就是创建了两个对象，造成资源浪费</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br></pre></td></tr></table></figure></li>
<li><p>匿名对象可以<strong>作为方法的参数或返回值</strong></p>
</li>
</ol>
<hr>
<h1 id="10-关键字"><a href="#10-关键字" class="headerlink" title="10    关键字"></a>10    关键字</h1><p><strong>定义</strong>：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p>
<p><strong>特点</strong>：关键字中所字母都为小写</p>
<p><strong>有哪些</strong>：</p>
<p><img src="/2020/05/26/JavaSE/image-20210723101625081.png" alt="image-20210723101625081"></p>
<p><img src="/2020/05/26/JavaSE/image-20210730094044842.png" alt="image-20210730094044842"></p>
<p><img src="/2020/05/26/JavaSE/%E5%85%B3%E9%94%AE%E5%AD%97.png"></p>
<blockquote>
<p>  <strong>保留字</strong></p>
</blockquote>
<p><strong>定义</strong>：现Java版本尚未使用，但以后版本可能会作为关键字使用。</p>
<p><strong>注意</strong>：自己命名标识符时要避免使用这些保留字</p>
<blockquote>
<p>  <strong>标识符</strong></p>
</blockquote>
<p><strong>定义</strong>：凡是自己可以起名字的地方都叫标识符。</p>
<p><strong>涉及到的结构</strong>：包名、类名、接口名、变量名、方法名、常量名</p>
<p><strong>规则</strong>：(必须要遵守。否则，编译不通过)</p>
<p><img src="/2020/05/26/JavaSE/image-20210730094359137.png" alt="image-20210730094359137"></p>
<ul>
<li>  标识符应以字母、_ 、$开头</li>
</ul>
<p><strong>规范</strong>：（可以不遵守，不影响编译和运行。但是要求大家遵守）</p>
<p><img src="/2020/05/26/JavaSE/image-20210730094602848.png" alt="image-20210730094602848"></p>
<p><strong>注意</strong>：在起名字时，为了提高阅读性，要尽量意义，“见名知意”。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><blockquote>
<ol>
<li> <strong>static 可以修饰的结构</strong>：</li>
</ol>
</blockquote>
<ul>
<li><p>  主要用来修饰类的内部结构：<strong>属性、方法、代码块、内部类</strong></p>
</li>
<li><p>  被<code>static</code>修饰的成员是<strong>属于类</strong>的，而不是单单属于某个对象的。</p>
</li>
<li><p>  被 static 修饰的 方法/属性 可以在没有创建对象的情况下被调用。</p>
</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>static 修饰属性：类变量</strong></li>
</ol>
</blockquote>
<ul>
<li>  被 <code>static</code>修饰的成员变量称为<strong>静态成员变量</strong> 或 <strong>类变量</strong>。</li>
<li>  依据同一份类模板创建的每个对象都共享同一份类变量的值，任何对象都可以更改该类变量的值，也可以在不创建实例对象的情况下对类变量进行操作。</li>
<li>  静态变量随着类的加载而加载，可以通过 <code>类.静态变量</code> 的方式进行调用。</li>
<li>  静态变量的加载要早于对象的创建。</li>
<li>  由于类只会加载一次，则静态变量在内存中也只会存在一份。</li>
<li>  <strong>类变量有专门的存储区域</strong>，存在方法区的静态域中，所有的实例对象中保存的是类变量的地址引用。</li>
</ul>
<p><strong>案例：</strong></p>
<p>​        新学期开学，学生报到。现在想按照报到顺序为每一位学生分配学号<code>sid</code>，从第一名学生开始学号为 1，以此类推。学号必须是唯一的，连续的，并且与班级人数相符。以便知道要分配给下一名新同学的学号是多少。【这样我们就需要一个变量，与单独的每一个学生对象无关，而是与创建了多少个学生对象（执行了多少次创建过程）有关】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numberOfStudent</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、Student类只提供了无参构造方法，所以创建学生对象必须使用该类。</span></span><br><span class="line"><span class="comment">        2、每次new一个新的对象时必调用一次构造方法，且numberOfStudent是一个类(静态)变量，所以每个对象都可     以修改该属性的值，做到了每创建一个对象numberOfStudent就会自增1，对应的sid也就实现了自增长。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sid = ++numberOfStudent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.sid = ++numberOfStudent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sid=&quot;</span> + sid +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Student&#123;name=&#x27;null&#x27;, gender=&#x27;null&#x27;, sid=1&#125;</span></span><br><span class="line"><span class="comment">            Student&#123;name=&#x27;李四&#x27;, gender=&#x27;女&#x27;, sid=2&#125;</span></span><br><span class="line"><span class="comment">            Student&#123;name=&#x27;王五&#x27;, gender=&#x27;男&#x27;, sid=3&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<ol start="3">
<li> <strong>static修饰方法：静态静态方法、类方法</strong></li>
</ol>
</blockquote>
<ul>
<li><p>随着类的加载而加载；</p>
</li>
<li><p>建议使用<code>类名.方法名</code>直接调用静态方法，而不是通过实例对象调用静态方法（当然也可以调用成功）。</p>
</li>
<li><p>注意事项：</p>
<ol>
<li><strong>静态方法只能访问静态成员（静态方法+静态变量）</strong>。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>非静态方法既可以调用非静态的方法或属性，也可以调用静态的方法或属性。</li>
<li><strong>静态方法中不能使用 this 和 super 关键字</strong>。【因为 this 和 super 都代表对象实例，而静态方法不依赖任何实例对象】</li>
</ol>
<p><strong>如何理解？</strong></p>
<p>​        <em>因为静态成员先于实例对象成员创建，静态成员在类加载阶段就已经被创建出来了，而实例成员直到执行 <code>&lt;init&gt;()</code> 构造方法时才被创建出来，所以静态成员有可能访问不到实例。</em></p>
<blockquote>
<ol start="4">
<li> <strong>static 修饰代码块：静态代码块</strong></li>
</ol>
</blockquote>
<ul>
<li><p>  静态代码块：使用<code>static</code>修饰的代码块，定义在<strong>类中方法外</strong>。</p>
</li>
<li><p>  随着类的加载而执行，且只执行一次，优先于和构造方法的执行。</p>
</li>
<li><p><strong>格式</strong>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class ClassName&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用</strong>：给类变量进行初始化赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 给类变量赋值</span></span><br><span class="line">        id = <span class="number">2</span>;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到list中</span></span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ol start="5">
<li> <strong>static 内存分布</strong></li>
</ol>
</blockquote>
<p><code>static</code>修饰的内容：</p>
<ol>
<li>是随着类的加载而加载的，且只加载一次。</li>
<li>存储于一块固定的内存区域（静态区），所以可以直接通过类名调用。</li>
<li>它优先于对象存在，所以，可以被所有对象共享。</li>
</ol>
<ul>
<li>非静态成员变量：操作各自的空间（堆内存中）</li>
<li>静态成员变量：操作共享空间（方法区的静态区中）</li>
</ul>
<p><img src="/2020/05/26/JavaSE/%E9%9D%99%E6%80%81%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png"></p>
<hr>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote>
<p>  <strong>可以修饰的结构：</strong></p>
</blockquote>
<ul>
<li>  类、方法、变量</li>
</ul>
<blockquote>
<p>  <strong>final 修饰类</strong>：</p>
</blockquote>
<ul>
<li>  被修饰的类，不能被继承。</li>
<li>  比如：String类、System类、StringBuffer类</li>
</ul>
<blockquote>
<p>  <strong>final 修饰方法</strong></p>
</blockquote>
<ul>
<li>  被修饰的方法，不能被重写。</li>
<li>  比如：Object 类中 <code>getClass()</code></li>
</ul>
<blockquote>
<p>  <strong>final 修饰变量</strong></p>
</blockquote>
<ul>
<li>被修饰的普通类型变量，不能被重新赋值。</li>
<li>被修饰的引用类型变量，引用的地址值不能再发生改变。</li>
<li>被 final 修饰的变量，建议在定义时所有字母都使用大写。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li><p>修饰类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finall class 类名&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修饰方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写被final修饰的方法，编译时会报错。</span></span><br></pre></td></tr></table></figure></li>
<li><p>修饰变量</p>
<blockquote>
<ul>
<li><strong>基本类型变量</strong>：基本类型的局部变量，被<code>final</code>修饰后，只能赋值一次，不能再次被赋值。</li>
<li><strong>引用类型变量</strong>：引用类型的局部变量，被<code>final</code>修饰后，只能指向一个引用，地址不能再更改，但是不影响对象内部成员变量值的修改。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、修饰基本类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    a = <span class="number">99</span>; <span class="comment">// error，编译时直接报错，不可被重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、修饰引用类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    u = <span class="keyword">new</span> <span class="title class_">User</span>();     <span class="comment">// error,地址不能再修改</span></span><br><span class="line">    u.setName(<span class="string">&quot;zs&quot;</span>);    <span class="comment">// Ok，可以修改对象内部成员变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="权限修饰符（3个）"><a href="#权限修饰符（3个）" class="headerlink" title="权限修饰符（3个）"></a>权限修饰符（3个）</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">默认</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一类中</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">同一包中</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包中有继承关系的类</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包中的无关类</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>建议</strong>：</p>
<ol>
<li>成员变量使用<code>private</code>，隐藏细节。</li>
<li>构造方法使用<code>public</code>，方便创建对象。</li>
<li>成员方法使用<code>public</code>，方便调用方法。</li>
</ol>
</blockquote>
<hr>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>this</code> 可以理解为：当前对象  或 当前正在创建的对象。</p>
<p><strong>可以调用的结构</strong>：属性；方法；构造器</p>
<blockquote>
<p>  <strong><code>this</code> 调用属性、方法</strong>：</p>
</blockquote>
<ol>
<li>在<strong>类的方法</strong>中，我们可以使用 <code>this.属性</code> 或 <code>this.方法</code> 的方式，调用<strong>当前对象</strong>的属性或方法。<ul>
<li>  通常情况下，我们都择省略 <code>this.</code>。</li>
<li>  特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用 <code>this.变量</code> 的方式，表明此变量是属性，而非形参。</li>
</ul>
</li>
<li>在<strong>类的构造器</strong>中，我们可以使用 <code>this.属性</code> 或 <code>this.方法</code> 的方式，调用<strong>当前正在创建的对象</strong>的属性或方法。<ul>
<li>  通常情况下，我们都择省略 <code>this.</code>。</li>
<li>  特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用 <code>this.变量</code> 的方式，表明此变量是属性，而非形参。</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong><code>this</code> 调用构造器：</strong></p>
</blockquote>
<ul>
<li>  我们在类的构造器中，可以显式的使用 <code>this(形参列表)</code> 的方式，调用本类中指定的其他构造器；</li>
<li>  构造器中不能通过 <code>this(形参列表)</code> 的方式调用自己，因为这样会无限递归。【总的原则就是一个构造器调用其它的构造器不能出现无限递归，出现递归则会发生编译时异常】</li>
<li>  如果一个类中有 n 个构造器，则最多可以有 <code>n-1</code> 个构造器中调用用了 <code>this(形参列表)</code>。</li>
<li>  规定：<code>this(形参列表)</code> 必须声明在当前构造器的首行。</li>
<li>  构造器内部，最多只能声明一个 <code>this(形参列表)</code>，用来调用其他的构造器。</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p><code>super</code> 关键字可以理解为：父类对象</p>
<p><strong>可以调用的结构</strong>：属性、方法、构造器</p>
<blockquote>
<p>  <strong>super 调用属性、方法：</strong></p>
</blockquote>
<p>我们可以在子类的方法或构造器中，通过使用 <code>super.属性</code> 或 <code>super.方法</code> 的方式，显式的调用父类中声明的属性或方法。</p>
<ul>
<li>  通常情况下，我们习惯省略 <code>super.</code>；</li>
<li>  特殊情况1：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用 <code>super.属性</code> 的方式，表明调用的是父类中声明的属性。</li>
<li>  特殊情况2：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用 <code>super.方法</code> 的方式，表明调用的是父类中被重写的方法。</li>
</ul>
<blockquote>
<p>  <strong>super调用构造器</strong>：</p>
</blockquote>
<ul>
<li>  我们可以在子类的构造器中显式的使用 <code>super(形参列表)</code> 的方式，调用父类中声明的指定的构造器；</li>
<li>  <code>super(形参列表)</code> 的使用，必须声明在子类构造器的首行！</li>
<li>  我们<strong>在类的构造器中，针对于 <code>this(形参列表)</code> 或 <code>super(形参列表)</code> 只能二一，不能同时出现</strong>。</li>
<li>  在构造器的首行，没显式的声明 <code>this(形参列表)</code> 或 <code>super(形参列表)</code>，则默认调用的是父类中空参的构造器 <code>super()</code>。</li>
<li>  在类的多个构造器中，至少要存在一个类构造器中使用了 <code>super(形参列表)</code>，调用父类中的构造器。</li>
</ul>
<hr>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><h2 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h2><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><blockquote>
<p>见<code>13.2    abstract</code></p>
</blockquote>
<hr>
<h1 id="11-封装"><a href="#11-封装" class="headerlink" title="11    封装"></a>11    封装</h1><blockquote>
<p>  <strong>封装</strong>：将某些属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。</p>
</blockquote>
<h2 id="11-1-为什么要有封装？"><a href="#11-1-为什么要有封装？" class="headerlink" title="11.1    为什么要有封装？"></a>11.1    为什么要有封装？</h2><ol>
<li> <strong>程序设计追求“高内聚，低耦合”。</strong></li>
<li> <strong>隐藏对象内部的复杂性，只对外公开简单的接口，让代码更容易理解</strong>。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</li>
<li> <strong>提高代码的安全性</strong>，防止该类的代码和数据被其它类随意访问。</li>
</ol>
<blockquote>
<ul>
<li>  高内聚：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>  低耦合：仅对外暴露少量的方法用于使用。</li>
</ul>
</blockquote>
<h2 id="11-2-封装思想的代码提现"><a href="#11-2-封装思想的代码提现" class="headerlink" title="11.2    封装思想的代码提现"></a>11.2    封装思想的代码提现</h2><ol>
<li> 将类的属性私有化（private），同时提供公共（public）的<code>get/set</code>方法来获取和设置该属性的值。</li>
<li> 不对外暴露的私有（private）的方法。</li>
<li> 单例模式（将构造器私有化）。</li>
<li> 如果不希望类在包外被调用，可以将类设置为缺省的。</li>
</ol>
<h2 id="11-3-权限修饰符"><a href="#11-3-权限修饰符" class="headerlink" title="11.3    权限修饰符"></a>11.3    权限修饰符</h2><blockquote>
<p>  <strong>权限修饰符可用来修饰的结构说明：</strong></p>
</blockquote>
<ul>
<li>  4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</li>
<li>  修饰非内部类的话，只能使用：缺省、public</li>
</ul>
<p><img src="/2020/05/26/JavaSE/image-20210730173311690.png" alt="image-20210730173311690"></p>
<h2 id="11-3-封装优化"><a href="#11-3-封装优化" class="headerlink" title="11.3    封装优化"></a>11.3    封装优化</h2><h3 id="1-this关键字"><a href="#1-this关键字" class="headerlink" title="1.    this关键字"></a>1.    this关键字</h3><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.    构造方法"></a>2.    构造方法</h3><hr>
<h1 id="12-继承"><a href="#12-继承" class="headerlink" title="12    继承"></a>12    继承</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<p>多个类中存在相同属性或行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。</p>
<blockquote>
<p>  <strong>继承：</strong></p>
</blockquote>
<ul>
<li>子类继承父类的<strong>非私有和非静态的</strong>属性和方法，使得子类对象具有与父类对象相同的属性、方法。</li>
<li>子类可以直接访问父类中的非私有和非静态的属性和行为。</li>
</ul>
<blockquote>
<p>  <strong>好处</strong>：</p>
</blockquote>
<ol>
<li>提高代码的复用性</li>
<li>类与类之间产生了关系，是多态的前提。</li>
</ol>
<blockquote>
<p>  <strong>继承的特点</strong></p>
</blockquote>
<ol>
<li> 一个类可以被多个子类继承。</li>
<li> 单继承：一个类只能有一个父类</li>
<li> 子类直接继承的父类，称为 <strong>直接父类</strong>；间接继承的父类称为 <strong>间接父类</strong>。</li>
<li> 子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法。</li>
</ol>
<h2 id="为什么要有？"><a href="#为什么要有？" class="headerlink" title="为什么要有？"></a>为什么要有？</h2><ol>
<li> 减少了代码的冗余，提高了代码的复用性。【像Java中很多顶级父类，一直从JDK1.1、1.2的版本沿用至今，很多都是利用类的继承性】</li>
<li> 便于功能的扩展</li>
<li> 多态性的前提</li>
</ol>
<h2 id="继承后的特点"><a href="#继承后的特点" class="headerlink" title="继承后的特点"></a>继承后的特点</h2><p><img src="/2020/05/26/JavaSE/%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%90%8E%E6%88%90%E5%91%98%E7%9A%84%E7%89%B9%E7%82%B9.png" alt="子类继承父类后成员的特点"></p>
<h3 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="1.    成员变量"></a>1.    成员变量</h3><ul>
<li><p>子父类中成员变量无重名：无影响</p>
</li>
<li><p><strong>子父类中成员变量有重名</strong>：有影响，通过子类对象访问父类中的<strong>非私有成员变量</strong>时，需要使用<code>super</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.父类成员变量</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-普通方法"><a href="#2-普通方法" class="headerlink" title="2.    普通方法"></a>2.    普通方法</h3><ul>
<li>子父类中成员方法无重名：无影响</li>
<li><strong>字父类中成员方法有重名：重写</strong></li>
</ul>
<h3 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3.    构造方法"></a>3.    构造方法</h3><ul>
<li>  因为构造方法的名字和类名是一致的，所以不会出现子类和父类中构造方法重名的问题。</li>
<li>  构造方法的作用是创建并初始化对象，由于创建子类对象时要用到一部分父类对象的数据，所以在创建子类对象之前，必须先初始化父类对象。</li>
<li>  子类的无参构造器中会隐式地调用 <code>super()</code> 方法来调用父类的构造方法，这个隐式调用在编译后位于构造方法的第一行。</li>
<li>  所以说如果想要重载子类的构造方法，必须先显式地调用父类的构造方法，即<code>super()</code>。因为 JVM 不会对重载的构造方法进行隐式调用 <code>super()</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="comment">// 重载子类的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();    <span class="comment">// 调用父类构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>父类对象优先于子类对象产生</strong></p>
</blockquote>
<p>因为子类对象中包含了父类对象的部分成员变量和方法，所以每次创建子类对象时，先要初始化父类对象，再初始化子类对象。</p>
<ul>
<li><p><strong>super</strong>：代表父类的存储空间地址。</p>
</li>
<li><p><strong>this</strong>：代表当前对象的引用。</p>
</li>
</ul>
<img src="/2020/05/26/JavaSE/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" style="zoom:80%;">



<hr>
<h2 id="super-amp-this"><a href="#super-amp-this" class="headerlink" title="super &amp; this"></a>super &amp; this</h2><ul>
<li>  <code>this</code> 时当前对象的引用，可以调用当前对象的 属性、普通方法 和 <strong>构造方法</strong> 。</li>
<li>  <code>super</code>表示父类对象的引用，可以调用父类对象中的 属性、普通方法 和 <strong>构造方法</strong> 。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">调用方式</td>
<td align="center">调用当前对象的属性、方法、构造函数</td>
<td align="center">调用父类对象中的属性、方法、构造函数</td>
</tr>
<tr>
<td align="center">调用位置</td>
<td align="center">调用构造函数时放在第一行，其它可自行选择</td>
<td align="center">调用构造函数时放在第一行，其它可自行选择</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>  <strong>this(参数)</strong> 表示调用当前对象的构造方法，</li>
<li>  <strong>super(参数)</strong> 表示调用父类对象的构造方法。</li>
</ul>
</blockquote>
<hr>
<h2 id="子类对象实例化全过程"><a href="#子类对象实例化全过程" class="headerlink" title="子类对象实例化全过程"></a>子类对象实例化全过程</h2><blockquote>
<p>  <strong>从结果上看</strong>：继承性</p>
</blockquote>
<ul>
<li>  子类继承父类以后，就获取了父类中声明的属性或方法。</li>
<li>  创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</li>
</ul>
<blockquote>
<p>  <strong>从过程上看</strong>：</p>
</blockquote>
<p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类构造器，进而调用父类的父类构造器，… 直到调用了java.lang.Object 类中空参的构造器为止。正因为加载过所有的父类结构，所以在子类中才可以看到内存中父类中的结构，子类对象才可以进行调用。</p>
<blockquote>
<p>  <strong>图示</strong></p>
</blockquote>
<p><img src="/2020/05/26/JavaSE/image-20210730212054243.png" alt="image-20210730212054243"></p>
<blockquote>
<p>  <strong>注意事项</strong>：</p>
</blockquote>
<p><strong>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为 new 的子类对象</strong>。并没有创建对应的父类实例，只是将父类的 Class 对象加载到内存中读取了被子类继承的方法和属性而已。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Java 虽然不支持多继承，但支持多层继承。所有的类都继承自 java.lang.Object 类，这就意味着所的类具有 Object 类声明的功能。</p>
<blockquote>
<p>  <a href>Object</a></p>
</blockquote>
<hr>
<h1 id="13-抽象类"><a href="#13-抽象类" class="headerlink" title="13    抽象类"></a>13    抽象类</h1><h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1    概述"></a>13.1    概述</h2><blockquote>
<p>父类中的方法，往往被多个子类重写，子类各自的实现方式不尽相同。所以父类中方法的<strong>方法声明</strong>和<strong>方法体</strong>，大多数时候只有方法声明还有意义，而方法主体则没有实际意义了。为了方便，大多数时候我们在父类中只编写<strong>方法声明</strong>，而把具体的<strong>方法体</strong>交给子类去实现。</p>
</blockquote>
<ul>
<li>我们把没有方法体并使用<code>abstract</code>修饰的方法，叫做<strong>抽象方法</strong>。</li>
<li>把使用<code>abstract</code>修饰的类，叫做<strong>抽象类</strong>。[抽象类中可以没有抽象方法]</li>
</ul>
<h2 id="13-2-abstract"><a href="#13-2-abstract" class="headerlink" title="13.2    abstract"></a>13.2    abstract</h2><blockquote>
<p>  <strong>可以修饰的结构：类、方法</strong></p>
</blockquote>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>  <strong>抽象类不能实例化。</strong></li>
<li>  <strong>但是抽象类中一定有构造器，便于子类实例化时调用。</strong></li>
<li>  开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作。</li>
<li>  <strong>抽象类中，不一定包含抽象方法</strong>，但是包含抽象方法的类必定是抽象类。</li>
<li>  抽象类的子类必须重写父类中所有的抽象方法。否则，该子类也必须声明为抽象类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">    <span class="comment">// 抽象方法（必须）</span></span><br><span class="line">    <span class="comment">// 其它.....</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="抽象类结构"><a href="#抽象类结构" class="headerlink" title="抽象类结构"></a>抽象类结构</h4><p><strong>必须有：</strong></p>
<ol>
<li>构造方法</li>
</ol>
<p><strong>可以有</strong>：</p>
<ol start="2">
<li> 抽象方法</li>
<li> 普通属性、方法</li>
<li> 静态属性、静态方法。</li>
</ol>
<p><strong>总结：</strong>抽象类和普通类只有两点不同：</p>
<ul>
<li>  抽象类必须用 <code>abstract</code> 修饰外；</li>
<li>  抽象类中<strong>可以</strong>包含抽象方法。</li>
</ul>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br><span class="line"><span class="comment">// 没有方法体</span></span><br></pre></td></tr></table></figure>





<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li> <code>abstract</code> 不能用来修饰：属性、构造器等结构</li>
<li> <code>abstract</code> 不能用来修饰私有方法、静态方法、<code>final</code> 的方法、<code>final</code> 的类。</li>
</ol>
<p><strong>理解：</strong></p>
<p><code>abstract</code> 的作用就是定义顶级的接口和方法，一般只起一个声明的作用，而不做具体实现，具体实现交由不同的子类去完成。而我们上面的这些方法：构造方法、私有方法、静态方法、final 方法，它们都有一个共同的特点，就是<strong>每个方法都不能被重写</strong>。这些方法都不能被子类去重新实现，也就是说如果你把这些方法声明为抽象的，它们就会永久成为抽象的了，这样就失去了定义方法的意义。</p>
<blockquote>
<p>  <strong>总结：<code>abstract</code> 修饰的方法，必须要能被重写。</strong></p>
</blockquote>
<h3 id="设计模式——模板方法"><a href="#设计模式——模板方法" class="headerlink" title="设计模式——模板方法"></a>设计模式——模板方法</h3><hr>
<h1 id="14-接口"><a href="#14-接口" class="headerlink" title="14    接口"></a>14    接口</h1><ul>
<li>  接口用来定义一种对外的<strong>规范</strong>。</li>
<li>  接口是一种<strong>引用类型</strong>，是方法的集合。</li>
</ul>
<h2 id="14-1-接口中的成员"><a href="#14-1-接口中的成员" class="headerlink" title="14.1    接口中的成员"></a>14.1    接口中的成员</h2><blockquote>
<p>  <strong>JDK8 之前</strong>：接口中只能定义全局常量和抽象方法。</p>
</blockquote>
<ul>
<li>  <strong>全局</strong>常量：<code>public static final</code>的.但是书写时，可以省略不写</li>
<li>  <strong>全局</strong>抽象方法：<code>public abstract</code> 的方法</li>
<li>  注意：一定要是全局 <code>public</code> 的，不是全局的就会产生编译时异常。</li>
</ul>
<img src="/2020/05/26/JavaSE/image-20210731003259648.png" alt="image-20210731003259648" style="zoom:80%;">



<blockquote>
<ol start="2">
<li> <strong>从 JDK8 开始</strong>：接口中除了定义全局常量和抽象方法之外，还可以定义<strong>静态方法、默认方法</strong>。</li>
</ol>
</blockquote>
<ul>
<li>  <strong>注意</strong>：无论是静态方法还是默认方法，前提都必须是<strong>全局方法</strong>。</li>
</ul>
<img src="/2020/05/26/JavaSE/image-20210731003735380.png" alt="image-20210731003735380" style="zoom:80%;">



<blockquote>
<ol start="3">
<li> <strong>从 JDK9 开始</strong>：接口中新增可以定义私有（private）方法了。</li>
</ol>
</blockquote>
<ul>
<li>  接口中的私有方法用于改善接口内部的代码可重用性。比如多个 default 方法中存在重复的代码可以抽取出一个 private 方法供接口内部调用。但是这个方法是不会对外暴露的，所以说接口对外暴露的方法都要求必须是全局(public)的。</li>
<li>  可以说正是因为 JDK8 的改动才导致 JDK9 需要在接口内部新增可以定义私有方法。因为在 JDK8 之前，接口内部是不存在方法实现的，从 JDK8 开始新增了 默认方法 和 静态方法 后，接口内部才可以写一些方法实现了。</li>
</ul>
<blockquote>
<p>  <strong>总结</strong></p>
</blockquote>
<ol>
<li><p> 接口中对外暴露的方法必须是<strong>全局方法</strong>。</p>
</li>
<li><p> 接口中<strong>只能定义方法和常量</strong>，<strong>变量和代码块都不能在接口中定义</strong>。</p>
</li>
<li><p> 接口中没有构造方法，不能被实例化。</p>
</li>
<li><p> 接口中的默认方法（default 修饰的方法）与类中的默认权限修饰符方法是不同的。</p>
</li>
<li><p> 如果实现类实现了接口中的所有抽象方法，则此实现类就可以实例化了；如果实现类没有实现接口中的所有抽象方法，则此实现类仍为一个抽象类，仍然不能被实例化。</p>
</li>
<li><p>Java类可以实现多个接口。【弥补了Java单继承性的局限性】</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">BB</span> <span class="keyword">implements</span> <span class="title class_">CC</span>,DD,EE</span><br></pre></td></tr></table></figure></li>
<li><p> 接口与接口之间可以继承，而且可以多继承。</p>
</li>
</ol>
<h3 id="接口、普通类、抽象类中的成员比较"><a href="#接口、普通类、抽象类中的成员比较" class="headerlink" title="接口、普通类、抽象类中的成员比较"></a>接口、普通类、抽象类中的成员比较</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">普通类</th>
<th align="center">抽象类</th>
<th align="center">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">属性（成员<strong>变量</strong>）</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center"><strong>全局</strong>常量<code>[public static final]</code></td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">构造方法</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center">成员方法</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">抽象方法</td>
<td align="center">✖</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">私有方法</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔<code>[JDK9++]</code></td>
</tr>
<tr>
<td align="center">静态方法</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔<code>[JDK8++]</code></td>
</tr>
<tr>
<td align="center">默认方法</td>
<td align="center">–</td>
<td align="center">1️⃣</td>
<td align="center">✔<code>[JDK8++]</code></td>
</tr>
<tr>
<td align="center">静态代码块</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
</tbody></table>
<h2 id="14-2-接口-vs-抽象类"><a href="#14-2-接口-vs-抽象类" class="headerlink" title="14.2    接口 vs.抽象类"></a>14.2    接口 vs.抽象类</h2><ul>
<li>  接口和抽象类都不能被实例化。</li>
<li>  但是抽象类中有构造方法，而接口中没有构造方法。</li>
<li>  创建接口的实现类对象，就可以调用接口中的<strong>非静态和非私有</strong>方法了。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">接口</th>
<th align="center">抽象类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否可以实例化？</td>
<td align="center">✖</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center">是否包含构造方法？</td>
<td align="center">✖</td>
<td align="center">✔</td>
</tr>
</tbody></table>
<h2 id="14-3-接口中的成员详解"><a href="#14-3-接口中的成员详解" class="headerlink" title="14.3    接口中的成员详解"></a>14.3    接口中的成员详解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名称&#123;</span><br><span class="line">    <span class="comment">// 全局抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 全局默认方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-抽象方法"><a href="#1-抽象方法" class="headerlink" title="1    抽象方法"></a>1    抽象方法</h3><ol>
<li>使用<code>public abstract abstract</code> 修饰，没有方法体，该方法供子类实现使用。</li>
<li>接口中有多个抽象方法并且抽象方法有重名时，只需重写一次。</li>
</ol>
<h3 id="2-默认方法（JDK8-）"><a href="#2-默认方法（JDK8-）" class="headerlink" title="2    默认方法（JDK8++）"></a>2    默认方法（JDK8++）</h3><ol>
<li><p>使用<code>public default</code>修饰，供子类调用或重写。</p>
</li>
<li><p>实现类可以继承，可以重写默认方法，但是只能通过实现类的对象来调用（因为接口不能创建实例对象）。[实现类的对象又可以使用接口来表示，这就是多态，父类引用指向子类对象]</p>
</li>
</ol>
<h3 id="3-静态方法（JDK8-）"><a href="#3-静态方法（JDK8-）" class="headerlink" title="3     静态方法（JDK8++）"></a>3     静态方法（JDK8++）</h3><ol>
<li>使用<code>public static</code> 修饰，<strong>只能</strong>通过 <code>接口名.方法名</code> 直接调用。【因为接口不能创建实例对象】</li>
<li>静态方法保存在内存中的方法区，<strong>只能使用接口名调用，不能通过实现类名或实现类对象调用</strong>。</li>
</ol>
<ul>
<li>  普通类中的静态方法，既可以通过类名调用，也可以通过实例对象调用。</li>
<li>  接口中的静态方法，不能够通过 实现类类名 和 实现类对象 调用。</li>
<li>  普通类中，静态属性和静态方法只保留一份在方法区中，实例对象中保存着 Class 对象的地址，所以可以通过实例对象调用 Class 对象中的属性和方法。</li>
<li>  但是在接口中，子类实现接口的时候 私有方法 和 静态方法 不会继承给子类，所以子类成员中就已经失去了私有方法和静态方法，显然实例化时也没有私有方法和静态方法的地址信息，所以不能通过 实现类类名 和 实现类对象 调用。*</li>
</ul>
<ol start="3">
<li>接口中，存在同名的静态方法并不会冲突，因为静态方法不会继承给实现类，只能通过各自的接口名访问。</li>
</ol>
<h3 id="4-私有方法"><a href="#4-私有方法" class="headerlink" title="4    私有方法"></a>4    私有方法</h3><ol>
<li><p>使用<code>private</code>关键字修饰，<strong>在接口中可以省略</strong>，<strong>供接口中的默认方法或静态方法调用</strong>。</p>
<ul>
<li><strong>私有方法</strong>：只有默认方法可以调用。</li>
<li><strong>私有静态方法</strong>：默认方法和静态方法都可以调用。</li>
</ul>
</li>
<li><p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么就可以抽取出来，封装到私有方法中，供默认方法调用【类似于工具类】。</p>
</li>
</ol>
<hr>
<h2 id="14-4-接口的实现"><a href="#14-4-接口的实现" class="headerlink" title="14.4    接口的实现"></a>14.4    接口的实现</h2><blockquote>
<p>类与接口的关系叫做实现关系。即<strong>类实现接口</strong>。</p>
<p>该类可以称为接口的实现类，也可以称为接口的子类。</p>
</blockquote>
<h3 id="1-非抽象子类实现接口"><a href="#1-非抽象子类实现接口" class="headerlink" title="1  非抽象子类实现接口"></a>1  非抽象子类实现接口</h3><ol>
<li>必须重写接口中所有抽象方法。</li>
<li>继承了接口中的默认方法，既可以直接调用，也可以重写。</li>
<li>无法继承接口中的私有方法和静态方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 子类 implements 接口名&#123;</span><br><span class="line">    <span class="comment">// 重写接口中的抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中的默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-接口的多实现"><a href="#2-接口的多实现" class="headerlink" title="2.    接口的多实现"></a>2.    接口的多实现</h3><ul>
<li>一个类只能继承一个父类。</li>
<li>但是，一个类可以实现多个接口。</li>
<li>而且，一个类可以继承一个父类的同时，实现多个接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 子类名 extends 父类名 implements 接口名<span class="number">1</span>，接口名<span class="number">2</span>，...&#123;</span><br><span class="line">    <span class="comment">// 重写接口中的抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中的默认方法【不重名时可选】</span></span><br><span class="line">    <span class="comment">// 重写其它方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h4><ul>
<li><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</p>
<p><strong><code>extends &gt; 接口1 &gt; 接口2 &gt; ...</code></strong></p>
</li>
</ul>
<hr>
<h2 id="14-5-接口的多继承"><a href="#14-5-接口的多继承" class="headerlink" title="14.5    接口的多继承"></a>14.5    接口的多继承</h2><ul>
<li>一个类只能直接继承一个父类，</li>
<li>但是，一个接口能继承另一个或多个接口。</li>
<li>接口的继承使用<code>extends</code>关键字。</li>
<li>子接口继承多个父接口，如果父接口中的方法有重名的，那么子接口需要重写一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B&#123;	<span class="comment">// A,B都是接口</span></span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附1：-1"><a href="#附1：-1" class="headerlink" title="附1："></a>附1：</h4><ol>
<li>子接口重写默认方法时，<code>default</code>关键字可以保留。</li>
<li><strong>子类(实现类)重写默认方法时，<code>default</code>关键字不可以保留。</strong></li>
</ol>
<hr>
<h2 id="14-6-接口中的注意事项"><a href="#14-6-接口中的注意事项" class="headerlink" title="14.6    接口中的注意事项"></a>14.6    接口中的注意事项</h2><ol>
<li><strong>接口中，无法定义成员变量，但是可以定义成员常量</strong>，其值不可以改变，使用<code>public static final</code>修饰。</li>
<li>接口中，没有构造方法，不能创建对象<strong>。</strong></li>
<li>接口中，只能有方法和常量，不能有代码块（包括静态代码块和非静态代码块）。</li>
<li><strong>类优先原则</strong>：如果子类同时继承了父类和实现了接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。</li>
<li><strong>接口冲突原则：</strong>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没重写此方法的情况下会报错。这就需要我们必须在实现类中重写此方法</li>
<li>通过实现类的对象，可以调用接口中的默认方法。如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法。</li>
<li>如果想要在实现类中调用接口中的默认方法，可以通过 <code>super.方法名</code> 来调用。</li>
</ol>
<hr>
<h1 id="15-多态"><a href="#15-多态" class="headerlink" title="15    多态"></a>15    多态</h1><h2 id="15-1-是什么"><a href="#15-1-是什么" class="headerlink" title="15.1    是什么"></a>15.1    是什么</h2><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<ul>
<li>  多态是指同一行为，具有多个不同的表现形式。</li>
<li>  指<strong>程序中定义的引用变量所指向的具体类型和通过该引用变量调用的方法调用在编译期并不确定，而是在运行期才确定</strong>。</li>
</ul>
<blockquote>
<p>  <strong>对象的多态性</strong>：</p>
</blockquote>
<p>父类的引用指向子类的对象。</p>
<blockquote>
<p>  <strong>充要条件</strong>：</p>
</blockquote>
<ol>
<li>继承或实现。【二选一】</li>
<li>重写父类方法。【意义体现】</li>
<li>父类引用指向子类对象。【格式体现】</li>
</ol>
<blockquote>
<p>  <strong>格式</strong>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>注意事项</strong>：</p>
</blockquote>
<ul>
<li>对象的多态性，只适用于方法，不适用于属性。</li>
<li>用多态的方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后的方法。</li>
</ul>
<blockquote>
<p>  <strong>多态的好处</strong>：</p>
</blockquote>
<ul>
<li>  定义时可以只定义顶层接口(类)，具体实现的时候再关注到底层细节。</li>
</ul>
<hr>
<h2 id="15-2-向上转型-amp-向下转型"><a href="#15-2-向上转型-amp-向下转型" class="headerlink" title="15.2    向上转型 &amp; 向下转型"></a>15.2    向上转型 &amp; 向下转型</h2><h3 id="1-向上转型"><a href="#1-向上转型" class="headerlink" title="1.    向上转型"></a>1.    向上转型</h3><ul>
<li>向上转型 == 多态；</li>
<li>多态本身就是子类类型向父类类型转换的过程，这个过程是默认的。</li>
<li>当父类引用指向一个子类对象时，便是向上转型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br></pre></td></tr></table></figure>





<h3 id="2-向下转型"><a href="#2-向下转型" class="headerlink" title="2.    向下转型"></a>2.    向下转型</h3><blockquote>
<p>  <strong>是什么？</strong></p>
</blockquote>
<ul>
<li><p>向下转型：父类类型向子类类型转换的过程，这个过程是<strong>强制</strong>的。</p>
</li>
<li><p>将父类实例转换为子类实例可以使用强制类型转换的格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型)父类对象的变量名;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>  <strong>为什么要向下转型？</strong></p>
</blockquote>
<p>由于对象具有多态性，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？就是使用向下转型。</p>
<blockquote>
<p>  <strong>注意：转型的异常</strong></p>
</blockquote>
<ol>
<li> 使用强转时，可能出现 <strong>ClassCastException</strong> 的异常。</li>
<li> 为了避免在向下转型时出现 <code>ClassCastException </code>的异常，我们在向下转型之前，会先进行 <code>instanceof </code>的判断，只有返回为 true 时才进行向下转型；如果返回 false 则不进行向下转型。</li>
</ol>
<blockquote>
<p>  <strong>instanceof 的使用：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">① a <span class="keyword">instanceof</span> A：判断对象a是否是类A的实例，如果是返回<span class="literal">true</span>；如果不是返回<span class="literal">false</span>。</span><br><span class="line">② 如果 a <span class="keyword">instanceof</span> A 返回<span class="literal">true</span>，则 a <span class="keyword">instanceof</span> B 也返回<span class="literal">true</span>。其中，类B是类A的父类。</span><br><span class="line">③ 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</span><br><span class="line"></span><br><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1. 如果变量名属于该类型，则返回true；</span></span><br><span class="line"><span class="comment">	2. 如果变量名不属于该类型，则返回false。</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>规范的语法格式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"><span class="keyword">if</span> (p1 <span class="keyword">instanceof</span> Woman) &#123;</span><br><span class="line">    <span class="type">Woman</span> <span class="variable">w</span> <span class="operator">=</span> (Woman) p1;	<span class="comment">//强制类型转换，向下转型</span></span><br><span class="line">    w.shopping();	<span class="comment">//调用子类方法</span></span><br><span class="line">    w.beauty = <span class="literal">false</span>;	<span class="comment">//调用子类属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-对比"><a href="#3-对比" class="headerlink" title="3    对比"></a>3    对比</h3><p><img src="/2020/05/26/JavaSE/image-20210730215015521.png" alt="image-20210730215015521"></p>
<hr>
<h2 id="15-3-接口多态的综合案例"><a href="#15-3-接口多态的综合案例" class="headerlink" title="15.3    接口多态的综合案例"></a>15.3    接口多态的综合案例</h2><h3 id="1-笔记本电脑"><a href="#1-笔记本电脑" class="headerlink" title="1.    笔记本电脑"></a>1.    笔记本电脑</h3><pre><code>笔记本电脑（laptop）通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口，但是具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。

定义USB接口，具备最基本的开启功能和关闭功能。

鼠标和键盘想要能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘生产出来也无法使用。
</code></pre>
<h3 id="2-案例分析"><a href="#2-案例分析" class="headerlink" title="2.    案例分析"></a>2.    案例分析</h3><pre><code>定义笔记本类，USB接口，USB鼠标类，USB键盘类。
</code></pre>
<ol>
<li>USB接口，包括开启、关闭功能</li>
<li>笔记本类，包含运行功能、关机功能、使用USB设备功能</li>
<li>鼠标类，要实现USB接口，并具备点击功能。</li>
<li>键盘类，要实现USB接口，并具备敲击功能。</li>
</ol>
<h3 id="3-案例实现"><a href="#3-案例实现" class="headerlink" title="3.    案例实现"></a>3.    案例实现</h3><ol>
<li><p>定义USB接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// USB接口，包括开启、关闭功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Usb</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义Mouse实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标已连接，可正常使用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标已断开连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;点击鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>定义Keyboard实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Keyboard</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘已连接，可正常使用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘已断开连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">knock</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;敲击键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>定义笔记本Laptop类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  笔记本类：包含运行功能、关机功能、使用USB设备功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Laptop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一键关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用USB设备功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useUsb</span><span class="params">(Usb usb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (usb!=<span class="literal">null</span>)&#123;</span><br><span class="line">            usb.open();</span><br><span class="line">            <span class="keyword">if</span> (usb <span class="keyword">instanceof</span> Mouse)&#123;</span><br><span class="line">                ((Mouse) usb).click();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (usb <span class="keyword">instanceof</span> Keyboard)&#123;</span><br><span class="line">                ((Keyboard) usb).knock();</span><br><span class="line">            &#125;</span><br><span class="line">            usb.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Laptop</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义笔记本类，USB接口，USB鼠标类，USB键盘类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1. USB接口，包括开启、关闭功能</span></span><br><span class="line"><span class="comment">        2. 笔记本类，包含运行功能、关机功能、使用USB设备功能</span></span><br><span class="line"><span class="comment">        3. 鼠标类，要实现USB接口，并具备点击功能。</span></span><br><span class="line"><span class="comment">        4. 键盘类，要实现USB接口，并具备敲击功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个笔记本对象</span></span><br><span class="line">        <span class="type">Laptop</span> <span class="variable">laptop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Laptop</span>();</span><br><span class="line">        <span class="comment">// 2. 笔记本开机</span></span><br><span class="line">        laptop.run();</span><br><span class="line">        <span class="comment">// 3. 使用鼠标</span></span><br><span class="line">        laptop.useUsb(<span class="keyword">new</span> <span class="title class_">Mouse</span>());</span><br><span class="line">        <span class="comment">// 4. 使用键盘</span></span><br><span class="line">        laptop.useUsb(<span class="keyword">new</span> <span class="title class_">Keyboard</span>());</span><br><span class="line">        <span class="comment">// 5. 笔记本关机</span></span><br><span class="line">        laptop.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/08/02/%E6%B3%9B%E5%9E%8B/">超链接：泛型</a></p>
<hr>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/31/%E5%BC%82%E5%B8%B8/">超链接：异常</a></p>
<hr>
<h1 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/10/13/IO%E7%B3%BB%E7%BB%9F/">超链接：IO</a></p>
<hr>
<h1 id="容器（数组-集合）"><a href="#容器（数组-集合）" class="headerlink" title="容器（数组 + 集合）"></a>容器（数组 + 集合）</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/">超链接：容器</a></p>
<hr>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/01/29/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">超链接：Java8新特性</a></p>
<hr>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/08/20/%E5%8F%8D%E5%B0%84/">超链接：反射</a></p>
<hr>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/08/02/%E6%9E%9A%E4%B8%BE/">超链接：枚举</a></p>
<hr>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/08/02/%E6%B3%A8%E8%A7%A3/">超链接：注解</a></p>
<h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><blockquote>
<ol>
<li> <strong>java.lang.Object类的说明：</strong></li>
</ol>
</blockquote>
<ol>
<li> Object 类是所有类的根类。</li>
<li> 如果在类的声明中未使用 <code>extends</code> 关键字指明其父类，则默认父类为 <code>java.lang.Object</code> 类。 </li>
<li>Object 类中的功能(属性、方法)具有通用性。<ul>
<li>  属性：无</li>
<li>  方法：<code>equals() | toString() | getClass() | hashCode() | clone() | finalize() | wait() | notify() | notifyAll()</code></li>
</ul>
</li>
<li> Object类只声明了一个空参的构造器</li>
</ol>
<blockquote>
<ol start="2">
<li> <strong>equals() 方法</strong></li>
</ol>
</blockquote>
<ol>
<li><p> 只适用于引用数据类型。</p>
</li>
<li><p>Object 类中定义的 <code>equals()</code> 和 <code>==</code> 的作用是相同的，都是比较两个对象的地址值是否相同。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码：Object#equals()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 诸如 String、Date、File、包装类等都重写了 <code>Object#equals()</code> 方法。重写后比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p>
</li>
<li><p>如果我们自定义的类需要使用 <code>equals()</code> 比较两个对象的”实体内容”是否相同的话。那么我们就需要重写继承自 Object类中的<code>equals()</code> 方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写其equals()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age == u.age &amp;&amp; <span class="built_in">this</span>.name.equals(u.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 在实际开发中，可以使用 IDE 工具的提供的自动生成功能。</p>
</li>
<li><p>回顾 <code>==</code> 运算符的使用：</p>
<ul>
<li>  可以用在基本数据类型变量和引用数据类型变量中</li>
<li>  如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</li>
</ul>
<ul>
<li>   如果比较的是引用数据类型变量：比较两个对象的地址值是否相同。</li>
<li>补充：<code>==</code> 符号使用时，必须保证符号左右两边的变量类型一致。</li>
</ul>
</li>
</ol>
<blockquote>
<ol start="3">
<li> <strong>toString()方法</strong></li>
</ol>
</blockquote>
<ol>
<li><p> 当我们输出一个对象的引用时，实际上就是调用当前对象的 <code>toString()</code>。</p>
</li>
<li><p>Object 类中 <code>toString()</code> 的定义：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p> 像 <code>String、Date、File、包装类</code> 等都重写了 Object 类中的 <code>toString()</code> 方法。使得在调用对象的 <code>toString()</code> 时，返回”实体内容”信息。</p>
</li>
<li><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写示例</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Customer [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h2 id="为什么要有包装类"><a href="#为什么要有包装类" class="headerlink" title="为什么要有包装类"></a>为什么要有包装类</h2><ul>
<li>  为了使基本数据类型的变量具有类的特征，引入包装类。</li>
<li>  因为有一些方法只能通过引用类型对象才能调用，基本数据类型变量是无法胜任的。最常见的比如继承自 Object 类的诸多方法。</li>
</ul>
<h2 id="基本数据类型与对应的包装类"><a href="#基本数据类型与对应的包装类" class="headerlink" title="基本数据类型与对应的包装类"></a>基本数据类型与对应的包装类</h2><p><img src="/2020/05/26/JavaSE/image-20210730221022919.png" alt="image-20210730221022919"></p>
<p>​    </p>
<h2 id="需要掌握的类型间的转换：（基本数据类型、包装类、String）"><a href="#需要掌握的类型间的转换：（基本数据类型、包装类、String）" class="headerlink" title="需要掌握的类型间的转换：（基本数据类型、包装类、String）"></a>需要掌握的类型间的转换：（基本数据类型、包装类、String）</h2><p><img src="/2020/05/26/JavaSE/image-20210730221227422.png" alt="image-20210730221227422"></p>
<blockquote>
<p>  <strong>简易版</strong></p>
</blockquote>
<ol>
<li> <code>基本数据类型&lt;---&gt;包装类</code>：自动装箱 与 自动拆箱</li>
<li> <code>基本数据类型/包装类 --&gt; String</code>：调用 String 重载的 <code>valueOf(Xxx xxx)</code></li>
<li><code>String---&gt;基本数据类型/包装类</code>：调用包装类的 <code>parseXxx(String s)</code><ul>
<li>  注意：转换时，可能会报NumberFormatException</li>
</ul>
</li>
</ol>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/06/13/String/">超链接：String 详解</a></li>
</ul>
<h1 id="Java-比较器"><a href="#Java-比较器" class="headerlink" title="Java 比较器"></a>Java 比较器</h1><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/09/14/Java%E4%B8%ADComparable%E6%8E%A5%E5%8F%A3%E5%92%8CComparator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/">超链接：Java中Comparable接口和Comparator接口的区别</a>     </li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/04/20/Listener/" rel="prev" title="Listener">
                  <i class="fa fa-chevron-left"></i> Listener
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/" rel="next" title="容器（数组+集合）">
                  容器（数组+集合） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
