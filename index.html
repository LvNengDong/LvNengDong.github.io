<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/15/IDEA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/15/IDEA/" class="post-title-link" itemprop="url">IDEA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-15 22:28:31 / Modified: 22:57:51" itemprop="dateCreated datePublished" datetime="2022-07-15T22:28:31+08:00">2022-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">开发工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IDEA界面介绍"><a href="#IDEA界面介绍" class="headerlink" title="IDEA界面介绍"></a>IDEA界面介绍</h1><p>界面介绍</p>
<p>工具窗口切换</p>
<p>添加标记标签断点记录</p>
<h1 id="单文件编辑"><a href="#单文件编辑" class="headerlink" title="单文件编辑"></a>单文件编辑</h1><h1 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h1><h1 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h1><ul>
<li><p>添加断点    ctrl+ F8</p>
</li>
<li><p>单步运行（step over）在当前类中一行一行执行代码，不进入方法内部。  F8</p>
</li>
<li><p>从一个断点跳到下一个断点（F9）</p>
</li>
<li><p>查看所有断点 <code>ctrl+shift+F8</code></p>
</li>
<li><p>禁用所有断点 </p>
</li>
<li><p>表达式求值</p>
<ul>
<li>表达式求值不会影响到后面程序的执行</li>
</ul>
</li>
</ul>
<p><img src="/2022/07/15/IDEA/image-20220715225504958.png" alt="image-20220715225504958"></p>
<h1 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h1><h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/27/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/27/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC/" class="post-title-link" itemprop="url">网络数据在内核中如何流转?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-27 22:58:51" itemprop="dateCreated datePublished" datetime="2022-06-27T22:58:51+08:00">2022-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-28 00:28:57" itemprop="dateModified" datetime="2022-06-28T00:28:57+08:00">2022-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">理论基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一次具体的网络数据收发过程"><a href="#一次具体的网络数据收发过程" class="headerlink" title="一次具体的网络数据收发过程"></a>一次具体的网络数据收发过程</h2><h3 id="应用程序通过网络发送数据总览"><a href="#应用程序通过网络发送数据总览" class="headerlink" title="应用程序通过网络发送数据总览"></a>应用程序通过网络发送数据总览</h3><p>首先应用程序会准备好数据，使用用户态下的库函数（比如调用Java的 NIO 的 Socket API 中的 write 方法）去调用“系统调用”，接着调用系统的 API 接口函数，进入内核态。。</p>
<blockquote>
<p>用户态下的库函数不能直接操作一些权限等级较高的内核操作，只能通过发送系统调用，让系统调用代为处理。</p>
</blockquote>
<p>内核态对应的系统服务函数会复制应用程序进程中的数据到内核的内存空间中，然后将数据移交给网络协议栈，在网络协议栈中将数据层层打包。</p>
<p>最后，包装好的数据会交给网卡驱动，网卡驱动程序负责将打包好的数据写入网卡并让其发送出去。</p>
<p>其一般流程图如下所示：</p>
<img src="/2022/06/27/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC/dcb38fc1c0eef666eb1496cbf97a82bc.jpg" alt="img" style="zoom: 25%;">



<h3 id="接收过程总览"><a href="#接收过程总览" class="headerlink" title="接收过程总览"></a>接收过程总览</h3><p>接收数据就是发送数据的逆过程。</p>
<p>首先，网卡接收到数据，通过 DMA 复制到指定的内存；接着发送中断，用于通知网卡驱动结束复制数据。然后网络协议接收到网卡驱动传过来的数据，层层解包，获取真正的有效数据。最后，这个数据会发送给用户态监听的应用进程。</p>
<img src="/2022/06/27/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC/8a726909f0a19ff1683e541d3712b4dd.jpg" alt="img" style="zoom:25%;">





<hr>
<h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>Internet 套接字是 TCP/IP 协议栈中传输层协议的接口，也是传输层以上所有协议的实现。</p>
<p>在 Linux</p>
<p>也就是说，HTTP 数据必须先封装到 Socket 结构的数据，才能继续包装成 TCP 数据包。 </p>
<p>你在A镇，想给在B镇的老婆捎句话。但是A镇和B镇太远了，于是你就想着打电话。[想要进行网络通信]</p>
<p>但是电话只有镇长家才有，镇长是上流社会的，你又不认识镇长。[用户态无法操作内核态]</p>
<p>镇长有一个司机，[内核态Socket]</p>
<p>这个司机的老婆是你的邻居，[用户态Socket]</p>
<p>你们非常熟，</p>
<p>于是，你拜托司机的老婆，把你要给自己老婆说的话写在纸上来给她[数据-&gt;用户态Socket]</p>
<p>司机的老婆又跟司机说了这个事儿[用户态Socket-&gt;内核态Socket]</p>
<p>司机最后跟镇长说了这个事，</p>
<p>镇长也是个热心肠的人，拿着你的信一字一句的打电话到B镇镇长家里；[TCP网络通信]</p>
<p>B镇镇长又一层层把消息最终传给你的老婆。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/27/%E8%BE%93%E5%85%A5URL%EF%BC%8C%E4%BB%8E%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%88%B0%E5%93%8D%E5%BA%94%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/27/%E8%BE%93%E5%85%A5URL%EF%BC%8C%E4%BB%8E%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%88%B0%E5%93%8D%E5%BA%94%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%EF%BC%9F/" class="post-title-link" itemprop="url">输入URL，从一个请求到响应都发生了什么事？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-27 21:12:20 / Modified: 22:59:22" itemprop="dateCreated datePublished" datetime="2022-06-27T21:12:20+08:00">2022-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">理论基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="输入URL，从一个请求到响应都发生了什么事？"><a href="#输入URL，从一个请求到响应都发生了什么事？" class="headerlink" title="输入URL，从一个请求到响应都发生了什么事？"></a>输入URL，从一个请求到响应都发生了什么事？</h1><h2 id="全局概览"><a href="#全局概览" class="headerlink" title="全局概览"></a>全局概览</h2><ol>
<li><p>常规的网络交互过程是从客户端发起网络请求，用户态的应用程序（比如浏览器）会生成 HTTP 请求报文，并通过 DNS 协议查找到对应的远端 IP 地址。</p>
<blockquote>
<p>如果我们使用的是</p>
</blockquote>
</li>
<li><p>在<strong>套接字生成之后</strong>进入内核态，浏览器会委托操作系统内核去通知网络协议栈中的上半部分，也就是 TCP/UDP 协议发起连接请求。</p>
</li>
<li><p>然后经由网络协议栈的下半部分 <strong>IP 协议进行包装，使数据包具有远程定位能力</strong>。</p>
</li>
<li><p>经过 MAC 层处理，找到接收方的 MAC 地址。</p>
</li>
<li><p>最终数据包再经过网卡转化成电信号，电信号经过交换机、路由器发送到服务端，服务端经过处理拿到数据，再通过各种网络协议把数据响应给客户端。</p>
</li>
<li><p>客户端拿到数据进行渲染。</p>
</li>
<li><p>客户端和服务器端之间反复交换数据，客户端的页面数据就会发生变化。</p>
</li>
</ol>
<h2 id="发起请求阶段（应用层）"><a href="#发起请求阶段（应用层）" class="headerlink" title="发起请求阶段（应用层）"></a>发起请求阶段（应用层）</h2><p>应用层是多层网络结构中的最上层，也是我们能直接接触到的一层。</p>
<p>我们手机或电脑使用的软件都是在应用层实现的，包括浏览器、邮件应用、甚至于我们开发人员使用的IDE（比如我们通过IDE去访问远程服务器上的数据）。对于应用层来说，它只需要关注于为用户提供应用功能，不用去关注数据是如何传输的。</p>
<p>你可以理解为：<strong>应用层是工作在操作系统中的用户态</strong>。</p>
<h2 id="用户输入：在浏览器中输入URL"><a href="#用户输入：在浏览器中输入URL" class="headerlink" title="用户输入：在浏览器中输入URL"></a>用户输入：在浏览器中输入URL</h2><p>我们在浏览器中输入 URL 的过程中，浏览器就开始工作了。</p>
<p>首先，浏览器会根据我们的输入内容，匹配相似的 URL 及关键词，给出输入建议，同时校验 URL 的合法性，在你输入的 URL 前后补全这个 URL。</p>
<blockquote>
<p>比如，以我们输入 baidu.com 为例，首先，浏览器会判断这是一个格式合法的 URL，并且补全为 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a></p>
</blockquote>
<p>其中，http 为协议，baidu.com 为网络地址。每个浏览器网络栏中的地址都符合通用 URI 的语法。URI 一般由五个分层序列组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI = scheme:[//authority]path[?query][#fragment]</span><br><span class="line"></span><br><span class="line">URI = 方案:[//授权]路径[?查询][片段ID]</span><br></pre></td></tr></table></figure>

<p>接着，浏览器会从 URL 中提取出网络请求的地址，也即主机名（host）。一般主机名可以是域名或 IP 地址，此处使用域名。</p>
<p><strong>对 URL 进行解析之后，浏览器确定了服务器的主机名和请求路径，接下来就是根据这些信息来生成 HTTP 请求消息了</strong>。</p>
<blockquote>
<p>注：所以 HTTP 请求其实并不神秘，只不过是把一些客户端要发送的数据以特定的格式封装成一个大的数据对象。归根结底只不过是对数据的封装罢了。</p>
</blockquote>
<h2 id="网络请求前：查看浏览器缓存"><a href="#网络请求前：查看浏览器缓存" class="headerlink" title="网络请求前：查看浏览器缓存"></a>网络请求前：查看浏览器缓存</h2><p><strong>浏览器在 HTTP 报文生成完成后</strong>，它并不是马上就开始网络请求的。</p>
<blockquote>
<p>从这句话我们可以看出来，浏览器的一个重要作用是将客户端要发送的数据封装成一个 HTTP 请求。</p>
<p>并且，我们要明白，在 HTTP 请求中，没有服务器 IP 地址，没有服务器进程的端口信息。但是有域名信息。</p>
</blockquote>
<p>在浏览器发出之前，浏览器会先检查本地计算机中的缓存，如果发现之前访问过当前的 URL，会先进入缓存中查询。此时存在的缓存有：路由器缓存、DNS缓存、浏览器缓存、Service Worker、Memory Cache、Disk Cache、Push Cache、系统缓存等。</p>
<p>比如：如果在浏览器缓存里没有命中缓存，<strong>浏览器会做一个系统调用获得系统缓存的记录</strong>，也就是调用 <code>gethostbyname</code> 方法，这是一个系统调用，它的作用是通过域名获取 IP 地址。这个方法会返回如下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> *h_name; <span class="comment">// （字符类型的）主机名，比如 192.168.0.0.1</span></span><br><span class="line">    <span class="type">char</span> **h_aliases; <span class="comment">// 主机的别名。www.baidu.com 就是百度自己服务器的别名 </span></span><br><span class="line">    <span class="type">int</span> h_addrtype; <span class="comment">// 主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)</span></span><br><span class="line">    <span class="type">int</span> h_length; <span class="comment">// 主机ip地址的长度 </span></span><br><span class="line">    <span class="type">char</span> **h_addr_list; <span class="comment">// 主机的ip地址（注意，这个是以网络字节序存储的）</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> h_addr h_addr_list[0] </span></span><br><span class="line">    #这个函数，是将类型为af的网络地址结构src，转换成主机序的字符串形式，存放在长度为cnt的字符串中。返回指向dst的一个指针。如果函数调用错误，返回值是<span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>如果之前没有访问过当前的 URL，就会跳过缓存这一步，这时就真正进入网络中进行操作了。</p>
<h2 id="域名解析：DNS"><a href="#域名解析：DNS" class="headerlink" title="域名解析：DNS"></a>域名解析：DNS</h2><p>浏览器在生成 HTTP 请求之后，需要委托操作系统将 HTTP 报文发送到对应的服务器端。在发送消息之前，必须知道服务器的 IP 地址，而域名服务器提供了通过域名解析 IP 地址的服务。</p>
<h2 id="网络协议栈（传输层和网络层）"><a href="#网络协议栈（传输层和网络层）" class="headerlink" title="网络协议栈（传输层和网络层）"></a>网络协议栈（传输层和网络层）</h2><p>现在我们已经根据 URL 拿到服务器的唯一地址了，接下来就要委托操作系统将 HTTP 报文发送出去了，这个过程由操作系统中的网络协议栈进行处理。</p>
<p>TCP/IP 协议栈是现在使用最广泛的网络协议栈（相较于 OSI 协议栈）。</p>
<p>协议栈是分层结构的，<strong>它的上半部分负责和应用层通过套接字（Socket）进行交互</strong>，它可以是 TCP 或 UDP 协议。应用层会委托协议栈的上半部分（传输层及之上）完成收发数据的工作；而协议栈的下半部分（网络层及之下）则负责把数据发送到指定方的 IP 协议，由 IP 协议连接下层的网卡驱动。</p>
<blockquote>
<p>注：socket 其实就是连接应用层与传输层的一个接口，负责把应用层数据转发给传输层，在传输层按照TCP或UDP协议的格式将数据封装成数据包。</p>
</blockquote>
<p><img src="http://processon.com/chart_image/62b9bf50637689073326365f.png"></p>
<h2 id="可靠性传输：建立TCP连接"><a href="#可靠性传输：建立TCP连接" class="headerlink" title="可靠性传输：建立TCP连接"></a>可靠性传输：建立TCP连接</h2><p>浏览器通过 DNS 解析拿到目标服务器的 IP 后，加上目标服务器的端口（HTTP默认80，HTTPS默认443，这些端口都是服务器公开的，在浏览器输入网址时就已经得到了）。这时浏览器就会委托操作系统调用协议栈的上半部分创建新的套接字（Socket），并向对应的 IP 发起 TCP 连接。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/26/%E4%BB%80%E4%B9%88%E6%98%AFSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/26/%E4%BB%80%E4%B9%88%E6%98%AFSocket/" class="post-title-link" itemprop="url">什么是Socket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-26 00:01:22 / Modified: 20:36:28" itemprop="dateCreated datePublished" datetime="2022-06-26T00:01:22+08:00">2022-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总纲："><a href="#总纲：" class="headerlink" title="总纲："></a>总纲：</h1><p><strong>Socket 是对传输层协议(TCP/UDP)的抽象，是传输层之上与传输层间进行信息交互的接口。我们知道两台计算机之间进行的网络通信是要通过“网卡”这一硬件设备来实现的，而“网卡”一般只有操作系统内核才有权限操作。而一般我们最常见网络通信是应用程序之间的网络通信，比如说：两台电脑上互相聊微信。而微信是操作系统上的一个应用程序，运行中的微信可以称其为一个进程，并且这个进程是处于用户态的，我们知道，用户态的进程是没有权限操作网卡的，为了使两台电脑间的微信能正常通信，这就又涉及到一个概念『系统调用』。系统调用是操作系统提供给用户态进程操作内核资源的一系列接口。通过这些接口可以实现：微信进程发起系统调用 –&gt; 内核操作网卡发送数据给接收端。</strong></p>
<p><strong>但是一个应用程序如何告诉系统调用自己的需求呢？以传输层为 TCP 协议为例，TCP 协议有很多操作，比如监听、接收连接、断开连接、数据传输等。那么这些操作映射到传输层之上，以 Java NIO 举例，就是 Socket 中的各种方法。所以总结下来就是，Socket 是对 TCP/IP 或 UDP 协议的一种映射，通过 Socket 对象中的方法执行的操作，最终会映射到 TCP/UDP 的协议栈上，继而通过“网卡”来完成数据传输。</strong></p>
<p>Socket 就是传输层提供给传输层之上的接口。应用层通过调用这个接口告诉传输层它想要执行的操作。</p>
<p>TCP/UDP 是数据包，那么这些数据从哪儿来呢？应用层！</p>
<p>应用层如何将数据传递给TCP/UDP数据呢？Socket！</p>
<p>正确理解HTTP</p>
<p>HTTP 可以理解为一个数据包，这个数据包在发送的时候还是得把它封装成 TCP 能看懂的数据包。只不过在发送到接收端后再按照一定的规则依次拆解开来即可。</p>
<p>客户端发送数据，不管有没有携带真实数据，肯定发过来一个数据包。那么服务器就要读，所以服务器的Channel中肯定产生了一个可读事件。</p>
<h1 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h1><p>客户端第一次连接服务器，服务器通过 accept 接受连接，同时将一条能连接到客户端的通道中的读事件注册到Selector中。(因为客户端作为数据的发送方，服务器作为数据的接收方，服务器要读取客户端发送过来的数据，所以服务器肯定是要关注自己机器上的读事件)。</p>
<p>在读到数据的同时，服务器还可以把数据写到这条通道中，这条通道就是客户端与服务器连接的通道，通道的另一端就是客户端，这时客户端机器就可以通过读通道中的数据拿到服务器返回的数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">Linux操作系统综述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-24 17:28:30 / Modified: 18:11:00" itemprop="dateCreated datePublished" datetime="2022-06-24T17:28:30+08:00">2022-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/19/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/19/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">Java正则表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-19 22:30:19 / Modified: 22:40:07" itemprop="dateCreated datePublished" datetime="2022-06-19T22:30:19+08:00">2022-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">正则表达式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  应用场景：</p>
<ul>
<li>  文本处理</li>
</ul>
</blockquote>
<h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><p><img src="http://processon.com/chart_image/62af337fe401fd5a4d73c494.png"></p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="Case1："><a href="#Case1：" class="headerlink" title="Case1："></a>Case1：</h2><ol>
<li> 提取文章中所有的英文单词</li>
<li> 提取文章中所有的数字</li>
<li> 提取文章中所有英文单词和数字</li>
<li> 提取报读热榜标题</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">网络编程理论基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-19 09:37:55 / Modified: 10:47:53" itemprop="dateCreated datePublished" datetime="2022-06-19T09:37:55+08:00">2022-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="客户端-服务器网络编程模型"><a href="#客户端-服务器网络编程模型" class="headerlink" title="客户端-服务器网络编程模型"></a>客户端-服务器网络编程模型</h2><p>服务器端需要一开始就监听在某一个众所周知的端口上，等待客户端发送请求，一旦有客户端连接建立，服务器端就会消耗一定的计算机资源为它服务。服务器端是需要同时为成千上万的客户端服务的。如何保证服务器端在数据量巨大的客户端访问时仍能维持效率和稳定，这正是高性能网络编程要解决的问题。</p>
<p>客户端相对来说更为简单，它向服务器端监听的端口发起连接请求，连接建立之后，通过连接桐庐和服务器端进行通信。</p>
<p><strong>还有一点需要强调的是，无论是客户端，还是服务器端，它们运行的单位都是进程(process)，而不是机器。</strong>一个客户端，比如我们的手机终端，同一个时刻可以建立多个到不同服务器的连接，比如同时打游戏，上知乎，逛天猫；而服务器端更是可能在一台机器上部署运行了多个服务，比如同时开启了 SSH 服务和 HTTP 服务。</p>
<h2 id="IP和端口"><a href="#IP和端口" class="headerlink" title="IP和端口"></a>IP和端口</h2><p>端口号是一个 16 位的整数，最多为 65536。当一个客户端发起连接请求时，客户端的端口是由操作系统内核临时分配的，称为临时端口；然而，前面也提到过，服务器端的端口通常是一个众所周知的端口。</p>
<p>一个连接可以通过客户端-服务器端的IP和端口唯一确定，这叫做套接字对，按照下面的四元组表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(clientaddr: clientport, serveraddr: serverport)</span><br></pre></td></tr></table></figure>

<p>下图表示了一个客户端-服务器之间的连接：</p>
<p><img src="https://static001.geekbang.org/resource/image/54/2a/543b5488f9422558069df507cfaa462a.png?wh=1004*328" alt="img"></p>
<h2 id="数据报和字节流"><a href="#数据报和字节流" class="headerlink" title="数据报和字节流"></a>数据报和字节流</h2><p>TCP，又被叫做字节流套接字（Stream Socket），注意我们这里先引入套接字 socket，套接字 socket 在后面几讲中将被反复提起，因为它实际上是网络编程的核心概念。</p>
<p>当然，UDP 也有一个类似的叫法, 数据报套接字（Datagram Socket），一般分别以“SOCK_STREAM”与“SOCK_DGRAM”分别来表示 TCP 和 UDP 套接字。</p>
<h2 id="Socket到底是什么？"><a href="#Socket到底是什么？" class="headerlink" title="Socket到底是什么？"></a>Socket到底是什么？</h2><p><img src="https://static001.geekbang.org/resource/image/0b/64/0ba3f3d04b1466262c02d6f24ee76a64.jpg" alt="img"></p>
<p>这张图是网络编程中，客户端和服务器工作的核心逻辑。</p>
<p>我们先从右侧的服务器端开始看，因为客户端在发起连接请求之前，服务器端必须先初始化好。右侧的图显示的是服务器端初始化的过程。</p>
<ul>
<li>  首先初始化 socket；</li>
<li>  之后服务器端需要执行 bind 函数，将自己的服务能力绑定在一个众所周知的地址和端口上；</li>
<li>  接着，服务器端执行 listen 操作，将原先的 socket 转化为服务端的 socket；</li>
<li>  最后，服务端阻塞在 accept 上等待客户端请求的到来。</li>
</ul>
<p>此时，服务器端已经准备就绪。客户端需要：</p>
<ul>
<li>  先初始化 socket，</li>
<li>  再执行 connect 向服务端的地址和端口号发起连接请求(这里的地址和端口必须是客户端预先知晓的)。这个过程，就是著名的 <strong>TCP三次握手</strong>。</li>
</ul>
<p>一旦三次握手完成，客户端和服务器端建立连接，就进入了数据传输过程。</p>
<p>具体来说，</p>
<ul>
<li>  客户端进程向操作系统内核发起 write 字节流写操作，</li>
<li>  内核协议栈将字节流通过网络设备传输到服务器端，</li>
<li>  服务器端从内核得到消息，将字节流从内核读入到进程中，并开始业务逻辑的处理。</li>
<li>  完成之后，服务器端再将得到的结果以同样的方式写给客户端。</li>
</ul>
<p>可以看到，一旦连接建立，数据的传输就不再是单向的，而是双向的，这也是 TCP 的一个显著特性。</p>
<p>当客户端完成和服务器端的交互后，比如执行一次 Telnet 操作，或者一次 HTTP 请求，需要和服务器端断开连接，就会执行 close 函数……</p>
<p>将这幅图的真正意义在于引入 socket 的概念。请注意，以上所有的操作，都是通过 socket 来完成的。无论是客户端的 connect，还是服务器端的 accept，或者 read/write 操作等，<strong>socket 是我们用来建立连接，传输数据的唯一途径。</strong></p>
<h3 id="更好地理解socket：一个更直观的解释"><a href="#更好地理解socket：一个更直观的解释" class="headerlink" title="更好地理解socket：一个更直观的解释"></a>更好地理解socket：一个更直观的解释</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/14/Guava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/14/Guava/" class="post-title-link" itemprop="url">Guava</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-14 21:28:16" itemprop="dateCreated datePublished" datetime="2022-06-14T21:28:16+08:00">2022-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-17 19:29:07" itemprop="dateModified" datetime="2022-07-17T19:29:07+08:00">2022-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaExt/" itemprop="url" rel="index"><span itemprop="name">JavaExt</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>声明</strong></p>
<p>  本文所有内容均参考自<a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki">Guava官方文档</a>，是在对官方文档汉化的基础上形成的。</p>
</blockquote>
<p>Guava 工程是Google公司开发的一个类库，它被广泛应用在Google公司开发的Java项目中，其中包含了对：</p>
<ul>
<li>  集合[collections]</li>
<li>  缓存[chahing]</li>
<li>  原生类型支持[primitives support]</li>
<li>  并发库[concurrency libraries]</li>
<li>  通用注释[common annotations]</li>
<li>  字符串处理[string processing]</li>
<li>  I/O</li>
<li>  ……</li>
</ul>
<p>等多个模块的支持。所有这些工具每天都被Google工程师应用在产品服务中。</p>
<p><img src="http://processon.com/chart_image/62a88f780e3e747c5c433c56.png"></p>
<p>Guava依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="目-录"><a href="#目-录" class="headerlink" title="目  录"></a>目  录</h1><h2 id="1-基本工具-Basic-utilities"><a href="#1-基本工具-Basic-utilities" class="headerlink" title="1.基本工具[Basic utilities]"></a>1.基本工具[Basic utilities]</h2><p>让使用Java语言变得更舒适。</p>
<ol>
<li> 避免使用null：null是模棱两可的，过度使用null会引起不必要的错误。因此很多Guava工具类都不会使用null值代表失败。</li>
<li> 参数检查：让方法中的条件检查更简单。</li>
<li> 常见Object方法：简化Object方法的实现，如hashCode()和toString()</li>
<li> 排序：Guava强大的流畅风格比较器</li>
<li> Throwables：简化了异常和错误的传播与检查。</li>
</ol>
<h1 id="基本工具-Basic-utilities"><a href="#基本工具-Basic-utilities" class="headerlink" title="基本工具[Basic utilities]"></a>基本工具[Basic utilities]</h1><h2 id="1-避免和使用null"><a href="#1-避免和使用null" class="headerlink" title="1 避免和使用null"></a>1 避免和使用null</h2><h3 id="1-1-为什么要避免使用null？"><a href="#1-1-为什么要避免使用null？" class="headerlink" title="1.1 为什么要避免使用null？"></a>1.1 为什么要避免使用null？</h3><blockquote>
<p><strong>使用 null 的缺点：</strong></p>
</blockquote>
<p>null 代表不确定的对象，是一个很模糊的概念，非常容易产生歧义。</p>
<p>大多数情况下，使用 null 是为了表示<strong>某种缺失</strong>情况，但这并非是绝对的，还有一种情况是：就是想给某个对象赋值为 null。这种情况下就会产生歧义。比如：</p>
<blockquote>
<p><strong>问题：</strong></p>
</blockquote>
<p>如果 <code>Map.get(key)</code> 返回的 value 为 null，其代表的含义可能是该 key 指向的 value 是 null，也可能是该 key 在 map 中不存在。</p>
<blockquote>
<p><strong>优点：</strong></p>
</blockquote>
<p>当然，使用 null 也并非一无是处，null 本身不是对象（不是 Object 实例）。从内存消耗和效率方面来看，使用 null 是更为廉价的。</p>
<h3 id="1-2-对null进行的优化：Optional"><a href="#1-2-对null进行的优化：Optional" class="headerlink" title="1.2 对null进行的优化：Optional"></a>1.2 对null进行的优化：Optional</h3><p>为了解决使用 null 存在的种种弊端，Guava 引入了 <code>Optional&lt;T&gt;</code> 作为对 null 的上位替代。</p>
<p>Guava 中的 <code>Optional&lt;T&gt;</code> 表示了一种<strong>可能为null</strong>的 T 类型对象的引用。Optional 实例中可能包含对非 null 对象的引用（<em>引用存在</em>），也可能什么也不包括（<strong>引用缺失</strong>）。</p>
<h4 id="1-2-1-Optional快速入门"><a href="#1-2-1-Optional快速入门" class="headerlink" title="1.2.1 Optional快速入门"></a>1.2.1 Optional快速入门</h4><ul>
<li>API 所在包：<code>com.google.common.base.Optional</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; possible = Optional.fromNullable(t); <span class="comment">// 将一个T类型的实例包装成一个Optional对象（t可以为null）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">present</span> <span class="operator">=</span> possible.isPresent(); <span class="comment">// 若Optional包含的T实例不为null，则返回true；否则返回false</span></span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> possible.get(); <span class="comment">// 返回Optional包含T的实例，该T实例必须不为空，否则会抛出一个IllegalStateException异常</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-创建一个Optional对象"><a href="#1-2-2-创建一个Optional对象" class="headerlink" title="1.2.2 创建一个Optional对象"></a>1.2.2 创建一个Optional对象</h4><p>Guava 没有提供对 Optional 类公开的构造方法，而是使用工厂模式通过 Optional 类提供了3个创建 Optional 对象的静态方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td><code>Optional&lt;T&gt; fromNullable(T nullableReference)</code></td>
<td>T对象可以为null，也可以不为null</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; of(T reference)</code></td>
<td>T对象不能为null</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; absent()</code></td>
<td>得到的<code>Optional&lt;T&gt;</code>实例内的T实例一定为null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; optional1 = Optional.of(t); <span class="comment">//将一个T类型的实例转换为Optional对象（t不可以为null）</span></span><br><span class="line">Optional&lt;Object&gt; optional2 = Optional.absent(); <span class="comment">// 获得一个Optional对象，其内部为null</span></span><br><span class="line">Optional&lt;T&gt; optional3 = Optional.fromNullable(t); <span class="comment">// 将一个T类型的实例转换为Optional对象，实例t可以不为空，也可以为空</span></span><br><span class="line"><span class="comment">// Optional.fromNullable(null) 等同于 Optional.absent()</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-Optional实例方法"><a href="#1-2-3-Optional实例方法" class="headerlink" title="1.2.3 Optional实例方法"></a>1.2.3 Optional实例方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isPresent()</td>
<td>若Optional包含的T实例不为null，返回true；否则，返回false。</td>
</tr>
<tr>
<td>T get()</td>
<td>若Optional包含的T实例不为null，返回T；否则，抛出IllegalStateException</td>
</tr>
<tr>
<td>T or(T t)</td>
<td>若Optional包含的T实例不为null，返回T；否则，返回参数输入的T实例。</td>
</tr>
<tr>
<td>T orNull()</td>
<td>若Optional包含的T实例不为null，返回T；否则，返回null。</td>
</tr>
</tbody></table>
<h3 id="1-3-Java中的Optional"><a href="#1-3-Java中的Optional" class="headerlink" title="1.3 Java中的Optional"></a>1.3 Java中的Optional</h3><p>正是受到 Guava 的启发，Java8 将 Optional 类作为一个新特性引入自身的类库。所以在大多数时候，我们可以直接使用 Java8 的 Optional 类，以减少对外部 jar 包的依赖。</p>
<blockquote>
<p><strong>链接：<a href>Java8中的Optional新特性</a></strong></p>
<ul>
<li>TODO</li>
</ul>
</blockquote>
<hr>
<h2 id="2-优雅的检验参数-Preconditions"><a href="#2-优雅的检验参数-Preconditions" class="headerlink" title="2 优雅的检验参数[Preconditions]"></a>2 优雅的检验参数[Preconditions]</h2><p><strong>问题：</strong></p>
<p>当对外暴露的接口方法中的参数过多时，需要对参数进行必要的检查，以便将预期外的请求快速驳回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">someMethod</span><span class="params">(<span class="type">int</span> arg1, String arg2, String arg3, Object arg4)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg1&gt;<span class="number">0</span> &amp;&amp; isNotEmpty(arg2) &amp;&amp; isNotEmpty(arg3) &amp;&amp; arg4!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// maybe需要将具体的错误类型告诉调用方</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方案：</strong></p>
<p><code>com.google.common.base.Preconditions</code></p>
<table>
<thead>
<tr>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>checkArgument(boolean expression, String errorMessageTemplate, Object… errorMessageArgs)</td>
</tr>
<tr>
<td>checkNotNull(T reference, String errorMessageTemplate, Object… errorMessageArgs)</td>
</tr>
<tr>
<td>checkState(boolean expression, String errorMessageTemplate, Object… errorMessageArgs)</td>
</tr>
<tr>
<td>checkElementIndex(int index, int size, String desc);</td>
</tr>
<tr>
<td>checkPositionIndex(int index, int size, String desc);</td>
</tr>
<tr>
<td>checkPositionIndexes(int start, int end, int size)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查 boolean 类型的 expression 值是否为 true，</span></span><br><span class="line"><span class="comment"> * 失败时(值为false)抛出IllegalArgumentException并携带错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkArgument(<span class="type">boolean</span> expression, String errorMessageTemplate, Object... errorMessageArgs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查reference对象是否为null，失败时抛出NullPointerException并携带错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkNotNull(T reference, String errorMessageTemplate, Object... errorMessageArgs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查 expression 是否为 true，失败时抛出IllegalStateException并携带错误信息</span></span><br><span class="line"><span class="comment"> * 相比于checkArgument，该方法在某些场景下更有语义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkState(<span class="type">boolean</span> expression, String errorMessageTemplate, Object... errorMessageArgs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查index是否在合法范围 [0,size) 内(不包含size)，若不在合法范围内，</span></span><br><span class="line"><span class="comment"> * 则抛出IndexOutOfBoundsException并携带错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkElementIndex(<span class="type">int</span> index, <span class="type">int</span> size, String desc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查index是否在合法范围 [0,size] 内(包含size)，若不在合法范围内，</span></span><br><span class="line"><span class="comment"> * 则抛出IndexOutOfBoundsException并携带错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkPositionIndex(<span class="type">int</span> index, <span class="type">int</span> size, String desc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查[start, end)是否在 (0, size) 集合的合法子集范围内</span></span><br><span class="line"><span class="comment"> * 失败时抛出IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Preconditions.checkPositionIndexes(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> size);</span><br></pre></td></tr></table></figure>

<p>上述六个方法是 Preconditions 类中的主要方法，当然，Preconditions 还提供了这些类不同参数的重载方法。</p>
<p>以 checkNotNull 为例，它的基本使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/21 16:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreconditionsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            checkNotNull(<span class="literal">null</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           System.out.println(e); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">           System.out.println(e.getMessage()); <span class="comment">// null</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkNotNullWithErrorMessage(<span class="literal">null</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">            System.out.println(e.getMessage()); <span class="comment">// list不能为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkNotNullWithFormatErrorMessage(<span class="literal">null</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">            System.out.println(e.getMessage()); <span class="comment">// list不能为空，errorCode为 9528</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查参数是否为null，若为null则抛出NullPointerException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkNotNull</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        Preconditions.checkNotNull(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查参数是否为null，若为null则抛出NullPointerException，</span></span><br><span class="line"><span class="comment">     * 并将 errorMessage 设置到 NullPointerException 对象的 message 中。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkNotNullWithErrorMessage</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(list, <span class="string">&quot;list不能为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查参数是否为null，若为null则抛出NullPointerException，</span></span><br><span class="line"><span class="comment">     * 并将 errorMessage 设置到 NullPointerException 对象的 message 中；</span></span><br><span class="line"><span class="comment">     * 还提供对 errorMessage 进行格式化的功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkNotNullWithFormatErrorMessage</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(list, <span class="string">&quot;list不能为空，errorCode为 %s&quot;</span>, <span class="number">9528</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>checkArgument</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_checkArgument</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">arg1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Preconditions.checkArgument(arg1.equals(<span class="string">&quot;World&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(e); <span class="comment">// java.lang.IllegalArgumentException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>checkElementIndex</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  现有一空数组，容量为 0。</span></span><br><span class="line"><span class="comment"> *  欲取数组中下标为 10 的位置上的元素，必然会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_checkElementIndex</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Preconditions.checkElementIndex(<span class="number">10</span>, list.size());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(e); <span class="comment">// java.lang.IndexOutOfBoundsException: index (10) must be less than size (0)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>checkPositionIndexes(int start, int end, int size)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preconditions.checkPositionIndexes(<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>); <span class="comment">//OK。size为10，[0,5) 在[0,10)的范围内</span></span><br><span class="line">Preconditions.checkPositionIndexes(<span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>); <span class="comment">//OK</span></span><br><span class="line">Preconditions.checkPositionIndexes(<span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// java.lang.IndexOutOfBoundsException: end index (5) must not be greater than size (4)</span></span><br><span class="line"><span class="comment">// size为4，[0,5) 不在[0,4) 的范围内</span></span><br></pre></td></tr></table></figure>







<hr>
<h2 id="3-常见的Object方法-Objects"><a href="#3-常见的Object方法-Objects" class="headerlink" title="3. 常见的Object方法[Objects]"></a>3. 常见的Object方法[Objects]</h2><p>帮助简化对象的 equals、hashCode、toString、compare、compareTo 等方法的编写。</p>
<h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h3><ul>
<li>实现 Comparable 接口；</li>
<li>重写 compareTo 方法，使用 ComparisonChain 简化比较过程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.ComparisonChain;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/17 0:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;User&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ComparisonChain.start()</span><br><span class="line">                .compare(<span class="built_in">this</span>.name, user.name)</span><br><span class="line">                .compare(<span class="built_in">this</span>.age, user.age)</span><br><span class="line">                .result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="4-强大的比较器-Ordering"><a href="#4-强大的比较器-Ordering" class="headerlink" title="4. 强大的比较器(Ordering)"></a>4. 强大的比较器(Ordering)</h2><p>Ordering 是 Guava 类库提供的一个强大的比较器工具。和 JDK 中的 Comparator 相比，Guava 中的 Ordering 功能更强，它非常容易扩展，可以很轻松地构造复杂的 Comparator。用于在容器中进行比较、排序等操作。</p>
<p><strong>常用静态方法：</strong></p>
<p><code>com.google.common.collect.Ordering</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ordering.natural(); <span class="comment">//使用Comparable类型的自然排序。比如：整数从小到大，字符串按字典顺序排序。</span></span><br><span class="line">Ordering.usingToString(); <span class="comment">//使用toString()返回的字符串按字典顺序进行排序</span></span><br><span class="line">Ordering.;</span><br><span class="line">Ordering.;</span><br><span class="line">Ordering.;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="集合-Collections"><a href="#集合-Collections" class="headerlink" title="集合[Collections]"></a>集合[Collections]</h1><p>Guava 中最成熟和为人所知的部分就是对 JDK 中集合的扩展。主要包括以下几部分：</p>
<ul>
<li>  <strong>不可变集合</strong></li>
<li>  <strong>新的集合类型</strong></li>
<li>  <strong>强大的集合工具类</strong></li>
<li>  <strong>扩展工具类</strong></li>
</ul>
<h2 id="不可变集合-Immutable-Collections"><a href="#不可变集合-Immutable-Collections" class="headerlink" title="不可变集合[Immutable Collections]"></a>不可变集合[Immutable Collections]</h2><h3 id="为什么要使用不可变集合？"><a href="#为什么要使用不可变集合？" class="headerlink" title="为什么要使用不可变集合？"></a>为什么要使用不可变集合？</h3><p>创建对象的<strong>不可变拷贝</strong>是一项很好的<strong>防御性编程</strong>技巧。因此，Guava 为所有 <strong>JDK标准集合</strong> 类型和 <strong>Guava新集合</strong> 类型都提供了简单易用的不可变版本。</p>
<p><strong>不可变对象的优点：</strong></p>
<ul>
<li>  当对象被不被信任的库调用时，不可变形式是安全的。</li>
<li>  不可变对象同时被多个线程调用时，不存在线程安全问题。</li>
<li>  不可变集合不需要考虑变化，因此可以节省时间和空间。</li>
<li>  不可变对象因为固定不变，可以作为常量来安全使用。</li>
</ul>
<p><strong>JDK中不可变集合的缺点：</strong></p>
<p>当然，JDK 的 Collections 工具类也为我们提供了诸多 <code>unmodifiableXxx()</code> 方法用于把集合包装为不可变形式。但相比 Guava 中的不可变集合存在如下缺点：</p>
<ul>
<li>  <strong>笨重而且累赘</strong>：不能舒适地用在所有想做防御性拷贝的场景；</li>
<li>  <strong>不安全</strong>：JDK 中的不可变集合是在原有集合的基础上进行包装产生的。如果原有集合被改变了，那么不可变集合也会随着改变。所以在使用时要保证没人通过原集合的引用进行修改，返回的集合才是真正不可变的。</li>
<li>  <strong>低效</strong>：包装过的集合仍然保有可变集合的开销，比如并发修改的检查、散列表的额外空间，等等。</li>
</ul>
<p>如果你没有修改某个集合的需求，或者希望某个集合保持不变时，把它防御性地拷贝到不可变集合是个很好的实践。</p>
<blockquote>
<p>  <strong>Tip</strong></p>
<p>  <em>所有Guava不可变集合的实现都不接受null值。我们对Google内部的代码库做过详细研究，发现只有5%的情况需要在集合中允许null元素，剩下的95%场景都是遇到null值就快速失败。如果你需要在不可变集合中使用null，请使用JDK中的Collections.unmodifiableXXX方法。</em></p>
</blockquote>
<h3 id="创建一个不可变集合对象"><a href="#创建一个不可变集合对象" class="headerlink" title="创建一个不可变集合对象"></a>创建一个不可变集合对象</h3><p>不可变集合可以通过如下多种方式创建：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>copyOf 方法</td>
<td>根据已存在的集合创建不可变集合</td>
</tr>
<tr>
<td>of 方法</td>
<td>直接通过多个值来创建不可变集合</td>
</tr>
<tr>
<td>Builder 工具</td>
<td>通过链式编程来创建不可变集合（灵活度高）</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何创建不可变集合？</span></span><br><span class="line"><span class="comment"> *  1、copyOf 方法</span></span><br><span class="line"><span class="comment"> *  2、of 方法</span></span><br><span class="line"><span class="comment"> *  3、Builder 工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 方式一：copyOf()</span></span><br><span class="line">    ImmutableList&lt;Integer&gt; USERS = ImmutableList.copyOf(Arrays.asList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：of()</span></span><br><span class="line">    <span class="keyword">final</span> ImmutableSet&lt;String&gt; COLOR_NAMES = ImmutableSet.of(</span><br><span class="line">            <span class="string">&quot;red&quot;</span>,</span><br><span class="line">            <span class="string">&quot;green&quot;</span>,</span><br><span class="line">            <span class="string">&quot;purple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式三：Builder</span></span><br><span class="line">    ImmutableSet&lt;String&gt; NEW_COLOR_NAMES = ImmutableSet.&lt;String&gt;builder()</span><br><span class="line">            .addAll(COLOR_NAMES)</span><br><span class="line">            .add(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用不可变集合"><a href="#使用不可变集合" class="headerlink" title="使用不可变集合"></a>使用不可变集合</h3><p>Guava 很好的兼容了 Java 原生的集合类型，除了对集合的写操作，原先对 Java 中集合的操作都可以用在 Guava 中的不可变集合对象上。</p>
<p><img src="/2022/06/14/Guava/image-20220627185355351.png" alt="image-20220627185355351"></p>
<p>从图中可以看出所有写操作涉及的 API 都是不被支持的。</p>
<h4 id="asList-视图"><a href="#asList-视图" class="headerlink" title="asList 视图"></a>asList 视图</h4><p>所有的不可变集合都有一个 asList() 方法，用于提供 ImmutableList 视图，来帮助你用列表的形式方便地读取集合中的元素。</p>
<p>例如，你可以使用 <code>sortedSet.asList().get(k)</code> 从 ImmutableSortedSet 中读取第 k 个最小的元素。</p>
<h3 id="可变集合与不可变集合的对应关系"><a href="#可变集合与不可变集合的对应关系" class="headerlink" title="可变集合与不可变集合的对应关系"></a>可变集合与不可变集合的对应关系</h3><table>
<thead>
<tr>
<th>可变集合接口</th>
<th>属于JDK还是Guava？</th>
<th>不可变版本</th>
</tr>
</thead>
<tbody><tr>
<td>Collection</td>
<td>JDK</td>
<td>ImmutableCollection</td>
</tr>
<tr>
<td>List</td>
<td>JDK</td>
<td>ImmutableList</td>
</tr>
<tr>
<td>Set</td>
<td>JDK</td>
<td>ImmutableSet</td>
</tr>
<tr>
<td>SortedSet/NavigableSet</td>
<td>JDK</td>
<td>ImmutableSortedSet</td>
</tr>
<tr>
<td>Map</td>
<td>JDK</td>
<td>ImmutableMap</td>
</tr>
<tr>
<td>SortedMap</td>
<td>JDK</td>
<td>ImmutableSortedMap</td>
</tr>
<tr>
<td>Multiset</td>
<td>Guava</td>
<td>ImmutableMultiset</td>
</tr>
<tr>
<td>SortedMultiset</td>
<td>Guava</td>
<td>ImmutableSortedMultiset</td>
</tr>
<tr>
<td>Multimap</td>
<td>Guava</td>
<td>ImmutableMultimap</td>
</tr>
<tr>
<td>ListMultimap</td>
<td>Guava</td>
<td>ImmutableListMultimap</td>
</tr>
<tr>
<td>SetMultimap</td>
<td>Guava</td>
<td>ImmutableSetMultimap</td>
</tr>
<tr>
<td>BiMap</td>
<td>Guava</td>
<td>ImmutableBiMap</td>
</tr>
<tr>
<td>ClassToInstanceMap</td>
<td>Guava</td>
<td>ImmutableClassToInstanceMap</td>
</tr>
<tr>
<td>Table</td>
<td>Guava</td>
<td>ImmutableTable</td>
</tr>
</tbody></table>
<hr>
<h2 id="新的集合类型-New-Collection-Types"><a href="#新的集合类型-New-Collection-Types" class="headerlink" title="新的集合类型[New Collection Types]"></a>新的集合类型[New Collection Types]</h2><p>Guava 引入了很多 JDK 没有的，但在开发中很有用的新的集合类型。这些新集合类型的底层依然是 JDK 中的集合类型，并没有向 JDK 集合抽象中强加一些其它概念。</p>
<h3 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h3><p>Set 是一个无序的、其内元素不能重复的集合。</p>
<p>List 是一个有序的、其内元素可以重复的集合。</p>
<p>Multiset 集合了两者的特点。首先，其内的元素是无序的；其次，其内的元素是可以重复的。</p>
<h4 id="Multiset初体验"><a href="#Multiset初体验" class="headerlink" title="Multiset初体验"></a>Multiset初体验</h4><p>统计一个词在文档中出现了多少次，传统的做法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 统计一个词在文档中出现了多少次。</span></span><br><span class="line"><span class="comment">    *      1、传统做法、</span></span><br><span class="line"><span class="comment">    *      2、使用Multiset实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">statWordCount</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;A big black bug bit a big black bear and made the big black bear bleed blood&quot;</span>;</span><br><span class="line">       <span class="comment">// 将 text 按空格划分为多个单词</span></span><br><span class="line">       Iterable&lt;String&gt; words = Splitter.on(<span class="string">&quot; &quot;</span>).split(text);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 传统做法</span></span><br><span class="line">       Map&lt;String, Integer&gt; wordCountMap = oldStatWordCount(words);</span><br><span class="line">       System.out.println(wordCountMap);</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用Multiset实现</span></span><br><span class="line">       Multiset&lt;String&gt; wordCount = newStatWordCount(words);</span><br><span class="line">       System.out.println(wordCount);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">oldStatWordCount</span><span class="params">(Iterable&lt;String&gt; words)</span>&#123;</span><br><span class="line">       HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(word);</span><br><span class="line">           <span class="keyword">if</span> (count == <span class="literal">null</span>)&#123;</span><br><span class="line">               map.put(word, <span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(word, count+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">       <span class="comment">// &#123;the=1, A=1, big=3, a=1, bug=1, and=1, made=1, black=3, bear=2, bit=1, bleed=1, blood=1&#125;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Multiset&lt;String&gt; <span class="title function_">newStatWordCount</span><span class="params">(Iterable&lt;String&gt; words)</span> &#123;</span><br><span class="line">       HashMultiset&lt;String&gt; multiset = HashMultiset.create();</span><br><span class="line">       <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">           multiset.add(word);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> multiset;</span><br><span class="line">       <span class="comment">// [the, A, big x 3, a, bug, and, made, black x 3, bear x 2, bit, bleed, blood]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这种写法很笨拙，也很容易出错，并且不支持同时收集多种统计信息，如：总词数。</p>
<p>Guava 提供了一个新的集合类型 <strong>Multiset</strong>，它支持多次添加相同的元素。</p>
<p>维基百科从数学的角度这样定义 Multiset：</p>
<blockquote>
<p>  Multiset 是 Set 概念的延伸，其内的元素可以重复出现。与 Set 相同而与 Tuple(元组) 相反的是，Multiset 中元素的顺序是无关紧要的，<code>Multiset&#123;a,a,b&#125;</code> 和 <code>Multiset&#123;a,b,a&#125;</code> 是相等的。</p>
</blockquote>
<h4 id="Multiset的两种视角"><a href="#Multiset的两种视角" class="headerlink" title="Multiset的两种视角"></a>Multiset的两种视角</h4><p>可以从两个角度来理解 Multiset：</p>
<ol>
<li><p>**无序的 <code>ArrayList&lt;E&gt;</code>**。比如：</p>
<ul>
<li>它可以通过 add(E) 方法向集合中添加单个给定元素。</li>
<li>通过 iterator() 方法返回一个迭代器，包含 Multiset 中的全部元素（包含重复元素）。</li>
<li>通过 size() 方法返回所有元素的总个数（包括重复元素）</li>
<li>……</li>
</ul>
</li>
<li><p><strong><code>Map&lt;E, Integer&gt;</code>，键为元素，值为元素的个数。</strong>比如：</p>
<ul>
<li>它可以通过 count(Object) 方法返回给定元素的计数。</li>
<li>通过 entrySet() 方法返回 <code>Set&lt;Multiset.Entry&lt;E&gt;&gt;</code>，这和 Map 的 entrySet() 方法类似。</li>
<li>通过 elementSet() 方法返回所有不重复元素的 <code>Set&lt;E&gt;</code>，和 Map 的 keySet() 方法类似。</li>
<li>……</li>
</ul>
</li>
</ol>
<p>值得注意的是，除了极少数情况，Multiset 和 JDK 中原生的 Collection 接口的约定完全一致。具体来说，TreeMultiset 在判断元素是否相等时，与 TreeSet 一样用 compare() 方法，而不是 Object.equals() 方法。</p>
<p>另外特别注意，<code>Multiset.addAll(Collection)</code> 可以向一个 Multiset 中添加 Collection 中的所有元素并进行计数，这比用 for 循环向 Map 中添加元素和计数方便多了。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>count(E)</td>
<td>统计指定元素在Multiset中的数量</td>
</tr>
<tr>
<td>elementSet()</td>
<td>Multiset中不重复元素的集合，类型为<code>Set&lt;E&gt;</code></td>
</tr>
<tr>
<td>entrySet()</td>
<td></td>
</tr>
<tr>
<td>add(E, int)</td>
<td>增加指定元素在Multiset中的数量</td>
</tr>
<tr>
<td>remove(E, int)</td>
<td>减少指定元素在Multiset中的数量</td>
</tr>
<tr>
<td>setCount(E, int)</td>
<td>设置指定元素在Multiset中的数量，不可以为负数。</td>
</tr>
<tr>
<td>size()</td>
<td>返回集合元素总个数(包括重复的元素)</td>
</tr>
</tbody></table>
<h4 id="Multiset-不是-Map"><a href="#Multiset-不是-Map" class="headerlink" title="Multiset 不是 Map"></a>Multiset 不是 Map</h4><p>值得注意的是，<code>Multiset&lt;E&gt;</code> 不是 <code>Map&lt;E, Integer&gt;</code>。虽然 Map 可能是某些 Multiset 实现的一部分。</p>
<p>准确地来说，Multiset 是一种 Collection 类型，它实现了 Collection 接口的相关约定。</p>
<p>关于 Multiset 和 Map 的区别还包括：</p>
<ul>
<li>  Multiset 中元素的计数只能是正数（不能是负数或者0）。</li>
<li>  multiset.size() 返回集合的大小，等同于所有元素数量的总和。对于不重复元素的个数，应该使用 <code>elementSet.size()</code> 方法。</li>
<li>  multiset.iterator() 方法会迭代重复元素，因此迭代长度等于 multiset.size()。</li>
<li>  Multiset 支持直接增加、减少或设置元素的数量。setCount(elem, 0) 等同于移出所有的 elem。</li>
<li>  对 multiset 中没有的元素，multiset.count(elem) 始终返回0。而 Map 则返回 null。</li>
</ul>
<h4 id="Multiset-的各种实现"><a href="#Multiset-的各种实现" class="headerlink" title="Multiset 的各种实现"></a>Multiset 的各种实现</h4><p>Multiset 是一个接口，Guava 提供了多种 Multiset 的实现，大致对应 JDK 中 Map 的各种实现。</p>
<table>
<thead>
<tr>
<th>Map</th>
<th>对应的Multiset</th>
<th>是否支持Null元素</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>HashMultiset</td>
<td>是</td>
</tr>
<tr>
<td>TreeMap</td>
<td>TreeMultiset</td>
<td>是(如果comparator支持的话)</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>LinkedHashMultiset</td>
<td>是</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>ConcurrentHashMultiset</td>
<td>否</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMultiset</td>
<td>否</td>
</tr>
</tbody></table>
<h4 id="SortedMultiset"><a href="#SortedMultiset" class="headerlink" title="SortedMultiset"></a>SortedMultiset</h4><p>…</p>
<h3 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h3><p>一个有经验的 Java 程序员或多或少都在某个项目中编写过类似 <code>Map&lt;K, List&lt;V&gt;&gt;</code> 或 <code>Map&lt;K, Set&lt;V&gt;&gt;</code> 这种笨拙的结构。</p>
<p>而 Guava 的 Multimap 可以很容易地让一个键映射多个值。</p>
<p>从两个角度理解 Multimap 的设计理念：</p>
<ul>
<li><p>“键-单个值映射”的集合</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;1</span><br><span class="line">a-&gt;2</span><br><span class="line">a-&gt;4</span><br><span class="line">b-&gt;3</span><br><span class="line">c-&gt;5</span><br></pre></td></tr></table></figure></li>
<li><p>或者是 “键-值集合的映射”</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;[1,2,4]</span><br><span class="line">b-&gt;3</span><br><span class="line">c-&gt;5</span><br></pre></td></tr></table></figure></li>
</ul>
<p>一般来说，Multimap 接口应该以第一种方式来看待，但 <code>asMap()</code> 方法返回的视图为 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 格式，让我们可以从另一种角度来看待 Multimap。</p>
<p>重要的是，不会有任何键映射到空集合。一个键要么至少一个值，要么就根本不在 Multimap 中。</p>
<p>Multimap 是一个顶级接口，很少被直接使用，更多的时候我们会使用它的子接口 ListMultimap 或 SetMultimap，它们分别把键映射到 List 和 Set。</p>
<h4 id="修改-Multimap"><a href="#修改-Multimap" class="headerlink" title="修改 Multimap"></a>修改 Multimap</h4><p><code>Multimap.get(key)</code> 会以集合的形式返回键所对应的值的视图。即使没有任何的返回值，也会返回空集合。</p>
<ul>
<li>  ListMultimap.get(key) 返回 List 集合；</li>
<li>  SetMultimap.get(key) 返回 Set 集合。</li>
</ul>
<p>对值视图集合进行的修改最终都会反映到底层的 Multimap。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Person&gt; aliceChildren = childrenMultimap.get(alice);</span><br><span class="line">aliceChildren.clear();</span><br><span class="line">aliceChildren.add(bob);</span><br><span class="line">aliceChildren.add(carol);</span><br></pre></td></tr></table></figure>

<p>其它(更直接地)修改 Multimap 的方法还有：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>等价表达</th>
</tr>
</thead>
<tbody><tr>
<td><code>put(K, V)</code></td>
<td>添加单个值到键映射的集合</td>
<td>multimap.get(key).add(value)</td>
</tr>
<tr>
<td><code>putAll(K, Iterable&lt;V&gt;)</code></td>
<td>添加多个值到键映射的集合</td>
<td></td>
</tr>
<tr>
<td><code>remove(K, V)</code></td>
<td>移除键到值的映射，如果有这样的映射并移除成功，返回true。</td>
<td></td>
</tr>
<tr>
<td><code>removeAll(K)</code></td>
<td>清空键对应的所有值，返回的集合包含了所有之前映射到K的值，但删除之后修改这个集合就不会影响Multimap了。</td>
<td>multimap.get(key).clear()</td>
</tr>
<tr>
<td><code>replaceValues(K, Iterable&lt;V&gt;)</code></td>
<td>清除键对应的所有值，并重新把key关联到Iterable中的每个元素，返回的集合包含所有之前映射到K的值。</td>
<td>multimap.get(key).clear();<br>Iterables.addAll(multimap.get(key), values)</td>
</tr>
</tbody></table>
<p>​    </p>
<h4 id="Multimap的视图"><a href="#Multimap的视图" class="headerlink" title="Multimap的视图"></a>Multimap的视图</h4><p>Multimap 还支持若干强大的视图：</p>
<ul>
<li><p><strong>asMap()</strong> 为 <code>Multimap&lt;K, V&gt;</code> 提供 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 形式的视图。</p>
<ul>
<li>  返回的 Map 支持 remove 操作，并且会反映到底层的 Multimap，但不支持 put 和 putAll 操作。</li>
<li>  如果你想为 Multimap 中不存在的键返回 null，而不是一个空集合，你就可以使用 <code>asMap().get(key)</code>。</li>
<li>Java 类型系统不允许 ListMultimap 直接为 asMap().get(key) 返回 List。所以如果有需求，你需要手动把 asMap.get(key) 返回的结果转换为和是的集合类型。比如：<ul>
<li>  将 SetMultimap.asMap().get(key) 返回的结果转为 Set 类型；</li>
<li>  将 ListMultimap.asMap().get(key) 返回的结果转为 List 类型；</li>
<li>  也可以用 Multimaps 工具类中的静态方法 asMap() 帮你完成类型的转换。</li>
</ul>
</li>
</ul>
</li>
<li><p>**entries()**：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Map.Entry&lt;K, V&gt;&gt; entries();</span><br></pre></td></tr></table></figure>

<p>  用 <code>Collection&lt;Map.Entry&lt;K, V&gt;&gt;</code> 返回 Multimap 中所有 “键-单个值映射” (包括重复键)。</p>
</li>
<li><p>**keySet()**：用 Set 表示 Multimap 中所有不同的键</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>keys()</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Multiset&lt;K&gt; <span class="title function_">keys</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>  用 Multiset 表示 Multimap 中所有的键，每个键重复出现的次数等于它映射的值的个数。</li>
<li>  可以从这个 Multiset 中移除元素，但不能做添加操作。移除操作会反映到底层的 Multimap。</li>
</ul>
</li>
<li><p><strong>values()</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>  用一个“扁平”的 <code>Collection&lt;V&gt;</code> 包含 Multimap 中的所有值。这一点类似于 <code>Iterables.concat(multimap.asMap().values())</code>，但它直接返回了单个的 Collection，而不像 <code>multimap.asMap().values()</code> 那样是分开的 Collection。</li>
</ul>
</li>
</ul>
<h4 id="Multimap不是Map"><a href="#Multimap不是Map" class="headerlink" title="Multimap不是Map"></a>Multimap不是Map</h4><p><code>Multimap&lt;K, V&gt;</code> 不是 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code>，虽然某些 Multimap 的具体实现使用了 map。它们之间的显著区别有：</p>
<ul>
<li><code>Multimap.get(key)</code> 总是返回非 null，但可能是空的集合。<ul>
<li>  这并不意味着 Multimap 为相应的键花费内存创建了集合，而是……</li>
<li>  如果你更喜欢像 Map 那样，为 Multimap 中没有的键返回 null，请使用 asMap() 方法获取一个 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code>。或者使用静态方法 <code>Multimaps.asMap()</code> 为 ListMultimap 返回一个 <code>Map&lt;K, List&lt;V&gt;&gt;</code>。对于 SetMultimap 和 SortedSetMultimap，也有类似的静态方法存在。</li>
</ul>
</li>
<li>当且仅当有 value 映射到 key 时，Multimap.containsKey(key) 才会返回 true。<ul>
<li>  需要注意的是：如果 key 之间映射过一个或多个值，但它们都被移出后，Multimap.containsKey(key) 返回 false。</li>
</ul>
</li>
<li>Multimap.entries() 返回 Multimap 中所有的 “键-单个值映射”，包括重复键。<ul>
<li>  如果你想要得到所有的 “键-值集合映射”，请使用 asMap.entrySet()。</li>
</ul>
</li>
<li>Multimap.size() 返回所有 “键-单个值映射” 的个数，而非不同键的个数。<ul>
<li>  要想获得不同键的个数，请使用 Multimap.keySet().size()。</li>
</ul>
</li>
</ul>
<h4 id="Multimap的各种实现"><a href="#Multimap的各种实现" class="headerlink" title="Multimap的各种实现"></a>Multimap的各种实现</h4><p>Multimap 提供了多种形式的实现，在大多数要使用 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 的地方，你都可以使用它们。</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>键类型</th>
<th>值类型</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayListMultimap</td>
<td></td>
<td>ArrayList</td>
</tr>
<tr>
<td>LinkedListMultimap</td>
<td></td>
<td>LinkedList</td>
</tr>
<tr>
<td>HashMultimap</td>
<td></td>
<td>HashSet</td>
</tr>
<tr>
<td>LinkedHashMultimap</td>
<td></td>
<td>LinkedHashMap</td>
</tr>
<tr>
<td>TreeMultimap</td>
<td></td>
<td>TreeSet</td>
</tr>
<tr>
<td>ImmutableListMultimap</td>
<td></td>
<td>ImmutableList</td>
</tr>
<tr>
<td>ImmutableSetMultimap</td>
<td></td>
<td>ImmutableSet</td>
</tr>
</tbody></table>
<p>除了两个不可变形式的实现，其它所有实现都支持 null 键和 null 值。</p>
<h3 id="BiMap"><a href="#BiMap" class="headerlink" title="BiMap"></a>BiMap</h3><p>在 JDK 中，实现键值对的双向映射(即既可以通过key找到value，也可以通过value找到key)需要维护两个单独的 map，并保持它们之间的同步。</p>
<p>但这种方式很容易出错，特别是对于值已经在 map 中的情况，会变得非常混乱。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; kToV = Maps.newHashMap();</span><br><span class="line">    HashMap&lt;Integer, String&gt; vToK = Maps.newHashMap();</span><br><span class="line">    kToV.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">42</span>);</span><br><span class="line">    vToK.put(<span class="number">42</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果 &quot;Bob&quot; 和 42 已经在 map 中了，会发生什么？</span></span><br><span class="line">    <span class="comment">// 如果我们忘了同步两个map，则会有新的bug产生。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BiMap&lt;K,V&gt;</code> 是特殊的 Map：</p>
<ul>
<li>  可以用 <code>inverse()</code> 反转 <code>BiMap&lt;K, V&gt;</code> 的键值映射；</li>
<li>  可以保证值是唯一的，因此 <code>values()</code> 返回 Set 而不是普通的 Collection。</li>
</ul>
<p>在 BiMap 中，如果你想把键映射到已经存在的值，会抛出 IllegalArgumentException 异常。如果对特定值，你想要强制替换它的键，可以使用 <code>BiMap.forcePut(key, value)</code>。</p>
<h4 id="BiMap的各种实现类"><a href="#BiMap的各种实现类" class="headerlink" title="BiMap的各种实现类"></a>BiMap的各种实现类</h4><table>
<thead>
<tr>
<th>键-值 实现</th>
<th>值-键 实现</th>
<th>对应的BiMap实现</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>HashMap</td>
<td>HashBiMap</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMap</td>
<td>ImmutableBiMap</td>
</tr>
<tr>
<td>EnumMap</td>
<td>EnumMap</td>
<td>EnumBiMap</td>
</tr>
<tr>
<td>EnumMap</td>
<td>HashMap</td>
<td>EnumHashBiMap</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注</strong>：Map 类中还有一些诸如 synchronizedBiMap 的 BiMap 工具方法。</p>
</blockquote>
<h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><p>通常来说，当你想用多个键做索引时，你可能会使用类似 <code>Map&lt;FirstName, Map&lt;LastName， Person&gt;&gt;</code> 的结构来实现。这种方式很丑陋，使用上也不太友好。</p>
<p>为此，Guava 提供了新的集合类型 Table，它有两个键：“行”和“列”，通过这两个键唯一映射到一个值。</p>
<p>Table 提供了多种视图，以便你从各种角度去理解它。</p>
<ul>
<li>**rowMap()**：用 <code>Map&lt;R, Map&lt;C, V&gt;&gt;</code> 表现 <code>Table&lt;R, C, V&gt;</code>。<ul>
<li>同样的，<strong>rowKeySet()</strong> 返回“行”的集合 <code>Set&lt;R&gt;</code>。</li>
</ul>
</li>
<li>**row(r)**：返回给定“行”的所有列，返回值格式为 <code>Map&lt;C, V&gt;</code>。<ul>
<li>注意：对这个 map 进行的写操作也将反映到 Table 中。</li>
</ul>
</li>
<li>类似的“列”的访问方法：<strong>columnMap()<strong>、</strong>columnKeySet()<strong>、</strong>column(c)</strong><ul>
<li>基于“列”的访问会比基于“行”的访问效率略低。</li>
</ul>
</li>
<li>**cellSet()**：用元素类型为 <code>Table.Cell&lt;R, C, V&gt;</code> 的 Set 表现 <code>Table&lt;R, C, V&gt;</code>。Cell 类似于 Map.Entry，但它是用行和列两个键进行划分的。</li>
</ul>
<h4 id="Table的实现类"><a href="#Table的实现类" class="headerlink" title="Table的实现类"></a>Table的实现类</h4><ul>
<li><strong>HashBasedTable</strong>：底层使用 <code>HashMap&lt;R, HashMap&lt;C, V&gt;&gt;</code> 实现。</li>
<li><strong>TreeBasedTable</strong>：底层使用 <code>TreeMap&lt;R, TreeMap&lt;C, V&gt;&gt;</code> 实现。</li>
<li><strong>ImmutableTable</strong>：底层使用 <code>ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt;</code> 实现。<ul>
<li>注：ImmutableTable 对稀疏或密集的数据集都有优化。</li>
</ul>
</li>
<li><strong>ArrayTable</strong>：要求在构造时就指定行和列的大小，本质上由一个二维数组实现，以提升访问速度和密集 Table 的内存利用率。</li>
</ul>
<h3 id="ClassToInstanceMap"><a href="#ClassToInstanceMap" class="headerlink" title="ClassToInstanceMap"></a>ClassToInstanceMap</h3><p>ClassToInstanceMap 是一种特殊的 Map：它的键是类型，而值是符合所指类型的对象实例。</p>
<p>为了扩展 Map 接口，ClassToInstance 额外声明了两个方法：</p>
<ul>
<li><code>getInstance(Class&lt;T&gt;)</code></li>
<li><code>T putInstance(Class&lt;T&gt;, T)</code></li>
</ul>
<p>从而避免强制类型转换，同时保证了类型安全。</p>
<p>ClassToInstanceMap 有唯一的泛型参数，通常称为 B，代表 Map 支持的所有类型的上界。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassToInstanceMap&lt;Number&gt; numberDefaults = MutableClassToInstanceMap.create();</span><br><span class="line">numberDefaults.putInstance(Integer.class, Integer.valueOf(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>从技术上讲，<code>ClassToInstanceMap&lt;B&gt;</code> 实现了 <code>Map&lt;Class&lt;? extends B&gt;, B&gt;</code>。或者换句话说就是：一个映射 B 的子类类型到对应实例的 Map。B 始终是 Map 所支持类型的上限，默认 B 就是 Object。</p>
<h4 id="ClassToInstanceMap的实现类"><a href="#ClassToInstanceMap的实现类" class="headerlink" title="ClassToInstanceMap的实现类"></a>ClassToInstanceMap的实现类</h4><ul>
<li>MutableClassToInstanceMap</li>
<li>ImmutableClassToInstanceMap</li>
</ul>
<h3 id="RangeSet"><a href="#RangeSet" class="headerlink" title="RangeSet"></a>RangeSet</h3><p>RangeSet 描述了一组不相连的、非空的区间。</p>
<p>当把一个区间添加到可变的 RangeSet 时，所有相连的区间会被合并，空区间会被忽略。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create();</span><br><span class="line">rangeSet.add(Range.closed(<span class="number">1</span>, <span class="number">10</span>)); <span class="comment">// [1.10]，前闭后闭</span></span><br><span class="line">rangeSet.add(Range.closedOpen(<span class="number">11</span>, <span class="number">15</span>)); <span class="comment">// [11,15)，前开后闭</span></span><br><span class="line"><span class="comment">// 不相连区间 ==&gt; &#123; [1.10], [11,15) &#125;</span></span><br><span class="line">rangeSet.add(Range.closedOpen(<span class="number">15</span>, <span class="number">20</span>)); <span class="comment">// [15,20)</span></span><br><span class="line"><span class="comment">// 相连区间 ==&gt; &#123; [1.10], [11,20) &#125;</span></span><br><span class="line">rangeSet.add(Range.openClosed(<span class="number">0</span> ,<span class="number">0</span>)); <span class="comment">// 空区间</span></span><br><span class="line"><span class="comment">// &#123; [1.10], [11,20) &#125;</span></span><br><span class="line"><span class="comment">// 删除区间</span></span><br><span class="line">rangeSet.remove(Range.open(<span class="number">5</span>, <span class="number">10</span>)); <span class="comment">// (5, 10)</span></span><br><span class="line"><span class="comment">// &#123; [1, 5], [10, 10], [11,20) &#125;</span></span><br><span class="line">System.out.println(rangeSet); <span class="comment">// [[1..5], [10..10], [11..20)]</span></span><br></pre></td></tr></table></figure>

<p>请注意：要合并 <code>Range.closed(1, 10)</code> 和 <code>Range.closedOpen(11, 15)</code> 这样的区间，你需要首先用 <strong>Range.canonical(DiscreteDomain)</strong> 对区间进行预处理。例如：<code>DiscreteDomain.integers()</code>。</p>
<blockquote>
<p>  <strong>注意</strong></p>
<p>  RangeSet 不支持 GWT，也不支持 JDK5 和更早版本。因为，RangeSet 需要充分利用 JDK6 中的 NavigableMap 的特性。</p>
</blockquote>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </p>
<h3 id="RangeMap"><a href="#RangeMap" class="headerlink" title="RangeMap"></a>RangeMap</h3><h2 id="强大的集合工具类"><a href="#强大的集合工具类" class="headerlink" title="强大的集合工具类"></a>强大的集合工具类</h2><p>JDK 在 <code>java.util.Collections</code> 包中提供了很多对 Collection 进行操作的静态方法。Guava 沿着这些路线提供了更多的工具方法，这也是 Guava 最流行和最成熟的部分之一。</p>
<p>常见的工具类与集合接口的对应关系归纳如下：</p>
<table>
<thead>
<tr>
<th>集合接口</th>
<th>属于JDK还是Guava</th>
<th>对应的Guava工具类</th>
</tr>
</thead>
<tbody><tr>
<td>Collection</td>
<td>JDK</td>
<td>Collections2(不要和<code>java.util.Collections</code>混淆)</td>
</tr>
<tr>
<td>List</td>
<td>JDK</td>
<td>Lists</td>
</tr>
<tr>
<td>Set</td>
<td>JDK</td>
<td>Sets</td>
</tr>
<tr>
<td>SortedSet</td>
<td>JDK</td>
<td>Sets</td>
</tr>
<tr>
<td>Map</td>
<td>JDK</td>
<td>Maps</td>
</tr>
<tr>
<td>SortedMap</td>
<td>JDK</td>
<td>Maps</td>
</tr>
<tr>
<td>Queue</td>
<td>JDK</td>
<td>Queues</td>
</tr>
<tr>
<td>Multiset</td>
<td>Guava</td>
<td>Multisets</td>
</tr>
<tr>
<td>Multimap</td>
<td>Guava</td>
<td>Multimaps</td>
</tr>
<tr>
<td>BiMap</td>
<td>Guava</td>
<td>Maps</td>
</tr>
<tr>
<td>Table</td>
<td>Guava</td>
<td>Tables</td>
</tr>
</tbody></table>
<h3 id="使用Lists工具类操作List集合"><a href="#使用Lists工具类操作List集合" class="headerlink" title="使用Lists工具类操作List集合"></a>使用Lists工具类操作List集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lists 工具类的常用方法</span></span><br><span class="line"><span class="comment"> *      1、对集合进行 反转 / 拆分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLists</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拆分：将list集合拆分为每3个为一组</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; listList = Lists.partition(list, <span class="number">3</span>);</span><br><span class="line">    System.out.println(JSON.toJSONString(listList));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">            [1,2,3],</span></span><br><span class="line"><span class="comment">            [4,5,6],</span></span><br><span class="line"><span class="comment">            [7]</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转</span></span><br><span class="line">    List&lt;Integer&gt; reverseList = Lists.reverse(list);</span><br><span class="line">    System.out.println(reverseList); <span class="comment">// [7, 6, 5, 4, 3, 2, 1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用Sets工具类操作Set集合"><a href="#使用Sets工具类操作Set集合" class="headerlink" title="使用Sets工具类操作Set集合"></a>使用Sets工具类操作Set集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets 工具类的常用方法</span></span><br><span class="line"><span class="comment"> *      1、取两个集合的 并集 / 交集 / 差集（标准差集 &amp; 对称差集）</span></span><br><span class="line"><span class="comment"> *      2、将一个集合拆解为其所有可能的子集</span></span><br><span class="line"><span class="comment"> *      3、求两个集合的笛卡尔积</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSets</span><span class="params">()</span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set1 = Sets.newHashSet(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    HashSet&lt;Integer&gt; set2 = Sets.newHashSet(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并集</span></span><br><span class="line">    Sets.SetView&lt;Integer&gt; union = Sets.union(set1, set2);</span><br><span class="line">    System.out.println(union); <span class="comment">// [1, 2, 3, 4, 5, 8, 6, 7]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    Sets.SetView&lt;Integer&gt; intersection = Sets.intersection(set1, set2);</span><br><span class="line">    System.out.println(intersection); <span class="comment">// [4, 5]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准差集</span></span><br><span class="line">    Sets.SetView&lt;Integer&gt; difference1 = Sets.difference(set1, set2);</span><br><span class="line">    Sets.SetView&lt;Integer&gt; difference2 = Sets.difference(set2, set1);</span><br><span class="line">    System.out.println(difference1); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    System.out.println(difference2); <span class="comment">// [8, 6, 7]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称差集</span></span><br><span class="line">    Sets.SetView&lt;Integer&gt; difference = Sets.symmetricDifference(set1, set2);</span><br><span class="line">    System.out.println(difference); <span class="comment">// [1, 2, 3, 8, 6, 7]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个集合拆解为其所有可能的子集</span></span><br><span class="line">    HashSet&lt;String&gt; set = Sets.newHashSet(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    Set&lt;Set&lt;String&gt;&gt; setSet = Sets.powerSet(set);</span><br><span class="line">    System.out.println(JSON.toJSONString(setSet));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">            [],</span></span><br><span class="line"><span class="comment">            [&quot;a&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;b&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;a&quot;,&quot;b&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;c&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;a&quot;,&quot;c&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;b&quot;,&quot;c&quot;],</span></span><br><span class="line"><span class="comment">            [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个集合的笛卡尔积</span></span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; listSet = Sets.cartesianProduct(</span><br><span class="line">            Sets.newHashSet(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            Sets.newHashSet(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    );</span><br><span class="line">    System.out.println(JSON.toJSONString(listSet));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">            [1,4],</span></span><br><span class="line"><span class="comment">            [1,3],</span></span><br><span class="line"><span class="comment">            [2,4],</span></span><br><span class="line"><span class="comment">            [2,3]</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><p>在 JDK7 之前，构造新的集合时要反复地声明泛型类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line"><span class="comment">// JDK7之前，在等号左边和右边都需要显式地声明泛型类型，否则编译时就会报错</span></span><br></pre></td></tr></table></figure>

<p>尽管从 JDK7 开始，钻石操作符 <code>&lt;&gt;</code> 已经做出了一些优化，我们可以只在 “=” 左边声明泛型的类型，右边的泛型类型通过自动推断得出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>但是如果你正在操作一个使用 JDK6 甚至更早的项目，显然反复地声明泛型类型是非常麻烦的。为此，Guava 提供了能够推断泛型的静态工厂方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;User&gt; list = Lists.newArrayList();</span><br><span class="line">LinkedHashMap&lt;String, User&gt; map = Maps.newLinkedHashMap();</span><br></pre></td></tr></table></figure>

<p>但是 Guava 的静态工厂方法远不止这么简答。使用工厂方法，我们可以方便地在初始化集合时指定初始元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; copySet = Sets.newHashSet(elements);</span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此外，通过工厂方法的名称，可以提高集合初始化大小时的可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Type&gt; exactly100 = Lists.newArrayListWithCapacity(<span class="number">100</span>);</span><br><span class="line">ArrayList&lt;Type&gt; approx100 = Lists.newArrayListWithExpectedSize(<span class="number">100</span>);</span><br><span class="line">HashSet&lt;Type&gt; approx100Set = Sets.newHashSetWithExpectedSize(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：对于 Guava 中引入的新集合类型，在创建其实例时并没有暴露原始的构造器，也没有在 <code>Collections2</code> 工具类中提供初始化方法，而是直接在集合类中提供了静态工厂方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMultiset&lt;String&gt; multiset = HashMultiset.create();</span><br></pre></td></tr></table></figure>





<h3 id="Iterables"><a href="#Iterables" class="headerlink" title="Iterables"></a>Iterables</h3><p>在条件允许的情况下，Guava 提供的工具方法更偏向于接受 Iterable 类型而不是 Collection 类型。</p>
<p>在 Google 公司，对于不存放在主存中的数据集，比如从数据库或其他数据中心收集到的结果集，因为其实际上还没有攫取全部数据，这类结果集都不能支持类似 size() 的操作，所以通常都不会用 Collection 类型来表示。</p>
<p>因此，很多你期望的支持所有集合的操作都保存在 Iterables 类中。</p>
<p>截至 Guava1.2 版本，Iterables 使用 FluentIterable 类进行了补充，它包装了一个 Iterable 实例，并对许多操作提供了 “fluent”(链式调用)语法。</p>
<p>下面列出了一些最常用的工具方法，但更多 Iterables 的函数式方法将在对应的“函数式编程”章节讨论。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>frequency(Iterable, Object)</td>
<td>返回Object对象在Iterable中出现的次数</td>
<td></td>
</tr>
<tr>
<td>partition(Iterable, int)</td>
<td>把iterable按指定大小分割，得到的子集都不能进行修改操作</td>
<td></td>
</tr>
<tr>
<td>getFirst(Iterable, T default)</td>
<td>返回iterable中的第一个元素，若iterable为空则返回默认值。</td>
<td></td>
</tr>
<tr>
<td>getLast(Iterable)</td>
<td>返回iterable中的最后一个元素，若iterable为空则抛出NoSuchElementException。</td>
<td></td>
</tr>
<tr>
<td>elementsEqual(Iterable, Iterable)</td>
<td>如果两个iterable中的所有元素相等且顺序一致，返回true</td>
<td></td>
</tr>
<tr>
<td>unmodifableIterable(Iterable)</td>
<td>返回iterable的不可变视图。</td>
<td></td>
</tr>
<tr>
<td>limit(Iterable, int)</td>
<td>限制iterable的元素个数，限制给定值</td>
<td></td>
</tr>
<tr>
<td>getOnlyElement(Iterable)</td>
<td>获取iterable中唯一的元素。如果iterable为空或有多个元素，则快速失败。</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h1 id="字符串工具"><a href="#字符串工具" class="headerlink" title="字符串工具"></a>字符串工具</h1><h2 id="连接器-Joiner"><a href="#连接器-Joiner" class="headerlink" title="连接器[Joiner]"></a>连接器[Joiner]</h2><p>Joiner 是一个字符串处理工具，它的作用就是：用一个分隔符把多个字符串连接起来，并且如果字符串序列中含有 <code>null</code> 也能够很好的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个连接器，这个连接器使用&quot;$&quot;作为连接符，并且会自动跳过null值 </span></span><br><span class="line"><span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;$&quot;</span>).skipNulls();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> joiner.join(<span class="string">&quot;Harry&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Ron&quot;</span>, <span class="string">&quot;Hermione&quot;</span>);</span><br><span class="line">System.out.println(s); <span class="comment">//Harry$Ron$Hermione</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>useForNull(String)</code> 方法可以用某个给定的字符串来替换 null，而不像 <code>skipNulls()</code> 方法那样直接忽略 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;$&quot;</span>).useForNull(<span class="string">&quot;Empty&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> joiner.join(<span class="string">&quot;Harry&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Ron&quot;</span>, <span class="string">&quot;Hermione&quot;</span>);</span><br><span class="line">System.out.println(s); Harry$Empty$Ron$Hermione</span><br></pre></td></tr></table></figure>

<p>joiner 也可以用来连接 Object 类型，这种情况下，它会将 Object 的 toString() 值连接起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">13</span>),</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">24</span>)</span><br><span class="line">);</span><br><span class="line"><span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;^_^&quot;</span>).skipNulls();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> joiner.join(userList);</span><br><span class="line">System.out.println(s); <span class="comment">//User(name=张三, age=13)^_^User(name=李四, age=24)^_^User(name=王五, age=35)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>Tip</strong></p>
<p>  joiner 实例一旦创建是不可变的。每次执行定义 Joiner 的语句得到的都是一个新的 joiner 实例，这使得 joiner 实例都是安全的，所以你可以将其定义为 static final 常量。</p>
</blockquote>
<h3 id="静态方法-连接器工厂"><a href="#静态方法-连接器工厂" class="headerlink" title="静态方法(连接器工厂)"></a>静态方法(连接器工厂)</h3><p>Joiner 类只有两个静态方法，分别是：</p>
<ul>
<li><code>Joiner on(String separator)</code></li>
<li><code>Joiner on(char separator)</code></li>
</ul>
<p>这两个方法都是用于创建一个连接器实例 joiner，并在创建时指定要以哪种分隔符对字符串进行拼接。只不过一个使用 String 类型的分隔符，另一个使用 char 类型的分隔符。</p>
<p>我们可以将 Splitter 类理解为一个连接器工厂，它的作用就是创建 splitter 连接器实例。</p>
<h3 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h3><p><img src="/2022/06/14/Guava/image-20220620220652695.png" alt="image-20220620220652695"></p>
<p>与 JDK8 中的流式操作类似，joiner 中的方法也可以分为 **中间操作方法 **和 <strong>终止操作方法</strong> 两大类。</p>
<ul>
<li>中间操作方法主要用于设置 joiner 连接器的属性，主要包括 skipNulls、useForNull、withKeyValueSeparator 等等。中间操作仅仅只是用于设置对字符串的处理规则，并没有真正的执行处理字符串的过程。</li>
<li>而终止操作则是把待处理的数据交给 joiner 实例，让其真正地去处理数据。常见的终止操作方法有 join 和 appendTo 两个。<ul>
<li><code>String join(...)</code>：join 方法的返回值是一个字符串，表示它会将 joiner 处理后的数据写到 String 类型的字符串中。</li>
<li><code>&lt;A extends Appendable&gt; A appendTo()</code>：appendTo 方法的返回值是 Appendable 类型的对象，它比较灵活多变，常见的我们可以把处理后的数据写到 StringBuffer 或 StringBuilder 中，或者是写到 Writer 中(这些都是 Appendable  接口的子类对象)，进而写出到磁盘上。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>join()</strong></p>
</blockquote>
<p>join 方法有三种变式：</p>
<ul>
<li><code>String join(Iterable&lt;?&gt; parts)</code></li>
<li><code>String join(Iterator&lt;?&gt; parts)</code></li>
<li><code>String join(Object first, Object second, Object... rest)</code></li>
</ul>
<p>前两种方法接收一个集合类型，返回值是 String，就是把集合类型中的所有元素拼接成一个字符串。如果集合的泛型是 Object 类型，返回的结果就是集合中每个元素的 toString() 方法返回值拼接的结果。</p>
<blockquote>
<p><strong>appendTo()</strong></p>
</blockquote>
<p>appendTo() 方法的作用将 joiner 处理后的数据写到一个 Appendable 类型的对象中。</p>
<p>该方法的第一个参数要求是 Appendable 类型的对象(StringBuffer 和 StringBuilder 都是 Appendable 接口的子类)；其余参数可以是 Object 类型，此时会将其 toString() 方法的返回值当做要追加的数据；也可以是 Iterable 或 Iterator 类型；或者是多个 Object 对象。</p>
<p>该方法设计的逻辑就是：对于 joiner 处理过的字符串，我们可能会在某个地方用到它，所以我们需要先找个地方把这个处理结果暂存起来。这个地方可以是 StringBuffer、也可以是本地磁盘。     </p>
<p><img src="/2022/06/14/Guava/image-20220620223152644.png" alt="image-20220620223152644"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/20 22:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; stringList = Lists.newArrayList(</span><br><span class="line">            <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Golang&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; stringListWithNullValue = Lists.newArrayList(</span><br><span class="line">            <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Golang&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res1</span> <span class="operator">=</span> joiner.join(stringList);</span><br><span class="line">        System.out.println(res1); <span class="comment">// Java#Python#C#Golang</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果集合中含有null值，直接使用join()拼接集合中的元素，会抛出 NullPointerException</span></span><br><span class="line">        <span class="comment">//String res2 = joiner.join(stringListWithNullValue); // NullPointerException</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了解决这个问题，可以为连接器实例 joiner 设置自动跳过 null 值的功能</span></span><br><span class="line">        <span class="type">Joiner</span> <span class="variable">joiner2</span> <span class="operator">=</span> joiner.skipNulls();</span><br><span class="line">        <span class="type">String</span> <span class="variable">res2</span> <span class="operator">=</span> joiner2.join(stringListWithNullValue);</span><br><span class="line">        System.out.println(res2); <span class="comment">// Java#Python#Golang</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于null值，如果我们不想直接跳过，而是使用一个Default值替换Null，可以使用useForNull()方法</span></span><br><span class="line">        <span class="type">Joiner</span> <span class="variable">joiner3</span> <span class="operator">=</span> joiner.useForNull(<span class="string">&quot;Empty&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res3</span> <span class="operator">=</span> joiner3.join(stringListWithNullValue);</span><br><span class="line">        System.out.println(res3); <span class="comment">// Java#Python#Empty#Golang</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAppendToStringBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> joiner.skipNulls().appendTo(stringBuffer, stringListWithNullValue);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 它的一个执行流程是，先用joiner对象处理集合中的数据。</span></span><br><span class="line"><span class="comment">         * 最后把处理后的结果数据写到目的地(这里是写到sb中)</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        System.out.println(res.toString()); <span class="comment">// Java$Python$Golang</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并且 res 和 stringBuffer 是同一个 StringBuffer 实例</span></span><br><span class="line">        System.out.println(stringBuffer == res); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAppendToWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// Writer 也实现了 Appendable 接口</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 将 joiner 处理后得到的字符串写出到 Writer 中，最终写入磁盘上</span></span><br><span class="line">        Joiner.on(<span class="string">&quot;$&quot;</span>).skipNulls().appendTo(fileWriter, stringListWithNullValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="内部类MapJoiner"><a href="#内部类MapJoiner" class="headerlink" title="内部类MapJoiner"></a>内部类MapJoiner</h3><p>MapJoiner 是 Joiner 的内部类，它主要用来处理 Map 集合中的字符串数据，它可以先将 Map 中每个 Entry 的 key 和 value 用一个连接符连接起来，再用另一个连接符连接每一个 Entry。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/20 22:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = ImmutableMap.of(</span><br><span class="line">            <span class="string">&quot;23&quot;</span>, <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">            <span class="string">&quot;24&quot;</span>, <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">            <span class="string">&quot;25&quot;</span>, <span class="string">&quot;王五&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMapJoiner</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Joiner.<span class="type">MapJoiner</span> <span class="variable">mapJoiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot; $ &quot;</span>)</span><br><span class="line">                .withKeyValueSeparator(<span class="string">&#x27;=&#x27;</span>)  <span class="comment">// key和value的分隔符</span></span><br><span class="line">                .useForNull(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// join 和 appendTo 是终止操作方法。join是把结果写到字符串中；appendTo则比较灵活多变</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> mapJoiner.join(map);</span><br><span class="line">        System.out.println(res); <span class="comment">// 23=张三 $ 24=李四 $ 25=王五</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> mapJoiner.appendTo(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(), map);</span><br><span class="line">        System.out.println(buffer.toString()); <span class="comment">// 23=张三 $ 24=李四 $ 25=王五</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="拆分器-Splitter"><a href="#拆分器-Splitter" class="headerlink" title="拆分器[Splitter]"></a>拆分器[Splitter]</h2><p>与 Joiner 相反，Splitter 的作用是把一个字符串根据给定的分隔符进行分割。</p>
<p>JDK 内置的字符串拆分工具有一些奇怪的特性。比如，<code>String.split()</code> 方法会悄悄丢掉尾部的分隔符。</p>
<blockquote>
<p>  问题：</p>
<ul>
<li><code>&quot;,a,b,&quot;.split(&quot;,&quot;)</code> 会返回什么？<ol>
<li> <code>&quot;&quot;,&quot;a&quot;,&quot;b&quot;,&quot;&quot;</code></li>
<li> <code>null,&quot;a&quot;,&quot;b&quot;,null</code></li>
<li> <code>&quot;a&quot;,null,&quot;b&quot;</code></li>
<li> <code>&quot;a&quot;,&quot;b&quot;</code></li>
<li> 以上都不对</li>
</ol>
</li>
</ul>
</blockquote>
<p>正确答案是5。真正的结果是：<code>&quot;&quot;,&quot;a&quot;,&quot;b&quot;</code>，只有尾部的空字符串被忽略了，首部的空字符串没有被忽略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = <span class="string">&quot;,a,b,&quot;</span>.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">System.out.println(strings.length); <span class="comment">// 3</span></span><br><span class="line">System.out.println(Arrays.toString(strings)); <span class="comment">// [, a, b]</span></span><br></pre></td></tr></table></figure>

<p>而 Guava 中的 <strong>Splitter</strong> 使用了令人放心的、直白流畅的 API 对这些混乱的特性做了优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterable&lt;String&gt; strings = Splitter.on(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    .trimResults()</span><br><span class="line">    .omitEmptyStrings() <span class="comment">//省略空字符串</span></span><br><span class="line">    .split(<span class="string">&quot;foo,bar,,    qux&quot;</span>);</span><br><span class="line">System.out.println(Iterables.toString(strings)); <span class="comment">// [foo, bar, qux]</span></span><br></pre></td></tr></table></figure>

<p>上述代码返回 <code>Iterable&lt;String&gt;</code> 类型的对象，其中包含 “foo”、“bar”和“qux”。</p>
<p>Splitter 可以被设置为按照任何模式、字符、字符串或者字符匹配器拆分。</p>
<h3 id="静态方法-拆分器工厂"><a href="#静态方法-拆分器工厂" class="headerlink" title="静态方法(拆分器工厂)"></a>静态方法(拆分器工厂)</h3><p>与 Joiner 类似，Splitter 中的静态方法也被用于创建 splitter 实例，并在创建时指定字符串拆分的规则。</p>
<p>我们可以将 Splitter 类理解为一个拆分器工厂，它的作用就是创建 splitter 拆分器。</p>
<p><img src="/2022/06/14/Guava/image-20220621123921407.png" alt="image-20220621123921407"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Splitter.on(char)</td>
<td>按单个字符拆分</td>
<td>Splitter.on(‘;’)</td>
</tr>
<tr>
<td>Splitter.on(CharMatcher)</td>
<td>按字符匹配器拆分</td>
<td>Splitter.on(CharMatcher.BREAKING_WHITESPACE)</td>
</tr>
<tr>
<td>Splitter.on(String)</td>
<td>按字符串拆分</td>
<td>Splitter.on(“,”)</td>
</tr>
<tr>
<td>Splitter.on(Pattern)<br>Splitter.onPattern(String)</td>
<td>按正则表达式拆分</td>
<td>Splitter.onPattern(“\r?\n”)</td>
</tr>
<tr>
<td>Splitter.fixedLength(int)</td>
<td>按固定长度拆分(最后一段可能比给定长度短)</td>
<td>Splitter.fixedLength(3)</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_Splitter_onPattern</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;好$好$学$习$天$天$向$上&quot;</span>;</span><br><span class="line">    <span class="comment">// 正则表达式：通过&quot;$&quot;进行分割</span></span><br><span class="line">    List&lt;String&gt; dstList1 = Splitter.onPattern(<span class="string">&quot;\\$&quot;</span>).splitToList(srcStr);</span><br><span class="line">    List&lt;String&gt; dstList2 = Splitter.on(Pattern.compile(<span class="string">&quot;\\$&quot;</span>)).splitToList(srcStr);</span><br><span class="line">    System.out.println(dstList1.toString()); <span class="comment">// [好, 好, 学, 习, 天, 天, 向, 上]</span></span><br><span class="line">    System.out.println(dstList2.toString()); <span class="comment">// [好, 好, 学, 习, 天, 天, 向, 上]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以客户端发送报文给服务器为例。规定每4个长度为一组。</span></span><br><span class="line"><span class="comment"> * 现客户端发送了一串报文为：010010XR8764YTE3</span></span><br><span class="line"><span class="comment"> * 服务器端接收到报文后需要解析这串报文。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_Splitter_fixedLength</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;010010XR8764YTE3&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建一个以字符长度为拆分依据的 splitter 实例</span></span><br><span class="line">    <span class="type">Splitter</span> <span class="variable">splitter</span> <span class="operator">=</span> Splitter.fixedLength(<span class="number">4</span>);</span><br><span class="line">    List&lt;String&gt; dstList = splitter.splitToList(srcStr);</span><br><span class="line">    System.out.println(dstList.toString()); <span class="comment">// [0100, 10XR, 8764, YTE3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="普通方法-1"><a href="#普通方法-1" class="headerlink" title="普通方法"></a>普通方法</h3><p>与 joiner 类似，splitter 实例可以调用的方法也可分为两类：<strong>拆分器修饰方法</strong> 和 <strong>拆分器执行方法</strong>。</p>
<ul>
<li>拆分器修饰方法主要用来定义 splitter 实例的执行规则，常见的有：trimResults、omitEmptyStrings、limit、withKeyValueSeparator 等等，这些方法仅仅是对 splitter 的修饰，并没有真正执行数据的处理流程。</li>
<li>拆分器执行方法则是通过连接到真正的数据源，使用 joiner 对数据源数据进行处理。常见的有 split() 和 splitToList()。</li>
</ul>
<p><img src="/2022/06/14/Guava/image-20220621125041695.png" alt="image-20220621125041695"></p>
<h4 id="拆分器修饰方法"><a href="#拆分器修饰方法" class="headerlink" title="拆分器修饰方法"></a>拆分器修饰方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>omitEmptyStrings()</td>
<td>省略结果字符串中的空白元素</td>
<td>a,,c<code>-&gt;</code>a,c</td>
</tr>
<tr>
<td>trimResults()</td>
<td>移除结果字符串中的头部空白和尾部空白</td>
<td></td>
</tr>
<tr>
<td>trimResults(charMatcher)</td>
<td>给定匹配器，移除结果字符串的头部匹配字符和尾部匹配字符</td>
<td></td>
</tr>
<tr>
<td>limit(int)</td>
<td>限制拆分出的元素数量</td>
<td></td>
</tr>
</tbody></table>
<h4 id="拆分器执行方法"><a href="#拆分器执行方法" class="headerlink" title="拆分器执行方法"></a>拆分器执行方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>split(CharSequence sequence)</td>
<td>使用splitter实例对sequence数据进行拆分</td>
</tr>
<tr>
<td>splitToList(CharSequence sequence)</td>
<td>使用splitter实例对sequence数据进行拆分，并将拆分结果写到List中</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;阿福,成龙   ,,,小玉,    老爹&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建 splitter 实例</span></span><br><span class="line">    <span class="type">Splitter</span> <span class="variable">splitter</span> <span class="operator">=</span> Splitter.on(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、修饰 splitter 实例</span></span><br><span class="line">    <span class="comment">// 2.1 omitEmptyStrings</span></span><br><span class="line">    <span class="type">Splitter</span> <span class="variable">splitter1</span> <span class="operator">=</span> splitter.omitEmptyStrings(); <span class="comment">// 忽略空字符</span></span><br><span class="line">    <span class="comment">/*  &quot;阿福,成龙   ,,,小玉,    老爹&quot; --&gt; [阿福, 成龙   , 小玉,     老爹]  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 trimResults</span></span><br><span class="line">    <span class="type">Splitter</span> <span class="variable">splitter2</span> <span class="operator">=</span> splitter.trimResults(); <span class="comment">// 忽略单个元素前面和后面的空白</span></span><br><span class="line">    <span class="comment">/*  &quot;阿福,成龙   ,,,小玉,    老爹&quot; --&gt; [阿福,成龙,,,小玉,老爹]  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、执行拆分</span></span><br><span class="line">    <span class="comment">// 将处理的结果写到Iterable类型的对象中</span></span><br><span class="line">    Iterable&lt;String&gt; iterable = splitter1.split(srcStr);</span><br><span class="line">    System.out.println(Iterables.toString(iterable));</span><br><span class="line">    <span class="comment">// 将处理的结果写到List类型的对象中</span></span><br><span class="line">    List&lt;String&gt; list = splitter2.splitToList(srcStr);</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_splitter_limit</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;好$好$学$习$天$天$向$上&quot;</span>;</span><br><span class="line">    List&lt;String&gt; dstList = Splitter.on(<span class="string">&#x27;$&#x27;</span>).limit(<span class="number">4</span>).splitToList(srcStr);</span><br><span class="line">    System.out.println(dstList.size()); <span class="comment">// 4。拆分的结果只有4部分</span></span><br><span class="line">    System.out.println(dstList.toString()); <span class="comment">// [好, 好, 学, 习$天$天$向$上]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="内部类MapSplitter"><a href="#内部类MapSplitter" class="headerlink" title="内部类MapSplitter"></a>内部类MapSplitter</h3><p>MapSplitter 是 Splitter 的内部类，它是专门用于处理 KV 形式的字符串，并且会把处理后的字符串写到一个 Map 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_Splitter_withKeyValueSeparator</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcStr</span> <span class="operator">=</span> <span class="string">&quot;科比=24;乔丹=24;库里=30&quot;</span>;</span><br><span class="line">    Map&lt;String, String&gt; map = Splitter.on(<span class="string">&#x27;;&#x27;</span>).withKeyValueSeparator(<span class="string">&#x27;=&#x27;</span>).split(srcStr);</span><br><span class="line">    System.out.println(map.toString()); <span class="comment">// &#123;科比=24, 乔丹=24, 库里=30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>Tip</strong></p>
<p>  Splitter 实例总是不可变的。每次执行 Splitter 的定义语句返回的都是一个新的 splitter 实例。这保证了 splitter 实例都是线程安全的，你可以将其定义为 static final 常量。</p>
</blockquote>
<h2 id="字符串匹配器-CharMatcher"><a href="#字符串匹配器-CharMatcher" class="headerlink" title="字符串匹配器(CharMatcher)"></a>字符串匹配器(CharMatcher)</h2><p>在 Guava 早期的版本中，为了处理字符串，在 StringUtil 类中添加了很多处理字符串的方法。如 allSacii、collapse、collapseControlChars、collapseWhitespace、indexOfChars、lastIndexNotOf、numSharedChars、removeChars、removeCrLf、replaceChars、retainAllChars、strip、stripAndCollapse、stripNonDigits 等等。</p>
<p>但是归根结底，所有的字符串处理方法都只为了解决两个问题：</p>
<ul>
<li>如何匹配字符串？</li>
<li>如何处理匹配成功的字符串？</li>
</ul>
<p>为了解决这个难题，Guava 提供了 CharMatcher 工具类。</p>
<p>你可以简单地认为一个 CharMatcher 实例代表着某一<strong>类</strong>字符，如数字类、空白字符类、大写字符类、小写字符类等等。实际上，CharMatcher 实例就是对字符串中的每个字符进行布尔判断，判断其是否属于某一类。</p>
<p>CharMatcher 底层通过实现 <code>Predicate&lt;Character&gt;</code> 接口来实现断言功能（判断某个字符是否属于某一类）。</p>
<blockquote>
<p>  <code>public abstract class CharMatcher implements Predicate&lt;Character&gt; &#123;</code></p>
</blockquote>
<p>使用 CharMatcher 的好处在于它还提供了一系列方法，让你可以对字符串作特定的操作(如何处理匹配成功的字符串)，包括了：</p>
<ul>
<li>  修剪(trim)</li>
<li>  折叠(collapse)</li>
<li>  移除(remove)</li>
<li>  保留(retain)</li>
<li>  ……</li>
</ul>
<p>使用 CharMatcher 主要分为两步：</p>
<ul>
<li>  step1：匹配字符串；</li>
<li>  step2：对匹配成功的字符串执行特定的操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只保留数字字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_digit_retain</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;control 1 control 2 control 3&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> CharMatcher</span><br><span class="line">            .digit() <span class="comment">//匹配数字</span></span><br><span class="line">            .retainFrom(str); <span class="comment">//执行“保留”操作</span></span><br><span class="line">    System.out.println(resStr); <span class="comment">//123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去掉两端的空格，并把中间的连续空格替换成字符 &#x27;*&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWHITESPACE</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;  好好学习，    天天向上！  &quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> CharMatcher</span><br><span class="line">            .whitespace() <span class="comment">//匹配空格</span></span><br><span class="line">            .trimAndCollapseFrom(str, <span class="string">&#x27;*&#x27;</span>); <span class="comment">//匹配到3组空格后：1.移除头部和尾部的2组空格；2.压缩中间一组空格，并使用*代替空格</span></span><br><span class="line">    System.out.println(resStr); <span class="comment">//好好学习，*天天向上！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJAVA_DIGIT</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;不3不4；3妻4妾；7上8下&quot;</span>;</span><br><span class="line">    <span class="comment">// 用 &#x27;*&#x27; 替换所有数字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> CharMatcher</span><br><span class="line">            .javaDigit() <span class="comment">//匹配数字</span></span><br><span class="line">            .replaceFrom(str, <span class="string">&#x27;*&#x27;</span>); <span class="comment">// 执行“替换”操作</span></span><br><span class="line">    System.out.println(resStr); <span class="comment">//不*不*；*妻*妾；*上*下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 只保留数字和小写字母</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,I am 23 years!&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resStr</span> <span class="operator">=</span> CharMatcher.javaDigit() <span class="comment">//匹配数字</span></span><br><span class="line">            .or(CharMatcher.javaLowerCase()) <span class="comment">//匹配大写字母</span></span><br><span class="line">            .retainFrom(str); <span class="comment">//执行“保留”操作</span></span><br><span class="line">    System.out.println(resStr); <span class="comment">//elloam23years</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取字符串匹配器"><a href="#获取字符串匹配器" class="headerlink" title="获取字符串匹配器"></a>获取字符串匹配器</h3><p>如下图所示，CharMatcher 提供了很多方法可以满足日常使用中的大多数字符串匹配的需求。</p>
<p><img src="/2022/06/14/Guava/image-20220618182414129.png" alt="image-20220618182414129"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>any()</td>
<td>匹配全部字符</td>
<td></td>
</tr>
<tr>
<td>none()</td>
<td>所有字符都不匹配</td>
<td></td>
</tr>
<tr>
<td>anyof()</td>
<td>？</td>
<td></td>
</tr>
<tr>
<td>ascii()</td>
<td>判断字符是否为ASCII</td>
<td></td>
</tr>
<tr>
<td>breakingWhitespace()</td>
<td>匹配字符串中的空格。</td>
<td></td>
</tr>
<tr>
<td>digit()</td>
<td>根据Unicode确定字符是否为数字。</td>
<td></td>
</tr>
<tr>
<td>inRange(char, char)</td>
<td>给定字符范围匹配。</td>
<td></td>
</tr>
<tr>
<td>invisible()</td>
<td>确定字符是否不可见(根据字符的Unicode类别确定)</td>
<td></td>
</tr>
<tr>
<td>is(char match)</td>
<td>匹配单个字符</td>
<td></td>
</tr>
<tr>
<td>isNot(char match)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>javaDigit()</td>
<td>根据Java的定义确定字符是否为数字。</td>
<td></td>
</tr>
<tr>
<td>javaLetter()</td>
<td>根据Java的定义确定字符是否为字母。</td>
<td></td>
</tr>
<tr>
<td>javaLetterOrDigit()</td>
<td>根据Java的定义确定字符是字母或数字。</td>
<td></td>
</tr>
<tr>
<td>javaLowerCase</td>
<td>根据Java的定义确定字符是否为小写字母。</td>
<td></td>
</tr>
<tr>
<td>javaUpperCase</td>
<td>根据Java的定义确定字符是否为大写字母。</td>
<td></td>
</tr>
<tr>
<td>noneOf()</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>singleWidth()</td>
<td>判断字符是否为单字节宽度</td>
<td>汉字总是大于一个字节，可以根据这个特性区分出英文和中文</td>
</tr>
<tr>
<td>whitespace()</td>
<td>根据最新的Unicode标准确定字符是否为空格，</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>CharMatcher breakingWhitespace()</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_breakingWhitespace</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CharMatcher.breakingWhitespace().removeFrom(<span class="string">&quot;啊，   我爱你  中国&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> CharMatcher.breakingWhitespace().replaceFrom(<span class="string">&quot;啊，   我爱你  中国&quot;</span>, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">    System.out.println(s); <span class="comment">// 啊，我爱你中国</span></span><br><span class="line">    System.out.println(s1); <span class="comment">// 啊，啊，___我爱你__中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>is(char match)/isNot(char match)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CharMatcher.is(<span class="string">&#x27;a&#x27;</span>).removeFrom(<span class="string">&quot;abc_abc_abc&quot;</span>);</span><br><span class="line">System.out.println(s); <span class="comment">//bc_bc_bc</span></span><br></pre></td></tr></table></figure>

<p><strong>inRange(char, char)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CharMatcher.inRange(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>).removeFrom(<span class="string">&quot;ABC_abc_123&quot;</span>);</span><br><span class="line">System.out.println(s); <span class="comment">//ABC__123</span></span><br></pre></td></tr></table></figure>



<h3 id="使用字符串匹配器"><a href="#使用字符串匹配器" class="headerlink" title="使用字符串匹配器"></a>使用字符串匹配器</h3><p>CharMatcher 提供了多种方法操作匹配到的字符。其中最常见的如下：</p>
<p><img src="/2022/06/14/Guava/image-20220618201827157.png" alt="image-20220618201827157"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String retainFrom(CharSequence sequence)</td>
<td>在字符序列中保留匹配到的字符，移出其它字符。</td>
</tr>
<tr>
<td>String removeFrom(CharSequence sequence)</td>
<td>从字符序列中移除所有匹配到的字符</td>
</tr>
<tr>
<td>String replaceFrom(CharSequence sequence, CharSequence replacement)</td>
<td>用特定的字符序列代替匹配到的字符</td>
</tr>
<tr>
<td>String trimFrom(CharSequence sequence)</td>
<td>移除字符序列的头部匹配字符和尾部匹配字符</td>
</tr>
<tr>
<td>String collapseFrom(CharSequence sequence, char replacement)</td>
<td>把匹配到的每组连续字符首先压缩为单个字符，再替换为指定字符。</td>
</tr>
<tr>
<td>boolean matchesAllOf(CharSequence sequence)</td>
<td>判断是否字符序列中的所有字符都匹配成功</td>
</tr>
<tr>
<td>boolean matches(char c)</td>
<td>判断某个字符是否匹配成功</td>
</tr>
<tr>
<td>int countIn(CharSequence sequence)</td>
<td>统计sequence中有多少个符合条件的字符</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>matches(char c)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_matches</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 判断字符&#x27;5&#x27;是否是Java中的数字类型</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> CharMatcher.javaDigit().matches(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">    System.out.println(b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断字符&#x27;a&#x27;是否是Java中的数字类型</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> CharMatcher.javaDigit().matches(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    System.out.println(b1); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>int countIn(CharSequence sequence)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_countIn</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 统计 content 中有多少个 &#x27;a&#x27; 字符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;A big black bear sat on a big black bug&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> CharMatcher.is(<span class="string">&#x27;a&#x27;</span>).countIn(content);</span><br><span class="line">    System.out.println(count); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>String collapseFrom(CharSequence sequence, char replacement)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_collapseFrom</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1、首先通过 breakingWhitespace 匹配到所有的空格</span></span><br><span class="line"><span class="comment">    * 2、压缩，如果存在多个空格，就压缩为一个空格</span></span><br><span class="line"><span class="comment">    * 3、替换空格为&#x27;!&#x27;</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CharMatcher.breakingWhitespace().collapseFrom(<span class="string">&quot;啊   我爱你   中国&quot;</span>, <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    System.out.println(s); <span class="comment">// 啊!我爱你!中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="字符集-Charsets"><a href="#字符集-Charsets" class="headerlink" title="字符集(Charsets)"></a>字符集(Charsets)</h2><p>Charsets 针对所有 Java 平台都会使用的6种字符集提供了常量引用。并建议我们在项目中使用这些常量引用，而不是通过字面量名称获取字符集实例。</p>
<ul>
<li><p>不要这样做字符集处理：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用字符串“UTF-8”指定字符串编码格式</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="string">&quot;Hello world&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>试试这样写：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="string">&quot;Hello world&quot;</span>.getBytes(Charsets.UTF_8);</span><br></pre></td></tr></table></figure>
<ul>
<li>避免因手动输出失误，导致 UnsupportedEncodingException 异常</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/14/Guava/image-20220618203756169.png" alt="image-20220618203756169"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Charset</span> <span class="variable">charset</span> <span class="operator">=</span> Charsets.UTF_8;</span><br><span class="line">    <span class="type">Charset</span> <span class="variable">charset1</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(charset.equals(charset1)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Charsets.UTF_8 源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">UTF_8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="大小写格式-CaseFormat"><a href="#大小写格式-CaseFormat" class="headerlink" title="大小写格式(CaseFormat)"></a>大小写格式(CaseFormat)</h2><p>CaseFormat 被用来进行字符串在各种书写格式之间进行转换。比如：大小写、驼峰等等。</p>
<p>CaseFormat 支持的格式如下：</p>
<p><img src="/2022/06/14/Guava/image-20220618204633138.png" alt="image-20220618204633138"></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>LOWER_CAMEL</td>
<td>helloWorld</td>
</tr>
<tr>
<td>LOWER_HYPHEN</td>
<td>hello-world</td>
</tr>
<tr>
<td>LOWER_UNDERSCORE</td>
<td>hello_world</td>
</tr>
<tr>
<td>UPPER_CAMEL</td>
<td>HelloWorld</td>
</tr>
<tr>
<td>UPPER_UNDERSCORE</td>
<td>HELLO_WORLD</td>
</tr>
</tbody></table>
<p>CaseFormat 的用法非常直接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 LOWER_CAMEL 格式的 helloWorld 转为 UPPER_UNDERSCORE 格式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, <span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">System.out.println(s); <span class="comment">//HELLO_WORLD</span></span><br></pre></td></tr></table></figure>







<h2 id="Strings工具类"><a href="#Strings工具类" class="headerlink" title="Strings工具类"></a>Strings工具类</h2><p>我们首先来看一下 Strings 工具类提供的一些静态方法。</p>
<p><img src="/2022/06/14/Guava/image-20220621181533957.png" alt="image-20220621181533957"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String emptyToNull(String string)</td>
<td>将空字符串转换为NULL</td>
</tr>
<tr>
<td>String nullToEmpty(String string)</td>
<td>将NULL转换为空字符串</td>
</tr>
<tr>
<td>String commonPrefix(CharSequence a, CharSequence b)</td>
<td>返回两个字符串的公共前缀</td>
</tr>
<tr>
<td>String commonSuffix(CharSequence a, CharSequence b)</td>
<td>返回两个字符串的公共后缀</td>
</tr>
<tr>
<td>String repeat(String string, int count)</td>
<td>返回由<code>输入字符串*特定数量</code>的连接组成的字符串</td>
</tr>
<tr>
<td>boolean isNullOrEmpty(String string)</td>
<td></td>
</tr>
<tr>
<td>String padStart(String string, int minLength, char padChar)</td>
<td>判断字符串是否满足给定的最小长度，若不<br>满足则使用指定字符填充到最小要求长度。</td>
</tr>
<tr>
<td>String padEnd(String string, int minLength, char padChar)</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>emptyToNull</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Strings;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/21 18:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_emptyToNull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1、emptyToNull</span></span><br><span class="line">        <span class="comment">// 如果一个字符串是空串，就可以调用 emptyToNull 方法把它转换成一个 NULL 值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Strings.emptyToNull(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(s == <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：&quot;空格&quot; 不是空字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Strings.emptyToNull(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(s1 == <span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、nullToEmpty</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> Strings.nullToEmpty(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===&quot;</span> + s2 + <span class="string">&quot;===&quot;</span>); <span class="comment">// ======</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：如果传入的参数不是NULL，则将字符串原样返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> Strings.nullToEmpty(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(s3); <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、commonPrefix：返回两个字符串的公共前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> Strings.commonPrefix(<span class="string">&quot;张三风&quot;</span>, <span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        System.out.println(s4); <span class="comment">// 张三</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：如果两个字符串没有公共的前缀，则返回空字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> Strings.commonPrefix(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(s5.equals(<span class="string">&quot;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、commonPrefix：返回两个字符串的公共后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> Strings.commonSuffix(<span class="string">&quot;龙傲天&quot;</span>, <span class="string">&quot;帝释天&quot;</span>);</span><br><span class="line">        System.out.println(s6); <span class="comment">// 天</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、repeat</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> Strings.repeat(<span class="string">&quot;嗨 &quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(s7); <span class="comment">// 嗨 嗨 嗨</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、isNullOrEmpty</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Strings.isNullOrEmpty(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> Strings.isNullOrEmpty(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(b1 + <span class="string">&quot;;&quot;</span> + b2); <span class="comment">// true;true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9、padStart/padEnd：判断字符串是否满足给定的最小长度，若不满足则填充到最小要求长度</span></span><br><span class="line">        <span class="comment">// 在原字符串的头部 padStart 填充</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> Strings.padStart(<span class="string">&quot;hello&quot;</span>, <span class="number">9</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        System.out.println(s9); <span class="comment">// xxxxhello</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在原字符串的尾部填充</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s10</span> <span class="operator">=</span> Strings.padEnd(<span class="string">&quot;hello&quot;</span>, <span class="number">9</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        System.out.println(s10); <span class="comment">// xxxxhello</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果字符串长度大于要求的最小长度，则无需填充</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> Strings.padStart(<span class="string">&quot;hello&quot;</span>, <span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        System.out.println(s8); <span class="comment">// helloxxxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="Guava的函数式编程-Functional"><a href="#Guava的函数式编程-Functional" class="headerlink" title="Guava的函数式编程[Functional]"></a>Guava的函数式编程[Functional]</h1><p>Guava 的函数式编程与 JDK8 的函数式编程非常类似，但是通过引入 Guava 可以在更早的 JDK 版本中使用函数式编程。</p>
<h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p>一个 <code>&lt;X&gt; input</code>，一个 <code>boolean output</code></p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>一个 <code>&lt;X&gt; input</code>，一个 <code>&lt;Y&gt; output</code></p>
<h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h2><p>没有 input，有一个 <code>&lt;Y&gt; output</code></p>
<h2 id="Functional"><a href="#Functional" class="headerlink" title="Functional"></a>Functional</h2><h1 id="Guava之I-O"><a href="#Guava之I-O" class="headerlink" title="Guava之I/O"></a>Guava之I/O</h1><p>同类产品：Apache commons-io</p>
<h2 id="为字节流-字符流提供的工具类"><a href="#为字节流-字符流提供的工具类" class="headerlink" title="为字节流/字符流提供的工具类"></a>为字节流/字符流提供的工具类</h2><ul>
<li>ByteStreams：提供对 InputStream/OutputStream 的操作。</li>
<li>CharStreams：提供对 Reader/Writer 的操作。</li>
</ul>
<p>在已创建流的基础上，可以使用 ByteStreams 和 CharStreams 对已创建的流进行操作。</p>
<p>注意：在使用完这两个工具类之后，一定要记得手动关闭已创建的流，因为流对象并不是这两个工具类创建的，它们只是对流对象进行了各项操作，所以它们并不能自动关闭流。</p>
<h2 id="源（Source）与汇（Sink）：对I-O进一步的抽象"><a href="#源（Source）与汇（Sink）：对I-O进一步的抽象" class="headerlink" title="源（Source）与汇（Sink）：对I/O进一步的抽象"></a>源（Source）与汇（Sink）：对I/O进一步的抽象</h2><p>源（Source）与汇（Sink）是 Guava 对 IO 的进一步抽象。</p>
<blockquote>
<p>I/O 指的是：InputStream、OutputStream、Reader、Writer 四大基类及其各种子实现类</p>
</blockquote>
<ul>
<li><strong>源（Source）：可读的数据流</strong></li>
<li><strong>汇（Sink）：可写的数据流</strong></li>
</ul>
<p>创建流对象的源头可能是不同的，比如：</p>
<ul>
<li>数据源是一个网络资源(URL)</li>
<li>或者数据源是一个文件</li>
</ul>
<p>但是通过这些不同的数据源创建出来的流对象本质上是一致的。所以 Guava 在此基础上提出了<strong>源（Source）</strong>和<strong>汇（Sink）</strong>的抽象。</p>
<ul>
<li>源是可读的，</li>
<li>汇是可写的，</li>
</ul>
<p>对于不同的数据类型，源又分为：</p>
<ul>
<li>ByteSource</li>
<li>CharSource</li>
</ul>
<p>汇被分为：</p>
<ul>
<li>ByteSink</li>
<li>CharSink</li>
</ul>
<p>通过这两个概念，我们在使用时可以屏蔽掉流是如何创建的。通过统一的一组 API 就可以操作由不同的源创建出来的流。并且由于它（Source 和 Sink）还是流的创建者，所以在使用完毕后还会负责将流关闭。</p>
<blockquote>
<p>比如，之前在使用流时我们会创建 FileInputStream 表示源来自于文件，HttpInputStream 表示数据来源于 HTTP 消息，PipeInputStream 表示数据来源于管道。但是我们又没办法不使用具体的实现类，因为基类 InputStream 中只提供了很少的可供使用的公共方法。</p>
</blockquote>
<h2 id="实战案例：文件操作"><a href="#实战案例：文件操作" class="headerlink" title="实战案例：文件操作"></a>实战案例：文件操作</h2><blockquote>
<p>利用 Guava 提供的相关工具类，实现对文件的常见操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableList;</span><br><span class="line"><span class="keyword">import</span> com.google.common.io.CharSink;</span><br><span class="line"><span class="keyword">import</span> com.google.common.io.CharSource;</span><br><span class="line"><span class="keyword">import</span> com.google.common.io.Files;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/26 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用源（Source）与汇（Sink）对文件进行操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建对应的 Source 和 Sink</span></span><br><span class="line">        <span class="type">CharSource</span> <span class="variable">charSource</span> <span class="operator">=</span> Files.asCharSource(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;data.txt&quot;</span>), Charsets.UTF_8);</span><br><span class="line">        <span class="type">CharSink</span> <span class="variable">charSink</span> <span class="operator">=</span> Files.asCharSink(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;data_backup.txt&quot;</span>), Charsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、文件拷贝：将源数据写入汇中</span></span><br><span class="line">        charSource.copyTo(charSink);</span><br><span class="line">        ImmutableList&lt;String&gt; strings = charSource.readLines();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>charSource 对象中的常用方法</p>
<p><img src="/2022/06/14/Guava/image-20220626213840626.png" alt="image-20220626213840626"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将文件中的全部数据读到 String 类型的字符串中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件中的第一行数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readFirstLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行读取文件中的数据，并将读到的数据保存到不可变集合 ImmutableList 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ImmutableList&lt;String&gt; <span class="title function_">readLines</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐行读取文件中的数据，并对每一行数据都使用行处理器 LineProcessor 进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readLines</span><span class="params">(LineProcessor&lt;T&gt; processor)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行形成一个Stream流对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Stream&lt;String&gt; <span class="title function_">lines</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>charSink 对象中的常用方法</p>
<p><img src="/2022/06/14/Guava/image-20220626215615258.png" alt="image-20220626215615258"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 charSequence 中的数据写入“汇”（charSink对象）中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(CharSequence charSequence)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Readable 对象中的数据写入“汇”（charSink对象）中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeFrom</span><span class="params">(Readable readable)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行写入。数据来源于已划分好元素的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLines</span><span class="params">(Iterable&lt;? extends CharSequence&gt; lines)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行写入。对每行元素还可以通过 lineSeparator 进一步划分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLines</span><span class="params">(Iterable&lt;? extends CharSequence&gt; lines, String lineSeparator)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按行写入。数据来源于 Stream 流对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLines</span><span class="params">(Stream&lt;? extends CharSequence&gt; lines)</span></span><br></pre></td></tr></table></figure>







<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>拷贝文件</p>
<p><img src="/2022/06/14/Guava/image-20220621210614019.png" alt="image-20220621210614019"></p>
<p>移动文件</p>
<p><img src="/2022/06/14/Guava/image-20220621212601535.png" alt="image-20220621212601535"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建流与汇对象</p>
<p>创建临时文件</p>
<p>创建文件的父级目录</p>
<p>判断文件</p>
<p>CharSource</p>
<p>CharSink</p>
<p>CharStreams</p>
<p>ByteSource</p>
<p>ByteSink</p>
<p>ByteStreams</p>
<p>Closer</p>
<p>BaseEncoding</p>
<hr>
<h1 id="汪文君Collections"><a href="#汪文君Collections" class="headerlink" title="汪文君Collections"></a><strong>汪文君Collections</strong></h1><h2 id="FluentIterable"><a href="#FluentIterable" class="headerlink" title="FluentIterable"></a><strong>FluentIterable</strong></h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h3><p><strong>FluentIterable 是一个工具类，提供了如下静态方法：</strong></p>
<p><strong><img src="/2022/06/14/Guava/image-20220620213131901.png" alt="image-20220620213131901"></strong></p>
<ul>
<li><p><strong>from()：从数组类型 <code>E[]</code> 或 Iterable 类型的容器中取出数据放入 FluentIterable 集合中。</strong></p>
<ul>
<li><strong><code>FluentIterable&lt;E&gt; from(E[] elements)</code></strong></li>
<li><strong><code>FluentIterable&lt;E&gt; from(FluentIterable&lt;E&gt; iterable)</code></strong></li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> FluentIterable <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; nameList = Lists.newArrayList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    FluentIterable&lt;String&gt; fluentIterable = FluentIterable.from(nameList);</span><br><span class="line">    <span class="keyword">for</span> (String s : fluentIterable) &#123;</span><br><span class="line">        System.out.print(s); <span class="comment">// 张三 李四 王五</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fluentIterable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>concat()</code> 将数据拼接起来</strong></p>
</li>
<li><p><strong><code>of()</code> 0 个元素</strong></p>
</li>
<li><p><strong><code>of(E element, E... elements)</code> 1到多个元素。可变长度的 elements 可以为 0 个，但 element 必须有一个。</strong></p>
</li>
</ul>
<h3 id="普通方法-2"><a href="#普通方法-2" class="headerlink" title="普通方法"></a><strong>普通方法</strong></h3><p><strong>通过构造一个 FluentIterable 实例，我们看到它可以调用如下普通方法。</strong></p>
<p><strong><img src="/2022/06/14/Guava/image-20220620214807393.png" alt="image-20220620214807393"></strong></p>
<blockquote>
<p><strong><code>transformAndConcat(Function&lt;? super E, ? extends Iterable&lt;? extends T&gt;&gt; function)</code></strong></p>
</blockquote>
<p><strong>转换和连接</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/03/Activiti7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/03/Activiti7/" class="post-title-link" itemprop="url">Activiti7</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-03 11:51:15" itemprop="dateCreated datePublished" datetime="2022-06-03T11:51:15+08:00">2022-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-05 18:31:25" itemprop="dateModified" datetime="2022-06-05T18:31:25+08:00">2022-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E4%BD%9C%E6%B5%81/" itemprop="url" rel="index"><span itemprop="name">工作流</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一章-工作流概述"><a href="#第一章-工作流概述" class="headerlink" title="第一章 工作流概述"></a>第一章 工作流概述</h1><h2 id="1、什么是工作流"><a href="#1、什么是工作流" class="headerlink" title="1、什么是工作流"></a>1、什么是工作流</h2><p>…</p>
<h2 id="2、工作流应用场景"><a href="#2、工作流应用场景" class="headerlink" title="2、工作流应用场景"></a>2、工作流应用场景</h2><ul>
<li>  业务类：合同审批流程、订单处理流程、出入库审批流程等。</li>
<li>  行政类：请假流程、出差流程、办公用品申请流程等。</li>
<li>  财务类：报销流程、支付流程等。</li>
<li>  客户服务类：售后跟踪、客户投诉等。</li>
</ul>
<h2 id="3、BPMN2-0规范"><a href="#3、BPMN2-0规范" class="headerlink" title="3、BPMN2.0规范"></a>3、BPMN2.0规范</h2><h3 id="3-1-BPMN2-0是什么"><a href="#3-1-BPMN2-0是什么" class="headerlink" title="3.1 BPMN2.0是什么"></a>3.1 BPMN2.0是什么</h3><p>BPMN，Business Process Modeling Notation，业务流程模型注解。</p>
<h3 id="3-2-BPMN2-0基本流程符号"><a href="#3-2-BPMN2-0基本流程符号" class="headerlink" title="3.2 BPMN2.0基本流程符号"></a>3.2 BPMN2.0基本流程符号</h3><h4 id="事件Event"><a href="#事件Event" class="headerlink" title="事件Event"></a>事件Event</h4><p><img src="/2022/06/03/Activiti7/image-20220605171023417.png" alt="image-20220605171023417"></p>
<h4 id="活动Activity"><a href="#活动Activity" class="headerlink" title="活动Activity"></a>活动Activity</h4><p>活动是工作或任务的一个通用术语。</p>
<p>一个活动可以是一个任务，还可以是一个当前流程的子处理流程；其次，你还可以为活动指定不同的类型。</p>
<p>常见的活动如下：</p>
<p><img src="/2022/06/03/Activiti7/image-20220605171205918.png" alt="image-20220605171205918"></p>
<h4 id="网关Gateway"><a href="#网关Gateway" class="headerlink" title="网关Gateway"></a>网关Gateway</h4><p>网关用来处理决策：</p>
<p><img src="/2022/06/03/Activiti7/image-20220605171309046.png" alt="image-20220605171309046"></p>
<p><strong>排他网关（X）</strong></p>
<ul>
<li>  只有一条路径会被选择。流程执行到该网关时，按照输出流的顺序逐个计算，当条件的计算结果为true时，继续执行当前网关的输出流。</li>
<li>  如果多条线路的计算结果都是true，则会执行第一个为true的线路。如果所有网关的计算没有true，则抛出异常。</li>
<li>  排他网关需要和条件顺序流结合使用。使用default属性指定默认的顺序流，当所有的条件都不满足时会执行默认顺序流。</li>
</ul>
<p><strong>并行网关（+）</strong></p>
<ul>
<li>所有路径会被同时选择。<ul>
<li>  分支：并行执行所有输出顺序流，为每一条顺序流创建一个并行执行线路。</li>
<li>  汇聚：所有从并行网关拆分并执行完的线路均在此等候，直到所有的线路都执行完成才继续向后执行。</li>
</ul>
</li>
</ul>
<p><strong>包含网关（o）</strong></p>
<ul>
<li>可以同时执行多条线路，也可以在网关上设置条件。<ul>
<li>  分支：计算每条线路上的表达式，当表达式的结果为true时，创建一个并行线路并继续执行。</li>
<li>  汇聚：所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。</li>
</ul>
</li>
</ul>
<p><strong>事件网关（o+）</strong></p>
<ul>
<li>  专门为中间捕获事件设置的，允许设置多个输出流指向多个不同的中间捕获事件。当流程执行到事件网关后，流程处于等待状态，需要等待抛出事件才能将等待状态转换为活动状态。</li>
</ul>
<h4 id="定时器事件"><a href="#定时器事件" class="headerlink" title="定时器事件"></a>定时器事件</h4><p><img src="/2022/06/03/Activiti7/image-20220605172512814.png" alt="image-20220605172512814"></p>
<ul>
<li>开始定时器事件<ul>
<li>  可以设置时间，定时开始启动流程实例。</li>
</ul>
</li>
<li>中间定时器事件<ul>
<li>  设定延迟时间，当完成任务A后，到达延时时间后，流程才会走向任务B。</li>
</ul>
</li>
<li>边界定时器事件<ul>
<li>  用于向某节点上添加边界定时事件。在设定时间内没有完成，流程实例则自动走向下一节点。</li>
</ul>
</li>
</ul>
<h1 id="第二章-Activiti"><a href="#第二章-Activiti" class="headerlink" title="第二章 Activiti"></a>第二章 Activiti</h1><h2 id="1、什么是Activiti"><a href="#1、什么是Activiti" class="headerlink" title="1、什么是Activiti"></a>1、什么是Activiti</h2><p>官网：<a target="_blank" rel="noopener" href="https://www.activiti.org/">https://www.activiti.org/</a></p>
<h2 id="2、Activiti开发流程"><a href="#2、Activiti开发流程" class="headerlink" title="2、Activiti开发流程"></a>2、Activiti开发流程</h2><ol>
<li><p>绘制流程定义模型</p>
<p> 遵循BPMN的流程规范，使用BPMN的流程定义工具，通过<strong>流程符号</strong>把整个业务流程定义出来。可以将流程定义文件的字节流保存到模型数据表中（Model）。</p>
</li>
<li><p>部署流程定义：</p>
<p> 就是将第一步画好的流程定义模型进行部署。</p>
<p> 加载画好的流程定义文件，将它转换成流程定义数据（ProcessDefinition），保存到流程定义数据表中。</p>
</li>
<li><p>启动流程（提交流程申请）</p>
<p> 部署好了流程定义之后就可以使用这个流程了。</p>
<p> 启动流程实例就是提交申请，比如申请请假就是提交了一个流程实例、申请报销也是提交了一个流程实例</p>
<p> 生成流程实例数据（ProcessInstance），生成第一节点任务数据（Task）</p>
</li>
<li><p>处理人审批流程节点任务</p>
<p> 完成任务审批。生成审批结果，生成下一节点任务数据。</p>
</li>
</ol>
<p><img src="/2022/06/03/Activiti7/Activiti%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.svg" alt="Activiti开发流程"></p>
<h2 id="3、开发环境"><a href="#3、开发环境" class="headerlink" title="3、开发环境"></a>3、开发环境</h2><h3 id="3-1-框架版本号"><a href="#3-1-框架版本号" class="headerlink" title="3.1 框架版本号"></a>3.1 框架版本号</h3><table>
<thead>
<tr>
<th align="center">开发环境</th>
<th align="center">版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SpringBoot</td>
<td align="center">2.5.0</td>
</tr>
<tr>
<td align="center">Activiti</td>
<td align="center">7.1.0.M6</td>
</tr>
<tr>
<td align="center">JDK</td>
<td align="center">1.8</td>
</tr>
<tr>
<td align="center">MySQL</td>
<td align="center">8.0</td>
</tr>
<tr>
<td align="center">Maven</td>
<td align="center">3.6.3</td>
</tr>
</tbody></table>
<h3 id="3-2-Activiti支持的数据库"><a href="#3-2-Activiti支持的数据库" class="headerlink" title="3.2 Activiti支持的数据库"></a>3.2 Activiti支持的数据库</h3><p>Activiti 实质上就是通过数据库的数据表来控制业务流程。其支持的数据库如下：</p>
<table>
<thead>
<tr>
<th>数据库类型</th>
<th>JDBC连接示例</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>h2</td>
<td><code>jdbc:h2:tcp://localhost/activiti</code></td>
<td>默认使用的数据库</td>
</tr>
<tr>
<td>mysql</td>
<td><code>jdbc:mysql://localhost:3306/activiti?autoReconnect=true</code></td>
<td>使用<code>mysql-connector-java</code>数据库驱动程序进行测试</td>
</tr>
<tr>
<td>oracle</td>
<td><code>jdbc:oracle:thin:@localhost:1521:xe</code></td>
<td></td>
</tr>
<tr>
<td>postgres</td>
<td><code>jdbc:postgresql://localhost:5432/activiti</code></td>
<td></td>
</tr>
<tr>
<td>db2</td>
<td><code>jdbc:db2://localhost:50000/activiti</code></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h3 id="3-3-依赖坐标"><a href="#3-3-依赖坐标" class="headerlink" title="3.3 依赖坐标"></a>3.3 依赖坐标</h3><ul>
<li><p>Activiti核心依赖</p>
<ul>
<li>  在Maven项目中，只需导入该依赖即可使用Activiti的核心功能</li>
</ul>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--activiti核心依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.0.M6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>SpringBoot整合Activiti依赖</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4、Activiti配置入门"><a href="#4、Activiti配置入门" class="headerlink" title="4、Activiti配置入门"></a>4、Activiti配置入门</h2><blockquote>
<p>  <strong>前置：</strong></p>
<ol>
<li> 在MySQL服务器中创建一个 activiti01 数据库；</li>
<li> 创建Maven项目并导入相关依赖；</li>
</ol>
</blockquote>
<h3 id="4-1-activiti-cfg-xml-核心配置"><a href="#4-1-activiti-cfg-xml-核心配置" class="headerlink" title="4.1 activiti.cfg.xml 核心配置"></a>4.1 activiti.cfg.xml 核心配置</h3><p>Activiti 流程引擎通过名为 <code>activiti.cfg.xml</code> 的配置文件进行配置。所以需要在 resource 目录下创建 <code>activiti.cfg.xml</code> 文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--默认情况下，bean的id必须是processEngineConfiguration--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/activiti01?nullCatalogMeansCurrent=true<span class="symbol">&amp;amp;</span>autoReconnect=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--characterEncoding=utf8 ：防止向MySQL中插入中文数据时乱码--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nullCatalogMeansCurrent=true ：解决数据库初始化时自动创建表的问题--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &amp;amp;  转义符+分隔符--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcDriver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUsername&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql_lvnengdong&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcPassword&quot;</span> <span class="attr">value</span>=<span class="string">&quot;AdminLnd5639634&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--activiti 数据库表的生成策略--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            自动更新数据库结构：</span></span><br><span class="line"><span class="comment">                true：默认值，适用于开发环境。activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建。</span></span><br><span class="line"><span class="comment">                false：适用于生产环境。activiti在启动时，会对比当前数据库中表的版本，不过没有表或者版本不匹配，则抛出异常。</span></span><br><span class="line"><span class="comment">                create_drop：在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）</span></span><br><span class="line"><span class="comment">                drop_create：在activiti启动时删除原来的旧表，然后再创建新表（不需要手段关闭引擎）</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseSchemaUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>注意：</strong></p>
<ul>
<li>  为了防止向MySQL数据库中插入中文数据时乱码，需要设置插入数据的字符编码为UTF8。</li>
<li>  数据库连接URL后面可以添加多个属性，当存在多个属性时，彼此之间需要使用『转义符+封号』<code>&amp;amp;</code> 分隔。 </li>
</ul>
</blockquote>
<h3 id="4-2-创建ProcessEngine流程引擎实例和数据表"><a href="#4-2-创建ProcessEngine流程引擎实例和数据表" class="headerlink" title="4.2 创建ProcessEngine流程引擎实例和数据表"></a>4.2 创建ProcessEngine流程引擎实例和数据表</h3><p>加载类路径下的 <code>activiti.cfg.xml</code> 配置文件，根据该文件中的配置构造一个流程引擎实例。在创建该实例的时候，会执行数据库的初始化脚本创建数据表。</p>
<p>创建ProcessEngine流程引擎实例的方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngine;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngineConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngines;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/3 17:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivitiTest01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建流程引擎实例。</span></span><br><span class="line"><span class="comment">     * 在创建流程引擎实例的时候，会执行数据库初始化脚本，在数据库中创建25张表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getProcessEngine</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方式一：使用工具类ProcessEngines获取默认的流程引擎实例</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 使用这种方式，要求核心配置文件中流程引擎实例的id必须是 “processEngineConfiguration”</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">        System.out.println(<span class="string">&quot;processEngine：&quot;</span> + processEngine);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 方式二：使用配置类创建流程引擎实例（等同于方式一）</span></span><br><span class="line"><span class="comment">        *   查看源码可知，该方法底层调用了 createProcessEngineConfigurationFromResource 方法，并指定了</span></span><br><span class="line"><span class="comment">        *   配置文件的路径为 activiti.cfg.xml ，核心实例的 beanName 为 processEngineConfiguration</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *   所以，举一反三可以知道，如果想自定义配置文件的路径和核心实例的 beanName，可直接调用</span></span><br><span class="line"><span class="comment">        *   createProcessEngineConfigurationFromResource 方法</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">ProcessEngineConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> ProcessEngineConfiguration.createProcessEngineConfigurationFromResourceDefault();</span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">processEngine1</span> <span class="operator">=</span> configuration.buildProcessEngine();</span><br><span class="line">        System.out.println(<span class="string">&quot;processEngine1：&quot;</span> + processEngine1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 方式三：显式指定配置文件路径和 beanName</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">ProcessEngineConfiguration</span> <span class="variable">configuration1</span> <span class="operator">=</span> ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(<span class="string">&quot;activiti.cfg.bak.xml&quot;</span>, <span class="string">&quot;myProcessEngineConfiguration&quot;</span>);</span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">processEngine2</span> <span class="operator">=</span> configuration1.buildProcessEngine();</span><br><span class="line">        System.out.println(<span class="string">&quot;processEngine2：&quot;</span> + processEngine2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-3-Activiti的25张数据表分析"><a href="#4-3-Activiti的25张数据表分析" class="headerlink" title="4.3 Activiti的25张数据表分析"></a>4.3 Activiti的25张数据表分析</h3><p>Activiti 在创建 ProcessEngine 流程实例的时候会自动创建25张数据表，这正是 Activiti 能实现工作流的基础。</p>
<p><img src="/2022/06/03/Activiti7/image-20220604091757471.png" alt="image-20220604091757471"></p>
<p>Activiti 数据库中表的命名都是以 <code>act_</code> 开头的。<code>act_</code> 代表 Activiti。</p>
<ul>
<li>  <code>act_ge_*</code>：ge 是 generate 的缩写。这些表存放通用数据。即在各种情况下都会使用的数据，比如资源文件（图片、规则等）。</li>
<li>  <code>act_hi_*</code>：hi 是 history 的缩写。这些表存放历史数据，如结束的流程实例（变量、任务等）</li>
<li>  <code>act_re_*</code>：re 是 repository 的缩写。这些表存放静态数据信息。比如，流程定义、流程的资源（图片、规则等）。Activiti 只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。这样运行时表就可以一直很小、速度很快。</li>
<li>  <code>act_ru_*</code>：ru 是 runtime 的缩写。这些表是运行时的流程变量，用户任务、职责等运行时的数据。Activiti 只存储实例执行期间的运行时数据，当流程实例结束时，将删除这些记录。这就保证了这些运行时的表小且快。</li>
<li>  <code>act_evt_log</code>：evt 是 event 的缩写。这张表是流程引擎通用事件的日志记录表，方便管理员跟踪处理。</li>
<li>  <code>act_procdef_info</code></li>
</ul>
<table>
<thead>
<tr>
<th>表名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>通用数据</strong></td>
<td></td>
</tr>
<tr>
<td>act_ge_bytearray</td>
<td>二进制数据表。主要用来存储一些字节数据，比如涉及到的图片、画的流程图以及对应的XML文件，都会以二进制数据保存在这张表中。</td>
</tr>
<tr>
<td>act_ge_property</td>
<td>属性数据表。存储整个Activiti引擎的元数据信息。初始化表结构时，会插入版本号信息等。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>历史数据</strong></td>
<td></td>
</tr>
<tr>
<td>act_hi_actinst</td>
<td>历史节点表</td>
</tr>
<tr>
<td>act_hi_attachment</td>
<td>历史附件表。比如审批可能会涉及到提交附件，就会保存在这张表中。</td>
</tr>
<tr>
<td>act_hi_comment</td>
<td>历史意见表。如果审批时除了“批准”或“不批准”外，还需要编辑“审批意见”，则“审批意见”会保存在这张表中。</td>
</tr>
<tr>
<td>act_hi_detail</td>
<td>历史详情表。提供历史变量查询。</td>
</tr>
<tr>
<td>act_hi_identitylink</td>
<td>历史流程人员表。每个节点对应的审批人/处理人的信息。</td>
</tr>
<tr>
<td>act_hi_procinst</td>
<td>历史流程实例表。procinst = process instance。每次提交申请，都会保存一份历史数据</td>
</tr>
<tr>
<td>act_hi_taskinst</td>
<td>历史任务实例表</td>
</tr>
<tr>
<td>act_hi_varinst</td>
<td>历史变量表</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>流程定义表</strong></td>
<td></td>
</tr>
<tr>
<td>act_re_deployment</td>
<td>部署信息表</td>
</tr>
<tr>
<td>act_re_model</td>
<td>流程设计模型表</td>
</tr>
<tr>
<td>act_re_procdef</td>
<td>流程定义数据表</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>流程运行数据表</strong></td>
<td></td>
</tr>
<tr>
<td>act_ru_deadletter_job</td>
<td>作业死亡信息表。如果作业失败超过重试次数，则写入到此表。</td>
</tr>
<tr>
<td>act_ru_event_subscr</td>
<td>throwEvent、catchEvent时间监听信息表</td>
</tr>
<tr>
<td>act_ru_execution</td>
<td>运行时流程执行实例表</td>
</tr>
<tr>
<td>act_ru_identitylink</td>
<td>运行时流程人员表。主要存储任务节点与参与者的相关信息。</td>
</tr>
<tr>
<td>act_ru_integration</td>
<td>运行时积分表。</td>
</tr>
<tr>
<td>act_ru_job</td>
<td>定时异步任务数据表。</td>
</tr>
<tr>
<td>act_ru_suspended_job</td>
<td>运行时作业暂停表。比如流程中有一个定时任务，如果把这个任务停止工作了，这个任务写入此表中。</td>
</tr>
<tr>
<td>act_ru_task</td>
<td>运行时任务节点表。</td>
</tr>
<tr>
<td>act_ru_timer_job</td>
<td>运行时定时器作业表。</td>
</tr>
<tr>
<td>act_ru_variable</td>
<td>运行时流程变量数据表。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>其它表</strong></td>
<td></td>
</tr>
<tr>
<td>act_procdef_info</td>
<td>流程定义的动态变更信息。procdef = process definition。即如果流程的定义发生了变更，会在这张表中进行记录。</td>
</tr>
<tr>
<td>act_evt_log</td>
<td>通用事件日志记录表。</td>
</tr>
</tbody></table>
<p>act_hi_detail，提供历史变量查询。比如在请假流程中，如果“请假时间&lt;3天”由直接部门领导审批即可，如果“请假时间&gt;3天”，则需要总经理审核。这其中，“3天”就是一个历史变量，而历史变量就会保存在 act_hi_detail 表中。</p>
<h2 id="Activiti-API服务接口"><a href="#Activiti-API服务接口" class="headerlink" title="Activiti API服务接口"></a>Activiti API服务接口</h2><p>Activiti 流程引擎包含了 25 张表，而且表间关系复杂，理解难度高。</p>
<p>按照传统的方式，有了数据库表后，就应该为每张表创建 Entity 实体类，然后为其创建对应的 DAO 接口，然后再创建对应的 Service 来实现对表数据的增删改查。</p>
<p>但是这些表数量多，关系复杂，还要兼顾流程引擎的处理方式，自己去实现一套处理规则难度很大。</p>
<p>因此 Activiti 已经帮我们把这些东西都实现了，不需要我们手动去创建 Entity、Dao、Service、Controller，它提供了一套简单易用的 APi，我们直接调用即可完成对应的功能。</p>
<p><img src="/2022/06/03/Activiti7/image-20220604111356712.png" alt="image-20220604111356712"></p>
<blockquote>
<p>  <strong>Tip</strong></p>
<p>  Activiti7 中没有 IdentityService 和 FormService 接口。</p>
</blockquote>
<h3 id="Activiti7的Service核心接口"><a href="#Activiti7的Service核心接口" class="headerlink" title="Activiti7的Service核心接口"></a>Activiti7的Service核心接口</h3><ul>
<li><p>Service管理接口说明</p>
<table>
<thead>
<tr>
<th>Service接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RuntimeService</strong></td>
<td>运行时Service，可以处理所有处于运行状态的流程实例和任务。</td>
</tr>
<tr>
<td><strong>RepositoryService</strong></td>
<td>流程仓库Service，主要用于管理流程仓库，比如流程模型的控制管理（部署、删除、挂起、激活…）</td>
</tr>
<tr>
<td><strong>TaskRepository</strong></td>
<td>任务Service。用于管理和查询任务，例如：签收、办理等。</td>
</tr>
<tr>
<td><strong>HistoryService</strong></td>
<td>历史Service。可以查询所有历史数据，例如，流程实例信息、参与者信息、完成时间…</td>
</tr>
<tr>
<td>ManagementService</td>
<td>引擎管理Service。和具体业务无关，主要用于对Activiti流程引擎进行管理和维护。</td>
</tr>
<tr>
<td>DynamicBpmnService</td>
<td>RepositoryService可以用来部署流程模型（使用XML定义好的），一旦部署到Activiti（解析后保存到DB）后，流程模型就不会再变了，除非修改XML文件内容并重新部署。而DynamicBpmnService则允许我们在程序运行的过程中去修改流程模型的内容。比如：修改流程定义中分配的角色、优先级、流程流转条件等。</td>
</tr>
</tbody></table>
</li>
<li><p>核心Service接口实例的获取方式</p>
<p>  <img src="/2022/06/03/Activiti7/image-20220604113226413.png" alt="image-20220604113226413"></p>
</li>
</ul>
<blockquote>
<p>  创建流程引擎实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p>Activiti 在创建流程引擎实例时，会执行数据库初始化的脚本，除了创建 25 张表外，还会执行下列语句向 <code>ACT_GE_PROPERTY</code> 表中插入一些元数据信息。</p>
<p>总共插入了 4 条数据，也就是说：在成功创建流程引擎实例后，数据库中就存在了以下四条记录。</p>
<p><img src="/2022/06/03/Activiti7/Activiti%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-1654417958883.png" alt="Activiti数据库初始化"></p>
<h3 id="部署流程模型"><a href="#部署流程模型" class="headerlink" title="部署流程模型"></a>部署流程模型</h3><p>通过BPMN和png文件部署流程模型</p>
<p>BPMN 对应的 XML 文件是流程模型真正的数据来源，而png图片只是对XML数据的描述文件，更方便用户进行预览。</p>
<p>部署流程模型的实质就是通过 Activiti 提供的 API 向数据库表中添加数据。我们以创建一个“请假申请流程”为例，查看部署流程模型时都向哪些表中添加了数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngine;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngines;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.RepositoryService;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.repository.Deployment;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.repository.DeploymentBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/5 10:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivitiTest02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 部署流程模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deploymentTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取流程引擎实例</span></span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">        <span class="comment">// 2、获取部署流程模型的相关Service——RepositoryService</span></span><br><span class="line">        <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line">        <span class="comment">// 3、调用相关API部署流程模型</span></span><br><span class="line">        <span class="type">DeploymentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> repositoryService.createDeployment();</span><br><span class="line">        <span class="type">Deployment</span> <span class="variable">deployment</span> <span class="operator">=</span> builder.name(<span class="string">&quot;请假申请流程&quot;</span>)  <span class="comment">// 起名字</span></span><br><span class="line">                .addClasspathResource(<span class="string">&quot;processes/leave.bpmn&quot;</span>)  <span class="comment">// 加载资源文件</span></span><br><span class="line">                .addClasspathResource(<span class="string">&quot;processes/leave.png&quot;</span>)</span><br><span class="line">                .deploy();</span><br><span class="line">        <span class="comment">// 4、输出部署结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;部署ID=====&quot;</span> + deployment.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;部署名称=====&quot;</span> + deployment.getName());</span><br><span class="line">        <span class="comment">// 5、部署之后，流程模型数据就会保存到数据库表中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 执行以上代码，输出结果为：</span></span><br><span class="line"><span class="comment">        --------------------------------------</span></span><br><span class="line"><span class="comment">                部署ID=====1</span></span><br><span class="line"><span class="comment">                部署名称=====请假申请流程</span></span><br><span class="line"><span class="comment">        ----------------------------------- */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应数据库涉及到的写操作操作有：</p>
<p><img src="/2022/06/03/Activiti7/%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%98%E5%8C%96.png" alt="部署流程模型数据库变化"></p>
<p><img src="/2022/06/03/Activiti7/bpmn-structure.png" alt="bpmn-structure"></p>
<p><img src="/2022/06/03/Activiti7/activiti-flow.png" alt="activiti-flow"></p>
<h2 id="流程-amp-流程实例"><a href="#流程-amp-流程实例" class="headerlink" title="流程 &amp; 流程实例"></a>流程 &amp; 流程实例</h2><ul>
<li>  流程由遵守 BPMN2.0 规范的 XML 文件指定，定义流程即完成流程文件的设计。</li>
<li>  流程发布后，使用 RuntimeService 可以开启一个流程实例，每个流程可以开启 N 次流程实例，且实例之间的数据相互隔离。</li>
</ul>
<h2 id="用户任务"><a href="#用户任务" class="headerlink" title="用户任务"></a>用户任务</h2><p>用户任务是 BPMN 规范中 Activities 组件下的重要组成部分，在 Activiti 中对应 Task 类；区别于其它类型的任务，用户任务需要进行领取操作，不会自动执行，且领取后从待处理任务列表中移出，其它候选人不可见。</p>
<h2 id="用户-amp-角色"><a href="#用户-amp-角色" class="headerlink" title="用户 &amp; 角色"></a>用户 &amp; 角色</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/31/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/31/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-31 12:13:49" itemprop="dateCreated datePublished" datetime="2022-05-31T12:13:49+08:00">2022-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-11-06 15:36:06" itemprop="dateModified" datetime="2021-11-06T15:36:06+08:00">2021-11-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
