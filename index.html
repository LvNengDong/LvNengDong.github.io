<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">计算机组成原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-11 22:29:53" itemprop="dateCreated datePublished" datetime="2022-09-11T22:29:53+08:00">2022-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-09-15 00:30:10" itemprop="dateModified" datetime="2022-09-15T00:30:10+08:00">2022-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="冯诺伊曼体系"><a href="#冯诺伊曼体系" class="headerlink" title="冯诺伊曼体系"></a>冯诺伊曼体系</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>将<strong>程序指令</strong>和<strong>数据</strong>一起存储的计算机。</p>
<h3 id="冯诺依曼体系诞生的背景"><a href="#冯诺依曼体系诞生的背景" class="headerlink" title="冯诺依曼体系诞生的背景"></a>冯诺依曼体系诞生的背景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 早期计算机仅含固定用途程序</span><br><span class="line">&gt;&gt; 改变程序得更改结构、重新设计电路</span><br><span class="line">&gt;&gt; 把程序存储起来并设计通用电路</span><br><span class="line">&gt;&gt; 存储程序指令，设计通用电路</span><br></pre></td></tr></table></figure>

<ol>
<li>早期的计算机仅能运行固定用途程序（程序由硬件决定）。也就是说，一台计算机能执行什么功能在它出厂时就已经确定了，一台设计用来做数学运算的计算机只能用于执行出厂时初始化好的数学运算程序，不能做一些文本编辑功能，也不能用来打游戏。这就是“程序指令被写死了”，是刻在硬件上的。【数据是灵活的，程序是写死的】</li>
<li>如果想要让计算机具备其它功能，就必须更改电路，重新设计机器（硬件）。</li>
<li>为了改变这一现状，冯诺依曼的想法是——把程序存储起来，并设计通用电路。让程序决定电路的走向，进而实现不同的功能。【数据是灵活的，程序也是灵活的】</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911224816690.png" alt="image-20220911224816690"></p>
<h3 id="冯诺依曼体系架构"><a href="#冯诺依曼体系架构" class="headerlink" title="冯诺依曼体系架构"></a>冯诺依曼体系架构</h3><p><strong>体系架构</strong></p>
<ul>
<li>必须有一个存储器：存储程序和程序运行所需的数据</li>
<li>必须有一个控制器：控制程序的流转</li>
<li>必须有一个运算器</li>
<li>必须有输入设备</li>
<li>必须有输出设备</li>
</ul>
<p><strong>冯诺依曼机能够完成的功能</strong></p>
<ul>
<li>能够把需要的程序和数据送至计算机中</li>
<li>能够长期记忆程序、数据、中间结果及最终运算结果的能力</li>
<li>能够具备算术、逻辑运算和数据传送等数据加工处理的能力</li>
<li>能够按照要求将处理结果输出给用户</li>
</ul>
<blockquote>
<p>现代计算机都是冯诺依曼机</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911225714328.png" alt="image-20220911225714328"></p>
<p>图解：</p>
<ul>
<li>运算器协同存储器、控制器完成数据的处理，把处理结果给到输出设备；</li>
<li>控制器不仅控制了运算器和存储器，还控制了输入、输出设备，控制器是至关重要的一环。</li>
</ul>
<h3 id="冯诺依曼瓶颈"><a href="#冯诺依曼瓶颈" class="headerlink" title="冯诺依曼瓶颈"></a>冯诺依曼瓶颈</h3><p>上图就是一个早期的冯诺依曼计算机体系结构的示意图。可以看到，存储器和CPU是分开的。实际上，将存储器和CPU分开并不是一个好的结构，这也是冯诺依曼结构的瓶颈所在——<strong>CPU和存储器之间的速率问题无法调和</strong>。</p>
<p>一般而言，CPU速率是要远快于存储器的，这也就导致了CPU经常空转等待数据传输，这时非常浪费CPU资源的。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911230701008.png" alt="image-20220911230701008"></p>
<h2 id="现代计算机的结构"><a href="#现代计算机的结构" class="headerlink" title="现代计算机的结构"></a>现代计算机的结构</h2><p>现代计算机结构本质上还属于冯诺依曼体系，不过它在冯诺依曼体系结构的基础上进行了一定程度的修改，用于解决 CPU与存储设备之间的性能差异问题。</p>
<p>现代计算机的体系结构如下图，它将存储器也纳入了CPU的范围。当然，这里的存储器主要是指围绕CPU构建的高速存储设备，比如 CPU的寄存器、内存等等。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911231021606.png" alt="image-20220911231021606"></p>
<h1 id="计算机的层次与编程语言"><a href="#计算机的层次与编程语言" class="headerlink" title="计算机的层次与编程语言"></a>计算机的层次与编程语言</h1><p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220911233008017.png" alt="image-20220911233008017"></p>
<h2 id="硬件逻辑层"><a href="#硬件逻辑层" class="headerlink" title="硬件逻辑层"></a>硬件逻辑层</h2><ul>
<li>门、触发器等逻辑电路组成</li>
</ul>
<h2 id="微程序机器层"><a href="#微程序机器层" class="headerlink" title="微程序机器层"></a>微程序机器层</h2><ul>
<li>编程语言是<strong>微指令集</strong></li>
<li><strong>微指令</strong>所组成的<strong>微程序</strong>直接交由硬件执行。</li>
</ul>
<blockquote>
<p>微指令是直接操控计算机硬件的指令，计算机在出厂时已经定义好了各种各样的微指令，组成了所谓的“微指令集”。上层程序将多个微指令组成微程序，直接交由计算机硬件调度。</p>
</blockquote>
<h2 id="传统机器层"><a href="#传统机器层" class="headerlink" title="传统机器层"></a>传统机器层</h2><ul>
<li>编程语言是 CPU 指令集（机器指令）</li>
<li>编程语言和硬件是直接相关</li>
<li>不同架构的 CPU 使用不同的 CPU 指令集</li>
</ul>
<blockquote>
<p>传统机器层的编程语言是CPU指令集，这一层提供了各种各样的CPU指令（机器指令），通过机器指令操作硬件。程序员可以直接编写机器指令来操作计算机硬件。</p>
<p>不同架构的CPU使用的机器指令集是不一样的。比如 Inter 和 AMD 这两种 CPU 就使用两套不同的指令集，除了不同厂商，同一厂商也会生产不同指令集的CPU，比如 x86 和 x86-64 也使用了不同的指令集，所以它们之间是无法相互兼容的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912004341651.png" alt="image-20220912004341651"></p>
<h2 id="操作系统层"><a href="#操作系统层" class="headerlink" title="操作系统层"></a>操作系统层</h2><ul>
<li>向上提供了简易的操作界面</li>
<li>向下对接了指令系统，管理硬件资源</li>
<li>操作系统层是在软件和硬件之间的适配层</li>
</ul>
<h2 id="汇编语言层"><a href="#汇编语言层" class="headerlink" title="汇编语言层"></a>汇编语言层</h2><ul>
<li>编程语言是汇编语言</li>
<li>汇编语言可以<strong>翻译</strong>成可直接执行的机器语言</li>
<li>完成翻译的过程的程序就是汇编器</li>
</ul>
<p>汇编语言的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 把DS放入堆或栈</span><br><span class="line">PUSH DS</span><br><span class="line">PUSH AX</span><br><span class="line"># 移动 AX 到 <span class="number">0040</span></span><br><span class="line">MOV AX,<span class="number">0040</span></span><br><span class="line">MOV DS,AX</span><br></pre></td></tr></table></figure>



<h2 id="高级语言层"><a href="#高级语言层" class="headerlink" title="高级语言层"></a>高级语言层</h2><ul>
<li>Java、C、…</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul>
<li>Office、WPS、…</li>
</ul>
<hr>
<h1 id="计算机的计算单位"><a href="#计算机的计算单位" class="headerlink" title="计算机的计算单位"></a>计算机的计算单位</h1><h2 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a>容量单位</h2><p>TODO</p>
<h2 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a>速度单位</h2><p>TODO</p>
<hr>
<h1 id="计算机的字符与编码集"><a href="#计算机的字符与编码集" class="headerlink" title="计算机的字符与编码集"></a>计算机的字符与编码集</h1><h2 id="字符编码集的历史"><a href="#字符编码集的历史" class="headerlink" title="字符编码集的历史"></a>字符编码集的历史</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><ul>
<li>ASCII 可以理解为一个美版或英版的 GBK。</li>
<li>ASCII码包含 95 个可打印字符，</li>
<li>33 个不可打印字符（包括控制字符）</li>
<li>使用 7 个 bits 就可以完全表示 ASCII 码</li>
</ul>
<p>$$<br>𝟑𝟑+𝟗𝟓=𝟏𝟐𝟖=𝟐^𝟕<br>$$</p>
<blockquote>
<p>计算机早期的主要在美、英等英语母语国家使用，因此 ASCII 码已经足以满足日常使用了。但是随着一些非英语母语国家引入计算机，ASCII 就开始无法描述这些国家的语言了。比如一些数学符号 “÷ ≠ ≥ ≈” 等。因此，就有了第一次对 ASCII 码的扩充，从7bits 扩充到了 8bits，原来的128个字符就扩充到了256个字符，对应的是 Extended ASCII 码。</p>
</blockquote>
<h3 id="Extended-ASCII码"><a href="#Extended-ASCII码" class="headerlink" title="Extended ASCII码"></a>Extended ASCII码</h3><p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912010432326.png" alt="image-20220912010432326"></p>
<h3 id="字符编码集的国际化"><a href="#字符编码集的国际化" class="headerlink" title="字符编码集的国际化"></a>字符编码集的国际化</h3><ul>
<li>欧洲、中亚、东亚、拉丁美洲国家的语言多样性</li>
<li>语言体系不一样，不以有限字符组合的语言。<ul>
<li>不以有限字符组合：英文是以有限个字符进行组合的，无论有多少个单词，始终都基于这个26个字母；而中文则不以有限个字符进行组合。</li>
</ul>
</li>
<li>中国、韩国、日本等的语言最为复杂。</li>
</ul>
<h2 id="中文编码集"><a href="#中文编码集" class="headerlink" title="中文编码集"></a>中文编码集</h2><p>GBK：收录了 21003 个汉字，支持全部中日韩汉字。</p>
<blockquote>
<p>GBK 是一个比较完备的中文字符编码集，但同时它也只是一个<strong>本地化的编码集</strong>。也就是说，它用于汉字和01机器码之间的转换，这套编码对于安装了GBK编码集的机器使用是完全没问题的，但是如果在国外一台没有安装GBK编码的机器上，显然会出现大问题。</p>
<p>比如，国内的一个纯中文的网站，被美国一台电脑浏览，这台电脑没有安装GBK编码，那么这个网页在电脑中的显示就是乱码的。</p>
<p>所以，我们不仅要有本地化的编码，还要有全世界统一的规范。</p>
</blockquote>
<h2 id="兼容全球的字符集：Unicode"><a href="#兼容全球的字符集：Unicode" class="headerlink" title="兼容全球的字符集：Unicode"></a>兼容全球的字符集：Unicode</h2><ul>
<li>Unicode ：统一码、万国码、单一码</li>
<li>Unicode 定义了世界通用的符号集， <code>UTF-*</code> 实现了编码</li>
<li><code>UTF-8</code> 以字节为单位对 Unicode 进行编码</li>
</ul>
<blockquote>
<ul>
<li>中文版的 Windows 系统默认使用 GBK 编码</li>
<li>编程推荐使用 UTF-8 编码</li>
</ul>
</blockquote>
<h1 id="计算机概论组成篇"><a href="#计算机概论组成篇" class="headerlink" title="计算机概论组成篇"></a>计算机概论组成篇</h1><h2 id="章节导学"><a href="#章节导学" class="headerlink" title="章节导学"></a>章节导学</h2><p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912012557727.png" alt="image-20220912012557727"></p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912012900633.png" alt="image-20220912012900633"></p>
<h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><h3 id="总线的概述"><a href="#总线的概述" class="headerlink" title="总线的概述"></a>总线的概述</h3><p>解决不同设备之间的通信问题。</p>
<h4 id="是什么？有什么用？"><a href="#是什么？有什么用？" class="headerlink" title="是什么？有什么用？"></a>是什么？有什么用？</h4><p><strong>USB总线</strong></p>
<p>USB 的全称是 Universal Serial Bus，它也是一条总线，中文名叫“通用串行总线”。USB 总线的作用有以下几个：</p>
<ul>
<li>提供了计算机对外的连接接口。鼠标、键盘等外设可以通过USB连接到计算机上。</li>
<li>规定了连接的标准，促使外围设备接口的统一。</li>
</ul>
<p>类似的，除了 USB总线，计算机中还有 PCI总线（用来连接外置显卡）、ISA总线等等。总结以下就是：总线是为了解决不同设备之间的通信问题而存在的。</p>
<p><strong>有什么用</strong></p>
<p>没有总线（没有统一的连接标准）之前，每个输入设备需要分别连接到存储器、运算器、控制器上，一旦输入设备多了的话，连接线就会越来越多，连接就会比较乱。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912014543563.png" alt="image-20220912014543563"></p>
<p>有了总线之后（以IO总线为例），外围设备连接只需要连接到总线上，由总线进行转发，对外暴露的结构非常简单。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912014832192.png" alt="image-20220912014832192"></p>
<h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><h4 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h4><p>片内总线：芯片（CPU）内部的总线。高集成度芯片内部的信息传输线。</p>
<ul>
<li>寄存器与寄存器之间</li>
<li>寄存器与控制器、运算器之间</li>
<li>高集成度芯片内部的信息传输线</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912015528776.png" alt="image-20220912015528776"></p>
<h4 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h4><p>系统总线：连接计算机各种外围设备的总线。外围设备包括：硬盘、IO设备、USB插槽、PCI插槽、显卡、声卡等。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912015737767.png" alt="image-20220912015737767"></p>
<p>整体而言，系统总线可分为以下三类：</p>
<ul>
<li>数据总线</li>
<li>地址总线</li>
<li>控制总线</li>
</ul>
<blockquote>
<p>系统总线：CPU、主内存、 IO设备、各组件之间的信息传输线。</p>
</blockquote>
<p><strong>数据总线：</strong></p>
<ul>
<li>双向传输各个部件的数据信息</li>
<li>数据总线的位数（总线宽度）是数据总线的重要参数，一般与CPU位数相同（32/64位）。</li>
<li>对于32位的总线，单次可以传输32bit（4byte）的数据。</li>
</ul>
<p><strong>地址总线：</strong></p>
<ul>
<li>地址总线的作用是：用于传输数据的地址（寻址），即指定源数据或目的数据在内存中的地址</li>
<li>地址总线的位数与存储单元有关</li>
<li>如果 <code>地址总线位数=n</code>，那么它的寻址范围就是 <code>0~ 𝟐^𝒏</code>。</li>
</ul>
<p><strong>控制总线：</strong></p>
<ul>
<li>控制总线是用来发出各种控制信号的传输线</li>
<li>控制信号经由控制总线从一个组件发给另外一个组件，比如从<code>CPU-&gt;磁盘</code></li>
<li>控制总线可以监视不同组件之间的状态（就绪/未就绪）</li>
</ul>
<h3 id="总线的仲裁"><a href="#总线的仲裁" class="headerlink" title="总线的仲裁"></a>总线的仲裁</h3><h4 id="为什么需要总线仲裁"><a href="#为什么需要总线仲裁" class="headerlink" title="为什么需要总线仲裁"></a>为什么需要总线仲裁</h4><p>为什么需要总线仲裁：为了解决总线使用权的冲突问题。</p>
<p>假设计算机中，主存需要和硬盘和IO设备交换数据，此时硬盘和IO设备都已经就绪了，那么“总线”该由硬盘来使用呢还是IO设备来使用呢？</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912020902697.png" alt="image-20220912020902697"></p>
<p><strong>总线仲裁</strong>就是用于解决不用设备使用总线的优先级策略，</p>
<h4 id="总线仲裁的方法"><a href="#总线仲裁的方法" class="headerlink" title="总线仲裁的方法"></a>总线仲裁的方法</h4><h5 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h5><p>现有设备1、2、3通过总线与计算机内组件通信，仲裁控制器通过仲裁控制线与设备1、2、3通信。对于<strong>链式查询</strong>而言，会将多个设备按优先排成一个链条。如果设备2希望使用总线，需要先通过仲裁控制线向仲裁控制器发送仲裁请求，仲裁控制器按照1、2、3的顺序发送仲裁结果，所以仲裁结果一定会先到达设备1，如果设备1此时不需要使用总线，则将使用权继续转发到设备2，如果设备1此时正好也需要使用总线，那么优先得到总线的使用权，设备2此时得不到总线的使用权。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912021319208.png" alt="image-20220912021319208"></p>
<ul>
<li>好处：电路复杂度低，仲裁方式简单</li>
<li>坏处：<ul>
<li>优先级低的设备难以获得总线使用权</li>
<li>对电路故障敏感，出现故障后会影响后面所有节点的设备</li>
</ul>
</li>
</ul>
<h5 id="计时器定时查询"><a href="#计时器定时查询" class="headerlink" title="计时器定时查询"></a>计时器定时查询</h5><ul>
<li>仲裁控制器对设备编号并使用计数器累计计数</li>
<li>接收到仲裁信号后，往所有设备发出计数值</li>
<li>计数值与设备编号一致则获得总线使用权</li>
</ul>
<p>仲裁控制器通过仲裁控制线与设备1、2、3通信，并且仲裁控制器内部会维护一个计数器，计数器值枚举了所有的设备编号。某个设备（以设备2为例）需要使用总线时，会先向仲裁控制器发送请求，仲裁控制器向所有的设备发送计时器的值，比如第一次发送了1，设备1收到1后不会使用总线（因为它没有使用总线的需求），设备2收到1后不能使用总线（因为计时器的值不对应）。如果设备2没有获得总线的使用权，每隔一段时间都会想仲裁控制器发送总线的使用请求，直至能够获取到。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912022344587.png" alt="image-20220912022344587"></p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912022404523.png" alt="image-20220912022404523"></p>
<h5 id="独立请求"><a href="#独立请求" class="headerlink" title="独立请求"></a>独立请求</h5><ul>
<li>每个设备均有总线独立连接仲裁器</li>
<li>设备可单独向仲裁器发送请求和接收请求</li>
<li>当同时收到多个请求信号，仲裁器有权按优先级分配使用权</li>
</ul>
<p>设备1、2、3可独立地向仲裁控制器发出仲裁请求以及接收仲裁控制发出的允许使用总线的信号。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912023255855.png" alt="image-20220912023255855"></p>
<ul>
<li>好处：响应速度快，优先顺序可动态改变</li>
<li>缺点：独立请求会导致设备连线多，总线控制复杂</li>
</ul>
<h1 id="计算机的输入输出设备"><a href="#计算机的输入输出设备" class="headerlink" title="计算机的输入输出设备"></a>计算机的输入输出设备</h1><h2 id="常见的输入输出设备"><a href="#常见的输入输出设备" class="headerlink" title="常见的输入输出设备"></a>常见的输入输出设备</h2><p>常见输入设备：</p>
<ul>
<li>字符输入设备：键盘</li>
<li>图像输入设备：鼠标、数位板、扫描仪</li>
</ul>
<p>图像输出设备：显示器、打印机、投影仪</p>
<h2 id="输入输出接口的通用设计"><a href="#输入输出接口的通用设计" class="headerlink" title="输入输出接口的通用设计"></a>输入输出接口的通用设计</h2><p>按照一般的设计思维，输入输出接口首先要有<strong>读写设备数据</strong>的功能，即计算机既可以读取输入设备的数据，也可以向输出设备中写数据；其次，计算机应该有<strong>感知设备是否被占用</strong>的功能，因为有些输入输出设备是独占式的，计算机必须感知到设备是否可用，进而设计不同情况下的处理策略；第三，接口应该被设计为可以<strong>判断设备是否已经连接成功</strong>的功能；第四，接口应该具备<strong>判断设备是否已经启动</strong>的功能。</p>
<h3 id="数据线"><a href="#数据线" class="headerlink" title="数据线"></a>数据线</h3><p>数据线是I/O设备与主机之间进行数据交换的传送线。根据IO设备的不同，数据线可分为：单向传输数据线和双向传输数据线。</p>
<h3 id="状态线"><a href="#状态线" class="headerlink" title="状态线"></a>状态线</h3><p>状态线是IO设备向主机报告自身状态的信号线。通过状态线，主机就可以查询设备是否已经正常连接并就绪，或查询设备是否已经被其它进程占用了。</p>
<h3 id="命令线"><a href="#命令线" class="headerlink" title="命令线"></a>命令线</h3><p>命令线是CPU向IO设备发送命令的信号线。比如发送读写信号，发送启动/停止信号。</p>
<p>以CPU读取磁盘上某个区域的数据为例，CPU首先会向磁盘设备发送读数据的信号。以光驱为例，CPU会向光驱设备发送启动/停止信号，以此来启动/停止光驱的马达。</p>
<h3 id="设备选择线"><a href="#设备选择线" class="headerlink" title="设备选择线"></a>设备选择线</h3><p>设备选择线是主机选择与某个I/O设备进行交互的信号线。通过设备选择线，主机就可以对连在总线上的I/O设备进行选择。</p>
<p>假设在USB总线上连接了3个U盘，此时，计算机对某个U盘的读写操作就是通过设备选择线来选择具体的U盘进行操作的。</p>
<h2 id="CPU与IO设备的通信"><a href="#CPU与IO设备的通信" class="headerlink" title="CPU与IO设备的通信"></a>CPU与IO设备的通信</h2><p>CPU速度与IO设备速度不一致。</p>
<h3 id="程序中断"><a href="#程序中断" class="headerlink" title="程序中断"></a>程序中断</h3><p>当外围的IO设备就绪时，就会向CPU发出中断信号，CPU内部有专门的电路来响应中断信号。当CPU收到中断信号后，就会暂停当前正在执行的工作，转为执行外围IO设备的工作。直到外围IO设备的工作执行完毕后，CPU才会继续执行之前暂停的工作。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912153148820.png" alt="image-20220912153148820"></p>
<p><code>发送中断（IO设备） -&gt; 响应中断（CPU） -&gt; 中断返回（CPU）</code> 的例子</p>
<p>以上图为例，</p>
<ul>
<li>在时间点1，CPU正在执行主程序，打印机处于待机状态；</li>
<li>在时间点2，CPU向打印机发送了一条“启动打印机”的命令，然后在时间点3切换任务重新回去执行主程序。打印机在收到命令后，开始做启动打印机的准备工作，当然，这个时间段相对较长一些；</li>
<li>在时间点4，当打印机准备就绪后，就会给CPU发送一个<strong>“程序中断”</strong>信号，CPU在收到这个信号后，就会发送这次中断，暂停正在执行的主程序，转而处理打印机的任务——向打印机发送要打印的数据。需要注意的是：CPU响应中断不一定是立即发生的，可能会有一定时延，比如有一个任务优先级非常高，那么此时这个打印机发送的中断就不会被立即响应。这里为了简化理解，我们省略了一些细节。</li>
<li>时间点4到时间点5之间就是CPU与打印机数据交换的过程，CPU发送数据，打印机接收数据。</li>
<li>在时间点5之后，打印机发送完数据后就切换任务重新去执行主程序了，而打印机接收完数据后就开始执行打印数据的过程了。</li>
</ul>
<p><strong>总结：</strong></p>
<p><code>程序中断提供了低速设备通知CPU的一种异步的方式，CPU可以高速运转同时兼顾低速设备的响应。</code></p>
<p><strong>不足：</strong></p>
<p>虽然通过“程序中断”，CPU可以高速运转同时兼顾低速设备的响应，但是外围设备频繁地打断CPU并不是一个很好的方式，因为CPU频繁切换线程会降低CPU的使用效率。因此，计算机内部还有一种不需要CPU参与的数据访问方式——DMA（直接存储器访问）。</p>
<h3 id="DMA（直接存储器访问）"><a href="#DMA（直接存储器访问）" class="headerlink" title="DMA（直接存储器访问）"></a>DMA（直接存储器访问）</h3><ul>
<li>DMA 也是一种硬件设备；</li>
<li>它直接连接主存与 IO 设备；</li>
<li>工作时不需要 CPU 的参与。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912155759946.png" alt="image-20220912155759946"></p>
<p>我们平时使用的硬盘、外置显卡等硬件中都有DMA这一设备。</p>
<hr>
<h1 id="计算机存储器概览"><a href="#计算机存储器概览" class="headerlink" title="计算机存储器概览"></a>计算机存储器概览</h1><h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><p><strong>按存储介质分类</strong></p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912161843335.png" alt="image-20220912161843335"></p>
<p><strong>按存取方式分类</strong></p>
<ul>
<li>随机存储器（RAM）：可读可写，存储器的任何一个单元随时都能被读（随机读取），但写不是随机的。</li>
<li>串行存储器：可读可写，但读取数据的时候需要按照数据写入的顺序从头开始查找。</li>
<li>只读存储器（ROM）：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912161918767.png" alt="image-20220912161918767"></p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="存储器的评价指标"><a href="#存储器的评价指标" class="headerlink" title="存储器的评价指标"></a>存储器的评价指标</h3><ul>
<li>读写速度：5400转、7200转</li>
<li>存储容量：2T、4G</li>
<li>价格</li>
</ul>
<p>存储器的这些评价指标是影响存取器层级结构的关键因素。</p>
<h3 id="存储器的层次结构-1"><a href="#存储器的层次结构-1" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p>位价是衡量存储器的指标，它综合考量了读写速度、存储容量及价格在内的一系列因素。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912162811913.png" alt="image-20220912162811913"></p>
<ul>
<li>缓存指CPU中的寄存器及高速缓存；</li>
<li>主存指计算机的内存；</li>
<li>辅存指计算机的一些外部存储设备，比如磁盘、U盘、硬盘等。</li>
</ul>
<h4 id="缓存-主存层次"><a href="#缓存-主存层次" class="headerlink" title="缓存-主存层次"></a>缓存-主存层次</h4><ul>
<li>原理：局部性原理</li>
<li>实现：在CPU与主存之间增加一层速度快（容量小）的 Cache</li>
<li><strong>目的：解决主存速度不足的问题。</strong></li>
</ul>
<p>因为有高速缓存的存在，所以让CPU尽可能多地区访问高速缓存而非主存，所以高速缓存中最好保存的都是一些热点数据，以此来提交CPU访问数据的命中率，进而提高CPU的利用率。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912163305685.png" alt="image-20220912163305685"></p>
<p><strong>局部性原理：</strong></p>
<blockquote>
<p>局部性原理是指CPU访问存储器时，无论是<code>存/取指令</code>还是<code>存/取数据</code>，所访问的存储单元都 <code>趋于聚集在一个较小的连续区域中 </code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220912164137379.png" alt="image-20220912164137379"></p>
<h4 id="主存-辅存层次"><a href="#主存-辅存层次" class="headerlink" title="主存-辅存层次"></a>主存-辅存层次</h4><ul>
<li>原理：局部性原理</li>
<li>实现：主存之外增加辅助存储器（磁盘、 SD 卡、 U 盘等）</li>
<li><strong>目的：解决主存容量不足的问题</strong></li>
</ul>
<p>假设你在电脑上装了一个30G的游戏，而你的电脑只有8G内存，那游戏是怎么跑起来的呢？这其实利用了局部性原理，电脑会将当前正在使用的数据加载到内存中，而对于一大部分不使用的数据则存放到辅存中去，通过主存和辅存频繁的数据交换来保证游戏的正常运行。这也是为什么我们在游戏中切换场景时会需要长时间 loading 的原因，因为切换场景需要交换的数据一般是比较多的，所以等待时间比较长。</p>
<h2 id="计算机的主存储器与辅助存储器"><a href="#计算机的主存储器与辅助存储器" class="headerlink" title="计算机的主存储器与辅助存储器"></a>计算机的主存储器与辅助存储器</h2><p>两个问题：</p>
<ul>
<li>为什么断电后，计算机内存中的数据会丢失？</li>
<li>为什么断电后，磁盘中的数据不会丢失？</li>
</ul>
<h3 id="主存储器——内存"><a href="#主存储器——内存" class="headerlink" title="主存储器——内存"></a>主存储器——内存</h3><ul>
<li>内存是一种RAM （随机存取存储器 Random Access Memory）</li>
<li>为什么断电后，主存中的数据会丢失：RAM 是通过<strong>电容</strong>来存储数据，必须隔一段时间刷新一次，刷新时必须连接点断；如果断电后，电容中的电子将会丢失，那么一段时间后将丢失所有数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913214628968.png" alt="image-20220913214628968"></p>
<p>主存储器由半导体存储体、驱动器、译码器、读写电路和控制电路组成。</p>
<p>主存如何与CPU进行交互：对于CPU而言，其内部有一个<code>主存数据寄存器（MDR）</code>，它会通过数据总线与读写电路进行连接，同时在CPU中还有一个<code>主存地址寄存器（MAR）</code>，它会通过地址总线与内存进行连接。有了数据总线和地址总线后，CPU 可以通过地址总线来指定将要读写内存中的哪一块数据，同时通过数据总线进行相关数据的传输。</p>
<p>主存与操作系统的位数也有一定的关系，我们平时所说的32位系统和64位系统，不同位数的系统对内存的要求也是不一样的，比如32位系统，最多只能支持4GB的内存，因为32位系统的地址总线最多只有 2^32 位，所以它的寻址范围最大只有4GB。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913215812034.png" alt="image-20220913215812034"></p>
<h3 id="辅助存储器——磁盘"><a href="#辅助存储器——磁盘" class="headerlink" title="辅助存储器——磁盘"></a>辅助存储器——磁盘</h3><h4 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h4><ul>
<li>表面是可磁化的硬磁特性材料</li>
<li>移动磁头读取磁道信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913215847990.png" alt="image-20220913215847990"></p>
<p>对于辅助存储器，它由<code>盘片</code>和<code>磁头</code>组成。盘片利用磁材料存储数据，磁头通过左右移动来读取盘片上存储的数据。</p>
<p><code>磁道</code>是指磁盘上某一圈存储的内容。</p>
<p><code>盘片</code>的一个平面结构如下：它会包含很多<code>磁道</code>，每条磁道又由多个<code>扇区</code>组成。通过<code>磁头位置</code>来描述磁头目前正处于哪一条磁道，通过<code>磁头方向</code>来描述磁头的旋转方向（顺时针/逆时针）</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913220238225.png" alt="image-20220913220238225"></p>
<h4 id="磁盘的调度算法"><a href="#磁盘的调度算法" class="headerlink" title="磁盘的调度算法"></a>磁盘的调度算法</h4><ul>
<li>先来先服务算法</li>
<li>最短寻道时间优先</li>
<li>扫描算法（电梯算法）</li>
<li>循环扫描算法</li>
</ul>
<img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913220816598.png" alt="image-20220913220816598" style="zoom: 50%;">

<p>假设最外圈磁道为磁道1，最内圈磁道为磁道5。假设磁头当前位于磁道4，并且磁头方向向外，现在CPU接到几个读取磁盘的任务，要求分别读取位置在 <code>1 4 2 3 1 5</code> 磁道上的数据。</p>
<h5 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h5><blockquote>
<p>按顺序访问进程的磁道读写需求</p>
</blockquote>
<p>对于<strong>FIFO</strong>算法，它会依次读取 1、4、2、3、1、5 磁道上的数据，平平无奇。</p>
<h5 id="最短寻道时间优先算法"><a href="#最短寻道时间优先算法" class="headerlink" title="最短寻道时间优先算法"></a>最短寻道时间优先算法</h5><blockquote>
<p>与磁头当前位置有关</p>
<p>优先访问离磁头最近的磁道</p>
</blockquote>
<p>对于<code>最短寻道时间优先算法</code>，我们可以先对磁道离磁头的距离做一个排序，分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">磁道4：0</span><br><span class="line">磁道3：1</span><br><span class="line">磁道2：2</span><br><span class="line">磁道1：3</span><br><span class="line">磁道5：1</span><br></pre></td></tr></table></figure>

<p>所以，CPU会依次读取4、5、3、2、1、1磁道上的数据。这里有一个问题是，磁道5和磁道3距离磁道4的距离都是1，至于它会先读取哪个磁道，我也没有看过具体的调度策略。</p>
<h5 id="扫描算法（电梯算法）"><a href="#扫描算法（电梯算法）" class="headerlink" title="扫描算法（电梯算法）"></a>扫描算法（电梯算法）</h5><ul>
<li>每次只往一个方向移动</li>
<li>到达一个方向需要服务的尽头再反方向移动</li>
</ul>
<p>因为当前磁头的运动方向是向外的，所以CPU最终访问磁盘的顺序是：4、3、2、1、1、5</p>
<h5 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h5><p>可以想象成把扫描算法的首尾连成了一个环。</p>
<p>因为当前磁头的运动方向是向外的，所以CPU最终访问磁盘的顺序是：4、3、2、1、1、5</p>
<hr>
<h2 id="计算机的高速缓存"><a href="#计算机的高速缓存" class="headerlink" title="计算机的高速缓存"></a>计算机的高速缓存</h2><p><code>CPU &lt;-&gt; 高速缓存 &lt;-&gt; 主存</code></p>
<p>高速缓存是CPU与主存之间的中间层，是为了解决CPU与主存速度不匹配而存在的。</p>
<h3 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h3><p><strong>字</strong>：是指存放在一个存储单元中的二进制代码组合<br><strong>字块</strong>：存储在<code>连续的</code>存储单元中而被看作是一个单元的一组字</p>
<p>假设一个字为32位，一个字块共B个字，那么<code>B*M</code>就是主存的总字数，<code>B*M*32</code>就是主存的总容量。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913225611387.png" alt="image-20220913225611387"></p>
<ul>
<li>字的地址包含两个部分</li>
<li>前m位指定字块的地址</li>
<li>后b位指定指定字在字块中的地址</li>
</ul>
<p>知道<strong>字</strong>与<strong>字块</strong>的概念有助于了解寻址的过程，对于<code>字的寻址</code>，首先会找到所在字块的地址，然后在字块中根据字的地址进行定位。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913230009309.png" alt="image-20220913230009309"></p>
<p>对于高速缓存中的数据而言，只存在两种情况，命中和未命中：</p>
<ul>
<li>CPU需要的数据在缓存里；</li>
<li>CPU需要的数据不在缓存里；-&gt;不在缓存中的数据需要去主存拿</li>
</ul>
<p>命中率：命中率是衡量缓存的重要性能指标。理论上 CPU 每次都能从高速缓存取数据的时候，命中率为 1。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913230819040.png" alt="image-20220913230819040"></p>
<blockquote>
<p>访问高速缓存的次数占访问总次数的比例。</p>
</blockquote>
<h3 id="高速缓存的替换策略"><a href="#高速缓存的替换策略" class="headerlink" title="高速缓存的替换策略"></a>高速缓存的替换策略</h3><p>为了保证缓存的利用率尽可能高，需要在不同场景下使用不同的缓存替换策略。</p>
<p><strong>高速缓存的替换时机：</strong>当CPU不能从高速缓存中获得所需的数据时，就需要从主存中载入所需数据，这时候就会执行数据的替换策略。</p>
<ul>
<li>随机算法</li>
<li>先进先出算法</li>
<li>最不经常使用算法 </li>
<li>最近最少使用算法</li>
</ul>
<hr>
<h1 id="计算机的指令系统"><a href="#计算机的指令系统" class="headerlink" title="计算机的指令系统"></a>计算机的指令系统</h1><h2 id="机器指令的形式"><a href="#机器指令的形式" class="headerlink" title="机器指令的形式"></a>机器指令的形式</h2><p>机器指令主要由两部分组成：操作码 + 地址码</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913231746532.png" alt="image-20220913231746532"></p>
<ul>
<li>操作码指明指令所要完成的操作。操作码的位数反映了机器的操作种类，比如对于8位的操作码，它的操作方式最多就只有<code>2^8=256</code>种。</li>
<li>地址码直接给出操作数或者操作数的地址。因为指令要服务于数据，CPU可以根据数据或数据地址进行相关运算。而地址码就是指向数据或数据的地址。地址码分三地址指令、二地址指令和一地址指令。三地址码指令指的是地址码中包含3个数据或数据地址，其它两个也类似。</li>
</ul>
<p><strong>三地址指令</strong></p>
<p>三地址码指令常见的操作如下，假设 Operation 为加法操作，常见的操作是：把addr1上的数据加到addr2上，并将最终结果写到addr3。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913232300660.png" alt="image-20220913232300660"></p>
<p><strong>二地址指令</strong></p>
<p>二地址指令常见的操作是 addr1+addr2，最后把结果存入 addr1 或者 addr2。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913233114057.png" alt="image-20220913233114057"></p>
<p><strong>一地址指令</strong></p>
<p>一地址指令就是自己对自己操作，最终把自己写入当前地址。常见的有自增、自减操作等。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913233210844.png" alt="image-20220913233210844"></p>
<p><strong>零地址指令</strong></p>
<p>零地址指令指没有地址码部分的机器指令。通过是一些不需要操作数据的指令，比如空操作、停机操作、中断返回操作等。</p>
<h2 id="机器指令的操作类型"><a href="#机器指令的操作类型" class="headerlink" title="机器指令的操作类型"></a>机器指令的操作类型</h2><h3 id="数据传输："><a href="#数据传输：" class="headerlink" title="数据传输："></a>数据传输：</h3><ul>
<li>数据传输发生在寄存器之间、寄存器与存储单元之间、存储单元之间<ul>
<li>存储单元包括：高速缓存、主存、辅存等一系列硬件设施，</li>
</ul>
</li>
<li>数据传输包括：数据读写、交换地址数据、清零置一等操作</li>
</ul>
<h3 id="算术逻辑操作"><a href="#算术逻辑操作" class="headerlink" title="算术逻辑操作"></a>算术逻辑操作</h3><ul>
<li>操作数之间的加减乘除运算</li>
<li>操作数的与或非等逻辑位运算</li>
</ul>
<h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><ul>
<li>数据左移（乘2）</li>
<li>数据右移（除2）</li>
</ul>
<h3 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h3><p>控制指令主要包括：等待指令、停机指令、空操作指令、中断指令等</p>
<h2 id="机器指令的寻址方式"><a href="#机器指令的寻址方式" class="headerlink" title="机器指令的寻址方式"></a>机器指令的寻址方式</h2><p>机器指令是怎样找到相关数据的！</p>
<p>首先要找到如何操作数据的指令，接着要找到待操作的数据。</p>
<h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><ul>
<li><p><strong>顺序寻址</strong></p>
</li>
<li><p><strong>跳跃寻址</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220913235659272.png" alt="image-20220913235659272"></p>
<p>以上图为例，指令101~105是按顺序执行的，这就叫做顺序寻址；但是地址105的指令内容是跳到102地址，这就是一个跳跃寻址。</p>
<h3 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h3><ul>
<li>立即寻址</li>
<li>直接寻址</li>
<li>间接寻址</li>
</ul>
<p><strong>立即寻址</strong></p>
<p>通过指令可以直接获得操作数的方式叫<strong>立即寻址</strong>，也就是说，在指令的地址码部分直接包含了需要操作的数据。这种情况下，运行指令的时候就无需访问存储器，直接从指令中获得操作数即可。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914000224896.png" alt="image-20220914000224896"></p>
<p><strong>直接寻址</strong></p>
<p>直接寻址是指，机器指令的地址码部分直接给出了操作数在主存中的地址，直接通过这个地址就可以访问到操作数，无需计算操作数的地址。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914000615931.png" alt="image-20220914000615931"></p>
<p><strong>间接寻址</strong></p>
<p>间接寻址是指指令中的地址码给出的是操作数地址的地址，我们需要访问一次或多次主存来获取操作数。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914000758266.png" alt="image-20220914000758266"></p>
<p><strong>三种寻址方式的比较</strong></p>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>立即寻址</td>
<td>速度快</td>
<td>地址码位数限制操作数表示范围</td>
</tr>
<tr>
<td>直接寻址</td>
<td>寻找操作数简单</td>
<td>地址码位数限制操作数寻址范围</td>
</tr>
<tr>
<td>间接寻址</td>
<td>操作数寻址范围大</td>
<td>速度较慢</td>
</tr>
</tbody></table>
<h1 id="计算机的控制器（CPU组件之一）"><a href="#计算机的控制器（CPU组件之一）" class="headerlink" title="计算机的控制器（CPU组件之一）"></a>计算机的控制器（CPU组件之一）</h1><p>计算机的控制器是协调和控制计算机运行的。</p>
<p>计算机的控制器主要包含以下组件：</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914234102144.png" alt="image-20220914234102144"></p>
<p><strong>程序计数器</strong>：</p>
<p>程序计数器用于存储下一条要执行的指令的地址。当CPU工作时，会循环不断地从程序计数器中拿出指令的地址，进而找打指令并执行，当这个地址被拿出时，程序计数器会指向下一条指令的地址。</p>
<p>所以说，程序计数器是用于提供给其它控制单元，当前要执行的指令的地址的。</p>
<p><strong>时序发生器</strong></p>
<ul>
<li>电气工程领域，用于发送时序脉冲。</li>
<li>CPU依据不同的时序脉冲有节奏的进行工作。</li>
</ul>
<p><strong>指令译码器</strong></p>
<ul>
<li>指令译码器是控制器的主要部件之一。</li>
<li>前面我们讲过了，计算机指令由操作码和地址码两部分组成。</li>
<li>指令译码器的工作就是将操作码或地址码翻译成对应的操作，以及控制传输地址码对应的数据。</li>
</ul>
<p><strong>指令寄存器</strong></p>
<ul>
<li>指令寄存器也是控制器的主要部件之一</li>
<li>它的作用是从主存或者高速缓存中取计算机指令，这样CPU就可以直接从指令寄存器中拿到指令并运算了，速度更快。</li>
</ul>
<p><strong>主存地址寄存器</strong></p>
<ul>
<li>保存当前CPU正要访问的内存单元的地址</li>
<li>使用地址总线与主存通信。</li>
</ul>
<p><strong>主存数据寄存器</strong></p>
<ul>
<li>保存当前CPU正要读或者些的主存数据</li>
<li>使用数据总线与主存通信。</li>
</ul>
<p><strong>通用寄存器</strong></p>
<ul>
<li>用于暂时存放或传送数据或指令</li>
<li>可保存ALU运算的中间结果</li>
<li>容量比一般专用寄存器要大</li>
</ul>
<h1 id="计算机的运算器（CPU组件之一）"><a href="#计算机的运算器（CPU组件之一）" class="headerlink" title="计算机的运算器（CPU组件之一）"></a>计算机的运算器（CPU组件之一）</h1><p>运算器使用来进行数据运算加工的。</p>
<p>主要由数据缓冲器、ALU、通用寄存器、状态字寄存器组成。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220914235904462.png" alt="image-20220914235904462"></p>
<p><strong>数据缓冲器</strong>：数据缓冲器分为输入缓冲和输出缓冲。输入缓冲用于暂时存放外设传送过来的数据；输出缓冲用于暂时存放发往外设的数据。也就是说，ALU在运算时下一个数据是从缓冲区中获取的，同样，ALU在运算完毕时会先将数据保存在输出缓冲中，等待控制器下一步的命令，把它送到相应的位置。</p>
<p><strong>ALU</strong></p>
<ul>
<li>ALU：算术逻辑单元，是运算器的重要组成部分</li>
<li>可以完成常见的位运算（左右位移、与或非等）</li>
<li>完成算术运算（加减乘除）</li>
</ul>
<p><strong>状态字寄存器</strong></p>
<p>状态寄存器主要存放一些运算中的状态，比如：条件码、进位、溢出、结果正负等；</p>
<p>同时它也可以存放一些运算控制信息（比如调试跟踪标记位、允许中断位等）</p>
<p><strong>通用寄存器</strong></p>
<ul>
<li>用于暂时存放或传送数据或指令</li>
<li>可以保存ALU的运算中间结果</li>
<li>容量一般比专用寄存器要大</li>
</ul>
<h1 id="计算机指令的执行过程"><a href="#计算机指令的执行过程" class="headerlink" title="计算机指令的执行过程"></a>计算机指令的执行过程</h1><h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p>整体来说，指令执行的过程可分为3步：<code>取指令 -&gt; 分析指令 -&gt; 执行指令</code></p>
<p>指令执行过程中涉及到的一些设备：</p>
<ul>
<li>数据缓存器</li>
<li>指令缓存器</li>
<li>运算器（ALU）</li>
<li>寄存器<ul>
<li>数据缓存器</li>
<li>状态字寄存器</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20220915001916422.png" alt="image-20220915001916422"></p>
<h2 id="CPU的流水线设计"><a href="#CPU的流水线设计" class="headerlink" title="CPU的流水线设计"></a>CPU的流水线设计</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/10/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/10/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">git常用操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-10 15:09:16" itemprop="dateCreated datePublished" datetime="2022-09-10T15:09:16+08:00">2022-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-09-11 22:13:35" itemprop="dateModified" datetime="2022-09-11T22:13:35+08:00">2022-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="暂存区的作用"><a href="#暂存区的作用" class="headerlink" title="暂存区的作用"></a>暂存区的作用</h2><p>暂存区的作用：暂时存放，还没有作为一个正式提交的版本。但是暂存区中的文件已经被git管理了，暂存区中的文件可以很容易地被git变成一次正式的提交；同时，它又可以回退，用暂存区的文件覆盖工作目录的文件，在实际开发中还是很有使用价值的。</p>
<ol>
<li>在工作目录中执行修改操作引发的变更，可以先添加到暂存区；</li>
<li>然后再在工作目录中尝试使用另外一套解决方案，假如第二套方案没有第一套方案好的话，就可以用暂存区的第一套方案覆盖工作目录。</li>
</ol>
<h2 id="通过几次commit来认识工作区和暂存区"><a href="#通过几次commit来认识工作区和暂存区" class="headerlink" title="通过几次commit来认识工作区和暂存区"></a>通过几次commit来认识工作区和暂存区</h2><blockquote>
<p>大纲：4次提交</p>
<ul>
<li>第一次提交：加入 index.html 和 git-logo 图片</li>
<li>第二次提交：加入 style.css</li>
<li>第三次提交：加入 script.js</li>
<li>第四次提交：修改 index.html</li>
</ul>
</blockquote>
<p><strong>git status 查看工作目录和暂存区的状态</strong></p>
<ol>
<li><p>初始化一个 Git 项目，命名为 git-learning</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Git init <span class="string">&quot;git-learning&quot;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>向仓库中添加 <code>index.html</code> 和 <code>images/git-logo</code> 图片文件</p>
</li>
<li><p>通过 <code>git status</code> 查看工作目录和暂存区的状态</p>
<p> <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910152842936.png" alt="image-20220910152842936"></p>
<ul>
<li>当前处于 master 分支；</li>
<li>还没有提交（commit）过；</li>
<li>git还没有管理下列文件，可以使用 <code>git add</code> 命令可以将下列文件加入到暂存区，以便于将来可以被提交（commit）；</li>
<li>没有添加任何提交，存在未被跟踪的文件，可以使用 <code>git add</code> 进行跟踪。</li>
</ul>
</li>
<li><p>将上面的文件及文件夹加入暂存区，纳入Git的管理，重新查看工作目录和暂存区的状态</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add index.html images/git-logo.png</span><br><span class="line">$ git status</span><br></pre></td></tr></table></figure>

<p> <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910153545186.png" alt="image-20220910153545186"></p>
<ul>
<li>暂存区的下列变化处于待提交状态，可以被commit</li>
</ul>
</li>
<li><p>为上面的变更执行一次正式的提交，并查看工作目录及暂存区状态</p>
<p> <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910154004923.png" alt="image-20220910154004923"></p>
</li>
<li><p>使用 <code>git log</code> 查看提交（commit）日志</p>
<p> <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910154104422.png" alt="image-20220910154104422"></p>
</li>
<li><p>考虑到页面太简陋了，我们可以新添加一个 css 文件：<code>styles/style.css</code></p>
<ul>
<li>使用 <code>git status</code> 查看状态</li>
<li>将 css 文件添加到暂存区</li>
<li>提交</li>
<li>查看提交日志</li>
</ul>
<p> <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910154623103.png" alt="image-20220910154623103"></p>
</li>
<li><p>添加js文件实现动画效果<code>js/script.js</code></p>
<ul>
<li>使用 <code>git status</code> 查看状态</li>
<li>将 css 文件添加到暂存区</li>
<li>提交</li>
<li>查看提交日志</li>
</ul>
</li>
<li><p>修改 index.html，声明参考文件的信息。</p>
<ul>
<li><p>查看工作区和暂存区状态</p>
<p>  <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910155226183.png" alt="image-20220910155226183"></p>
</li>
<li><p>将变更添加到暂存区：<strong>git add -u：对于已经被 Git 管理的文件，可以使用 git add -u 将这些文件添加到暂存区，无需挨个添加文件到暂存区</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -u</span><br></pre></td></tr></table></figure></li>
<li><p>提交</p>
</li>
<li><p>查看提交日志</p>
</li>
</ul>
<p> <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910155819134.png" alt="image-20220910155819134"></p>
</li>
</ol>
<p><strong>经验：</strong>不应该将全部的文件都被Git管理，每次修改后，只需将要被管理的文件加入暂存区，等到觉得可以达到一次提交的程度，将暂存区的文件一次性提交到git仓库即可。</p>
<h2 id="给文件重命名的简便方法"><a href="#给文件重命名的简便方法" class="headerlink" title="给文件重命名的简便方法"></a>给文件重命名的简便方法</h2><h3 id="复杂方法："><a href="#复杂方法：" class="headerlink" title="复杂方法："></a>复杂方法：</h3><p>给文件重命名的复杂方法：</p>
<ol>
<li>在工作目录给文件重命名；</li>
<li>将重命名的文件提交到暂存区；</li>
<li>将暂存区的文件提交到git本地仓库</li>
</ol>
<p>我们先让git仓库管理一个 readme 文件。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910160602002.png" alt="image-20220910160602002"></p>
<p>然后使用这种复杂的方式将 readme 重命名为 <code>readme.md</code></p>
<ol>
<li><p>在工作目录将 readme 重命名为 <code>readme.md</code>，查看当前状态</p>
<p> <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910160803119.png" alt="image-20220910160803119"></p>
<p> 可以看到，对于 git 而言，它要求你：先将 readme 文件删除，然后将 readme.md 文件添加到暂存区。所以我们需要进行<strong>两个步骤</strong>：</p>
<ul>
<li>将 readme.md 添加到暂存区；</li>
<li>将 readme 从Git仓库中删除（如果不删除会影响后面的提交）</li>
</ul>
<p> <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910161235381.png" alt="image-20220910161235381"></p>
<p> 最终在暂存区表现出的状态是“重命名”：<code>readme -&gt; readme.md</code></p>
</li>
</ol>
<h3 id="简便方法："><a href="#简便方法：" class="headerlink" title="简便方法："></a>简便方法：</h3><p>好了，看完了“复杂方法”，我们再来看一种简单的方法。首先，我们可以将暂存区及工作目录上所有的变更都清理掉，撤回上一次提交的状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910161924272.png" alt="image-20220910161924272"></p>
<p>使用简洁的命令完成重命名操作</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910162111914.png" alt="image-20220910162111914"></p>
<p>提交</p>
<h2 id="通过git-log查看版本演变历史"><a href="#通过git-log查看版本演变历史" class="headerlink" title="通过git log查看版本演变历史"></a>通过git log查看版本演变历史</h2><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/631c49f41e085349e18bb085">https://www.processon.com/view/link/631c49f41e085349e18bb085</a></p>
<p>基于 master 分支的第二个版本创建一个 temp 分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b temp ee0dbd54ba13aef995</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910162840536.png" alt="image-20220910162840536"></p>
<p>在 tmep 分支进行一次 commit</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910163237014.png" alt="image-20220910163237014"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有分支的演进历史，并启用图形化功能</span></span><br><span class="line">$ git <span class="built_in">log</span> --all --graph --oneline</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220910163600623.png" alt="image-20220910163600623"></p>
<ul>
<li>前两次提交是公共的，从这之后开始分叉；</li>
<li>第三次、五次和六次提交属于 master 分支；</li>
<li>test 提交属于 temp 分支。</li>
</ul>
<h2 id="git目录"><a href="#git目录" class="headerlink" title=".git目录"></a>.git目录</h2><p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911001742494.png" alt="image-20220911001742494"></p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD 是一个文本文件，查看其内容为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> HEAD</span><br><span class="line">ref: refs/heads/temp</span><br></pre></td></tr></table></figure>

<p>ref 表示这是一个引用，引用指向的地址为 <code>refs/heads/temp</code>，去对应的地址中查看可知，HEAD指向的就是正在使用的分支，可以看到目前指向了 temp 分支。当然，如果你当前不在 temp 分支上，比如你在 master 分支上进行开发，HEAD 指向的就是 master 分支。如果你切换了分支，HEAD 的引用就会发生改变。实际上，我们手动去编辑 HEAD 文件内容，与执行 <code>check out</code> 切换分支的效果是一样的。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911002056285.png" alt="image-20220911002056285"></p>
<p>通过 git branch 命令查看当前工作在哪个分支上。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911003831557.png" alt="image-20220911003831557"></p>
<p>通过 git checkout 切换分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>







<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 也是一个文本文件（配置文件）,保存了当前git的一些配置信息。对于这些配置信息，我们既可以通过 git提供的一些简单命令进行修改（比如用户名和邮箱信息），也可以直接在配置文件上进行修改，最终效果都是一样的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> config</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = <span class="literal">false</span></span><br><span class="line">        bare = <span class="literal">false</span></span><br><span class="line">        logallrefupdates = <span class="literal">true</span></span><br><span class="line">        symlinks = <span class="literal">false</span></span><br><span class="line">        ignorecase = <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911003036152.png" alt="image-20220911003036152"></p>
<p>refs 目录下有 heads 和 tags 两个目录，复数意味着Git仓库是可以有很多 head 和 tag 的。</p>
<ul>
<li>tag 又叫做“里程碑”，比如我们的项目开发到了一个新的阶段，需要的当前的成功进行发版，比如 V1.0，这时候可以对当前最新的 commit 打上一个标识（tag）。但实际上，tag 引用的也是这次 commit 的 id。</li>
<li>heads 对应着我们的许多分支，分支就是独立的开发空间，对于一个人来说，比如我们开发前后端分离的项目，我们可以为前端建立一个分支，为后端建立一个分支，两个分支相互独立开发。对于多人协作开发来说，每个人可以在自己独立的分支上进行代码开发，开发完毕后将所有的分支合并到主分支上，避免开发过程中频繁冲突的问题。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911002056285.png" alt="image-20220911002056285"></p>
<p>实际上，不管是 heads 还是 tags 中，保存的都是一些文件。对于 heads/xx，xx指向的是xx分支下最新的一次commit id，对于 tags/xx，xx 指向的是发布 tag 那一次的 commit id。</p>
<p>我们可以进入这两个文件夹看一下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ./refs/heads/master</span><br><span class="line">c646c8437e51ef484391dc69d3302bac92c5b5a2</span><br></pre></td></tr></table></figure>

<p>可以看到 master 是一个文件，它指向当前分支最近一次提交（commit）的id；同理，tags 下面的文件也是 tag 的提交名称，这个名称的内容是 tag 提交（commit）时的 id。</p>
<p>我们来具体看一下这个 id 的类型，可以看到它确实是一个 commit 类型。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911005239122.png" alt="image-20220911005239122"></p>
<h3 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h3><p>objects 中都是一些目录。可以看到有非常多的文件夹，一个比较特殊的文件夹是 <strong>pack</strong>，pack 的作用就是整理，当 objects 中文件夹的数量太多时，Git 就会进行自我梳理，将一些前缀一样的文件打包整理到 pack 中</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911005735914.png" alt="image-20220911005735914"></p>
<p>以文件夹 e6 为例，这里面存放的都是以 “e6” 开头的 object，我们通过拼接 “e6” 与文件夹内的子文件夹名称，可以得到一个完成的 id，根据这个 id 可以查看对应的 object 类型。比如下面我们就查出了两种类型 <strong>commit</strong> 和 <strong>blob</strong>，实际上 Git 中还有类型为 <strong>tree</strong> 的 object。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911010601184.png" alt="image-20220911010601184"></p>
<p>object 可以近似地理解为 Java 中的 Object，Git 中任何东西都可以称为 object。比如一次 commit 是一个 object，一个分支（head）是一个 object，一个 tag 是一个 object。</p>
<hr>
<h2 id="commit、tree和blob三个对象之间的关系"><a href="#commit、tree和blob三个对象之间的关系" class="headerlink" title="commit、tree和blob三个对象之间的关系"></a>commit、tree和blob三个对象之间的关系</h2><p>Git对象彼此关系</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911011805031.png" alt="image-20220911011805031"></p>
<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>每一次执行 git commit 命令都会创建一个 commit 对象。一个 commit 一定会对应于一棵树（tree）。</p>
<p>这棵树表示这次 commit 后得到的当前项目所有文件夹及文件的快照视图。</p>
<h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>在 tree 对象中，我们还可以看到子 tree 对象，表示文件夹，对应的，blob 对象表示文件。</p>
<h3 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h3><p>文件内容。</p>
<p>注意的一点是：blob 与文件名没有一点儿关系。只要文件的内容相同，那么 Git 就会将其视为一个 blob。所以对于一些名字不同而内容相同的文件，Git 不会对内容进行重复存储，只需要将这两个文件名指向同一个 blob 即可。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>接下来，我们通过具体操作对上面的理论进行测试。</p>
<ol>
<li>查看当前所处的分支，并选定某一次 commit 进行测试，这里选择第六次提交这个分支吧。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911013408226.png" alt="image-20220911013408226"></p>
<ol start="2">
<li><p>查看 commit 对象的内容</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p c646c8437e51ef484391dc69d</span><br></pre></td></tr></table></figure></li>
<li><p>在 commit 对象中找到 tree 的 id 继续查看 tree 内容</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 111c8fce9c06a90c640</span><br></pre></td></tr></table></figure></li>
<li><p>在 tree 对象中找到 blob 的 id 继续查看 blob 的内容</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 6ad4c68d567a1a5b415dcfce2010</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911013835531.png" alt="image-20220911013835531"></p>
<ol start="5">
<li>返回上一步，查看最外层 tree 对象下的 tree 对象的内容。发现 tree 下面继续是一个 blob 对象。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911014148594.png" alt="image-20220911014148594"></p>
<hr>
<h2 id="小练习：数一数tree的个数"><a href="#小练习：数一数tree的个数" class="headerlink" title="小练习：数一数tree的个数"></a>小练习：数一数tree的个数</h2><p>TODO</p>
<h2 id="分离头指针情况下的注意事项"><a href="#分离头指针情况下的注意事项" class="headerlink" title="分离头指针情况下的注意事项"></a>分离头指针情况下的注意事项</h2><h3 id="什么是分离头指针？"><a href="#什么是分离头指针？" class="headerlink" title="什么是分离头指针？"></a>什么是分离头指针？</h3><p>分离头指针：<strong>HEAD指针与分支分离</strong>。commit没有基于某个分支（branch），这就会造成 HEAD 不与分支绑定，这种情况就叫做“分离头指针”。</p>
<h3 id="分离头指针的使用场景"><a href="#分离头指针的使用场景" class="headerlink" title="分离头指针的使用场景"></a>分离头指针的使用场景</h3><p>通常情况下，我们都会使用 <code>git checkout 分支名称</code> 命令来进行分支间的切换，但是 checkout 后面不光可以跟分支名称，还可以是某次 commit 的 id 号，比如下面这样，我们使用“第二次提交”的 commit id 作为 checkout 的目的地。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ee0dbd54ba13aef995ec7</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911195110717.png" alt="image-20220911195110717"></p>
<p>与正常切换分支不同的是，这次切换我们可以看到一大段的建议信息，大意如下：</p>
<blockquote>
<ul>
<li>你现在正处于“分离头指针”状态下，你可以在这个状态下进行一些实验性的修改，如果你觉得实验结果好的话，可以提交这些修改，如果觉得实验结果不好的话，可以放弃在这个状态下进行的任何提交。通过切换回现存的某个分支来放弃这些修改。</li>
<li>如果你想保留你在这个状态下的提交，需要创建一个新的分支，你可以参考如下命令：</li>
</ul>
</blockquote>
<p>给它一个使用场景就是：我们现在想基于某一个 commit 进行实验性的开发，那么就可以进入“分离头指针”状态，在一个没有分支的状态下工作，在这个状态下进行试验开发并提交代码。如果试验的结果不理想，你不想要这些测试代码了，那么你可以直接切回到一个现有的分支下（比如 master），你在 “detached HEAD” 状态下进行的所有开发都会在不远的将来的某一时间被 Git 清理掉。</p>
<p>当然，如果你觉得这次试验很成功，那么一定不要忘了给 “detached HEAD” 绑定一个真正的分支，否则这些提交都会被 Git 当做无关紧要的 commit 而丢弃掉。</p>
<h3 id="分离头指针的使用案例"><a href="#分离头指针的使用案例" class="headerlink" title="分离头指针的使用案例"></a>分离头指针的使用案例</h3><p>通过前面一系列工作，我们现在已经处于 “detached HEAD” 状态，当前数据是基于“第二次提交”这个分支。我们现在修改 css 文件，将其中的某个参数的颜色改为 green，然后通过 git status 查看工作区与暂存区的状态。可以看到Git已经识别出了，当前处于分离头指针状态，并且对应于某一个 commit。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911202518833.png" alt="image-20220911202518833"></p>
<p>继续 commit 这次修改，并查看 log 状态。可以看到，在 log 中，HEAD 指针并没有指向某个具体的分支，这与我们前面看到的是不一样的，正常的应该类似于 <code>HEAD -&gt; master</code>，这也是“分离头指针”名字的由来，即<strong>HEAD指针与分支分离</strong>。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911202703873.png" alt="image-20220911202703873"></p>
<p>我们查看所有分支上的 log 树可知，Git 并没有把 “detached HEAD” 状态下的提交当成一次正式提交，所以当切换到某个具体分支后，在 “detached HEAD” 状态下的提交都会在将来某个时间段被 Git 清理掉。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911202955357.png" alt="image-20220911202955357"></p>
<p>比如，我们在进行分支切换的时候，Git 也会提示你：如果需要的话，可以为 “detached HEAD” 状态下的提交创建一个新的分支。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911203328098.png" alt="image-20220911203328098"></p>
<p>我们可以先为其创建一个新的分支，然后重新查看所有分支的 log 记录，此时，“detached HEAD” 状态下的分支由于绑定了具体的分支，这些提交也就变成了有效提交，可以被永久保存。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911203352863.png" alt="image-20220911203352863"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你想进行一些尝试性的变更，可以在分离头指针的状态下进行，如果尝试的结果不理想，可以直接 checkout 到一个开发分支上，那么你在分离头指针状态下的变更会被自动回收。</p>
<p>当进行分支切换时，在分离头指针状态下产生的切换很可能会被Git当做垃圾回收掉，如果你认为这些变更是重要的，切记一定要将commit与分支进行绑定。</p>
<p>如果你想进行变更，请一定要跟某个分支关联。在分支的基础上，对分支进行变更。</p>
<hr>
<h2 id="进一步理解HEAD和branch"><a href="#进一步理解HEAD和branch" class="headerlink" title="进一步理解HEAD和branch"></a>进一步理解HEAD和branch</h2><p>HEAD 最终落脚的一定是某一个 commit。当前这个 commit 可以是在某个分支下的，也可以是与分支无关的。</p>
<p>HEAD 不仅可以指向当前分支的最近一次提交，同时 HEAD 也可以不与分支关联，当处于“分离头状态”下，HEAD 指向的就是某一次提交，不与任何分支关联。</p>
<p>Before：已有分支情况下，HEAD 和 branch 之间的关系</p>
<p>Now：新建分支的情况下，HEAD 和 branch 的关系</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在source的基础上创建并切换分支，source可以是某一个分支，也可以是某一次commit</span></span><br><span class="line">git checkout -b <span class="variable">$&#123;branch_name&#125;</span> <span class="variable">$&#123;source&#125;</span></span><br></pre></td></tr></table></figure>

<p>基于 fix_css 分支创建新的 fix_readme 分支。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911205651063.png" alt="image-20220911205651063"></p>
<p>查看 HEAD 指向的引用（最终一定是某一次 commit）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .git/HEAd</span><br><span class="line">ref: refs/heads/fix_readme</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .git/refs/heads/fix_readme</span><br><span class="line">a9773e93bd968e575a17b29c79f33529629273df</span><br></pre></td></tr></table></figure>







<h3 id="比较两个分支间的差异"><a href="#比较两个分支间的差异" class="headerlink" title="比较两个分支间的差异"></a>比较两个分支间的差异</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff commit_id1 commit_id2</span><br></pre></td></tr></table></figure>

<p>这里也可以使用 HEAD 及其衍生的关键字来代替 commit id。比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD HEAD~1</span><br></pre></td></tr></table></figure>

<p>因为 HEAD 指的是当前分支的最新版本，我们可以以此为基础，倒推出 HEAD 的前一个版本、前两个版本等等。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911210933363.png" alt="image-20220911210933363"></p>
<h3 id="HEAD的特殊标识符"><a href="#HEAD的特殊标识符" class="headerlink" title="HEAD的特殊标识符"></a>HEAD的特殊标识符</h3><p>几种常见的表示方式：</p>
<ul>
<li><code>HEAD~1</code>：HEAD 的上一个版本</li>
<li><code>HEAD~2</code>：HEAD 的前两个版本</li>
<li><code>HEAD^1</code>：等价于 <code>HEAD~1</code></li>
<li><code>HEAD^</code>：等价于 <code>HEAD^1</code></li>
<li><code>HEAD^^</code>：HEAD 的前两个版本，等价于 <code>HEAD~2</code></li>
</ul>
<h1 id="独自使用Git时的常见场景"><a href="#独自使用Git时的常见场景" class="headerlink" title="独自使用Git时的常见场景"></a>独自使用Git时的常见场景</h1><h2 id="怎么删除不需要的分支"><a href="#怎么删除不需要的分支" class="headerlink" title="怎么删除不需要的分支"></a>怎么删除不需要的分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名称</span><br><span class="line">git branch -D 分支名称</span><br></pre></td></tr></table></figure>

<p>如图所示，我们正处于 master 分支下，准备删除 <code>fix_readme</code> 分支，执行 <code>git branch -d fix_readme</code> 命令后出错，错误信息是：</p>
<blockquote>
<p>fix_readme 分支还没有被完全 merge 到主分支上，是否确认删除？如果确认删除，请执行<code>git branch -D fix_readme</code> 命令。</p>
</blockquote>
<p>这其实相当于“确认删除”的按钮，如果你非常确定就是要删除某一个分支，并不准备对其进行 merge，可以直接执行 <code>git branch -D</code> 来删除分支。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911214624907.png" alt="image-20220911214624907"></p>
<p><strong>注意事项</strong></p>
<p>删除分支前需要注意，不能在当前分支上删除当前分支。也就是说，比如你正处于 <code>fix_readme</code> 分支下，那么你是不能删除这个分支的，你必须切换到其它分支（比如master），然后才能删除 <code>fix_readme</code> 分支。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911214316309.png" alt="image-20220911214316309"></p>
<h2 id="怎么修改最新commit的Message？"><a href="#怎么修改最新commit的Message？" class="headerlink" title="怎么修改最新commit的Message？"></a>怎么修改最新commit的Message？</h2><p>查看 master 分支的 commit log 可知，我们的 commit message 没有“第四次提交”，这是因为我在提交的时候记岔了，那么现在我想要改变一下提交信息。首先，我们把最新的 commit message 由“第六次提交”改成“第五次提交”。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911215651915.png" alt="image-20220911215651915"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>输入这条命令后，会弹出一个可编辑的 vim 文本，直接修改即可。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911220149820.png" alt="image-20220911220149820"></p>
<p>修改完成后，重新查看 commit log。</p>
<p><img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/git/image-20220911220311588.png" alt="image-20220911220311588"></p>
<h2 id="怎么修改老旧commit的message？"><a href="#怎么修改老旧commit的message？" class="headerlink" title="怎么修改老旧commit的message？"></a>怎么修改老旧commit的message？</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i commit_id</span><br></pre></td></tr></table></figure>

<p>基于哪个 commit 变更</p>
<p>TODO</p>
<h2 id="怎样把连续的多个commit整理成1个？"><a href="#怎样把连续的多个commit整理成1个？" class="headerlink" title="怎样把连续的多个commit整理成1个？"></a>怎样把连续的多个commit整理成1个？</h2><p>TODO</p>
<h2 id="怎么比较暂存区和HEAD所含文件的差异？"><a href="#怎么比较暂存区和HEAD所含文件的差异？" class="headerlink" title="怎么比较暂存区和HEAD所含文件的差异？"></a>怎么比较暂存区和HEAD所含文件的差异？</h2><p>TODO</p>
<h2 id="怎么比较工作区和暂存区文件的差异？"><a href="#怎么比较工作区和暂存区文件的差异？" class="headerlink" title="怎么比较工作区和暂存区文件的差异？"></a>怎么比较工作区和暂存区文件的差异？</h2><h2 id="如何让暂存区恢复成和HEAD的一样？"><a href="#如何让暂存区恢复成和HEAD的一样？" class="headerlink" title="如何让暂存区恢复成和HEAD的一样？"></a>如何让暂存区恢复成和HEAD的一样？</h2><h2 id="如何让工作区的文件恢复成和暂存区的一样？"><a href="#如何让工作区的文件恢复成和暂存区的一样？" class="headerlink" title="如何让工作区的文件恢复成和暂存区的一样？"></a>如何让工作区的文件恢复成和暂存区的一样？</h2><h2 id="怎样取消暂存区部分文件的更改？"><a href="#怎样取消暂存区部分文件的更改？" class="headerlink" title="怎样取消暂存区部分文件的更改？"></a>怎样取消暂存区部分文件的更改？</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/ZooKeeper%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/14/ZooKeeper%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">ZooKeeper安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-14 18:49:52" itemprop="dateCreated datePublished" datetime="2022-08-14T18:49:52+08:00">2022-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-09-16 00:21:52" itemprop="dateModified" datetime="2022-09-16T00:21:52+08:00">2022-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ZooKeeper/" itemprop="url" rel="index"><span itemprop="name">ZooKeeper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="JDK-环境"><a href="#JDK-环境" class="headerlink" title="JDK 环境"></a>JDK 环境</h3><p>由于 ZooKeeper 是基于 Java 开发的，所以在安装 ZooKeeper 前必须保证当前计算机上已经安装了 JDK，并配置了 JAVA_HOME 环境变量。</p>
<h3 id="安装包选择"><a href="#安装包选择" class="headerlink" title="安装包选择"></a>安装包选择</h3><p><strong>问题描述：</strong> 在安装 <code>zookeeper-3.5.7</code> 时，已经在 <code>conf</code> 文件夹下拷贝并重命名了一份 <code>zoo.cfg</code> 文件，结果在执行 <code>bin</code> 目录下的 <code>zkServer.sh</code> 脚本时依然启动失败，查看日志中的错误信息，提示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找不到或无法加载主类 org.apache.zookeeper.server.quorum.QuorumPeerMain</span><br></pre></td></tr></table></figure>

<p><strong>原因分析：</strong></p>
<ul>
<li>使用的是未编译的 jar 包。</li>
<li>注：ZooKeeper 从 3.5 版本开始，命名就发生了改变，如果是 <code>apache-zookeeper-3.5.5.tar.gz</code> 这种命名的，都是未编译的，而 <code>apache-zookeeper-3.5.5-bin.tar.gz</code> 这种命名的，才是已编译的包。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>重新下载 <code>apache-zookeeper-3.5.5-bin.tar.gz</code> 包，然后解压使用。</li>
</ul>
<h2 id="单节点ZK安装部署"><a href="#单节点ZK安装部署" class="headerlink" title="单节点ZK安装部署"></a>单节点ZK安装部署</h2><ol>
<li><p>首先你需要下载ZooKeeper的安装包。如果你在本地直接有这个安装包，可以调到第4步。</p>
</li>
<li><p>去ZooKeeper官网找某一版本的下载链接，使用 <code>wget</code>命令进行下载。wget默认会把文件下载到当前路径下，你可以根据需求自行调整。</p>
</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/LvNengDong/pic-go/main/img/ZooKeeper/image-20220915234458103.png" alt="image-20220915234458103"></p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dlcdn.apache.org/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1-bin.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>如果没有安装 wget，可以先使用 <code>yum install -y wget</code> 下载 wget。</p>
</li>
<li><p>拷贝 ZooKeeper 安装包<code>（apache-zookeeper-3.5.7-bin-bin.tar.gz）</code>到 Linux 系统下的指定目录<code>(/opt/software)</code>中。</p>
</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 software]$ ll</span><br><span class="line">总用量 375040</span><br><span class="line">-rw-rw-r--. 1 lvnengdong lvnengdong   3130819 11月 30 11:09 apache-zookeeper-3.5.7-bin-bin.tar.gz    # ZooKeeper安装包</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将安装包解压到 <code>/opt/module</code> 目录下</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 software]$ tar -zxvf apache-zookeeper-3.5.7-bin-bin.tar.gz -C ../module/</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>ZooKeeper 目录简析</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin-bin]$ ll</span><br><span class="line">总用量 32</span><br><span class="line">drwxr-xr-x. 2 lvnengdong lvnengdong   232 2月  10 2020 bin   # 保存运行ZooKeeper的脚本文件</span><br><span class="line">drwxr-xr-x. 2 lvnengdong lvnengdong    77 2月   7 2020 conf  # 配置文件目录</span><br><span class="line">drwxr-xr-x. 5 lvnengdong lvnengdong  4096 2月  10 2020 docs</span><br><span class="line">drwxrwxr-x. 2 lvnengdong lvnengdong  4096 11月 30 12:02 lib</span><br><span class="line">-rw-r--r--. 1 lvnengdong lvnengdong 11358 9月  13 2018 LICENSE.txt</span><br><span class="line">-rw-r--r--. 1 lvnengdong lvnengdong   432 2月  10 2020 NOTICE.txt</span><br><span class="line">-rw-r--r--. 1 lvnengdong lvnengdong  1560 2月   7 2020 README.md</span><br><span class="line">-rw-r--r--. 1 lvnengdong lvnengdong  1347 2月   7 2020 README_packaging.txt</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>bin</code> 目录简析</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin-bin]$ ll bin</span><br><span class="line">总用量 56</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong  232 5月   4 2018 README.txt</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong 2067 2月   7 2020 zkCleanup.sh</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong 1158 2月  10 2020 zkCli.cmd</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong 1621 2月   7 2020 zkCli.sh   # 启动ZK客户端</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong 1766 2月   7 2020 zkEnv.cmd</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong 3690 1月  31 2020 zkEnv.sh</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong 1286 1月  31 2020 zkServer.cmd</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong 4573 2月   7 2020 zkServer-initialize.sh</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong 9386 2月   7 2020 zkServer.sh    # 启动ZK服务器端</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong  996 10月  3 2019 zkTxnLogToolkit.cmd</span><br><span class="line">-rwxr-xr-x. 1 lvnengdong lvnengdong 1385 2月   7 2020 zkTxnLogToolkit.sh</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>尝试启动 ZooKeeper 服务器端</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin-bin]$ bin/zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.5.7-bin/bin/../conf/zoo.cfg</span><br><span class="line">grep: /opt/module/apache-zookeeper-3.5.7-bin/bin/../conf/zoo.cfg: 没有那个文件或目录</span><br><span class="line">grep: /opt/module/apache-zookeeper-3.5.7-bin/bin/../conf/zoo.cfg: 没有那个文件或目录</span><br><span class="line">mkdir: 无法创建目录&quot;&quot;: 没有那个文件或目录</span><br><span class="line">Usage: bin/zkServer.sh [--config &lt;conf-dir&gt;] &#123;start|start-foreground|stop|restart|status|print-cmd&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异常分析：ZK 启动时要加载 <code>/conf/zoo.cfg</code> 配置文件，而我们当前的服务器上并没有创建这个配置文件，所以我们需要去创建这个配置文件。</li>
</ul>
<ol start="9">
<li>修改配置文件</li>
</ol>
<ul>
<li><p>在 <code>conf</code> 目录下有一个文件叫做 <code>zoo_sample.cfg</code>，这是一个配置文件的模板，我们可以复制其副本为 <code>zoo.cfg</code>，作为 ZK 启动时加载的配置文件，在这个基础上进行自定义修改。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ cd conf/</span><br><span class="line">[lvnengdong@hadoop102 conf]$ ll</span><br><span class="line">总用量 12</span><br><span class="line">-rw-r--r--. 1 lvnengdong lvnengdong  535 5月   4 2018 configuration.xsl</span><br><span class="line">-rw-r--r--. 1 lvnengdong lvnengdong 2712 2月   7 2020 log4j.properties</span><br><span class="line">-rw-r--r--. 1 lvnengdong lvnengdong  922 2月   7 2020 zoo_sample.cfg</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝配置文件</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 conf]$ cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件 <code>zoo.cfg</code>【配置文件分析见下文】</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 conf]$ vim zoo.cfg</span><br><span class="line"></span><br><span class="line"># 修改 dataDir 属性为：</span><br><span class="line">dataDir=/opt/module/apache-zookeeper-3.5.7-bin-bin/data</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="10">
<li>创建 <code>/opt/module/apache-zookeeper-3.5.7-bin/data</code>目录</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ mkdir data</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>再次尝试启动 ZK</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ bin/zkServer.sh --help</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.5.7-bin/bin/../conf/zoo.cfg</span><br><span class="line">Usage: bin/zkServer.sh [--config &lt;conf-dir&gt;] &#123;start|start-foreground|stop|restart|status|print-cmd&#125;</span><br><span class="line"></span><br><span class="line"># 启动ZK</span><br><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin-bin]$ bin/zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.5.7-bin-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>查看是否启动成功</li>
</ol>
<ul>
<li><p>jps</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin-bin]$ jps</span><br><span class="line">80707 QuorumPeerMain</span><br></pre></td></tr></table></figure></li>
<li><p>执行 <code>zkServer.sh status</code> 脚本查看 ZK 的状态</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin-bin]$ bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.5.7-bin-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: standalone    # 单机模式</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ZK-配置文件分析"><a href="#ZK-配置文件分析" class="headerlink" title="ZK 配置文件分析"></a>ZK 配置文件分析</h2><p><strong>zoo.cfg</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># Zookeeper服务器与客户端的心跳间隔时间，单位毫秒。</span><br><span class="line"># 即默认每 2000ms 客户端与服务器端进行一次心跳</span><br><span class="line"># “心跳”是Zookeeper中使用的基本时间单位</span><br><span class="line">tickTime=2000</span><br><span class="line"></span><br><span class="line"># 集群中Follower与Leader第一次连接时能容忍的</span><br><span class="line"># 最大心跳次数（tickTime的数量），用于划定集群中</span><br><span class="line"># Follower机器连接Leader机器的。</span><br><span class="line"># 人话：也就是说ZK集群中的Follower在刚启动时需要从Leader中</span><br><span class="line"># 同步数据，同步数据耗时最长不能超过10次心跳（默认），</span><br><span class="line"># 如果超过了就抛出异常</span><br><span class="line">initLimit=10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 集群中Leader与Follower之间的最大响应时间单位，假如响应</span><br><span class="line"># 时间超过5次心跳，Leader就认为Follwer已经死掉了，就会从</span><br><span class="line"># 服务器列表中删除Follwer。</span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ZK集群保存数据的目录。</span><br><span class="line"># 建议不要使用 /tmp 目录，因为在Linux中临时文件目录会被定期清理</span><br><span class="line">dataDir=/tmp/zookeeper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ZK进程对外暴露的提供服务的端口号，也就是客户端连接时使用的端口。</span><br><span class="line">clientPort=2181</span><br><span class="line"></span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line"># 最大客户端连接数（需要使用时可以将注释放开）</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line"># 在 dataDir 目录中保留的不同版本的快照数量（需要使用时可以将注释放开）</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line"># 清除任务间隔时间(小时)</span><br><span class="line"># 设置为 “0” 表示禁用自动清除功能</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure>





<h2 id="分布式安装部署"><a href="#分布式安装部署" class="headerlink" title="分布式安装部署"></a>分布式安装部署</h2><h3 id="ZK-集群的特点"><a href="#ZK-集群的特点" class="headerlink" title="ZK 集群的特点"></a>ZK 集群的特点</h3><ol>
<li>ZK 集群中包含一个 Leader 和多个 Follower。Leader 负责发起投票和决议，更新系统状态；Follower 用于接收客户端请求并向客户端返回结果，在选举 Leader 的过程中参与投票。</li>
<li>ZK 集群实现了主从复制，但没有实现读写分离。</li>
<li>Follower 在掉线后，重新上线后首先需要同步数据。</li>
</ol>
<ol>
<li><p><strong>集群规划</strong></p>
<p> 在 hadoop102、hadoop103 和 hadoop104 三个节点上部署 Zookeeper。</p>
</li>
<li><p><strong>解压安装</strong></p>
<p> （1）解压 Zookeeper 安装包到 <code>/opt/module/</code> 目录下</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 software]$ tar -zxvf apache-zookeeper-3.5.7-bin -C /opt/module/</span><br></pre></td></tr></table></figure>

<p> （2）同步 <code>/opt/module/apache-zookeeper-3.5.7-bin</code> 目录内容到hadoop103、hadoop104</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ xsync /opt/module/apache-zookeeper-3.5.7-bin/</span><br><span class="line"># xsync是将某个文件分发到集群中所有机器上的脚本</span><br></pre></td></tr></table></figure></li>
<li><p><strong>配置服务器编号</strong></p>
<p> （1）在 <code>/opt/module/apache-zookeeper-3.5.7-bin/</code> 目录下创建 <code>data</code> 目录，并在该目录下创建一个 <code>myid</code> 文件</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ mkdir -p data</span><br><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ touch ./data/myid</span><br></pre></td></tr></table></figure>

<p> （2）编辑 <code>myid</code> 文件，在文件中添加当前服务器节点的编号（这个编号只是为了用于标识当前的服务器，可以是任意值，只要不重复即可）</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># myid文件的内容</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p> （3）拷贝配置好的 zookeeper 到其他机器上，并分别在hadoop103、hadoop104上修改 myid 文件中内容为3、4</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ xsync data/</span><br></pre></td></tr></table></figure></li>
<li><p><strong>配置zoo.cfg文件</strong></p>
<p> （1）重命名 <code>/opt/module/apache-zookeeper-3.5.7-bin/conf</code> 这个目录下的 <code>zoo_sample.cfg</code> 为 <code>zoo.cfg</code></p>
<p> （2）修改 <code>zoo.cfg</code> 文件</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1、修改数据存储路径配置</span><br><span class="line">dataDir=/opt/module/apache-zookeeper-3.5.7-bin/data</span><br><span class="line"></span><br><span class="line"># 2、增加如下配置</span><br><span class="line">#######################cluster##########################</span><br><span class="line">server.2=hadoop102:2888:3888</span><br><span class="line">server.3=hadoop103:2888:3888</span><br><span class="line">server.4=hadoop104:2888:3888</span><br></pre></td></tr></table></figure>

<p> （3）同步zoo.cfg配置文件</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ xsync ./conf/zoo.cfg</span><br></pre></td></tr></table></figure>

<p> （4）配置参数解读</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.A=B:C:D</span><br></pre></td></tr></table></figure>

<ul>
<li>A 是一个数字，表示服务器编号，即当前服务器是第几号服务器。集群模式下配置一个文件 <code>myid</code>，这个文件在 <code>dataDir</code> 目录下，这个文件里面有一个数据就是 A 的值，Zookeeper 启动时读取此文件，拿到服务器编号与 <code>zoo.cfg</code> 里面的配置信息比较，从而判断当前服务器的相关信息。</li>
<li>B 是当前服务器的地址。</li>
<li>C 是当前服务器与集群中的 Leader 进行数据交换时使用的端口。</li>
<li>D 是万一集群中的 Leader 服务器挂了，那么 C 就无法继续使用了，这时需要一个端口来进行重新选举新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</li>
</ul>
</li>
<li><p><strong>集群操作</strong></p>
<p> （1）分别启动三个节点上的 ZooKeeper</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ bin/zkServer.sh start</span><br><span class="line">[lvnengdong@hadoop103 apache-zookeeper-3.5.7-bin]$ bin/zkServer.sh start</span><br><span class="line">[lvnengdong@hadoop104 apache-zookeeper-3.5.7-bin]$ bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<p> （2）查看ZK线程状态</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ xcall jps</span><br><span class="line">要执行的命令是jps</span><br><span class="line">---------------------hadoop102-----------------</span><br><span class="line">70690 Jps</span><br><span class="line">73576 QuorumPeerMain</span><br><span class="line">---------------------hadoop103-----------------</span><br><span class="line">116029 Jps</span><br><span class="line">115086 QuorumPeerMain</span><br><span class="line">---------------------hadoop104-----------------</span><br><span class="line">110019 Jps</span><br><span class="line">109931 QuorumPeerMain</span><br></pre></td></tr></table></figure>

<p> （3）查看 ZK 集群状态</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop104 apache-zookeeper-3.5.7-bin]$ bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.5.7-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: leader    # hadoop104节点被选举为leader</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[lvnengdong@hadoop103 apache-zookeeper-3.5.7-bin]$ bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.5.7-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: follower  # hadoop103和102节点都是follower</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[lvnengdong@hadoop102 apache-zookeeper-3.5.7-bin]$ bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.5.7-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/24/CentOS%E6%B1%89%E5%8C%96%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/24/CentOS%E6%B1%89%E5%8C%96%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">CentOS汉化相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-24 18:15:50 / Modified: 18:28:47" itemprop="dateCreated datePublished" datetime="2022-07-24T18:15:50+08:00">2022-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="CentOS7修改中文显示"><a href="#CentOS7修改中文显示" class="headerlink" title="CentOS7修改中文显示"></a>CentOS7修改中文显示</h2><ol>
<li><p>首先查看自己当前使用的语言包</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$LANG</span></span><br><span class="line">en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p> 可以看出为 en_US，即英文。</p>
</li>
<li><p>安装最新的语言包</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install kde-l10n-Chinese</span><br></pre></td></tr></table></figure></li>
<li><p>查看中文语言包是否存在</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">locale -a | grep zh_CN</span><br><span class="line">zh_CN</span><br><span class="line">zh_CN.gb18030</span><br><span class="line">zh_CN.gb2312</span><br><span class="line">zh_CN.gbk</span><br><span class="line">zh_CN.utf8</span><br></pre></td></tr></table></figure>

</li>
<li><p>临时修改语言包</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANG=<span class="string">&quot;zh_CN.UTF-8&quot;</span>    <span class="comment"># 修改为中文</span></span><br><span class="line">LANG=<span class="string">&quot;en_US.UTF-8&quot;</span>    <span class="comment"># 修改为英文</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>永久修改需要配置 <code>/etc/locale.conf</code> 文件</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.conf </span><br></pre></td></tr></table></figure>

 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>

</li>
<li><p>重启生效</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 6</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="配置“那个男人”显示中文"><a href="#配置“那个男人”显示中文" class="headerlink" title="配置“那个男人”显示中文"></a>配置“那个男人”显示中文</h2><p>Linux 默认提供了三种万能的帮助命令：man，help，info。</p>
<p>man 是很有用的一个工具，但是对于很多英文水平有限的人来说学习起来有些困难，在此提供 CentOS7 安装中文版 man 的详细步骤。</p>
<ol>
<li><p>查找 man 中文安装包</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep man.*zh</span><br><span class="line">man-pages-zh-CN.noarch 1.5.2-4.el7 @base</span><br></pre></td></tr></table></figure>

<p> 由此可以找到以上安装包，如果找不到，执行 <code>yum -y update</code> 更新安装包。</p>
</li>
<li><p>执行安装命令</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install man-pages-zh-CN.noarch</span><br></pre></td></tr></table></figure>

</li>
<li><p>编辑配置文件使中文包生效</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bashrc</code> 文件在每个用户的『用户目录』下面，在命令上可以用 <code>～</code> 符号访问。</li>
<li>而且 bashrc 是个隐藏文件，需要加上一个 <code>.</code> 点号</li>
</ul>
</li>
<li><p>在 <code>bashrc</code> 中增加:</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> cman=‘man -M /usr//share/man/zh_CN’</span><br></pre></td></tr></table></figure></li>
<li><p>重载配置文件</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

</li>
<li><p>这样 man 命令就能使用中文帮助文档了，同样可以使用 cman。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/15/IDEA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/15/IDEA/" class="post-title-link" itemprop="url">IDEA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-15 22:28:31 / Modified: 22:57:51" itemprop="dateCreated datePublished" datetime="2022-07-15T22:28:31+08:00">2022-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">开发工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IDEA界面介绍"><a href="#IDEA界面介绍" class="headerlink" title="IDEA界面介绍"></a>IDEA界面介绍</h1><p>界面介绍</p>
<p>工具窗口切换</p>
<p>添加标记标签断点记录</p>
<h1 id="单文件编辑"><a href="#单文件编辑" class="headerlink" title="单文件编辑"></a>单文件编辑</h1><h1 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h1><h1 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h1><ul>
<li><p>添加断点    ctrl+ F8</p>
</li>
<li><p>单步运行（step over）在当前类中一行一行执行代码，不进入方法内部。  F8</p>
</li>
<li><p>从一个断点跳到下一个断点（F9）</p>
</li>
<li><p>查看所有断点 <code>ctrl+shift+F8</code></p>
</li>
<li><p>禁用所有断点 </p>
</li>
<li><p>表达式求值</p>
<ul>
<li>表达式求值不会影响到后面程序的执行</li>
</ul>
</li>
</ul>
<p><img src="/2022/07/15/IDEA/image-20220715225504958.png" alt="image-20220715225504958"></p>
<h1 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h1><h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/27/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/27/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC/" class="post-title-link" itemprop="url">网络数据在内核中如何流转?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-27 22:58:51" itemprop="dateCreated datePublished" datetime="2022-06-27T22:58:51+08:00">2022-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-28 00:28:57" itemprop="dateModified" datetime="2022-06-28T00:28:57+08:00">2022-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">理论基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一次具体的网络数据收发过程"><a href="#一次具体的网络数据收发过程" class="headerlink" title="一次具体的网络数据收发过程"></a>一次具体的网络数据收发过程</h2><h3 id="应用程序通过网络发送数据总览"><a href="#应用程序通过网络发送数据总览" class="headerlink" title="应用程序通过网络发送数据总览"></a>应用程序通过网络发送数据总览</h3><p>首先应用程序会准备好数据，使用用户态下的库函数（比如调用Java的 NIO 的 Socket API 中的 write 方法）去调用“系统调用”，接着调用系统的 API 接口函数，进入内核态。。</p>
<blockquote>
<p>用户态下的库函数不能直接操作一些权限等级较高的内核操作，只能通过发送系统调用，让系统调用代为处理。</p>
</blockquote>
<p>内核态对应的系统服务函数会复制应用程序进程中的数据到内核的内存空间中，然后将数据移交给网络协议栈，在网络协议栈中将数据层层打包。</p>
<p>最后，包装好的数据会交给网卡驱动，网卡驱动程序负责将打包好的数据写入网卡并让其发送出去。</p>
<p>其一般流程图如下所示：</p>
<img src="/2022/06/27/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC/dcb38fc1c0eef666eb1496cbf97a82bc.jpg" alt="img" style="zoom: 25%;">



<h3 id="接收过程总览"><a href="#接收过程总览" class="headerlink" title="接收过程总览"></a>接收过程总览</h3><p>接收数据就是发送数据的逆过程。</p>
<p>首先，网卡接收到数据，通过 DMA 复制到指定的内存；接着发送中断，用于通知网卡驱动结束复制数据。然后网络协议接收到网卡驱动传过来的数据，层层解包，获取真正的有效数据。最后，这个数据会发送给用户态监听的应用进程。</p>
<img src="/2022/06/27/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC/8a726909f0a19ff1683e541d3712b4dd.jpg" alt="img" style="zoom:25%;">





<hr>
<h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>Internet 套接字是 TCP/IP 协议栈中传输层协议的接口，也是传输层以上所有协议的实现。</p>
<p>在 Linux</p>
<p>也就是说，HTTP 数据必须先封装到 Socket 结构的数据，才能继续包装成 TCP 数据包。 </p>
<p>你在A镇，想给在B镇的老婆捎句话。但是A镇和B镇太远了，于是你就想着打电话。[想要进行网络通信]</p>
<p>但是电话只有镇长家才有，镇长是上流社会的，你又不认识镇长。[用户态无法操作内核态]</p>
<p>镇长有一个司机，[内核态Socket]</p>
<p>这个司机的老婆是你的邻居，[用户态Socket]</p>
<p>你们非常熟，</p>
<p>于是，你拜托司机的老婆，把你要给自己老婆说的话写在纸上来给她[数据-&gt;用户态Socket]</p>
<p>司机的老婆又跟司机说了这个事儿[用户态Socket-&gt;内核态Socket]</p>
<p>司机最后跟镇长说了这个事，</p>
<p>镇长也是个热心肠的人，拿着你的信一字一句的打电话到B镇镇长家里；[TCP网络通信]</p>
<p>B镇镇长又一层层把消息最终传给你的老婆。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/27/%E8%BE%93%E5%85%A5URL%EF%BC%8C%E4%BB%8E%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%88%B0%E5%93%8D%E5%BA%94%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/27/%E8%BE%93%E5%85%A5URL%EF%BC%8C%E4%BB%8E%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%88%B0%E5%93%8D%E5%BA%94%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%EF%BC%9F/" class="post-title-link" itemprop="url">输入URL，从一个请求到响应都发生了什么事？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-27 21:12:20 / Modified: 22:59:22" itemprop="dateCreated datePublished" datetime="2022-06-27T21:12:20+08:00">2022-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">理论基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="输入URL，从一个请求到响应都发生了什么事？"><a href="#输入URL，从一个请求到响应都发生了什么事？" class="headerlink" title="输入URL，从一个请求到响应都发生了什么事？"></a>输入URL，从一个请求到响应都发生了什么事？</h1><h2 id="全局概览"><a href="#全局概览" class="headerlink" title="全局概览"></a>全局概览</h2><ol>
<li><p>常规的网络交互过程是从客户端发起网络请求，用户态的应用程序（比如浏览器）会生成 HTTP 请求报文，并通过 DNS 协议查找到对应的远端 IP 地址。</p>
<blockquote>
<p>如果我们使用的是</p>
</blockquote>
</li>
<li><p>在<strong>套接字生成之后</strong>进入内核态，浏览器会委托操作系统内核去通知网络协议栈中的上半部分，也就是 TCP/UDP 协议发起连接请求。</p>
</li>
<li><p>然后经由网络协议栈的下半部分 <strong>IP 协议进行包装，使数据包具有远程定位能力</strong>。</p>
</li>
<li><p>经过 MAC 层处理，找到接收方的 MAC 地址。</p>
</li>
<li><p>最终数据包再经过网卡转化成电信号，电信号经过交换机、路由器发送到服务端，服务端经过处理拿到数据，再通过各种网络协议把数据响应给客户端。</p>
</li>
<li><p>客户端拿到数据进行渲染。</p>
</li>
<li><p>客户端和服务器端之间反复交换数据，客户端的页面数据就会发生变化。</p>
</li>
</ol>
<h2 id="发起请求阶段（应用层）"><a href="#发起请求阶段（应用层）" class="headerlink" title="发起请求阶段（应用层）"></a>发起请求阶段（应用层）</h2><p>应用层是多层网络结构中的最上层，也是我们能直接接触到的一层。</p>
<p>我们手机或电脑使用的软件都是在应用层实现的，包括浏览器、邮件应用、甚至于我们开发人员使用的IDE（比如我们通过IDE去访问远程服务器上的数据）。对于应用层来说，它只需要关注于为用户提供应用功能，不用去关注数据是如何传输的。</p>
<p>你可以理解为：<strong>应用层是工作在操作系统中的用户态</strong>。</p>
<h2 id="用户输入：在浏览器中输入URL"><a href="#用户输入：在浏览器中输入URL" class="headerlink" title="用户输入：在浏览器中输入URL"></a>用户输入：在浏览器中输入URL</h2><p>我们在浏览器中输入 URL 的过程中，浏览器就开始工作了。</p>
<p>首先，浏览器会根据我们的输入内容，匹配相似的 URL 及关键词，给出输入建议，同时校验 URL 的合法性，在你输入的 URL 前后补全这个 URL。</p>
<blockquote>
<p>比如，以我们输入 baidu.com 为例，首先，浏览器会判断这是一个格式合法的 URL，并且补全为 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a></p>
</blockquote>
<p>其中，http 为协议，baidu.com 为网络地址。每个浏览器网络栏中的地址都符合通用 URI 的语法。URI 一般由五个分层序列组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI = scheme:[//authority]path[?query][#fragment]</span><br><span class="line"></span><br><span class="line">URI = 方案:[//授权]路径[?查询][片段ID]</span><br></pre></td></tr></table></figure>

<p>接着，浏览器会从 URL 中提取出网络请求的地址，也即主机名（host）。一般主机名可以是域名或 IP 地址，此处使用域名。</p>
<p><strong>对 URL 进行解析之后，浏览器确定了服务器的主机名和请求路径，接下来就是根据这些信息来生成 HTTP 请求消息了</strong>。</p>
<blockquote>
<p>注：所以 HTTP 请求其实并不神秘，只不过是把一些客户端要发送的数据以特定的格式封装成一个大的数据对象。归根结底只不过是对数据的封装罢了。</p>
</blockquote>
<h2 id="网络请求前：查看浏览器缓存"><a href="#网络请求前：查看浏览器缓存" class="headerlink" title="网络请求前：查看浏览器缓存"></a>网络请求前：查看浏览器缓存</h2><p><strong>浏览器在 HTTP 报文生成完成后</strong>，它并不是马上就开始网络请求的。</p>
<blockquote>
<p>从这句话我们可以看出来，浏览器的一个重要作用是将客户端要发送的数据封装成一个 HTTP 请求。</p>
<p>并且，我们要明白，在 HTTP 请求中，没有服务器 IP 地址，没有服务器进程的端口信息。但是有域名信息。</p>
</blockquote>
<p>在浏览器发出之前，浏览器会先检查本地计算机中的缓存，如果发现之前访问过当前的 URL，会先进入缓存中查询。此时存在的缓存有：路由器缓存、DNS缓存、浏览器缓存、Service Worker、Memory Cache、Disk Cache、Push Cache、系统缓存等。</p>
<p>比如：如果在浏览器缓存里没有命中缓存，<strong>浏览器会做一个系统调用获得系统缓存的记录</strong>，也就是调用 <code>gethostbyname</code> 方法，这是一个系统调用，它的作用是通过域名获取 IP 地址。这个方法会返回如下结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span> </span><br><span class="line">    <span class="type">char</span> *h_name; <span class="comment">// （字符类型的）主机名，比如 192.168.0.0.1</span></span><br><span class="line">    <span class="type">char</span> **h_aliases; <span class="comment">// 主机的别名。www.baidu.com 就是百度自己服务器的别名 </span></span><br><span class="line">    <span class="type">int</span> h_addrtype; <span class="comment">// 主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)</span></span><br><span class="line">    <span class="type">int</span> h_length; <span class="comment">// 主机ip地址的长度 </span></span><br><span class="line">    <span class="type">char</span> **h_addr_list; <span class="comment">// 主机的ip地址（注意，这个是以网络字节序存储的）</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> h_addr h_addr_list[0] </span></span><br><span class="line">    #这个函数，是将类型为af的网络地址结构src，转换成主机序的字符串形式，存放在长度为cnt的字符串中。返回指向dst的一个指针。如果函数调用错误，返回值是<span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>如果之前没有访问过当前的 URL，就会跳过缓存这一步，这时就真正进入网络中进行操作了。</p>
<h2 id="域名解析：DNS"><a href="#域名解析：DNS" class="headerlink" title="域名解析：DNS"></a>域名解析：DNS</h2><p>浏览器在生成 HTTP 请求之后，需要委托操作系统将 HTTP 报文发送到对应的服务器端。在发送消息之前，必须知道服务器的 IP 地址，而域名服务器提供了通过域名解析 IP 地址的服务。</p>
<h2 id="网络协议栈（传输层和网络层）"><a href="#网络协议栈（传输层和网络层）" class="headerlink" title="网络协议栈（传输层和网络层）"></a>网络协议栈（传输层和网络层）</h2><p>现在我们已经根据 URL 拿到服务器的唯一地址了，接下来就要委托操作系统将 HTTP 报文发送出去了，这个过程由操作系统中的网络协议栈进行处理。</p>
<p>TCP/IP 协议栈是现在使用最广泛的网络协议栈（相较于 OSI 协议栈）。</p>
<p>协议栈是分层结构的，<strong>它的上半部分负责和应用层通过套接字（Socket）进行交互</strong>，它可以是 TCP 或 UDP 协议。应用层会委托协议栈的上半部分（传输层及之上）完成收发数据的工作；而协议栈的下半部分（网络层及之下）则负责把数据发送到指定方的 IP 协议，由 IP 协议连接下层的网卡驱动。</p>
<blockquote>
<p>注：socket 其实就是连接应用层与传输层的一个接口，负责把应用层数据转发给传输层，在传输层按照TCP或UDP协议的格式将数据封装成数据包。</p>
</blockquote>
<p><img src="http://processon.com/chart_image/62b9bf50637689073326365f.png"></p>
<h2 id="可靠性传输：建立TCP连接"><a href="#可靠性传输：建立TCP连接" class="headerlink" title="可靠性传输：建立TCP连接"></a>可靠性传输：建立TCP连接</h2><p>浏览器通过 DNS 解析拿到目标服务器的 IP 后，加上目标服务器的端口（HTTP默认80，HTTPS默认443，这些端口都是服务器公开的，在浏览器输入网址时就已经得到了）。这时浏览器就会委托操作系统调用协议栈的上半部分创建新的套接字（Socket），并向对应的 IP 发起 TCP 连接。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/26/%E4%BB%80%E4%B9%88%E6%98%AFSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/26/%E4%BB%80%E4%B9%88%E6%98%AFSocket/" class="post-title-link" itemprop="url">什么是Socket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-26 00:01:22 / Modified: 20:36:28" itemprop="dateCreated datePublished" datetime="2022-06-26T00:01:22+08:00">2022-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总纲："><a href="#总纲：" class="headerlink" title="总纲："></a>总纲：</h1><p><strong>Socket 是对传输层协议(TCP/UDP)的抽象，是传输层之上与传输层间进行信息交互的接口。我们知道两台计算机之间进行的网络通信是要通过“网卡”这一硬件设备来实现的，而“网卡”一般只有操作系统内核才有权限操作。而一般我们最常见网络通信是应用程序之间的网络通信，比如说：两台电脑上互相聊微信。而微信是操作系统上的一个应用程序，运行中的微信可以称其为一个进程，并且这个进程是处于用户态的，我们知道，用户态的进程是没有权限操作网卡的，为了使两台电脑间的微信能正常通信，这就又涉及到一个概念『系统调用』。系统调用是操作系统提供给用户态进程操作内核资源的一系列接口。通过这些接口可以实现：微信进程发起系统调用 –&gt; 内核操作网卡发送数据给接收端。</strong></p>
<p><strong>但是一个应用程序如何告诉系统调用自己的需求呢？以传输层为 TCP 协议为例，TCP 协议有很多操作，比如监听、接收连接、断开连接、数据传输等。那么这些操作映射到传输层之上，以 Java NIO 举例，就是 Socket 中的各种方法。所以总结下来就是，Socket 是对 TCP/IP 或 UDP 协议的一种映射，通过 Socket 对象中的方法执行的操作，最终会映射到 TCP/UDP 的协议栈上，继而通过“网卡”来完成数据传输。</strong></p>
<p>Socket 就是传输层提供给传输层之上的接口。应用层通过调用这个接口告诉传输层它想要执行的操作。</p>
<p>TCP/UDP 是数据包，那么这些数据从哪儿来呢？应用层！</p>
<p>应用层如何将数据传递给TCP/UDP数据呢？Socket！</p>
<p>正确理解HTTP</p>
<p>HTTP 可以理解为一个数据包，这个数据包在发送的时候还是得把它封装成 TCP 能看懂的数据包。只不过在发送到接收端后再按照一定的规则依次拆解开来即可。</p>
<p>客户端发送数据，不管有没有携带真实数据，肯定发过来一个数据包。那么服务器就要读，所以服务器的Channel中肯定产生了一个可读事件。</p>
<h1 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h1><p>客户端第一次连接服务器，服务器通过 accept 接受连接，同时将一条能连接到客户端的通道中的读事件注册到Selector中。(因为客户端作为数据的发送方，服务器作为数据的接收方，服务器要读取客户端发送过来的数据，所以服务器肯定是要关注自己机器上的读事件)。</p>
<p>在读到数据的同时，服务器还可以把数据写到这条通道中，这条通道就是客户端与服务器连接的通道，通道的另一端就是客户端，这时客户端机器就可以通过读通道中的数据拿到服务器返回的数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/24/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">Linux操作系统综述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-24 17:28:30 / Modified: 18:11:00" itemprop="dateCreated datePublished" datetime="2022-06-24T17:28:30+08:00">2022-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/19/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/19/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">Java正则表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-06-19 22:30:19 / Modified: 22:40:07" itemprop="dateCreated datePublished" datetime="2022-06-19T22:30:19+08:00">2022-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">正则表达式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  应用场景：</p>
<ul>
<li>  文本处理</li>
</ul>
</blockquote>
<h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><p><img src="http://processon.com/chart_image/62af337fe401fd5a4d73c494.png"></p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="Case1："><a href="#Case1：" class="headerlink" title="Case1："></a>Case1：</h2><ol>
<li> 提取文章中所有的英文单词</li>
<li> 提取文章中所有的数字</li>
<li> 提取文章中所有英文单词和数字</li>
<li> 提取报读热榜标题</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
