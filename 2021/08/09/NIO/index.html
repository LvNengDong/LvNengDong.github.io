<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="课程大纲 第一章 Java I&#x2F;O 模型在真实开发中，非阻塞I&#x2F;O 配合 I&#x2F;O多路复用，是高性能网络编程中最常见的技术。 1. 阻塞&amp;非阻塞；同步&amp;异步1.1 同步(synchronous) &amp; 异步(asynchronous)同步&#x2F;异步主要针对C(client)端：  同步：简单来说，“同步”就是在C端发出一个功能调用时，在没有得到处理结果之前，该调用就不返回，而C端后">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO">
<meta property="og:url" content="http://example.com/2021/08/09/NIO/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="课程大纲 第一章 Java I&#x2F;O 模型在真实开发中，非阻塞I&#x2F;O 配合 I&#x2F;O多路复用，是高性能网络编程中最常见的技术。 1. 阻塞&amp;非阻塞；同步&amp;异步1.1 同步(synchronous) &amp; 异步(asynchronous)同步&#x2F;异步主要针对C(client)端：  同步：简单来说，“同步”就是在C端发出一个功能调用时，在没有得到处理结果之前，该调用就不返回，而C端后">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://processon.com/chart_image/62a72a32e0b34d29447092bf.png">
<meta property="og:image" content="http://processon.com/chart_image/62b5b7def346fb6dc5800047.png">
<meta property="og:image" content="http://example.com/2021/08/09/NIO/image-20210909171418839.png">
<meta property="og:image" content="http://processon.com/chart_image/62a885837d9c082d0b2cb18d.png">
<meta property="og:image" content="http://processon.com/chart_image/62b5bc5d1efad40851a8a913.png">
<meta property="og:image" content="http://processon.com/chart_image/62b453cdf346fb075472e93a.png">
<meta property="og:image" content="http://processon.com/chart_image/62b471935653bb104192d9ed.png">
<meta property="og:image" content="http://processon.com/chart_image/62b453cdf346fb075472e93a.png">
<meta property="og:image" content="http://processon.com/chart_image/62a86862e0b34d294473999b.png">
<meta property="og:image" content="http://processon.com/chart_image/62a87a9f1efad4656677a49d.png">
<meta property="og:image" content="http://processon.com/chart_image/62aef1cd1efad41af0432596.png">
<meta property="og:image" content="http://processon.com/chart_image/62aef4d1e401fd5a4d73630a.png">
<meta property="og:image" content="http://processon.com/chart_image/62b322b7e0b34d0712cdaa9a.png">
<meta property="article:published_time" content="2021-08-09T04:28:02.000Z">
<meta property="article:modified_time" content="2022-06-25T10:26:13.683Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://processon.com/chart_image/62a72a32e0b34d29447092bf.png">


<link rel="canonical" href="http://example.com/2021/08/09/NIO/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/08/09/NIO/","path":"2021/08/09/NIO/","title":"NIO"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>NIO | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2"><span class="nav-number">1.</span> <span class="nav-text">课程大纲</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-Java-I-O-%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">第一章 Java I&#x2F;O 模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%98%BB%E5%A1%9E-amp-%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9B%E5%90%8C%E6%AD%A5-amp-%E5%BC%82%E6%AD%A5"><span class="nav-number">2.1.</span> <span class="nav-text">1. 阻塞&amp;非阻塞；同步&amp;异步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%90%8C%E6%AD%A5-synchronous-amp-%E5%BC%82%E6%AD%A5-asynchronous"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 同步(synchronous) &amp; 异步(asynchronous)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%98%BB%E5%A1%9E-Block-amp-%E9%9D%9E%E9%98%BB%E5%A1%9E-Unblock"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 阻塞(Block) &amp; 非阻塞(Unblock)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">1.2.1 什么是阻塞？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">1.2.2 什么是非阻塞？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-I-O%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">2. I&#x2F;O模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%98%BB%E5%A1%9EI-O"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 阻塞I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%9D%9E%E9%98%BB%E5%A1%9EI-O"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 非阻塞I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-NIO-%E6%A6%82%E8%BF%B0"><span class="nav-number">2.3.</span> <span class="nav-text">3. NIO 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-Channel"><span class="nav-number">2.3.1.</span> <span class="nav-text">3.3.1 Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-Buffer"><span class="nav-number">2.3.2.</span> <span class="nav-text">3.3.2 Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Selector"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.3 Selector</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BC%93%E5%86%B2%E5%8C%BA-Buffer"><span class="nav-number">3.</span> <span class="nav-text">第二章 缓冲区[Buffer]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Buffer%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">1. Buffer的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7"><span class="nav-number">3.1.1.</span> <span class="nav-text">Buffer 对象的重要属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Buffer%E7%9A%84%E5%B8%B8%E7%94%A8API"><span class="nav-number">3.2.</span> <span class="nav-text">2. Buffer的常用API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%9B%B4%E6%8E%A5%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E5%8C%BA-ByteBuffer"><span class="nav-number">3.3.</span> <span class="nav-text">3. 直接字节缓冲区[ByteBuffer]</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%80%9A%E9%81%93-Channel"><span class="nav-number">4.</span> <span class="nav-text">第三章 通道[Channel]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Channel%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">1 Channel概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Channel%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">2 Channel实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-FileChannel"><span class="nav-number">4.3.</span> <span class="nav-text">3 FileChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E-channel-%E4%B8%AD%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">4.3.0.1.</span> <span class="nav-text">从 channel 中读数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91-channel-%E4%B8%AD%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-number">4.3.0.2.</span> <span class="nav-text">向 channel 中写数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">4.3.0.3.</span> <span class="nav-text">通道间的数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileChannel-transferTo-transferFrom"><span class="nav-number">4.3.0.3.1.</span> <span class="nav-text">FileChannel#transferTo&#x2F;transferFrom</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileChannel-size-%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.0.4.</span> <span class="nav-text">FileChannel#size()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileChannel-truncate-%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.0.5.</span> <span class="nav-text">FileChannel#truncate() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileChannel-force-%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.0.6.</span> <span class="nav-text">FileChannel#force() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileChannel-position-%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.0.7.</span> <span class="nav-text">FileChannel#position() 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-TCP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E7%9A%84Channel"><span class="nav-number">4.4.</span> <span class="nav-text">4. TCP协议相关的Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-SocketChannel"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.1 SocketChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5"><span class="nav-number">4.4.1.3.</span> <span class="nav-text">写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%97%AD"><span class="nav-number">4.4.1.4.</span> <span class="nav-text">关闭</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-ServerSocketChannel"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.2 ServerSocketChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8Socket%E9%80%9A%E9%81%93"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">创建服务器Socket通道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">接收连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%AE%9E%E6%88%98"><span class="nav-number">4.4.3.</span> <span class="nav-text">4.3 实战</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%80%89%E6%8B%A9%E5%99%A8-Selector"><span class="nav-number">5.</span> <span class="nav-text">第四章 选择器[Selector]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%80%89%E6%8B%A9%E5%99%A8%E5%9F%BA%E7%A1%80"><span class="nav-number">5.1.</span> <span class="nav-text">1. 选择器基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%89%E4%B8%AA%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="nav-number">5.1.1.</span> <span class="nav-text">1.1 三个相关的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BASelector%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text">1.2 如何创建Selector选择器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SelectionKey%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">2. SelectionKey相关的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">3. 使用选择器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E5%8A%9B%E8%8A%82%E7%82%B9"><span class="nav-number">6.</span> <span class="nav-text">动力节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.1.</span> <span class="nav-text">JVM读取数据模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO%E4%B8%8E%E4%BC%A0%E7%BB%9FIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.</span> <span class="nav-text">NIO与传统IO的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Channel"><span class="nav-number">7.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Channel%E6%A6%82%E8%BF%B0-1"><span class="nav-number">7.1.</span> <span class="nav-text">1. Channel概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Scatter-Gather"><span class="nav-number">7.2.</span> <span class="nav-text">2. Scatter&#x2F;Gather</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-FileChannel-1"><span class="nav-number">7.3.</span> <span class="nav-text">3. FileChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-number">7.3.1.</span> <span class="nav-text">3.1 内存映射文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-FileChannel%E5%8F%8C%E5%90%91%E4%BC%A0%E8%BE%93"><span class="nav-number">7.3.2.</span> <span class="nav-text">3.2 FileChannel双向传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F"><span class="nav-number">7.3.3.</span> <span class="nav-text">3.3 缓冲区设置固定大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Channel%E5%88%B0Channel%E7%9A%84%E4%BC%A0%E8%BE%93"><span class="nav-number">7.3.4.</span> <span class="nav-text">3.4 Channel到Channel的传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Gather"><span class="nav-number">7.3.5.</span> <span class="nav-text">3.5 Gather</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-SocketChannel%E5%92%8CServerSocketChannel"><span class="nav-number">7.4.</span> <span class="nav-text">4. SocketChannel和ServerSocketChannel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-DatagramChannel"><span class="nav-number">7.5.</span> <span class="nav-text">5. DatagramChannel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Pipe"><span class="nav-number">7.6.</span> <span class="nav-text">6. Pipe</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%95%E6%B3%A1%E6%95%99%E8%82%B2"><span class="nav-number">8.</span> <span class="nav-text">咕泡教育</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ByteBuffer"><span class="nav-number">8.1.</span> <span class="nav-text">2. ByteBuffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Buffer%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="nav-number">8.1.1.</span> <span class="nav-text">2.3 Buffer常见方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">分配空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91Buffer%E4%B8%AD%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">向Buffer中写入数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8EBuffer%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">8.1.1.3.</span> <span class="nav-text">从Buffer中读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mark-amp-reset"><span class="nav-number">8.1.1.4.</span> <span class="nav-text">mark &amp; reset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E-ByteBuffer-%E4%BA%92%E8%BD%AC"><span class="nav-number">8.1.1.5.</span> <span class="nav-text">字符串与 ByteBuffer 互转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Scattering-Reads"><span class="nav-number">8.1.2.</span> <span class="nav-text">2.4 Scattering Reads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Gathering-Writes"><span class="nav-number">8.1.3.</span> <span class="nav-text">2.5 Gathering Writes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="nav-number">8.2.</span> <span class="nav-text">3. 文件编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-FileChannel"><span class="nav-number">8.2.1.</span> <span class="nav-text">3.1 FileChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%B8%A4%E4%B8%AAChannel%E9%97%B4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="nav-number">8.2.2.</span> <span class="nav-text">3.2 两个Channel间传输数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Path"><span class="nav-number">8.2.3.</span> <span class="nav-text">3.3 Path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Files"><span class="nav-number">8.2.4.</span> <span class="nav-text">3.4 Files</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">8.3.</span> <span class="nav-text">4. 网络编程（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E9%9D%9E%E9%98%BB%E5%A1%9E-vs-%E9%98%BB%E5%A1%9E"><span class="nav-number">8.3.1.</span> <span class="nav-text">4.1 非阻塞 vs. 阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">8.3.1.2.</span> <span class="nav-text">非阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">8.3.1.3.</span> <span class="nav-text">多路复用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">9.</span> <span class="nav-text">其它</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="NIO | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          NIO
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-09 12:28:02" itemprop="dateCreated datePublished" datetime="2021-08-09T12:28:02+08:00">2021-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-25 18:26:13" itemprop="dateModified" datetime="2022-06-25T18:26:13+08:00">2022-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><p><img src="https://processon.com/chart_image/62a72a32e0b34d29447092bf.png"></p>
<h1 id="第一章-Java-I-O-模型"><a href="#第一章-Java-I-O-模型" class="headerlink" title="第一章 Java I/O 模型"></a>第一章 Java I/O 模型</h1><p>在真实开发中，<strong>非阻塞I/O</strong> 配合 <strong>I/O多路复用</strong>，是高性能网络编程中最常见的技术。</p>
<h2 id="1-阻塞-amp-非阻塞；同步-amp-异步"><a href="#1-阻塞-amp-非阻塞；同步-amp-异步" class="headerlink" title="1. 阻塞&amp;非阻塞；同步&amp;异步"></a>1. 阻塞&amp;非阻塞；同步&amp;异步</h2><h3 id="1-1-同步-synchronous-amp-异步-asynchronous"><a href="#1-1-同步-synchronous-amp-异步-asynchronous" class="headerlink" title="1.1 同步(synchronous) &amp; 异步(asynchronous)"></a>1.1 同步(synchronous) &amp; 异步(asynchronous)</h3><p><strong>同步/异步主要针对C(client)端：</strong></p>
<ul>
<li><strong>同步：</strong>简单来说，“同步”就是在C端发出一个功能调用时，在没有得到处理结果之前，该调用就不返回，而C端后续的任务必须等待当前调用返回后，才能进行下一步。这是一种串行化的思想，事情必须一件一件做，等前一件事情做完了才能做下一件事情。<ul>
<li>例如普通的同步B/S模式：提交请求-&gt;等待服务器处理-&gt;处理完毕返回。在此期间客户端浏览器不能干其它事情。</li>
</ul>
</li>
<li><strong>异步：</strong>异步的概念和同步相对，当C端发出一个异步调用后，调用者不会立刻得到结果。实际处理这个调用的部件在任务完成后，通过状态、通知和回调来通知调用者。<ul>
<li>例如Ajax请求(异步)：请求通过事件触发 -&gt; 服务器处理(这时浏览器仍然可以做其它事情) -&gt; 处理完毕。</li>
</ul>
</li>
</ul>
<p>简单来说，同步是一种可靠有序的运行机制。当我们进行同步操作时，后续的任务必须等待当前调用返回，才会进行下一步；而异步则相反，其它任务不需要等待当前调用返回，通常依靠回调、事件等机制来实现任务间次序关系。</p>
<h3 id="1-2-阻塞-Block-amp-非阻塞-Unblock"><a href="#1-2-阻塞-Block-amp-非阻塞-Unblock" class="headerlink" title="1.2 阻塞(Block) &amp; 非阻塞(Unblock)"></a>1.2 阻塞(Block) &amp; 非阻塞(Unblock)</h3><p><strong>阻塞/非阻塞主要针对S(Server)端：</strong></p>
<h4 id="1-2-1-什么是阻塞？"><a href="#1-2-1-什么是阻塞？" class="headerlink" title="1.2.1 什么是阻塞？"></a>1.2.1 什么是阻塞？</h4><p>当服务器上的应用程序(实际上是一个进程，对于单线程程序来说，一个应用程序只有一个线程)调用阻塞I/O完成某个操作时，应用程序会被挂起，等待操作系统内核完成操作后，再重新得到 CPU 继续执行应用程序，感觉上应用程序就像被“阻塞”了一样。实际上，在内核处理 I/O 操作的这段时间内，CPU 会被内核切换给其它有需要的进程，因此这个应用程序不能得到 CPU 资源来做其它的事情。</p>
<blockquote>
<p><strong>以“应用程序执行写数据的I/O操作”进行分析：</strong></p>
<p>当一个网络应用程序(用户态的进程)执行写操作时，首先等待写出的数据会保存在当前进程的内存空间中。当用户态进程发起“写操作”的系统调用后，CPU 需要将这份数据从用户进程的内存空间拷贝到当前操作系统的内核态空间中，当然这需要一定的时间。在没有得到这个系统调用的返回结果之前，这个用户态的进程将一直处于阻塞状态。直到得到了系统调用的返回结果后，用户进程重新轮询得到 CPU 资源后，进程才离开阻塞状态继续运行。</p>
</blockquote>
<p><strong>问：阻塞的是谁？</strong></p>
<p>答：阻塞的是应用程序（也就是应用程序对应的用户态进程）</p>
<h4 id="1-2-2-什么是非阻塞？"><a href="#1-2-2-什么是非阻塞？" class="headerlink" title="1.2.2 什么是非阻塞？"></a>1.2.2 什么是非阻塞？</h4><p>与阻塞 I/O 不同，当应用程序调用非阻塞 I/O 完成某个操作时，应用程序首先会通过系统调用来访问操作系统内核，但不会等待内核完成处理，而是立刻返回。这种情况下，内核就不会把 CPU 时间切换给其它进程，因此应用程序可以继续使用 CPU 资源来完成其它事情。</p>
<blockquote>
<p><strong>举例</strong></p>
<p>拿“去书店买书”举例子。</p>
<ul>
<li>阻塞 I/O 就是：你去了书店，告诉老板(内核)你想要某本书，然后你就一直在那儿等着，直到老板翻箱倒柜找到了你想要的书(本地阻塞)，有可能还要帮你联系全城的其它分店(网络阻塞)。注意：这个过程你一直滞留在书店等待老板的回复，就好像在书店老板这里“阻塞”住了。</li>
<li>而非阻塞 I/O 则是：你去了书店，问老板有没有你心仪的那本书，老板查了下电脑，告诉你没有，你就悻悻地离开了。一周以后，你又来这个书店，再问这个老板，老板一查，有了，于是你买了这本书。注意：这个过程中，你没有被阻塞，而是在不断地轮询。</li>
</ul>
<p><strong>I/O 多路复用</strong></p>
<ul>
<li>但是轮询的效率太低了，于是你跟老板商量：“老板，到货给我打电话吧，我再来付钱取书。”这就是所谓的 I/O 多路复用。</li>
</ul>
<p><strong>AIO(异步I/O)</strong></p>
<ul>
<li>再进一步，你连去书店取书也想省了，得了，让老板代劳吧。你留下地址，付了书费，让老板到货时寄给你，你直接在家里拿到书就可以看了。这就是传说中的异步 I/O。</li>
</ul>
</blockquote>
<h2 id="2-I-O模型"><a href="#2-I-O模型" class="headerlink" title="2. I/O模型"></a>2. I/O模型</h2><p>目前为止，Java 共支持 3 种 IO 模型：BIO、NIO、AIO</p>
<ul>
<li><strong>BIO（同步阻塞 I/O）</strong></li>
<li><strong>NIO（同步非阻塞I/O）</strong></li>
<li><strong>AIO（异步非阻塞I/O）</strong></li>
</ul>
<p>这里我们暂时不考虑同步和异步的问题，只从阻塞和非阻塞两个角度来学习常见的 I/O 模型。</p>
<h3 id="2-1-阻塞I-O"><a href="#2-1-阻塞I-O" class="headerlink" title="2.1 阻塞I/O"></a>2.1 阻塞I/O</h3><p><strong>所谓的阻塞I/O，就是在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其它任务，只有当条件就绪才能继续。如果读取数据，代码会阻塞直至用户线程的内存空间中有可供读取的数据。同样，如果写入数据，在内核写入完成前，用户线程会一直处于阻塞状态。</strong></p>
<p>传统的 Server/Client 模式基于 TPR(Thread per Request)原则，服务器会为每个客户端连接创建一个新的线程，由该线程单独负责处理当前次的客户请求。这种模式的缺点就是：服务器需要创建多个线程来维护多个连接，大量的线程会增大服务器的开销，甚至导致服务器宕机。</p>
<p><img src="http://processon.com/chart_image/62b5b7def346fb6dc5800047.png"></p>
<p>大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量。但这又带来了新的问题，如果线程池中有100个线程，而目前这100个线程都在进行文件传输，就会导致第101个用户的请求无法被及时处理，即便第101个用户只想请求一个几KB大小的页面。</p>
<h3 id="2-2-非阻塞I-O"><a href="#2-2-非阻塞I-O" class="headerlink" title="2.2 非阻塞I/O"></a>2.2 非阻塞I/O</h3><p>在 Java NIO 中，非阻塞 I/O 采用了基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，相反是注册感兴趣的特定 I/O 事件(如可读数据到达，新的套接字连接等)。在特定事件发生时，系统再通知我们。</p>
<blockquote>
<p>我要读数据 –&gt; 发起“系统调用” –&gt; 我不被阻塞，继续执行其它操作 –&gt; 我去注册一个感兴趣的读事件 –&gt; 数据达到用户进程内存空间时通知我 –&gt; 我去读数据</p>
<ul>
<li>注：“我” == 用户进程</li>
</ul>
</blockquote>
<p>NIO 中实现非阻塞 I/O 的核心对象就是 Selector。Selector 就是注册各种 I/O 事件的地方。当我们感兴趣的事件发生时，这个对象就会告诉我们所发生的事件。</p>
<p><img src="/2021/08/09/NIO/image-20210909171418839.png" alt="image-20210909171418839"></p>
<p>从图中可以看出，当用户进程空间有读或写等任何注册的事件发生时，可以从 Selector 中获得相应的 SelectionKey，同时从 SelectionKey 中可以找到发生的事件和该事件所发生的具体的 SelectableChannel，以获得客户端发送过来的数据。</p>
<p><strong>非阻塞指的是 I/O 事件本身不阻塞，但是获取 I/O 事件的 <code>select()</code> 方法是需要阻塞等待的。区别是阻塞 I/O 会阻塞在 I/O 操作上，NIO 阻塞在事件获取上，没有事件就没有 I/O，从更高的层次看 I/O 就不阻塞了。</strong></p>
<p><strong>也就是说只有 I/O 已经发生那么我们才评估 I/O 是否阻塞，但是 <code>select()</code> 阻塞的时候 I/O 还没有发生，何谈 I/O 的阻塞呢？NIO 的本质是延迟 I/O 操作到真正发生 I/O 的时候，而不是以前的只要 I/O 流打开了就一直等待 IO 操作。</strong></p>
<table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流（Stream Oriented）</td>
<td>面向缓冲区（Buffer Oriented）</td>
</tr>
<tr>
<td>阻塞IO（Blocking IO）</td>
<td>非阻塞IO（Non Blocking IO）</td>
</tr>
<tr>
<td>无</td>
<td>选择器（Selectors）</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-NIO-概述"><a href="#3-NIO-概述" class="headerlink" title="3. NIO 概述"></a>3. NIO 概述</h2><blockquote>
<p>  <strong>Java NIO；New IO 或 Non Blocking IO</strong></p>
</blockquote>
<p>Java NIO 是 JDK1.4 引入的一组全新的IO API，用于代替之前版本的 IO API。NIO 使用了<strong>面向缓冲区</strong>的、<strong>基于通道</strong>的IO操作，可以更加高效地执行文件的读写操作。</p>
<p>Java NIO 的三个核心组件：</p>
<ul>
<li><strong>Channels</strong></li>
<li><strong>Buffers</strong></li>
<li><strong>Selectors</strong></li>
</ul>
<p>虽然除此之外，Java NIO 中还有很多其它的类和组件，如 Pipe 和 FileLock。但其它 API 只不过是与三个核心组件配合使用的工具类。</p>
<h3 id="3-3-1-Channel"><a href="#3-3-1-Channel" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h3><blockquote>
<p>  <strong>Channel；通道</strong></p>
</blockquote>
<p>Channel 和传统 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream，OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。</p>
<p>NIO 中的 Channel 的主要实现类有：</p>
<ul>
<li>  FileChannel</li>
<li>  DatagramChannel</li>
<li>  SocketChannel</li>
<li>  ServerSocketChannel，</li>
</ul>
<p>这里看名字就可以猜出个所以然来：分别可以对应：</p>
<ul>
<li>  文件 I/O</li>
<li>  UDP 数据传输</li>
<li>  TCP 数据传输（Server 和 Client）</li>
</ul>
<h3 id="3-3-2-Buffer"><a href="#3-3-2-Buffer" class="headerlink" title="3.3.2 Buffer"></a>3.3.2 Buffer</h3><p>NIO 中的关于 Buffer 实现有：</p>
<ul>
<li>  <strong>ByteBuffer</strong></li>
<li>  <strong>CharBuffer</strong></li>
<li>  DoubleBuffer</li>
<li>  FloatBuffer</li>
<li>  IntBuffer</li>
<li>  LongBuffer</li>
<li>  ShortBuffer</li>
</ul>
<p>分别对应基本数据类型是：</p>
<ul>
<li>  byte</li>
<li>  char</li>
<li>  double</li>
<li>  float</li>
<li>  int</li>
<li>  long</li>
<li>  short</li>
</ul>
<h3 id="3-3-Selector"><a href="#3-3-Selector" class="headerlink" title="3.3 Selector"></a>3.3 Selector</h3><p><strong>Selector 运行单线程处理多个 Channel</strong>。</p>
<p>如果你的应用程序需要维护了多个通道，并且每个连接的流量都很低，使用 Selector 就会很方便。例如在一个聊天服务器中，使用 Selector，可以向 Selector 注册多个 Channel，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件。</p>
<hr>
<h1 id="第二章-缓冲区-Buffer"><a href="#第二章-缓冲区-Buffer" class="headerlink" title="第二章 缓冲区[Buffer]"></a>第二章 缓冲区[Buffer]</h1><h2 id="1-Buffer的属性"><a href="#1-Buffer的属性" class="headerlink" title="1. Buffer的属性"></a>1. Buffer的属性</h2><p>Buffer 实际上就是一个数组，这个数组的内容与元信息会被包装成一个 <code>java.nio.Buffer</code> 对象，并提供了一组访问这些信息的 API。</p>
<h3 id="Buffer-对象的重要属性"><a href="#Buffer-对象的重要属性" class="headerlink" title="Buffer 对象的重要属性"></a>Buffer 对象的重要属性</h3><ul>
<li><strong>capacity</strong>：容量。指缓冲区可以存储多少个字节的数据。<ul>
<li>容量在创建 Buffer 实例时指定，创建后不能再次修改。如果缓冲区满了，需要清空后才能继续写数据。</li>
</ul>
</li>
<li><strong>position</strong>：当前位置（读写指针）。指缓冲区当前写入/读取的位置。<ul>
<li>新的 Buffer 对象 position 初始值为 0，每读/写一个数据，position 自动向后移动一个单位，它的最大值是 <code>capacity-1</code>。当 Buffer 发生读写模式的切换时，position 会被重置为 0。</li>
</ul>
</li>
<li><strong>limit</strong>：上限。指第一个不能被读/写的位置。<ul>
<li>limit 上限后面的单元既不能读也不能写。在 Buffer 缓冲区的写模式下，limit 表示能够写入多少个数据；在读模式下，limit 表示最多可以读取多少个数据。</li>
</ul>
</li>
<li>mark：标记。设置一个标记位置。<ul>
<li>调用 mark() 方法会把标记设置在 position 位置，当调用 reset() 方法时，会把 position 设置为 mark 标记的位置。</li>
</ul>
</li>
</ul>
<p><img src="http://processon.com/chart_image/62a885837d9c082d0b2cb18d.png" alt="img"></p>
<p><code>CharBuffer.allocate(12)</code> 方法会创建一个大小为 12 个字符的 Buffer 数组。</p>
<ul>
<li>对于该 buffer 对象来说，新建的 buffer 对象默认处于写模式(因为新建的buffer里面没有内容，所以必然处于写模式)，position 初始为 0，capacity 和 limit 为 12。</li>
<li>向缓冲区中写入 5 个字符后，position 会移动到下标为 5 的地方，capacity 和 limit 未发生改变。</li>
<li>调用 flip() 方法切换到读模式后，capacity 仍不会发生变化，但 position 变为 0，limit 会变为 position 原来的位置(最多能读多少个字符)，即下标为 5 的位置。<ul>
<li>在写模式下，position 始终在真实数据的后一个位置，表示下一个要写的位置。而在读模式下，position 每次都指示当前次要读的数据的位置。</li>
</ul>
</li>
</ul>
<h2 id="2-Buffer的常用API"><a href="#2-Buffer的常用API" class="headerlink" title="2. Buffer的常用API"></a>2. Buffer的常用API</h2><p>在 NIO 中，Buffer 常见的子类有：</p>
<ul>
<li>ByteBuffer、CharBuff、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer</li>
</ul>
<p>这些 Buffer 覆盖了能够通过 I/O 发送的所有基本数据类型：</p>
<ul>
<li>byte、char、double、float、int、long、short 等。</li>
</ul>
<p>实际上使用比较多的是 <strong>ByteBuffer 和 CharBuffer</strong>。</p>
<ul>
<li>每个 Buffer 类都有一个静态方法 <code>allocate(capacity)</code> 可用于创建一个指定容量的缓冲区；</li>
<li>都有一个 <code>put()</code> 方法用于向缓冲区中写数据；一个 <code>get()</code> 方法用于从缓冲区中读数据；</li>
<li>当缓冲区中还有未读完的数据，而要求马上向缓冲区中写数据时，可以调用 <code>compact()</code> 方法进行压缩，将所有未读数据复制到 buffer 的起始位置，把 position 设置到最后一个未读元素的后面，limit 属性设置为 capacity。【可以理解为切换到了写模式，其实所谓的读写模式就是通过设置 position 和 limit 的位置来实现的】</li>
<li><code>capacity()</code> 方法返回缓冲区的大小。</li>
<li><code>hasRemaining()</code>：判断当前 position 后面是否还有待处理的数据。即判断 position 与 limit 之间是否还有有效数据。</li>
<li><code>limit()</code>：返回 limit 上限的位置</li>
<li><code>mark()</code>：设置缓冲区的标志位置，这个值只能在 0~position 之间。之后可以通过 <code>reset()</code> 方法返回到这个位置。</li>
<li><code>position()</code> 可以返回 position 当前位置。</li>
<li><code>remaining()</code> 返回当前 position 位置与 limit 之间的数据量</li>
<li><code>reset()</code> 方法可以将 position 设置为 mark 标志位</li>
<li><code>rewind()</code> 方法会将 position 设置为 0，并取消 mark 标志位。</li>
<li><code>clear()</code> 清空缓冲区。仅仅是修改 position 标志为 0，设置 limit 标志为 capacity，缓冲区中的数据还是存在的。</li>
<li><code>flip()</code> 方法可以把缓冲区由写模式切换到读模式。即先设置 limit 为 position 位置，再把 position 设置为 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 Buffer 的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBuffer01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建 CharBuffer 缓冲区对象</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、打印 capacity、limit、position</span></span><br><span class="line">    System.out.println(<span class="string">&quot;02************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、向缓冲区中写数据</span></span><br><span class="line">    buf.put(<span class="string">&quot;你&quot;</span>);</span><br><span class="line">    buf.put(<span class="string">&quot;好&quot;</span>);</span><br><span class="line">    buf.put(<span class="string">&quot;世&quot;</span>);</span><br><span class="line">    buf.put(<span class="string">&quot;界&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;03************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、调用 flip()，把缓冲区切换为读模式</span></span><br><span class="line">    buf.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;04************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、调用 get() 方法读取缓冲区中的数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;05************************************&quot;</span>);</span><br><span class="line">    System.out.println(buf.get()); <span class="comment">//你</span></span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、再次写数据，把数据保存在 position 位置(由于没有切换写模式，所以会直接覆盖position位置的数据)</span></span><br><span class="line">    buf.put(<span class="string">&quot;X&quot;</span>); <span class="comment">// 你X世界</span></span><br><span class="line">    System.out.println(<span class="string">&quot;06************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、设置标志</span></span><br><span class="line">    buf.mark(); <span class="comment">//标志设在了下标为2的位置上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8、再读一个字符</span></span><br><span class="line">    System.out.println(<span class="string">&quot;08************************************&quot;</span>);</span><br><span class="line">    System.out.println(buf.get()); <span class="comment">//世</span></span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9、调用 reset()，把position重置为mark标志位置</span></span><br><span class="line">    buf.reset();</span><br><span class="line">    System.out.println(<span class="string">&quot;09************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10、调用compact压缩，把buffer中未读的数据复制到 position 为 0 的位置【compact会完成读到写模式的转换】</span></span><br><span class="line">    buf.compact();</span><br><span class="line">    System.out.println(<span class="string">&quot;10************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11、调用 clear() 清空。仅仅是修改 position/limit 的值</span></span><br><span class="line">    buf.clear();</span><br><span class="line">    System.out.println(<span class="string">&quot;11************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12、clear() 清空以后，缓冲区的数据依然存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;12************************************&quot;</span>);</span><br><span class="line">    System.out.println(buf); <span class="comment">// 世界世界</span></span><br><span class="line">    <span class="comment">//通过循环把position与limit之间的内容逐个打印</span></span><br><span class="line">    <span class="keyword">while</span> (buf.hasRemaining())&#123;</span><br><span class="line">        System.out.println(buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用缓冲区就是为了提高数据传输效率，一次读写一个字符或者一个字节效率不高，可以进行批量处理操作。</span></span><br><span class="line"><span class="comment"> * 可以借助数组，把缓冲区中的一块数据读到数组中，也可以把数组中的部分内容保存到缓冲区。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBuffer02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 可以把字符串保存到 buffer 缓冲区中</span></span><br><span class="line">    buffer.put(<span class="string">&quot;你好世界，你好NIO&quot;</span>);</span><br><span class="line">    buffer.flip(); <span class="comment">// 切换为读模式(主要是为了改变limit的值)</span></span><br><span class="line">    System.out.println(buffer); <span class="comment">//你好世界，你好NIO</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] dst = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//调用 get() 方法把缓冲区中的数据读到字符数组中</span></span><br><span class="line">    <span class="comment">//注意：批量传输时大小总是固定的，如果没有指定传输的大小，意味着把数组填满。如果数组不能被填满，则会抛出异常</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">remainingCharBuffer</span> <span class="operator">=</span> buffer.get(dst);</span><br><span class="line">    System.out.println(<span class="string">&quot;数组中数据：&quot;</span> + Arrays.toString(dst)); <span class="comment">//数组中数据：[你, 好, 世, 界, ，, 你, 好, N]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;缓冲区中剩余数据：&quot;</span> + remainingCharBuffer); <span class="comment">// 缓冲区中剩余数据：IO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续把buffer中的内容读取到字符数组中，当缓冲区的数据量不足以填满整个数组时，会抛出异常</span></span><br><span class="line">    <span class="comment">// buffer.get(dst); //BufferUnderflowException</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在批量读取数据缓冲区的数据时，一定记得查询缓冲区中的剩余量。</span></span><br><span class="line">    <span class="comment">// 把小缓冲区中的数据填充到大数组中时，一定要指定缓冲区剩余量的长度。</span></span><br><span class="line">    buffer.get(dst, <span class="number">0</span>, buffer.remaining()); <span class="comment">// 把buffer缓冲区中剩余的数据(总大小为remaining)传输到dst数组0开始的位置</span></span><br><span class="line">    System.out.println(Arrays.toString(dst)); <span class="comment">// [I, O, 世, 界, ，, 你, 好, N]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取缓冲区中的数据</span></span><br><span class="line">    buffer.clear();</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(dst.length, buffer.remaining());</span><br><span class="line">        buffer.get(dst, <span class="number">0</span>, len);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(dst, <span class="number">0</span>, len)); <span class="comment">//你好世界，你好NIO</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量写入</span></span><br><span class="line">    <span class="type">char</span>[] contents = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">// 把字符数组中的数据写入到缓冲区中(如果缓冲区没有足够的空间，会抛出异常)</span></span><br><span class="line">    <span class="comment">//buffer.put(contents); //BufferOverflowException</span></span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer.capacity()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer.limit()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer.position()); <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">    buffer.clear();</span><br><span class="line">    buffer.put(contents);</span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(buffer); <span class="comment">//abcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Buffer 对象的创建方式：</span></span><br><span class="line"><span class="comment"> *      1、分配操作创建缓冲区。allocate() 方法分配一个私有的，指定容量大小的数据来存储元素。</span></span><br><span class="line"><span class="comment"> *      2、包装操作创建缓冲区。它使用现成的数组作为存储空间来充当一个缓冲区。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方式一：分配操作创建缓冲区</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buf1</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方式二：使用包装操作创建缓冲区</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">// 把现成的数组包装成一个Buffer对象</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buf2</span> <span class="operator">=</span> CharBuffer.wrap(charArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过调用 put() 方法向缓冲区中保存数据，也会直接影响到数组</span></span><br><span class="line">    buf2.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    buf2.flip();</span><br><span class="line">    System.out.println(buf2); <span class="comment">//hello</span></span><br><span class="line">    System.out.println(Arrays.toString(charArray)); <span class="comment">//[h, e, l, l, o,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组做的任何修改，也会影响到缓冲区对象</span></span><br><span class="line">    charArray[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    System.out.println(buf2); <span class="comment">//Xello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不管是 allocate() 还是通过 warp() 方法创建的缓冲区都是间接的。</span></span><br><span class="line"><span class="comment">     * 间接缓冲区会使用备份数组 hasArray() 方法判断是否有一个可存取的备份数组。</span></span><br><span class="line"><span class="comment">     * 如果 hasArray() 返回 true，可以通过 array() 返回缓冲区对象使用的备份数组的引用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (buf2.hasArray())&#123;</span><br><span class="line">        <span class="type">char</span>[] backupArray = buf2.array();</span><br><span class="line">        System.out.println(Arrays.toString(backupArray)); <span class="comment">//[X, e, l, l, o,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓冲区的复制与分隔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建缓冲区</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 2、存储数据</span></span><br><span class="line">    buffer.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;buffer.position=&quot;</span> + buffer.position()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、缓冲区的复制</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> buffer.duplicate();</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer2.capacity()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer2.limit()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer2.position()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    buffer2.flip();</span><br><span class="line">    System.out.println(buffer2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer 与 buffer2 实际引用同一个数组</span></span><br><span class="line">    buffer2.clear();</span><br><span class="line">    buffer2.put(<span class="string">&quot;NIO_world&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出 buffer 中的内容</span></span><br><span class="line">    buffer.flip(); <span class="comment">// 反转，把limit设置的值为上一个position的值5</span></span><br><span class="line">    System.out.println(buffer); <span class="comment">//NIO_w</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔缓冲区，slice() 方法根据 [position, limit) 区间创建一个新的缓冲区</span></span><br><span class="line">    buffer2.position(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer2.capacity()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer2.limit()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer2.position()); <span class="comment">//3</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> buffer2.slice();</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer3.capacity()); <span class="comment">//13</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer3.limit()); <span class="comment">//13</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer3.position()); <span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-直接字节缓冲区-ByteBuffer"><a href="#3-直接字节缓冲区-ByteBuffer" class="headerlink" title="3. 直接字节缓冲区[ByteBuffer]"></a>3. 直接字节缓冲区[ByteBuffer]</h2><p>在硬盘和操作系统中处理的数据都是二进制的 01 数据，Buffer 的子类中只有 ByteBuffer 字节缓冲区有资格参与 IO 操作。</p>
<p>Channel 通道只能使用 ByteBuffer 作为它的参数。</p>
<p>直接字节缓冲区通常是 IO 操作最好的选择，如果使用非直接字节缓冲区可能会导致性能损耗。如果向通道传递一个非直接字节缓冲区，通道可能会先创建一个临时的直接字节缓冲区，将非直接缓冲区中的内容复制到这个临时的直接字节缓冲区中，使用临时直接字节缓冲区执行底层的 IO 操作。</p>
<p>直接缓冲区是 IO 的最佳选择，可能创建直接缓冲区比创建非直接缓冲区的成本要高。直接缓冲区使用的内存是通过调用本地操作系统分配的，绕过了 JVM 的堆栈。</p>
<p>现在 JVM 可能会执行缓冲区缓存的优化，作为入门初级开发人员，不要考虑优化的问题，先保证程序的正确性。</p>
<p><code>ByteBuffer.allocateDirect(16)</code> 方法创建直接字节缓冲区。</p>
<hr>
<h1 id="第三章-通道-Channel"><a href="#第三章-通道-Channel" class="headerlink" title="第三章 通道[Channel]"></a>第三章 通道[Channel]</h1><h2 id="1-Channel概述"><a href="#1-Channel概述" class="headerlink" title="1 Channel概述"></a>1 Channel概述</h2><p><strong>通道(Channel)负责将缓冲区的数据块移入到各种I/O源，如文件、socket、数据报等；或者是将各种 I/O 源的数据移入到缓冲区。</strong></p>
<ul>
<li>  通道与流(Stream)的不同之处在于通道是双向的，而流只在一个方向上移动(一个流必须是 InputStream 或 OutputStream)。</li>
<li>  而且通道可以用于读、写或同时用于读写。因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5/310007?fr=aladdin">全双工</a></li>
<li>  NIO 中通过 Channel 封装了对数据源的操作，通过 Channel 我们可以操作数据源，但又不必关心数据源的具体物理结构。这个数据源可以是多种的。比如，可以是文件，也可以是网络 socket。</li>
<li>  在大多数应用中，Channel 与文件描述符或者 socket 是一一对应的。</li>
<li>  <strong>Channel 用于在 Buffer 缓冲区和位于通道另一侧的实体(通常是一个文件或套接字)之间有效地传输数据。</strong></li>
</ul>
<blockquote>
<p>  <strong>Channel接口源码</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio.channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tells whether or not this channel is open.</span></span><br><span class="line"><span class="comment">     * 判断通道是否打开</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if, and only if, this channel is open</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this channel.</span></span><br><span class="line"><span class="comment">     * 关闭通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>  与缓冲区不同，Channel API 主要由接口指定。<strong>通道API仅仅进行了一些功能性的描述，具体的实现方式根据不同的操作系统会有根本性的差异。</strong>因此很自然地，Channel 的实现通常使用操作系统的本地代码。</li>
<li>  Channel 是一个对象，可以通过它读取和写入数据。拿 NIO 与传统 I/O 做个比较，通道就像是流，所有数据都通过 Buffer 对象来处理。你永远不会将字节直接写入通道中，相反，你是将数据写入包含一个或者多个字节的缓冲区。同样，你不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</li>
</ul>
<p>Java NIO 的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道中。但流的读写通常是单向的。</li>
<li>通道可以异步的读写。</li>
<li>通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：</li>
</ul>
<p><img src="http://processon.com/chart_image/62b5bc5d1efad40851a8a913.png"></p>
<hr>
<h2 id="2-Channel实现"><a href="#2-Channel实现" class="headerlink" title="2 Channel实现"></a>2 Channel实现</h2><p>下面是 Java NIO 中最重要的 Channel 的实现：</p>
<ul>
<li><strong>FileChannel</strong>：从文件中读写数据。</li>
<li><strong>DatagramChannel</strong>：能通过 UDP 协议读写网络中的数据。</li>
<li><strong>SocketChannel</strong>：能通过 TCP 协议读写网络中的数据。</li>
<li><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，像 Web 服务器那样。对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<p>这些通道涵盖了 UDP 和 TCP 网络 I/O，以及文件 I/O。</p>
<h2 id="3-FileChannel"><a href="#3-FileChannel" class="headerlink" title="3 FileChannel"></a>3 FileChannel</h2><h4 id="从-channel-中读数据"><a href="#从-channel-中读数据" class="headerlink" title="从 channel 中读数据"></a>从 channel 中读数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 FileChannel 读取文件中的数据到 Buffer 中</span></span><br><span class="line"><span class="comment">     *  1、创建 FileChannel 对象</span></span><br><span class="line"><span class="comment">     *  2、创建 Buffer 对象</span></span><br><span class="line"><span class="comment">     *  3、通过 FileChannel 读取文件中的数据到 Buffer 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建FileChannel对象（FileChannel不能直接创建，创建该对象要依赖于一个File对象）</span></span><br><span class="line">        <span class="comment">// args1：文件路径。 args2：文件模式（读/写/执行）</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">afile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\nio\\src\\resource\\demo.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> afile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建Buffer对象，并分配buffer的大小（4字节）</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将数据从文件读取到Buffer中</span></span><br><span class="line">        <span class="comment">// 返回值用于记录当前次读取的字节数，等于-1时表示读取到了最后一行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> fileChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取了：&quot;</span> + bytesRead + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 目的：验证数据是否已经读到了buffer中。</span></span><br><span class="line"><span class="comment">            * 方式：取出buffer对象中的数据，打印在控制台上</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="comment">// 进行读写模式的转换【在这里转换的目的是为了输出读到的内容】</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// hasRemaining方法用于判断Buffer中是否还有剩余的数据内容</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 获取buffer中的内容</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) buffer.get();</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 循环从文件中读取数据到buffer中（当buffer中无数据后，bytesRead变量应该为-1）</span></span><br><span class="line">            bytesRead = fileChannel.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、释放资源</span></span><br><span class="line">        afile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;操作结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">读取了：4字节</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">读取了：4字节</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">读取了：1字节</span><br><span class="line">9</span><br><span class="line">操作结束</span><br></pre></td></tr></table></figure>



<h4 id="向-channel-中写数据"><a href="#向-channel-中写数据" class="headerlink" title="向 channel 中写数据"></a>向 channel 中写数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 向 Channel 中写数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、进行数据传输时需要使用到 Channel（通道），也就是说需要先创建一个连通两端（发送方/接收方）的通道</span></span><br><span class="line"><span class="comment">        2、创建 Channel 需要两端，其中一端为连接的发起方，在这里就是我们的代码端，所以我们必须还要手动指定</span></span><br><span class="line"><span class="comment">        另一端，一般我们会指定为一个文件。</span></span><br><span class="line"><span class="comment">      整个流程也就是说，把我们在代码中的数据发送给本机上的某个文件，在这两端之间建立一个 channel 用于数据传输，</span></span><br><span class="line"><span class="comment">      当然也会用到 buffer，因为 channel 的读或写操作都直接依赖于 buffer ，用 buffer 作为一个中转站，再去</span></span><br><span class="line"><span class="comment">      访问到具体的文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建 channel 对象，需要提前指定好 channel 的另一端，一般是一个文件对象</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo02.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、建立 磁盘文件 到 Java程序虚拟内存 间的连接通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、分配一块缓冲区，用于向channel中写数据</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、在内存中新建一段数据，并将其写入 buffer 中</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;This is my world!&quot;</span>).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        buffer.clear(); <span class="comment">// 使用前先清空buffer中的数据，这是一个好习惯</span></span><br><span class="line">        buffer.put(bytes);</span><br><span class="line"></span><br><span class="line">        buffer.flip();  <span class="comment">// 切换为读模式(向channel中写就意味着从buffer中读)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、将 buffer 中的数据写入 channel 中</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())</span><br><span class="line">        &#123;</span><br><span class="line">            channel.write(buffer);	<span class="comment">// 注意 write() 方法需要在while循环中进行调用，因为无法保证 write() 方法一次能向 channel 中写入多少字节，因此需要重复调用 write() 方法，直到 buffer 为空</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="通道间的数据传输"><a href="#通道间的数据传输" class="headerlink" title="通道间的数据传输"></a>通道间的数据传输</h4><p>两个通道间的数据可以进行直接的数据传输</p>
<h5 id="FileChannel-transferTo-transferFrom"><a href="#FileChannel-transferTo-transferFrom" class="headerlink" title="FileChannel#transferTo/transferFrom"></a>FileChannel#transferTo/transferFrom</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通道间的数据传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、建立两个通道</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo02.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel1</span> <span class="operator">=</span> file1.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel2</span> <span class="operator">=</span> file2.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、通道间进行数据传输（将channel1中的数据传输到channel2中）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> channel1.size();</span><br><span class="line"><span class="comment">//        channel1.transferTo(position, count, channel2);   // 方法1</span></span><br><span class="line">        channel2.transferFrom(channel1, position, count);   <span class="comment">// 方法2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、关闭资源</span></span><br><span class="line">        channel1.close();</span><br><span class="line">        channel2.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<h4 id="FileChannel-size-方法"><a href="#FileChannel-size-方法" class="headerlink" title="FileChannel#size()方法"></a>FileChannel#size()方法</h4><ul>
<li>  FileChannel 对象是根据其所关联的具体文件来创建的，</li>
<li>  所以 FileChannel 实例的 size() 方法将返回该实例所关联的文件的大小。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> fileChannel.size();	</span><br></pre></td></tr></table></figure>



<h4 id="FileChannel-truncate-方法"><a href="#FileChannel-truncate-方法" class="headerlink" title="FileChannel#truncate() 方法"></a>FileChannel#truncate() 方法</h4><ul>
<li>  FileChannel 实例一定会关联到某一个具体的文件</li>
<li>  可以使用 <strong>FileChannel#truncate()</strong> 方法来截取这个文件，截取文件时，会将指定长度后面的部分删除掉。截取后得到一个新的 fileChannel 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">newFileChannel</span> <span class="operator">=</span> fileChannel.truncate(<span class="number">1024</span>);	<span class="comment">// 截取文件的前 1024 个字节</span></span><br></pre></td></tr></table></figure>



<h4 id="FileChannel-force-方法"><a href="#FileChannel-force-方法" class="headerlink" title="FileChannel#force() 方法"></a>FileChannel#force() 方法</h4><ul>
<li>  在使用 Channel 时，出于性能考虑，操作系统会先将 channel 中的数据写出到缓存中，缓存区满了之后再将缓存中的数据写到磁盘上，所以一般情况下 fileChannel 无法保证数据一定会即时写到磁盘上。</li>
<li>  若想保证这一点，可以使用 FileChannel 的 force() 方法会将通道中尚未写入磁盘中的数据和缓存中的数据强制写到磁盘上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.force(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// force() 方法有一个 boolean 类型的参数，指明是否将数据写到磁盘上</span></span><br></pre></td></tr></table></figure>





<hr>
<h4 id="FileChannel-position-方法"><a href="#FileChannel-position-方法" class="headerlink" title="FileChannel#position() 方法"></a>FileChannel#position() 方法</h4><ul>
<li>  <strong>FileChannel#position()</strong> 方法可以获取 filechannel 当前读/写到的位置，</li>
<li>  也可以调用 position(long pos) 方法设置 fileChannel 的读/写的位置。</li>
<li>  该功能用于对 fileChannel 的某个特定位置进行读/写操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();	<span class="comment">// 获取 fileChannel 的当前位置</span></span><br><span class="line">channel.position(pos + <span class="number">123</span>);	<span class="comment">// 设置 fileChannel 的新的当前位置</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>  如果将当前位置设置在文件结束符之后，再试图从文件通道中读取数据，读方法将返回 -1。</li>
<li>  如果将当前位置设置在文件结束符之后，然后向通道中写数据，文件将被撑大到当前位置并写入数据。但是这有可能导致<strong>“文件空洞”</strong>，即磁盘上物理文件中写入的数据间有空隙。</li>
</ul>
<hr>
<h2 id="4-TCP协议相关的Channel"><a href="#4-TCP协议相关的Channel" class="headerlink" title="4. TCP协议相关的Channel"></a>4. TCP协议相关的Channel</h2><p>Channel接口有很多实现类，但是对于网络编程来说，实际上只有3个重要的通道类：SocketChannel、ServerSocketChannel和DatagramChannel。对于TCP连接，只需要前两个通道类；对于UDP连接只需要第三个通道类。</p>
<h3 id="4-1-SocketChannel"><a href="#4-1-SocketChannel" class="headerlink" title="4.1 SocketChannel"></a>4.1 SocketChannel</h3><p>SocketChannel对象可以读写<code>TCP Socket</code>。每个SocketChannel都与一个Socket对象关联。这个Socket对象可用于高级配置，但有些应用采用默认选项就可以正常运行，对于这些应用程序，可以忽略这个需求。</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>SocketChannel类没有公共的构造函数。但提供了两个静态 open() 方法来创建新的SocketChannel对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">(SocketAddress remote)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>第一个方法会尝试建立连接(通过系统调用告知操作系统内核尝试与远端建立连接)。这个方法是一个阻塞方法。也就是说，在连接建立或抛出异常之前，当前线程将一直处于阻塞状态。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open(address);</span><br></pre></td></tr></table></figure>

<p>无参版本的方法不会立即建立连接。它会创建一个初始未连接socket，以后必须用 connect() 方法进行连接。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">channel.connect(address);</span><br></pre></td></tr></table></figure>

<p>如果你希望以非阻塞的方式打开通道时，还需要配置通道的各项属性。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">channel.connect(address);</span><br></pre></td></tr></table></figure>

<p>或者你还想在连接前配置 socket 的各种选项，你可以选择一种更迂回的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> channel.socket();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">socket.connect(address);</span><br></pre></td></tr></table></figure>

<p>使用非阻塞通道时，connect() 方法会立即返回。在等待操作系统与远端服务器建立连接时，程序可以做其它事情。不过，程序在实际使用这个连接之前，一定要调用 finshConnect() 方法验证连接是否完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回true表示连接现在可以使用；</span></span><br><span class="line"><span class="comment"> * 返回false表示连接还未建立成功；</span></span><br><span class="line"><span class="comment"> * 如果连接无法建立，比如网络出现故障，将会抛出一个异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">finishConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>当然，这只对非阻塞模式是必须的。对于阻塞通道，当线程可以继续正常向后执行时连接一定已经建立成功了。</p>
<p>如果程序想检查连接是否完成，可以使用以下两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isConnectionPending</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>如果连接处于打开状态，isConnected() 方法会返回true。如果连接仍在建立过程中，isConnectionPending() 返回 true。</p>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>为了读取 SocketChannel 通道中的数据，首先要创建一个 ByteBuffer 对象，可以读取通道中的数据写到 Buffer 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>通道会用尽可能多的数据填充缓冲区，然后返回写入缓冲区的字节数。如果遇到流末尾，通道会将所有的剩余字节数写出到缓冲区，并且在下一次调用 read() 时返回<code>-1</code>。</p>
<p>如果通道是阻塞的，这个方法至少读取一个字节(读取成功)，或者返回<code>-1</code>(读取完成)，或者抛出异常(读取失败)。但如果通道是非阻塞的，这个方法可能返回<code>0</code>。</p>
<blockquote>
<ul>
<li>在阻塞模式下，若 SocketChannel 中没有数据可读，或者缓冲区满了，就会阻塞，直到满足读的条件(源有数据可读，目的地可以写数据)。所以一般阻塞模式的 read() 是比较简单的。</li>
<li>在非阻塞模式下，read() 方法返回 0 有两种情况：<ul>
<li>（1）首先是：某一时刻的 socketChannel 中没有数据可读会返回0。</li>
<li>（2）其次是：byteBuffer 中的 position 等于 limit 了，即 byteBuffer 缓冲区满了也会返回0；</li>
</ul>
</li>
</ul>
</blockquote>
<p>例如，下面的循环会一直读取从 socketChannel 读取数据向缓冲区写入，直到缓冲区填满或检测到流末尾为止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (buffer.hasRemaining() &amp;&amp; channel.read(buffer) != -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>





<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>Socket通道提供了读写方法，一般情况下它们是全双工的。要想写入，只需先填充一个 ByteBuffer，再将 ByteBuffer 中的数据写入通道中即可。</p>
<p>基本的 write() 方法接收一个缓冲区对象作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>与读取一样，如果通道是非阻塞的，这个方法不能保证会一次性将缓冲区中的全部内容写入到通道中。不过基于缓冲区游标的特性，你可以很容易的反复调用这个方法，直到缓冲区完全排空，且数据已经完全写入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (buffer.hasRemaining() &amp;&amp; channel.write(buffer) != -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>就像正常的 Socket 一样，在用完通道后应该将其关闭，释放它使用的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>如果通道已经关闭，再进行重复关闭将没有任何效果。如果试图读/写已关闭的通道，将抛出一个异常。如果不确定通道是否已经关闭，可以使用 isOpen() 方法检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通道已经关闭时，该方法返回 false；</span></span><br><span class="line"><span class="comment"> * 如果通道是打开的，则返回 true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>close() 和 isOpen() 方法是 Channel 接口中声明的仅有的两个方法，所有的通道类都共享这两个方法。</p>
<hr>
<h3 id="4-2-ServerSocketChannel"><a href="#4-2-ServerSocketChannel" class="headerlink" title="4.2 ServerSocketChannel"></a>4.2 ServerSocketChannel</h3><p>与 SocketChannel、DatagramChannel 不同，ServerSocketChannel 类并没有定义读和写的功能。ServerSocketChannel 类只有两个目的：监听并接受一个新的客户端连接和创建新的 SocketChannel 对象，它本身从不传递数据。</p>
<p>ServerSocketChannel 类本身只声明了4个方法，其中 accept() 最重要。该类还从其超类继承了几个方法，主要与向 Selector 注册来得到客户端连接通知有关。最后，与所有的通道一样，它有一个 close() 方法，用于关闭服务器 Socket。</p>
<h4 id="创建服务器Socket通道"><a href="#创建服务器Socket通道" class="headerlink" title="创建服务器Socket通道"></a>创建服务器Socket通道</h4><p>静态工厂方法 ServerSocketChannel.open() 用于创建一个新的 ServerSocketChannel 对象。不过，在 JDK7 之前，这个方法实际并不打开一个新的服务器 Socket，而只是创建一个 Channel 对象。在使用之前，需要调用 socket() 方法来获得相应的 ServerSocket 对象。之后，你就可以使用 serverSocket 的各种设置方法配置任何服务器选项。比如接收缓冲区的大小或 Socket 的超时值。最后，对于你希望绑定的端口，将这个 serverSocket 连接到对应端口的 SocketAddress。例如，下面的代码希望在端口 80 上打开一个 ServerSocketChannel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> server.socket();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">80</span>);</span><br><span class="line">socket.bind(address);</span><br></pre></td></tr></table></figure>

<p>在 Java7 之后，这个过程会更简单一些，因为现在 ServerSocketChannel 有了一个自己的 bind() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">80</span>);</span><br><span class="line">server.bind(address);</span><br></pre></td></tr></table></figure>

<p>JVM 在创建 ServerSocketChannel 对象时使用了工厂方法而不是构造函数，但是不同的虚拟机可以提供这个类的不同实现，从而更适用于本地硬件和操作系统。</p>
<h4 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h4><p>一旦打开并绑定了 ServerSocketChannel 对象，accept() 方法就可以监听新入站的 TCP 连接了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title function_">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>accept() 可以在阻塞或非阻塞模式下操作。</p>
<p>在阻塞模式下，accept() 方法等待入站连接。然后它接受一个连接，并返回连接到到远程客户端的一个 SocketChannel 对象。在建立连接之前，线程无法进行任何操作。这种策略适用于立即响应每一个请求的简单服务器。阻塞模式是默认模式。</p>
<p>在非阻塞模式下，如果没有入站连接，accept() 方法会返回 null。非阻塞模式更适合于需要为每个连接完成大量工作的服务器，这样就可以并发地处理多个请求。非阻塞模式一般与 Selector 配合使用。为了使 ServerSocketChannel 处于非阻塞模式，要向其 configureBlocking() 方法传入 false。</p>
<p>accept() 方法声明：出现错误时将抛出一个 IOException。IOException 的几个常见的子类及运行时异常如下：</p>
<ul>
<li>ClosedChannelException    关闭后无法重新打开一个 ServerSocketChannel。</li>
<li>AsynchronousCloseException    执行 accept() 方法时，另一个线程管理了这个 ServerSocketChannel</li>
<li>ClosedByInterruptException    一个阻塞 ServerSocketChannel 在等待时，另一个线程中断了这个线程。</li>
<li>NotYetBoundException    调用了 open()，但在调用之前没有将 ServerSocketChannel 对应的 ServerSocket 对象与地址绑定。这是一个运行时异常，不是 IOException 异常。</li>
<li>SecurityException    安全管理器拒绝这个应用程序绑定所请求的端口。</li>
</ul>
<h3 id="4-3-实战"><a href="#4-3-实战" class="headerlink" title="4.3 实战"></a>4.3 实战</h3><p>ServerSocketChannel 可以监听新进来的 TCP 连接。</p>
<p>SocketChannel 是一个连接到 TCP 网络套接字的。</p>
<p><strong>ServerSocketChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Date</span> 2022/6/19 21:11</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerSocketChannelTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="comment">// 1、建立一个新的(未绑定ServerSocket服务器的)的Channel通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、得到与 channel 相连的 serverSocket，并为 serverSocket 绑定端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));   <span class="comment">// 由于当前在服务器端，IP就是本机IP，所以直接绑定端口号即可</span></span><br><span class="line">        <span class="comment">// 从JDK7开始，上述两步可合为一步，代码如下：</span></span><br><span class="line">        <span class="comment">//serverSocketChannel.bind(new InetSocketAddress(port));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、设置通道(Channel)为非阻塞模式。当没有传入连接时，accept()方法返回null</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、服务器始终保持监听状态，监测是否有客户端请求连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是ServerSocket服务器，已经准备就绪。&quot;</span>);</span><br><span class="line">            <span class="comment">// 服务器通过 accept() 方法接收客户端发生的 socketChannel。(socketChannel中携带了客户端发送过来的数据)</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">            <span class="comment">// 如果没有入站请求，accept() 方法默认的返回值为null</span></span><br><span class="line">            <span class="keyword">if</span> (socketChannel == <span class="literal">null</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">//这里设置了：当没有客户端接入时，服务器等待3000ms后再重新监测</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当有连接到达服务器时：</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 先给客户端发送一个问候(服务器端-&gt;Buffer-&gt;SocketChannel)</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charsets.UTF_8.encode(<span class="string">&quot;Hello，I&#x27;m from socketServer&quot;</span>);</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Channel支持全双工数据传输，既有读的通道，也有也的通道，同时读写并不冲突</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                <span class="comment">// 再读取客户端中发送来的内容</span></span><br><span class="line">                <span class="type">SocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> socketChannel.socket().getRemoteSocketAddress();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端地址：&quot;</span> + address.toString());</span><br><span class="line">                <span class="comment">// 读取客户端发来的数据保存到buffer中</span></span><br><span class="line">                buffer.clear(); <span class="comment">// 复用buffer</span></span><br><span class="line">                socketChannel.read(buffer);</span><br><span class="line">                <span class="comment">// 打印buffer中的内容</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端发来的信息：&quot;</span> + Charsets.UTF_8.decode(buffer));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>SocketChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ReadableByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/19 21:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketChannelTest</span> &#123;</span><br><span class="line">    <span class="comment">// 服务器IP和进程端口号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT); <span class="comment">// Server Socket的地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个未连接 ServerSocket 的 SocketChannel(客户端Channel，客户端发出/接收的数据都要经过该channel)</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="comment">// 连接 socketChannel 与 socket</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> socketChannel.socket();</span><br><span class="line">        <span class="comment">// 建立客户端 socket 与服务器 serverSocket 的连接</span></span><br><span class="line">        socket.connect(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TCP连接需要一定时间，两个连接的建立需要进行“三次握手”</span></span><br><span class="line">        <span class="comment">// 可以调用 finishConnect() 方法查看连接是否完成，如果没有连接成功返回false</span></span><br><span class="line">        <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在连接中，请稍后...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功! ^_^&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向服务器发送消息[客户端代码 -&gt; Buffer -&gt; 客户端Channel -&gt; 服务器Channel]</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charsets.UTF_8.encode(<span class="string">&quot;Hello, I&#x27;m form client socket&quot;</span>);</span><br><span class="line">        System.out.println(buffer.position());</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得服务器发送给客户端的消息(服务器返回 -&gt; 客户端Channel -&gt; buffer -&gt; 打印输出)</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socketChannel.socket().getInputStream();</span><br><span class="line">        <span class="type">ReadableByteChannel</span> <span class="variable">newChannel</span> <span class="operator">=</span> Channels.newChannel(inputStream);</span><br><span class="line">        <span class="comment">// 读 newChannel 中的数据到 buffer 中</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        newChannel.read(buffer);</span><br><span class="line">        <span class="comment">// 展示buffer中的数据</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(Charsets.UTF_8.decode(buffer));</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="第四章-选择器-Selector"><a href="#第四章-选择器-Selector" class="headerlink" title="第四章 选择器[Selector]"></a>第四章 选择器[Selector]</h1><h2 id="1-选择器基础"><a href="#1-选择器基础" class="headerlink" title="1. 选择器基础"></a>1. 选择器基础</h2><p>选择器提供了一种<strong>选择执行已经就绪任务的能力</strong>。</p>
<blockquote>
<p><strong>已就绪任务</strong>：该任务已经从操作系统内核返回用户态的进程空间了，对程序而言，这就是“就绪”了。</p>
</blockquote>
<p>Selector 选择器允许单线程处理多个通道。</p>
<p>如果服务器同时维护着多个连接通道，并且每个连接通道的流量都比较低，这时候就可以使用 Selector 来管理多个通道。</p>
<p>一个线程维护一个 Selector 实例，一个 Selector 实例维护多个 Channel 通道，这样就实现了一个线程同时管理多个 Channel 通道。 </p>
<p><img src="http://processon.com/chart_image/62b453cdf346fb075472e93a.png" alt="img"></p>
<ul>
<li>要使用 Selector 选择器，就需要向 Selector 实例注册 Channel 实例，注册成功后会返回一个维护 Channel 与 Selector 间关系的对象(SelectionKey)，并在 SelectionKey 实例中记录当前 Selector 关心的通道和通道中发生的操作。选择键 selectionKey 会追踪通道是否就绪。</li>
<li>selector 实例可以调用它的 <code>select()</code> 方法，来获取其关联的 selectionKey 的最新状态(调用 <code>select()</code> 方法后，与 selector 实例关联的所有的 channel 的信息都会被更新)。以此来检查所有被注册到 selector 的 channel 的最新消息，可以选择出两次调用 <code>selec()</code> 方法的间隔内新就绪的 channel。</li>
<li>Selector 选择器提供了一种询问 Channel 通道是否已经准备好执行 I/O 操作的能力。比如：了解 ServerSocketChannel 是否有新的连接，SocketChannel 是否还有更多的字节需要读取。</li>
</ul>
<h3 id="1-1-三个相关的类"><a href="#1-1-三个相关的类" class="headerlink" title="1.1 三个相关的类"></a>1.1 三个相关的类</h3><p><strong>Selector 选择器</strong></p>
<ul>
<li>Selector 选择器对象通过 SelectionKey 对象管理着所有注册成功的通道(Channel)，包括通道的基本信息和就绪状态。</li>
</ul>
<p><strong>SelectableChannel 可被选择的通道</strong></p>
<ul>
<li><p>SelectableChannel 是一个抽象类，是所有支持就绪检查的通道类的基类。</p>
</li>
<li><p>注意：FileChannel 不是 SelectableChannel 的子类，即 FileChannel 是不能注册到 Selector 选择器上的。</p>
</li>
<li><p>一个 selectableChannel 实例可以注册到多个 selector 实例上，但是不能多次注册到同一个一个选择器上。</p>
<p>  <img src="http://processon.com/chart_image/62b471935653bb104192d9ed.png" alt="img"></p>
</li>
</ul>
<p><strong>SelectionKey 选择键</strong></p>
<ul>
<li>SelectionKey 封装了 selectableChannel 与 selector 之间的一种关联关系。</li>
<li>selectionKey 包含了两个 byte 集合，一个指示注册关系所关心的通道操作，另一个表示通道已经准备好的操作。</li>
</ul>
<h3 id="1-2-如何创建Selector选择器"><a href="#1-2-如何创建Selector选择器" class="headerlink" title="1.2 如何创建Selector选择器"></a>1.2 如何创建Selector选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建Selector实例[工厂模式]</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、channel通道必须设置为非阻塞模式才能注册到Selector选择器上</span></span><br><span class="line"><span class="type">SelectableChannel</span> <span class="variable">selectableChannel1</span> <span class="operator">=</span> ...;</span><br><span class="line">selectableChannel1.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 创建两个channel实例</span></span><br><span class="line"><span class="type">SelectableChannel</span> <span class="variable">selectableChannel2</span> <span class="operator">=</span> ...;</span><br><span class="line">selectableChannel2.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、把channel通道的OP_READ事件注册到selector上，会返回一个选择键(SelectionKey实例)</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> selectableChannel1.register(selector, SelectionKey.OP_READ); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     arg1：把channel通道注册到哪个selector上；</span></span><br><span class="line"><span class="comment">     arg2：selector选择器关注channel通道中的哪些操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用位运算符把selector关注的多种操作连接起来</span></span><br><span class="line">selectableChannel2.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     SelectionKey 包含的操作有：</span></span><br><span class="line"><span class="comment">         1) OP_CONNECT  通道中是否发生了“客户端请求连接服务器”的事件   </span></span><br><span class="line"><span class="comment">         2) OP_ACCEPT  只有 ServerSocketChannel 有这个事件，通道中是否发生了“查看新的连接”的事件</span></span><br><span class="line"><span class="comment">         3) OP_READ  通道中是否发生了“读操作准备就绪”事件</span></span><br><span class="line"><span class="comment">         4) OP_WRITE  通道中是否发生了“写操作准备就绪”事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、注册完成后，可调用 select() 方法轮询是否有就绪的通道</span></span><br><span class="line"><span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> selector.select(); <span class="comment">// select()方法返回就绪通道的数量</span></span><br></pre></td></tr></table></figure>





<h2 id="2-SelectionKey相关的方法"><a href="#2-SelectionKey相关的方法" class="headerlink" title="2. SelectionKey相关的方法"></a>2. SelectionKey相关的方法</h2><p>向 Selector 注册一个 Channel 通道时，就会返回一个 SelectionKey 选择键对象，这个 selectionKey 对象表示一个通道与一个选择器之间的关联关系。</p>
<p><img src="http://processon.com/chart_image/62b453cdf346fb075472e93a.png" alt="img"></p>
<p><strong>selectionKey 对象中的方法：</strong></p>
<ul>
<li><p>channel()    返回该键对应的通道</p>
</li>
<li><p>selector()    返回该键对应的选择器</p>
</li>
<li><p>cancel()    删除选择器与通道间的关联关系</p>
</li>
<li><p>isValid()    判断选择器与通道的关联关系是否有效</p>
</li>
<li><p>interestOps()    返回 selector 对象关注的该通道中的操作/事件。</p>
<ul>
<li><p>返回结果是一个整数，该整数是一个比特掩码，可以使用位运算符检查所关心的操作。如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 selector 对象关注的该通道中的事件的编码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该编码是否对应 SelectionKey.OP_READ </span></span><br><span class="line"><span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> interestOps &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">if</span> (key == SelectionKey.OP_READ)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是一个 SelectionKey.OP_READ 事件&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>readyOps()    返回通道中已经就绪的操作。</p>
<ul>
<li>返回值也是一个整数，也可以使用类似上面的位运算操作检测通道中有哪个事件/操作已经准备就绪。</li>
</ul>
</li>
<li><p>除了按位与操作外，还可以使用 selectionKey 对象的 isReadable()、isWritable()、isConnectable()、isAccetable() 等方法来检测通道中哪些事件已就绪。</p>
</li>
</ul>
<h2 id="3-使用选择器"><a href="#3-使用选择器" class="headerlink" title="3. 使用选择器"></a>3. 使用选择器</h2><p>Selector 选择器通过 SelectionKey 对象维护着所有注册成功的集合通道。</p>
<p>每个 Selector 对象都有以下三个集合：</p>
<ul>
<li>已注册的 selectionKey 对象集合(<code>Set&lt;SelectionKey&gt;</code> )：通过 <code>selector.keys()</code> 方法返回这个集合。</li>
<li>已就绪的 selectionKey 对象集合：通过 <code>selector.selectedkeys()</code> 方法返回。该集合中的每个成员都是相关通道及关注的事件被选择器判断已经准备好了的。</li>
<li>已取消的 selectionKey 对象集合：这个集合包含了调用过 cancel() 方法的 selectionKey 对象集合。</li>
</ul>
<p>对于新创建的 Selector 对象，这三个集合都为空。</p>
<br>

<p>Selector 类的核心就是 select() 选择，该方法调用时，执行以下步骤：</p>
<ol>
<li>检查 <code>已取消的 selectionKey 对象集合</code>，如果该集合非空，就把该集合中的 selectionKey 对象从另外两个集合中移除，并注销相关的通道。该步骤结束后，<code>已取消的 selectionKey 对象集合</code> 应该是空的。</li>
<li>检查 <code>Set&lt;SelectionKey&gt;</code> 集合中所有 selectionKey 对象的 interset 集合，判断每个通道所关注的操作/事件是否已经就绪。</li>
<li>返回两次调用 <code>select()</code> 方法的时间间隔内进入就绪状态的通道的数量。</li>
</ol>
<p><strong>基本操作流程：</strong></p>
<p>通常使用以下方法来管理这些键：</p>
<ol>
<li>调用选择器对象的 select() 方法，如果就绪通道的数量大于 0，则执行下一步。</li>
<li>遍历 <code>selector.selectedkeys()</code> 方法的返回结果，得到所有已就绪的通道及通道中事件的数据：<ol>
<li>检查集合中的每个元素，查看相关通道的就绪信息，并进行处理；</li>
<li>处理完毕后，将 selectionKey 从  <code>Set&lt;SelectionKey&gt;</code> 集合中移除；</li>
<li>继续检查下一个元素。</li>
</ol>
</li>
</ol>
<p><strong>通用代码模板：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/25 16:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 服务端选择器模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerSelectorTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        serverSocketChannel.bind(address);</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 将serverSocketChannel的OP_ACCEPT事件注册到selector上</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 持续监听</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 接受连接</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// 读数据</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable())&#123;</span><br><span class="line">                    <span class="comment">// 写数据</span></span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 移除处理完的selectionKey</span></span><br><span class="line">                selectionKeys.remove(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="动力节点"><a href="#动力节点" class="headerlink" title="动力节点"></a>动力节点</h1><h2 id="JVM读取数据模型"><a href="#JVM读取数据模型" class="headerlink" title="JVM读取数据模型"></a>JVM读取数据模型</h2><p><img src="http://processon.com/chart_image/62a86862e0b34d294473999b.png"></p>
<p>假设现在的场景是一个Java程序从磁盘上读取数据。</p>
<p>任何程序都是运行在操作系统之上的，所以还会涉及到一个操作系统的内核空间，由操作系统内核来真正读取磁盘上的数据。在读取数据时，内核会启动一个磁盘控制器组件来读取磁盘上的数据到操作系统内核的缓冲区中。这个读取过程叫做DMA（Direct Memory Access）。</p>
<p>而我们的 Java 程序是从操作系统内核的缓冲区中读取的数据。把操作系统的缓冲区的数据读取到JVM的内存中。</p>
<p>这就是一个最简单的Java程序读取磁盘数据的模型。</p>
<p>对于目前的计算机，程序在读取数据的时候，CPU的处理速度往往不是程序运行效率的短板，CPU的处理速度非常快。更多的时候，程序运行的快慢是由I/O的效率决定的。</p>
<p>对于现代计算机的操作系统，它的IO性能已经发展的非常好了，操作系统可以快速的传输数据。</p>
<p>但对于JVM而言，它为了提供统一的操作环境，它对一些操作系统的强大的功能给屏蔽了，也就是说，由于JVM自身在IO方面的效率不足，导致了程序运行的效率变慢。在操作系统中，它可以从硬件上很快的读取数据到缓冲区，但是JVM的IO只能慢速地从缓冲区读取数据。</p>
<p>从JDK4开始，引入了NIO，在很大程序上提升了Java程序的IO效率。</p>
<p>主要有以下这些包：</p>
<ul>
<li>  <code>java.nio.*</code>：定义了各种与Buffer相关的API</li>
<li>  <code>java.nio.channel.*</code>：定义了与Channel和Selector相关的API</li>
<li>  <code>java.nio.charset.*</code>：定义了与字符集相关的API</li>
</ul>
<h2 id="NIO与传统IO的区别"><a href="#NIO与传统IO的区别" class="headerlink" title="NIO与传统IO的区别"></a>NIO与传统IO的区别</h2><p>传统的IO是面向流的，每次可以从流中读取一个或多个字节，只能向后读取，不能向前移动。</p>
<p>NIO是面向缓冲区的，把数据读到一个缓冲区中，可以在缓冲区中向前/向后移动，增加了程序的灵活性。</p>
<p>在NIO中，所有的数据都需要通过Channel传输，通道可以直接将一块数据映射到内存中。</p>
<p>Channel是双向的，不仅可以读取数据，还能保存数据。程序不能直接读写Channel通道，Channel只与Buffer缓冲区交互。</p>
<p>Java程序在读数据的时候，会先把数据源（比如操作系统中的缓冲区）上的数据读到Channel，通过Channel将数据传递到Buffer，Java程序是从Buffer中读取数据。</p>
<p><img src="http://processon.com/chart_image/62a87a9f1efad4656677a49d.png"></p>
<p>传统IO（IO流）是线程阻塞的。在调用 read()/write() 读写数据时，线程会阻塞，直到数据读/写完毕。在读写过程中，线程不能执行其它任务。</p>
<p>NIO是线程不阻塞的。当线程从Channel中读取数据时，如果通道中没有可用的数据，线程不会阻塞，可以继续做其它的任务。</p>
<hr>
<hr>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="1-Channel概述-1"><a href="#1-Channel概述-1" class="headerlink" title="1. Channel概述"></a>1. Channel概述</h2><p>Channel 是一种新的 I/O 的访问方式，用于在字节缓冲区与通道另一侧的实体(可以是文件也可以是 Socket)之间进行数据的传输。</p>
<p>Channel 可以双向读写数据，也可以实现异步读写。</p>
<p>程序不能直接访问 Channel，Channel 只能与 Buffer 缓冲区进行交互。即：在执行读操作时，需要先把通道中的数据读到 Buffer 缓冲区中，程序再从 Buffer 中读取数据；在执行写操作时，程序会先把数据写入 Buffer 缓冲区中，再把 Buffer 中的数据写到 Channel 中。</p>
<p>常用的 Channel 有：</p>
<ul>
<li>  FileChannel  读写文件的通道。</li>
<li>  DatagramChannel  通过UDP读写网络数据的通道。</li>
<li>  SocketChannel/ServerSocketChannel  读写Socket套接字中数据的通道。</li>
</ul>
<h2 id="2-Scatter-Gather"><a href="#2-Scatter-Gather" class="headerlink" title="2. Scatter/Gather"></a>2. Scatter/Gather</h2><p>有时候如果能从一个源填充到多个缓冲区，这会很有用。这称为**散布(Scatter)**。下面两个方法接收一个 ByteBuffer 数组作为参数，按顺序填充数组中的多个 ByteBuffer。</p>
<blockquote>
<p>所在类：interface ScatteringByteChannel</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">read</span><span class="params">(ByteBuffer[] dsts, <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>第一个方法填充所有缓冲区。第二个方法则从位于 offset 的缓冲区开始，填充 length 个缓冲区。</p>
<p>在填充缓冲数组时，常用的代码范式如下，只要列表中最后一个缓冲区还有剩余空间，就可以继续填充。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer[] buffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[<span class="number">2</span>];</span><br><span class="line">buffers[<span class="number">0</span>] =ByteBuffer.allocate(<span class="number">1000</span>);</span><br><span class="line">buffers[<span class="number">1</span>] =ByteBuffer.allocate(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">while</span> (buffers[<span class="number">1</span>].hasRemaining() &amp;&amp; channel.read(buffers) != -<span class="number">1</span>)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将多个缓冲区的数据写入到一个 Socket 通常很有用。这称为**聚集(Gather)**。例如，你可能希望在一个缓冲区存储 HTTP 首部，在另一个缓冲区存储 HTTP 主体。具体实现甚至可使用两个线程同时填充这两个缓冲区。下面两个方法接受一个 ByteBuffer 对象作为参数，并按顺序依次排空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">write</span><span class="params">(ByteBuffer[] srcs, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>第一个方法依次排空所有缓冲区。第二个方法则从位于 offset 的缓冲区开始，排空 length 个缓冲区。</p>
<p><strong>分散读，集中写</strong></p>
<p>Scatter(分散) 和 Gather(集中)是通道提供的一个重要功能。Scatter、Gather 是指在多个缓冲区中实现一个简单的 IO 操作(有时也被称为矢量 IO)。</p>
<p>Scatter 是指从 Channel 通道中读取数据，把这些数据按顺序分散写入到多个 Buffer 缓冲区中。</p>
<ul>
<li>  从 Channel 中读取数据，先把数组存储到 buffer1 缓冲区中；</li>
<li>  buffer1 缓冲区满了之后，再把通道中的数据写入到 buffer2，当 buffer2 也写满之后，最后把数据写到 buffer3 中。</li>
</ul>
<p><img src="http://processon.com/chart_image/62aef1cd1efad41af0432596.png"></p>
<p>Gather 是指在写操作时，将多个 Buffer 缓冲区中的数据写到同一个 Channel 中。</p>
<ul>
<li>  Gather 先把 buffer1 中的数据写到 Channel 中；</li>
<li>  再把 buffer2 中的数据写到 Channel 中；</li>
<li>  最后把 buffer3 中的数据写到 Channel 中。</li>
</ul>
<p><img src="http://processon.com/chart_image/62aef4d1e401fd5a4d73630a.png"></p>
<p>Scatter、Gather 经常用于需要将传输的数据分开的场景。</p>
<p>如 Scatter 从一个 Channel 中读取数据存储到多个 Buffer 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">ByteBuffer[] bufferArray = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1, buffer2, buffer3&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">channel.read(bufferArray); <span class="comment">// 从bufferArray中读取数据</span></span><br></pre></td></tr></table></figure>

<p>使用 read() 方法从 channel 中读取数据，将 channel 中的顺序按照 bufferArray 数组中 buffer 的顺序依次存储到缓冲区中。</p>
<p>注意：必须在 buffer1 缓冲区写满后才能写入 buffer2 缓冲区。</p>
<p>使用 Scatter/Gather 处理的数据大小都是固定的。</p>
<h2 id="3-FileChannel-1"><a href="#3-FileChannel-1" class="headerlink" title="3. FileChannel"></a>3. FileChannel</h2><p>FileChannel 可以通过 RandomAccessFile、FileInputStream 或 FileOutputStream 对象调用 <code>getChannel()</code> 方法获取。</p>
<p>FileChannel 虽然是双向的，既有 read() 方法又有 write() 方法。但是根据 FileInputStream 获得的通道是只读的，如果调用 write() 方法会产生异常。并且如果访问的文件是只读属性的，也不能执行 write() 写操作。</p>
<p>FileChannel 对象是线程安全的，不过并非所有的线程操作都是多线程的，影响通道位置或者影响文件大小的操作都是单线程的。即如果有一个线程在执行会影响通道位置的操作，那么其它尝试此类操作的线程需要等待。</p>
<h3 id="3-1-内存映射文件"><a href="#3-1-内存映射文件" class="headerlink" title="3.1 内存映射文件"></a>3.1 内存映射文件</h3><p>FileChannel 常用的三类方法：<code>map()</code>、<code>read()</code> 和 <code>write()</code>。</p>
<p>map() 方法会创建一个由磁盘文件支持的虚拟内存映射，并在这块虚拟内存空间上封装一个 MappedByteBuffer 对象。需要注意的是：为一个文件建立虚拟内存映射后，文件数据通常不会从硬盘读到内存。当然这并非是绝对的，这取决于操作系统。</p>
<p><code>read()/write()</code> 方法的作用是从 Buffer 中读写数据。</p>
<p>通过内存映射机制访问文件会比常规方法更高效，因为不需要做明确的系统调用，操作系统的虚拟内存可以自动缓存内存页，这些是使用系统内存缓存的，不会消耗 JVM 的堆内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存映射文件：</span></span><br><span class="line"><span class="comment"> *  即把磁盘上某个文件的数据映射到虚拟内存中，以这种方式访问文件数据的效率比较高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 把当前类文件(ChannelTest.java)以内存映射的方式读到 out.txt 文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件的 File 对象</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src/test/java/com/donglijiedian/buffer/ChannelTest.java&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 Channel 读取文件内容</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="comment">// 创建输出Channel，用于把文件把存到 out.txt 文件中</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>).getChannel();</span><br><span class="line">    <span class="comment">// 将 inChannel 中的数据映射到虚拟内存中</span></span><br><span class="line">    <span class="type">MappedByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, file.length());</span><br><span class="line">    <span class="comment">// 把缓冲区中的数据输出到 outChannel 中</span></span><br><span class="line">    outChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以把 buffer 中的内容打印出来</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> Charsets.UTF_8.decode(buffer);</span><br><span class="line">    System.out.println(charBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-2-FileChannel双向传输"><a href="#3-2-FileChannel双向传输" class="headerlink" title="3.2 FileChannel双向传输"></a>3.2 FileChannel双向传输</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-3-缓冲区设置固定大小"><a href="#3-3-缓冲区设置固定大小" class="headerlink" title="3.3 缓冲区设置固定大小"></a>3.3 缓冲区设置固定大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读写文件时，设置缓冲区为固定大小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 把 data.txt 文件的内容复制到 data_backup.txt 文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、磁盘(data.txt) -&gt; Channel -&gt; Buffer</span></span><br><span class="line">    <span class="comment">// 2、Buffer -&gt; Channel -&gt; 磁盘(data_backup.txt)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data_backup.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">srcChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">dstChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 srcChannel 中读数据写到 buffer 中</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> srcChannel.read(byteBuffer);</span><br><span class="line">    <span class="keyword">while</span> (readBytes != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 把 buffer 中的内容写到 dstChannel 中</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        dstChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">// 继续读 srcChannel 中的内容到 buffer 中</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        readBytes = srcChannel.read(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 dstChannel 到 data_backup.txt 的过程自动完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-Channel到Channel的传输"><a href="#3-4-Channel到Channel的传输" class="headerlink" title="3.4 Channel到Channel的传输"></a>3.4 Channel到Channel的传输</h3><p>如果经常需要将文件从一个位置传输到另一个位置，可以直接使用通道与通道之间的传输，而不需要中间缓冲区(Buffer)来传递数据。</p>
<p>Channel 到 Channel 间的传输是及其快速的，特别是在底层操作系统提供本地支持的时候，有的操作系统可以不经过用户空间而是直接使用内核空间传输数据。</p>
<blockquote>
<p>  <strong>注意：</strong></p>
<p>  只有 FileChannel 类有这两个方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通道与通道之间数据的传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  把 data.txt 复制到 data_backup.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data_backup.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 inChannel 从 0 开始的所有字节传输到 outChannel 中</span></span><br><span class="line">    <span class="comment">//inChannel.transferTo(0, file.length(), outChannel); // 等价表达</span></span><br><span class="line">    outChannel.transferFrom(inChannel, <span class="number">0</span>, file.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-Gather"><a href="#3-5-Gather" class="headerlink" title="3.5 Gather"></a>3.5 Gather</h3><h2 id="4-SocketChannel和ServerSocketChannel"><a href="#4-SocketChannel和ServerSocketChannel" class="headerlink" title="4. SocketChannel和ServerSocketChannel"></a>4. SocketChannel和ServerSocketChannel</h2><hr>
<h2 id="5-DatagramChannel"><a href="#5-DatagramChannel" class="headerlink" title="5. DatagramChannel"></a>5. DatagramChannel</h2><p>DatagramChannel 是对 UDP 无连接用户数据报协议的通道。</p>
<p><strong>DatagramChannelServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/22 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * UDP 没有所谓的客户端和服务器端，服务器和客户端在实现上没有什么区别，</span></span><br><span class="line"><span class="comment"> * 所以需要人为地给设置哪个机器是客户端，哪个机器是服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 模拟服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatagramChannelServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个初始通道(未绑定Socket)的通道</span></span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">datagramChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、初始化通道(绑定本地机器的IP和端口号)</span></span><br><span class="line">        datagramChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9090</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、设置为非阻塞模式</span></span><br><span class="line">        datagramChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器启动后，持续监听，等待客户端发送数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 接收客户端发送的数据，写到buffer中</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> (InetSocketAddress)datagramChannel.receive(buffer);</span><br><span class="line">            <span class="comment">// 如果没有客户端向服务器发送数据，address默认为null</span></span><br><span class="line">            <span class="comment">// 没有客户端发送数据</span></span><br><span class="line">            <span class="keyword">if</span> (address == <span class="literal">null</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有客户端发送数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端IP：&quot;</span> + address);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端端口号：&quot;</span> + address.getPort());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端发送的数据：&quot;</span> + Charsets.UTF_8.decode(buffer));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回数据给客户端</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">// arg1:发送给客户端的内容。  arg2：客户端地址</span></span><br><span class="line">            datagramChannel.send(Charsets.UTF_8.encode(content), address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/22 21:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *  DatagramChannel 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatagramChannelClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器IP和进程端口号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 datagramChannel，但无需初始化，由随机分配的端口号发送数据</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">serverAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT);</span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">datagramChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">        datagramChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(Charsets.UTF_8.encode(line));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 buffer 中的数据发送到服务器</span></span><br><span class="line">            buffer.flip();  <span class="comment">// 切换到读模式</span></span><br><span class="line">            datagramChannel.send(buffer, serverAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收服务器返回的数据</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">SocketAddress</span> <span class="variable">receive</span> <span class="operator">=</span> datagramChannel.receive(buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 receive=null 时，表示未接收到数据</span></span><br><span class="line">            <span class="keyword">while</span> (receive == <span class="literal">null</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;正在等待服务器端的响应结果......&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(Charsets.UTF_8.decode(buffer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-Pipe"><a href="#6-Pipe" class="headerlink" title="6. Pipe"></a>6. Pipe</h2><p>Pipe(管道)：用于在两个线程之间进行单向的数据传输。</p>
<p>数据传输过程如下图所示：</p>
<p>Pipe 由 Source 通道和一个 Sink 通道两部分组成。线程A负责把数据写到 Sink 通道中，线程B负责从 Source 通道中获取数据。在管道中完成数据从 Sink 通道到 Source 通道的传递。</p>
<p><img src="http://processon.com/chart_image/62b322b7e0b34d0712cdaa9a.png"></p>
<p><strong>Tip：</strong>Pipe 是一个管道，但是它有两个通道(Channel)。</p>
<blockquote>
<p><strong>Pipe 使用说明：</strong></p>
</blockquote>
<ol>
<li><p>创建 Pipe 实例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pipe</span> <span class="variable">pipe</span> <span class="operator">=</span> Pipe.open();</span><br></pre></td></tr></table></figure></li>
<li><p>向管道中写数据(向 sink 通道中写数据)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写数据首先要拿到 Sink 通道对象</span></span><br><span class="line">Pipe.<span class="type">SinkChannel</span> <span class="variable">sinkChannel</span> <span class="operator">=</span> pipe.sink();</span><br><span class="line"><span class="comment">// 将数据保存到 buffer 对象中</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charsets.UTF_8.encode(<span class="string">&quot;Hello Pipe&quot;</span>);</span><br><span class="line"><span class="comment">// 向 sink 通道中写数据</span></span><br><span class="line">sinkChannel.write(buffer);</span><br></pre></td></tr></table></figure></li>
<li><p>从管道中读数据(从 source 通道中读数据)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读数据首先要拿到 source 通道对象</span></span><br><span class="line">Pipe.<span class="type">SourceChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> pipe.source();</span><br><span class="line">buffer.flip(); <span class="comment">// 切换为读模式</span></span><br><span class="line"><span class="comment">// 从 source 通道中读数据</span></span><br><span class="line">sourceChannel.read(buffer);</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Pipe;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/22 22:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 演示在两个线程之间通过 Pipe 管道实现数据的传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.io.PipedOutputStream&#125; 和 &#123;<span class="doctag">@link</span> java.io.PipedInputStream&#125;</span></span><br><span class="line"><span class="comment"> * 分别是管道输出流类和管道输入流类。</span></span><br><span class="line"><span class="comment"> * 在管道通信时，线程A向 &#123;<span class="doctag">@link</span> java.io.PipedOutputStream&#125; 中写入数据，这些数据会</span></span><br><span class="line"><span class="comment"> * 自动发送到对应的 &#123;<span class="doctag">@link</span> java.io.PipedInputStream&#125; 中，线程B就可以从 &#123;<span class="doctag">@link</span> java.io.PipedInputStream&#125;</span></span><br><span class="line"><span class="comment"> * 中读取数据，从而实现线程A到线程B的数据传输。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 输入流对象和输出流对象</span></span><br><span class="line">        <span class="type">PipedInputStream</span> <span class="variable">pipedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedInputStream</span>();</span><br><span class="line">        <span class="type">PipedOutputStream</span> <span class="variable">pipedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedOutputStream</span>();</span><br><span class="line">        <span class="comment">// 在输入流对象和输出流对象之间建立连接[重要]</span></span><br><span class="line">        pipedInputStream.connect(pipedOutputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程</span></span><br><span class="line">        <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>(pipedOutputStream);</span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>(pipedInputStream);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sender).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(receiver).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送数据的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedOutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sender</span><span class="params">(PipedOutputStream outputStream)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.outputStream = outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟发送数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello, sender：&quot;</span> + i + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">                <span class="comment">// 将字符串数据写到outputStream流中</span></span><br><span class="line">                outputStream.write(text.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收数据的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PipedInputStream inputStream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Receiver</span><span class="params">(PipedInputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inputStream = inputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">                len = inputStream.read(bytes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<hr>
<h1 id="咕泡教育"><a href="#咕泡教育" class="headerlink" title="咕泡教育"></a>咕泡教育</h1><h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2. ByteBuffer"></a>2. ByteBuffer</h2><h3 id="2-3-Buffer常见方法"><a href="#2-3-Buffer常见方法" class="headerlink" title="2.3 Buffer常见方法"></a>2.3 Buffer常见方法</h3><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>可以使用 allocate() 方法为 ByteBuffer 分配空间，其它 XxxBuffer 类也有类似的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  在 NIO 中，buffer 空间的大小，一经分配，就不能再发生改变。而在 Netty 中对这一点做了增强，Netty 支持对 buffer 的大小进行后修改。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testByteBufferAllocate</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(ByteBuffer.allocate(<span class="number">16</span>).getClass()); <span class="comment">//class java.nio.HeapByteBuffer</span></span><br><span class="line">    System.out.println(ByteBuffer.allocateDirect(<span class="number">16</span>).getClass()); <span class="comment">//class java.nio.DirectByteBuffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        class java.nio.HeapByteBuffer</span></span><br><span class="line"><span class="comment">            - Buffer空间使用的是JVM的堆内存。</span></span><br><span class="line"><span class="comment">            - 与操作系统的直接内存相比，堆内存的读写效率较低。</span></span><br><span class="line"><span class="comment">            - 堆内存空间会受到GC的影响。（可能会在GC时发生数据的移动，降低效率）</span></span><br><span class="line"><span class="comment">       **********************************************************</span></span><br><span class="line"><span class="comment">        class java.nio.DirectByteBuffer</span></span><br><span class="line"><span class="comment">            - Buffer空间使用的是直接内存。</span></span><br><span class="line"><span class="comment">            - 直接内存的读写效率较高。因为它相比于JVM堆内存少一次数据的拷贝。</span></span><br><span class="line"><span class="comment">            - 使用的是系统内存，不会受到GC的影响。</span></span><br><span class="line"><span class="comment">            - 缺点：</span></span><br><span class="line"><span class="comment">                - 需要调用操作系统来分配内存，分配时的效率较低。</span></span><br><span class="line"><span class="comment">                - 如果使用不当，可能会造成内存泄露。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="向Buffer中写入数据"><a href="#向Buffer中写入数据" class="headerlink" title="向Buffer中写入数据"></a>向Buffer中写入数据</h4><p>有两种方法。</p>
<ol>
<li><p>调用 channel 的 read() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取channel中的数据，写到buffer中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>

</li>
<li><p>调用 buffer 自己的 put() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.put((<span class="type">byte</span>) <span class="number">127</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h4><p>同样有两种办法。</p>
<ol>
<li><p>调用 channel 的 write() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将buffer中的数据写到channel中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buffer);</span><br></pre></td></tr></table></figure></li>
<li><p>调用 buffer 自己的 get() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buffer.get();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get() 方法会让 position 指针向后走，如果想重复读取数据</p>
<ul>
<li>  可以调用 rewind() 方法将 position 重新置为 0。</li>
<li>  或者调用 get(int index) 获取索引 index 的内容，它不会移动指针。</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_rewind_and_getX</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    buffer.flip(); <span class="comment">// buffer的初始模式为写模式，如需读取数据需要切换为读模式</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//1</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//2</span></span><br><span class="line">    buffer.rewind();</span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//1</span></span><br><span class="line">    System.out.println(buffer.get(<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="mark-amp-reset"><a href="#mark-amp-reset" class="headerlink" title="mark &amp; reset"></a>mark &amp; reset</h4><ul>
<li>  mark：做一个标记，记录 position 的位置</li>
<li>  reset：将 position 重置到 mark 的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_mark_and_reset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//1</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//2</span></span><br><span class="line">    buffer.mark(); <span class="comment">//加标记</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//3</span></span><br><span class="line">    buffer.reset(); <span class="comment">//回到标记</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//3</span></span><br><span class="line">    buffer.reset();</span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h4><p><strong>字符串–&gt;ByteBuffer</strong></p>
<ol>
<li><p>手动分配buffer，手动将字符串转为字节数据，并添加到buffer中</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、字符串 --&gt; ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">buffer1.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li>
<li><p>Charset</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、Charset</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>wrap()</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、wrap()</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>  <strong>Tip</strong></p>
<p>  方式二和方式三在完成字符串到ByteBuffer的转换后，会自动将当前模式切换到读模式，在读模式下可以直接读取Buffer中的数据。而在方式一中，必须手动切换为读模式才能正常读到Buffer中的数据。</p>
</blockquote>
<p><strong>ByteBuffer –&gt; 字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StandardCharsets</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(buffer2).toString();</span><br><span class="line">System.out.println(string); <span class="comment">//hello</span></span><br></pre></td></tr></table></figure>





<h3 id="2-4-Scattering-Reads"><a href="#2-4-Scattering-Reads" class="headerlink" title="2.4 Scattering Reads"></a>2.4 Scattering Reads</h3><blockquote>
<p>  <strong>分散读，集中写</strong></p>
</blockquote>
<p>分散读取。</p>
<p><strong>需求：</strong>已知一个文本文件 3parts.txt。文件的三部分分别是3、3、5个字节。需要将这个文件读取到Buffer中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onetwothree</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>  思路一：将这三部分的内容（3+3+5=11字节）全部读到一个 ByteBuffer 中，之后再利用其它手段将ByteBuffer拆分为三部分。</li>
<li>  思路二：在读取的时候按照 3/3/5 字节将这个文件中的内容读取到三个 ByteBuffer 中。这种方式就叫做 Scattering Reads（分散读）</li>
</ul>
<p><strong>演示：</strong></p>
<p>使用如下方式读取，可以将数据填充到三个Buffer中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分散读（测试用例）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScatteringReads</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src/main/resources/3parts.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 从channel中读数据写到多个buffer中</span></span><br><span class="line">    channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">    <span class="comment">// 尝试打印查看buffer中是否已经写入了数据</span></span><br><span class="line">    buffer1.flip();</span><br><span class="line">    buffer2.flip();</span><br><span class="line">    buffer3.flip();</span><br><span class="line">    System.out.println((<span class="type">char</span>) buffer1.get(<span class="number">0</span>)); <span class="comment">//o</span></span><br><span class="line">    System.out.println((<span class="type">char</span>) buffer2.get(<span class="number">0</span>)); <span class="comment">//t</span></span><br><span class="line">    System.out.println((<span class="type">char</span>) buffer3.get(<span class="number">1</span>)); <span class="comment">//h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-5-Gathering-Writes"><a href="#2-5-Gathering-Writes" class="headerlink" title="2.5 Gathering Writes"></a>2.5 Gathering Writes</h3><p>集中写</p>
<p><strong>需求：</strong>已有 3 个 ByteBuffer，先需将这 3 个 ByteBuffer 写入到一个文件中。</p>
<p><strong>思路：</strong></p>
<ul>
<li>  思路一：先将这 3 个 ByteBuffer 组合成一个更大的 ByteBuffer，再将大的 ByteBuffer 写入到文件中。</li>
<li>  思路二：按照一定的顺序分别将这 3 个 ByteBuffer 写到同一个文件中（追加写）。</li>
</ul>
<p><strong>演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集中写（测试用例）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGatheringWrites</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;am&quot;</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;are&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;3parts2.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    channel.write(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结束后，查看文件可以看到数据已经写入。</p>
<hr>
<h2 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3. 文件编程"></a>3. 文件编程</h2><h3 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h3><blockquote>
<p>  <strong>注意</strong></p>
<p>  FileChannel 只能工作在阻塞模式下，不能配合 Selector 使用。只有网络编程中的 Channel，如 SocketChannel 等才能配合 Selector 工作在非阻塞模式下。</p>
</blockquote>
<p><strong>获取：</strong></p>
<p>FileChannel 不能直接创建，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 <strong>getChannel()</strong> 方法。</p>
<ul>
<li>  通过 FileInputStream 获取的 Channel 只能读；</li>
<li>  通过 FileOutputStream 获取的 Channel 只能写；</li>
<li>  通过 RandomAccessFile 获取的 Channel 的读写权限根据构造 RandomAccessFile 时的读写模式决定。</li>
</ul>
<p><strong>读取：</strong></p>
<p>读取 channel 中的数据写入到 buffer 中。返回值表示读取到了多少字节，<code>-1</code> 表示读取到了文件的末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>



<p><strong>写入：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ...;</span><br><span class="line">buffer.put(...); <span class="comment">//存入数据</span></span><br><span class="line">buffer.flip(); <span class="comment">//切换到读模式</span></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 while 中调用 channel.write() 方法时因为 write() 方法不能保证一次将 buffer 中的内容全部写入 channel 中。</p>
<p><strong>关闭：</strong></p>
<p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close() 方法会间接地调用 channel 的 close() 方法。</p>
<p><strong>位置：</strong></p>
<ul>
<li><p>获取当前位置</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();</span><br></pre></td></tr></table></figure></li>
<li><p>设置当前位置</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">newPos</span> <span class="operator">=</span> ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></table></figure>

<ul>
<li>设置当前位置时，如果设置为文件的末尾：<ul>
<li>  这时读会返回 <code>-1</code>；</li>
<li>  这时写入，会追加内容。但要注意，如果 position 超过了文件末尾，在执行写入时新内容和原末尾之间会用 0 填充。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>大小：</strong></p>
<p>使用 size 方法获取文件的大小。</p>
<p><strong>强制写入</strong></p>
<p>操作系统出于性能的考虑，会先将数据写入操作系统的缓存中，而不是立刻写入磁盘。但是可以调用 force(true) 方法将文件内容和元数据(文件的权限等信息)立刻写入磁盘。</p>
<hr>
<h3 id="3-2-两个Channel间传输数据"><a href="#3-2-两个Channel间传输数据" class="headerlink" title="3.2 两个Channel间传输数据"></a>3.2 两个Channel间传输数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个channel之间数据的传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_fileChannelTransferTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;b.txt&quot;</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">    <span class="comment">// 效率高，底层会利用操作系统的“零拷贝”进行优化</span></span><br><span class="line">    <span class="comment">// transferTo 方法每次传输的数据不能大于2G，超过2G的内容将被丢弃</span></span><br><span class="line">    from.transferTo(<span class="number">0</span>, from.size(), to);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    log.info(<span class="string">&quot;transferTo 用时&#123;&#125;秒&quot;</span>, (end-start)/<span class="number">1000_000.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-3-Path"><a href="#3-3-Path" class="headerlink" title="3.3 Path"></a>3.3 Path</h3><p>JDK7 引入了 Path 和 Paths 类。</p>
<ul>
<li>  Path 用来表示文件/目录。</li>
<li>  Paths 是工具类，用来获取 Path 实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\1.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">source3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:/1.txt&quot;</span>); <span class="comment">//另一种等价写法</span></span><br><span class="line"><span class="comment">// 目录+文件名</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source4</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>);</span><br><span class="line"><span class="comment">// 获取网络资源</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source5</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;http://processon.com/chart_image/62a885837d9c082d0b2cb18d.png&quot;</span>);</span><br></pre></td></tr></table></figure>





<h3 id="3-4-Files"><a href="#3-4-Files" class="headerlink" title="3.4 Files"></a>3.4 Files</h3><p>检查文件/目录是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> Files.exists(path);</span><br></pre></td></tr></table></figure>



<p>创建一级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> ...;</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果目录已存在，会抛出 FileAlreadyExistsException 异常</li>
<li>  不能一次创建多级目录，否则会抛出 NoSuchFileException 异常。</li>
</ul>
<p>创建多级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> ...;</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>



<p>拷贝文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  如果目标文件已存在，会抛出 FileAlreadyExistsException 异常</p>
</li>
<li><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>移动文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>

<ul>
<li>  StandardCopyOption.ATOMIC_MOVE 用来保证文件移动时的原子性。</li>
</ul>
<p><strong>删除文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果文件不存在，会抛出 NoSuchFileException 异常。</li>
</ul>
<p><strong>删除目录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/a/b&quot;</span>);</span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果目录中还有内容，会抛出 DirectoryNotEmptyException 异常。</li>
</ul>
<p><strong>遍历目录中的文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历目录中的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilesWalkFileTree</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Software\\Dev\\Java\\jdk1.8.0_162&quot;</span>);</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Files.walkFileTree(source, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====&quot;</span> + dir);</span><br><span class="line">            dirCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;dir count&quot;</span> + dirCount);</span><br><span class="line">    System.out.println(<span class="string">&quot;file count&quot;</span> + fileCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>查看目录下的所有 jar 包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看目录下的所有jar包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilesWalkFileTreeExt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Software\\Dev\\Java\\jdk1.8.0_162&quot;</span>);</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">jarFileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Files.walkFileTree(source, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.toString().endsWith(<span class="string">&quot;.jar&quot;</span>))&#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                jarFileCount.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;file count：&quot;</span> + jarFileCount);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>使用 walkFileTree 实现删除多级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 walkFileTree 实现删除多级目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestWalkFileTreeDel</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\study\\http_study - 副本&quot;</span>);</span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====&gt; 进入&#123; &quot;</span> + dir + <span class="string">&quot; &#125;目录&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="comment">// 删除文件</span></span><br><span class="line">            Files.delete(file);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;==== 退出&#123; &quot;</span> + dir + <span class="string">&quot; &#125;目录&quot;</span>);</span><br><span class="line">            <span class="comment">// 删除目录</span></span><br><span class="line">            Files.delete(dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 walkFileTree 实现递归文件夹的拷贝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 walkFileTree 实现递归文件夹的拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWalkFileTreeCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\study\\http_study&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\study\\http_study - 副本&quot;</span>);</span><br><span class="line">    Files.walkFileTree(source, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====&gt; 进入&#123; &quot;</span> + dir + <span class="string">&quot; &#125;目录&quot;</span>);</span><br><span class="line">            <span class="comment">// 拷贝外层文件夹（文件夹需要创建，文件才需要拷贝）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> dir.toString().replace(source.toString(), target.toString());</span><br><span class="line">            Files.createDirectory(Paths.get(targetName));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="comment">// 拷贝内层文件</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> file.toString().replace(source.toString(), target.toString());</span><br><span class="line">            Files.copy(file, Paths.get(targetName));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4-网络编程（重点）"><a href="#4-网络编程（重点）" class="headerlink" title="4. 网络编程（重点）"></a>4. 网络编程（重点）</h2><h3 id="4-1-非阻塞-vs-阻塞"><a href="#4-1-非阻塞-vs-阻塞" class="headerlink" title="4.1 非阻塞 vs. 阻塞"></a>4.1 非阻塞 vs. 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>  在没有数据可读，或数据复制过程中，线程必须阻塞等待。不会占用CPU，但线程相当于闲置。</li>
<li>  32位JVM一个线程320K，64位JVM一个线程1024K。为了减少线程数，需要采用线程池技术。</li>
<li>  但即使使用了线程池，如果有很多连接建立，长时间的 inactive，会阻塞线程池中的所有线程。</li>
</ul>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>  在某个 Channel 没有可读事件时，线程不必阻塞，它可以去处理其它有可读事件的 Channel。</li>
<li>  但是在数据复制过程中，线程实际还是阻塞的（AIO改进的地方）</li>
<li>  写数据时，线程只是等待数据写入 Channel 中即可，无需等待 Channel 通过网络把数据发送出去。</li>
</ul>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>线程必须配合 Selector 才能完成对多个 Channel 可读事件的监控，这称之为多路复用。</p>
<ul>
<li>  多路复用仅针对网路IO，普通文件IO无法利用多路复用。</li>
<li>  如果不用 Selector 多路复用，那么 Channel 读取到的字节很多时候都是 0，而 Selector 保证了有可读事件才去读取。</li>
<li>  Channel 输入的数据一旦准备好，就会触发 Selector 的可读事件。</li>
</ul>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p><strong>BIO 执行流程</strong></p>
<ol>
<li> 服务器启动；</li>
<li> 客户端通过 Socket 向服务器发起通信，默认情况下服务器端会为每一个请求建立一个线程与之通讯；</li>
<li> 客户端发出请求后，会先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝；</li>
<li> 如果有响应，客户端线程会等待请求结束后，再执行其它操作。在请求未结束前，不允许执行其它操作，即会陷入阻塞。</li>
</ol>
<p>进程是不能直接发送网络包的，需要调用系统调用将数据复制到内核，内核使用网卡驱动程序进行发送。</p>
<p>服务器的实现模式为一个线程处理多个请求（连接），客户端发送的请求都会被注册到多路复用器（Selector）上，多路复用器轮询到连接有 IO 请求时就处理，没有则继续轮询。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/07/volatile/" rel="prev" title="volatile">
                  <i class="fa fa-chevron-left"></i> volatile
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/09/BlockingQueue/" rel="next" title="BlockingQueue">
                  BlockingQueue <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
