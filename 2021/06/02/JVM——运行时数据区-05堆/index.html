<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1    堆的核心概述（Heap） 堆空间用于存储Java对象实例。 一个 JVM 进程只存在一个堆空间，该进程下的所有线程共享该堆空空间。 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 堆区空间在JVM启动时就被创建出来了，并且在创建时就已经确定好了其空间的大小。 堆空间是JVM内存中最大的一块空间。 堆空间的大小是可以调节的。 堆空间中还可以划">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM——运行时数据区:05堆">
<meta property="og:url" content="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1    堆的核心概述（Heap） 堆空间用于存储Java对象实例。 一个 JVM 进程只存在一个堆空间，该进程下的所有线程共享该堆空空间。 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 堆区空间在JVM启动时就被创建出来了，并且在创建时就已经确定好了其空间的大小。 堆空间是JVM内存中最大的一块空间。 堆空间的大小是可以调节的。 堆空间中还可以划">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E7%A9%BA%E9%97%B4.png">
<meta property="og:image" content="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E7%A9%BA%E9%97%B4%E9%BB%98%E8%AE%A4%E5%88%86%E9%85%8D%E6%AF%94%E4%BE%8B.png">
<meta property="og:image" content="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png">
<meta property="article:published_time" content="2021-06-02T02:17:58.000Z">
<meta property="article:modified_time" content="2021-08-03T12:13:09.731Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E7%A9%BA%E9%97%B4.png">


<link rel="canonical" href="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/","path":"2021/06/02/JVM——运行时数据区-05堆/","title":"JVM——运行时数据区:05堆"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM——运行时数据区:05堆 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0%EF%BC%88Heap%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">1    堆的核心概述（Heap）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.1.</span> <span class="nav-text">堆空间的内存布局</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%AE%BE%E7%BD%AE%E5%A0%86%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.</span> <span class="nav-text">2    设置堆空间大小</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.1.</span> <span class="nav-text">堆空间大小的设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OOM%E8%AF%B4%E6%98%8E%E4%B8%8E%E4%B8%BE%E4%BE%8B"><span class="nav-number">2.2.</span> <span class="nav-text">OOM说明与举例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.</span> <span class="nav-text">3    年轻代与老年代</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.1.</span> <span class="nav-text">参数设置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">4    对象分配过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">对象分配一般过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">4.1.1.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-number">4.2.</span> <span class="nav-text">对象分配的特殊情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Minor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="nav-number">5.</span> <span class="nav-text">5    Minor GC、Major GC、Full GC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E5%BC%8FGC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">5.1.</span> <span class="nav-text">分代式GC的触发条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="nav-number">6.</span> <span class="nav-text">6    堆空间分代思想</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">7.</span> <span class="nav-text">7    内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%99%8B%E5%8D%87%E8%A7%84%E5%88%99"><span class="nav-number">7.1.</span> <span class="nav-text">对象晋升规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">7.2.</span> <span class="nav-text">内存分配策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9ATLAB"><span class="nav-number">8.</span> <span class="nav-text">8    为对象分配内存：TLAB</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89TLAB%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%89%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">为什么会有TLAB（Thread Local Allocation Buffer）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTLAB-%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">什么是TLAB ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TLAB-%E8%AF%B4%E6%98%8E"><span class="nav-number">8.3.</span> <span class="nav-text">TLAB 说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B%EF%BC%88%E5%90%ABTLAB%EF%BC%89"><span class="nav-number">8.3.1.</span> <span class="nav-text">对象分配过程（含TLAB）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">8.4.</span> <span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E5%B0%8F%E7%BB%93%E5%A0%86%E7%A9%BA%E9%97%B4%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">9.</span> <span class="nav-text">9    小结堆空间参数设置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">10.</span> <span class="nav-text">10    空间分配担保</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">11    堆是分配对象存储的唯一选择吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="nav-number">11.1.</span> <span class="nav-text">逃逸分析概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="nav-number">11.1.1.</span> <span class="nav-text">参数设置：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="nav-number">11.1.2.</span> <span class="nav-text">结论：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">11.2.</span> <span class="nav-text">逃逸分析代码优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="nav-number">11.2.1.</span> <span class="nav-text">一、栈上分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%90%8C%E6%AD%A5%E7%9C%81%E7%95%A5"><span class="nav-number">11.2.2.</span> <span class="nav-text">二、同步省略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%88%86%E7%A6%BB%E5%AF%B9%E8%B1%A1%E6%88%96%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="nav-number">11.2.3.</span> <span class="nav-text">三、分离对象或标量替换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93%EF%BC%9A%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B9%B6%E4%B8%8D%E6%88%90%E7%86%9F"><span class="nav-number">11.3.</span> <span class="nav-text">逃逸分析小结：逃逸分析并不成熟</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%B0%8F%E7%BB%93"><span class="nav-number">12.</span> <span class="nav-text">12    小结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM——运行时数据区:05堆 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM——运行时数据区:05堆
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 10:17:58" itemprop="dateCreated datePublished" datetime="2021-06-02T10:17:58+08:00">2021-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 20:13:09" itemprop="dateModified" datetime="2021-08-03T20:13:09+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-堆的核心概述（Heap）"><a href="#1-堆的核心概述（Heap）" class="headerlink" title="1    堆的核心概述（Heap）"></a>1    堆的核心概述（Heap）</h1><ul>
<li>堆空间用于存储Java对象实例。</li>
<li>一个 JVM 进程只存在一个堆空间，该进程下的所有线程共享该堆空空间。</li>
<li>《Java虚拟机规范》规定，<strong>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</strong>。</li>
<li>堆区空间在JVM启动时就被创建出来了，并且在创建时就已经确定好了其空间的大小。</li>
<li>堆空间是JVM内存中最大的一块空间。</li>
<li>堆空间的大小是可以调节的。</li>
<li><strong>堆空间中还可以划分出线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</strong> </li>
<li>“几乎”所有的对象实例以及数组都应当在运行时分配在堆上。</li>
<li>数组和对象可能永远不会存储在栈中，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>在方法结束后，堆中的对象并不会马上被移除，仅仅在GC时才会被移除。</li>
<li>堆是GC执行垃圾回收的重点区域。</li>
</ul>
<h2 id="堆空间的内存布局"><a href="#堆空间的内存布局" class="headerlink" title="堆空间的内存布局"></a>堆空间的内存布局</h2><p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E7%A9%BA%E9%97%B4.png" alt="堆空间"></p>
<p>现代垃圾回收器大部分都基于<strong>分代收集理论</strong>设计，堆空间细分为：</p>
<blockquote>
<p><strong>Java8 之前</strong>堆空间在逻辑上分为三部分：<strong>年轻代 + 老年代 + 永久代</strong></p>
</blockquote>
<ul>
<li>Young Generation Space  年轻代   Young/New</li>
<li>新生代又可划分为 Eden 区和 Survivor 区</li>
<li>Tenure generation space  老年代    Old/Tenure</li>
<li>Permanent Space        永久代    Perm</li>
</ul>
<blockquote>
<p>从 <strong>Java8 开始</strong>堆空间逻辑在上分为三部分：<strong>新生代 + 老年代 + 元空间</strong> </p>
</blockquote>
<ul>
<li><p>Young Generation Space  年轻代    Young/New</p>
<ul>
<li>  新生代又可划分为 Eden 区和 Survivor 区</li>
</ul>
</li>
<li><p>Tenure generation space  老年代    Old/Tenure</p>
</li>
<li><p>Meta Space            元空间    Meta</p>
</li>
</ul>
<blockquote>
<p>  堆空间的演变仅仅是针对于方法区而言的，从Java8开始将 <code>永久代--&gt;&gt; 元空间</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆空间在逻辑上可分为三部分：1、年轻代 2、老年代 3、永久代/元空间</span><br><span class="line">但是在物理上，堆空间只有：1、年轻代 2、老年代</span><br></pre></td></tr></table></figure>





<p><strong>约定</strong>：</p>
<ul>
<li>新生区 &lt;=&gt; 新生代 &lt;=&gt; 年轻代</li>
<li>养老区 &lt;=&gt; 养老区 &lt;=&gt; 老年代</li>
<li>永久区 &lt;=&gt; 永久代</li>
</ul>
<hr>
<h1 id="2-设置堆空间大小"><a href="#2-设置堆空间大小" class="headerlink" title="2    设置堆空间大小"></a>2    设置堆空间大小</h1><h2 id="堆空间大小的设置"><a href="#堆空间大小的设置" class="headerlink" title="堆空间大小的设置"></a>堆空间大小的设置</h2><p>堆空间的大小在JVM进程启动时就已经确定好了，但是开发人员仍可以通过参数 <code>-Xmx</code> 和 <code>Xms</code> 来显式的指定这个空间的大小。</p>
<ul>
<li><strong>-Xms</strong> 用于设置堆空间的初始内存，等价于 <code>-XX:InitialHeapSize</code> </li>
<li><strong>-Xmx</strong> 用于设置堆空间的最大内存，等价于 <code>-XX:MaxHeapSize</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-X 是JVM的运行参数</span><br><span class="line">    ms 是 memory start</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 查看堆设置的参数</span></span><br><span class="line">    方式一：jps /   jstat -gc 进程id</span><br><span class="line">    方式二：-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一旦堆空间中的所有内存之和的大小超过 <code>-Xmx</code> 所指定的最大内存时，将会抛出 <strong>OutOfMemoryError</strong> 异常。</p>
</li>
<li><p>通常会将 <code>-Xms</code> 和 <code>-Xmx</code> 两个参数配置相同的值，其<strong>目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</strong></p>
</li>
<li><p>默认情况下：</p>
<p><code>初始内存大小 = 物理内存大小 / 64</code></p>
<p><code>最大内存大小 = 物理电脑内存大小 / 4</code> </p>
</li>
</ul>
<hr>
<h2 id="OOM说明与举例"><a href="#OOM说明与举例" class="headerlink" title="OOM说明与举例"></a>OOM说明与举例</h2><ul>
<li>堆空间内存溢出错误信息：<code>java.lang.OutOfMemoryError: Java heap space</code></li>
</ul>
<hr>
<h1 id="3-年轻代与老年代"><a href="#3-年轻代与老年代" class="headerlink" title="3    年轻代与老年代"></a>3    年轻代与老年代</h1><p>存储在堆空间中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</li>
<li>另外一类对象的生命周期非常长，在某些极端的情况下甚至与JVM线程的生命周期保持一致。</li>
</ul>
<p>按照上述标准，将Java堆空间进一步细分的话，又可划分为 <strong>年轻代（YoungGen）</strong> 和 <strong>老年代（OldGen）</strong>。</p>
<blockquote>
<p>其中 <strong>年轻代</strong> 又可以划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>；</p>
<ul>
<li>  <strong>Survivor区</strong> 又可划分为 <strong>Survivor0区</strong> 和 <strong>Survivor1区</strong>（有时也叫做from区、to区）</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>年轻代保存的是生命周期较短的对象，这类对象由于生命周期较短，所以经常需要被GC回收；</span><br><span class="line">    <span class="number">1.1</span>	Eden区被翻译为伊甸园区，伊甸园在西方神话中就是最早出现的人类亚当和夏娃居住的地方，对应在JVM内存中Eden区就是Java对象</span><br><span class="line">    创建出来时最先在堆中的位置。</span><br><span class="line"><span class="number">2</span>、老年代保存的是生命周期较长的对象，这类对象生命周期较长，所以被GC回收回收的频率较低。</span><br></pre></td></tr></table></figure>



<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E7%A9%BA%E9%97%B4%E9%BB%98%E8%AE%A4%E5%88%86%E9%85%8D%E6%AF%94%E4%BE%8B.png" alt="堆空间默认分配比例"></p>
<p><strong>配置新生代与老年代在堆结构的占比：</strong></p>
<ul>
<li><p>默认值是 <code>-XX:NewRatio=2</code>，表示新生代占1份，老年代占2份，新生代占整个堆的 1/3 。</p>
</li>
<li><p>可以修改 <code>-XX:NewRatio=4</code>，表示新生代占1份，老年代占4份，新生代占整个堆的 1/5。</p>
</li>
<li><p><strong>NewRatio = 老年代/新生代</strong> </p>
</li>
<li><p>在 HotSpot 中，Eden区和另外两个Survivor取所占堆空间的默认比例是：8：1：1</p>
</li>
<li><p>当然也可以通过参数<code>-XX:SurvivorRatio</code> 来调整这个空间比例。比如：SurvivorRatio = 8 。</p>
</li>
<li><p><strong>几乎所有的 Java 对象都是在 Eden 区被出生的。</strong></p>
<blockquote>
<p><strong>问题：什么时候Java对象不是在Eden区出生的？</strong></p>
<p>答：如果我们New了一个对象，并且这个对象所占内存非常大，大到伊甸园区都放不下，可以直接把对象存储到老年代。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>绝大多数的Java对象的销毁都是在新生代中进行的。据统计，绝大多数的对象生命周期都非常短，大部分在未晋升到老年代之前就已经被GC了。</p>
</li>
<li><p>可以使用参数 <code>-Xmn</code> 设置新生代最大内存的大小。（这个参数一般使用默认值即可） </p>
</li>
</ul>
<hr>
<h1 id="4-对象分配过程"><a href="#4-对象分配过程" class="headerlink" title="4    对象分配过程"></a>4    对象分配过程</h1><p>为新创建的对象分配内存空间是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配，在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑GC执行完垃圾回收后是否会在内存空间产生内存碎片等问题。</p>
<h2 id="对象分配一般过程"><a href="#对象分配一般过程" class="headerlink" title="对象分配一般过程"></a>对象分配一般过程</h2><ol>
<li><p><code>new</code> 出的新对象首先保存在 <code>Eden</code> 区。（此区有大小限制）</p>
</li>
<li><p>当伊甸园区的空间已被填满，并且程序又需要创建对象时，这时将会触发垃圾回收器对 <code>Eden</code>区中的对象进行一次 Minor GC：</p>
<ul>
<li>将 <code>Eden</code> 区中已失效的对象进行回收；</li>
<li>将 <code>Eden</code>区中未失效的对象移动到 <code>Survivor0</code> 区，并且为每一个移动到幸存者区的对象分配一个年龄计数器。</li>
<li>此时，<code>Eden</code> 区就已经被完全清空了，也就可以创建新的对象保存到 <code>Eden</code> 区。</li>
</ul>
</li>
<li><p>继续往伊甸园区保存新创建的对象，如果伊甸园区满，将再次触发 Minor GC：</p>
<ul>
<li>将 <code>Eden</code> 区中已失效的对象进行销毁；</li>
<li>将 <code>Eden</code> 区中未失效的对象，移动到 <code>Survivor1</code> 区，年龄计数器+1；</li>
<li>并且将 <code>Survivor0</code> 区中经过 Minor GC 筛选后没有被回收的对象 ，也要移动到 <code>Survivor1</code> 区，并将年龄计数器+1。</li>
<li>也就是说，对于 <code>Eden</code> 区和 <code>Survivor</code> 区中的对象，每次 Minor GC 后，都要将筛选后留下来的对象移动到空的 <code>Survivor </code>区中（即如果S0区为空，就将伊甸园区和S1区中的有效对象移动到S0区，如果S1区为空，就将伊甸园区和S0区中的有效对象移动到S1区中）。</li>
<li>此时，<code>Eden</code> 区和 <code>Survivor0</code> 区就都被清空了。</li>
</ul>
</li>
<li><p>继续往伊甸园区保存新创建的对象，如果伊甸园区满，再次触发 Minor GC，此时会将 GC 筛选后留下来的对象重新放回 <code>Survivor0</code>区，年龄计数器+1。以此类推，下次 GC 接着再放回 <code>Survivor1</code> 区，并累加年龄计数器。</p>
</li>
<li><p>啥时候能去养老区呢？可以设置 <strong>GC 次数的阈值，默认是 15 次</strong>。当年龄计数器大于等于 15 之后，即经历 15 次GC仍然存活在幸存者区的对象，就可以进入养老区了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以通过参数 -XX:MaxTenuringThreshold=&lt;N&gt; 来设置进入养老区的GC次数。</span><br></pre></td></tr></table></figure></li>
<li><p>在老年代相对安全，不会频繁的触发 GC。<strong>即 Minor GC 不会对老年代空间进行垃圾回收</strong>，只有当养老区空间内存不足时，触发了 <strong>Major GC 后才会对老年代进行垃圾回收的操作</strong>。</p>
</li>
<li><p>若老年代在执行了 Major GC 后发现仍然没有足够空间保存新进入老年代的对象，就会产生 OOM 异常。</p>
<p><code>java.lang.OutOfMemoryError: Java heap space</code></p>
</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<ol>
<li> <strong><code>from区</code> 和 <code>to区</code> 是相对的：</strong></li>
</ol>
</blockquote>
<ul>
<li><code>to区</code> 永远是内存为空的幸存者区，<code>from区</code> 永远是内存不为空的幸存者区。</li>
<li>即：如果幸存者1区为空，则该区就是 to区；如果幸存者1区不为空，则该区就是 from区。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>GC</strong></li>
</ol>
</blockquote>
<ul>
<li>伊甸园区满的时候会触发 YGC/Minor GC；</li>
<li>幸存者区满的时候不会触发 YGC/Minor GC</li>
<li>但是当 YGC/Minor GC 被触发的时候，会将伊甸园区和幸存者区一起进行GC。 </li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>关于垃圾回收：</strong></li>
</ol>
</blockquote>
<p>频繁在新生区，很少在养老区，几乎不在永久代（/元空间 ）。</p>
<hr>
<h2 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h2><p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="堆中对象分配过程"></p>
<ol>
<li><p>使用 <code>new</code> 关键字在堆中创建出一个对象；</p>
</li>
<li><p>如果 Eden 放得下，就在 Eden 分配一块内存保存对象；</p>
</li>
<li><p>如果 Eden 放不下，就会触发 YGC 进行垃圾回收，GC 结束后会清空 Eden 空间，</p>
<ul>
<li>如果此时 Eden 放得下，就在 Eden 分配一块内存保存对象。</li>
<li>如果要创建的对象是一个超大的对象，所需要分配的内存大于 Eden 本身的内存空间。则跳过 Eden 和 Survivor ，直接去判断 Old 区能否放得下该对象；<ul>
<li>如果 Old 区能放得下该对象，就直接在 Old 区分配一块内存保存对象。</li>
<li>如果 Old 区放不下该对象，就会触发 FGC 对 Old 区的空间进行垃圾回收，GC 结束后会清理 Old 区已失效的对象。<ul>
<li>如果经过 FGC 后，Old 区剩余的内存空间大于创建新对象需要的内存空间，即可以放得下了，就在 Old 区分配一块内存保存对象。</li>
<li>如果经过 FGC 后，Old 区剩余的内存空间仍不足以支持新对象的创建，则抛出 OOM 异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>YGC 的详细过程：</strong></p>
</blockquote>
<p>当 Eden 满时触发 YGC，</p>
<ol>
<li>首先会回收 Eden 中失效的对象的内存空间；</li>
<li>如果 Survivor 放得下：<ol>
<li>将 Eden 中未失效的对象移动至 Survivor ；</li>
<li>将 Survivor 中 from 区的对象移动至 to 区。</li>
<li>如果 Survivor 中对象的存活时间超过阈值，就晋升为老年代，移动至 Old 区；</li>
<li>如果对象的存活时间未超过阈值，则继续从 from 区移动到 to 区；</li>
</ol>
</li>
<li>如果 Survivor 放不下：<ul>
<li>直接晋升到老年代，移动至 Old 区。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="5-Minor-GC、Major-GC、Full-GC"><a href="#5-Minor-GC、Major-GC、Full-GC" class="headerlink" title="5    Minor GC、Major GC、Full GC"></a>5    Minor GC、Major GC、Full GC</h1><blockquote>
<p>  Minor，未成年人</p>
<p>  Major：成年人</p>
</blockquote>
<p>JVM在进行GC时，并非每次GC都会对堆空间的三个内存区域（新生代、老年代、方法区）全部进行回收。</p>
<p>在 HotSpot 中，GC 按照回收区域又可分为两大种类型：①部分回收（Partial GC）    ②整堆回收（Full GC）</p>
<ul>
<li>部分回收：不是完整回收整个Java堆的垃圾回收。其中又可分为：<ol>
<li>新生代回收（Minor GC / Young GC）：只针对新生代区（Eden 和 Survivor）的GC。</li>
<li>老年代回收（Major GC / Old GC）：只针对老年代区的GC。</li>
<li>混合回收（Mixed GC）：针对整个新生代和部分老年代的GC。</li>
</ol>
</li>
<li>整堆回收（Full GC）：针对整个Java堆和方法区的垃圾回收</li>
</ul>
<ul>
<li><input checked disabled type="checkbox"> <strong>注意：很多时候 Major GC 和 Full GC 会混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></li>
</ul>
<hr>
<h2 id="分代式GC的触发条件"><a href="#分代式GC的触发条件" class="headerlink" title="分代式GC的触发条件"></a>分代式GC的触发条件</h2><blockquote>
<p>  <strong>Minor GC 的触发条件</strong></p>
</blockquote>
<ul>
<li>当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是 Eden 区满，Survivor 区满不会触发GC。（每次触发 Minor GC 会清理整个年轻代的内存空间）</li>
<li>因为 Java 对象<strong>大多都具备朝生夕灭</strong>的特性，所以 Minor GC 触发非常频繁，一般回收速度也比较快。</li>
<li>触发 Minor GC 后会引发 STW（Stop The Work），暂停其它用户的线程，等到垃圾回收结束，用户线程才会恢复运行。 </li>
</ul>
<blockquote>
<p>  <strong>Major GC / Full GC的触发条件</strong></p>
</blockquote>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC” 或 “Full GC” 就发生了。</li>
<li>发生了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。</li>
<li>Major GC 的速度一般会比 Minor GC 慢10倍以上，STW 的时间更长。</li>
<li>如果 Major GC 后，内存还不足，就会报 OOM 了。</li>
</ul>
<blockquote>
<p>  <strong>Full GC 的触发机制</strong></p>
</blockquote>
<p>触发 Full GC 执行的情况有以下5种：</p>
<ol>
<li>手动调用 <code>System.gc()</code> 方法，</li>
<li>老年代空间不足时；</li>
<li>方法区空间不足时；</li>
<li>某次 Minor GC 后进入老年代的对象的平均内存的大小大于老年代的可用内存；</li>
<li>由 Eden、from 区向 to 区复制时，如果待复制内容的大小大于 to 区的可用内存，就会把超出部分的对象转存到老年代，若此时老年代的可用内存小于待加入内存的大小，则会触发 Full GC 。</li>
</ol>
<p><strong>说明：Full GC 是开发或调优中尽量要避免的，这样暂停时间会短一些。</strong></p>
<hr>
<h1 id="6-堆空间分代思想"><a href="#6-堆空间分代思想" class="headerlink" title="6    堆空间分代思想"></a>6    堆空间分代思想</h1><p>研究表明，不同的对象生命周期不同，其中 70%~99% 的对象都是临时对象。</p>
<blockquote>
<p>  <strong>问题：Java堆空间为什么需要分代保存对象？不分代就不能正常工作了吗？</strong></p>
</blockquote>
<p>答：其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。</p>
<ul>
<li>  如果没有分代，那么所有的对象都会保存在一整块堆内存中，就如同把一个学校所有的人都关在一个教室。此时，每次GC的时候都需要把堆的所有的对象扫描一遍，才能够判断哪些对象已失效，哪些对象未失效。</li>
<li>  而在堆空间中，大部分的对象都是一些临时对象，生命周期很短。如果分代保存的话，把新创建的对象集中保存在某一块内存区域，当 GC 的时候只需扫描这块保存新对象的区域即可，而对于那些已经晋升到老年代的对象，只需要隔很久去GC一次即可。这样可以极大的节省CPU资源。</li>
</ul>
<hr>
<h1 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7    内存分配策略"></a>7    内存分配策略</h1><h2 id="对象晋升规则"><a href="#对象晋升规则" class="headerlink" title="对象晋升规则"></a>对象晋升规则</h2><ul>
<li><p>如果对象出生在 Eden 并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。</p>
</li>
<li><p>对象在 Survivor 中每熬过一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（HotSpot VM 默认为15岁，但是每个JVM、每个GC都有所不同）时，就会被晋升到养老区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于晋升到养老区的年龄阈值，可以通过参数： -XX:MaxTenuringThreshold 来设置。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到 Eden</li>
<li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li>
<li>长期存活的对象分配到老年代</li>
<li><strong>动态对象年龄判断</strong><ul>
<li>如果 Survivor 中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入养老区，无需等到 MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保<ul>
<li><code>-XX:HandlePromotionFailure</code></li>
</ul>
</li>
</ul>
<hr>
<h1 id="8-为对象分配内存：TLAB"><a href="#8-为对象分配内存：TLAB" class="headerlink" title="8    为对象分配内存：TLAB"></a>8    为对象分配内存：TLAB</h1><blockquote>
<p><strong>TLAB；Thread Local Allocation Buffer；本地线程缓存区</strong></p>
</blockquote>
<h2 id="为什么会有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么会有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么会有TLAB（Thread Local Allocation Buffer）？"></a>为什么会有TLAB（Thread Local Allocation Buffer）？</h2><ul>
<li><p>堆空间是所有线程共享的区域，任何线程都可以访问到堆空间中的共享数据。</p>
</li>
<li><p><strong>由于对象是在堆空间中创建的，所以在高并发条件下为新创建对象分配内存空间是线程不安全的。</strong></p>
<blockquote>
<p>假设有3个线程同时创建对象，这三个线程同时进入分配内存空间的环节，</p>
<ol>
<li> 首先，线程A申请到了一块内存地址为<code>0x1101</code>的内存空间，但是还没来得及创建对象，就被切换到线程B执行了；</li>
<li> 线程B经检查后，发现地址为<code>0x1101</code>的内存空间是空闲的 ，所以线程B也得到了这块内存空间用于保存创建的对象；</li>
<li> 同理，线程C也得到了地址为<code>0x1101</code>的内存空间。</li>
</ol>
<p>这三个线程在申请堆空间时都被JVM分配到了编号为<code>0x1101</code>的内存空间，但是在创建对象时这三个对象使用同一块内存就会产生冲突了。</p>
</blockquote>
</li>
<li><p>为了避免多个线程操作同一地址，在创建对象时还需要使用加锁等机制。显然，加锁是非常影响分配速度的。</p>
</li>
</ul>
<hr>
<h2 id="什么是TLAB-？"><a href="#什么是TLAB-？" class="headerlink" title="什么是TLAB ？"></a>什么是TLAB ？</h2><ul>
<li>从内存模型的角度来讲，对 <strong>Eden</strong> 继续进行划分，JVM <strong>在 Eden 区中划分出一块区域作为 TLAB 区</strong>，这块区域为每个线程都分配了一个私有缓存区域。</li>
<li>多线程同时创建对象时，使用 TLAB 可以避免一系列的线程不安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
</ul>
<hr>
<h2 id="TLAB-说明"><a href="#TLAB-说明" class="headerlink" title="TLAB 说明"></a>TLAB 说明</h2><ul>
<li><strong>尽管不是所有的对象实例都能在 TLAB 中成功创建，但JVM确实是将TLAB作为内存分配的首选。</strong></li>
<li>默认情况下，TLAB 空间的内存非常小，仅占整个 Eden 的 1%，所以当这个空间容纳不下我们要创建的对象实例时，就无法在 TLAB中成功创建对象。当然我们可以通过参数 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间占用 Eden 的百分比大小。</li>
<li><strong>一旦对象在 TLAB 空间中创建失败时，JVM 就会尝试着通过使用加锁机制确保创建对象时的原子性，直接在 Eden 空间中创建对象。</strong></li>
<li>在程序中，开发人员可以通过参数 <code>-XX:UseTLAB</code> 来设置是否开启 TLAB 空间。</li>
</ul>
<h3 id="对象分配过程（含TLAB）"><a href="#对象分配过程（含TLAB）" class="headerlink" title="对象分配过程（含TLAB）"></a>对象分配过程（含TLAB）</h3><p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="对象分配过程"></p>
<hr>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote>
<p>  <strong>问题：堆空间一定都是共享的吗？</strong></p>
</blockquote>
<p>答：不是。堆空间中 Eden 区中的 TLAB 区是每个线程私有的。</p>
<hr>
<h1 id="9-小结堆空间参数设置"><a href="#9-小结堆空间参数设置" class="headerlink" title="9    小结堆空间参数设置"></a>9    小结堆空间参数设置</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial		<span class="comment">// 查看所有参数使用的默认值</span></span><br><span class="line">-XX:+PrintFlagsFinal		<span class="comment">// 查看所有参数的最终值（可能存在修改，不再是初始值）</span></span><br><span class="line"></span><br><span class="line">-XX:NewRatio		<span class="comment">// 配置新生代与老年代在堆结构中的占比</span></span><br><span class="line"></span><br><span class="line">-Xms		<span class="comment">// 设置初始堆空间的内存（默认为物理内存的1/64）</span></span><br><span class="line">-Xmx		<span class="comment">// 设置最大堆空间的内存（默认为物理内存的1/64）</span></span><br><span class="line">-Xmn		<span class="comment">// 设置新生代内存的大小（初始值和最大值）</span></span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio=[size]		<span class="comment">// 设置新生代中 Eden 和 S0/S1 空间的比例</span></span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold	<span class="comment">// 设置新生代垃圾的最大年龄，超过阈值进入养老区</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails		<span class="comment">// 输出详细的GC处理日志</span></span><br><span class="line">-XX:+PrintGC	<span class="comment">// 打印GC简要信息</span></span><br><span class="line"></span><br><span class="line">-XX:HandlePromotionFailure	<span class="comment">// 是否设置空间分配担保</span></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="10-空间分配担保"><a href="#10-空间分配担保" class="headerlink" title="10    空间分配担保"></a>10    空间分配担保</h1><p>在发生 Minor GC 之前，虚拟机会<strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p>
<ul>
<li>如果大于，则此次 Minor GC 是安全的。（最极端的情况就是新生代所有的对象都在这一次GC后进入到养老区）</li>
<li>如果小于，则虚拟机会查看参数 <code>-XX:HandlePromotionFailure</code> 的值是否允许担保失败。<ul>
<li>如果 <code>-XX:HandlePromotionFailure=true</code>，表示允许担保失败，那么会继续<strong>检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul>
<li><input checked disabled type="checkbox"> 如果大于，则尝试进行一次 Minor GC ，但这个 Minor GC  依然是有风险的。因为平均数据并不能决定本次数据。</li>
<li><input checked disabled type="checkbox"> 如果小于，则改为进行一次 Full GC。</li>
</ul>
</li>
<li>如果 <code>-XX:HandlePromotionFailure=false</code>，表示不允许担保失败，直接进行一次 Full GC。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<p>执行 Minor GC 前需要进行担保：</p>
<ul>
<li>  若担保成功，则继续执行 Minor GC；</li>
<li>  若担保失败，则直接进行 Full GC。</li>
</ul>
<blockquote>
<p>  <strong>担保机制在不同 JDK 版本中的变化：</strong></p>
</blockquote>
<ul>
<li>  JDK7 之前，担保机制需要手动开启或关闭；</li>
<li>  从 JDK7 开始，担保机制变更为自动开启的了。</li>
</ul>
<p>从 JDK7 开始，<strong>HandlePromotionFailure</strong>参数不再会影响到虚拟机的空间分配担保策略，即默认<code>-XX:HandlePromotionFailure=true</code>。虽然在源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。规则变为：<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升老年代对象的平均大小就会进行 Minor GC，否则将进行 Full GC</strong>。</p>
<hr>
<h1 id="11-堆是分配对象存储的唯一选择吗？"><a href="#11-堆是分配对象存储的唯一选择吗？" class="headerlink" title="11    堆是分配对象存储的唯一选择吗？"></a>11    堆是分配对象存储的唯一选择吗？</h1><ul>
<li>随着 JIT 编译器的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 </li>
<li>在 Java 虚拟机中，对象是在 Java 堆中分配的。但是有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这就就无需在堆上分配内存，也无需进行垃圾回收了，这就是最常见的<strong>堆外存储技术</strong>。</li>
<li>此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现了 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC的回收效率的目的。  </li>
</ul>
<h2 id="逃逸分析概述"><a href="#逃逸分析概述" class="headerlink" title="逃逸分析概述"></a>逃逸分析概述</h2><ul>
<li><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
</li>
<li><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
</li>
<li><p>通过逃逸分析，HotSpot 编译器能够分析出一个新的对象引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
</li>
<li><p><strong>逃逸分析的基本行为就是分析对象动态作用域</strong>：</p>
</li>
<li><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p>
</li>
<li><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生了逃逸。例如作为调用参数传递到其它方法中。</p>
</li>
<li><p><strong>没有发生逃逸的对象，可以分配到栈上，随着方法执行的结束，栈空间就被移出</strong>。</p>
</li>
</ul>
<h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><ul>
<li><p>从 JDK7 开始，HotSpot 就默认开启了逃逸分析。</p>
</li>
<li><p>如果是更早的版本，开发人员可以通过：</p>
</li>
<li><ul>
<li><code>-XX: +DoEscapeAnalysis</code> 参数显式的开启逃逸分析。</li>
<li><code>-XX: +PrintEscapeAnalysis</code> 查看逃逸分析的筛选结果。</li>
</ul>
</li>
</ul>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><ul>
<li>开发中能使用局部变量的，就不要在方法外定义。</li>
</ul>
<hr>
<h2 id="逃逸分析代码优化"><a href="#逃逸分析代码优化" class="headerlink" title="逃逸分析代码优化"></a>逃逸分析代码优化</h2><p>使用逃逸分析，编译器可以对代码作如下优化：</p>
<blockquote>
<ol>
<li>栈上分配</li>
<li>同步省略 </li>
<li>分离对象或标量替换</li>
</ol>
</blockquote>
<h3 id="一、栈上分配"><a href="#一、栈上分配" class="headerlink" title="一、栈上分配"></a>一、栈上分配</h3><ul>
<li>将堆分配转换为栈分配，分配在栈上的对象不需要进行垃圾回收，方法出栈后对象自动被销毁，可以提高程序的性能。</li>
<li>JIT 编译器在编译期间会根据逃逸分析的结果，如果发现一个对象并没有逃逸出当前方法的话，就可能被优化成栈上分配。分配完成后，调用在栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</li>
</ul>
<h3 id="二、同步省略"><a href="#二、同步省略" class="headerlink" title="二、同步省略"></a>二、同步省略</h3><p>如果发现一个对象只能被一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<ul>
<li>  线程同步的代价是非常高的，同步的后果是降低并发性和性能。</li>
<li>  在动态编译同步代码块的时候，JIT 编译器可以借助逃逸分析来判断同步代码块所使用的锁对象是否只能被一个线程访问而没有被发布到其它线程。</li>
<li>  如果没有，那么JIT编译器在编译这个同步代码块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做同步省略，也叫锁消除。</li>
</ul>
<h3 id="三、分离对象或标量替换"><a href="#三、分离对象或标量替换" class="headerlink" title="三、分离对象或标量替换"></a>三、分离对象或标量替换</h3><p>有的对象可能不需要作为一个连续的内存结构存在也能被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<ul>
<li>  标量（Scalar）是指一个无法再分解成更小数据的数据。</li>
<li>  Java 中的基本数据类型就是标量。</li>
<li>  相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为它可以分解成其它聚合量和标量。</li>
<li>  在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个成员变量来代替。这个过程就是标量替换。</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x + <span class="string">&quot;;point.y=&quot;</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码经过标量替换后，就会变成：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x + <span class="string">&quot;;point.y=&quot;</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    可以看到，Point这个聚合量经过逃逸分析后，发现它并没有逃逸，就会替换成两个非聚合量了。</span></span><br><span class="line"><span class="comment">    那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。</span></span><br><span class="line"><span class="comment">    因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</span></span><br><span class="line"><span class="comment">    这些临时变量不需要创建对象来保存，直接保存在栈中的临时变量表中即可。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    标量替换为栈上分配提供了很好的基础。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>标量替换参数设置</strong></p>
</blockquote>
<p>使用参数 <code>-XX:+EliminateAllocations</code> 开启标量替换（默认就是打开的），允许将对象打散成标量对象分配在栈上。</p>
<hr>
<h2 id="逃逸分析小结：逃逸分析并不成熟"><a href="#逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="逃逸分析小结：逃逸分析并不成熟"></a>逃逸分析小结：逃逸分析并不成熟</h2><ul>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是<strong>无法保证逃逸分析节省的性能消耗一定能高于它的消耗</strong>。虽然经过逃逸分析可以做标量替换、栈上分配和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相当耗时的过程。</li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的，那这个逃逸分析的过程就白白浪费了。</li>
<li>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</li>
<li>有一些观点认为：通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。Oracle HotSpot JVM 中就并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li>
<li>目前很多书籍还是基于 JDK7 之前的版本，JDK 已经发生了很大的变化，intern 字符串的缓存和静态变量曾经都被分配在永久代中，而永久代已经被元数据区取代，但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</li>
</ul>
<hr>
<h1 id="12-小结"><a href="#12-小结" class="headerlink" title="12    小结"></a>12    小结</h1><ul>
<li>年轻代是大部分对象诞生、成长、消亡的区域，大部分对象在这里产生、应用、最后被垃圾回收器回收，结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从 Survivor 区筛选拷贝过来的 Java对象。当然，也会有特殊情况，我们知道普通的对象会被分配在TLAB上，但是如果对象太大，JVM会试图直接分配在Eden 其它位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li>当GC只发生在年轻代中，回收年轻代对象的行为被称为 Minor GC。当GC发生在老年代时则被称为 Major GC 或者 Full GC 。一般的，Minor GC 的发生频率要比 Major GC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-04%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/" rel="prev" title="JVM——运行时数据区:04本地方法栈">
                  <i class="fa fa-chevron-left"></i> JVM——运行时数据区:04本地方法栈
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-06%E6%96%B9%E6%B3%95%E5%8C%BA/" rel="next" title="JVM——运行时数据区:06方法区">
                  JVM——运行时数据区:06方法区 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
