<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文默认使用 HotSpot 虚拟机 + JDK8 ，如有其它情况会具体指出。  1  String 的基本特性   String；字符串；  顾名思义，就是把一个个的字符串在一起，所以说字符串的底层实现就是一个字符数组。      String 被声明为 final 的表示类不可被继承。   String 实现了 Serializable 接口，表示字符串是支持序列化的。   String">
<meta property="og:type" content="article">
<meta property="og:title" content="String">
<meta property="og:url" content="http://example.com/2021/06/13/String/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="本文默认使用 HotSpot 虚拟机 + JDK8 ，如有其它情况会具体指出。  1  String 的基本特性   String；字符串；  顾名思义，就是把一个个的字符串在一起，所以说字符串的底层实现就是一个字符数组。      String 被声明为 final 的表示类不可被继承。   String 实现了 Serializable 接口，表示字符串是支持序列化的。   String">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/06/13/String/1623398509911-a4c2e130-bfc9-4aa7-9a9d-531df6e1cdee.png">
<meta property="og:image" content="http://example.com/2021/06/13/String/1623478701279-d327aa0f-fdc0-47a9-a63e-e310317f7271.png">
<meta property="og:image" content="http://example.com/2021/06/13/String/1623488782339-dd95c67e-52d3-4dfd-887b-52ed4e499a47.png">
<meta property="og:image" content="http://example.com/2021/06/13/String/1623491535138-3562077b-906b-41ae-aaee-49806b528949.png">
<meta property="og:image" content="http://example.com/2021/06/13/String/1623492457552-7821a5f9-93b5-44b1-aabf-11514fb0ba93.png">
<meta property="og:image" content="http://example.com/2021/06/13/String/1623492807620-7f60184d-4382-4830-b450-95b9019c6051.png">
<meta property="og:image" content="http://example.com/2021/06/13/String/image-20210613173632473.png">
<meta property="og:image" content="http://example.com/2021/06/13/String/1623508433062-ce767a2e-fba1-4f8d-bd53-374635e01625.png">
<meta property="article:published_time" content="2021-06-13T03:42:39.000Z">
<meta property="article:modified_time" content="2021-07-31T09:57:19.500Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/06/13/String/1623398509911-a4c2e130-bfc9-4aa7-9a9d-531df6e1cdee.png">


<link rel="canonical" href="http://example.com/2021/06/13/String/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/06/13/String/","path":"2021/06/13/String/","title":"String"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>String | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-String-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">1  String 的基本特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-String-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98"><span class="nav-number">1.1.</span> <span class="nav-text">1.1    String 存储结构的演变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-String-%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">1.2    String 的不可变性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-String-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">2.</span> <span class="nav-text">2  String 的内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String-%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.1.</span> <span class="nav-text">String 对象可以保存在内存中的哪些位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC-JDK-%E4%B8%AD-StringPool-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%B0%83%E6%95%B4"><span class="nav-number">2.2.</span> <span class="nav-text">不同版本 JDK 中 StringPool 在内存中的调整</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">2.1    字符串常量池的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E4%BF%9D%E5%AD%98%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD"><span class="nav-number">2.4.</span> <span class="nav-text">2.2    如何将字符串对象保存到字符串常量池中</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">4  字符串拼接操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F-%E5%B8%B8%E9%87%8F"><span class="nav-number">3.1.</span> <span class="nav-text">常量 + 常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F-%E5%8F%98%E9%87%8F-%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">常量&#x2F;变量 +变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9Afinal-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text">特殊情况：final 修饰的变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo"><span class="nav-number">3.4.</span> <span class="nav-text">Demo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-intern-%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">5  intern() 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">有什么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#intern-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.2.</span> <span class="nav-text">intern() 的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0"><span class="nav-number">4.3.</span> <span class="nav-text">练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Demo1"><span class="nav-number">4.3.1.</span> <span class="nav-text">Demo1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Demo2"><span class="nav-number">4.3.2.</span> <span class="nav-text">Demo2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACJDK%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">4.4.</span> <span class="nav-text">不同版本JDK中不同方式创建字符串对象的先后顺序的影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#intern-%E7%9A%84%E7%BB%83%E4%B9%A0"><span class="nav-number">4.5.</span> <span class="nav-text">intern 的练习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-G1-%E4%B8%AD%E7%9A%84-String-%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">5.</span> <span class="nav-text">7  G1 中的 String 去重操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E8%AF%B4%E6%98%8E"><span class="nav-number">5.1.</span> <span class="nav-text">背景说明</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/13/String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="String | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          String
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-13 11:42:39" itemprop="dateCreated datePublished" datetime="2021-06-13T11:42:39+08:00">2021-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-07-31 17:57:19" itemprop="dateModified" datetime="2021-07-31T17:57:19+08:00">2021-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>  本文默认使用 HotSpot 虚拟机 + JDK8 ，如有其它情况会具体指出。</p>
</blockquote>
<h1 id="1-String-的基本特性"><a href="#1-String-的基本特性" class="headerlink" title="1  String 的基本特性"></a>1  String 的基本特性</h1><blockquote>
<p>  <strong>String；字符串；</strong></p>
</blockquote>
<p>顾名思义，就是把一个个的字符串在一起，所以说<strong>字符串的底层实现就是一个字符数组</strong>。</p>
<img src="/2021/06/13/String/1623398509911-a4c2e130-bfc9-4aa7-9a9d-531df6e1cdee.png" alt="image.png">

<ul>
<li>  String 被声明为 <strong>final</strong> 的表示类不可被继承。</li>
<li>  String 实现了 <strong>Serializable</strong> 接口，表示字符串是支持序列化的。</li>
<li>  String 实现了 <strong>Comparable</strong> 接口，表示 String 可以比较大小。</li>
<li>  在 JDK8 中，String 使用字符数组 <strong>final char[] value</strong> 数组来存储字符串数据。</li>
</ul>
<h2 id="1-1-String-存储结构的演变"><a href="#1-1-String-存储结构的演变" class="headerlink" title="1.1    String 存储结构的演变"></a>1.1    String 存储结构的演变</h2><ul>
<li>  在 JDK9 之前，String 底层是通过<strong>字符数组 <code>char[]</code></strong> 来保存字符串的。</li>
<li>  从 <strong>JDK9</strong> 开始，String 底层变成了通过<strong>字节数组 <code>byte[]</code></strong> 来保存字符串数据。【字符型 char 编码后都可以用数字（byte型）表示】</li>
</ul>
<blockquote>
<p>  <strong>为什么要变化？</strong></p>
</blockquote>
<p>String 底层将 <code>char[]</code> 变成 <code>byte[]</code> 来存储字符串数据，可以节约一些空间。</p>
<p>同时，String 的一些衍生对象，如 StringBuffer、StringBuilder 等也作出了同样的改变，将存储结构变更为了 byte[] 。</p>
<hr>
<h2 id="1-2-String-的不可变性"><a href="#1-2-String-的不可变性" class="headerlink" title="1.2    String 的不可变性"></a>1.2    String 的不可变性</h2><blockquote>
<p>  String：<strong>不可变的字符序列</strong></p>
</blockquote>
<ul>
<li>  当对字符串<strong>重新赋值</strong>时，会重新分配内存区域，重新赋值，而不是在原先 <code>value[]</code> 的基础上进行更新。</li>
<li>  当对现有的字符串进行<strong>拼接</strong>操作时，也是重新分配内存区域，重新赋值，而不是在原先 <code>value[]</code> 的基础上进行拼接、赋值。</li>
<li>  当<strong>调用 <code>String replace(char oldChar, char newChar)</code> 方法</strong>使用新字符串替换当前字符串指定的子串时，也是重新分配内存区域并重新赋值，而不能在原先字符串数组 <code>value[]</code> 的基础上进行操作。</li>
</ul>
<blockquote>
<p>  <strong>String 字符串为什么不能直接拼接字符串？【==String为什么设计成不可变的？】</strong></p>
</blockquote>
<p>String 的底层数据结构是 <code>char[]</code> 或 <code>byte[]</code>，由于<strong>数组的定长性</strong>，即一旦被创建出来，它的长度就就确定了，不能再被更改。在进行字符串拼接操作时，原数组的容量显然是不足以容纳拼接后的新数组的，所以只能新开辟一块更大的空间保存新的字符串，而不是去改变原有的字符串。【如果新数组的长度小于原数组，又会导致数组存在多个空白区域，造成内存的浪费，也是不合理的】</p>
<hr>
<h1 id="2-String-的内存分配"><a href="#2-String-的内存分配" class="headerlink" title="2  String 的内存分配"></a>2  String 的内存分配</h1><h2 id="String-对象可以保存在内存中的哪些位置"><a href="#String-对象可以保存在内存中的哪些位置" class="headerlink" title="String 对象可以保存在内存中的哪些位置"></a>String 对象可以保存在内存中的哪些位置</h2><blockquote>
<p>  <strong>String 对象可以保存在内存中的哪些位置?</strong></p>
</blockquote>
<ol>
<li> 字符串常量池中；</li>
<li> 堆中(的非字符串常量池空间)；</li>
<li> 二者都保存</li>
</ol>
<hr>
<h2 id="不同版本-JDK-中-StringPool-在内存中的调整"><a href="#不同版本-JDK-中-StringPool-在内存中的调整" class="headerlink" title="不同版本 JDK 中 StringPool 在内存中的调整"></a>不同版本 JDK 中 StringPool 在内存中的调整</h2><ul>
<li>  在 JDK7 之前，字符串常量池存放在<strong>方法区</strong>中（在 HotSpot 中就是永久代）。</li>
<li>  JDK7，HotSpot 将字符串常量池的位置调整到了<strong>堆</strong>中。</li>
<li>  JDK8：字符串常量池存储在方法区（元空间）</li>
</ul>
<blockquote>
<p>  <strong>问题：String Pool 为什么要从方法区调整到堆空间中？</strong></p>
</blockquote>
<p><strong>保存在方法区的缺点</strong>：</p>
<ol>
<li> 方法区（永久代/元空间）默认占用的内存空间较小，如果在方法区中保存大量的 String 对象，极易导致方法区空间出现 OOM  异常。</li>
<li> 即使将方法区初始的内存空间设置为一个较高的值，但是由于方法区进行 GC 的频率极低，这也就意味着在方法区中，String 对象在使用完后，无法做到及时的 GC，也会导致方法区频繁出现 OOM 异常。</li>
</ol>
<p><strong>保存在堆空间的优点</strong>：</p>
<ol>
<li> 首先堆空间解决了保存在方法区时的两个问题：①内存空间小。  ②GC不及时。</li>
<li> 所有的 String 字面量对象都保存在堆（Heap）中，它就和其它普通对象一样，这样的好处就是在进行 JVM 调优时只需调整堆的大小就可以了。【原来保存在元空间中时还要特意为了 String 常量池去进行元空间的性能调优】</li>
</ol>
<hr>
<h2 id="2-1-字符串常量池的数据结构"><a href="#2-1-字符串常量池的数据结构" class="headerlink" title="2.1    字符串常量池的数据结构"></a>2.1    字符串常量池的数据结构</h2><blockquote>
<p>  <strong>字符串常量池数据结构</strong></p>
</blockquote>
<ul>
<li>  通过字面量的方式<strong>（区别于 new）</strong>给一个字符串赋值，此时字符串的值保存在堆空间的字符串常量池中。</li>
<li>  <strong>字符串常量池的底层数据结构是一个 HashTable，所以说字符串常量池中不会存储相同内容的字符串</strong> 。</li>
<li>  String 的 StringPool 是一个固定大小的 HashTable，数组的默认长度在不同的 JDK 版本中均有所不同。</li>
<li>  如果放进 StringPool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后就会导致调用 <code>String.intern()</code> 时性能大幅下降。</li>
</ul>
<p><strong>参数信息：</strong></p>
<ul>
<li>  使用 <code>-XX:StringTableSize</code> 可以设置 StringPool 的长度。</li>
<li>  JDK6中，StringPool 的默认长度为 1009，可以任意设置大小；</li>
<li>  从 JDK7 开始，StringPool 的默认长度增加到了 60013 ；</li>
<li>  从 JDK8 开始，可设置的最小长度为 1009 。</li>
</ul>
<blockquote>
<p>  <strong>具体代码分析</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol>
<li> 由于字符串常量池在堆空间中，所以一个程序中所有的线程用的是同一个字符串常量池；</li>
<li> 由于字符串常量池底层是 HashTable 结构，所以池中不会出现重复的字符串，所以上述代码中的变量 <code>s1</code> 和 <code>s2</code> 指向的是同一个地址。</li>
<li> 由于字符串的不可变性，第 5 行代码中等号右边的语句会在字符串常量池中新开辟一块内存空间用于保存字符串“hello”，并将其赋值给等号左边的变量 s1。</li>
<li> 所以此时 s1 指向的是 “hello”  的地址，而 s2 指向的 “abc” 的地址，两者不相等。</li>
</ol>
<hr>
<h2 id="2-2-如何将字符串对象保存到字符串常量池中"><a href="#2-2-如何将字符串对象保存到字符串常量池中" class="headerlink" title="2.2    如何将字符串对象保存到字符串常量池中"></a>2.2    如何将字符串对象保存到字符串常量池中</h2><p>​        对于 Java 中的 8 种基本数据类型和引用类型 String，这些类型在程序中的使用是非常频繁的（二八原则），为了使这些类型的数据在内存中速度更快、更节省内存，都提供了一种常量池的概念。    </p>
<p>​        常量池就类似于一个 Java 系统级别提供的缓存。8 种基本类型数据的常量池都是系统协调的，String类型的常量池比较特殊，想要<strong>将字符串对象保存在字符串常量中主要方法有两种</strong> ：</p>
<ol>
<li>直接使用双引号声明出来的 String 对象（字符串字面量对象）会直接存储在常量池中。<ul>
<li>  比如： <code>String info = &quot;HelloWorld&quot;;</code> </li>
</ul>
</li>
<li> 如果不是通过双引号声明的 String 对象，也可以使用 String 提供的 <strong>intern()</strong> 方法将某个字符串对象加入到字符串常量池中。</li>
</ol>
<hr>
<h1 id="4-字符串拼接操作"><a href="#4-字符串拼接操作" class="headerlink" title="4  字符串拼接操作"></a>4  字符串拼接操作</h1><blockquote>
<ul>
<li>  字符串常量 + 字符串常量</li>
<li>  字符串常量 + 字符串变量</li>
<li>  字符串变量 + 字符串变量</li>
</ul>
</blockquote>
<h2 id="常量-常量"><a href="#常量-常量" class="headerlink" title="常量 + 常量"></a>常量 + 常量</h2><ul>
<li>  常量与常量的拼接结果还保存在字符串常量池中，原理是编译期优化。</li>
<li>  编译期优化：</li>
</ul>
<blockquote>
<p>  <strong>问题：如何理解“编译期优化”？</strong></p>
</blockquote>
<p>答：两个字符串常量相加，在被编译成 <code>.class</code> 字节码文件时就已经将这两个常量拼接为一个常量字面量了，所以加载到内存中的只有一个字符串字面量来，所以会将这个字符串字面量保存到字符串常量池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;    <span class="comment">// 在编译后，就等同于 &quot;abc&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  .java 文件需要先被编译成 .class 字节码文件，再被加载到JVM中执行。</span></span><br><span class="line"><span class="comment">     *      在 .class 文件中，s1 已经是一个拼接过的常量了。即</span></span><br><span class="line"><span class="comment">     *          String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     *          String s2 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     *      所以在将字节码文件加载到 JVM 中运行时这两个常量都会保存在堆空间的常量池中，</span></span><br><span class="line"><span class="comment">     *	 并且常量池中不允许出现重复的元素，所以说 s1 和 s2 指向同一个对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2);   <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s2));      <span class="comment">// true</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<hr>
<h2 id="常量-变量-变量"><a href="#常量-变量-变量" class="headerlink" title="常量/变量 +变量"></a>常量/变量 +变量</h2><ul>
<li>  常量池中不会保存相同内容的字面量对象。</li>
</ul>
<blockquote>
<p>  <strong>结论：</strong></p>
</blockquote>
<ul>
<li>  在多个字符串拼接操作中，只要存在变量，结果就<strong>只会</strong>保存在堆中的非常量池区域。</li>
<li>  <strong>Tip：此时拼接后的 String 对象只会保存在堆中的非常量池区域，而不会同步保存到字符串常量池中！！！</strong></li>
</ul>
<blockquote>
<p>  <strong>原理：</strong>字符串拼接操作底层是通过 <code>StringBuilder#append()</code> 方法实现的。</p>
</blockquote>
<p>在多个字符串拼接操作中，只要存在变量，那么 JVM 在进行字符串拼接的时候，</p>
<ol>
<li> 首先会 <code>new StringBuilder()</code> 对象，</li>
<li> 然后调用该对象中的 <code>append()</code> 方法拼接字符串，</li>
<li> 最后再调用  <code>StringBuilder#toString()</code> 方法，将拼接后的字符串对象转换成 String 对象，并将这个 String 对象保存在堆中(的非常量池区域)。</li>
</ol>
<blockquote>
<p>  <strong>代码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + s2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        s1 + s2 的执行细节：</span></span><br><span class="line"><span class="comment">            1、StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="comment">            2、sb.append(s1);</span></span><br><span class="line"><span class="comment">            3、sb.append(s2);</span></span><br><span class="line"><span class="comment">            4、sb.toString();  --&gt;&gt; 类似于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  最终 s4 指向的地址是在第 4 步的 <code>sb.toString()</code> 中确定的，这个方法类似于 <code>new String()</code>，但是并不相同。</li>
<li>  <strong>使用 <code>new String()</code> 创建出来的 String 对象会同时保存在堆和字符串常量池中</strong>，而 <code>StringBuilder#toString()</code> 方法生成的 String 对象只保存在堆中(的非常量池区域)。</li>
</ul>
<blockquote>
<p>  <strong>Tip</strong>：</p>
</blockquote>
<ul>
<li>  在 JDK5 之前，含有变量的字符串拼接操作，底层使用的类是 StringBuffer，<em>因为 JDK5 之前并没有 StringBuilder 这个类</em>；</li>
<li>  从 JDK5 开始，才使用 StringBuilder 代替 StringBuffer 来完成含有变量的字符串拼接操作。</li>
</ul>
<blockquote>
<p>  <strong>字节码文件</strong></p>
</blockquote>
<p><img src="/2021/06/13/String/1623478701279-d327aa0f-fdc0-47a9-a63e-e310317f7271.png" alt="test.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">2</span> &lt;a&gt;   <span class="comment">// 在字符串常量池中创建一个字面量对象&lt;a&gt;，并得到该字面量对象的内存地址</span></span><br><span class="line"> <span class="number">2</span> astore_1     <span class="comment">// 将字面量&lt;a&gt;的内存地址保存到栈中栈帧的局部变量表中下标为 1 的位置上</span></span><br><span class="line"> <span class="number">3</span> ldc #<span class="number">3</span> &lt;b&gt;  </span><br><span class="line"> <span class="number">5</span> astore_2     </span><br><span class="line"> <span class="number">6</span> ldc #<span class="number">4</span> &lt;ab&gt;  </span><br><span class="line"> <span class="number">8</span> astore_3    </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/* 创建 StringBuilder 对象开始 */</span></span><br><span class="line"> <span class="number">9</span> <span class="keyword">new</span> #<span class="number">5</span> &lt;java/lang/StringBuilder&gt; </span><br><span class="line"><span class="number">12</span> dup</span><br><span class="line"><span class="number">13</span> invokespecial #<span class="number">6</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="comment">/*  创建 StringBuilder 对象结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span> aload_1  <span class="comment">// 取出局部变量表中下标为1的位置上的值，即常量池中字面量对象&lt;a&gt;的地址值</span></span><br><span class="line"><span class="number">17</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;    <span class="comment">// 调用 StringBuilder#append() 将该值追加到 StringBuilder 对象中</span></span><br><span class="line"><span class="number">20</span> aload_2  </span><br><span class="line"><span class="number">21</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">     </span><br><span class="line"><span class="number">24</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.toString&gt;  <span class="comment">// 调用 StringBuilder#toString() 将StringBuilder对象转化为String对象</span></span><br><span class="line"><span class="number">27</span> astore <span class="number">4</span> <span class="comment">// 将上一条指令得到的String对象的内存地址值保存到局部变量表下标为4的位置上</span></span><br><span class="line"></span><br><span class="line"><span class="number">29</span> <span class="keyword">new</span> #<span class="number">5</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">32</span> dup</span><br><span class="line"><span class="number">33</span> invokespecial #<span class="number">6</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">36</span> ldc #<span class="number">2</span> &lt;a&gt;   <span class="comment">// 从常量池中得到字符串常量&lt;a&gt;</span></span><br><span class="line"><span class="number">38</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;    </span><br><span class="line"><span class="number">41</span> aload_2      </span><br><span class="line"><span class="number">42</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;    </span><br><span class="line"><span class="number">45</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.toString&gt;  </span><br><span class="line"><span class="number">48</span> astore <span class="number">5</span>     </span><br><span class="line">     </span><br><span class="line"><span class="number">50</span> <span class="keyword">return</span>   <span class="comment">// 返回</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="特殊情况：final-修饰的变量"><a href="#特殊情况：final-修饰的变量" class="headerlink" title="特殊情况：final 修饰的变量"></a>特殊情况：final 修饰的变量</h2><p>使用 <code>final</code> 修饰的变量等价于常量，因为在 <code>.java</code> 源文件在编译成 <code>.class</code> 字节码文件的时候就已经把 <code>final</code> 修饰的变量转换成常量值了（编译期优化）。也就是说加载到内存中的就是字符串字面量常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);  <span class="comment">// true</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用 final 修饰的变量，在编译成字节码文件的时候就已经把这些变量转换成常量了（编译期优化），</span></span><br><span class="line"><span class="comment">        也就是说加载到内存中的是常量字符串，常量与常量的拼接自然保存在常量池中。</span></span><br><span class="line"><span class="comment">        所以可以得到 s3==s4 为 true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>如果拼接的结果调用 <code>intern()</code> 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象在常量池中的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;   <span class="comment">// String Pool；poolAddress[0]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;   <span class="comment">// String Pool；poolAddress[1]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;     <span class="comment">// String Pool；poolAddress[2]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;    <span class="comment">// String Pool；poolAddress[2]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;  <span class="comment">// Not String Pool； heapAddress[0]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;  <span class="comment">// Not String Pool; heapAddress[1]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;    <span class="comment">// Not String Pool; heapAddress[2]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();    <span class="comment">// String Pool；poolAddress[2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     *      s1 保存在字符串常量池中，地址为 poolAddress[0]；</span></span><br><span class="line"><span class="comment">     *      s2 保存在字符串常量池中，地址为 poolAddress[1]；</span></span><br><span class="line"><span class="comment">     *      s3 保存在字符串常量池中，地址为 poolAddress[2]；</span></span><br><span class="line"><span class="comment">     *      s4 是两个常量的拼接，由于编译期优化，结果仍保存在常量池中，并且地址为 poolAddress[2]；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      s5 是 变量+常量 的拼接，结果只会保存在堆中的非常量池区域，所以 s5 的地址为 heapAddress[0]；</span></span><br><span class="line"><span class="comment">     *      s6 也是 变量+常量 的拼接，结果会保存在堆中的非常量池区域，并且在非常量池区域并没有要求相同的值只能保存一份数据，所以 s6 会占用一块新的内存空间，地址为 heapAddress[1]；</span></span><br><span class="line"><span class="comment">     *      s7 也是 变量+变量 的拼接，结果会保存在堆中的非常量池区域，原理同 s6 一样，s7 的地址为 heapAddress[2]；</span></span><br><span class="line"><span class="comment">     *      s8 是 s6 调用 intern() 方法得到的返回值，由于s6对应的字符串字面量在常量池中已经存在了，所以 s8 的地址值为 poolAddress[2];</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);   <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s5);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s6);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s7);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s6);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s7);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s6 == s7);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s8);   <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="5-intern-方法"><a href="#5-intern-方法" class="headerlink" title="5  intern() 方法"></a>5  intern() 方法</h1><h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><blockquote>
<p>  <strong>源码分析</strong></p>
</blockquote>
<p><img src="/2021/06/13/String/1623488782339-dd95c67e-52d3-4dfd-887b-52ed4e499a47.png" alt="image.png"></p>
<p>​        <strong>intern()</strong> 方法是 String 类中的一个方法，查看源码可知，<code>String#intern()</code> 方法是一个 <code>native</code> 修饰的本地方法。也就是说，其具体实现是由 C/C++ 编写的。</p>
<blockquote>
<p>  <strong>主要作用：</strong></p>
</blockquote>
<p>现有一个字符串对象 <code>String s1</code> ，当调用 <code>s1.intern()</code> 方法时，</p>
<ol>
<li> 首先要去判断字符串常量池中是否已经存在一个 String 对象其字面量与 s1 的字面量相同；</li>
<li> 如果存在，那么就返回字符串常量池中该 String 对象的地址；</li>
<li> 如果不存在，就将 s1 对象的字面量值拷贝一份到字符串常量池中，并返回该 String 对象在字符串常量池中的地址。</li>
</ol>
<blockquote>
<p>  <strong>Tip：</strong></p>
</blockquote>
<p>调用 <code>String#intern()</code> 方法可以确保字符串在内存中只有一份数据，这样可以节约内存空间，加快字符串操作任务的执行速度。</p>
<p><strong>分析：</strong></p>
<ul>
<li>  调用 <code>String#intern()</code> 方法后，如果 String 对象原本就保存在字符串常量池中，那不会有任何改变；</li>
<li>  如果 String 对象原本保存在堆(的非字符串常量池区域)中，那么调用此方法后，就会返回一个字符串常量池中对象的地址。</li>
<li>  这时就可以把原来堆(的非字符串常量池区域)中的 String 对象回收掉，让内存中只保留一份字符串字面量数据。【这一步不是必须的】</li>
</ul>
<hr>
<h2 id="intern-的使用场景"><a href="#intern-的使用场景" class="headerlink" title="intern() 的使用场景"></a>intern() 的使用场景</h2><p>如果不是通过字符串字面量（即双引号）创建的 String 对象，如果想要将其保存到字符串常量池中，可以使用 String 提供的 intern() 方法。</p>
<blockquote>
<p>  <strong>问题：如何保证字符串变量 s 指向的字符串是字符串常量池中的数据而不是堆中非常量池区域的数据呢？</strong></p>
</blockquote>
<p>答：有2种方式</p>
<ol>
<li> 直接通过双引号而不是 new 关键字来创建 String 对象。如：<code>String s = &quot;HelloWorld&quot;;</code></li>
<li> 对堆中的字符串对象，调用 <code>intern()</code> 方法，得到的返回值就是指向字符串常量池中对应字符串字面量的地址。</li>
</ol>
<blockquote>
<p>  <strong>问题：<code>new String(&quot;HelloWorld&quot;)</code> 会创建几个对象？</strong> </p>
</blockquote>
<p>答：如果在此之前，字符串常量池中已有字面量对象 <code>“HelloWorld”</code>，则只会在堆中新建 1 个对象；否则会新建 2 个对象，一个保存在堆中非字符串常量池区域（和普通对象一样），另一个保存在字符串常量池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	创建动作分解：</span></span><br><span class="line"><span class="comment">    	1、new String()  堆中；</span></span><br><span class="line"><span class="comment">    	2、&quot;HelloWorld&quot;  字符串常量池中；</span></span><br><span class="line"><span class="comment">    	3、执行堆中的 String 对象的初始化方法；</span></span><br><span class="line"><span class="comment">    	4、将等式左边的地址赋值给等式右边的变量。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 首先，在堆中非常量池区域中创建一个 String 对象。</li>
<li> 其次，在字符串常量池中创建字面量为 <code>&quot;HelloWorld&quot;</code> 的字面量对象。</li>
<li> 再次，调用 String 类的构造方法，对字符串对象 s 进行显式初始化；</li>
<li> 最后，将结果地址保存到局部变量表下标为 1 的位置上。</li>
<li> <strong>注意：虽然现在字符串常量池和堆中都有“HelloWorld”这个字符串对象，但是此时 s 得到的地址是堆中的！！！</strong></li>
</ol>
<p><img src="/2021/06/13/String/1623491535138-3562077b-906b-41ae-aaee-49806b528949.png" alt="image.png"></p>
<blockquote>
<p>  <strong>扩展：<code>String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> 会创建多少个对象？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/13/String/1623492457552-7821a5f9-93b5-44b1-aabf-11514fb0ba93.png" alt="image.png"></p>
<p>分析：</p>
<ul>
<li>  对象1：<code>new StringBuilder()</code>， 首先，两个字符串变量拼接时，需要一个辅助对象 StringBuilder 。</li>
<li>  对象2：<code>new String(&quot;a&quot;)</code>，</li>
<li>  对象3：常量池中的字面量对象 “a”</li>
<li>  对象4：<code>new String(&quot;b&quot;)</code>，</li>
<li>  对象5：常量池中的字面量对象 “b”</li>
<li>  对象6：在调用 <code>StringBuilder.toString()</code> 方法时，根据 <code>toString()</code> 方法的源码，还要创建一个 String 对象。</li>
</ul>
<blockquote>
<p>  <strong>toString() 方法</strong></p>
</blockquote>
<p><strong>虽然 toString() 方法底层调用了 new String() 方法，但是却不会在字符串常量池中创建对应的字符串对象，只会在堆中创建字符串对象。</strong></p>
<p><img src="/2021/06/13/String/1623492807620-7f60184d-4382-4830-b450-95b9019c6051.png" alt="image.png"></p>
<blockquote>
<p>  <code>StringBuilder#toString()</code> 的字节码文件</p>
</blockquote>
<ul>
<li>  我们可以看到并没有在字符串常量池中创建 String 对象。</li>
</ul>
<p><img src="/2021/06/13/String/image-20210613173632473.png" alt="image-20210613173632473"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);    <span class="comment">// s1 --&gt;&gt; Not String Pool ；heapAddr[0]</span></span><br><span class="line">    s1.intern();    <span class="comment">// s1 --&gt;&gt; Not String Pool ；heapAddr[0]</span></span><br><span class="line">    			   <span class="comment">// s1.intern() 的返回值 --&gt;&gt; String Pool ； poolAddr[0]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;    <span class="comment">// s2 --&gt;&gt; String Pool ； poolAddr[0]</span></span><br><span class="line">    System.out.println(s1 == s2);   <span class="comment">// False</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ol>
<li><p>使用 <code>new</code> 关键字创建对象，</p>
<ul>
<li>  首先会在堆中非常量池区域分配内存保存字符串对象 “1” ；</li>
<li>  并且之后还会在常量池中分配内存保存字面量对象 “1” ;</li>
<li>  但是此时栈中局部变量表中的 s1 保存的是堆中非常量池区域的字符串对象的内存地址；</li>
</ul>
</li>
<li><p>调用 <code>s1.intern()</code> 方法，JVM 尝试在字符串常量池中创建值为 “1” 的字面量对象，发现已存在，得到该字面量对象的地址，作为方法的返回值。<code>intern()</code> 方法是有返回值的，返回值就是字面量对象 “1” 在字符串常量池中的内存地址，但是在本例中并没有接收这个地址，也就是说目前为止，s1 指向的仍然是堆中非常量池区域中那个字符串对象的内存地址。</p>
</li>
<li><p>直接使用双引号创建 String 对象，JVM 会尝试在字符串常量池中创建值为 “1” 的字面量对象，发现已存在，得到该字面量对象的地址，并将此字面量对象的内存地址保存在栈的局部变量表中，即此时 s2 指向字符串常量池中对应字面量对象的地址。</p>
</li>
<li><p>所以，<code>s1==s2</code> 结果为 False</p>
</li>
</ol>
<h3 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// s3 --&gt;&gt; Not String Pool ；heapAddr[1]</span></span><br><span class="line">       s3.intern();    <span class="comment">// // s3 --&gt;&gt; Not String Pool ；heapAddr[1]</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;    <span class="comment">// JDK6：String Pool ； poolAddr[1]  JDK7：Not String Pool ；heapAddr[1]</span></span><br><span class="line">       System.out.println(s3 == s4);   <span class="comment">// JDK6：False  JDK7：True</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>s3</code> 指向的对象是由两个字符串对象拼接而成的，在进行字符串拼接时，底层要借助 <code>StingBuilder</code> 实现。其中有一步需要使用 <code>StringBuilder#toString()</code> 方法将 <code>Stringbuilder</code> 对象转换成 <code>String</code> 对象，在使用 <code>toString()</code> 方法时，<strong>只</strong>会在堆中的非常量池区域创建一个 <code>String</code> 对象，并不会在常量池中创建这个对象对应的字面量对象（类似于 new，但不会同步到常量池中）。所以第 2 行代码在执行完毕后 <code>s3</code> 指向一个堆中的字符串对象。</li>
<li>由于此时字符串常量池中没有字面量对象 <code>“11”</code>，所以调用 <code>intern()</code> 方法会在常量池中创建一个字符串对象<code>“11&quot;</code>并返回其地址值。<ul>
<li>  在 JDK7 之前，由于字符串常量池不在堆空间中，所以会真正意义上的在字符串常量池创建一个字符串对象<code>“11”</code>并返回其地址值。</li>
<li>  从 JDK7 开始，由于字符串常量池也保存在堆空间中，所以这时不会在常量池中创建真正的字符串对象<code>“11”</code>了，而是直接拿来了 s3 对象的地址值。</li>
</ul>
</li>
<li>此处没有使用 <code>intern()</code> 方法的返回值，所以 s3 仍然指向堆中非常量池空间中的那个字符串对象的地址。</li>
<li>直接使用字面量创建String对象。由于此时字符串常量池中已有该字面量对象，所以不再新建对象，只是返回字面量对象的地址，而显然该字面量对象的地址是一个地址值，最后真正指向的对象还是堆中非常量池区域的那个String对象，而返回地址按照对象的就近原则也是堆中非常量池区域的String对象的地址值。</li>
<li>所以说， 在JDK7之前，<code>s3 == s4</code> 为 False；而从JDK7开始，<code>s3 == s4</code> 为 True</li>
</ol>
<img src="/2021/06/13/String/1623508433062-ce767a2e-fba1-4f8d-bd53-374635e01625.png" alt="intern的使用 (1).png" style="zoom: 67%;">





<h2 id="不同版本JDK中不同方式创建字符串对象的先后顺序的影响"><a href="#不同版本JDK中不同方式创建字符串对象的先后顺序的影响" class="headerlink" title="不同版本JDK中不同方式创建字符串对象的先后顺序的影响"></a>不同版本JDK中不同方式创建字符串对象的先后顺序的影响</h2><ol>
<li> 如果只想在堆的非字符串常量池区域创建对象： <code>String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> 此时字符串常量池中没有“ab”对应的字面量对象。</li>
<li>如果这时继续在常量池中也保存一份 “ab” 字符串对应的字面量对象。可以调用 <code>s1.intern();</code> 方法。<ul>
<li>  从 JDK7 开始，为了节省内存，在常量池中创建字符串对象这一步，如果在堆的非常量池区域存在相同字面量值的对象，就不再创建一个“真正”的字面量对象了，而是在常量池的字面量对象的地址中保存堆中非常量池区域那个对象的地址值。</li>
<li>  而在 JDK7 之前，在常量池中创建的对象时真正意义上的字面量对象，保存的是真正的数据值，而不是对象的引用。</li>
</ul>
</li>
<li> 如果使用 <code>String s1 = new String(&quot;1&quot;);</code> 创建对象，这时会创建两个对象，即字符串常量池中的字面量对象和 Java 堆的非字符串常量池区域的对象，这两个对象都是真正意义上的对象。上述1，2的规则就不再使用了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK8 中测试</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// Not String Pool ；heapAddr[1]</span></span><br><span class="line">       s3.intern();    <span class="comment">// String Pool ； poolAddr[1]</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;    <span class="comment">// Not String Pool ；heapAddr[1]</span></span><br><span class="line">       System.out.println(s3 == s4);   <span class="comment">// True</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       调换了2、3行代码的执行顺序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// Heap&#x27;s Not String Pool ；heapAddr[0]</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;    <span class="comment">// String Pool ; poolAddr[0]</span></span><br><span class="line">       s3.intern();    <span class="comment">// String Pool ； poolAddr[0]</span></span><br><span class="line">       System.out.println(s3 == s4);   <span class="comment">// False</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>总结：String中intern()的使用：</strong></p>
</blockquote>
<ul>
<li><p>  在 JDK7 之前，将字符串对象尝试放入字符串常量池中时：</p>
</li>
<li><ul>
<li>  如果字符串常量池中已经含有，则并不会放入，并返回已有对象的内存地址；</li>
<li>  如果字符串常量池中没有，则会将当前对象的值复制一份，放入字符串常量池，并返回字符串常量池中该对象的内存地址；</li>
</ul>
</li>
<li><p>  从 JDK7 开始，将字符串对象尝试放入字符串常量池中时：</p>
</li>
<li><ul>
<li>  如果字符串常量池中已经含有该字面量对象，则直接返回该字面量对象的内存地址即可；</li>
<li>  如果没有，则会把<strong>对象的引用地址复制一份</strong>，放入字符串常量池，并返回字符串常量池中的引用地址。</li>
</ul>
</li>
</ul>
<h2 id="intern-的练习"><a href="#intern-的练习" class="headerlink" title="intern 的练习"></a>intern 的练习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//      String x = &quot;ab&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// 在上一行代码执行完毕之后，字符串常量池中并没有字面量对象 &quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">        <span class="comment">// JDK6中，在字符串常量池中创建字面量对象 &quot;ab&quot; ，并将地址值赋给 s2</span></span><br><span class="line">        <span class="comment">// JDK8中，在字符串常量池中没有创建字面量对象 &quot;ab&quot;，而是创建了一个引用对象，指向堆中非字符串常量池中的地址并将地址返回</span></span><br><span class="line">        System.out.println(s1 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false（JDK6）；true（JDK8）</span></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);  <span class="comment">// &quot;ab&quot; --&gt;&gt; Heap   执行完以后，在字符串常量池中不会生成 &quot;ab&quot;</span></span><br><span class="line">    s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   <span class="comment">// s2 --&gt;&gt; String Pool --&gt;&gt; Heap</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);   <span class="comment">// &quot;ab&quot; --&gt;&gt; Heap, SringPool    执行完以后，在字符串常量池中会生成 &quot;ab&quot;，但是s1指向的是Heap中的那个</span></span><br><span class="line">    s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   <span class="comment">// s2 --&gt;&gt; String Pool</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="7-G1-中的-String-去重操作"><a href="#7-G1-中的-String-去重操作" class="headerlink" title="7  G1 中的 String 去重操作"></a>7  G1 中的 String 去重操作</h1><p>字符串常量池中本就不允许存储重复元素，所以 String 的去重操作针对的是堆中非字符串常量池的区域。</p>
<p>String s1 = new String(“hello”);</p>
<p>String s1 = new String(“hello”);</p>
<p>什么是去重操作？（图）</p>
<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><blockquote>
<p>  背景</p>
</blockquote>
<p>通过对大量 Java 应用的研究测试表明：</p>
<ul>
<li>  堆中存活的数据集合中 String 对象占据了约 25%；</li>
<li>  其中 String 对象中重复的对象又占了约 13.5%；重复的意思就是： <code>string1.equals(string2) == true</code> </li>
<li>  堆上存在重复的String对象必然是一种内存资源的浪费。</li>
<li>  String 对象的平均长度是 45</li>
</ul>
<p>许多大规模Java应用的瓶颈在于内存，而这些项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样能避免浪费内存。</p>
<hr>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="prev" title="JVM——类加载机制">
                  <i class="fa fa-chevron-left"></i> JVM——类加载机制
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/14/%E9%93%BE%E8%A1%A8/" rel="next" title="链表">
                  链表 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
