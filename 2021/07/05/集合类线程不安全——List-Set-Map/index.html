<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="ArrayList 线程不安全   带着问题学习：  在 Java8 中，   new ArrayList&lt;&gt;() 的底层数据结构是什么？  new ArrayList&lt;&gt;() 的初始长度是多少？  数组长度一旦初始化就不能再修改了，Java 底层对 ArrayList 扩容的机制是什么？  数组扩容的标准是什么？每次扩容多大？  ArrayList 是线程安全的吗？  写">
<meta property="og:type" content="article">
<meta property="og:title" content="集合类线程不安全——List&#x2F;Set&#x2F;Map">
<meta property="og:url" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="ArrayList 线程不安全   带着问题学习：  在 Java8 中，   new ArrayList&lt;&gt;() 的底层数据结构是什么？  new ArrayList&lt;&gt;() 的初始长度是多少？  数组长度一旦初始化就不能再修改了，Java 底层对 ArrayList 扩容的机制是什么？  数组扩容的标准是什么？每次扩容多大？  ArrayList 是线程安全的吗？  写">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705132107889.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705110738072.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705111012804.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705111123760.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705133755514.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705140516278.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705112039567.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705112635200.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705112857905.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705114523086.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705114959424.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705144202128.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705144627777.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705145256894.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705145658774.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705145828821.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705205807031.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705211114239.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705211801881.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705212216863.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705213152762.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705213534400.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705215106596.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705214658694.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705221837637.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705225253807.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705225457854.png">
<meta property="og:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705225617057.png">
<meta property="article:published_time" content="2021-07-05T01:39:29.000Z">
<meta property="article:modified_time" content="2021-09-22T10:02:01.873Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705132107889.png">


<link rel="canonical" href="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/","path":"2021/07/05/集合类线程不安全——List-Set-Map/","title":"集合类线程不安全——List/Set/Map"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>集合类线程不安全——List/Set/Map | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ArrayList-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">1.</span> <span class="nav-text">ArrayList 线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ArrayList-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">1    ArrayList 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ArrayList-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">2    ArrayList 构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">空参构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">带参构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-ArrayList-%E7%9A%84%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="nav-number">1.3.</span> <span class="nav-text">3    ArrayList 的动态扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-ArrayList-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">1.4.</span> <span class="nav-text">4    ArrayList 线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">ArrayList 线程不安全案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%951%EF%BC%9AVector"><span class="nav-number">1.4.2.</span> <span class="nav-text">解决方法1：Vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8-Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-ArrayList"><span class="nav-number">1.4.3.</span> <span class="nav-text">解决方法2：使用 Collections 工具类创建线程安全的 ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%953%EF%BC%9ACopyOnWriteArrayList"><span class="nav-number">1.4.4.</span> <span class="nav-text">解决方法3：CopyOnWriteArrayList</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashSet-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">2.</span> <span class="nav-text">HashSet 线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-HashSet-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">1    HashSet 底层数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81-HashSet-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2    代码验证 HashSet 线程不安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-HashSet-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%882%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">3    如何解决 HashSet 线程不安全（2种方法）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">3.</span> <span class="nav-text">HashMap 线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81-HashMap-%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">3.1.</span> <span class="nav-text">1    代码验证 HashMap 不安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-HashMap-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">3.2.</span> <span class="nav-text">2    如何解决 HashMap 线程不安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.3.</span> <span class="nav-text">3    ConcurrentHashMap源码分析</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="集合类线程不安全——List/Set/Map | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          集合类线程不安全——List/Set/Map
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-05 09:39:29" itemprop="dateCreated datePublished" datetime="2021-07-05T09:39:29+08:00">2021-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-22 18:02:01" itemprop="dateModified" datetime="2021-09-22T18:02:01+08:00">2021-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="ArrayList-线程不安全"><a href="#ArrayList-线程不安全" class="headerlink" title="ArrayList 线程不安全"></a>ArrayList 线程不安全</h1><blockquote>
<p>  <strong>带着问题学习：</strong></p>
</blockquote>
<p>在 Java8 中，</p>
<ol>
<li> <code>new ArrayList&lt;&gt;()</code> 的底层数据结构是什么？</li>
<li> <code>new ArrayList&lt;&gt;()</code> 的初始长度是多少？</li>
<li> 数组长度一旦初始化就不能再修改了，Java 底层对 ArrayList 扩容的机制是什么？</li>
<li> 数组扩容的标准是什么？每次扩容多大？</li>
<li> ArrayList 是线程安全的吗？</li>
<li> 写一个 ArrayList 不安全的例子？</li>
<li> 如何解决 ArrayList 线程不安全？有几种方法？</li>
</ol>
<blockquote>
<p>  <strong>答案：</strong></p>
</blockquote>
<ol>
<li><p> ArrayList 底层的数据结构是 Object 数组： <code>Object[] elementData</code>。</p>
</li>
<li><p> <strong>使用 <code>new ArrayList&lt;&gt;()</code>  不会在内存中创建新的数组对象，而是将引用指向了一个在类加载阶段就已经创建好了的容量为 0 的空数组，只有在调用了 <code>add()</code> 方法时，才会在堆空间中创建一个数组对象，并设置数组的初始容量为 10</strong>。</p>
</li>
<li><p>Java 底层对 ArrayList 进行扩容使用的是 <strong>Arrays.copyOf()</strong> 方法，更深一层是 <strong>System.arraycopy()</strong> 方法（System.arraycopy 是一个本地方法）。</p>
<ul>
<li>  ArrayList 底层是用数组实现的，对于数组而言，其容量只能被指定一次，而 ArrayList 的扩容机制其实就是创建一个容量更大的新的数组，将原先数组中的数据全部拷贝到新数组中去。</li>
</ul>
</li>
<li><p>正常情况下，ArrayList 扩容的标准是每次扩张一半，即数组容量扩大 1.5 倍。比如，新建一个 ArrayList 数组，数组容量最初为 10，第一次扩容后从 10 扩展到 15，第二次则是从 15 扩展到 22。</p>
<ul>
<li><p>  但是，如果数组扩容 1.5 倍后仍不够用的话，那么有多少个元素，就把容量到多少，即数组的容量刚好能盛下所有元素；</p>
</li>
<li><p>  还有一种情况，数组的容量是有上限的，这个上限值被规定为 <strong>Integer.MAX_VALUE</strong>（因为数组下标是 int 类型的所以最大值不能超出 Integer 的取值范围），达到最大值后再怎么扩容数组容量都不会再变了。</p>
</li>
<li><p>  扩展：HashMap 的初始长度是 16，每次扩容容量增加一倍。</p>
</li>
</ul>
</li>
<li><p> ArrayList 是线程不安全的。</p>
</li>
<li><p> 例子见下文</p>
</li>
<li><p>解决 ArrayList 的线程不安全有多种方法，根据使用场景自行选择。本文罗列出来了 3 种。</p>
<ul>
<li>  <code>new Vector()</code></li>
<li>  <code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code></li>
<li>  <code>new CopyOnWriteArrayList&lt;&gt;()</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="1-ArrayList-概述"><a href="#1-ArrayList-概述" class="headerlink" title="1    ArrayList 概述"></a>1    ArrayList 概述</h2><p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705132107889.png" alt="image-20210705132107889"></p>
<ul>
<li>  <code>ArrayList</code> 实现了<code> List</code> 接口，继承了 <code>AbstractList</code> 类；</li>
<li>  底层数据结构是一个 Object 数组， <code>Object[] elementData</code>。并通过一系列机制实现了数组的自动扩容。</li>
<li>  它是线程不安全的，一般多用于单线程环境下（与 Vector 最大的区别就是，Vector 是线程安全的，但是 ArrayList 性能更好）；</li>
<li>  它实现了 Serializable 接口，支持序列化，能够通过序列化传输；</li>
<li>  它实现了 RandomAccess 接口，支持快速随机访问，这里表现为可以通过下标直接访问（底层是数组实现的，所以可以直接用数组下标来索引）；</li>
<li>  实现了 Cloneable 接口，能被克隆。</li>
<li>  <strong>数组是不可以自动扩容的！</strong></li>
</ul>
<hr>
<h2 id="2-ArrayList-构造方法"><a href="#2-ArrayList-构造方法" class="headerlink" title="2    ArrayList 构造方法"></a>2    ArrayList 构造方法</h2><p><code>ArrayList</code> 一共提供了 3 个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>



<ul>
<li>  源码分析（部分）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组默认的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类加载阶段就已经创建好了的一个不可变的、共享的、空的 Object[] 数组对象</span></span><br><span class="line"><span class="comment">     *   如果用户创建的数组对象是空的，那么无需在堆中新建一个对象，直接引用这个实例即可。</span></span><br><span class="line"><span class="comment">     *	 好处就是如果程序中存在多个空数组对象，不会浪费更多的内存为每个空数组分配空间，只使用这一个即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	*	主要用于与 EMPTY_ELEMENTDATA 区分开来。二者实现方式相同</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存了到达非空数组对象的地址</span></span><br><span class="line"><span class="comment">     * transient 修饰表示序列化时忽略该字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 	size 表示 elementData 的长度。</span></span><br><span class="line"><span class="comment">     *  注意 size 是 ArrayList 的一个私有变量，用于记录该 list 集合中有效元素的数量，而不是容量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  ArrayList 的单参构造函数，构造具有指定初始容量的空列表。创建时需要传递数组长度 initialCapacity</span></span><br><span class="line"><span class="comment">     *      1、数组长度大于0，新建一个 Object[initialCapacity] 数组，并返回地址</span></span><br><span class="line"><span class="comment">     *      2、数组长度等于0，不在堆中新建数组对象，直接让 elementData 指向类加载阶段就创建好的空数组</span></span><br><span class="line"><span class="comment">     *      3、数组长度小于0，抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造函数。如果是空参构造函数的话，不会在内存中新建对象，而是直接让 elementData 指向</span></span><br><span class="line"><span class="comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA，这是一个空数组。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 在 ArrayList 实例对象调用 add() 方法的时候，才会真正创建 Object[10] 数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="空参构造器"><a href="#空参构造器" class="headerlink" title="空参构造器"></a>空参构造器</h3><blockquote>
<p>  首先查看源码中 <strong>无参构造器</strong> 的实现：</p>
</blockquote>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705110738072.png" alt="image-20210705110738072"></p>
<ul>
<li>  上面的注释表明：无参构造器将会提供一个初始容量为 10 的空数组，即 Object[10]。</li>
<li>  但是实际上并不是在这一步实现的。我们继续查看 <strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong> 和 <strong>elementData</strong> 的源码。</li>
<li>  发现 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 只是一个空数组，这一步只是让 <strong>elementData</strong> 指向了一个容量为 0  的空数组罢了。</li>
</ul>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705111012804.png" alt="image-20210705111012804"></p>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705111123760.png" alt="image-20210705111123760"></p>
<hr>
<h3 id="带参构造器"><a href="#带参构造器" class="headerlink" title="带参构造器"></a>带参构造器</h3><p>ArrayList 有<strong>两个带参构造器</strong> ，其实现分别如下：</p>
<blockquote>
<ol>
<li> <strong>public ArrayList(Collection&lt;? extends E&gt; c)</strong> ：</li>
</ol>
</blockquote>
<ul>
<li><p>  这个构造器用于将一个 Collection 的子类实例对象中的所有元素拷贝到新集合的 elementData 中。</p>
</li>
<li><p>Collection 的子类实例对象有两种情况：</p>
<p>  ① 如果实例对象为空，则直接复用类加载阶段就已经创建好的空数组即可；</p>
<p>  ② 如果实例对象不为空，将原实例对象中的所有元素复制一份到新数组中。</p>
</li>
</ul>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705133755514.png" alt="image-20210705133755514"></p>
<p><code>Collection#toArray()</code> 方法是一个抽象方法，具体的实现过程由实现类决定，该方法的作用是：返回一个包含此集合中所有元素的数组，返回值是 <code>Object[]</code> 数组，并且 <code>Object[]</code> 数组长度与集合中有效元素的个数是一样的。</p>
<ol>
<li> 首先将 <strong>Collection c</strong> 中的元素全部转添加到 <code>Object[]</code> 类型的 <strong>elementData</strong> 中；</li>
<li> 获取 elementData 数组的长度 length 并将其赋值给 size， size 用于记录集合中有效元素个数。</li>
<li>判断：<ul>
<li>  如果 size 不为 0，正常情况下，<code>elementData.getClass() == Object[].class</code> 应该是恒成立的，也就不用进入 if 条件的执行体中，如果因为一些其它原因导致 <code>c.toArray</code> 方法没有返回 <code>Object[]</code> 类型，则会进入 if 条件的执行体中调用 <code>Arrays.copyOf()</code> 方法重新执行一遍转换操作。</li>
<li>  如果 size 不为 0，说明 Collection c 为空，直接让 elementData 指向一个类初始化时就已经创建好的空数组对象。</li>
</ul>
</li>
</ol>
<blockquote>
<ol start="2">
<li> <strong>public ArrayList(int initialCapacity)</strong></li>
</ol>
</blockquote>
<p>这是一个带初始容量的 ArrayList 构造方法，构造具有指定初始容量的空列表。创建时需要传递数组长度 <strong>initialCapacity</strong>。</p>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705140516278.png" alt="image-20210705140516278"></p>
<ol>
<li> 若数组长度大于0，新建一个 <code>Object[initialCapacity]</code> 数组；</li>
<li> 若数组长度等于0，直接复用类加载阶段创建好的 Object 空数组；</li>
<li> 若数组长度小于0，抛出异常。</li>
</ol>
<hr>
<h2 id="3-ArrayList-的动态扩容"><a href="#3-ArrayList-的动态扩容" class="headerlink" title="3    ArrayList 的动态扩容"></a>3    ArrayList 的动态扩容</h2><blockquote>
<p>  <strong>带着问题学习：</strong></p>
</blockquote>
<ol>
<li> 通过上面的学习，我们还是不知道为什么无参构造器默认指向了一个容量为 0 的数组，而在注释中却说是一个初始容量为 10 的数组呢？</li>
<li> 通过上面的学习我们并没有看到 <code>ArrayList</code> 的动态扩容，那么为什么说 <code>ArrayList</code> 是一个动态扩容的数组呢？</li>
</ol>
<p>这些问题在 <strong>add()</strong> 方法中都能找到答案。</p>
<blockquote>
<ol>
<li> <strong>add() 方法是 List 接口声明的通用的方法，在 ArrayList 中的实现如下：</strong></li>
</ol>
</blockquote>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705112039567.png" alt="image-20210705112039567"></p>
<p>源码分析：</p>
<ol>
<li> <strong>size</strong> 是当前数组中有效元素的个数（未新增 e 元素之前）。</li>
<li> <strong>ensureCapacityInternal</strong> 方法的作用是保证数组容量不会被撑爆，该方法接收的参数是 <code>size+1</code> ；</li>
<li> 如果数组容量得到保证后，新增的元素将保存在 <code>size</code> 的位置上（因为数组元素下标从 0 开始），并返回结果为真，表示新增成功。</li>
</ol>
<p>接下来进入 <strong>ensureCapacityInternal</strong> 方法查看其具体实现：</p>
<blockquote>
<ol start="2">
<li>  <strong>ensureCapacityInternal 方法</strong></li>
</ol>
</blockquote>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705112635200.png" alt="image-20210705112635200"></p>
<p><strong>ensureCapacityInternal</strong> 继续调用 <strong>ensureExplicitCapacity</strong> 和 <strong>calculateCapacity</strong> 方法保证数组容量问题。</p>
<blockquote>
<ol start="3">
<li> <strong>calculateCapacity 方法</strong></li>
</ol>
</blockquote>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705112857905.png" alt="image-20210705112857905"></p>
<p><strong>方法参数：</strong></p>
<ul>
<li>  <strong>minCapacity</strong> 是新增元素后需要的最小数组容量<code>[minCapacity = size+1]</code>。</li>
<li>  <strong>DEFAULT_CAPACITY</strong> 是一个常量 10，表示默认数组的容量。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>  返回值是一个整形变量，表示添加新元素后数组中元素的个数。也即数组所需的最小容量。</li>
</ul>
<p><strong>原理：</strong></p>
<ol>
<li>在这个方法中，首先会判断 <code>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 是否成立。<ul>
<li>  成立的条件是 ArrayList 实例必须是使用无参构造器创建的，并且是第一次调用 <code>add()</code> 方法，<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 是一个类初始化阶段就已经创建好了的空数组对象，只有调用了 ArrayList 类的无参构造器才会让 elementData 指向这个对象。</li>
</ul>
</li>
<li> 如果结果为真，则说明 elementData 是使用无参构造器创建的，并且是第一次调用 <code>add()</code> 方法。显然，对于 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 而言， size 为 0，<code>size+1</code> 即 <code>minCapacity</code> 将会是 1，使用 <code>Math.max(DEFAULT_CAPACITY, minCapacity)</code> 取较大值后返回的是 10。直到这里无参构造器才创建了一个容量为 10 的数组。</li>
<li> 所以说“无参构造器默认创建一个容量为 10 的数组”并不严格，应该说：<strong>无参构造器默认不会在内存中创建新数组，而是指向一个在类加载阶段就已经创建好了的容量为 0  的空数组，只有在调用了 add() 方法时，才会在堆空间中创建一个新的容量为 10 的数组</strong>。【注意：add() 方法只能一个一个地添加元素，不能一次性添加多个。】</li>
<li> 得到了 <code>minCapacity</code> 数组容量这个值后，当前方法出栈继续调用上一个方法 <strong>ensureExplicitCapacity</strong>。</li>
</ol>
<blockquote>
<ol start="4">
<li>  <strong>ensureExplicitCapacity 方法</strong></li>
</ol>
</blockquote>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705114523086.png" alt="image-20210705114523086"></p>
<ol>
<li> <code>modCount++</code> 是用于在快速失败机制中判断使用的，与本文相关性不大，暂时略过。</li>
<li>接下来判断，新增元素后元素的个数是否超过了当前数组的容量，如果超过了，则证明需要扩容了。<ul>
<li>  如果是使用无参构造器创建的 <code>ArrayList</code> 对象，在这一步 <code>minCapacity == 10</code>；而 <code>elementData.length</code> 则是 0，必然满足扩容的条件。</li>
</ul>
</li>
<li> 调用 <strong>grow</strong> 方法进行扩容。</li>
</ol>
<blockquote>
<ol start="5">
<li> <strong>grow 方法</strong></li>
</ol>
</blockquote>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705114959424.png" alt="image-20210705114959424"></p>
<ol>
<li> <strong>minCapacity</strong> 是新增元素后需要的最小容量</li>
<li> <strong>oldCapacity</strong> 是原来（未新增元素前）数组的容量</li>
<li> 由于在上一个方法中已经知道原来的数组已经放不下新增的元素了，所以这里首先要进行扩容。<strong>oldCapacity &gt;&gt; 1</strong> 是位运算的右移操作，右移一位相当于除以 2，所以这句代码就等于 <code>int newCapacity = oldCapacity + oldCapacity/2</code>，即容量扩大为原来的 1.5 倍。</li>
<li>比较扩容后新数组的容量 <code>newCapacity</code> 与 新增元素后需要的最小容量 <code>minCapacity</code> ，如果扩容后仍然不够，则直接让 <code>newCapacity == minCapacity</code>，而不再是计算 1.5 倍的扩容。（即如果扩容 1.5 倍后仍然容量不够，那就直接让数组的容量等于元素的个数）<ul>
<li>  例如：使用无参构造函数的 <code>ArrayList</code> 对象第一次调用 <code>add()</code> 方法扩容，由于扩容前数组的容量为 0，即使扩容 1.5 倍也仍然是 0，所以这时候直接让新的数组长度等于 10 就行了，这种特殊情况可以无视扩容 1.5 倍的规则。</li>
<li>  如果使用有参构造函数创建了一个长度为 1 的 ArrayList 对象，即底层数组长度为 1，第一次扩容时扩大到 1.5 显然也是不合适的，所以可以直接扩容到 2。</li>
</ul>
</li>
<li>如果扩容后（第3或4步）发现新数组的容量超过了规定的最大容量 <strong>MAX_ARRAY_SIZE</strong>，则还需调用 <strong>hugeCapacity</strong>方法进行处理。（在数组长度已经很大的基础上，直接增加 0.5 倍是很大的，所以这时候我们需要额外加一些保护机制）<ul>
<li>  <strong>MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</strong>，因为数组下标是整型的数据，所以其取值范围不能超过这个范围。</li>
</ul>
</li>
</ol>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705144202128.png" alt="image-20210705144202128"></p>
<p>所有的处理结束后，调用 <strong>Arrays.copyOf</strong> 方法将原数组中的所有元素拷贝到新数组中。</p>
<blockquote>
<ol start="6">
<li> <strong>hugeCapacity 方法</strong>（非必须执行的方法）</li>
</ol>
</blockquote>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705144627777.png" alt="image-20210705144627777"></p>
<p>在数组长度已经很大的基础上，直接扩容 1.5 倍增长是很大的，所以这时候我们需要额外加一些保护机制。不再是在原数组长度的基础上增加 0.5 倍了，而是根据新增元素后需要的最小容量来改变新数组的容量（只有 2 种情况）。凡是能进入到该方法的都是大容量的数组（即扩大 1.5 就会超出上限）。</p>
<ol>
<li>如果新增元素后需要的最小容量大于 MAX_ARRAY_SIZE ，则将新数组的容量设置为 <strong>Integer.MAX_VALUE</strong>；</li>
<li>否则，将新数组的容量设置为 <strong>MAX_ARRAY_SIZE</strong>；</li>
</ol>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705145256894.png" alt="image-20210705145256894"></p>
<p>方法执行完后，当前栈帧出栈，执行上一个方法。</p>
<blockquote>
<ol start="7">
<li> <strong>Arrays.copyOf</strong></li>
</ol>
</blockquote>
<ol>
<li> 计算完扩容的容量后，继续执行真正地执行 grow 方法。调用 <strong>Arrays.copyof</strong> 方法，进行复制操作。</li>
</ol>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705145658774.png" alt="image-20210705145658774"></p>
<ol start="2">
<li> <strong>Arrays.copyof</strong> 底层真正执行的是 <strong>System.arraycopy</strong> 方法。</li>
</ol>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705145828821.png" alt="image-20210705145828821"></p>
<ol start="3">
<li> 而 <strong>System.arraycopy</strong> 方法则是一个本地方法。</li>
</ol>
<hr>
<h2 id="4-ArrayList-线程不安全"><a href="#4-ArrayList-线程不安全" class="headerlink" title="4    ArrayList 线程不安全"></a>4    ArrayList 线程不安全</h2><h3 id="ArrayList-线程不安全案例"><a href="#ArrayList-线程不安全案例" class="headerlink" title="ArrayList 线程不安全案例"></a>ArrayList 线程不安全案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">               list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">               System.out.println(list);</span><br><span class="line">           &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>根据上面几部分的学习，我们已经知道了 <code>ArrayList#add</code> 方法在写入数据之前，会先确定要写入位置的下标。如果多个线程同时向同一个 <code>list</code> 集合中写入数据，就可能存在<strong>多个线程同时取得了同一个下标的写入权</strong>，如果不加以限制，就可能会造成如下情况。即一个线程写的值覆盖了另一个线程写的值。</p>
<img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705205807031.png" alt="image-20210705205807031" style="zoom: 67%;">

<p>甚至可能会出现并发修改异常：<strong>java.util.ConcurrentModificationException</strong></p>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705211114239.png" alt="image-20210705211114239"></p>
<p>既然 <code>ArrayList#add()</code> 是线程不安全的，为了解决线程安全问题，我们应该怎么做呢？——加锁！！！</p>
<blockquote>
<p>  <strong>ArrayList 线程不安全总结：</strong></p>
</blockquote>
<p>ArrayList 在添加元素时会调用 <code>add()</code> 方法，add() 方法底层源码的逻辑是：每添加一个元素，会先确定要添加元素的下标位置，并判断是否超出当前数组的容量来决定是否需要扩容。这些过程都没有加锁，即如果多个线程并发执行时，会出现多个线程获取到同一个待插入位置的情况，这时先插入该位置的元素就会被后插入该位置的元素所覆盖。</p>
<hr>
<h3 id="解决方法1：Vector"><a href="#解决方法1：Vector" class="headerlink" title="解决方法1：Vector"></a>解决方法1：Vector</h3><p>加锁是最简单的方法，Java 的开发者们已经为我们提供好了 <strong>Vector#add()</strong> 方法用于执行线程安全的 add 方法。</p>
<blockquote>
<p>  <strong>Vector 类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<ul>
<li>  Vector 同样也实现了 <code>List&lt;E&gt;</code> 接口，继承了 <code>AbstractList&lt;E&gt;</code> 类。和 ArrayList 是同一层级的类。</li>
</ul>
<blockquote>
<p>  <strong>线程安全的代码</strong></p>
</blockquote>
<img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705211801881.png" alt="image-20210705211801881">

<ul>
<li>  只需将 <strong>new ArrayList</strong> 改为 <strong>new Vector</strong> 即可。</li>
</ul>
<blockquote>
<p>  <strong>Vector 的缺点</strong></p>
</blockquote>
<img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705212216863.png" alt="image-20210705212216863">

<ul>
<li>  查看 <strong>Vector#add</strong> 的源码，可以看到该方法被 synchronized 修饰，是线程安全的，但是这样一来就会严重影响高并环境下的程序执行速度了。</li>
<li>  我们可以看到该方法在 <code>JDK1.2</code> 之后就被声明弃用了。在早期的 JDK 时期，由于硬件设备的落后，单线程或少线程的程序是主流，加锁的 <code>add()</code> 方法能在不太影响程序执行速度的情况下加强程序的安全性，性价比还是很高的。但是在当前的硬件环境下，服务器端特别是电商项目大多都需要高并发的支持，这时再使用 <code>Vector#add</code> 方法对性能的影响就很大了。</li>
</ul>
<hr>
<h3 id="解决方法2：使用-Collections-工具类创建线程安全的-ArrayList"><a href="#解决方法2：使用-Collections-工具类创建线程安全的-ArrayList" class="headerlink" title="解决方法2：使用 Collections 工具类创建线程安全的 ArrayList"></a>解决方法2：使用 Collections 工具类创建线程安全的 ArrayList</h3><ul>
<li>  使用 <strong>Collections.synchronizedList</strong> 方法创建线程安全的 ArrayList。</li>
</ul>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705213152762.png" alt="image-20210705213152762"></p>
<ul>
<li>  下图可以看到，Collections 工具类提供了用于保证线程安全的 List 、Set 、Map 方法，那么也就说明 List、Set、Map 中一定有一些实现类是线程不安全的。具体就是：<strong>ArrayList、HashSet、HashMap</strong></li>
</ul>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705213534400.png" alt="image-20210705213534400"></p>
<h3 id="解决方法3：CopyOnWriteArrayList"><a href="#解决方法3：CopyOnWriteArrayList" class="headerlink" title="解决方法3：CopyOnWriteArrayList"></a>解决方法3：CopyOnWriteArrayList</h3><blockquote>
<p>  <strong>CopyOnWriteArrayList 类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable </span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>CopyOnWriteArrayList</strong> 是 JUC 包下的一个线程安全的 <code>ArrayList</code> 的变体。</li>
<li>  它实现了 <code>List&lt;E&gt;</code> 接口，在某种意义上，它和 ArrayList 、Vector 是平级的。</li>
<li>  它能保证线程安全是因为采用了<strong>写时复制技术</strong></li>
</ul>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705215106596.png" alt="image-20210705215106596"></p>
<blockquote>
<p>  <strong>线程安全的代码</strong></p>
</blockquote>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705214658694.png" alt="image-20210705214658694"></p>
<blockquote>
<p>  <strong>写时复制技术</strong></p>
</blockquote>
<ul>
<li>  顾名思义，“写时复制”就是写的时候才复制，也就是说“读的时候不复制”。</li>
<li>  我们都知道，多个线程读同一份资源不会有线程安全的问题，只有多个线程对同一份资源进行写操作的时候才可能出现线程安全问题。</li>
<li>  一般的加锁机制（重锁）不会区分读还是写，只要是某一资源被上锁了，不管是读还是写都需要进行资源的争夺。</li>
<li>  而如果某份资源在大多数情况下都是多线程读，只有少数情况下才会进行多线程写的话，使用不区分读写的锁显然对性能的浪费很大。而如果将读和写的操作分开，在某些情况下反而能得到更好的性能。写时复制技术就是这样一种技术。</li>
<li>  写时复制技术用到了<strong>读写分离的思想</strong>。</li>
<li>  读的时候共享，写的时候复制一份数据的副本对副本进行操作，写好以后，用副本覆盖原件。</li>
</ul>
<p>放在本例中就是，线程 A、B、C 同时执行 <code>list.add()</code> 操作，向集合中添加元素。</p>
<ol>
<li> 如果线程 A、B、C 同时要读 <code>list</code> 中的数据，可以任意读，无锁。</li>
<li> 如果线程 B 要修改 <code>list</code> 中的数据，如调用 <code>add()</code> 方法添加元素。不好意思，不能直接在原 <code>list</code> 集合中添加，线程 B 需要将原来的 <code>list</code> 集合的内容复制一份，将要添加的数据加入到 <code>list</code> 副本中。如果添加成功了，再将指向原 <code>list</code> 的指针指向新的 <code>list</code>，这就完成了一次集合中元素的添加。</li>
</ol>
<blockquote>
<p>  <strong>源码解读（部分）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的底层结构：Object[] </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] elements;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">            elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            elements = c.toArray();</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">                elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">        setArray(elements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> &#123;</span><br><span class="line">        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>add() 方法源码</strong></p>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705221837637.png" alt="image-20210705221837637"></p>
<ol>
<li> 首先加锁</li>
<li> 调用自身类中的 <code>getArray()</code> 方法获得当前集合对象的底层数组对象；</li>
<li> 将原数组复制一份并将长度增加 1，</li>
<li> 在新的索引位置上保存新增的元素；</li>
<li> 让对象的 <code>array</code> 属性指向新的数组对象（即原数组对象被废弃）；</li>
<li> 释放锁。</li>
</ol>
<hr>
<h1 id="HashSet-线程不安全"><a href="#HashSet-线程不安全" class="headerlink" title="HashSet 线程不安全"></a>HashSet 线程不安全</h1><p><strong>带着问题学习</strong></p>
<ol>
<li> HashSet 底层的数据结构是什么？</li>
<li> HashMap 是键值对的结构，而 <code>HashSet#add</code> 方法只用传递一个参数进去，为什么？</li>
</ol>
<p><strong>答案：</strong></p>
<ol>
<li> HashSet 底层的数据结构是 HashMap。</li>
<li> HashSet 底层确实调用了 <code>HashMap#put(K, V)</code> 方法，但是我们在调用 <code>HashSet#add</code> 方法时只需添加一个参数即可。这时因为 Java 开发人员在源码级别帮我们做了自动填充。HashSet 只是利用了 HashMap 键（Key）的不可重复性，至于值（Value）则是用一个常量填充。也就是说，我们每次调用  <code>HashSet#add(xxx)</code> 时，实际上调用的是 <code>HashMap#put(xxx, 常量)</code> 。至于这个常量是什么，在下文的源码分析中可以看到，其实只是一个类加载阶段就创建好的对象的地址。</li>
</ol>
<h2 id="1-HashSet-底层数据结构"><a href="#1-HashSet-底层数据结构" class="headerlink" title="1    HashSet 底层数据结构"></a>1    HashSet 底层数据结构</h2><blockquote>
<p>  <strong>源码分析</strong></p>
</blockquote>
<ol>
<li> 通过源码可以看到，HashSet 的底层数据结构其实是一个 HashMap。而 HashMap 的数据结构是键值对的，那么 HashSet 是如何处理这一情况的呢？</li>
</ol>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705225253807.png" alt="image-20210705225253807"></p>
<ol start="2">
<li> 在 <strong>HashSet#add</strong> 方法中可以看到，add 方法底层确实调用的是 <strong>HashMap#put</strong> 方法，其 Key 为要添加的元素，而 V 则是一个 <strong>PRESENT</strong> 值</li>
</ol>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705225457854.png" alt="image-20210705225457854"></p>
<ol start="3">
<li> 继续查看 PRESENT 的源码，我们可以看到， <strong>PRESENT</strong> 是一个常量值，也就是说 Value 是固定不变的。</li>
</ol>
<p><img src="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/image-20210705225617057.png" alt="image-20210705225617057"></p>
<ol start="4">
<li> 总结：HashSet 底层是 HashMap，但是只是利用了 HashMap 中键（key）的不可重复性，而在值（value）的部分则是使用一个常量值来填充。</li>
</ol>
<hr>
<h2 id="2-代码验证-HashSet-线程不安全"><a href="#2-代码验证-HashSet-线程不安全" class="headerlink" title="2    代码验证 HashSet 线程不安全"></a>2    代码验证 HashSet 线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">            System.out.println(set);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  这段代码也会出现 <strong>java.util.ConcurrentModificationException</strong> 异常，这就证明了 HashSet 也是线程不安全的。</li>
</ul>
<hr>
<h2 id="3-如何解决-HashSet-线程不安全（2种方法）"><a href="#3-如何解决-HashSet-线程不安全（2种方法）" class="headerlink" title="3    如何解决 HashSet 线程不安全（2种方法）"></a>3    如何解决 HashSet 线程不安全（2种方法）</h2><ol>
<li> <strong>Collections 工具类：Collections.synchronizedSet(new HashSet&lt;&gt;())</strong></li>
<li> <strong>写时复制技术：new CopyOnWriteArraySet&lt;&gt;()</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = new HashSet&lt;&gt;();    // 线程不安全</span></span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());     // 线程安全①</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();     <span class="comment">// 线程安全②</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="HashMap-线程不安全"><a href="#HashMap-线程不安全" class="headerlink" title="HashMap 线程不安全"></a>HashMap 线程不安全</h1><h2 id="1-代码验证-HashMap-不安全"><a href="#1-代码验证-HashMap-不安全" class="headerlink" title="1    代码验证 HashMap 不安全"></a>1    代码验证 HashMap 不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">// 线程不安全</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  错误信息：<strong>java.util.ConcurrentModificationException</strong></li>
</ul>
<h2 id="2-如何解决-HashMap-线程不安全"><a href="#2-如何解决-HashMap-线程不安全" class="headerlink" title="2    如何解决 HashMap 线程不安全"></a>2    如何解决 HashMap 线程不安全</h2><ol>
<li> <strong>Collections 工具类：Collections.synchronizedMap(new HashMap&lt;&gt;())</strong></li>
<li> <strong>JUC包下的HashMap：new ConcurrentHashMap&lt;&gt;()</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();    // 线程不安全</span></span><br><span class="line"><span class="comment">//        Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());     // 线程安全①</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();     <span class="comment">// 线程安全②</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-ConcurrentHashMap源码分析"><a href="#3-ConcurrentHashMap源码分析" class="headerlink" title="3    ConcurrentHashMap源码分析"></a>3    ConcurrentHashMap源码分析</h2><blockquote>
<p>  <strong>ConcurrentHashMap 类</strong></p>
</blockquote>
<ul>
<li>  ConcurrentHashMap 是 JUC 包下的一个 HashMap 的变式，与 HashMap 的功能基本一致，但是它是线程安全的。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable </span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>ConcurrentHashMap#put 方法源码</strong></p>
</blockquote>
<ol>
<li> <code>ConcurrentHashMap#put</code> 会调用 <code>ConcurrentHashMap#putVal</code> 方法</li>
<li> 在 <code>ConcurrentHashMap#putVal</code> 方法中的一部分代码块被加了锁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ConcurrentHashMap#put 方法 */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ConcurrentHashMap#putVal 方法 */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 1.根据 key 计算出 hash 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/03/JUC/" rel="prev" title="JUC">
                  <i class="fa fa-chevron-left"></i> JUC
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/08/JMM/" rel="next" title="JMM">
                  JMM <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
