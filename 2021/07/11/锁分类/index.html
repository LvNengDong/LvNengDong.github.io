<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="乐观锁 &amp; 悲观锁   公平锁 &amp; 非公平锁   独占锁 &amp;  共享锁   可重入锁   自旋锁   锁升级（无锁 | 偏向锁 | 轻量级锁 | 重量级锁）   锁优化技术（锁粗化、锁消除 ）   任何时候都要明确一点：加锁的主体是代码（共享数据），线程只是获取锁。最直观的解释就是我们将锁对象写在了代码中，而不是与线程绑定的。 乐观锁 &amp; 悲观锁乐观锁​">
<meta property="og:type" content="article">
<meta property="og:title" content="锁分类">
<meta property="og:url" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="乐观锁 &amp; 悲观锁   公平锁 &amp; 非公平锁   独占锁 &amp;  共享锁   可重入锁   自旋锁   锁升级（无锁 | 偏向锁 | 轻量级锁 | 重量级锁）   锁优化技术（锁粗化、锁消除 ）   任何时候都要明确一点：加锁的主体是代码（共享数据），线程只是获取锁。最直观的解释就是我们将锁对象写在了代码中，而不是与线程绑定的。 乐观锁 &amp; 悲观锁乐观锁​">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E4%B9%90%E8%A7%82%E9%94%81">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E6%82%B2%E8%A7%82%E9%94%81">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210711100056238.png">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210711100130951.png">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210711100200695.png">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210716151834421.png">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210716153220615.png">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E8%87%AA%E6%97%8B%E9%94%81">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E7%8B%AC%E5%8D%A0%E9%94%81">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E5%85%B1%E4%BA%AB%E9%94%81">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210712144602003.png">
<meta property="og:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210712150150198.png">
<meta property="article:published_time" content="2021-07-11T01:41:30.000Z">
<meta property="article:modified_time" content="2021-09-14T03:20:29.055Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E4%B9%90%E8%A7%82%E9%94%81">


<link rel="canonical" href="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/","path":"2021/07/11/锁分类/","title":"锁分类"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>锁分类 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-amp-%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">1.</span> <span class="nav-text">乐观锁 &amp; 悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">1.1.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">1.2.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.3.1.</span> <span class="nav-text">两种锁的使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-amp-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">公平锁 &amp; 非公平锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.</span> <span class="nav-text">二者区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA"><span class="nav-number">2.3.</span> <span class="nav-text">怎么创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">2.3.1.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">2.3.2.</span> <span class="nav-text">synchronized</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E9%80%92%E5%BD%92%E9%94%81%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">可重入锁（递归锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="nav-number">3.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.2.</span> <span class="nav-text">有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized"><span class="nav-number">3.2.1.</span> <span class="nav-text">Synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E6%AC%A1%E6%95%B0%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E6%AC%A1%E6%95%B0%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84Case"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">加锁次数和释放锁次数不一致的Case</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88AQS%EF%BC%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">Synchronized 的可重入实现原理（AQS）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">3.4.</span> <span class="nav-text">避免死锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="nav-number">4.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">4.2.</span> <span class="nav-text">手写一个自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.2.1.</span> <span class="nav-text">代码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81-amp-%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">独占锁 &amp; 共享锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="nav-number">5.1.</span> <span class="nav-text">独占锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">5.2.</span> <span class="nav-text">共享锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReenterReadWriteLock"><span class="nav-number">5.3.</span> <span class="nav-text">ReenterReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E5%89%8D"><span class="nav-number">5.3.1.</span> <span class="nav-text">加锁前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E5%90%8E"><span class="nav-number">5.3.2.</span> <span class="nav-text">加锁后</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized-%E9%94%81%E7%9A%84%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5"><span class="nav-number">6.</span> <span class="nav-text">synchronized 锁的降级策略</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="锁分类 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          锁分类
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-11 09:41:30" itemprop="dateCreated datePublished" datetime="2021-07-11T09:41:30+08:00">2021-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-14 11:20:29" itemprop="dateModified" datetime="2021-09-14T11:20:29+08:00">2021-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<ul>
<li>  乐观锁 &amp; 悲观锁</li>
<li>  公平锁 &amp; 非公平锁</li>
<li>  独占锁 &amp;  共享锁</li>
<li>  可重入锁</li>
<li>  自旋锁</li>
<li>  锁升级（无锁 | 偏向锁 | 轻量级锁 | 重量级锁）</li>
<li>  锁优化技术（锁粗化、锁消除 ）</li>
</ul>
</blockquote>
<p><strong>任何时候都要明确一点：加锁的主体是代码（共享数据），线程只是获取锁。</strong>最直观的解释就是我们将锁对象写在了代码中，而不是与线程绑定的。</p>
<h1 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁 &amp; 悲观锁"></a>乐观锁 &amp; 悲观锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>​        <strong>乐观锁</strong> 对应于生活中乐观的人，乐观的人总是想着事情往好的方向发展。</p>
<p>​        在并发情况下，对于一个线程来说，最好的情况就是在自己操作共享数据期间没有其它线程去更新这个数据。而对于乐观锁来说，它就很乐观的认为确实会发生这种情况。所以乐观锁操作数据时不会上锁，只是在更新的时候会判断一下在此期间是否有其他线程去更新这个数据。</p>
<p>​        乐观锁可以使用 <strong>版本号机制</strong> 和 <strong>CAS算法</strong> 实现。在 Java 中 <code>java.util.concurrent.atomic</code> 包下的原子类就是使用CAS 乐观锁实现的。</p>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E4%B9%90%E8%A7%82%E9%94%81" alt="图片"></p>
<hr>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>​        与乐观锁相反，<strong>悲观锁</strong> 考虑的则是最坏的情况。</p>
<p>​        一个共享数据加了悲观锁，那么线程每次想操作这个数据前都会假设其他线程也可能会操作这个数据，所以每次操作前都会上锁，这样其他线程想操作这个数据拿不到锁只能阻塞了。</p>
<p>​        在 Java 中，<code>synchronized</code> 和 <code>ReentrantLock</code> 等就是典型的悲观锁，还有一些使用了 synchronized 关键字的容器类如 <code>HashTable</code> 等也是悲观锁的应用。</p>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E6%82%B2%E8%A7%82%E9%94%81" alt="图片"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li> <strong>乐观锁 = 不真正加锁 + CAS</strong></li>
<li> 悲观锁：加独占锁，加锁后其它线程的<strong>读写</strong>操作都会被阻塞</li>
</ol>
<h3 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h3><ol>
<li> 乐观锁适用于写比较少（冲突比较小）的场景，因为不用上锁、释放锁，省去了锁的开销，从而提升了吞吐量。</li>
<li> 如果是写多读少的场景，即冲突比较严重，线程间竞争激烈，使用乐观锁就是导致线程不断进行重试，这样可能还降低了性能，这种场景下使用悲观锁就比较合适。</li>
</ol>
<hr>
<h1 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>  <strong>公平锁</strong>：</p>
</blockquote>
<p>指多个线程按照申请锁的顺序来获取锁，即谁先申请锁谁就优先获得锁。类似于生活中的排队，先到先得。</p>
<blockquote>
<p>  <strong>非公平锁</strong>：</p>
</blockquote>
<p>只多个线程获得锁的顺序并不是按照申请锁的顺序，有可能后申请锁的线程比先申请锁的线程优先获得锁。在高并发情况下，有可能造成<strong>优先级反转</strong>或者<strong>饥饿现象</strong>。</p>
<ul>
<li><p>  <strong>优先级反转现象</strong>：就是后申请锁的线程比先申请锁的线程优先获得锁的现象，后申请锁的线程本该是一个低优先级的线程，但是出现了优先级反转，它就提前获得了锁对象。（类似于插队）</p>
</li>
<li><p>  <strong>饥饿现象</strong>：饥饿现象是指如果一直存在插队的线程获得锁，就会导致本该获得锁的线程一直处于等待状态，这就叫做饥饿状态。</p>
</li>
</ul>
<hr>
<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><ul>
<li>  <strong>公平锁</strong></li>
</ul>
<p>在并发环境中，每个线程在争夺公平锁时会<strong>先</strong>查看此锁对象维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，<strong>才</strong>占有锁，否则就会加入到等待队列中，按照先进先出的规则等到自己获取锁。</p>
<ul>
<li>  <strong>非公平锁</strong></li>
</ul>
<p>如果锁对象是一个非公平锁，在并发环境中，每当有新线程进入争夺锁对象时，这个<strong>线程会直接去尝试占有锁</strong>，如果尝试失败，才会再采用类似公平锁的方式，让线程去锁对象维护的等待队列中排队。</p>
<blockquote>
<p>  在这种情况下，存在这样一种情况：线程 A 是当前持有锁的对象，线程 A 释放锁之后，按照优先级顺序本该线程 B 得到这个锁对象，但是此时有一个新线程 Z 进来了，这个 Z 不管三七二十一首先就去尝试占有锁了，如果这时候刚好处于 A 释放完锁而 B 有没有获取到锁的时间段，那么 Z 就会直接占有锁，而 B 获取不到锁后，只能继续在等待队列中排队了。这就是 B 线程被插队了。</p>
</blockquote>
<hr>
<h2 id="怎么创建"><a href="#怎么创建" class="headerlink" title="怎么创建"></a>怎么创建</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>​    JUC<code>(java.util.concurrent.locks)</code> 包中的 ReentrantLock 类提供了两个构造函数，用于创建一个公平锁对象或非公平锁对象。</p>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210711100056238.png" alt="image-20210711100056238"></p>
<blockquote>
<p>  <strong>无参构造器源码</strong></p>
</blockquote>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210711100130951.png" alt="image-20210711100130951"></p>
<blockquote>
<p>  <strong>带参构造器源码</strong>（创建时传入一个 boolean 类型的值）</p>
</blockquote>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210711100200695.png" alt="image-20210711100200695"></p>
<ul>
<li>  使用无参构造函数创建的 ReentrantLock 创建的锁对象是一个非公平锁，等价于 <code>new ReentrantLock(false)</code></li>
<li>  使用带参构造函数创建 ReentrantLock 对象时，构造函数传入 true 则会创建一个公平锁，传入 false 则创建一个非公平锁。</li>
</ul>
<hr>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>对于 synchronized 而言，本身就是一种<strong>非公平锁</strong>。</p>
<hr>
<h1 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h1><blockquote>
<p>  <strong>可重入锁；递归锁</strong></p>
</blockquote>
<h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>可重入锁指的是同一线程的外层方法获得锁之后，如果内层的递归方法仍然需要获得该锁，则可以直接使用，不会因为外层方法的锁对象还没释放而阻塞。（前提是锁对象得是同一个对象）</p>
<blockquote>
<p>  <strong>两（多）个需要锁的递归的同步方法，只使用了一把锁，这把锁在进入了最外层方法后，还可以继续在内存的同步方法中使用，即一锁多用</strong></p>
</blockquote>
<p><strong>可重入锁就是说某个线程获得某把锁的使用权，在没有归还锁的之前，这把锁可以一直使用！！！</strong></p>
<p>可重入锁的一个优点是可以一定程度避免死锁。</p>
<p><em>死锁则是一个外层同步方法需要 A 锁才能进入，进入之后内层方法则需要 B 锁才能进入，使用的不是同一把锁。</em></p>
<p><strong>举例说明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReenterLockTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">    	methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  在上面的类中有两个同步方法，methodA 和 methodB ，这两个方法都是同步方法使用同一个锁对象 this。</p>
</li>
<li><p>现有线程 T1 持有 this 锁对象，执行同步方法 methodA ，在 methodA 中调用了同步方法 methodB ，由于 methodA 和 methodB 用的是同一个锁对象，且 methodB 是在 methodA 中递归调用的，T1 线程可以接着使用还没有释放的 this 锁对象去调用 methodB，也就是说此时同步方法 methodB 要求的锁对线程 T1 来说是透明的。</p>
</li>
</ul>
<h2 id="有哪些"><a href="#有哪些" class="headerlink" title="有哪些"></a>有哪些</h2><blockquote>
<ul>
<li><p>隐式锁：synchronized</p>
<ul>
<li>  同步代码块</li>
<li>  同步方法</li>
</ul>
</li>
<li><p>  显式锁：ReentrantLock</p>
</li>
</ul>
</blockquote>
<p>ReentrantLock 和 Synchronized 都是典型的可重入锁。</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><strong>同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>同步方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==========短信发送成功&quot;</span>);</span><br><span class="line">        sendEmail();	<span class="comment">// sendEmail 也是一个同步方法，需要获得锁才能执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==========邮件发送成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReenterLockTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">            T1==========短信发送成功</span></span><br><span class="line"><span class="comment">            T1==========邮件发送成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  同一把锁在多个同步方法中使用。</li>
</ul>
<hr>
<h3 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><strong>常规案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==========短信发送成功&quot;</span>);</span><br><span class="line">            sendEmail();    <span class="comment">// 在一个同步方法中调用另一个同步方法（这两个同步方法用的是同一把锁）</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==========邮件发送成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReenterLockTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">            T1==========短信发送成功</span></span><br><span class="line"><span class="comment">            T1==========邮件发送成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="加锁次数和释放锁次数不一致的Case"><a href="#加锁次数和释放锁次数不一致的Case" class="headerlink" title="加锁次数和释放锁次数不一致的Case"></a>加锁次数和释放锁次数不一致的Case</h4><ul>
<li>  正常情况下，加几次锁就要释放几次锁</li>
<li>  如果加锁次数和释放锁的次数不一样的话，第 2 个线程将始终无法获取到锁，导致一直在等待。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/16 15:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可重入锁，模拟加锁2次，但是只释放一次锁 会导致的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();    <span class="comment">// 第1次加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;****外层锁&quot;</span>);</span><br><span class="line">            methodB();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//            lock.unlock();    // 第2次释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();    <span class="comment">// 第2次加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;****内层锁&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// 第1次释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            myData.methodA();</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new Thread(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;\nT2线程获取到CPU资源====&quot;);</span></span><br><span class="line"><span class="comment">//             myData.methodA();</span></span><br><span class="line"><span class="comment">//        &#125;, &quot;T2&quot;).start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码分析</strong></p>
<p>在只有一个线程 T1 执行 <code>myData.methodA()</code> 方法时，即使加了 2 次锁，也看不出来任何异常，程序正常运行，正常结束。符合可重入锁的一切特征。输出结果如下图所示。</p>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210716151834421.png" alt="image-20210716151834421"></p>
<p>但其实这样是有隐患的，调用 lock 和 unlock 加锁和释放锁的底层原理是通过 AQS 和 CAS 实现的。即每个锁对象都会维护一个 state 变量标识当前有多少个线程正在使用该锁对象，初始 <code>state==0</code>，表示无任何线程得到该锁对象。在本例中，由于加锁 2 次，释放锁 1 次，所以线程 T1 执行完后锁对象 lock 维护的 state 值是 1 而不是 0。</p>
<p>如果这时候有另一个线程想要去获得此锁对象的话（就是把上面 T2 线程相关代码的注释打开），在争夺锁对象之前要先经过 CAS 的比较，由于 <code>state == 1</code>，也就是说明该锁对象还被一个线程正在持有（实际上这个线程就是 T1，因为 T1 缺少一次释放锁的过程），所以 T2 获取锁对象的操作失败，如果 T1 一直不释放的话，T2 就会一直阻塞，无法继续进行下去。执行结果如下图所示：</p>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210716153220615.png" alt="image-20210716153220615"></p>
<p>T2 线程可以获取到 CPU 资源，但由于一直不能获取到锁对象所以会一直等待，导致进程不能结束。</p>
<hr>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="Synchronized-的可重入实现原理（AQS）"><a href="#Synchronized-的可重入实现原理（AQS）" class="headerlink" title="Synchronized 的可重入实现原理（AQS）"></a>Synchronized 的可重入实现原理（AQS）</h3><p>每个锁对象都拥有一个锁计数器和一个指向该使用锁的线程的指针。</p>
<ol>
<li>当一个线程争夺锁对象时，JVM 底层会执行一条 monitorenter 指令，这时<ul>
<li>  如果目标锁对象的计数器为 0，就说明该锁对象没有被其它线程所持有，Java 虚拟机会将该锁对象的持有线程设置为当前线程，并且将计数器 +1。</li>
<li>  在目标锁对象的计数器不为 0 的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机会将其计数器 +1，否则需要等待，直至持有线程释放该锁。</li>
</ul>
</li>
<li> 当执行到 monitorexit 指令时，Java 虚拟机会将锁对象的计数器 -1。若计数器为 0 则代表锁已经被释放。</li>
</ol>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>可重入锁最大的作用就是避免死锁</p>
<hr>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><blockquote>
<p>  <strong>自旋锁；SpinLock</strong></p>
</blockquote>
<h2 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>  <strong>概念</strong></p>
</blockquote>
<p><strong>自旋锁</strong> 是指尝试获取锁的线程在没有获得锁时不会被直接挂起，而是采用循环的方式去不断地尝试获取锁，这个循环就是所谓的自旋。【CAS 思想】</p>
<p><strong>Tip：</strong>处于自旋中的线程并不会一直等待获取锁后才结束循环。如果持有锁的线程对锁的占用时间过长，自旋锁在自旋一段时间后仍然无法获取到锁，还是会进入阻塞状态，这时候锁也就不再是自旋锁了。</p>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E8%87%AA%E6%97%8B%E9%94%81" alt="图片"></p>
<ul>
<li>  自旋锁的目的是为了减少线程被挂起的几率，因为线程的挂起和唤醒也都是耗资源的操作。【好处：减少上下文切换的消耗】</li>
<li>  但是如果锁被另一个线程占用的时间比较长，即使自旋了之后当前线程还是会被挂起，忙循环就会变成浪费系统资源的操作，因为循环会消耗 CPU，反而降低了整体性能。因此自旋锁是不适应锁占用时间长的并发情况的。【缺点：自旋时间过长时浪费 CPU 资源较多，反而会拖慢程序的整体性能】</li>
</ul>
<blockquote>
<p>  <strong>案例</strong></p>
</blockquote>
<p>​        有两个线程A、B在竞争一个锁，假设 A 拿到了锁对象，这个时候 B 就会被挂起阻塞，一直等到 A 释放了锁 B 才得到使用权。在操作系统中阻塞和唤醒其实也是一个耗时操作，如果线程 A 在很短的时间内就使用完并释放了锁，当这个时间比 <code>阻塞B线程 + 唤醒B 线程</code> 的总耗时更短的时候，我们将线程 B 挂起，其实并不是一个最优的选择。</p>
<blockquote>
<p>  <strong>扩展：自适应自旋锁</strong></p>
</blockquote>
<p>​        在 JDK1.6 引入了自适应自旋，这个就比较智能了，自旋时间不再固定，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果虚拟机认为这次自旋也很有可能再次成功那就会次序较多的时间，如果自旋很少成功，那以后可能就直接省略掉自旋过程，避免浪费处理器资源。</p>
<h2 id="手写一个自旋锁"><a href="#手写一个自旋锁" class="headerlink" title="手写一个自旋锁"></a>手写一个自旋锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/12 10:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：手写一个自旋锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过 CAS 操作完成自旋锁，T1 线程先调用同步方法A持有锁5s，</span></span><br><span class="line"><span class="comment"> * T2线程随后进来发现当前锁对象已经被（T1）占用，所以只能通过自旋等待，</span></span><br><span class="line"><span class="comment"> * 直到T1释放锁后T2随后抢到</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当线程 T1 持有锁的时候，T2 进入后不会阻塞，而是不停地循环去视图获取锁</span></span><br><span class="line"><span class="comment">*   1、T2 进入时如何判断 T1 已经持有锁了？ 线程间的可见性——volatile</span></span><br><span class="line"><span class="comment">*   2、不停循环——CAS思想</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       每个线程进入都会查看锁对象是否为空，为空则证明当前锁未被使用，可以交换，退出循环</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MySpinLock</span> <span class="variable">mySpinLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySpinLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// T1 线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            mySpinLock.myLock();</span><br><span class="line">            <span class="comment">// T1 线程持有锁 5s</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">5000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            mySpinLock.myUnLock();</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mian 线程睡眠 1s</span></span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// T2 线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            mySpinLock.myLock();</span><br><span class="line">            <span class="comment">// T2 线程持有锁 1s</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            mySpinLock.myUnLock();</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySpinLock</span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 真正的自旋锁对象是被 AtomicReference 包装的 Object 对象，在 atomicReference 中用 value 表示</span></span><br><span class="line">    AtomicReference&lt;Object&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	作用：根据锁对象的状态，选择让当前线程继续执行还是陷入循环</span></span><br><span class="line"><span class="comment">    		1、如果锁对象未被使用，线程跳过死循环，并修改锁状态</span></span><br><span class="line"><span class="comment">    		2、如果锁对象在使用中，当前线程就进入自旋（即执行死循环）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(currentThread.getName() + <span class="string">&quot;线程 ========== 进入&quot;</span>);</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        	根据 CAS 思想，设置主内存中对  atomicReference.value  的期望值为 null，</span></span><br><span class="line"><span class="comment">        	满足期望值后要将 atomicReference.value 的值更新为 currentThread。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, currentThread))&#123;</span><br><span class="line">            <span class="comment">// 死循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myUnLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(currentThread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(currentThread.getName() + <span class="string">&quot;线程 ========== 执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><blockquote>
<p>  <strong>测试类</strong></p>
</blockquote>
<ol>
<li> 在多线程环境下，T1 线程先获取到锁对象，持有锁对象 5s 执行任务，5s 后释放锁对象。</li>
<li> T2 线程在第 2s 进入，尝试获取锁对象未果，但 T2 并不会阻塞，而是不断的自旋（就是不断地尝试获取锁对象）；</li>
<li> 直到 T1 执行完任务释放锁对象后，T2 随后抢到锁对象，执行任务，最后释放锁对象。</li>
</ol>
<blockquote>
<p>  <strong>自旋锁类分析</strong></p>
</blockquote>
<p>首先要明确一点，自旋锁在自旋期间并不会挂起任何一个线程。即不像 synchronized 一样同一时间只有一个线程是活跃的。</p>
<p>​        每个线程执行 <code>myLock()</code> 方法时首先都会尝试获取锁。假设 T1 先执行 <code>myLock()</code>，T1 会先查看锁对象是否被占用。同理，T2 线程执行 <code>myLock()</code> 时也会查看锁对象是否被占用。</p>
<p>​        如果 T2 查看锁状态时发现锁对象正在被使用，由于自旋锁的特性，T2 不会直接挂起，而是会一直自旋，所以线程的本地内存也就不会被释放。</p>
<p>​        一段时间后 T1 释放了锁对象后（释放锁对象会修改锁状态的值），T2 要第一时间能得到锁的最新状态。所以<strong>自旋锁对象要使用 volatile 关键字修饰</strong>，保证多个线程间的可见性。</p>
<blockquote>
<p>  <strong>myLock() 方法</strong></p>
</blockquote>
<p><strong>myLock()</strong> 方法的作用是根据锁对象的状态，选择让当前线程继续执行还是陷入循环。判断的依据是：</p>
<ol>
<li> 如果锁对象 <strong>atomicReference</strong> 是第一次被使用，由于锁对象是使用无参构造函数 <strong>new AtomicReference()</strong> 创建的，所以主内存中的值 <strong>atomicReference.value = null</strong> 恒成立，代表此时没有其它线程正在使用该锁对象，当前线程可以获取到锁【其实就是不进入忙循环】。</li>
<li> 在线程 T1 使用锁的 5s 内，线程 T2 也进来了，通过 <code>myLock</code> 方法尝试获取锁对象，由于此时主内存中 value 值已经不为空了（变成了 T1 线程的 currentThread），所以 compareAndSet 方法返回值为 false，取反为 true，线程 T2 进入循环体，不停地做 CAS 判断。</li>
<li> 当线程 T1 执行结束后，会调用 <strong>myUnLock()</strong> 方法，由于 T1 执行过程中 T2 始终没有更新主内存中的 value 成功，所以此时主内存中的 value 还是与 T1 本地内存中的 currentThread 快照的值相同，T1 可以成功将主内存中的 value 修改为 null。</li>
<li> 由于 value 使用 volatile 修饰，所以当线程 T1 更新 value 后，线程 T2 能马上监听到，这段时间内 T2 一直在执行 myLock 方法，监听到 value 变为 null 后，终于 compareAndSet 方法可以退出循环了，这时候它会把 T2 线程的当前线程对象写回主内存中的 value 位置上，重新由 T2 来占用这把锁。</li>
<li> 在 T2 持有锁的时间段内，如果有其它线程进入也只能不断进行自旋直到 T2 执行完毕，修改主内存中的 value 为 null 后才能继续得到锁。</li>
</ol>
<hr>
<h1 id="独占锁-amp-共享锁"><a href="#独占锁-amp-共享锁" class="headerlink" title="独占锁 &amp; 共享锁"></a>独占锁 &amp; 共享锁</h1><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p><strong>独占锁 是指锁一次只能被一个线程所持有</strong>。</p>
<p>如果一个线程对数据加上排他锁后，那么其他线程不能再对该数据加任何类型的锁。获得独占锁的线程即能读数据又能修改数据。</p>
<p>JDK中的<code>synchronized</code> 和 <code>ReentrantLock</code> 就是独占锁。</p>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E7%8B%AC%E5%8D%A0%E9%94%81" alt="图片"></p>
<hr>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p><strong>共享锁 是指锁可被多个线程所持有</strong>。【共享数据被共享锁锁住，共享锁可被多个线程获取，获取到锁的线程都可以访问共享数据】</p>
<p>如果一个线程对数据加上共享锁后，那么其他线程只能对数据再加共享锁，不能加独占锁。</p>
<p><strong>获得共享锁的线程只能读数据，不能修改数据</strong>。</p>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/%E5%85%B1%E4%BA%AB%E9%94%81" alt="图片"></p>
<ul>
<li>  对 ReenterReadWriteLock 来说，其读锁是共享锁，写锁是独占锁</li>
</ul>
<hr>
<h2 id="ReenterReadWriteLock"><a href="#ReenterReadWriteLock" class="headerlink" title="ReenterReadWriteLock"></a>ReenterReadWriteLock</h2><p>对 ReenterReadWriteLock 来说，其读锁是共享锁，写锁是独占锁</p>
<ul>
<li>  写锁 ==&gt; 独占锁</li>
<li>  读锁 ==&gt; 共享锁</li>
</ul>
<p>读锁（共享锁）可以保证并发读是非常高效的，</p>
<p>读写、写读、写写的过程是互斥的。</p>
<h3 id="加锁前"><a href="#加锁前" class="headerlink" title="加锁前"></a>加锁前</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key, Object value)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;写线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;    正在写入：&quot;</span> + key);</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(<span class="string">&quot;写线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;    写入完成============&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;正在读取============&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        System.out.println(<span class="string">&quot;读线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;读取完成，结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5个线程同时写入，5个线程同时读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.write(String.valueOf(temp), temp);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.read(String.valueOf(temp));</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>资源类</strong></p>
<p>MyCache类。提供了 write 和 read 两个方法。</p>
<p><strong>测试类</strong></p>
<p>创建了 5 个线程向 myCache 对象写数据，5 个线程从  myCache 对象中读数据。</p>
<p><strong>执行结果分析</strong></p>
<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210712144602003.png" alt="image-20210712144602003"></p>
<p>​        从上图中我们看到，写线程 3 首先执行写操作，但是写操作并没有执行完 CPU 资源就被写线程 5 抢占了，并且 5 个写线程还没有</p>
<p>执行完写操作，就被读线程抢先读了。所以程序运行的结果是混乱的。</p>
<p>​        <strong>要想完成线程安全的写操作，必须满足两个条件：原子性 + 独占式锁</strong>。</p>
<p>​        【原子性：某个写线程在操作结束之前不能被其它线程中断】</p>
<h3 id="加锁后"><a href="#加锁后" class="headerlink" title="加锁后"></a>加锁后</h3><p>​        如果使用一个独占锁统一管理写操作和读操作，确实可以保证线程安全，但是会大大降低代码的并发性。对于读操作，多线程操作是安全的，可以加共享锁；对于写操作，多线程操作是不安全的，需要加独占式锁。对于一个对象的不同方法（读和写方法）加不同类型的锁，可以通过 <strong>ReentrantReadWriteLock</strong> 实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/12 13:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  多个线程同时读一个资源类不会引发线程安全问题，所以为了满足并发量，读取共享资源应该可以同时进行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  但是，如果有一个线程正在写（修改）共享资源，此时就不应该再有其它线程对该资源进行读或写了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  总结：</span></span><br><span class="line"><span class="comment"> *      读-读 可以共存</span></span><br><span class="line"><span class="comment"> *      读-写 不能共存</span></span><br><span class="line"><span class="comment"> *      写-写 不能共存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  写：原子+独占</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key, Object value)</span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();  <span class="comment">// 写方法加写锁（独占锁）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;写线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;    正在写入：&quot;</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(<span class="string">&quot;写线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;    写入完成============&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        rwLock.readLock().lock();    <span class="comment">// 读方法加读锁（共享锁）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;正在读取============&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;读线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;读取完成，结果是：&quot;</span> + result);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5个线程同时写入，5个线程同时读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.write(String.valueOf(temp), temp);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myCache.read(String.valueOf(temp));</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/11/%E9%94%81%E5%88%86%E7%B1%BB/image-20210712150150198.png" alt="image-20210712150150198"></p>
<hr>
<ul>
<li>  公平锁 &amp; 非公平锁</li>
<li>  可重入锁</li>
<li>  自旋锁</li>
<li>  分段锁</li>
</ul>
<hr>
<h1 id="synchronized-锁的降级策略"><a href="#synchronized-锁的降级策略" class="headerlink" title="synchronized 锁的降级策略"></a>synchronized 锁的降级策略</h1>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/10/CAS/" rel="prev" title="CAS">
                  <i class="fa fa-chevron-left"></i> CAS
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="next" title="线程池">
                  线程池 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
