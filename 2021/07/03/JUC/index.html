<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="JUC；java.util.concurrent；  JUC 是 java.util.concurrent 工具包的简称，这是一个专门处理线程的工具包。 JUC 一般指以下三个包：    java.util.concurrent   java.util.concurrent.atomic   java.util.concurrent.locks  前置知识进程&#x2F;线程进程：CPU 分配资源的最">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC">
<meta property="og:url" content="http://example.com/2021/07/03/JUC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JUC；java.util.concurrent；  JUC 是 java.util.concurrent 工具包的简称，这是一个专门处理线程的工具包。 JUC 一般指以下三个包：    java.util.concurrent   java.util.concurrent.atomic   java.util.concurrent.locks  前置知识进程&#x2F;线程进程：CPU 分配资源的最">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210714112703545.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210706214541876.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210706215410137.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210706222059608.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210707110323903.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210707111358025.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210707120201254.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210707120803646.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210707121613702.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/Lock%E9%94%81.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210707143619075.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210707144208656.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/%E9%94%81%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210708205927767.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210708210157359.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210708210859384.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210708211522773.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210713124120349.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210713130528886.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210713131401299.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210713141702447.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210713144925160.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/%E6%AD%BB%E9%94%81.png">
<meta property="og:image" content="http://example.com/2021/07/03/JUC/image-20210716115243510.png">
<meta property="article:published_time" content="2021-07-03T02:00:06.000Z">
<meta property="article:modified_time" content="2021-10-22T12:27:59.756Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/07/03/JUC/image-20210714112703545.png">


<link rel="canonical" href="http://example.com/2021/07/03/JUC/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/07/03/JUC/","path":"2021/07/03/JUC/","title":"JUC"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JUC | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">进程&#x2F;线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.2.</span> <span class="nav-text">并发&#x2F;并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">1.3.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">1.4.</span> <span class="nav-text">知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="nav-number">1.4.1.</span> <span class="nav-text">线程的执行时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%886%E7%A7%8D%EF%BC%89"><span class="nav-number">1.4.2.</span> <span class="nav-text">线程的状态（6种）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.3.</span> <span class="nav-text">线程的4种实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.4.</span> <span class="nav-text">加锁的3种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-%E5%92%8C-Lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%94%A8%E6%96%B0%E7%9A%84-Lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">Synchronized 和 Lock 有什么区别？用新的 Lock 有什么好处？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Synchronized%EF%BC%888%E9%94%81%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">Synchronized（8锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.2.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">小结（重要）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">3.</span> <span class="nav-text">多线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%97%E6%97%A8%EF%BC%9A"><span class="nav-number">3.1.</span> <span class="nav-text">宗旨：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">题目：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">3.3.</span> <span class="nav-text">分析：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">3.4.</span> <span class="nav-text">代码实现：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="nav-number">3.5.</span> <span class="nav-text">虚假唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.1.</span> <span class="nav-text">虚假唤醒原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">3.5.2.</span> <span class="nav-text">如何解决虚假唤醒问题？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%89%88%E5%86%99%E6%B3%95%EF%BC%88Lock%E7%89%88%EF%BC%89"><span class="nav-number">3.6.</span> <span class="nav-text">新版写法（Lock版）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%BE%E5%87%86%E5%94%A4%E9%86%92"><span class="nav-number">3.7.</span> <span class="nav-text">精准唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A-1"><span class="nav-number">3.7.1.</span> <span class="nav-text">题目：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%901%EF%BC%9A"><span class="nav-number">3.7.2.</span> <span class="nav-text">分析1：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B01%EF%BC%9A"><span class="nav-number">3.7.3.</span> <span class="nav-text">代码实现1：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%902%EF%BC%9A"><span class="nav-number">3.7.4.</span> <span class="nav-text">分析2：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition-%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.7.5.</span> <span class="nav-text">Condition 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B02%EF%BC%9A"><span class="nav-number">3.7.6.</span> <span class="nav-text">代码实现2：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">3.7.6.1.</span> <span class="nav-text">执行流程分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Callable"><span class="nav-number">4.</span> <span class="nav-text">Callable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Callable-%E5%92%8C-Runnable-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%883-%E7%82%B9%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">1    Callable 和 Runnable 的区别（3 点）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%80%9A%E8%BF%87Callable-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">2    通过Callable 实现多线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">5.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="nav-number">5.3.</span> <span class="nav-text">代码演示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">6.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-1"><span class="nav-number">6.2.</span> <span class="nav-text">代码演示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Semaphore"><span class="nav-number">7.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">8.</span> <span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0"><span class="nav-number">9.</span> <span class="nav-text">笔记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">10.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">10.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="nav-number">10.2.</span> <span class="nav-text">产生原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">10.3.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/03/JUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JUC | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JUC
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-03 10:00:06" itemprop="dateCreated datePublished" datetime="2021-07-03T10:00:06+08:00">2021-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-22 20:27:59" itemprop="dateModified" datetime="2021-10-22T20:27:59+08:00">2021-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>  <strong>JUC；java.util.concurrent；</strong></p>
</blockquote>
<p>JUC 是 <code>java.util.concurrent</code> 工具包的简称，这是一个专门处理线程的工具包。</p>
<p>JUC 一般指以下三个包：</p>
<ul>
<li>  <strong>java.util.concurrent</strong></li>
<li>  <strong>java.util.concurrent.atomic</strong></li>
<li>  <strong>java.util.concurrent.locks</strong></li>
</ul>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h2><p>进程：CPU 分配资源的最小单元</p>
<p>线程：CPU 执行任务的最小单元</p>
<p>进程：QQ.exe、office.exe</p>
<p>线程：</p>
<ol>
<li> 在运行的 QQ 程序中同时开着聊天窗口、视频聊天、语音聊天，这些分别都是一个个线程；</li>
<li> 在 Word 中，提供输入页面的是一个线程，打字中如果输出不合法检测并提示的也是一个线程，未保存强制退出后下次可以恢复的功能也需要一直维持一个线程。</li>
</ol>
<h2 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发/并行"></a>并发/并行</h2><ul>
<li>  并发：多个线程蜂拥而入抢同一份资源。秒杀、抢票</li>
<li>  并行：多件事情同时进行</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul>
<li>  3个售票员    卖出    100张票。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/3 20:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  题目：三个售票员  卖出  20张票。 如何编写企业级的多线程代码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 企业级代码固定的编程套路——</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1、在高内聚低耦合的情况下，  线程      操作      资源类</span></span><br><span class="line"><span class="comment"> *      1.1 一言不合，先创建一个资源类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>(<span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                ticket.saleTicket();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer ticketNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ticket</span><span class="params">(Integer ticketNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ticketNum = ticketNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;正在卖出第&quot;</span>+ticketNum+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticketNum--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="线程的执行时机"><a href="#线程的执行时机" class="headerlink" title="线程的执行时机"></a>线程的执行时机</h3><ol>
<li> <code>start()</code> 方法被调用之后线程并不会立即执行，具体什么时候执行要看什么时候能得到CPU资源，这是由底层操作系统决定的。</li>
</ol>
<h3 id="线程的状态（6种）"><a href="#线程的状态（6种）" class="headerlink" title="线程的状态（6种）"></a>线程的状态（6种）</h3><p><strong>线程有6种状态</strong>。可以通过 <code>Thread.State</code> 进入源码查看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    WAITING,	<span class="comment">// 不见不散 </span></span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,	<span class="comment">// 过时不候</span></span><br><span class="line"></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程的4种实现方式"><a href="#线程的4种实现方式" class="headerlink" title="线程的4种实现方式"></a>线程的4种实现方式</h3><ol>
<li> 继承 Thread 类并重写类中的 run() 方法</li>
<li> 实现 Runnable 接口并重写接口中的 run() 方法</li>
<li> 实现 Callable 接口并重写接口中的 run() 方法</li>
<li> 通过线程池分配一个线程</li>
</ol>
<p>但是我们在上面的代码中，既没有继承 Thread 类和实现 Runnable/Callable 接口，更没有出现过线程池，那么是如何实现线程的呢？</p>
<p><strong>匿名内部类 + Lambda表达式</strong> 。在代码中看起来我们并没有实现 Runnable 接口，但其实是实现了的，只是通过一些语法糖让其不直接在源代码中显示出来罢了，在编译成二进制字节码文件时实现 Runnable 接口的这个操作是真实存在的。</p>
<p>匿名内部类实现的细节：1、实现了 Runnable 接口，并重写了接口中的 run() 方法。    2、多态，用一个 Runnable 类型的变量接收重写后匿名对象的地址。</p>
<h3 id="加锁的3种方式"><a href="#加锁的3种方式" class="headerlink" title="加锁的3种方式"></a>加锁的3种方式</h3><ol>
<li> 直接在方法上使用 synchronized 加锁</li>
<li> 使用 synchronized 代码块</li>
<li> 使用 Java 中专门提供的锁对象 Lock</li>
</ol>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock 是 java.util.concurrent.locks 包下的一个接口，实现类有 3 个：</p>
<ul>
<li>  Class ReentrantLock</li>
<li>  Class ReentrantReadWriteLock.WriteLock</li>
<li>  Class ReentrantReadWriteLock.ReadLock</li>
</ul>
<p>常见的使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Xxx</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); </span><br><span class="line">        <span class="comment">// block until condition holds </span></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="comment">// ... method body </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock() </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="Synchronized-和-Lock-有什么区别？用新的-Lock-有什么好处？"><a href="#Synchronized-和-Lock-有什么区别？用新的-Lock-有什么好处？" class="headerlink" title="Synchronized 和 Lock 有什么区别？用新的 Lock 有什么好处？"></a>Synchronized 和 Lock 有什么区别？用新的 Lock 有什么好处？</h4><p><img src="/2021/07/03/JUC/image-20210714112703545.png" alt="image-20210714112703545"></p>
<blockquote>
<ol>
<li> <strong>原始构成</strong></li>
</ol>
</blockquote>
<ul>
<li><p>synchronized 是关键字，属于 JVM 层面的锁。</p>
<p>  底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象，只有在同步代码块或同步方法中才能调用 wait/notify 等方法。</p>
<p>   monitorenter 指令代表进入锁对象，monitorexit 代表退出锁对象。</p>
<p>  为什么会有两个 monitorexit 呢？一个是正常退出，一个是异常退出</p>
</li>
<li><p>  Lock 是具体类（<code>java.util.concurrent.locks.Lock</code>），是 API 的层面的锁</p>
</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>使用方法</strong></li>
</ol>
</blockquote>
<ul>
<li>  <strong>synchronized 不需要用户去手动释放锁</strong>，当 synchronized 代码执行完后，系统会自动让线程释放对锁的占用</li>
<li>  ReentrantLock 则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁现象。需要 lock 和 unlock 方法配合 try…finally 语句块来完成</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>等待是否可中断</strong></li>
</ol>
</blockquote>
<ul>
<li>  synchronized 不可中断，除非是抛出异常或者正常运行完成</li>
<li>ReentrantLock 可中断：<ol>
<li> 设置超时方法 <code>trylock（long timeout, TimeUnit unit）</code></li>
<li> <code>lockInterruptibly()</code> 放在代码块中，调用 interrupt() 方法可以中断。</li>
</ol>
</li>
</ul>
<blockquote>
<ol start="4">
<li> <strong>加锁是否公平</strong></li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li> <strong>锁绑定多个条件 Condition</strong></li>
</ol>
</blockquote>
<ul>
<li>  synchronized 没有</li>
<li>  ReentrantLock 用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像 synchronized 一样要么随机唤醒一个线程要么唤醒全部的线程。</li>
</ul>
<hr>
<h1 id="Synchronized（8锁）"><a href="#Synchronized（8锁）" class="headerlink" title="Synchronized（8锁）"></a>Synchronized（8锁）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>  对象锁；全局锁（静态锁/类锁）</p>
</blockquote>
<p>synchronized 实现同步的基础：Java 中每一个对象都可以作为锁。具体表现为以下 3 种形式：</p>
<ol>
<li><p> 对于同步方法，锁对象是当前实例对象（this）</p>
</li>
<li><p>对于同步代码块，锁对象是 synchronized 括号里配置的对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (&lt;锁对象&gt;)&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>对于静态同步方法，锁对象是当前类的 Class 对象</p>
</li>
</ol>
<blockquote>
<p>  <strong>锁对象是当前对象this</strong></p>
</blockquote>
<p>锁对象是当前对象 this 的情况有 2 种：</p>
<ol>
<li> 如果对象中存在被 <strong>synchronized</strong> 修饰的普通成员方法，那么该方法默认的锁对象就是当前对象 this。</li>
<li> 如果对象中存在 synchronized 代码块，也可以让当前对象 this 作为锁对象，但这不是唯一的。因为锁对象可以是任意对象。</li>
</ol>
<blockquote>
<p>  <strong>锁对象是当前类的 Class 对象</strong></p>
</blockquote>
<p>锁对象是当前类的 Class 对象的情况也有 2 种：</p>
<ol>
<li> 如果类中存在被 <strong>static synchronized</strong> 修饰的静态成员方法，那么该方法默认的锁对象就是当前类的 Class 对象。</li>
<li> 如果对象中存在 synchronized 代码块，同样也可以在同步代码块中指定锁对象为当前类的 Class 对象，这同样也不是唯一的。</li>
</ol>
<blockquote>
<p>  <strong>synchronized 机制</strong></p>
</blockquote>
<p><strong>如果一个方法被 synchronized 修饰，它锁的范围不仅仅是当前方法，而是包含这个方法的整个锁对象。</strong></p>
<ul>
<li>  即如果 synchronized 作用在一个普通成员方法/变量上，synchronized 锁的就是这个 this 对象。</li>
<li>  即如果 synchronized 作用在一个静态成员方法/变量上。synchronized 锁的就是这个类的 Class 对象。</li>
</ul>
<p>在一个对象里面，不管这个对象中有多少个同步方法，只要一个线程先访问了该对象中的任一同步方法，那么它锁的不仅仅是它访问的这一个同步方法，它锁的是该对象中的所有同步方法【因为该对象中的所有同步方法都需要该对象锁】。</p>
<p>一个对象里如果有多个 synchronized 方法，某一时刻，只要有任意一个线程去调用其中任一个 synchronized 方法，其它的线程就只能等待。换句话说就是，某一时刻，只能有唯一一个线程去访问这个对象中的 synchronized 方法。而对于对象中的非加锁方法则无限制。</p>
<p>如果锁对象是当前对象 this，被锁定后，其它线程都不能进入到当前对象的其它 synchronized 方法，但可以进入当前对象的非加锁方法。</p>
<p>如果锁对象是 Class 对象，被锁定后，其它线程就不能进入到该 Class 对象中执行其它的被  synchronized 修饰的方法，同样也可以执行非加锁方法。</p>
<hr>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><strong>资源类</strong></p>
<p>定义一个手机类，有三个功能：发邮件、发短信、sayHello</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*static*/</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// TimeUnit.SECONDS.sleep(3);	// 暂停3s</span></span><br><span class="line">            System.out.println(<span class="string">&quot;*****sendEmail&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*static*/</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>  <strong>测试类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁。问题：</span></span><br><span class="line"><span class="comment"> *  1、标准访问：请问先发送邮件、还是先发送短信</span></span><br><span class="line"><span class="comment"> *      先发送邮件</span></span><br><span class="line"><span class="comment"> *  2、暂停 3s 邮件方法，请问先发送邮件还是短信</span></span><br><span class="line"><span class="comment"> *      先发送邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3、新增普通 sayHello 方法，请问先发送邮件还是先说 hello</span></span><br><span class="line"><span class="comment"> *		先说hello</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  4、两部手机，请问先发送邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发短信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  5、两个静态同步方法，同一部手机，请问先发邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  6、两个静态同步方法，两部部手机，请问先发邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  7、一个静态同步方法，一个普通同步方法，同一部手机，请问先发邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发短信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  8、一个静态同步方法，一个普通同步方法，两部手机，请问先发邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发短信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoSafeArrayList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程--&gt;&gt; 操作 --&gt;&gt; 资源类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;phone.sendEmail();&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);	<span class="comment">// main线程暂停100ms，确保A线程能先于B线程创建</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            phone.sendSMS();  </span></span><br><span class="line"><span class="comment">//            phone.sayHello();</span></span><br><span class="line">            phone2.sendSMS();</span><br><span class="line">            &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mian 线程按顺序从上往下执行，A 线程先被创建出来（New），B 线程再被创建出来（New）</p>
<blockquote>
<ol>
<li> <strong>标准访问：请问先发送邮件、还是先发送短信？</strong></li>
</ol>
</blockquote>
<p>线程 A 先获得锁对象（this 对象，在这里是 phone 对象），在线程 A 未释放锁对象之前，整个资源类中的其它加锁方法也是不能被其它线程访问的。所以线程 A 会先执行 <code>Phone#sendEmail</code> 方法，再释放锁对象，此时线程 B 才有机会去得到锁对象，所以线程 B 后执行 <code>Phone#sendSMS</code> 方法。</p>
<blockquote>
<ol start="2">
<li> <strong>发邮件前暂停 3s ，请问先发送邮件还是短信？</strong></li>
</ol>
</blockquote>
<p>同情况 1 类似。并不是说线程 A 暂停了 3s 线程 B 就能趁着这 3s 时间去执行自己的发短信的方法。因为 <code>Phone#sendEmail</code> 和 <code>Phone#sendSMS</code> 用的是同一个锁对象，而线程 A 只是暂停 3s ，并没有归还锁对象，所以线程 B 的发短信方法还不能执行。只有等到线程 A 3s 后被唤醒，执行发邮件的方法，再释放锁对象后，线程 B 才能得到锁对象并执行发短信方法。</p>
<blockquote>
<ol start="3">
<li> <strong>新增 sayHello 方法，请问是先发送邮件还是先说 hello？</strong></li>
</ol>
</blockquote>
<p>此时，测试类作出一些改动：线程 B 不再发短信，而是改成说 hello 了，并且 sayHello 方法是不加锁的。</p>
<p>此时的情况变成了，A 线程仍率先拿到锁对象，准备去执行<code>Phone#sendEmail</code> 方法，但在这个方法内部需要先暂停 4s；这时候其它线程仍然是不能执行当前锁对象中的加锁方法的，但是对于非加锁方法并没有这个限制。也就是说，在发邮件方法等待的 4s 内，线程 B 已经执行完了 sayHello 方法了。也就是<code>Phone#sayHello</code> 方法先于 <code>Phone#sendEmail</code> 方法执行。</p>
<blockquote>
<ol start="4">
<li> <strong>两部手机，请问先发送邮件还是短信？</strong></li>
</ol>
</blockquote>
<p>再次回到 <code>Phone#sendEmail</code> 和 <code>Phone#sendSms</code> 方法，这时候创建两个手机实例对象 phone 和 phone2。</p>
<p>首先线程 A 率先拿到锁对象 phone，并在释放锁对象之前拒绝其它线程进入该对象执行加锁的方法；然后 B 线程也拿到了自己的锁对象 phone2 ，注意此时是有两个不同的锁对象的。线程 A 禁止其它线程执行 phone 对象中的加锁方法，而线程 B 则进制其它线程执行 phone2 对象中的加锁方法。这两个锁对象是不同的，所以执行中互不相关。由于线程 A 的发邮件方法要暂停 3s，那么显然线程 B 的发短信服务会先被执行。</p>
<blockquote>
<ol start="5">
<li> <strong>两个静态同步方法，同一部手机，请问先发邮件还是短信？</strong></li>
</ol>
</blockquote>
<p>修改 <code>Phone#sendEmail</code> 和 <code>Phone#sendSms</code> 方法均为静态方法。</p>
<p>由于静态加锁方法默认的锁是 Class 对象，Class 对象在类加载阶段就已经被创建出来了，是一个单例对象。所以不管通过该 Class 对象创建出来多少个实例，其锁对象始终只有一个，即 Class 对象。</p>
<p>程序执行过程中，线程 A 拿到锁对象 Phone_Class 对象；100ms 后线程 B 意图进入 Phone_Class 对象，但发现此时这个锁对象已经被线程 A 占用了，就只能等待直到 A 线程用完（执行完<code>Phone.sendEmail</code>方法）释放锁对象后，再去争夺锁对象来执行<code>Phone.sendSms</code> 方法。所以这种情况下会先发邮件。</p>
<blockquote>
<ol start="6">
<li> <strong>两个静态同步方法，两部部手机，请问先发邮件还是短信？</strong></li>
</ol>
</blockquote>
<p>类似于第 5 种情况，虽然是通过两个不同的实例对象 phone 和 phone2 来分别执行发邮件和发短信的方法的，但是由于发邮件和发短信的方法都是静态的，所以它们争夺的锁对象是同一个，自然也就会出现在某个线程争夺到锁对象后锁住对象内的其它加锁方法的情况了。所以这种情况下还是线程A会先抢到锁对象，也即发邮件会先于发短信执行。</p>
<blockquote>
<ol start="7">
<li> <strong>一个静态同步方法，一个普通同步方法，同一部手机，请问先发邮件还是短信</strong></li>
</ol>
</blockquote>
<p>静态同步方法要争夺的是 Class 对象锁，普通同步方法要争夺的是 this 对象锁，它们各自锁定的范围互不相关，所以不会存在争夺锁对象的情况。但是发邮件的速度要慢于发短信，所以发短信的方法先执行。</p>
<blockquote>
<ol start="8">
<li> <strong>一个静态同步方法，一个普通同步方法，两部手机，请问先发邮件还是短信?</strong></li>
</ol>
</blockquote>
<p>同第 7 种情况类似，两个线程使用两个不同的锁对象，不存在竞争关系。发短信的速度快于发邮件，所以发短信的操作先执行。</p>
<h2 id="小结（重要）"><a href="#小结（重要）" class="headerlink" title="小结（重要）"></a>小结（重要）</h2><p>加锁机制其实就是一个锁对象争夺的问题。</p>
<p>首先我们要明确<strong>锁对象是一个单例</strong>，如果一个类中只含有一个锁对象，并且该类中所有被 synchronized 修饰的方法用的都是同一把锁，那么显然同一时刻只能有一个线程持有这把锁，其它线程没有锁就只能等待锁被释放后再去争夺了。</p>
<p>在上面举的例子中，每个对象中就只设置了一个锁对象。那么自然该对象中所有被 synchronized 修饰的方法用的就是这把锁，就会出现线程 A 未释放锁前线程 B 不能执行其它被 synchronized 修饰的方法这种情况（因为其它 synchronized 方法执行所需要的锁还是线程 A 正在持有的锁）。</p>
<p>那么如果我们在一个对象中定义多把锁，每个加锁方法（被 synchronized 修饰的方法）用不同的锁。假设为：</p>
<ul>
<li>  定义两把锁 A、B</li>
<li>  定义两个加锁的方法 methodA()、methodB()。methodA() 方法用 A 锁，methodB() 方法用 B 锁，</li>
</ul>
<p>那么会出现一种情况就是：让线程1先被创建，线程2再被创建，执行同一个对象中的两个加锁方法methodA() 和 methodB()，但是线程1 执行方法 A 的时候，线程 B 也能执行方法 B，而不用等到线程 A 归还锁对象后线程 B 再执行方法 B，因为这两个加锁方法虽然在同一个类中，但是使用的不是一个锁对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/6 13:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MulLock</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;obj.methodA();&#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;obj.methodB();&#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法B 先于 方法A 执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulLock</span>&#123;</span><br><span class="line">    <span class="comment">// 在一个对象中定义两把锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;方法A被执行了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方法B被执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也就是<strong>判断一个对象中的多个方法能否被多个线程同时执行的最根本的依据就是这些方法使用的是不是同一把锁</strong>。</p>
<hr>
<h1 id="多线程间通信"><a href="#多线程间通信" class="headerlink" title="多线程间通信"></a>多线程间通信</h1><p>​    多线程并发执行时，默认情况下 CPU 是随机切换线程的，当我们需要多个线程能<strong>有规律</strong>的执行任务时，就需要通过线程来协调任务进度。</p>
<h2 id="宗旨："><a href="#宗旨：" class="headerlink" title="宗旨："></a>宗旨：</h2><ol>
<li> <strong>高内聚低耦合的情况下，线程  操作  资源类。</strong></li>
<li> <strong>线程执行体内的结构：判断/干活/通知</strong></li>
<li> <strong>防止虚假唤醒</strong></li>
</ol>
<p>​    </p>
<p>​        在实际的多线程应用中，多个线程不可能仅仅只是卖票（卖票是多个线程操作同一份资源，但执行的动作是相同的，也就是说无论哪个线程先执行对结果都不会影响，即使有一个线程特别牛逼，它一个人把票都卖完了也可以）。</p>
<p>​        通常情况会是：多个线程会操作同一资源，但是线程的执行顺序是有先后要求的。典型的就是生产消费线程，一个线程生产，另一个线程消费。这时候如果还是让 CPU 随机调度线程的话，就可能会出现供不应求（一直消费很少生产）或供过于求（一直生产很少消费）的情况，这都是不合适的。为了能让线程能按我们设计的顺序执行（比如生产线程执行一次，消费线程再执行一次，交替循环执行），达到供给平衡，我们就必须通过线程间的通信，通过频繁的挂起/唤醒线程来让线程按指定的顺序执行。</p>
<p>​        在一个线程执行体内，以生产/消费为例，最核心的代码当然是干活的代码，在生产线程中就是生产产品，在消费线程中就是消费产品。但是我们不能让线程直接去执行干活的代码，如果产品数量为0了，消费线程还去执行的话，显然是不合理的；同理，产品已经多到卖不完了，生产线程还一直生产产品也是不合适的。</p>
<p>​        在一个<strong>标准的线程执行体</strong>内，</p>
<ol>
<li> 第一步代码代码应该是<strong>判断</strong>。主要是根据实际需求判断当前线程进入后应该被挂起还是干活。在生产消费线程中，即使生产线程抢到了锁对象，在执行方法的时候首先也会判断当前产品是否足够，如果当前产品是充足的，它也不会去干活，而是把自己挂起，让消费线程去干活。消费线程也类似。</li>
<li> 只有判断之后才能开始<strong>干活</strong>。对于生产线程而言干活就是生产，对于消费线程而言干活就是消费。</li>
<li> 在干完活之后需要<strong>通知</strong>其它线程。这里的通知其实就是唤醒其它线程，因为在该线程干活之前可能存在为了让出锁资源而让自己陷入 Waiting 状态的线程，这种线程只有通过 notify 方法才能将其唤醒。这里的通知并不是把修改后的数据通知给其它线程，把修改后的数据通知给其它线程是通过 synchronized 的原子性来保证的。</li>
</ol>
<hr>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>​        实现：两个线程可以操作初始为 0 的一个变量，一个线程对变量进行 +1 操作，另一个线程对变量进行 -1 操作。加减操作交替执行 10 轮。最后结果仍为 0。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>​        根据题目可以看出这是一个经典的多线程通信问题。</p>
<ol>
<li> 多个线程操作同一份资源</li>
<li> 并且要求线程的执行顺序必须交替执行</li>
</ol>
<p>显然这需要通过多线程间通信来协调对资源的调度。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><ol>
<li> 定义一个操作类 Operator，类中有两个加锁的方法 add 和 sub 分别实现 +1 操作和 -1 操作。</li>
<li> 定义一个测试类 Demo ，创建两个线程 A、B 分别执行 add 方法和 sub 方法。每个方法执行 10 次。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">/*生产（+1）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、判断</span></span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、干活</span></span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+num);</span><br><span class="line">        <span class="comment">// 3、通知</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*消费（-1）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、判断</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、干活</span></span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+num);</span><br><span class="line">        <span class="comment">// 3、通知</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.day01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/6 14:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1、高内聚低耦合的前提下，线程 操作 资源类</span></span><br><span class="line"><span class="comment"> *  2、判断/干活/通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Operator</span> <span class="variable">ope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Operator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程A负责变量 +1，线程B负责变量 -1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.add();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.sub();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 测试结果如下，完全正确。我们可以看到 +1 操作和 -1 操作依次执行，交替 10 次。</li>
</ol>
<img src="/2021/07/03/JUC/image-20210706214541876.png" alt="image-20210706214541876" style="zoom: 67%;">



<h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><ol start="4">
<li> 我们在这里修改一下上面的代码，新增两个线程 C 和 D，让线程 C 负责加操作，线程 D 负责减操作。ABCD 交替执行 10 次。（只修改测试类的代码）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Operator</span> <span class="variable">ope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Operator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程A（+1）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.add();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程B（-1）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.sub();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程C（+1）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.add();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程D（-1）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.sub();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li> 我们想象中的代码的执行结果应该是：<code>1 -&gt; 0 -&gt; 1 -&gt; 0</code> 这样依次执行的。那么我们来看看真实的执行结果是什么呢？</li>
</ol>
<img src="/2021/07/03/JUC/image-20210706215410137.png" alt="image-20210706215410137" style="zoom:67%;">

<ol start="6">
<li><p>在结果中竟然看到了 <strong>2</strong> ，这与我们设计的程序不符。我们想象中的程序应该是：</p>
<ul>
<li>  每次当 add() 方法发现 num 为 1 时，不会干活，直接就把锁对象让出去了，只有 <code>num==0</code> 时，才会干活，进行 +1 操作。</li>
<li>  同理，每次当 sub() 方法发现 <code>num==0</code> 时，不会干活，直接就把锁对象让出去了，只有 <code>num==1</code> 时，才会干活，进行 +1 操作。</li>
</ul>
<p> 这样程序的执行结果永远只会是 0 和 1，且 0、1 交替出现，那么为什么会出现 2 呢？这种情况就叫做<strong>虚假唤醒</strong>，那么造成虚假唤醒的原因是什么呢？</p>
</li>
</ol>
<h3 id="虚假唤醒原理"><a href="#虚假唤醒原理" class="headerlink" title="虚假唤醒原理"></a>虚假唤醒原理</h3><blockquote>
<ol>
<li> <strong>只有两个线程的情况：</strong></li>
</ol>
</blockquote>
<p>在只有两个线程的情况下，线程 A 负责加操作，线程 B 负责减操作。</p>
<ol>
<li><p>当线程 A 获取到锁和 CPU 资源后，开始执行 add 方法。首先要判断当前 num 是否为 0，</p>
<ul>
<li>  如果 <code>num == 0</code> 才进行 +1 操作；</li>
<li>  否则，直接释放锁对象，自己进入 Waiting 状态。</li>
</ul>
</li>
<li><p>同理，当线程 B 获取到锁和 CPU 资源后，开始执行 sub 方法。首先判断当前 num 是否为 0，、</p>
<ul>
<li>  如果 <code>num == 0</code> 直接释放锁对象，自己进入 Waiting 状态；</li>
<li>  否则才进行 -1 操作。</li>
</ul>
<p> ​        但是请注意（以线程 A 进入 Waiting 状态为例）：假设线程 A 进入了 Waiting 状态，就会释放锁对象，并且此时 <code>num == 1</code> 恒成立，然后线程 B 必然会进入 Runnable 状态，并在随后得到 CPU 资源执行 sub 方法：1、进行 -1 操作  2、唤醒 A 线程。</p>
<p> ​        重点来了！！！线程 B 唤醒 A 线程后，B 与 A 此时都处于 Runnable 状态，然后开始竞争锁对象，假设这时候 A 获得了锁对象（当然如果 B 获得了锁对象也没有关系，因为此时 <code>num==0</code>，即使 B 获得了锁对象最终还是会执行 wait 方法归还锁对象），那么<strong>线程 A 并不会从头开始重新执行一遍 add 方法，而是直接续着上次执行的位置继续执行。 也就是判读操作在线程睡眠之前已经执行过一次了，线程醒来后就不再判断了，而是直接从上次断开的位置往下走。</strong></p>
</li>
</ol>
<p><img src="/2021/07/03/JUC/image-20210706222059608.png" alt="image-20210706222059608"></p>
<p>​    在只有 2 个线程的环境中这是 OK 的，因为只有两种状态，不会对结果产生影响。那么如果有 4 个线程呢？我们来分析一下。</p>
<blockquote>
<ol start="2">
<li> <strong>四个线程并发执行的情况</strong>：</li>
</ol>
</blockquote>
<ol>
<li><p> 初始情况，<code>num == 0</code>，ABCD 四个线程开始抢夺锁对象；</p>
</li>
<li><p> 假设 A+ 线程抢到了锁对象，执行 add 方法，由于<code>num==0</code>，开始干活，更新 <code>num==1</code>，唤醒其它线程，最后释放锁对象。</p>
</li>
<li><p> 接着 C+ 线程抢到了锁对象，执行 add 方法，由于<code>num==1</code>，不干活，进入 Waiting 状态，直接释放锁对象。</p>
</li>
<li><p> 此时 A+ 又抢到了锁对象，执行 add 方法，由于<code>num==1</code>，也不干活，进入 Waiting 状态，直接释放锁对象。</p>
</li>
<li><p>接下来线程 B- 终于抢到锁对象了。执行 sub 方法，由于<code>num==1</code>，开始干活，更新 <code>num==0</code>，唤醒其它线程，最后释放锁对象。</p>
<p> 请注意：这时候 A+ 和 C+ 线程又重新被唤醒了，进入了 Runnable 状态，ABCD 四个线程又处于同一起跑线上准备抢夺锁对象。</p>
</li>
<li><p> 这时因为 C+ 线程已经等了很久了，所以它又得到了锁对象，执行 add 方法，注意，它是从上一次断开的位置继续执行的，也就是 wait() 方法的后一行，也就是说这次 if 判断不再执行了，它直接就得干活，更新 <code>num==1</code>，然后唤醒其它线程，释放锁对象。</p>
</li>
<li><p> 接着 A+ 线程得到锁对象，执行 add 方法，同样它也会从上一次断开的位置继续执行，没有 if 判断，直接干活。诶，这时候你就会发现，num++ 执行后 <strong>num==2</strong>，if 判断失效了，这是不对的。我们想要的代码应该是发现 num==1 后就不再 +1 了，而是让 sub 方法去执行 -1 操作。这就是传说中的<strong>虚假唤醒原理</strong>。</p>
</li>
</ol>
<p><img src="/2021/07/03/JUC/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92.png" alt="虚假唤醒"></p>
<h3 id="如何解决虚假唤醒问题？"><a href="#如何解决虚假唤醒问题？" class="headerlink" title="如何解决虚假唤醒问题？"></a>如何解决虚假唤醒问题？</h3><p>虚假唤醒的问题管方很早就给出了解决的答案，在 Java8_API_Doc 中明确指出[<strong>java.lang.Object#wait</strong>]：</p>
<blockquote>
<p>  As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop</p>
<p>  中断和虚假唤醒是可能存在的，所以 <strong>wait()</strong> 方法应该总是在循环 <strong>while</strong> 中使用。</p>
</blockquote>
<p><img src="/2021/07/03/JUC/image-20210707110323903.png" alt="image-20210707110323903"></p>
<p>​        <strong>if</strong> 只起到判断的作用，而 <strong>while</strong> 则能起到<strong>循环判断</strong>的作用。只需要在上面代码中调用 wait 方法的地方用 while 语句替换 if 语句，即可解决虚假唤醒的问题。即每次线程从 Waiting 状态重新进入 Runnable 状态时，还是会进行一次判断的过程，判断成功则干活，不成功则再次进入 Waiting 状态。</p>
<blockquote>
<p>  <strong>修改代码</strong></p>
</blockquote>
<p>修改 Operator 类中的代码为：（只需要将所有使用 wait 方法的判断条件从 if 改为 while 即可）</p>
<p><img src="/2021/07/03/JUC/image-20210707111358025.png" alt="image-20210707111358025"></p>
<p>修改后的代码即可按照 <code>1-&gt;0-&gt;1_&gt;0</code> 的顺序交替执行。</p>
<h2 id="新版写法（Lock版）"><a href="#新版写法（Lock版）" class="headerlink" title="新版写法（Lock版）"></a>新版写法（Lock版）</h2><p>首先要明确一点，在 synchronized 的写法中，wait 和 notify 都是由 this 锁对象调用的。</p>
<p>而在 Lock 的写法中，this 对象不再是锁对象了，那么继续使用 this 调用 wait 和 notify 也就不合适了。在 JavaDoc 中，专门推出了一个接口类型 Condition 用于让线程进入等待/唤醒状态。接口中定义了 <strong>await()</strong> 、<strong>signal()<strong>、</strong>signalAll()</strong> 方法对标 Object 类中的 <strong>wait</strong>、<strong>notify</strong>、<strong>notifyAll</strong> 方法。对应方法的作用是一样的，但是 Condition 接口中的方法专门用于 Lock 锁对象。</p>
<p><img src="/2021/07/03/JUC/image-20210707120201254.png" alt="image-20210707120201254"></p>
<p><img src="/2021/07/03/JUC/image-20210707120803646.png" alt="image-20210707120803646"></p>
<ul>
<li>  官方的使用说明案例</li>
</ul>
<p><img src="/2021/07/03/JUC/image-20210707121613702.png" alt="image-20210707121613702"></p>
<blockquote>
<p>  <strong>修改代码（Operator类）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span>  <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*生产（+1）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、判断</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、干活</span></span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+num);</span><br><span class="line">            <span class="comment">// 3、通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">     <span class="comment">/*消费（-1）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+num);</span><br><span class="line"></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>总结</strong></p>
</blockquote>
<p><img src="/2021/07/03/JUC/Lock%E9%94%81.png" alt="Lock锁"></p>
<h2 id="精准唤醒"><a href="#精准唤醒" class="headerlink" title="精准唤醒"></a>精准唤醒</h2><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><p><strong>要求</strong>：多线程之间按顺序调用，3个线程按照 <code>A-&gt;B-&gt;C</code> 的顺序执行。A线程打印5次“AA”，B 线程打印10次“BB”，C线程打印15次“CC”；重复10轮</p>
<p><strong>分解</strong>：</p>
<ol>
<li> A 线程打印5次“AA”，A线程进入 Waiting 状态，并通知B线程；</li>
<li> B 线程被唤醒，打印10次“BB”，B线程进入 Waiting 状态，并通知C线程；</li>
<li> C 线程被唤醒，打印10次“CC”，C线程进入 Waiting 状态，并通知A线程；</li>
<li> 这就是一轮，重复10轮。</li>
</ol>
<h3 id="分析1："><a href="#分析1：" class="headerlink" title="分析1："></a>分析1：</h3><blockquote>
<p>  <strong>前置知识：</strong></p>
</blockquote>
<p>每个锁对象会维护一个等待队列用于存储正在争夺该锁的线程实例。</p>
<blockquote>
<p>  <strong>过程分析：</strong></p>
</blockquote>
<p>​        要想实现三个线程ABC依次执行，可以为每一个线程设置唯一的<strong>标志位</strong>，假设为：<strong>线程A：1</strong>；<strong>线程B：2</strong>；<strong>线程C：3</strong>。</p>
<ol>
<li> 假设线程 A 先得到了锁对象，线程 A 执行完之后，先修改标志位（指定下一个要执行的线程），再将锁抛出；</li>
<li> 这时候按照需求本应该线程 B 来执行了，但是由于线程 A 将锁抛出之前唤醒了所有线程，所以此时线程 A、B、C 会一起争夺锁对象，谁得到锁谁就执行。</li>
<li> 假设 C 得到了锁对象，由于标志位不匹配，线程 C 会进入 Waiting 状态，并将锁抛出，让线程 AB 重新争夺锁对象；</li>
<li> 假设接下来 B 得到了锁对象，由于标志位不匹配，线程 B 也会进入 Waiting 状态，并将锁抛出；</li>
<li> 接下来只有线程 B 是活跃的了，线程 B 直接得到锁对象，B 执行完方法后，修改标志位，唤醒其它所有线程，抛出锁对象。</li>
<li> 又开始新一轮的 ABC 抢占锁对象。</li>
<li> 所以如果我们这么设计代码的话，在电脑上正常是可以按需求顺利执行的。但是<strong>每次都是抢占式调度的话，每次让正确的线程得到锁对象的时间都会花费较多的时间</strong>。</li>
</ol>
<h3 id="代码实现1："><a href="#代码实现1：" class="headerlink" title="代码实现1："></a>代码实现1：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                cpu.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                cpu.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                cpu.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志位。线程A：1；线程B：2；线程C：3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">// 默认线程A先执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lock锁，每个锁可以设置多个监听器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>)&#123;</span><br><span class="line">                c.await(); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">2</span>;   <span class="comment">// 干完活后修改标志位</span></span><br><span class="line">            c.signalAll();	<span class="comment">// 唤醒所有线程</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>)&#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">3</span>;   </span><br><span class="line">            c.signalAll();    </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>)&#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">1</span>;   </span><br><span class="line">            c.signalAll();    </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="分析2："><a href="#分析2：" class="headerlink" title="分析2："></a>分析2：</h3><p>​        如果多个线程间能实现<strong>精准通知</strong>，即 A 干完活唤醒 B，B 干完活唤醒 C，C 干完活唤醒 A，形成一个闭环。而不是 ABC 每次干完活后进行广播式的通知，唤醒所有线程进行抢占式的资源争夺。那么显然程序的执行速度能得到极大的提升，因为这样就减少了每次线程抢占锁对象成功但在方法体中的判断不成功导致线程重新被挂起和重新被唤醒的时间。</p>
<p>​        为了能满足这个条件，首先 <strong>Object#notifyAll</strong> 和 <strong>Condition#signalAll</strong> 方法是肯定不能使用的。那么 <strong>Object#notify</strong> 和 <strong>Condition#signal</strong> 该选择哪一个呢？首先我们来看下 <strong>Object#notify</strong> 的源码。</p>
<p><img src="/2021/07/03/JUC/image-20210707143619075.png" alt="image-20210707143619075"></p>
<p>​        具体就是说：唤醒此对象监视的等待队列中的一个线程，如果这个对象有多个等待中的线程，就会选择其中一个被唤醒。这个选择是任意的，由实现自行决定。也就是说，<strong>如果我们不自己手动去实现，那么调用 notify 方法唤醒的线程是随机的</strong>。那么显然，要想做到精准唤醒就不适合是用 notify 方法了，当然也不是不可以用，只是要自己去重写 notify 方法比较复杂，而且在 JUC 包下已经提供了现成的可以实现精准唤醒的方法，你自己实现也不见得能比人家写得好。这个方法就是 signal 方法，我们来看一下。</p>
<p><img src="/2021/07/03/JUC/image-20210707144208656.png" alt="image-20210707144208656"></p>
<p>​        <strong>signal()</strong> 方法的作用就是唤醒一个等待的线程，但是这里它是<strong>可以自行选择</strong>的。也就是说如果有多个线程BCD都处于 Waiting 状态，A线程正在使用锁对象，A在使用完锁后，不再是把锁往出一扔就不管了，它是可以指定下一个给谁，通过这个方法我们就可以实现将处于 Waiting 状态的多个线程精准唤醒了。</p>
<h3 id="Condition-接口"><a href="#Condition-接口" class="headerlink" title="Condition 接口"></a>Condition 接口</h3><ul>
<li>  Lock 锁与监听器（Condition）是<strong>一对多</strong>的，一个 Lock 锁可以有多个监听器，Condition 与线程也是<strong>一对多</strong>的，每个 Condition 都可以监视该锁对象锁住的所有线程，即每个 Condition 都维护一个线程等待队列。</li>
<li>  <strong>Condition 维护了一个等待队列</strong>，默认情况下它会将等待时间最长的线程优先级设置为最高（即放在队首元素），但是可以手动绑定一个线程作为某个 Condition 优先级最高的线程，看起来的效果就是只要通过该监听器唤醒的线程是确定的。</li>
<li>  如果想要实现线程间的精准唤醒，Condition 数量最好设置成与线程数相等的，即每个 Condition 的最高优先级的名额绑定一个线程。</li>
<li>  <strong>线程在第一次调用 wait() 方法的时候与监听器绑定</strong>。</li>
</ul>
<p><img src="/2021/07/03/JUC/%E9%94%81%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8.png" alt="锁和监听器"></p>
<h3 id="代码实现2："><a href="#代码实现2：" class="headerlink" title="代码实现2："></a>代码实现2：</h3><p>只需修改 CPU 类中代码即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志位。线程A：1；线程B：2；线程C：3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">// 默认线程A先执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lock锁，每个锁可以设置多个监听器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>)&#123;</span><br><span class="line">                c1.await(); <span class="comment">// 持有 c1 钥匙的线程进入 Waiting</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">2</span>;   <span class="comment">// 干完活后修改标志位</span></span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>)&#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">3</span>;   <span class="comment">// 干完活后修改标志位</span></span><br><span class="line">            c3.signal();    <span class="comment">// 唤醒</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>)&#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">1</span>;   <span class="comment">// 干完活后修改标志位</span></span><br><span class="line">            c1.signal();    <span class="comment">// 唤醒</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h4><p>在 CPU 类中，定义了一个锁对象，锁对象分配了 3 个监听器。注意此时监听器还尚未与线程绑定。初始标志位为 1</p>
<ol>
<li><p>首先 A 线程得到了锁对象，</p>
<ul>
<li>经标志位判断后应该干活，</li>
<li>就去干活了，</li>
<li>干完活后修改了<strong>标志位为 2</strong>，</li>
<li>最后通知 c2 监听的阻塞队列中优先级最高的线程，让它来获取锁对象。  <em>注意：此时 c2 监听器还未手动指定优先级最高的线程，即 c2 监听的阻塞队列是按照默认的线程等待时间划分优先级的。虽然此时 ABC 三个线程都是 Runnable 的，但是 B 和 C 等待时间一定长于 A，所以 c2 此时会将锁对象分配给 B 和 C 中等待时间较长的线程。</em></li>
</ul>
</li>
<li><p>假设接下来 C 线程得到锁对象，</p>
<ul>
<li>经判断后发现没有轮到它干活，需要被挂起。调用 <code>c3.await</code> 方法让线程C进入 Waiting 状态，并释放锁对象。  <em>注意，此时<strong>监听器 c3 维护的阻塞队列队首元素就被写死为线程 C 了</strong>，以后再调用 c3.signal 唤醒的一定是线程 C。</em></li>
</ul>
</li>
<li><p>由于线程 C 被挂起了，线程 A、B 抢夺锁对象，假设 B 抢到了锁对象，</p>
<ul>
<li>  经标志位判断后应该干活，</li>
<li>  就去干活了，</li>
<li>  干完活后修改了<strong>标志位为 3</strong>，</li>
<li>  最后将锁对象分配给 c3 监听的阻塞队列中优先级最高的线程，即线程 C。</li>
</ul>
</li>
<li><p>线程 C 得到锁对象。</p>
<ul>
<li>  经标志位判断后应该干活，</li>
<li>  就去干活了，</li>
<li>  干完活后修改了<strong>标志位为 1</strong>，</li>
<li>  最后将锁对象分配给 c1 监听的阻塞队列中优先级最高的线程。</li>
<li>  由于 c3 已经与线程 C 绑定了，所以此时就相当于唤醒线程 C。</li>
<li>  此时线程 B 和 C 都处于 Runnable 状态，均可争夺锁对象。</li>
</ul>
</li>
<li><p>假如 B 争夺到了锁对象，</p>
<ul>
<li>  经判断后发现没有轮到它干活，需要被挂起。调用 <code>c2.await</code> 方法让线程 B 进入 Waiting 状态，并释放锁对象。</li>
<li>  此时<strong>监听器 c2 就真正与线程 B 绑定了</strong>。</li>
<li>  <strong>至此，线程ABC就分别于 c1、c2、c3监听器绑定了</strong>。</li>
</ul>
</li>
<li><p>此时只剩 C 还处于 Runnable 状态，线程 C 得到锁对象。</p>
<ul>
<li>  经标志位判断后应该干活，</li>
<li>  就去干活了，</li>
<li>  干完活后修改了<strong>标志位为 1</strong>，</li>
<li>  最后唤醒监听器 c1 监听的线程（线程A），让它来获取锁对象。</li>
</ul>
</li>
<li><p> ……</p>
</li>
</ol>
<blockquote>
<p>  <strong>一些疑问</strong></p>
</blockquote>
<ol>
<li><p>假设线程 A、B、C分别绑定了c1、c2、c3 监听器，线程A正在执行，线程B、C 处于 Waiting 状态，线程A执行完毕后，释放锁对象，通过 c2 唤醒线程B。那么这个时候线程 A 到底该不该和线程 B 去抢夺锁对象呢？</p>
<p> <em>答：由于 c2 监听器监听的线程阻塞队列中优先级最高的已经是 B 线程了，所以监听器 c2 监听到线程 A 释放锁对象后，c2 会直接把锁对象分配给线程 B。即使这时候线程 A 和线程 B 都处于 Runnable 状态，但是由于线程 B 的优先级一定是最高的，所以不会考虑线程 A。</em></p>
</li>
</ol>
<p>​        从理论上来讲，线程 B 被唤醒后处于 Runnable 状态，而线程 A 顺利执行完毕后并不会进入 Waiting 状态，并且 run() 方法中的代码没有执行完（要循环10次，假设目前只循环了1次），线程 A 也不会变成 Teminated 状态，那么我觉得线程 A 就也会变成 Runnable 状态，那么此时还是会有两个线程抢占式地争夺锁对象，自然也就称不上是精准唤醒了。</p>
<p>​        此块好像用到了 CAS ，先这样处理。等弄清楚后再补充。</p>
<hr>
<h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><ul>
<li>  Callable 是 Java 中实现多线程的四种方式之一。</li>
<li>  Callable 是一个函数式接口 <code>--&gt;&gt;</code> 支持 Lambda 表达式。</li>
</ul>
<h2 id="1-Callable-和-Runnable-的区别（3-点）"><a href="#1-Callable-和-Runnable-的区别（3-点）" class="headerlink" title="1    Callable 和 Runnable 的区别（3 点）"></a>1    Callable 和 Runnable 的区别（3 点）</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Runnable</th>
<th align="center">Callable</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现的方法不同</td>
<td align="center"><code>run()</code></td>
<td align="center"><code>call()</code></td>
</tr>
<tr>
<td align="center">是否抛出异常</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">有无返回值</td>
<td align="center">无</td>
<td align="center">有</td>
</tr>
</tbody></table>
<h2 id="2-通过Callable-实现多线程"><a href="#2-通过Callable-实现多线程" class="headerlink" title="2    通过Callable 实现多线程"></a>2    通过Callable 实现多线程</h2><p>首先我们来看一下标准的通过 Runnable 接口实现多线程的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;==========Runnable Starting&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Runnable线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        那么我们继续通过这种方式来通过 Callable 接口实现多线程可以吗？答案是不可以的。我们可以看到，在 Thread 的构造函数这一步出错了。</p>
<img src="/2021/07/03/JUC/image-20210708205927767.png" alt="image-20210708205927767" style="zoom: 80%;">

<p>来看一下 Thread 的构造函数。</p>
<p><img src="/2021/07/03/JUC/image-20210708210157359.png" alt="image-20210708210157359"></p>
<p>​        <strong>Thread 的构造方法有多种重载形式，但是没有一种可以直接接收 Callable 类型的参数</strong>，所以我们就不能直接在构造 Thread 对象的时候就绑定 Callable 接口。那么如何通过 Thread 关联到 Callable 呢？这就需要有一个中间的传递者，它既能认识 Thread，又能认识 Callable。</p>
<ol>
<li><p> 首先要明确一点，Thread 的构造器不能接收 Callable 类型的参数，但是可以接收 Runnable 类型的参数。根据类的多态性，Thread 的构造方法同样可以接收 Runnable 的子类类型对象，比如 <strong>RunnableFuture</strong> ，这是 Runnable 接口的一个子接口。</p>
</li>
<li><p>在 RunnableFuture 接口的实现类中有一个 <strong>FutureTask</strong> 类，我么来看一下它的构造方法。</p>
<p> <img src="/2021/07/03/JUC/image-20210708210859384.png" alt="image-20210708210859384"></p>
<p> 发现创建 FutureTask 时构造方法中可以传入一个 Runnable 对象或是 Callable 对象。 </p>
</li>
<li><p>  这时我们再来捋一捋，Thread 对象在创建时可以传入一个 Runnable 类型的对象，FutureTask 类的爷爷辈是 Runnable 接口，而 FutureTask 对象在创建时又需要一个 Callable 对象，这样我们就可以把 Callable 对象与 Thread 联系起来了。</p>
</li>
</ol>
<img src="/2021/07/03/JUC/image-20210708211522773.png" alt="image-20210708211522773" style="zoom:80%;">

<p>​    接下来改写我们的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、FutureTask 中的泛型类型应与 Callable 中线程执行体的返回值类型一致</span></span><br><span class="line"><span class="comment"> * 2、通过 FutureTask#get() 方法来获得 Callable 中线程执行体的返回值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;==========Callable Start&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;==========Callable end&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;Callable线程&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (!futureTask.isDone())&#123;	</span><br><span class="line">            <span class="comment">// 如果 Callable 线程没有计算完毕，则 main 线程等待其算完后再进行下一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();	<span class="comment">// 获得Callable线程的返回结果，如无必要，放在程序执行的最后，避免堵塞main线程</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><blockquote>
<p>  <strong>CountDownLatch；倒计时锁</strong></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>  <code>CountDownLatch</code> 是一种同步辅助工具，作用是<strong>让一个或多个线程挂起，直到另一些线程完成了一系列操作后被挂起的线程再被唤醒</strong>。</li>
<li>  <code>CountDownLatch</code> 对象是用给定的计数器初始化的。<strong>调用 await 方法会使当前线程阻塞</strong>，调用 <strong>countDown()</strong> 方法会减少计数值，直到当前计数减为零之后，所有等待的线程都会被释放， await 方法的后面的代码会继续执行。</li>
</ul>
<p><img src="/2021/07/03/JUC/image-20210713124120349.png" alt="image-20210713124120349"></p>
<hr>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="/2021/07/03/JUC/image-20210713130528886.png" alt="image-20210713130528886"></p>
<ul>
<li>  <strong>CountDownLatch#await()</strong> ：让当前线程进入等待，直到 latch 锁减到 0 再唤醒线程（每次减 1）。</li>
<li>  <strong>CountDownLatch#countDown()</strong> ：减少 latch 锁的计数，如果计数达到 0  则释放所有等待的线程。</li>
</ul>
<hr>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><blockquote>
<p>  <strong>场景模拟：</strong></p>
</blockquote>
<p>火箭发射前需要先执行 5 项准备工作，这 5 个任务是并发执行的，无先后顺序，但是必须等到这 5 个任务准备就绪后，才能发射火箭。</p>
<blockquote>
<p>  <strong>原始代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;=====准备就绪&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;火箭发射成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果：</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> * 火箭发射成功</span></span><br><span class="line"><span class="comment"> * 任务4=====准备就绪</span></span><br><span class="line"><span class="comment"> * 任务3=====准备就绪</span></span><br><span class="line"><span class="comment"> * 任务2=====准备就绪</span></span><br><span class="line"><span class="comment"> * 任务1=====准备就绪</span></span><br><span class="line"><span class="comment"> * 任务5=====准备就绪</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  在上面代码中，6个线程并发执行，所以并不能保证火箭发射一定会在 5 个准备工作之后进行。</li>
<li>  面对这种情况，我们之前的做法一般是让 <code>main</code> 线程先休眠足够长的时间，这段时间内让  5 个准备工作先执行完毕，最后再执行发射火箭的操作。这种操作虽然能解决问题，但是由于休眠时间是手动设定的，并不能保证一定精准。</li>
<li>  在这种情况下最好的方法就是使用 <strong>CountDownLatch</strong> 类。</li>
</ul>
<blockquote>
<p>  <strong>使用 CountDownLatch 优化后代码</strong></p>
</blockquote>
<p><img src="/2021/07/03/JUC/image-20210713131401299.png" alt="image-20210713131401299"></p>
<p>首先创建一个 <code>CountDownLatch</code> 对象，初始化值计数为 5，下面的操作都是并发执行的。</p>
<ul>
<li>  假设先执行 for 循环，创建了第一个线程，之后线程被挂起，而去执行 mian 线程了；</li>
<li>  main 线程执行到 <code>countDownLatch.await();</code> 时发现 CountDownLatch 对象的计数值不为 0，就会让当前线程（main）进入睡眠。</li>
<li>  for 循环中每个线程执行完毕时都会将 <code>CountDownLatch</code> 对象中的计数器 <code>-1</code>，当 for 循环中的五个线程全部执行完毕后，计数器值就会变成 0 ，这时由于 <code>countDownLatch.await();</code> 方法而挂起的线程会全部被唤醒（这里只有一个等待的线程，所以只唤醒了一个）</li>
</ul>
<blockquote>
<p>  <strong>执行结果：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">任务<span class="number">4</span>=====准备就绪</span><br><span class="line">任务<span class="number">5</span>=====准备就绪</span><br><span class="line">任务<span class="number">1</span>=====准备就绪</span><br><span class="line">任务<span class="number">3</span>=====准备就绪</span><br><span class="line">任务<span class="number">2</span>=====准备就绪</span><br><span class="line">火箭发射成功</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 个准备工作线程是没有指定的工作顺序的，但是 发射操作 一定会在 5 个准备工作全部完成之后才进行</span></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><blockquote>
<p>  <strong>CyclicBarrier；循环屏障</strong></p>
</blockquote>
<ul>
<li>  <code>CyclicBarrier</code> 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。</li>
<li>  它的主要作用是：让一组线程一起通过屏障点（也可以叫同步点）。每当有线程到达屏障点时，该线程就停止运行，直到所有的线程都到达了这个点，所有线程才重新运行。</li>
<li>  它的构造方法可以指定一个目标值，只有当到达屏障点的线程数量等于目标值时，屏障才会开门，所有停住的线程会同时继续运行。</li>
<li>  线程通过通过 <strong>Cyclic#await</strong> 方法停止运行，每调用一次 <code>await()</code> 方法，目标值+1。</li>
<li>  集齐七颗龙珠，才能召唤神龙。</li>
<li>  与 CountDownLatch 恰恰相反，CyclicBarrier 初始值为 0，只有达到指定值，才能开始执行。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><img src="/2021/07/03/JUC/image-20210713141702447.png" alt="image-20210713141702447"></p>
<blockquote>
<p>  <strong>两个参数的含义</strong>：</p>
</blockquote>
<ol>
<li> <strong>int parties</strong>：目标值</li>
<li> <strong>Runnable barrierAction</strong>：达到目标值后要执行的线程</li>
</ol>
<h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, ()-&gt;&#123; System.out.println(<span class="string">&quot;=======召唤神龙&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收集到了&quot;</span>+ temp +<span class="string">&quot;星龙珠&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();  <span class="comment">// 七个线程每个线程收集一颗龙珠，收集完成后，挂起</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;测试是否执行后续代码&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, Thread.currentThread().getName()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当七个线程全部执行完毕后，目标值就达到了，可以破开屏障，先执行 CyclicBarrier 构造方法中指定的线程，</span></span><br><span class="line">        <span class="comment">// 再执行之前被挂起的七个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果展示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 收集到了1星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了7星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了6星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了5星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了4星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了3星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了2星龙珠</span></span><br><span class="line"><span class="comment"> * =======召唤神龙</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><blockquote>
<p>  <strong>Semaphore；信号量；抢车位</strong></p>
</blockquote>
<ul>
<li>  多个线程抢多个资源</li>
<li>  Semaphore 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于<strong>控制并发的线程数</strong>。</li>
</ul>
<blockquote>
<p>  <strong>Semaphore 中的方法：</strong></p>
</blockquote>
<p><strong>Semaphore(int permits)</strong> 构造方法中指定了当前进程中最多只能允许几个线程同时运行。意思就是一个萝卜一个坑，线程就是萝卜，萝卜可以有多个，但是坑位是有限的，线程数可以远大于坑位数，但是同时（并发）运行的只能与坑位数量相同。</p>
<ul>
<li>  <code>Semaphore # acquire()</code>：占有坑位</li>
<li>  <code>Semaphore # release()</code>：释放坑位</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.other;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 14:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 模拟3个车位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;  <span class="comment">// 模拟6部汽车</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();    <span class="comment">/*抢到资源*/</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;====抢到车位&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;====停车3s后离开&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();    <span class="comment">/*释放资源*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/07/03/JUC/image-20210713144925160.png" alt="image-20210713144925160" style="zoom:80%;">

<blockquote>
<p>  <strong>结果分析：</strong></p>
</blockquote>
<ul>
<li>  线程 2、4、1 先抢到车位资源，每占用一分资源，Semaphore 信号量的值减少 1。线程使用完后，需要将占用的资源释放，每释放一份资源。Semaphore 信号量的值增加 1。</li>
<li>  当信号量值大于 0 时，表示还有资源（车位）可以使用，当为 0 时则表示没有资源能被使用了，这时每当有资源被释放，被阻塞的线程就可以去争夺资源了。</li>
<li>  我们在本地中设置每个线程对车位的使用时间都是 3s，所以基本上出现的是几乎 3 个线程同时占用，3 个线程同时释放的情况。如果我们将每个线程对车位的使用时间都设为随机值，就可以模拟，汽车走一辆，进来一辆的情况。</li>
</ul>
<hr>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><ul>
<li>  <a href>超链接：阻塞队列</a></li>
</ul>
<hr>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><ul>
<li><p>  lock() 方法 底层调用的是 sync.lock(); 方法；</p>
</li>
<li><p>  sync 是一个 Sync 类的对象，继承自 AbstractQueuedSynchronizer（AQS），实现类包括：</p>
</li>
<li><p>在非公平锁的实现方法中：</p>
<ol>
<li> 先进行 CAS 操作，如果 CAS 操作失败才去取同步队列中的第一个元素。</li>
</ol>
</li>
<li><p>  在公平锁的 lock 方法中：直接获取同步队列的第一个元素</p>
</li>
<li><p>  非公平锁和公平锁都没有重写 unlock 方法，所以用的是 Sync 对象中的同一个 unlock 方法</p>
</li>
<li><p>unlock() 方法 底层调用的是 sync.release(1); 方法</p>
<ul>
<li>  检查同步队列头结点是否为 null + 头结点状态设置为 </li>
</ul>
</li>
</ul>
<hr>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><img src="/2021/07/03/JUC/%E6%AD%BB%E9%94%81.png" alt="死锁"></p>
<p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种<strong>互相等待的现象</strong>，若无外力干涉那它们都将无法推进下去。如果系统资源充足，线程的资源请求都能满足，死锁出现的可能性就很低，否则就会因为争夺优先的资源而陷入死锁。</p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ul>
<li>  系统资源不足</li>
<li>  进程运行推进的顺序不合适</li>
<li>  资源分配不当</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/16 11:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造注入*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String lockA, String lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;****自己持有&quot;</span> + lockA + <span class="string">&quot;，尝试获得：&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;****自己持有&quot;</span> + lockB + <span class="string">&quot;，尝试获得：&quot;</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockA, lockB), <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockB, lockA), <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/03/JUC/image-20210716115243510.png" alt="image-20210716115243510"></p>
<p><strong>代码分析</strong></p>
<ol>
<li> main 线程启动，创建两个子线程 T1 和 T2。</li>
<li> 假设 T1 先执行，T1 先去争夺锁对象 lockA，此时无人争夺该锁对象，T1 得到 lockA 后在控制台上打印输出，然后进入睡眠状态。</li>
<li> T1 睡眠的时间足够长，足够 T2 线程获取到 lockB 对象并在控制台上打印输出，然后 T2 也进入睡眠状态。</li>
<li> 当 T1 睡醒后，只有得到了 lockB 锁才能继续执行下去，而 lockB 正在被 线程 T2 持有；当 T2 睡醒后，只有得到 lockA 才能继续执行下去，而 lockA 被线程 T1 持有。</li>
<li> 两个线程想要能继续执行的锁都被彼此所持有，这就造成了死锁的现象。</li>
</ol>
<hr>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/" rel="prev" title="Java面经——JavaSE">
                  <i class="fa fa-chevron-left"></i> Java面经——JavaSE
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/" rel="next" title="集合类线程不安全——List/Set/Map">
                  集合类线程不安全——List/Set/Map <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
