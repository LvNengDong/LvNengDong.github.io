<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. 是什么定义：   索引是一种文件。  索引是一种数据结构。     文件：  索引是一个文件，它是要占据物理空间的。    对于聚簇索引（如 InnoDB）而言，索引表中直接保存了对应的真实数据表中的所有的记录，所以 InnoDB 持久化后只会得到一个文件，即索引表数据和真实数据表数据都保存在一起。   对于非聚簇索引（如 MyISAM）而言，索引表中保存了数据表中对应记录的引用（也就是主键">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL索引">
<meta property="og:url" content="http://example.com/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. 是什么定义：   索引是一种文件。  索引是一种数据结构。     文件：  索引是一个文件，它是要占据物理空间的。    对于聚簇索引（如 InnoDB）而言，索引表中直接保存了对应的真实数据表中的所有的记录，所以 InnoDB 持久化后只会得到一个文件，即索引表数据和真实数据表数据都保存在一起。   对于非聚簇索引（如 MyISAM）而言，索引表中保存了数据表中对应记录的引用（也就是主键">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="file://E:/blog/source/_posts/MySQL%E7%B4%A2%E5%BC%95/image-20210724170912841.png?lastModify=1632123618">
<meta property="og:image" content="http://example.com/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/image-20210920161141312.png">
<meta property="og:image" content="http://example.com/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/BTree.png">
<meta property="og:image" content="http://example.com/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/java3-1562726249.jpeg">
<meta property="og:image" content="http://example.com/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/image-20210920174400590.png">
<meta property="article:published_time" content="2021-07-23T07:19:07.000Z">
<meta property="article:modified_time" content="2021-10-21T13:55:41.686Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file://E:/blog/source/_posts/MySQL%E7%B4%A2%E5%BC%95/image-20210724170912841.png?lastModify=1632123618">


<link rel="canonical" href="http://example.com/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/","path":"2021/07/23/MySQL索引/","title":"MySQL索引"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL索引 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">1. 是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">2. 优缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">3. 索引分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E5%BA%94%E7%94%A8%E5%B1%82%E6%AC%A1%E5%88%86%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">按应用层次分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">复合索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">最左前缀原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E6%98%AF%E5%90%A6%E8%81%9A%E7%B0%87%E5%88%86%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text">按是否聚簇分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB-%E4%B8%AD%E7%9A%84%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-amp-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">InnoDB 中的聚簇索引 &amp; 非聚簇索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM-%E5%8F%AA%E6%9C%89%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">MyISAM 只有非聚簇索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">非聚簇索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="nav-number">3.3.</span> <span class="nav-text">按存储结构分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-number">3.3.1.</span> <span class="nav-text">二叉排序树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.3.2.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree"><span class="nav-number">3.3.3.</span> <span class="nav-text">B-Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree-1"><span class="nav-number">3.3.4.</span> <span class="nav-text">B+Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash-%E7%B4%A2%E5%BC%95"><span class="nav-number">3.3.5.</span> <span class="nav-text">Hash 索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">3.4.</span> <span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.1.</span> <span class="nav-text">前缀索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E8%AF%AD%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">4. 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">4.1.</span> <span class="nav-text">创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%97%B6%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">4.1.1.</span> <span class="nav-text">1. 创建表时创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AF%B9%E5%B7%B2%E6%9C%89%E7%9A%84%E8%A1%A8%E6%96%B0%E5%A2%9E%E7%B4%A2%E5%BC%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">2. 对已有的表新增索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E4%BD%BF%E7%94%A8-CREATE-INDEX-%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">2.1 使用 CREATE INDEX 命令创建索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E4%BD%BF%E7%94%A8-ALTER-TABLE-%E5%91%BD%E4%BB%A4%E5%A2%9E%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">2.2 使用 ALTER TABLE 命令增加索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-number">4.2.</span> <span class="nav-text">删除索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%9A%84%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95"><span class="nav-number">4.3.</span> <span class="nav-text">查看一张表中创建的所有索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8BMySQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95"><span class="nav-number">4.4.</span> <span class="nav-text">查看MySQL语句执行时有没有用到索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">5.</span> <span class="nav-text">5. 索引失效的几种情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Q-amp-A"><span class="nav-number">6.</span> <span class="nav-text">Q&amp;A</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8B-Tree%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFB-Tree%EF%BC%8CHash%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">1、为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">2、非聚簇索引一定会回表查询吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.3.</span> <span class="nav-text">3、创建索引时需要注意什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">6.4.</span> <span class="nav-text">4、哪些情况下需要创建索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">6.5.</span> <span class="nav-text">5、哪些情况不需要创建索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">6.6.</span> <span class="nav-text">6、建索引的原则有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%AE%9A%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F"><span class="nav-number">6.7.</span> <span class="nav-text">7、使用索引查询一定能提高查询的性能吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%8F%8A%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">6.8.</span> <span class="nav-text">8、联合索引及最左匹配原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1-UUID-%E5%92%8C-%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.9.</span> <span class="nav-text">10、主键设计 UUID 和 自增主键的区别</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL索引 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL索引
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-23 15:19:07" itemprop="dateCreated datePublished" datetime="2021-07-23T15:19:07+08:00">2021-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-21 21:55:41" itemprop="dateModified" datetime="2021-10-21T21:55:41+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h1><p><strong>定义：</strong></p>
<ol>
<li> 索引是一种<strong>文件</strong>。</li>
<li> 索引是一种<strong>数据结构</strong>。</li>
</ol>
<blockquote>
<p>  <strong>文件：</strong></p>
</blockquote>
<p>索引是一个文件，它是要占据物理空间的。</p>
<ul>
<li>  对于聚簇索引（如 InnoDB）而言，索引表中直接保存了对应的真实数据表中的所有的记录，所以 InnoDB 持久化后只会得到一个文件，即索引表数据和真实数据表数据都保存在一起。</li>
<li>  对于非聚簇索引（如 MyISAM）而言，索引表中保存了数据表中对应记录的引用（也就是主键），所以对于 MyISAM 而言，持久化后会得到两个文件，一个文件用于保存索引表的数据，另一个文件用于保存真实表的数据。</li>
</ul>
<blockquote>
<p>  <strong>数据结构：</strong></p>
</blockquote>
<ul>
<li>  索引是一种数据结构。可以理解为“<strong>排好序的可以实现快速查找的数据结构</strong>”，能够用于提高数据查找的效率。</li>
<li>  索引的具体实现可以有多种，常见的有 B-树、B+树、AVL树、Hash 等等。</li>
<li>  通过对某些列建立索引，可以避免对数据的全局扫描，以更少的查找次数快速找到要查询的数据。</li>
</ul>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<p>索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。MySQL 索引的建立对于 MySQL 的高效运行是很重要的，索引可以大大提高 MySQL 的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。</p>
<blockquote>
<p>  <strong>解释说明：</strong></p>
</blockquote>
<p><strong>Before：</strong></p>
<ul>
<li>  如果没有索引，想要查询 <code>tb_user</code> 表中 <code>name=&quot;张三&quot;</code> 的这条数据，我们需要挨个查询 <code>tb_user</code> 表中的所有数据，直到找到 <code>name=&quot;张三&quot;</code> 的数据。当然这种查询存在随机性，可能第一个就直接查到了，也有可能直到最后一个才查到，平均时间复杂度为 <code>O(n)</code> 。</li>
</ul>
<p><strong>After：</strong></p>
<ul>
<li>  假设我们为 name 这一列建立了一个索引（假设索引的数据结构为 B+Tree），这时 name 列中的所有数据就会按照某种规则映射到 B+Tree 上，想要查询 <code>name=&quot;张三&quot;</code> 的这条数据时，用 <code>“张三”</code> 对应的值与 B+Tree 第一层的多个范围空间进行对比，找到满足条件的范围进入下一层对比，这样只需要很少的几次比较，就能够定位到 “张三” 在 BTree 中的位置，再从索引直接关联到数据库中真实数据的内存地址，即完成了一次快速的查询。</li>
</ul>
<blockquote>
<p>  <strong>索引会影响到两大功能的执行效率：</strong></p>
</blockquote>
<ol>
<li> 排序：<code>ORDER BY</code> </li>
<li> 查找：<code>WHERE；HAVING</code></li>
</ol>
<p><strong>解释：</strong></p>
<ul>
<li>  查找时，如果对应的字段建立了索引，就不会出现在某张表中挨个查找的情况，而是跳着查找，效率更高。</li>
<li>  排序时，因为索引结构本身就是有序的，所以对应的字段直接按照索引顺序正序或倒序排列即可。</li>
</ul>
<hr>
<h1 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2. 优缺点"></a>2. 优缺点</h1><blockquote>
<p>  <strong>优点</strong>：</p>
</blockquote>
<ol>
<li><strong>索引能提高数据检索速率</strong>，对于一些常用于查询的字段，如果将其设置为索引，能大大地提高查询的速率。<ul>
<li>  将频繁使用的字段就将其设置为索引，比不设索引时查询速度要快。</li>
</ul>
</li>
<li> <strong>对索引列的数据进行排序，排序的成本将大大降低</strong>。</li>
</ol>
<blockquote>
<p>  <strong>缺点</strong>：</p>
</blockquote>
<ol>
<li> <strong>需要维护额外的索引表的空间</strong>。索引也是一张表，该表保存了索引字段（主键天生就是索引字段），并指向实体表中的记录。所以索引也是要占用空间的。</li>
<li><strong>在发生写操作时，创建和维护索引需要额外的时间</strong>。虽然索引大大提高了查询速度，但同时会降低写操作的执行效率。比如在对表进行 CRUD 操作时，不仅需要更新表中的数据，还要更新对应的索引表。<ul>
<li>  对于 UPDATE 操作，记录变更后索引字段在索引表中的位置就可能发生变化，需要更新索引表。</li>
<li>  对于 INSERT 操作，添加记录后需要将新记录的索引字段加到索引表中。</li>
<li>  DELETE 同上。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h1><h2 id="按应用层次分类"><a href="#按应用层次分类" class="headerlink" title="按应用层次分类"></a>按应用层次分类</h2><ul>
<li>  <strong>单列索引</strong>：一个索引只包含单个列，一个表可以有多个单列索引。</li>
<li>  <strong>复合索引</strong>：即一个索引包含多个列。</li>
<li>  <strong>唯一索引</strong>：索引列的值必须唯一（即用于建立索引的列必须符合 UNIQUE），但<strong>允许有空值</strong>。【主键就是一种唯一索引】</li>
</ul>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><ul>
<li>  MySQL 可以使用多个字段同时建立一个索引，叫做复合索引。</li>
<li>  <strong>在复合索引中，如果想要命中索引，筛选条件需要严格按照建立索引时的字段顺序，否则无法命中索引</strong>。</li>
</ul>
<blockquote>
<p>   <strong>具体原因：</strong></p>
</blockquote>
<ul>
<li>  MySQL 使用索引时需要筛选条件按照索引的创建方式严格有序。</li>
<li>  假设现在建立了 <code>(id, name，age)</code> 的联合索引，那么索引的排序为： 先按照 id 排序，如果 id 相同，再按照 name 排序；如果 name 的值也相同，再按照 age 排序，以此类推。</li>
<li>  在进行查询时，如果仅仅按照 id 查询，是可以命中索引的；按照 <code>(id,name)</code> 或者 <code>(id,name.age)</code> 的顺序查询，也是可以命中索引的。但是如果调换了顺序，比如将 name 或 age 提到 id 之前，按照 <code>(name, id)</code> 的顺序来查询，就无法命中索引了。</li>
</ul>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><ul>
<li>  <strong>最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where 子句中使用最频繁的一列放在最左边</strong>。</li>
<li>  MySQL 会<strong>一直向右匹配直到遇到范围查询</strong>(&gt;、&lt;、between、like)就停止匹配，比如 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立 <code>(a,b,c,d)</code> 顺序的索引，d 是用不到索引的，如果建立 <code>(a,b,d,c)</code> 的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>  = 和 in 可以乱序，比如 <code>a = 1 and b = 2 and c = 3</code> 建立 <code>(a,b,c)</code> 索引可以任意顺序，MySQL 的查询优化器会帮你优化成索引可以识别的形式。</li>
</ul>
<hr>
<h2 id="按是否聚簇分类"><a href="#按是否聚簇分类" class="headerlink" title="按是否聚簇分类"></a>按是否聚簇分类</h2><blockquote>
<ul>
<li>  <strong>聚簇索引（聚集索引）</strong>：<strong>聚簇索引</strong>就是将索引数据和真实数据在物理上保存在一起，找到索引也就找到了数据。</li>
<li>  <strong>非聚簇索引</strong>：<strong>非聚簇索引</strong>就是真实数据和索引数据物理上不保存在一起，但是索引表中保存了指向真实数据的指针，要获取表中的真实数据有时还需要通过索引对应的地址空间到另一张专门保存数据的表中去找。</li>
</ul>
</blockquote>
<h3 id="InnoDB-中的聚簇索引-amp-非聚簇索引"><a href="#InnoDB-中的聚簇索引-amp-非聚簇索引" class="headerlink" title="InnoDB 中的聚簇索引 &amp; 非聚簇索引"></a>InnoDB 中的聚簇索引 &amp; 非聚簇索引</h3><p>在 InnoDB 里，</p>
<ul>
<li>  索引 <code>B+Tree</code> 的叶子节点存储了整行数据的索引是主键索引，也被称之为聚簇索引，即将整行数据与索引放到了一块，找到索引也就找到了数据。</li>
<li>  而索引 <code>B+Tree</code> 的叶子节点存储了主键的值（在这里主键的值就是指向真实数据的指针）的是非主键索引，也被称之为非聚簇索引、二级索引。</li>
</ul>
<blockquote>
<p>  <strong>聚簇索引与非聚簇索引的区别：</strong></p>
</blockquote>
<ul>
<li>  InnoDB 的聚簇索引其实就是在同一个结构中保存了 B+Tree 索引和数据行。</li>
<li>  非聚簇索引与聚簇索引的区别在于非聚簇索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）。</li>
<li>  对于 InnoDB 来说，想要查找数据我们还需要根据主键再去聚簇索引中进行查找，这个再根据聚簇索引查找数据的过程，我们称为<strong>回表</strong>。</li>
<li>  <strong>MyISAM 无论主键索引还是二级索引都是非聚簇索引，而 InnoDB 的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引</strong>。</li>
<li>  聚簇索引要求真实数据与索引存放在一起，所以<strong>一个表当中最好只有一个聚簇索引</strong>，而非聚簇索引可以有多个。如果想要一个表中能有多个聚簇索引，就需要给每一个聚簇索引分配一份真实表数据的副本。</li>
</ul>
<h3 id="MyISAM-只有非聚簇索引"><a href="#MyISAM-只有非聚簇索引" class="headerlink" title="MyISAM 只有非聚簇索引"></a>MyISAM 只有非聚簇索引</h3><ul>
<li>  MyISAM 使用的就是非聚簇索引，树的叶子节点上的 Data 不是数据本身，而是数据存放的地址。InnoDB 采用的是聚簇索引，树的叶子节点上的 Data 就是数据本身。</li>
<li>  MySQL 的 MyISAM 引擎在建立索引时，会专门维护一张索引表，索引表中除了索引值外，还有一列用于存储真实数据的内存地址，这就叫做非聚簇索引。</li>
<li>  因为</li>
<li>  InnoDB 中，如果表定义了 PrimaryKey，那么 PrimaryKey 就是聚簇索引。如果没有 PrimaryKey ，就会找第一个非空的 unique 列作用聚簇索引。否则，InnoDB 会创建一个隐藏的 row_id 作为聚簇索引。</li>
</ul>
<h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据（记录了真实真实数据的地址），在这些数据结构上我们可以实现高效的查找算法。这种数据结构，就是<strong>索引</strong>。</p>
<p>下图就是一种非聚簇索引的实现方式示例：</p>
<p><img src="file://E:/blog/source/_posts/MySQL%E7%B4%A2%E5%BC%95/image-20210724170912841.png?lastModify=1632123618" alt="image-20210724170912841"></p>
<ul>
<li>  左边是索引表，一共有两列七条记录，最左边记录的是真实数据的物理地址，Col1 是主键字段，Col2 是索引字段。</li>
<li>  为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</li>
<li>  一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</li>
</ul>
<h2 id="按存储结构分类"><a href="#按存储结构分类" class="headerlink" title="按存储结构分类"></a>按存储结构分类</h2><blockquote>
<ul>
<li>  二叉排序树（BST）</li>
<li>  平衡二叉树（AVL）</li>
<li>  B-Tree（B树）</li>
<li>  <strong>B+Tree（MySQL 的 InnoDB 引擎使用的是 B+Tree 索引）</strong></li>
<li>  Hash 索引</li>
<li>  Full-Text 全文索引</li>
<li>  R-Tree 索引</li>
</ul>
</blockquote>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><ul>
<li>  若它的左子树不为空，则左子树上所有关键字的值均小于根关键字的值；</li>
<li>  若它的右子树不为空，则右子树上所有关键字的值均大于根关键字的值；</li>
<li>  左右子树又是一棵二叉排序树。</li>
</ul>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><ul>
<li>  平衡二叉树首先是一棵二叉排序树，但是其要满足左右子树高度之差的绝对值不超过 1。</li>
<li>  平衡二叉树的左右子树也是平衡二叉树。</li>
</ul>
<hr>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B-Tree 能加快数据的访问速度。</p>
<ul>
<li>  因为存储引擎不再需要进行全表扫描来获取数据，</li>
<li>  数据分布在各个节点之中。</li>
</ul>
<p><img src="/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/image-20210920161141312.png" alt="image-20210920161141312"></p>
<hr>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><blockquote>
<p>  <strong>【概述】</strong></p>
</blockquote>
<ul>
<li>  <code>B+Tree</code> 是 <code>B-Tree</code> 的改进版本，<strong>数据都在叶子节点上</strong>，并且<strong>增加了顺序访问指针</strong>，每个叶子节点都有指向相邻的叶子节点的指针。</li>
<li>  相比 <code>B-Tree</code> 来说，进行范围查找时只需要查找两个节点，进行遍历即可。而 B-Tree 需要获取所有节点，相比之下 B+Tree 效率更高。</li>
</ul>
<blockquote>
<p>  <strong>【B+Tree性质】</strong></p>
</blockquote>
<ul>
<li>  非叶子节点不用来保存数据而是保存数据的索引。</li>
<li>  所有的叶子结点中包含了 <strong>① 全部关键字的信息，② 及指向含这些关键字记录的指针</strong>，并且叶子结点本身按关键字的大小从小到大顺序链接。</li>
<li>  所有的非叶子结点都起到了索引的作用，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>  B+Tree 中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>  B+Tree 有 2 个头指针，一个是树的根节点，一个是最小叶子节点的头结点。</li>
</ul>
<p><img src="/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/BTree.png" alt="BTree"></p>
<blockquote>
<p>  <strong>【初始化介绍】</strong></p>
</blockquote>
<p>一颗 B+树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含了<strong>数据项</strong>（深蓝色所示）和<strong>指针</strong>（黄色所示）。如磁盘块1 包含数据项 17 和 35，包含指针 P1、P2、P3。</p>
<ul>
<li>  P1 指向数据项小于 17 的磁盘块，P2 指向数据项在17~35 之间的磁盘块，P3 指向数据项大于 35 的磁盘块。</li>
<li>  真实的数据存储在于叶子节点中，即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。</li>
<li>  <strong>非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项</strong>。如 17、35 并不真实存在于数据表中。</li>
</ul>
<blockquote>
<p>  <strong>【查找过程】</strong></p>
</blockquote>
<ol>
<li> 如果要查找数据项 29，那么首先会把磁盘块 1 中的数据加载到内存中，发生第一次 IO，在内存中用二分查找确定 29 在17~35 之间，锁定磁盘块 1 的 P2 指针；</li>
<li> 通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 中的数据加载到内存中，发生第二次 IO，在内存中用二分查找确定 29 在 26~30 之间，锁定磁盘块 3 的 P2 指针；</li>
<li> 加载磁盘块 8 中的数据到内存中，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，总计三次 IO。</li>
</ol>
<blockquote>
<p>  <strong>【小总结】</strong></p>
</blockquote>
<p>在实际生产中，3 层的 BTree 可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。</p>
<hr>
<h3 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h3><blockquote>
<p>  <strong>【原理】</strong></p>
</blockquote>
<p>基于哈希表实现，对于每一行数据，存储引擎都会根据其索引列计算一个哈希值（HashCode），并且将所有的哈希码存储在索引表中，同时在索引表中保存指向每个数据行的指针。</p>
<p><img src="/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/java3-1562726249.jpeg"></p>
<blockquote>
<p>  <strong>【缺点】</strong></p>
</blockquote>
<p>对于 Hash 索引而言，只有精确匹配索引所有列的查询才有效。</p>
<ul>
<li>  这句话的意思是：对于复合索引，包含两个或两个以上的列。比如现在有一个复合索引包含了（id，name，age）三列，而 Hash 索引实现时是把这三列看做一个整体计算出一个 HashCode，所以想要利用 Hash 索引加快查找速度时，必须同时根据这三列算出的 HashCode 才是一个有效的 HashCode，如果仅仅包含了其中的一列或者两列，得到的 HashCode 就是一个非法的 HashCode，最终得到的结果自然也是不正确的。</li>
</ul>
<hr>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul>
<li>  如果索引的字段非常长，这既占内存空间，也不利于维护。如果只把很长字段的前面的公共部分作为一个索引，就变成了一个前缀索引。</li>
</ul>
<hr>
<h1 id="4-语法"><a href="#4-语法" class="headerlink" title="4. 语法"></a>4. 语法</h1><blockquote>
<p>  <strong>语法</strong></p>
</blockquote>
<ol>
<li> 创建：</li>
<li> 删除</li>
<li> 查看表的所有索引</li>
</ol>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="1-创建表时创建索引"><a href="#1-创建表时创建索引" class="headerlink" title="1. 创建表时创建索引"></a>1. 创建表时创建索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_index2 (</span><br><span class="line">  id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  first_name VARCHAR (16),</span><br><span class="line">  last_name VARCHAR (16),</span><br><span class="line">  id_card VARCHAR (18),</span><br><span class="line">  information TEXT,</span><br><span class="line">  KEY NAME (first_name, last_name),	# 复合索引</span><br><span class="line">  FULLTEXT KEY (information),	# 全文索引</span><br><span class="line">  UNIQUE KEY (id_card) # 唯一索引</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="2-对已有的表新增索引"><a href="#2-对已有的表新增索引" class="headerlink" title="2. 对已有的表新增索引"></a>2. 对已有的表新增索引</h3><h4 id="2-1-使用-CREATE-INDEX-命令创建索引"><a href="#2-1-使用-CREATE-INDEX-命令创建索引" class="headerlink" title="2.1 使用 CREATE INDEX 命令创建索引"></a>2.1 使用 CREATE INDEX 命令创建索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 创建：</span><br><span class="line">CREATE [UNIQUE] INDEX [indexName] ON table_name(column1, column2);	# 方式一</span><br></pre></td></tr></table></figure>

<h4 id="2-2-使用-ALTER-TABLE-命令增加索引"><a href="#2-2-使用-ALTER-TABLE-命令增加索引" class="headerlink" title="2.2 使用 ALTER TABLE 命令增加索引"></a>2.2 使用 ALTER TABLE 命令增加索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用 Alter 命令</span><br><span class="line">ALTER TABLE tb_name ADD PRIMARY KEY(column_list);	# 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</span><br><span class="line">ALTER TABLE tb_name ADD INDEX index_name(column_list) # 添加普通索引，索引值可出现多次。</span><br><span class="line">ALTER TABLE tb_name ADD UNIQUE INDEX index_name(column_list) # 添加唯一索引，要求被添加的列必须是唯一的</span><br><span class="line">ALTER TABLE tb_name ADD FULLTEXT index_name (column_list) # 该语句指定了索引为FULLTEXT ，用于全文索引。</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：主键天生就是一种唯一索引**</p>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除</span><br><span class="line">DROP INDEX [indexName] ON table_name;</span><br></pre></td></tr></table></figure>



<h2 id="查看一张表中创建的所有索引"><a href="#查看一张表中创建的所有索引" class="headerlink" title="查看一张表中创建的所有索引"></a>查看一张表中创建的所有索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查看</span><br><span class="line">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>案例</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 假设 name 和 openid 这两个字段在查询时频繁被使用，就可以将其设置为索引来增加查询速度</span><br><span class="line">SELECT * FROM USER WHERE NAME=&quot;&quot; AND openid=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">-- 单值索引</span><br><span class="line">CREATE INDEX idx_user_name ON USER(NAME)</span><br><span class="line"></span><br><span class="line">-- 复合索引</span><br><span class="line">CREATE INDEX idx_user_nameOpenid ON USER(NAME, openid) </span><br></pre></td></tr></table></figure>





<h2 id="查看MySQL语句执行时有没有用到索引"><a href="#查看MySQL语句执行时有没有用到索引" class="headerlink" title="查看MySQL语句执行时有没有用到索引"></a>查看MySQL语句执行时有没有用到索引</h2><ul>
<li>  通过 <strong>explain</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM user_info WHERE user_id = &#x27;1397023890531721218&#x27;;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/image-20210920174400590.png" alt="image-20210920174400590"></p>
<ul>
<li><p><strong>type</strong>：type 字段是判断查询是否高效的重要依据依据。<strong>通过 type 字段，我们可以判断此次查询是 全表扫描 还是 索引扫描</strong>。</p>
<ul>
<li>  <code>const</code>：主键索引或者唯一二级索引进行等值匹配的情况)</li>
<li>  <code>ref</code>：普通的二级索引列与常量进⾏等值匹配；</li>
<li>  <code>index</code>：扫描全表索引的覆盖索引。index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</li>
<li>  <code>ALL</code>：全表扫描。在相同的查询条件下, 它是速度最慢的。</li>
</ul>
<p>  通常来说，不同的 type 类型的性能关系如下：<strong>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</strong></p>
</li>
<li><p>  <strong>possible_key</strong>：查询中可能用到的索引(可以把用不到的删掉，降低优化器的优化时间) 。</p>
</li>
<li><p>  <strong>key</strong>：此字段是 MySQL 在当前查询时所真正使用到的索引。</p>
</li>
</ul>
<hr>
<h1 id="5-索引失效的几种情况"><a href="#5-索引失效的几种情况" class="headerlink" title="5. 索引失效的几种情况"></a>5. 索引失效的几种情况</h1><blockquote>
<ol>
<li> <strong>类型不一致（隐式类型转换）</strong>：</li>
</ol>
</blockquote>
<p>如果索引列出现了隐式类型转换，则 MySQL 不会使⽤索引。常见的情况是在 SQL 的 WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。【数据库中字段设置的为字符串类型，但是在查询的时候 where 语句后面的条件上使用的是数值类型，那么就不会使用索引】</p>
<blockquote>
<ol start="2">
<li> <strong>自动判断</strong>：</li>
</ol>
</blockquote>
<p>如果 MySQL 判断全表扫描⽐使⽤索引查询更快，则不会使⽤索引。</p>
<blockquote>
<ol start="3">
<li> <strong>函数导致索引失效</strong>：</li>
</ol>
</blockquote>
<ul>
<li>  函数导致索引失效的原因是：索引表中保存的数据表中的字段值，如果对索引字段使用函数，在进行检索时，就需要把索引表中的每个索引都进行一遍函数运算，然后再用函数运算得到的结果去与 where 条件比较，显然成本太大，这会导致索引失效。、</li>
<li>  正确的做法是，将函数放在筛选条件上而不是索引列上。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user` WHERE DATE(create_time) = &#x27;2020-09-03&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li> <strong>运算符导致的索引失效</strong>：</li>
</ol>
</blockquote>
<p>原因与函数导致索引失效一样，解决方法是将运算过程放在等号后面的条件上而不是索引列上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user` WHERE age - 1 = 20;	// 索引失效</span><br><span class="line">SELECT * FROM `user` WHERE age = 20+1;	// 解决方法</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="5">
<li> <strong>OR引起的索引失效</strong>：</li>
</ol>
</blockquote>
<p>OR 导致索引并不是一定会发生。如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user` WHERE `name` = &#x27;张三&#x27; OR height = &#x27;175&#x27;;	// 索引失效</span><br><span class="line">SELECT * FROM `user` WHERE `name` = &#x27;张三&#x27; OR name = &#x27;李四&#x27;;	// 索引不失效</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="6">
<li> <strong>模糊搜索导致索引失效</strong>：</li>
</ol>
</blockquote>
<ul>
<li>  模糊搜索导致索引失效也并不是一定会发生的。</li>
<li>  当 <code>%</code> 或者 <code>_</code> 放在匹配字段最前面是不走索引的，放在后面才会走索引。索引设计的时候就是从最左边的字符串开始匹配的，所以如果左边的字符串是确定的，就会走索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user` WHERE `name` LIKE &#x27;%冰&#x27;;	# 不走索引</span><br><span class="line">SELECT * FROM `user` WHERE `name` LIKE &#x27;张%&#x27;;	# 走索引</span><br></pre></td></tr></table></figure>

<ol>
<li></li>
</ol>
<blockquote>
<ol start="7">
<li> <strong>部分范围查询导致索引失效</strong>：</li>
</ol>
</blockquote>
<ul>
<li>  NOT IN、NOT EXISTS 导致索引失效。</li>
<li>  使用 != 或者 &lt;、&gt; 导致索引失效。</li>
<li>  因为使用索引查询的是是什么，而这些查询要求的结果是“不是什么”，</li>
</ul>
<hr>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="1、为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？"><a href="#1、为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？" class="headerlink" title="1、为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？"></a>1、为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</h2><blockquote>
<p>  <strong>B-Tree 的缺点：</strong> </p>
</blockquote>
<ol>
<li> B+Tree 的磁盘读写代价更低。B+Tree 的非叶子节点并没有保存指向关键字具体信息的指针，因此其非叶子节点相对 B-Tree 更小。也就是同一磁盘块能够容纳的节点数量越多，即同一磁盘块盘块所能容纳的关键字数量越多，一次性读入内存的需要查找的关键字也就越多，那么<strong>相对 IO 读写次数就降低了</strong>。</li>
<li> 由于 B+Tree 的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可。但是 B-Tree 因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以 <strong>B+Tree 更加适合区间查询的情况</strong>，所以通常B+树用于数据库索引。</li>
</ol>
<blockquote>
<p>  <strong>Hash 的缺点：</strong></p>
</blockquote>
<ul>
<li>  虽然可以快速定位，但是<strong>没有顺序，不支持排序</strong>；</li>
<li>  适合等值查询，如<code> =、in()、&lt;=&gt;</code>，<strong>不支持范围查询</strong>；因为 Hash 索引中的数据也是无序的，如果想要得到有序结果的话，同样需要全盘扫描。</li>
<li>  因为不是按照索引值顺序存储的，就不能像 <code>B+Tree </code>索引一样利用索引完成排序 ；</li>
<li>  Hash索引在查询等值时非常快 ；</li>
<li>  因为 Hash 索引始终索引的所有列的全部内容，所以<strong>不支持部分索引列的匹配查找</strong> ；</li>
<li>  如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。</li>
</ul>
<blockquote>
<p>  <strong>二叉树缺点：</strong></p>
</blockquote>
<ul>
<li><strong>查找效率不稳定</strong>。二叉树的查找效率跟树的高度有关，并且二叉树不能自平衡，如果出现某些极端数据，可能会导致二叉树的查询效率下降到接近于一个单链表。</li>
</ul>
<blockquote>
<p>  <strong>红黑树缺点：</strong></p>
</blockquote>
<ul>
<li>  树的高度随着数据量增加而增加。</li>
</ul>
<h2 id="2、非聚簇索引一定会回表查询吗？"><a href="#2、非聚簇索引一定会回表查询吗？" class="headerlink" title="2、非聚簇索引一定会回表查询吗？"></a>2、非聚簇索引一定会回表查询吗？</h2><ul>
<li>  不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为”<strong>覆盖索引</strong>“。</li>
<li>  举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行 <code>select score from student where score &gt; 90</code> 的查询时，在索引的叶子节点上，已经包含了score 信息，就不会再次进行回表查询。</li>
</ul>
<h2 id="3、创建索引时需要注意什么？"><a href="#3、创建索引时需要注意什么？" class="headerlink" title="3、创建索引时需要注意什么？"></a>3、创建索引时需要注意什么？</h2><ul>
<li>  <strong>索引字段应该设置非空约束</strong>。索引应该指定列为 NOT NULL，除非你想存储 NULL。在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。在使用时应该用 0 或者 空字符串 或者 其它特殊值代替 NULL。</li>
<li>  <strong>索引字段应该取离散程度高的字段</strong>：如果是单列索引，应该尽量选取离散程度高的字段作为索引。如果是复合索引，应该尽量让离散程度高的索引列放在复合索引的前面。可以通过 <code>count()</code> 函数查看字段的差异值，返回值越大说明字段的唯一值越多，字段的离散程度越高。</li>
</ul>
<h2 id="4、哪些情况下需要创建索引？"><a href="#4、哪些情况下需要创建索引？" class="headerlink" title="4、哪些情况下需要创建索引？"></a>4、哪些情况下需要创建索引？</h2><ol>
<li> <strong>主键</strong>天生就是唯一索引；</li>
<li> <strong>频繁作为查询条件的字段</strong>应该创建索引；</li>
<li> 查询中与其它表关联的字段，<strong>外键</strong>字段应该建立索引；</li>
<li> 查询中<strong>排序的字段</strong>。排序字段若通过索引去访问将大大提高排序速度；</li>
<li> 单键/组合索引的选择问题，<strong>组合索引性价比更高</strong>；</li>
<li> 查询中统计或者分组字段；</li>
</ol>
<h2 id="5、哪些情况不需要创建索引？"><a href="#5、哪些情况不需要创建索引？" class="headerlink" title="5、哪些情况不需要创建索引？"></a>5、哪些情况不需要创建索引？</h2><ol>
<li> 表记录太少；【表记录过少的话遍历查找也能很快就找到所有数据，而为此再专门维护一张索引表是不合适的】</li>
<li> 频繁更新的字段（经常增删改的表或者字段）不适合创建索引；【因为每次更新不单单要更新数据库表记录还会更新索引表记录】</li>
<li> Where 条件里用不到的字段不创建索引（不用做查询条件的字段）</li>
<li> <strong>过滤性不好的不适合建索引。</strong></li>
</ol>
<ul>
<li>假如一个表中有 10w 条记录，有一个字段 gender 只有 0 和 1 两种值，且每个值的分布概率大约为 50%，那么对这种字段建立索引一般不会提高数据库的查询速度。<ul>
<li>  索引的选择是指索引列中不同值的数量与表中记录数的比。如果一个表中有 2000 条记录，表索引列有 1980 个不同的值，那么这个索引的选择性就接近于 1，这个索引的效率越高。</li>
</ul>
</li>
</ul>
<h2 id="6、建索引的原则有哪些？"><a href="#6、建索引的原则有哪些？" class="headerlink" title="6、建索引的原则有哪些？"></a>6、建索引的原则有哪些？</h2><blockquote>
<ol>
<li> <strong>最左前缀匹配原则</strong></li>
</ol>
</blockquote>
<p>MySQL 会一直向右匹配直到遇到<strong>范围查询</strong><code>（&gt;、&lt;、between、like）</code>就停止匹配，比如 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立<code>(a,b,c,d)</code> 顺序的索引，d 是用不到索引的，如果建立 <code>(a,b,d,c)</code> 的索引则都可以用到，<code>a,b,d</code> 的顺序可以任意调整。</p>
<blockquote>
<ol start="2">
<li> <strong>= 和 in 可以乱序</strong></li>
</ol>
</blockquote>
<p>比如 <code>a = 1 and b = 2 and c = 3</code> 建立 <code>(a,b,c)</code> 索引可以任意顺序，MySQL 的查询优化器会帮你优化成索引可以识别的形式。</p>
<blockquote>
<ol start="3">
<li> <strong>尽量选择离散度高的列作为索引</strong></li>
</ol>
</blockquote>
<p>计算离散度的公式是 <code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的离散度是1，而一些状态、性别字段可能在海量数据面前区分度接近于 0。一般情况下索引字段的离散度应该在 0.1 以上，即平均 1 条索引扫描10条记录。</p>
<blockquote>
<ol start="4">
<li> <strong>索引列不能参与计算</strong></li>
</ol>
</blockquote>
<p>索引列不能参与计算，保持列“干净”，比如 <code>from_unixtime(create_time) = ’2014-05-29’</code> 就没有使用到索引，原因很简单，b+Tree 中存的都是数据表中的字段值，但进行检索时，需要把所有元素都用函数计算后才能比较，显然成本太大。所以语句应该写成 <code>create_time = unix_timestamp(’2014-05-29’)</code>。</p>
<blockquote>
<ol start="5">
<li> <strong>尽量扩展已有的索引，不要新建索引。</strong></li>
</ol>
</blockquote>
<p>比如表中已经有 a 的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可。</p>
<h2 id="7、使用索引查询一定能提高查询的性能吗？"><a href="#7、使用索引查询一定能提高查询的性能吗？" class="headerlink" title="7、使用索引查询一定能提高查询的性能吗？"></a>7、使用索引查询一定能提高查询的性能吗？</h2><ul>
<li>  通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</li>
<li>  索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出 4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。</li>
</ul>
<hr>
<h2 id="8、联合索引及最左匹配原则"><a href="#8、联合索引及最左匹配原则" class="headerlink" title="8、联合索引及最左匹配原则"></a>8、联合索引及最左匹配原则</h2><p>MySQL 可以使用多个字段同时建立一个索引，叫复合索引。但是在使用复合索引的时候，需要注意<strong>最左匹配原则</strong>。比如：</p>
<p>假设现在建立了 <code>idx_test(id, name, age)</code> 的复合索引，那么索引的排序为：先按照 id 排序，如果 id 相同，则按照 name 排序，如果 name 也相同，则按照 age 进行排序。</p>
<p>当进行查询时，此时索引仅仅按照 id 严格有序，因此必须首先使用 id 字段进行等值查询，之后对于匹配到的列而言，此时可以使用 name 字段用作索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁的列放在前面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、where id=5 and name=&#x27;zs&#x27; and age=23; 	# 可以走索引idx_test</span><br><span class="line">2、where name=&#x27;zs&#x27; and id=5 and age=23; 	# 可以走索引idx_test【MySQL底层默认的优化策略】</span><br><span class="line">3、where id=5 and name=&#x27;zs&#x27;;	# 可以走索引</span><br><span class="line">4、where id=5 and age=23;	# 可以走索引</span><br><span class="line">5、where id=5;	 # 可以走索引</span><br><span class="line">6、where name=&#x27;zs&#x27;;	# 不走索引</span><br><span class="line">7、where age=23;		# 不走索引</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>  如果条件里含有联合索引的第一个字段，那么不管 where 条件的顺序和个数，这次查询都会走索引。</li>
<li>  联合索引的使用和 and 条件的顺序无关。</li>
<li>  只要列中包含有 NULL 值都将不会被包含在索引中，复合索引只要有一列含有 NULL 值，那么这一列对于复合索引就是无效的。</li>
</ul>
<p><strong>联合索引的好处：</strong></p>
<ol>
<li> <strong>减少了建立索引的开销</strong>。建立一个 <code>(a,b,c)</code> 的复合索引，实际上等于建立了 <code>(a)，(a,b)，(a,b,c)</code> 三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销，对于大量数据的表，这是一笔不小的开销。</li>
<li> <strong>覆盖索引</strong>。对于复合索引 <code>(a,b,c)</code>，如果有如下的 <code>select a,b,c from table where a=1</code>，那么 MySQL 可以直接通过遍历索引取得数据，而无需会标。这将减少很多 IO 操作。</li>
<li> <strong>缩小筛选范围</strong>。对于 1000W 条数据的表，如果有如下 <code>select * from table where a=1 and b=2 and c=3</code>，假设每个条件可以筛选出 10% 的数据，如果只有单值索引，那么通过该索引只能筛选出 1000W*10%=100W 条数据，然后再回表从 100W 条数据中找到符合 <code>b=2 and c=3</code> 的数据，然后再排序、再分页。如果是复合索引，通过索引就可以筛选出 <code>1000W * 10% * 10% * 10% = 1W</code>，然后再回表查询这 1W 条数据即可。</li>
</ol>
<hr>
<h2 id="10、主键设计-UUID-和-自增主键的区别"><a href="#10、主键设计-UUID-和-自增主键的区别" class="headerlink" title="10、主键设计 UUID 和 自增主键的区别"></a>10、主键设计 UUID 和 自增主键的区别</h2><ul>
<li>  自增主键，在进行数据库插入时，位置相对固定（B+树的右下角），数据插入效率要高一些，能更好的支持区间查找</li>
<li>  UUID：由于 UUID 是随机生成的，插入时位置具有不确定性，插入效率要低一些。区间查找也没有自增主键性能优越。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/21/%E6%A0%91/" rel="prev" title="树">
                  <i class="fa fa-chevron-left"></i> 树
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/" rel="next" title="MySQL高级">
                  MySQL高级 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
