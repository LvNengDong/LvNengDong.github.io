<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Spring TX；Spring事务管理  Spring TX 概要   Spring 事务管理也是 AOP 的一种实现。   事务管理是一个通用的功能，可以将这个功能抽取出来，形成一个通知类（增强类）。   此时，我们就可以在程序中的任何地方将这个通知织入进去，形成切面。此时，切入点方法就已经被我们的事务管理器管理了。  基于 XML 配置文件的事务管理1    创建事务管理器 Sprin">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring——TX">
<meta property="og:url" content="http://example.com/2021/07/20/Spring%E2%80%94%E2%80%94TX/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Spring TX；Spring事务管理  Spring TX 概要   Spring 事务管理也是 AOP 的一种实现。   事务管理是一个通用的功能，可以将这个功能抽取出来，形成一个通知类（增强类）。   此时，我们就可以在程序中的任何地方将这个通知织入进去，形成切面。此时，切入点方法就已经被我们的事务管理器管理了。  基于 XML 配置文件的事务管理1    创建事务管理器 Sprin">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/07/20/Spring%E2%80%94%E2%80%94TX/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.png">
<meta property="article:published_time" content="2021-07-20T14:27:08.000Z">
<meta property="article:modified_time" content="2021-10-04T16:18:45.420Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/07/20/Spring%E2%80%94%E2%80%94TX/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.png">


<link rel="canonical" href="http://example.com/2021/07/20/Spring%E2%80%94%E2%80%94TX/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/07/20/Spring%E2%80%94%E2%80%94TX/","path":"2021/07/20/Spring——TX/","title":"Spring——TX"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring——TX | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-TX-%E6%A6%82%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">Spring TX 概要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-XML-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">基于 XML 配置文件的事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">1    创建事务管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%85%8D%E7%BD%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E9%80%9A%E7%9F%A5%EF%BC%88%E5%A2%9E%E5%BC%BA%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">2    配置事务管理器的通知（增强）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%85%8D%E7%BD%AE%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9A-lt-tx-attributes-gt"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1    配置事务的属性：&lt;tx:attributes&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-lt-tx-method-gt"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">2.1.1    &lt;tx:method&gt;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%85%8D%E7%BD%AE-AOP-%E5%88%87%E9%9D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">3    配置 AOP 切面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">4    总结（重要）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">2.5.</span> <span class="nav-text">5    完整代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">基于注解的事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.</span> <span class="nav-text">1    创建事务管理器对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BC%80%E5%90%AF-Spring-%E5%AF%B9%E6%B3%A8%E8%A7%A3%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">3.2.</span> <span class="nav-text">2    在配置文件中开启 Spring 对注解事务的支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%9C%A8%E4%B8%9A%E5%8A%A1%E5%B1%82%E4%BD%BF%E7%94%A8-Transactional-%E6%B3%A8%E8%A7%A3"><span class="nav-number">3.3.</span> <span class="nav-text">3    在业务层使用 @Transactional 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Transactional-%E6%B3%A8%E8%A7%A3"><span class="nav-number">3.3.1.</span> <span class="nav-text">@Transactional 注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-number">4.</span> <span class="nav-text">事务的传播行为</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">1    是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">2    怎么用？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.1.</span> <span class="nav-text">2.1    XML配置文件中使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%B3%A8%E8%A7%A3%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.2    注解中使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Demo"><span class="nav-number">4.3.</span> <span class="nav-text">3    Demo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">5.1.</span> <span class="nav-text">0    前置知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">1    怎么用？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%9C%A8-xml-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">5.2.1.</span> <span class="nav-text">1.1    在 xml 配置文件中设置隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%9C%A8%E6%B3%A8%E8%A7%A3%E4%B8%AD%E8%AE%BE%E7%BD%AE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">5.2.2.</span> <span class="nav-text">1.2    在注解中设置隔离级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Spring-%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">2    Spring 中事务的隔离级别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="nav-number">6.</span> <span class="nav-text">事务失效</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF"><span class="nav-number">6.1.</span> <span class="nav-text">Spring 事务失效的几种场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8A%9B%E5%87%BA%E7%BC%96%E8%AF%91%E6%9C%9F%E5%BC%82%E5%B8%B8%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E5%9B%9E%E6%BB%9A"><span class="nav-number">6.1.1.</span> <span class="nav-text">1    抛出编译期异常导致事务不能正常回滚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E8%87%AA%E5%B7%B1%E5%90%9E%E4%BA%86%E5%BC%82%E5%B8%B8%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E4%B8%8D%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%9B%9E%E6%BB%9A"><span class="nav-number">6.1.2.</span> <span class="nav-text">2    目标方法自己吞了异常导致事务不能正确回滚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-AOP-%E5%88%87%E9%9D%A2%E9%A1%BA%E5%BA%8F%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E4%B8%8D%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%9B%9E%E6%BB%9A"><span class="nav-number">6.1.3.</span> <span class="nav-text">3    AOP 切面顺序导致事务不能正确回滚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%9D%9Epublic%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="nav-number">6.1.4.</span> <span class="nav-text">4    非public方法导致事务失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-final-public-%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="nav-number">6.1.5.</span> <span class="nav-text">5    final&#x2F;public 方法导致事务失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="nav-number">6.1.6.</span> <span class="nav-text">6    父子容器导致事务失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%9C%AC%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="nav-number">6.1.7.</span> <span class="nav-text">6    本类方法调用导致事务失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E5%8A%A0%E9%94%81%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="nav-number">6.1.8.</span> <span class="nav-text">7    多线程下加锁位置不当导致事务失效</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/20/Spring%E2%80%94%E2%80%94TX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring——TX | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring——TX
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-20 22:27:08" itemprop="dateCreated datePublished" datetime="2021-07-20T22:27:08+08:00">2021-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-05 00:18:45" itemprop="dateModified" datetime="2021-10-05T00:18:45+08:00">2021-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>  <strong>Spring TX；Spring事务管理</strong></p>
</blockquote>
<h1 id="Spring-TX-概要"><a href="#Spring-TX-概要" class="headerlink" title="Spring TX 概要"></a>Spring TX 概要</h1><ul>
<li>  Spring 事务管理也是 AOP 的一种实现。</li>
<li>  事务管理是一个通用的功能，可以将这个功能抽取出来，形成一个通知类（增强类）。</li>
<li>  此时，我们就可以在程序中的任何地方将这个<strong>通知</strong>织入进去，形成切面。此时，切入点方法就已经被我们的事务管理器管理了。</li>
</ul>
<h1 id="基于-XML-配置文件的事务管理"><a href="#基于-XML-配置文件的事务管理" class="headerlink" title="基于 XML 配置文件的事务管理"></a>基于 XML 配置文件的事务管理</h1><h2 id="1-创建事务管理器"><a href="#1-创建事务管理器" class="headerlink" title="1    创建事务管理器"></a>1    创建事务管理器</h2><ul>
<li>Spring 框架为我们提供了管理事务的对象 <strong>DataSourceTransactionManager</strong>，这个对象中集成了事务的<strong>开启、提交、回滚、关闭</strong>等操作。</li>
<li>使用前需要先将 <code>DataSourceTransactionManager</code> 对象添加到 IoC 容器中。</li>
<li><code>DataSourceTransactionManager</code> 对象依赖于 <code>DataSource</code> 对象。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------配置事务管理器对象-----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> 	 <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-配置事务管理器的通知（增强）"><a href="#2-配置事务管理器的通知（增强）" class="headerlink" title="2    配置事务管理器的通知（增强）"></a>2    配置事务管理器的通知（增强）</h2><ul>
<li>  事务管理器的通知和普通 AOP 中的通知原理是一样的，只不过为了更加语义化，提供了 <code>&lt;tx:advice&gt;</code> 标签来专门定义事务管理器的通知。</li>
<li>  <strong>事务管理器的通知</strong>（简称“事务的通知”）是对事务管理器的增强，增强的方式是动态代理，可以自行选择是否需要增强。</li>
<li>  事务的通知的主要作用就是在通知中动态地给事务管理器添加一些额外的功能。比如：可以在事务的通知中定义<strong>事务的属性</strong>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------配置事务的通知-----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务的通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-1-配置事务的属性：-lt-tx-attributes-gt"><a href="#2-1-配置事务的属性：-lt-tx-attributes-gt" class="headerlink" title="2.1    配置事务的属性：&lt;tx:attributes&gt;"></a>2.1    配置事务的属性：<code>&lt;tx:attributes&gt;</code></h3><p>事务的属性被配置在事务的通知中，被 <code>&lt;tx:attributes&gt;</code> 标签包裹。</p>
<h4 id="2-1-1-lt-tx-method-gt"><a href="#2-1-1-lt-tx-method-gt" class="headerlink" title="2.1.1    &lt;tx:method&gt;"></a>2.1.1    <code>&lt;tx:method&gt;</code></h4><p><code>&lt;tx:method&gt;</code> 标签主要用于管理指定的方法。包含如下属性：</p>
<ul>
<li>  <strong>name</strong>：指定要被事务管理的方法的方法名，可以模糊指定或精确指定。【优先级：精准匹配&gt;部分匹配&gt;完全模糊匹配】</li>
<li>  <strong>isolation</strong>：用于指定<strong>事务的隔离级别</strong>。默认值是 Default，表示使用数据库的默认隔离级别。【MySQL 和 Oracle 不同】</li>
<li>  <strong>propagation</strong>：用于指定<strong>事务的传播行为</strong>。默认值是 REQUIRED。</li>
<li>  <strong>read-only</strong>：用于指定事务是否只读。只有查询方法才能设置事务为 true。默认值是false，表示读写。</li>
<li>  <strong>timeout</strong>：用于指定事务的超时时间。默认值是-1，表示永不超时，如果指定了数值，以秒为单位。</li>
<li>  <strong>rollback-for</strong>：用于指定一个异常，当产生该异常时，事务回滚，当产生其它异常时，事务不会滚。没有默认值，表示任何异常都会滚。</li>
<li>  <strong>no-rollback-for</strong>：用于指定一个异常，当产生该异常时，事务不回滚。产生其它异常时，事务回滚，没有默认值，表示任何异常都回滚。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------配置事务的属性-----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务的通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="3-配置-AOP-切面"><a href="#3-配置-AOP-切面" class="headerlink" title="3    配置 AOP 切面"></a>3    配置 AOP 切面</h2><ol>
<li> <strong>找到切入点</strong>：即要对哪个（些）方法施加配置好的事务。</li>
<li> 将事务的<strong>通知织入到切入点</strong>，形成切面</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.xsyu.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将事务通知织入到切入点，形成切面[事务中特有的切面：切入点+通知]--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Tip：</strong></p>
<ul>
<li>  一般情况下，AOP 中的切面使用 <code>&lt;aop:aspect&gt;</code> 标签；</li>
<li>  而在事务管理中，AOP 切面则使用语义化更加明确的 <code>&lt;aop:advisor&gt;</code> 标签。</li>
</ul>
<h2 id="4-总结（重要）"><a href="#4-总结（重要）" class="headerlink" title="4    总结（重要）"></a>4    总结（重要）</h2><ul>
<li>为了保证代码的可读性和易维护性，我们在 Service 层编写的对数据库的操作都是屏蔽了事务操作的、简单易懂的代码。</li>
<li>而把对事务的控制交给了 Spring 的 AOP 去控制。[等价于使用代理对象]<ul>
<li>所以 Spring 配置文件中的切入点就是 Service 层中实现类，再通过事务的属性 <code>&lt;tx:method name=&quot;&quot;&gt;</code> 定位到实现类中的具体方法，给对应的方法添加配置文件中配置好的事务；</li>
</ul>
</li>
</ul>
<p>所以只要将 <strong>事务的通知</strong> 织入到 <strong>切入点</strong> 中，就可以完成事务的控制。【把事务的通知织入切入点 就是 把事务相关的方法插入到业务方法中执行 的意思。】</p>
<h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5    完整代码"></a>5    完整代码</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Spring中基于XML的声明式事务管理器</span></span><br><span class="line"><span class="comment">            1. 创建事务管理器对象</span></span><br><span class="line"><span class="comment">            2. 配置事务管理器的通知（增强）[需要导入事务的约束]</span></span><br><span class="line"><span class="comment">                * id：事务通知的唯一标识</span></span><br><span class="line"><span class="comment">                * transaction-manager：事务管理器的引用</span></span><br><span class="line"><span class="comment">			 2.1 配置事务的属性</span></span><br><span class="line"><span class="comment">				* 在事务的通知&lt;tx:advice&gt;标签内部</span></span><br><span class="line"><span class="comment">            3.选择AOP中的事务通知的切入点</span></span><br><span class="line"><span class="comment">            4.把增强后的事务管理器织入切入点形成切面</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--创建事务管理器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器的通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--配置事务的属性（通知的具体内容）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置AOP切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.xsyu.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--把增强后的事务管理器对象织入切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/20/Spring%E2%80%94%E2%80%94TX/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">	1. 事务管理器对象 tx_id 封装了事务的基本操作；</span><br><span class="line">	2. 事务的通知 txAdice_id 在事务管理器对象的基础上，额外扩展了事务的属性相关的操作。</span><br><span class="line">	3. 配置切入点表达式 选择要增强的方法/方法集合；</span><br><span class="line">	4. 配置切面, 将 `通知` 织入到 `切入点表达式` 之中。</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="基于注解的事务管理"><a href="#基于注解的事务管理" class="headerlink" title="基于注解的事务管理"></a>基于注解的事务管理</h1><h2 id="1-创建事务管理器对象"><a href="#1-创建事务管理器对象" class="headerlink" title="1    创建事务管理器对象"></a>1    创建事务管理器对象</h2><h2 id="2-在配置文件中开启-Spring-对注解事务的支持"><a href="#2-在配置文件中开启-Spring-对注解事务的支持" class="headerlink" title="2    在配置文件中开启 Spring 对注解事务的支持"></a>2    在配置文件中开启 Spring 对注解事务的支持</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        1.创建事务管理器对象</span></span><br><span class="line"><span class="comment">        2.在配置文件中开启 Spring 对注解事务的支持</span></span><br><span class="line"><span class="comment">        3.在业务层使用 @Transactional 注解</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启Spring对注解事务的支持[使用注解增强service层的代码]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-在业务层使用-Transactional-注解"><a href="#3-在业务层使用-Transactional-注解" class="headerlink" title="3    在业务层使用 @Transactional 注解"></a>3    在业务层使用 @Transactional 注解</h2><h3 id="Transactional-注解"><a href="#Transactional-注解" class="headerlink" title="@Transactional 注解"></a>@Transactional 注解</h3><p><strong>作用</strong>：该注解的属性与 XML 配置文件中的事务属性的含义一致。</p>
<p><strong>作用范围</strong>：该注解可以在<strong>接口上</strong>、<strong>类上</strong>和<strong>方法上</strong>使用。</p>
<ul>
<li>在接口上使用，表示该接口的所有实现类都使用该事务；</li>
<li>在类上使用，表示该类中的所有方法都使用该事务；</li>
<li>在方法上使用，表示该方法使用该事务。</li>
<li>以上 3 个位置的优先级：<strong>方法&gt; 类&gt; 接口</strong>。即如果类上声明了事务A，类中的方法上声明了事务B，则该方法以事务B为主。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true, propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DI</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false, propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false, propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false, propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        accountDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target    转入账户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source    转出账户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money     交易金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false, propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transaction</span><span class="params">(Integer target, Integer source, Double money)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 事务开始</span></span><br><span class="line">            <span class="type">Account</span> <span class="variable">sourceAccount</span> <span class="operator">=</span> accountDao.findById(source);</span><br><span class="line">            <span class="type">Account</span> <span class="variable">targetAccount</span> <span class="operator">=</span> accountDao.findById(target);</span><br><span class="line">            sourceAccount.setMoney(sourceAccount.getMoney()-money);</span><br><span class="line">            targetAccount.setMoney(targetAccount.getMoney()+money);</span><br><span class="line">            accountDao.update(sourceAccount);</span><br><span class="line"><span class="comment">//            int i= 1/0;     // 模拟转账过程中出现异常</span></span><br><span class="line">            accountDao.update(targetAccount);</span><br><span class="line">        	<span class="comment">// 事务结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h1><h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1    是什么？"></a>1    是什么？</h2><ul>
<li>  <strong>事务的传播行为</strong>：当一个方法运行在被另一个事务管理的方法中时，必须指定事务该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，在新事务中运行。</li>
<li>  事务的传播行为可以由传播属性 <strong>propagation</strong> 指定。Spring 中定义了 7 种事务传播行为。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">传播属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>REQUIRED</strong>（默认）</td>
<td align="left">如果有事务正在运行，当前方法就在这个事务内运行，否则，就启动一个新的事务，并在新的事务内运行。</td>
</tr>
<tr>
<td align="left"><strong>REQUIRES_NEW</strong></td>
<td align="left">当前方法必须启动新事务，并在它自己的事务（新事务）内运行。如果有事务正在运行，应该将其挂起。</td>
</tr>
<tr>
<td align="left">SUPPORTS</td>
<td align="left">如果有事务正在运行，当前方法就在这个事务内运行；否则它可以不运行在事务中。</td>
</tr>
<tr>
<td align="left">NOT_SUPPORTED</td>
<td align="left">当前方法不应该运行在事务中，如果有运行中的事务，就将其挂起。</td>
</tr>
<tr>
<td align="left">MANDATORY</td>
<td align="left">当前方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常。</td>
</tr>
<tr>
<td align="left">NEVER</td>
<td align="left">当前方法不应该运行在事务中，如果有正在运行的事务，就抛出异常。</td>
</tr>
<tr>
<td align="left">NESTED</td>
<td align="left">如果有事务在运行，当前方法就应该在这个事务的嵌套事务内运行。否则，就启动一个新的事务，<br>并在它自己的事务内运行。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">methodA()&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    methodB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1、REQUIRED	A有则B用A，A无则B用B</span></span><br><span class="line"><span class="comment">// 2、REQUIRES_NEW	无论A有或无，B用自己的</span></span><br><span class="line"><span class="comment">// 3、SUPPORTS	A有则B用A，A无则B不用</span></span><br><span class="line"><span class="comment">// 4、NOT_SUPPORTED	无论A有或无，B都不用</span></span><br><span class="line"><span class="comment">// 5、MANDATORY	A无则抛出异常</span></span><br><span class="line"><span class="comment">// 6、NEVER	A有则抛出异常</span></span><br><span class="line"><span class="comment">// 7、NESTED		A有则B用A，A无则B用B（嵌套事务）</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-怎么用？"><a href="#2-怎么用？" class="headerlink" title="2    怎么用？"></a>2    怎么用？</h2><h3 id="2-1-XML配置文件中使用"><a href="#2-1-XML配置文件中使用" class="headerlink" title="2.1    XML配置文件中使用"></a>2.1    XML配置文件中使用</h3><ul>
<li>  事务的传播属性可以<strong>在 xml 配置文件中配置</strong>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器的增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-注解中使用"><a href="#2-2-注解中使用" class="headerlink" title="2.2    注解中使用"></a>2.2    注解中使用</h3><ul>
<li>  事务的传播属性可以<strong>在 @Transactional 注解的 propagation 属性中定义</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true, propagation = Propagation.SUPPORTS)</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3    Demo"></a>3    Demo</h2><p>我们来模拟一个场景：现在数据库中有 100 本书，每本书 60 元，模拟客户买书，每次只能买一本，每次买书都需要付一次钱，可以买多次。客户共有 100 元，一直买书直到买不起为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>	<span class="comment">// 默认是Required</span></span><br><span class="line"><span class="comment">// @Transactional(propagation=Propagation.REQUIRES_NEW)		</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">       pay();	<span class="comment">// pay 方法被另一个事务管理管理，这就需要判断事务的传递行为</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1、从自己账户余额中扣钱</span></span><br><span class="line">    <span class="comment">// 2、图书库存减一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>假设买书方法 <code>buyBook()</code> 和支付方法 <code>pay()</code> 都使用默认的事务传播行为 <strong>Required</strong>。在这种情况下，内部方法 <code>pay()</code> 和外层方法 <code>buyBook()</code> 用的是同一个事务，这种情况下会发生：多次买书的行为要么全部成功，要么全部失败（事务的原子性）。</p>
<p>  就比如在本例中，第一次买书后，客户余额 -60，库存 -1，<code>pay()</code> 方法正常结束，但是第二次买书时由于余额不足以支付，所以支付失败，这时候需要回滚，由于内层方法和外层方法使用的是同一个事务，所以会直接回滚到库存 100，用户余额 100 的状态。</p>
</li>
<li><p>  如果把事务传播行为改成 <strong>REQUIRES_NEW</strong>，在这种情况下，用户第一次买书后，就已经完成了一次事务，已经将数据库中的数据修改并提交了，即使第二次买书失败，也只会回滚到第二次买书前的状态（事务的隔离性），即库存 99，用户余额 40 的状态。</p>
</li>
</ul>
<hr>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><h2 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0    前置知识"></a>0    前置知识</h2><blockquote>
<p>  <strong>数据库事务并发导致的问题</strong>：</p>
</blockquote>
<ol>
<li>  脏读。事务 A 读到了事务 B 更新但未提交的数据。</li>
<li>  不可重复读。（多次获取）事务两次读到的<strong>数据不一致</strong>。</li>
<li>  幻读。（多次获取）事务两次读到表数据的<strong>数量不一致</strong>。</li>
</ol>
<blockquote>
<p>  <strong>隔离级别</strong></p>
</blockquote>
<ol>
<li>  读未提交。允许事务 A 读取事务 B 未提交的修改。</li>
<li>  读已提交。要求事务 A 只能读取事务 B 已提交的修改。</li>
<li>  可重复读 。确保一个事务可以多次从一个字段中读到相同的值。即事务 A 执行期间禁止其它事务对<strong>这个字段</strong>进行更新。【字段上锁】</li>
<li>  串行化。确保一个事务可以多次从一张表中读到相同数量的行。即在事务 A 执行期间，禁止其它事务对<strong>这张表</strong>进行添加、更新、删除操作。可避免任何并发问题，但性能差。【表上锁】</li>
</ol>
<hr>
<h2 id="1-怎么用？"><a href="#1-怎么用？" class="headerlink" title="1    怎么用？"></a>1    怎么用？</h2><p>在 Spring 中，通过 <strong>isolation</strong> 属性来设置事务的隔离级别。</p>
<h3 id="1-1-在-xml-配置文件中设置隔离级别"><a href="#1-1-在-xml-配置文件中设置隔离级别" class="headerlink" title="1.1    在 xml 配置文件中设置隔离级别"></a>1.1    在 xml 配置文件中设置隔离级别</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置事务的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-在注解中设置隔离级别"><a href="#1-2-在注解中设置隔离级别" class="headerlink" title="1.2    在注解中设置隔离级别"></a>1.2    在注解中设置隔离级别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = xxx, propagation = Propagation.SUPPORTS)</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-Spring-中事务的隔离级别"><a href="#2-Spring-中事务的隔离级别" class="headerlink" title="2    Spring 中事务的隔离级别"></a>2    Spring 中事务的隔离级别</h2><ul>
<li>  Spring 中事务的隔离级别与使用的数据库产品相关联，比如 Oracle 就只支持两种隔离级别，而 MySQL 支持 4 种隔离级别。</li>
<li>  <strong>Spring 中默认使用的是数据库产品默认的隔离级别</strong>。</li>
</ul>
<p>比如：</p>
<ul>
<li>  如果 Spring 连接的数据库产品是 MySQL，则默认的事务隔离级别是：<strong>Isolation.REPEATABLE_READ</strong>，可重复读。MySQL 默认的隔离级别。</li>
<li>  同理可得，<strong>Isolation.READ_COMMITTED</strong>，读已提交。Oracle 默认的隔离级别。</li>
</ul>
<hr>
<h1 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h1><p><strong>什么是事务失效？</strong></p>
<ul>
<li>  数据库事务满足 ACID 四大特性，只要破坏了其中某一特性就可以说事务失效了。</li>
</ul>
<h2 id="Spring-事务失效的几种场景"><a href="#Spring-事务失效的几种场景" class="headerlink" title="Spring 事务失效的几种场景"></a>Spring 事务失效的几种场景</h2><ol>
<li> 抛出编译期异常导致事务不能正常回滚</li>
<li> 目标方法自己吞了异常导致事务不能正确回滚</li>
<li> AOP 切面顺序导致事务不能正确回滚</li>
<li> 非<code>public</code>方法导致事务失效</li>
<li> <code>final/public</code> 方法导致事务失效</li>
<li> 父子容器导致事务失效</li>
<li> 本类方法调用</li>
<li></li>
</ol>
<p><strong>转账场景模拟：</strong></p>
<ul>
<li>  转账操作需要 from 账户余额减少， to 账户余额增加，所以需要用声明式事务将这两个操作管理起来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> accountMapper.findBalanceById(from);  <span class="comment">// from 账户余额</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; amount)   <span class="comment">// 如果余额足够转账</span></span><br><span class="line">    &#123;   </span><br><span class="line">        accountMapper.update(from, -balance);   <span class="comment">// from 账户余额减少</span></span><br><span class="line">        accountMapper.update(to, balance);  <span class="comment">// to 账户余额增加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-抛出编译期异常导致事务不能正常回滚"><a href="#1-抛出编译期异常导致事务不能正常回滚" class="headerlink" title="1    抛出编译期异常导致事务不能正常回滚"></a>1    抛出编译期异常导致事务不能正常回滚</h3><p><strong>事务失效的场景：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> accountMapper.findBalanceById(from);  </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; amount)</span><br><span class="line">    &#123;</span><br><span class="line">        accountMapper.update(from, -balance);   </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);		<span class="comment">// 该行代码会出现编译期异常 【CheckedException】</span></span><br><span class="line">        accountMapper.update(to, balance);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  加了 @Transactional 注解的方法，理论上就加上了事务，当代码中出现异常的时候，要求符合事务的原子性，也就是说由于程序出现异常而终止时，必须对已经完成的操作进行回滚。</li>
<li>  但是在在上述代码片段的第 7 行中，<code>new FileInputStream(&quot;aaa&quot;)</code> 会出现编译期异常，并且在这里我们没有自己处理异常，而是直接将异常抛给了上一层，所以该代码在运行的时候也会由于异常未被处理而终止程序。</li>
<li>  但是从结果来看：from 账户余额会减少，但是 to 账户余额并没有增加。也就是说这里出现了事务失效。</li>
</ul>
<p><strong>事务失效的原因：</strong></p>
<ul>
<li>  Spring 默认只会对出现了 RuntimeException 和 Error 的子类异常进行回滚操作，如果出现的异常是编译期异常，那么当发生异常导致程序中断时，数据是不会回滚的。</li>
</ul>
<p><strong>解决思路：</strong></p>
<ul>
<li>  覆盖 Spring 的默认配置，让 Spring 对所有因异常导致的程序终止都进行回滚操作。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>  配置 <code>@Transactional</code> 注解中的 <code>rollbackFor</code> 属性，显式地声明出现了哪些异常后要进行回滚操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span>	<span class="comment">// 显式声明只要出现了 Exception 的子类异常导致事务中断，都需要进行回滚操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> accountMapper.findBalanceById(from);  </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; amount)   </span><br><span class="line">    &#123;</span><br><span class="line">        accountMapper.update(from, -balance);   </span><br><span class="line">        accountMapper.update(to, balance);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>验证出现非编译异常时事务会发生回滚</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> accountMapper.findBalanceById(from);  </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; amount)   </span><br><span class="line">    &#123;</span><br><span class="line">        accountMapper.update(from, -balance);   </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;   <span class="comment">// 该行代码会发生一个非编译期异常，属于 RuntimeException 的子类异常</span></span><br><span class="line">        accountMapper.update(to, balance);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前方法中，发生了异常导致事务中断，但是对 from 账户进行的余额较少操作发生了回滚，保证了数据库表的一致性。</p>
<hr>
<h3 id="2-目标方法自己吞了异常导致事务不能正确回滚"><a href="#2-目标方法自己吞了异常导致事务不能正确回滚" class="headerlink" title="2    目标方法自己吞了异常导致事务不能正确回滚"></a>2    目标方法自己吞了异常导致事务不能正确回滚</h3><p><strong>事务失效的场景：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> accountMapper.findBalanceById(from);  </span><br><span class="line">    <span class="keyword">if</span> (balance &gt; amount)   </span><br><span class="line">    &#123;</span><br><span class="line">        accountMapper.update(from, -balance);</span><br><span class="line">        <span class="comment">/* 出现了异常，但是在业务方法内部自己通过 try...catch 处理了*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        accountMapper.update(to, balance);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  目标方法内部自己处理了异常（通过 <code>try...catch</code> 代码块）导致事务不能正确回滚。</li>
</ul>
<p><strong>事务失效的原因：</strong></p>
<ul>
<li>  Spring 中的事务是通过 AOP 动态织入的，也就是说，类似于 <code>commit、rollback</code> 等操作不是在目标方法内执行的，而是在目标方法代理对象中的同名方法中执行的。当发生了异常后，如果我们在目标方法中自己处理掉了异常，那么在同名的代理方法中，就会认为目标方法是没有发生异常的，自然也就不会触发异常回滚操作了。</li>
<li>  在业务层通过 @Autowired 注解得到的某个实例对象（比如 bean）其实是一个代理对象，在调用 <strong>bean.transfer</strong> 方法时，调用的是代理对象的 <code>transfer</code> 方法，代理对象的 <code>transfer</code> 方法中存在各种通知通知（前置/后置/环绕/异常通知），最内层的核心方法才会调用目标对象的 <strong>transfer</strong> 方法。也就是说，如果我们在目标对象的业务逻辑中直接将异常捕获并处理了，那么在代理对象的角度看来，目标对象的 <code>transfer</code> 方法是没有抛出异常的，自然也就不会对事务进行回滚了。</li>
</ul>
<p><strong>解决思路：</strong></p>
<ul>
<li>  既然在代理对象必须先发生异常然后才能进行回滚，那么我们只需要直接将目标对象的异常向上抛出给代理对象就可以了。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>  可以自行选择是否在目标方法中处理异常，但是如果自己处理了异常，还需要向上层代理对象抛出这个异常信息，目的就是让代理对象也能感知到出现了异常，以便于进行回滚。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> accountMapper.findBalanceById(from);</span><br><span class="line">    <span class="keyword">if</span> (balance &gt; amount)</span><br><span class="line">    &#123;</span><br><span class="line">        accountMapper.update(from, -balance);</span><br><span class="line">        <span class="comment">/* 出现了异常，但是在业务方法内部自己通过 try...catch 处理了*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  <span class="comment">// 在处理了异常的基础上继续向上层抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        accountMapper.update(to, balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="3-AOP-切面顺序导致事务不能正确回滚"><a href="#3-AOP-切面顺序导致事务不能正确回滚" class="headerlink" title="3    AOP 切面顺序导致事务不能正确回滚"></a>3    AOP 切面顺序导致事务不能正确回滚</h3><p><strong>事务失效的原因：</strong></p>
<p>对于配置了多层 AOP 切面的方法，比如 <code>transfer</code> 方法有两层切面，最外层是一个事务通知的切面，内层是一个自定义的日志切面，最内层才会执行目标对象的 <strong>transfer</strong> 方法。假设 <code>transfer</code> 方法抛出异常，首先会被日志切面接收，如果日志切面自己处理了异常且没有将异常继续向上层抛出，那么在事务通知切面看来，程序是正常执行的，自然也就不会对事务进行回滚了。</p>
<p><strong>解决思路：</strong></p>
<ul>
<li>  让事务切面可以感知到发生了异常。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li> 同情况 2，可以在处理了异常的情况下，继续向上层切面抛出异常。</li>
<li> 可以通过 <strong>@Order</strong> 注解调整切面的优先级，让事务切面成为紧挨着目标对象的切面，这样目标对象一旦抛出异常就能第一时间被事务切面捕捉到，当事务切面捕捉到发生了异常后就会执行回滚操作。</li>
</ol>
<hr>
<h3 id="4-非public方法导致事务失效"><a href="#4-非public方法导致事务失效" class="headerlink" title="4    非public方法导致事务失效"></a>4    非<code>public</code>方法导致事务失效</h3><p><strong>事务失效的场景：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="comment">/*public*/</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> accountMapper.findBalanceById(from);</span><br><span class="line">    <span class="keyword">if</span> (balance &gt; amount)</span><br><span class="line">    &#123;</span><br><span class="line">        accountMapper.update(from, -balance);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;	<span class="comment">// 模拟异常</span></span><br><span class="line">        accountMapper.update(to, balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>事务失效的原因：</strong></p>
<ul>
<li>  Spring 默认要求被代理的方法必须是 <strong>public</strong> 修饰的。</li>
<li>  而 @Transactional 底层的实现原理就是为目标方法创建一个代理对象以及代理方法，如果目标方法的权限修饰符是非 <code>public</code> 的，创建代理方法就会失败，也就等于 @Transactional 注解失效了，自然事务也就会失效了。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li> 将方法改为 public</li>
<li> 覆盖 Spring 的默认配置，让 <strong>非public</strong> 方法也能被代理。</li>
</ol>
<hr>
<h3 id="5-final-public-方法导致事务失效"><a href="#5-final-public-方法导致事务失效" class="headerlink" title="5    final/public 方法导致事务失效"></a>5    <code>final/public</code> 方法导致事务失效</h3><p><strong>事务失效的原因：</strong></p>
<ul>
<li>  Spring 事务底层是通过 AOP 实现的，也就是通过  JDK 动态代理或 cglib，帮助我们生成了代理类，在代理类中实现事务的功能。</li>
<li>  但是如果某个方法被 final 修饰了，那么在它的代理类中，就无法重写该方法，也就无法再代理方法中添加事务的功能。</li>
<li>  同样，如果某个方法是 static 的，同样无法通过动态代理，变成事务方法。</li>
</ul>
<hr>
<h3 id="6-父子容器导致事务失效"><a href="#6-父子容器导致事务失效" class="headerlink" title="6    父子容器导致事务失效"></a>6    父子容器导致事务失效</h3><p><strong>事务失效的原因：</strong></p>
<ul>
<li>  子容器扫描范围过大，把未加事务配置的 service 扫描进来。</li>
<li>  如果一个 Spring 程序中含有多个容器（以两个为例），且这两个容器间建立了父子关系。</li>
<li>  在发生依赖注入时，对于子容器，子容器首先从自身寻找要注入的对象，如果在自己的容器中找不到，再继续去父容器中寻找。</li>
</ul>
<blockquote>
<p>  举个例子：</p>
<ul>
<li>  在 Spring 中，如果想要让事务生效必须在配置类上使用 <strong>@EnableTransactionManagement</strong> 开始声明式事务，并且会在配置 类上规定包扫描的范围，这个范围也就是声明式事务起作用的范围。</li>
<li>  一般我们对于事务的处理都放在 Service 层进行，假设现在将 Service 层中的所有对象加入到父容器中。</li>
<li>  再创建一个子容器，子容器的扫描范围包括 Controller 层、Service 层和 Mapper 层（大于父容器），并且没有在子容器中使用声明式事务。</li>
<li>  当我们在 Controller 注入 Service 层的对象时，由于子容器中能够找到 Service 层的对象，因此它就不会去父容器中寻找了，但是子容器中的所有 Service 层的对象，都是没有声明事务的，那么用这些对象去调用带有 @Transactional 注解的方法，也不会产生事务 。</li>
</ul>
</blockquote>
<p><strong>解决方案：</strong></p>
<ol>
<li> 控制字容器的扫描范围，与父容器各自分工扫描，不要图简便将子容器范围扩大。</li>
<li> 不要用父子容器，所有的 bean 都放在同一容器。</li>
</ol>
<h3 id="6-本类方法调用导致事务失效"><a href="#6-本类方法调用导致事务失效" class="headerlink" title="6    本类方法调用导致事务失效"></a>6    本类方法调用导致事务失效</h3><p><strong>事务失效的场景：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  在方法 A 中调用了方法 B，方法 A 的传播行为是 REQUIRED，即 A 中的 B 方法如果没有事务，则复用 A 的事务，如果 B 有自己的事务，则将 A 的事务挂起。</li>
<li>  现在 B 方法的使用的事务传播行为是 REQUIRES_NEW，即 B 方法会创建自己的事务。所以，理论上当调用 A 方法时，必须创建两个事务。</li>
<li>  但是在执行过程中，只有 A 方法的事务创建成功了，B 方法没有执行事务的创建。也就是说 <strong>B 方法上的事务失效了</strong>。</li>
</ul>
<p><strong>事务失效的原因：</strong></p>
<ul>
<li>  本类方法调用不经过代理，因此无法增强。</li>
<li>  事务失效的原因在于动态代理未生效。@Transactional 注解的实现原理是通过动态代理的动态织入让普通的方法具备事务的增强功能，我们通过 @Autowired 注解得到的可以调用 A 方法的对象就是一个代理对象，但是由于方法 A 和方法 B 位于同一个类中，在 A 方法中直接通过 <code>this.B()</code> 调用 B 方法是一种直接调用，this 对象是一个原始对象而不是代理对象，并没有经过对应的增强，自然也就不会创建新的事务了。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>解决思路：不要让 this 对象来调用 B 方法，而是让代理对象来调用 B 方法。<ul>
<li>  方案1：用 @Autowired 注入自身的代理对象，用代理对象代替 this 对象调用 B 方法。</li>
<li>  方案2：通过  AopContext 获取当前类的代理对象，用代理对象代替 this 对象调用 B 方法。 </li>
</ul>
</li>
</ul>
<blockquote>
<p>  方案 1 实现：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span></span><br><span class="line">    &#123;   </span><br><span class="line"><span class="comment">//        this.B();</span></span><br><span class="line">        proxy.B();  <span class="comment">// 用代理对象代替 this 对象</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass());</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  方法 2 实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        this.B();</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">proxy</span> <span class="operator">=</span> (Service) AopContext.currentProxy();    <span class="comment">// 通过 AopContext 获取代理对象</span></span><br><span class="line">        proxy.B();  <span class="comment">// 用代理对象代替 this 对象</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass());</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-多线程下加锁位置不当导致事务失效"><a href="#7-多线程下加锁位置不当导致事务失效" class="headerlink" title="7    多线程下加锁位置不当导致事务失效"></a>7    多线程下加锁位置不当导致事务失效</h3><p><strong>事务失效的场景：</strong></p>
<p>在转账操作中，如果有多个线程同时运行 transfer 方法，由于 transfer 方法是没有任何同步措施的，所以可能会出现多个线程同时转走了from 账户内的余额，导致 from 账户余额为负数的情况。</p>
<p>假设 from 账户现有 1000 元，线程 A 和 B 同时执行把这 1000 元转账到 to 账户的操作。</p>
<ol>
<li> A 线程先查询账户余额，得到 from 账户余额为 1000 元，满足转账条件；</li>
<li> 此时 A 线程挂起，B 线程也查询账户余额，得到 from 账户余额为 1000 元，也满足转账条件；</li>
<li> 这时候 A 和 B 线程就都会执行转账操作，最终导致 from 账户余额为负数，这在业务上显然是不允许的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> accountMapper.findBalanceById(from);  </span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= amount)   </span><br><span class="line">    &#123;   </span><br><span class="line">        accountMapper.update(from, -balance);   </span><br><span class="line">        accountMapper.update(to, balance);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下我们会选择加锁的方式来解决这个问题。但是加锁的位置必须要注意，如果加锁的位置不当，就有可能会导致事务失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>	<span class="comment">// 在目标对象的方法上加锁</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> accountMapper.findBalanceById(from);  </span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= amount)   </span><br><span class="line">    &#123;   </span><br><span class="line">        accountMapper.update(from, -balance);   </span><br><span class="line">        accountMapper.update(to, balance);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在目标方法上加锁会导致事务失效。</p>
<p><strong>失效原因</strong></p>
<ul>
<li>  synchronized 方法保证的仅仅是目标方法的原子性，但是真正执行事务逻辑的代码都在代理对象中，比如 commit 等操作，它们并未处于 sync 代码块内</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>  方案一：synchronized 范围扩大至代理方法调用。也就是让 synchronized 同步代码块直接锁住代理对象，而不是只锁住目标对象中的目标方法。</li>
<li>  方案二：使用 MySQL 自身的锁机制。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/19/UML/" rel="prev" title="UML">
                  <i class="fa fa-chevron-left"></i> UML
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/20/Spring%E2%80%94%E2%80%94AOP/" rel="next" title="Spring——AOP">
                  Spring——AOP <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
