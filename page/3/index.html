<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">Vue组件化开发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-24 20:45:27" itemprop="dateCreated datePublished" datetime="2022-03-24T20:45:27+08:00">2022-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-25 13:52:30" itemprop="dateModified" datetime="2022-03-25T13:52:30+08:00">2022-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  前置知识链接：</p>
</blockquote>
<p>在大型应用开发的时候，页面需要划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。</p>
<p>组件化就是把页面中可以复用的部分抽取成成独立的组件，然后在不同的地方<strong>复用</strong>这些组件，减少了开发成本！</p>
<p>其实 Vue 应用就是一个组件，这也是它被称为 SPA 的由来，只不过这个组件底下又有很多层很多个子组件。</p>
<p>组件本质上也是一个 Vue 实例，因此它在创建时也需要定义 data、methods、生命周期函数等。</p>
<p>不同的是组件不会与某个页面的元素绑定，否则就无法复用了，因此没有 el 属性。</p>
<p>但是组件又是一个页面的一部分，即组件也是由静态 HTML 和 Vue 实例共同组成的，所以增加了 template 属性，它的值就是一段 HTML 代码。</p>
<h2 id="1-全局组件"><a href="#1-全局组件" class="headerlink" title="1 全局组件"></a>1 全局组件</h2><p>全局组件是一个创建后可悲任何 vue 实例都直接调用的组件。它是通过 <code>Vue.component()</code> 方法创建的。具体代码如下：</p>
<ul>
<li>  <strong>在组件中，data 必须是一个函数，不再是一个对象。</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用定义好的全局组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aaa</span>&gt;</span><span class="tag">&lt;/<span class="name">aaa</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/vue/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 定义一个全局组件。两个参数：1，组件名称。2，组件参数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;aaa&quot;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>:<span class="string">&#x27;&lt;button v-on:click=&quot;bbb++&quot;&gt;你点了我 &#123;&#123; bbb &#125;&#125; 次，我记住了.&lt;/button&gt;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">bbb</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>效果：</p>
<p><img src="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/60.gif"></p>
<h2 id="2-组件的复用"><a href="#2-组件的复用" class="headerlink" title="2 组件的复用"></a>2 组件的复用</h2><p>定义好的组件，可以任意复用多次：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复用定义好的全局组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aaa</span>&gt;</span><span class="tag">&lt;/<span class="name">aaa</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aaa</span>&gt;</span><span class="tag">&lt;/<span class="name">aaa</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aaa</span>&gt;</span><span class="tag">&lt;/<span class="name">aaa</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/1530084943778.png" alt="1530084943778"></p>
<p>你会发现每个组件互不干扰，都有自己的 bbb 值。这是怎么实现的呢？</p>
<p>答案就是：<strong>组件的data属性必须是函数</strong>。</p>
<p>当我们定义这个 <code>&lt;aaa&gt;</code> 组件时，它的 data 并不是像这样直接提供一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！</p>
<hr>
<h2 id="3-局部注册"><a href="#3-局部注册" class="headerlink" title="3 局部注册"></a>3 局部注册</h2><p>一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。</p>
<p>因此，对于一些并不频繁使用的组件，我们会采用局部注册。</p>
<p>我们先在外部定义一个对象，结构与创建组件时传递的第二个参数一致：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = &#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;&#x27;</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在Vue中使用它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        <span class="attr">counter</span>:counter <span class="comment">// 将定义的对象注册为组件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>components 就是当前 vue 对象导入的组件集合。<ul>
<li>其key就是子组件名称</li>
<li>其值就是组件对象的属性</li>
</ul>
</li>
<li>效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用</li>
</ul>
<hr>
<h2 id="4-组件通信"><a href="#4-组件通信" class="headerlink" title="4 组件通信"></a>4 组件通信</h2><p>通常一个单页应用会以一棵嵌套的组件树的形式来组织：</p>
<p><img src="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/1525855149491.png" alt="1525855149491"></p>
<ul>
<li>页面首先分成了顶部导航、左侧内容区、右侧边栏三部分</li>
<li>左侧内容区又分为上下两个组件</li>
<li>右侧边栏中又包含了3个子组件</li>
</ul>
<p>各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。</p>
<h3 id="4-1-props（父向子传递）"><a href="#4-1-props（父向子传递）" class="headerlink" title="4.1 props（父向子传递）"></a>4.1 props（父向子传递）</h3><ol>
<li>父组件使用子组件时，自定义属性（属性名任意，属性值为要传递的数据）</li>
<li>子组件通过props接收父组件属性</li>
</ol>
<p>父组件使用子组件，并自定义了title属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>打个招呼：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用子组件，同时传递title属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">introduce</span> <span class="attr">title</span>=<span class="string">&quot;大家好，我是锋哥&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;introduce&quot;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 直接使用props接收到的属性来渲染页面</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>:<span class="string">&#x27;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>:[<span class="string">&#x27;title&#x27;</span>] <span class="comment">// 通过props来接收一个父组件传递的属性</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/1530093525973.png" alt="1530093525973"></p>
<h3 id="4-2-props验证"><a href="#4-2-props验证" class="headerlink" title="4.2.props验证"></a>4.2.props验证</h3><p>我们定义一个子组件，并接受复杂数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myList = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">    &lt;ul&gt;\</span></span><br><span class="line"><span class="string">    	&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.id&#125;&#125; : &#123;&#123;item.name&#125;&#125;&lt;/li&gt;\</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;\</span></span><br><span class="line"><span class="string">    &#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">items</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">            <span class="attr">default</span>: [],</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个子组件可以对 items 进行迭代，并输出到页面。</li>
<li>props：定义需要从父组件中接收的属性<ul>
<li>items：是要接收的属性名称<ul>
<li>type：限定父组件传递来的必须是数组</li>
<li>default：默认值</li>
<li>required：是否必须</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</strong> </p>
<p>我们在父组件中使用它：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>传智播客已开设如下课程：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用子组件的同时，传递属性，这里使用了v-bind，指向了父组件自己的属性lessons --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-list</span> <span class="attr">:items</span>=<span class="string">&quot;lessons&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        myList <span class="comment">// 当key和value一样时，可以只写一个</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">lessons</span>:[</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;java&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;php&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;ios&#x27;</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/1530107338625.png" alt="1530107338625"></p>
<p>type类型，可以有：</p>
<p><img src="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/1530108427358.png" alt="1530108427358"></p>
<h3 id="4-3-动态静态传递"><a href="#4-3-动态静态传递" class="headerlink" title="4.3.动态静态传递"></a>4.3.动态静态传递</h3><p>给 prop 传入一个静态的值： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">introduce</span> <span class="attr">title</span>=<span class="string">&quot;大家好，我是锋哥&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>给 prop 传入一个动态的值： （通过v-bind从数据模型中，获取title的值）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">introduce</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>静态传递时，我们传入的值都是字符串类型的，但实际上<strong>任何类型</strong>的值都可以传给一个 props。 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个JavaScript表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">&quot;42&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">&quot;post.likes&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-4-子向父的通信"><a href="#4-4-子向父的通信" class="headerlink" title="4.4.子向父的通信"></a>4.4.子向父的通信</h3><p>来看这样的一个案例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>num: &#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用子组件的时候，传递num到子组件中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:num</span>=<span class="string">&quot;num&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;counter&quot;</span>, &#123;<span class="comment">// 子组件，定义了两个按钮，点击数字num会加或减</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>:<span class="string">&#x27;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;div&gt;\</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;button @click=&quot;num++&quot;&gt;加&lt;/button&gt;  \</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;button @click=&quot;num--&quot;&gt;减&lt;/button&gt;  \</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;/div&gt;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>:[<span class="string">&#x27;num&#x27;</span>]<span class="comment">// count是从父组件获取的。</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">num</span>:<span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>子组件接收父组件的num属性</li>
<li>子组件定义点击按钮，点击后对num进行加或减操作</li>
</ul>
<p>我们尝试运行，好像没问题，点击按钮试试：</p>
<p><img src="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/1530115066496.png" alt="1525859093172"></p>
<p>子组件接收到父组件属性后，默认是不允许修改的。怎么办？</p>
<p>既然只有父组件能修改，那么加和减的操作一定是放在父组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">num</span>:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123; <span class="comment">// 父组件中定义操作num的方法</span></span><br><span class="line">        <span class="title function_">increment</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">num</span>++;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">decrement</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">num</span>--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是，点击按钮是在子组件中，那就是说需要子组件来调用父组件的函数，怎么做？</p>
<p>我们可以<strong>通过v-on指令将父组件的函数绑定到子组件</strong>上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>num: &#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:count</span>=<span class="string">&quot;num&quot;</span> @<span class="attr">inc</span>=<span class="string">&quot;increment&quot;</span> @<span class="attr">dec</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在子组件中定义函数，函数的具体实现调用父组件的实现，并在子组件中调用这些函数。当子组件中按钮被点击时，调用绑定的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;counter&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;\</span></span><br><span class="line"><span class="string">        &lt;div&gt;\</span></span><br><span class="line"><span class="string">            &lt;button @click=&quot;plus&quot;&gt;加&lt;/button&gt;  \</span></span><br><span class="line"><span class="string">            &lt;button @click=&quot;reduce&quot;&gt;减&lt;/button&gt;  \</span></span><br><span class="line"><span class="string">        &lt;/div&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;count&#x27;</span>],</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">plus</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&quot;inc&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">reduce</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&quot;dec&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>vue提供了一个内置的this.$emit()函数，用来调用父组件绑定的函数</li>
</ul>
<p>效果：</p>
<p><img src="/2022/03/24/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/61.gif"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/" class="post-title-link" itemprop="url">检索技术（Part1）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-21 19:16:27" itemprop="dateCreated datePublished" datetime="2022-03-21T19:16:27+08:00">2022-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-05 14:05:53" itemprop="dateModified" datetime="2022-04-05T14:05:53+08:00">2022-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">检索技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="01-线性结构检索：从数组和链表的原理初窥检索本质"><a href="#01-线性结构检索：从数组和链表的原理初窥检索本质" class="headerlink" title="01 | 线性结构检索：从数组和链表的原理初窥检索本质"></a>01 | 线性结构检索：从数组和链表的原理初窥检索本质</h1><blockquote>
<p>  <strong>学习目标</strong>：通过学习数组和链表这样的线性结构的检索过程，举一反三，深入理解检索的概念。</p>
</blockquote>
<p>【问题】首先，我们来思考一个问题：什么是检索？</p>
<p>从字面意义上来讲，<u>检索就是将我们所需要的信息，从存储数据的地方高效取出的一种技术。</u>通过对这句话的简单理解，我们可以大概猜想到：想要提高检索效率，那我们的关注点应该有两个：</p>
<ol>
<li> 存储数据的地方</li>
<li> 取出数据的方式</li>
</ol>
<p>实际上也是这样，数据不同的存储方式，会导致不同的检索效率。那么，到底什么样的数据存储方式检索快？什么样的数据存储方式检索慢呢？这其实并无一个标准的答案，因为并没有哪种数据存储方式的检索效率可以在所有使用场景下都具有优势，脱离实际的理论都是空谈，在不同的应用场景中我们要学会取舍，选择当前需求下最合适的存储方式来解决问题。</p>
<p>今天，我们首先从数组和链表的特点入手，先来看一下它们是如何进行检索的。</p>
<h2 id="数组和链表有哪些优点？"><a href="#数组和链表有哪些优点？" class="headerlink" title="数组和链表有哪些优点？"></a>数组和链表有哪些优点？</h2><p>相信有一定计算机基础的小伙伴儿对这个问题已不陌生了。数组就是用一块连续的内存来存储数据。那如果我申请不到连续的内存空间怎么办呢？这时候就可以派上用场了。链表可以申请不连续的空间，通过一个指针按顺序将这些空间串起来，形成一条链，链表也正是因此得名。不过，严格意义上来讲，这个叫做单链表。如果没有特别说明，下文我提到的链表，指的都是只有一个后续指针的单链表。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321193427186.png" alt="image-20220321193427186"></p>
<p>从图片中我们可以看出，<strong>数组和链表代表了连续空间和不连续空间最基础的存储方式，它们是线性表（Linked List）的典型代表。其它所有的数据结构，比如栈、队列、二叉树、B+树等，不外乎都是这两者的结合和变化。</strong>以栈为例，它本质就是一个限制了读写位置的数组，特点是只允许先进后出。</p>
<p>因此，<strong>我们只需要从最基础的数组和链表入手，结合实际应用中遇到的问题去思考解决方案，就能逐步学习和了解更过的数据结构和检索技术。</strong></p>
<p>那么，数组和链表这两种线性数据结构的检索效率究竟如何呢？我们来具体看一下。</p>
<h2 id="如何使用二分查找提升数组的检索效率？"><a href="#如何使用二分查找提升数组的检索效率？" class="headerlink" title="如何使用二分查找提升数组的检索效率？"></a>如何使用二分查找提升数组的检索效率？</h2><p>首先，如果是无序数组的话，不管是数组还是链表，想要查找一个指定元素是否存在，在缺乏数据分布信息的情况下，我们只能从头到尾遍历一遍，才能知道其是否存在。这样的检索效率就是 <code>O(n)</code>。当然，如果数据集不大的话，其实直接遍历速度也很快。但是如果数据集规模比较大的话，我们就需要考虑更高效的检索方式。</p>
<p>对于大规模的、可排序的数据集，我们往往是先将它通过排序算法转换为有序的数据集，如果数据不可排序，那我们可以先对其建立索引，通过对索引进行排序间接完成数据的有序存储。然后通过一些检索算法，比如二分查找法来完成高效的检索。</p>
<p>二分查找也叫折半查找，它的思路很直观，就是将有序数组二分为左右两个部分，通过只在半边进行查找来提升检索效率。下面是二分查找的的具体实现步骤：</p>
<blockquote>
<p>  我们会先从中间元素查起，这就会有三种查询结果。</p>
<ol>
<li>中间元素的值就是我们要查询的值。也就是说直接查到了，那直接返回即可。</li>
<li>如果中间元素的值小于我们想查询的值，因为数组是有序的，所以我们以中间元素为分隔，左半边的数组元素一定都小于中间元素，也就是小于我们想查询的值。因此，我们想查询的值只可能存在于右半边的数组中。对于右半边的数组，我们还是可以继续使用二分查找的思路，再从它的中间查起，重复上面的过程。这样不停地“二分”下去，每次的检索空间都能减少一半，整体的平均查询效率就是 O(log n)，远远小于遍历整个数组的代价 O(n)。</li>
<li>同理，如果中间元素的值大于我们想查询的值，那么我们就只在左边的数组元素查找即可。</li>
</ol>
</blockquote>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321195720343.png" alt="image-20220321195720343"></p>
<p>由此可见，合理地组织数据的存储可以提高检索效率。<strong>检索的核心思路，其实就是通过合理组织数据，尽可能地快速减少查询范围。</strong>我们见到的各种检索算法和技术，本质上都是通过灵活应用各种数据结构的特点来组织数据，从而达到快速减少查询范围的目的。</p>
<h2 id="链表在检索和动态调整上的优缺点"><a href="#链表在检索和动态调整上的优缺点" class="headerlink" title="链表在检索和动态调整上的优缺点"></a>链表在检索和动态调整上的优缺点</h2><p>前面我们说了，数据无序存储的话，数据和链表的检索效率都很低，都需要全盘扫描遍历。如果数据有序的话，采用数组存储数据可以通过二分查找大大提高检索效率。但你有没有发现一个问题，即便数据有序，链表好像也没法儿提高检索效率啊。</p>
<p>数组的“连续空间存储”带来了数据可随机访问的特点。在有序数组应用二分查找时，它能以 O(1) 的时间代价快速访问到位于中间的值，然后以中间点为分界线，只选择左边或右边继续查找，从而能快速缩小查询范围。</p>
<p>但是链表并不具备“随机访问”的特点。当链表想要访问中间的元素时，我们必须从链表头开始，沿着链一步一步遍历过去，才能访问到期望的数值。即如果想要访问链表中间的节点，我们就需要遍历一半的节点，时间代价已经是 O(n/2) 了。从这个方面来看，由于少了“随机访问”的特性，链表的检索能力是偏弱的。</p>
<p>但，凡事都有两面性，<strong>链表的检索能力偏弱，作为弥补，它在动态调整上会更容易</strong>。我们可以以 O(1) 的时间代价完成节点的插入和删除，这是“连续空间”的数组难以做到的。毕竟如果我们要在有序数组中插入一个元素，为了保证“数组有序”，我们就必须将数组中排在这个元素后面的元素，全部顺序后移一位，这其实是一个 O(n) 的时间代价了。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321201525392.png" alt="image-20220321201525392"></p>
<p>因此，<u>在一些需要频繁插入删除数据的场合，有序数组不见得是最合适的选择。另一方面，在数据量非常大的场合，我们也很难保证能申请到连续空间来构建有序数组。</u>因此，学会高效合理地使用链表，也是非常重要的。</p>
<h2 id="如何灵活改造链表提升检索效率？"><a href="#如何灵活改造链表提升检索效率？" class="headerlink" title="如何灵活改造链表提升检索效率？"></a>如何灵活改造链表提升检索效率？</h2><p><u><strong>本质上，我们学习链表，就是在学习“非连续存储空间”的组织方案。</strong>我们知道，对于“非连续空间”，可以用指针将它串联成一个整体。只要掌握了这个思想，我们就可以在不同的应用场景中，设计出适用的数据结构，而不需要拘泥于链表自身的结构限制。</u></p>
<p>我们可以来看一个简单的例子。</p>
<p>比如说，如果我们觉得链表一个节点一个节点地遍历太慢，那么我们是不是可以对其进行简单改造，让链表的每个节点不再只是存储一个元素，而是存储一个小的数组。这样我们就能大幅减少节点的数量，从而减少依次遍历节点带来的“低寻址效率”。</p>
<p>如下图所示，我的链表里就只有两个节点，每个节点都存储了一个小的有序数组。这样在检索的时候，我可以用二分查找的思想，先查询第一个节点存储的数组中的末尾元素，看看是否是我们想要的数字。如果不是，我们要么在第一个节点的数组中继续二分查找，要么在第二个节点的数组中继续二分查找。这样的结构就能同时兼顾数组和链表的特点了，而且时间代价也是 O(log n)。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/image-20220321202554930.png" alt="image-20220321202554930"></p>
<p>可见，尽管常规的链表只能遍历检索，但是只要我们掌握了“非连续存储空间可以灵活调整”的特性，就可以设计更高效的数据结构和检索算法了。</p>
<hr>
<h1 id="02-非线性结构检索：数据频繁变化的情况下，如何高效检索？"><a href="#02-非线性结构检索：数据频繁变化的情况下，如何高效检索？" class="headerlink" title="02 | 非线性结构检索：数据频繁变化的情况下，如何高效检索？"></a>02 | 非线性结构检索：数据频繁变化的情况下，如何高效检索？</h1><p>当我们在电脑中查文件的时候，我们一般习惯先打开相应的磁盘，再打开文件夹及子文件夹，最后找到我们需要的文件。这其实就是一个检索路径。如果把所有的文件展开，这个查找路径其实是一种树状结构，即是一种非线性结构，而不是一个所有文件平铺排列的线性结构。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/1859310bd112d5479eac9c097db8b946.jpeg" alt="img"></p>
<p>我们都知道，<u>有层次的文件组织肯定比散乱平铺的文件更容易找到。这样一个熟悉的场景，是否是能给我们一个启发：对于零散的数据，非线性的树状结构是否可以帮助我们提高检索效率呢？</u></p>
<p>另一方面，我们也知道，在数据频繁更新的场景中，连续存储的有序数组并不是最合适的存储方案。因为数组为了保持有序必须不停地重建和排序，系统的检索性能就会急剧下滑。但是，非连续存储的有序链表倒是具有高效插入新数据的能力。因此，我们能否结合上面的例子，使用非线性的树状结构来改造有序链表，让链表也具有二分查找的能力呢？并且，如果成功的话，还是一种适用于写多读少场景的二分查找能力。</p>
<h2 id="树结构是如何进行二分查找的？"><a href="#树结构是如何进行二分查找的？" class="headerlink" title="树结构是如何进行二分查找的？"></a>树结构是如何进行二分查找的？</h2><p>上一节我们说过，因为链表不具备“随机访问”的特点，所以二分查找无法生效。当链表想要访问中间的元素时，我们必须从链表头开始，沿着指针一步一步遍历，需要遍历一半的节点才能到达中间节点，时间代价是 O(n/2)。而有序数组由于可以“随机访问”，因此只需要 O(1) 的时间代价就可以访问到中间节点了。</p>
<p>那如果我们能在链表中以 O(1) 的时间代价快速访问到中间的节点，是不是就可以和有序数组一样使用二分查找了？</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/2c61d26ed919411dd9be1a94cefb30ca.jpg" alt="img"></p>
<p>既然我们希望能以 O(1) 的时间代价访问中间节点，那直接将这个节点记录下来是不是就可以了？因此，如果我们已经把中间节点 M 拎出来单独记录了，那我们的第一步操作就是直接访问这个中间节点，然后判断这个节点和要查找的元素是否相等。如果相等，则返回查询结果。如果节点元素大于要查找的元素，那我们就道左边的部分继续查找；反之，则到右边的部分继续查找。</p>
<p>对于左边或者右边的部分，我们可以将它们视为两个独立的子链表，依然沿用这个逻辑。如果想用 O(1) 的时间代价就能访问这两个子链表的中间节点，我们就应该把左边部分的中间节点 L 和右边部分的中间节点 R 单独拎出来记录。</p>
<p>并且，由于我们是在访问完了 M 节点后，才决定接下来该去访问左边的 L 还是右边的 R。所以，我们还需要将 M 和 L，M 和 R 连接起来。我们可以让 M 带有两个指针，一个左指针指向 L，一个右指针指向 R。这样，在访问 M 以后，一旦发现 M 不是我们要查找的节点，那么我们接下来就可以通过指针快速访问到 L 或者 R 了。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/d274bfacd98b00d82746cfeb838ec1f4.jpeg" alt="img"></p>
<p>对于其余的节点，我们也可以进行同样的处理。下面这个结构，你是不是很熟悉，没错，这就是我们常见的二叉树。你再来观察一下，这个二叉树和普通的二叉树有什么不一样？</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/bf8df69285c21e28b493bd2f7a0c1abb.jpeg" alt="img"></p>
<p>没错，这个二叉树是有序的。它的左子树的所有节点的值都小于根节点，同时右子树所有节点的值都大于等于根节点。这样的有序结构，使得它能使用二分查找法，快速地过滤掉一半的数据。具备了这样特点的树，就是<strong>二叉检索树（Binary Search Tree）</strong>，或叫<strong>二叉排序树（Binary Sorted Tree）</strong>。</p>
<p>现在我们就可以简单对比一下。<strong>尽管有序数组和二叉检索树，在数据形态上看起来差异很大，但是在提高检索效率上，它们的核心原理都是一样的。</strong>那么，它们是如何提高检索效率的呢？核心原理又一致在哪里呢？下面我们从两个方面总结一下：</p>
<ul>
<li>  将数据有序化，并且根据数据存储的特点进行不同的组织。对于连续存储空间的数组而言，由于它具有“随机访问”的特性，因此直接存储即可；对于非连续存储空间的有序链表而言，由于它不具备“随机访问”的特性，因此，需要将它改造成可以快速访问到中间节点的树形结构。</li>
<li>  在进行检索的时候，它们都是通过二分查找的思想从中间节点开始查起。如果不命中，会快速缩小一半的查询空间。这样不停迭代的查询方式，让检索的时间代价能达到 O(log n) 这个级别。</li>
</ul>
<p>当然，如果你有一定的数据结构基础，就应该知道，二叉检索树的时间复杂度并不一定永远是 O(log n)。</p>
<h2 id="二叉检索树的空间平衡方案"><a href="#二叉检索树的空间平衡方案" class="headerlink" title="二叉检索树的空间平衡方案"></a>二叉检索树的空间平衡方案</h2><br>

<br>

<br>

<hr>
<h1 id="04-状态检索：如何判断一个用户是否存在？"><a href="#04-状态检索：如何判断一个用户是否存在？" class="headerlink" title="04 | 状态检索：如何判断一个用户是否存在？"></a>04 | 状态检索：如何判断一个用户是否存在？</h1><p>在实际工作中，我们经常需要判断一个对象是否存在。比如说，在注册新用户的时候，我们需要先快速判断这个用户 ID 是否被注册过；再比如说，在爬虫系统抓取网页之前，我们要判断一个 URL 是否已经被抓取过，从而避免无谓的、重复的抓取工作。</p>
<p>那么，对于这一类是否存在的状态检索需求，如果直接使用前面讲过的检索技术，如有序数组、二叉检索树以及哈希表来实现的话，它们的检索性能如何？是否有优化的方案呢？今天，我们就一起来讨论一下这些问题。</p>
<h3>如何使用数据的随机访问特性提高查询效率？

<p>以新注册用户时查询用户 ID 是否存在为例，我们可以直接使用有序数组、二叉检索树或者哈希表来存储所有的用户 ID。</p>
<p>我们知道，无论是有序数组还是二叉检索树，它们都是使用二分查找的思想从中间元素开始查起的。所以，在查询用户 ID 是否存在时，它们的平均检索时间复杂度都是 O(log n)，而哈希表的平均检索时间复杂度是 O(1)。因此，如果我们希望能快速查询出元素是否存在，那哈希表无疑是最合适的选择。不过，如果从工程实现的角度来看的话，哈希表的查询过程还是可以继续优化的。</p>
<p>比如说，如果我们要查询的对象 ID 本身是正整数类型，且 ID 范围有上限的话。我们可以申请一个足够大的数组，让数组长度超过 ID 的上限。然后，把数组中所有位置的值都初始化为 0。对于存在的用户，我们<strong>直接将用户 ID 作为数组下标</strong>，将该位置对应的值从 0 设置为 1 就可以了。</p>
<hr>
<h1 id="05-倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？"><a href="#05-倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？" class="headerlink" title="05 | 倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？"></a>05 | 倒排索引：如何从海量数据中查出同时带有“极“和”客”的唐诗？</h1><blockquote>
<p>  <strong>提出问题：</strong></p>
</blockquote>
<p>试想这样一个场景：假设你已经熟读唐诗300首了。这个时候，如果我给你一首诗的题目，相信你一定可以很快背出这首诗的内容。但是如果我问你，有哪些诗中同时包含了“极”和“客”字？很显然，第二个问题的难度比第一个问题大得多。</p>
<p>那么从程序设计的角度来看，这两个问题对应的检索过程又有什么不同呢？这就对应了两种非常常见且重要的检索技术：**正排索引 **和 <strong>倒排索引</strong>。</p>
<h3>什么是倒排索引？

<p>我们先来看看第一个问题：给出一首诗的题目，马上背出内容。这其实就是一个典型的键值查询场景。针对这个场景，我们可以给每首诗一个唯一的编号作为 ID，然后使用哈希表将诗的 ID 作为键（Key），把诗的内容作为键对应的值（Value）。这样，我们就能在 O(1) 的时间复杂度内，完成对指定 key 的检索。这样的以对象的唯一 ID 为 key 的哈希索引结构，叫做<strong>正排索引（Forward Index）</strong>。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/4b5e88addf89120aba176671c53d25f1.jpeg" alt="img"></p>
<p>一般来说，我们会遍历哈希表，遍历的时间复杂度是 O(n)。在遍历过程中，对于遇到的每一个元素对应着一首诗，如果我们想要判断这首诗中是否包含“极”字和“客”字，我们还需要遍历这首诗中的每一个字符。假设每首诗的平均长度是 k，那么遍历一首诗的时间代价就是 O(k)。所以，判断哪些诗中包含“极”字和“客”字的时间复杂度就是 O(n*k)。从分析中我们可以发现，这个检索过程全部都是遍历，因此时间复杂度非常高。对此，有什么优化方法吗？</p>
<p>我们首先来分析一下这两个场景。我们会发现，“根据题目查找内容”和“根据关键字查找题目”，这两个问题其实是完全相反的。既然完全相反，那我们能否“反着”建立一个哈希表来帮助我们查找呢？也就是说，如果我们以关键字作为 key 建立哈希表，是不是问题就解决了呢？接下来，我们试着操作一下。</p>
<p>我们将每个关键字当做 key，将包含了这个关键字的诗的列表当做存储的内容。这样，我们就建立了一个哈希表，根据关键字来查询这个哈希表，在 O(1) 的时间复杂度内，我们就能得到包含该关键字的文档列表。这种根据具体内容或者属性反过来索引文档标题的结构，就叫做<strong>倒排索引（Invert Index）</strong>。在倒排索引中，key 的集合叫做<strong>字典（Dictionary）</strong>，一个 key 后面对应的记录集合叫做<strong>记录列表（Posting List）</strong>。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/8e602ab79d98380c8c258a30a1e2108b.jpg" alt="img"></p>
<h3>如何创建倒排索引？

<p>前面我们介绍了倒排索引的概念，那创建一个倒排索引的过程究竟是怎么样的呢？我把这个过程总结成了以下步骤：</p>
<ol>
<li> 给每个文档编号，作为其唯一标识，<u>并且排好序</u>，然后开始遍历文档（为什么要先排序，然后再遍历文档呢？你可以想一下，后面我们会解释）。</li>
<li> 解析当前文档中的每个关键字，生成 <code>&lt;关键字, 文档ID, 关键字位置&gt;</code> 这样的数据对象。为什么要记录关键字位置这个信息呢？因为在许多检索的场景中，都需要显示关键字前后的内容，比如，在组合查询时，我们要判断多个关键字之间是否足够接近。所以我们需要记录位置信息，以方便提取相应关键字的位置。</li>
<li> 每检测到一个关键字，就将关键字作为 key 插入哈希表，如果哈希表中已经有这个 key 了，我们就在对应的 posting list 后面追加节点，记录该文档 ID（关键字的位置信息如果需要，也可以一并记录在节点中）；如果哈希表中还没有这个 key，我们就直接插入该 key，并创建 posting list 和对应节点。</li>
<li> 重复第2步和第3步，处理完所有文档，完成倒排索引的创建。</li>
</ol>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/2ccc78df6ebbd4d716318d5113fa090d.jpg" alt="img"></p>
<h3>如何查询同时含有“极”字和“客”字两个key的文档？

<p>如果只是查询包含“极”或者“客”这样的单个字的文档，我们直接以查询的字作为 key 去倒排索引表中检索，得到的 posting list 就是结果了。但是，如果我们的目的是要查询同时包含“极”和“客”这两个字的文档，那我们该如何操作呢？</p>
<p>我们可以先分别用两个 key 去倒排索引中检索，这样会得到两个不同的 posting list：A 和 B。A 中的文档都包含了“极”字，B 中的文档都包含了“客”字。那么，如果一个文档既出现在 A 中，又出现在 B 中，它是不是就同时包含了这两个字呢？按照这个思路，我们只需查找出 A 和 B 的公共元素即可。</p>
<p>那么问题来了，<u>我们该如何在 A 和 B 这两个链表中查找出公共元素呢？</u>如果 A 和 B 都是无序链表，我们只能将 A 链表和 B 链表中的每个元素分别比对一次，这个时间复杂度时 O(m*n)。但是，如果两个链表是有序的，我们就可以用归并排序的方法来遍历 A 和 B 两个链表，时间复杂度会降低到 O(m+n)，其中 m 是链表 A 的长度，n 是链表 B 的长度。</p>
<blockquote>
<p>  链表归并排序的步骤：</p>
<ol>
<li> 使用指定 p1 和 p2 分别指向有序链表 A 和 B 的第一个元素。</li>
<li>对比 p1 和 p2 指向的节点是否相同，这时会出现三种情况：<ul>
<li>  （1）两者的 id 相同，说明该节点为公共元素，直接将该节点加入归并结果。然后，p1 和 p2 要同时后移，指向下一个元素；</li>
<li>  （2）p1 元素的 id 小于 p2 元素的 id，p1 后移，指向 A 链表中的下一个元素；</li>
<li>  （3）p1 元素的 id 大于 p2 元素的 id，p2 后移，指向 B 链表中的下一个元素。</li>
</ul>
</li>
<li> 重复第 2 步，直到 p1 或 p2 移动到链表尾为止。</li>
</ol>
<p>  具体的操作步骤如下图所示：</p>
</blockquote>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/a377f626bbfc1de2f98f199ed0ad585f.jpg" alt="img"></p>
<p>那对于<strong>两个 key</strong> 的联合查询来说，除了有“<strong>同时存在</strong>”这样的场景以外，还有很多联合查询的实际例子。比如说，我们可以查询包含“极”<strong>或</strong>“客”的诗，也可以查询包含“极“<strong>且不包含</strong>”客”的诗。这些场景分别对应着交集、并集和差集等问题。具体的实现流程也和“同时存在”差不多，也是通过遍历链表对比的方式来完成的。</p>
<p>此外，在实际应用中，我们可能还需要对<strong>多个 key</strong> 进行联合查询，比如说，要查询同时包含“极“、”客“、”时“、”间” 四个字的诗，这个时候，我们利用多路归并的方法，同时遍历这四个关键字对应的 posting list 即可。实现过程如下图所示：</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/c91ce2f3cff16b20b0cca52a57336b96.jpeg" alt="img"></p>
<h3>重点回顾

<p>回顾上面讲的，你会发现，<u>倒排索引的核心其实并不复杂，它的具体实现其实是哈希表</u>，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间复杂度内完成查询。</p>
<p>尽管倒排索引的原理并不复杂，但是倒排索引是很多搜索引擎的核心。比如说：数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。</p>
<hr>
<h1 id="06-数据库检索：如何使用B-树对海量磁盘数据建立索引？"><a href="#06-数据库检索：如何使用B-树对海量磁盘数据建立索引？" class="headerlink" title="06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？"></a>06 | 数据库检索：如何使用B+树对海量磁盘数据建立索引？</h1><h2 id="为什么需要磁盘数据检索技术？"><a href="#为什么需要磁盘数据检索技术？" class="headerlink" title="为什么需要磁盘数据检索技术？"></a>为什么需要磁盘数据检索技术？</h2><p>前面我们学习的那些检索相关的数据结构和技术，都是直接操作内存中的数据，但是有时候，系统要处理的数据量非常庞大，数据无法全部存储在内存中，这时我们就需要借助磁盘完成存储和检索。我们熟悉的关系型数据库，比如 MySQL 和 Oracle，就是这样的典型系统。</p>
<p>数据库中支持多种索引方式，比如：Hash索引、全文索引和B+树索引，其中B+树索引是使用最频繁的类型，下面我们就来聊一聊磁盘上的数据检索有什么特点，以及B+树索引为什么能对磁盘上的大规模数据进行高效索引。</p>
<h2 id="磁盘和内存中数据的读写效率有什么不同？"><a href="#磁盘和内存中数据的读写效率有什么不同？" class="headerlink" title="磁盘和内存中数据的读写效率有什么不同？"></a>磁盘和内存中数据的读写效率有什么不同？</h2><p>首先，我们来研究一下，存储在内存中和磁盘中的数据，在检索效率方面有什么不同。</p>
<p>内存是半导体元件。<u>对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性</u>，因此内存也叫<strong>随机访问存储器（Random Access Memory，即 RAM）</strong>。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。</p>
<p>而磁盘是机械硬件。<u>磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取响应的数据。</u>尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10~100 万倍左右的差距。<u>但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的</u>。为什么会这样呢？这就和磁盘的读写原理有关了。</p>
<p>磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 512 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 4K 个字节。操作系统会一次读写多个扇区，所以<u>操作系统的最小读写单位是<strong>块（Block）</strong>，也叫做<strong>簇（Cluster）</strong>。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来</u>。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。</p>
<p>举个例子就是，在内存中读一个数据可能需要 0.01s，那么读 100 个数据就需要 1s。而在磁盘中，读一个数据需要 1s，假设这 100 个数据分布在不同的块中，那么读 100 个数据就需要 100s；而如果这 100 个数据分布在一个块中，那么同样只需要 1s 。所以说，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。</p>
<p>现在我们已经了解磁盘的特点了，那我们可以来看一下，如果使用之前学过的检索技术来检索磁盘中的数据，检索效率回是怎样的呢？</p>
<p>假设一个有序数据存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘读到内存中，然后在内存中进行二分查找。如果下一步要读的元素在其它块中，则需要再将相应块从磁盘读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。</p>
<p>由于磁盘相对于内存而言，访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：<strong>对磁盘的访问次数要尽可能的少！</strong></p>
<p>那么问题来了，我们应该如何减少磁盘的访问次数呢？将索引和数据分离就是一种常见的设计思路。</p>
<h2 id="如何将索引和数据分离？"><a href="#如何将索引和数据分离？" class="headerlink" title="如何将索引和数据分离？"></a>如何将索引和数据分离？</h2><p>我们以查询用户信息为例。我们知道，一个系统中的用户信息非常多，除了有唯一标识的ID以外，还有名字、邮箱、手机、兴趣爱好以及文章列表等各种信息。一个保存了所有用户信息的数组往往非常大，无法全部放在内存中，因此，我们会将它存储在磁盘中。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/3ad283ed20ba36a8f5f8350ee4bd7d56.jpg" alt="img"></p>
<p>当我们以用户的ID进行检索时，这个检索过程其实并不是需要读取存储用户的具体信息。因此，我们可以生成一个只用于检索的有序索引数组。数组中的每个元素只存两个值，一个是用户ID，另一个是这个用户信息在磁盘上的位置，那么这个数组空间就会很小，也就可以放入内存中了。这种用有序数组做索引的方法，叫做<strong>线性索引</strong>（Linear Index）。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/0e7ca7c9a2c9c373353ae5ec824f4f1e.jpg" alt="img"></p>
<p>【有序数组的缺点：】在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。（数据频繁变化 -&gt; 写操作多 -&gt; 产生大量的新增/删除/修改操作 -&gt; 有序数组中元素的位置需要频繁变化）</p>
<p>【哈希表的缺点：】但是，哈希表由于缺乏范围检索的能力，在一些场合中也不适用。</p>
<p>【只剩下二叉检索树：】因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。那么，上图中的线性索引结构，就变成了下图这个样子。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/0203a7cc903e3acf38e47a59ad3aa6b4.jpeg" alt="img"></p>
<p>【二叉检索树的缺点：】尽管二叉检索树可以解决数据动态修改的问题，但<u>在索引数据很大的情况下，依然会存在数据无法全部加载到内存中的情况。</u>这种情况下我们应该怎么办呢？</p>
<p>一个很自然的思路，就是将索引数据也存在磁盘中。那如果是树形索引，我们应该将哪些节点存入磁盘，又要如何从磁盘中读出这些数据进行检索呢？我们可以先自己想一想。然后再来看一下业界常用的解决方案 B+树是怎么做的。</p>
<h2 id="如何理解B-树的数据结构？"><a href="#如何理解B-树的数据结构？" class="headerlink" title="如何理解B+树的数据结构？"></a>如何理解B+树的数据结构？</h2><p>B+树是检索技术中非常重要的一个部分。这是为什么呢？因为<strong>B+树给出了树形索引的所有节点都存在磁盘上的高效检索方案，</strong>使得索引技术摆脱了内存空间的限制，得到了广泛的应用。</p>
<p>前面我们讲了，操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树形索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。<strong>B+树的一个关键设计就是，让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。</strong>这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。</p>
<p>B+树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。尽管内部节点和叶子节点的数据结构是一样的，但存储的内容是不同的。</p>
<p><u>内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。</u>这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而<u>叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。</u>通过这样的设计，B+树就能做到节点的空间利用率最大化。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/a994e93f2fdd38291998cba8149270eb.jpg" alt="img"></p>
<p>此外，<u>B+树还将同一层的所有节点串成了有序的双向链表，这样一来B+树就同时具备了良好的范围查询能力和灵活调整能力了。</u></p>
<p>因此，B+树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，就是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/72499a6180cfb1ee7e3c33e6ca433b65.jpg" alt="img"></p>
<h2 id="B-树是如何检索的？"><a href="#B-树是如何检索的？" class="headerlink" title="B+树是如何检索的？"></a>B+树是如何检索的？</h2><p>这样的结构，使得B+树可以作为一个完整的文件全部存储在磁盘中。当从根节点开始查询时，通过一次磁盘访问，我们就能将文件中的根节点这个数据块读出，然后在根节点的有序数组中进行二分查找。</p>
<p>具体的查找过程如下：</p>
<ol>
<li> 我们先确认要查找的值，位于数组中哪两个相邻的元素之间，然后我们将第一个元素对应的指针读出，获得下一个block的位置。（该 block 保存了两个相邻元素间的所有数据的ID）</li>
<li> 读出下一个 block 的节点数据后，我们再对它做同样的处理。这样，B+树会逐层访问内部节点，直到读出叶子节点。对于叶子节点中的数组，直接使用二分查找算法，我们就可以判断查找的元素是否存在。如果存在，我们就可以得到该查询值对应的存储数据。如果这个数据是详细信息的指针，那我们还需要再访问磁盘一次，将详细信息读出。</li>
</ol>
<p>我们前面说了，B+树是一棵完全平衡的 m 阶多叉树。所以，B+树的一个节点就能存储一个包含 m 个元素的数组，这样的话，一个只有 2~4 层的 B+ 树，就能索引数量级非常大的数据了，因此 B+ 树的层数往往很矮。比如说，一个 4K 的节点的内部可以存储 400 个元素，那么一个 4 层的 B+ 树最多能存储 400^4，也就是 256 亿个元素。（根节点存400个元素，第二层存 <code>400*400</code> 个元素，第三层存 <code>400*400*400</code>，第四层存 <code>400*400*400*400</code> 个元素，并且因为B+树只有叶子节点存储真实元素，所以说最多能存储 400^4 个元素）</p>
<p>不过，因为 B+ 树只有 4 层，这就意味着我们最多只需要读取 4 次就能到达叶子节点。并且，我们还可以通过将上面几层（非叶子节点层）的内部节点全部读取内存的方式，来降低磁盘读取的次数。</p>
<p>比如说，对于一个 4 层的 B+ 树，每个节点的大小是 4K，那么第一层根节点就是 4K，第二层最多有 400 个节点，一共就是 1.6M，第三层最多有 400^2 个节点，一共是 640M。对于现在常见的计算机来说，前三层的内部节点其实都可以存储在内存中，只有第四层的叶子节点才需要存储在磁盘中。这样一来，我们就只需要读取一次磁盘即可。这也是为什么，B+ 树要将内部节点和叶子节点区分开的原因。通过这种只让内部节点存储索引数据的设计，我们就可以更容易地把内部节点全部加载到内存中了。</p>
<h2 id="B-树是如何动态调整的？"><a href="#B-树是如何动态调整的？" class="headerlink" title="B+树是如何动态调整的？"></a>B+树是如何动态调整的？</h2><p>现在，你已经知道 B+ 树的结构和原理了。那 B+ 树在“新增节点”和“删除节点”这样的动态变化场景中，又是怎样操作的呢？接下来，让我们一起来看一下。</p>
<p>首先，我们来看插入数据。由于具体的数据都是存储在叶子节点上的，因此，数据的插入也是从叶子节点开始的。以一个节点有 3 个元素的 B+ 树为例，如果我们要插入一个 ID=6 的节点，首先要查询到对应的叶子节点，如果叶子节点的数组未满，那么就直接将该元素插入数组即可。具体过程如下图所示：</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/9ed9028cab65e6530966faae00d0d3d4.jpg" alt="img"></p>
<p>如果我们插入的是 ID=10 的节点呢？按照之前的逻辑，我们应该插入到 ID9 后面，但是 ID9 所在的这个节点已经存满了 3 个节点，无法继续存入了。因此，我们需要将该叶子节点<strong>分裂</strong>。<u>分裂的逻辑就是生成一个新的节点，并将数据在两个节点平分。</u></p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/674115e7c61637e56791e001ea840af2.jpg" alt="img"></p>
<p>叶子节点分裂完成后，上一层的内部节点也需要修改。但如果上一层的父节点也是满的，那么上一层的父节点也需要分裂。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/03af63ed8cd065743bd8b2bd812e5057.jpg" alt="img"></p>
<p>内部节点调整好了，下一步我们就要调整根节点了。由于根节点未满，因此我们不需要分裂，直接修改即可。</p>
<p><img src="/2022/03/21/%E6%A3%80%E7%B4%A2%E6%8A%80%E6%9C%AF%EF%BC%88Part1%EF%BC%89/53fd14349369951706f53abd1eff560f.jpg" alt="img"></p>
<p>如果根节点满了，那我们就需要将根节点分裂，并生成新的根节点作为第一层。</p>
<p>删除数据也类似。如果节点数据较慢，直接删除，如果删除后数组有一般以上的空间为空，那为了提高节点的空间利用率，该节点需要将左右两边兄弟节点中的元素转移过来。可以成功转移的条件是，元素转移后该节点及其兄弟节点的空间必须都能维持在半满以上。如果无法满足这个条件，就说明兄弟节点其实也足够空闲，那我们直接将该节点的元素并入兄弟节点，然后删除该节点即可。</p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>通过这节内容，你会发现，即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 <u>B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销</u>。</p>
<p><u>但是，B+ 树最大的优点在于，它提供了将索引数据存在磁盘中的高效检索方案。这让检索技术摆脱了内存的限制，</u>得到了更广泛的使用。</p>
<p>另外，本节内容还有一个重要的设计思想就是：将索引和数据分离，通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在很多大规模系统中，都是使用这个设计思路来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一种实践。</p>
</h3></h3></h3></h3></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/" class="post-title-link" itemprop="url">设计模式之美（Part2）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-20 13:48:14" itemprop="dateCreated datePublished" datetime="2022-03-20T13:48:14+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-25 20:25:27" itemprop="dateModified" datetime="2022-03-25T20:25:27+08:00">2022-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="11-实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"><a href="#11-实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？" class="headerlink" title="11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？"></a>11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？</h1><p>​    我们都知道，很多业务系统都是基于MVC三层架构来开发的。实际上，更确切点讲，<u>这是一种基于贫血模型的MVC三层架构开发模式。</u></p>
<p>​    虽然这种开发模式已经成为标准的Web项目的开发模式，但它却违反了面向对象风格，是一种彻彻底底的面向过程编程风格，因而被有些人称为反模式。特别是<strong>领域驱动设计（Domain Driven Design，DDD）</strong>盛行之后，这种基于贫血模型的传统开发模式就更加被人诟病。而基于充血模型的DDD开发模式越来越被人提倡。所以，接下来我们将结合一个虚拟钱包系统的开发案例，带你彻底搞懂这两种开发模式。</p>
<p>在正式进入实战项目之前，我们先要搞清楚下面几个问题：</p>
<blockquote>
<ul>
<li>  什么是贫血模型？什么是充血模型？</li>
<li>  为什么说基于贫血模型的传统开发模式违反OOP？</li>
<li>  基于贫血模型的传统开发模式既然违反OOP，那为什么又如此流行？</li>
<li>  什么情况下我们应该考虑使用基于充血模型的DDD开发模式？</li>
</ul>
</blockquote>
<h2 id="什么是基于贫血模型的传统开发模式？"><a href="#什么是基于贫血模型的传统开发模式？" class="headerlink" title="什么是基于贫血模型的传统开发模式？"></a>什么是基于贫血模型的传统开发模式？</h2><p>​    MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层，展示层、逻辑层、数据层。MVC三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会100%遵从MVC固定的分层模式，而是会根据具体的项目需求，做适当的调整。</p>
<p>​    比如，现在很多项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为Repository层、Service层、Controller层。其中，Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目，不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的Web项目，基本的分层思路都大差不差。</p>
<p>​    上面我们简单介绍了MVC三层开发架构。现在，我们再来看一下，什么是贫血模型？</p>
<p>​    实际上，你可能一直在用贫血模型做开发，只是自己不知道而已。不夸张地讲，目前几乎所有的业务后端系统，都是基于贫血模型的。我们来看一个简单的例子来具体理解一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Controller+VO（View Object）   //</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserBo <span class="title function_">getUserById</span><span class="params">(Long userId)</span>&#123;</span><br><span class="line">        <span class="type">UserBo</span> <span class="variable">userBo</span> <span class="operator">=</span> userService.getUserById(userId);</span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> [...convert userBo to userVo...];</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVo</span> &#123; <span class="comment">// 省略其它属性、get/set/construct方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      Service+BO（Business Object）   //</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserBo <span class="title function_">getUserById</span><span class="params">(Long userId)</span>&#123;</span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">userEntity</span> <span class="operator">=</span> userRepository.getUserById(userId);</span><br><span class="line">        <span class="type">UserBo</span> <span class="variable">userBo</span> <span class="operator">=</span> [...convert userEntity to userBo...];</span><br><span class="line">        <span class="keyword">return</span> userBo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBo</span> &#123; <span class="comment">// 省略其它属性、get/set/construct方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      Repository+Entity    //</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserEntity <span class="title function_">getUserById</span><span class="params">(Long userId)</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEntity</span> &#123; <span class="comment">// 省略其它属性、get/set/construct方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cellphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们平时开发Web后端项目的时候，基本上都是这么组织代码的。其中，UserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层。</p>
<p>​    从代码中，我们可以发现，UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话说，Service 层的数据和业务逻辑，被分割到 BO 和 Service 两个类中。像 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫做<strong>贫血模型（Anemic Domain Model）</strong>。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据和操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p>
<h2 id="什么是基于充血模型的DDD开发模式？"><a href="#什么是基于充血模型的DDD开发模式？" class="headerlink" title="什么是基于充血模型的DDD开发模式？"></a>什么是基于充血模型的DDD开发模式？</h2><p>​    上面讲了基于贫血模型的传统开发模式。现在我们再来了解一下，另一种目前更为推崇的开发模式：基于充血模型的DDD开发模式。</p>
<p><strong>首先，我们来了解一下，什么是充血模型？</strong></p>
<p>​    在贫血模型中，数据和业务逻辑被分割到不同的类中。<strong>充血模型（Rich Domain Model）</strong>正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象封装的特性，是典型的面向对象的编程风格。</p>
<p><strong>接下来，我们再来了解一下，什么是领域驱动设计（DDD）？</strong></p>
<p>​    领域驱动设计（DDD），主要用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，早在2004年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是“微服务”。</p>
<p>​    我们知道，除了监控、调用链路追踪、API网关等服务治理系统的开发之外，<u>微服务还有一个更重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。</u>所以说，微服务加速了领域驱动设计的盛行。</p>
<p>​    不过，我个人觉得，领域驱动设计有点儿类似于敏捷开发、SOA、PAAS等概念，听起来很高大上，但实际上只值“五分钱”。即便你没有听说过领域驱动设计，对这个概念一无所知，只要你开发过业务系统，就或多或少的用过它。做好领域驱动设计的关键是，看你对自己所做的业务的熟悉程度，而并不是你对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动设计搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计。所以，不要把领域驱动设计当成银弹，不要花太多的时间去过度研究它。</p>
<p>​    实际上，基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的。Controller层还是负责暴露接口，Repository层还是负责数据存取，Service层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的主要区别主要在Service层。</p>
<p>​    在基于贫血模型的传统开发模式中，Service层包含Service类和BO类两部分，BO是贫血模型，只包含数据，不包含具体的业务逻辑，业务逻辑集中在Service类中。在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain类就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而Service类变得非常轻薄。总结一下就是。<u>基于贫血模型的传统开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain</u>。</p>
<h2 id="为什么基于贫血模型的传统开发模式如此受欢迎？"><a href="#为什么基于贫血模型的传统开发模式如此受欢迎？" class="headerlink" title="为什么基于贫血模型的传统开发模式如此受欢迎？"></a>为什么基于贫血模型的传统开发模式如此受欢迎？</h2><p>​    前面我们讲过，基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了OOP的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的Web项目，都是基于这种贫血模型的开发模式，甚至连Spring框架的官方demo，都是按照这种开发模式来编写的。</p>
<p>​    我们前面也讲过，面向过程编程风格有种种弊端，比如：数据和操作分离之后，数据本身的操作就不受限制了，任何代码在任何位置都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个原因，我总结了以下三点原因。</p>
<ol>
<li> 大部分情况下，我们开发的业务系统可能都比较简单，简单到就是基于SQL的CRUD操作，所以我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单的业务开发工作。除此之外，因为业务比较简单，即使我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。</li>
<li> 充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始设计就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑，而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在Service层定义什么操作，不需要实现做太多设计。</li>
<li> 思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深入人心、习以为常。你随便问旁边一个大龄同事，基本上他参与过的所有Web项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事的。</li>
</ol>
<h2 id="什么项目应该考虑使用基于充血模型的DDD开发模式？"><a href="#什么项目应该考虑使用基于充血模型的DDD开发模式？" class="headerlink" title="什么项目应该考虑使用基于充血模型的DDD开发模式？"></a>什么项目应该考虑使用基于充血模型的DDD开发模式？</h2><p>​    既然基于贫血模型的开发模式已经成为了一种约定俗成的开发习惯，那什么样的项目应该考虑使用基于充血模型的DDD开发模式呢？</p>
<p>​    刚刚我们讲到，基于贫血模型的传统开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的DDD开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p>
<p>​    你可能会有一些疑问，这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到Service类中，一个将业务逻辑放到Domain领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的DDD开发模式就可以呢？</p>
<p>​    实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到Service层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的DDD开发模式的开发流程，在应对复杂业务系统开发的时候更有优势。为什么这么说呢？我们先来回忆一下，我们平时基于贫血模型的传统开发模式是怎么实现一个需求的。</p>
<p>​    不夸张的讲，我们平时的开发，大部分都是SQL驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中需要哪几张表，然后思考如何编写SQL语句来获取数据。之后就是定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码。</p>
<p>​    业务逻辑包裹在一个大的SQL中，而Service层可以做的事情很少。SQL都是针对特定的业务功能编写的，复用性差。当我们要开发另一个业务功能的时候，只能重新写条满足需求的SQL语句，这就可能导致各种长得差不多、区别很小的SQL语句满天飞。</p>
<p>​    所以，在这个过程中，很少有人会应用领域模型、OOP的概念，也很少有代码复用意识。对简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。</p>
<p>​    如果我们在项目中，应用了基于充血模型的DDD开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都是基于之前定义好的这些领域模型来完成。</p>
<p>​    我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的DDD开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。</p>
<hr>
<h1 id="12-实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"><a href="#12-实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？" class="headerlink" title="12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？"></a>12 | 实战一（下）：如何利用基于充血模型的DDD开发一个虚拟钱包系统？</h1><h2 id="钱包业务背景介绍"><a href="#钱包业务背景介绍" class="headerlink" title="钱包业务背景介绍"></a>钱包业务背景介绍</h2><p>​    很多具有支付、购买功能的应用（如淘宝、滴滴、极客时间等）都支持虚拟钱包功能。应用会为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转增、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面，你可以直观地感受一下。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/9e91377602ef154eaf866c7e9263a64a.jpg" alt="img"></p>
<p>​    一般来说，每个虚拟钱包账户都会对应用户的一个真实的支付账户，可能是银行卡账户，也有可能是第三方支付账户（比如支付宝、微信钱包）。为了方便后续的讲解，我们限定钱包暂时只支持充值、提现、查询余额、查询交易流水这五个核心功能，其它如冻结、透支、转增等不常用的功能暂不考虑。接下来，我们首先来看一下这五个核心功能的业务实现流程。</p>
<h3 id="1、充值"><a href="#1、充值" class="headerlink" title="1、充值"></a>1、充值</h3><p>​    用户通过第三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。整个过程我们可以分解为三个阶段：第一阶段是从用户的银行卡账户转账到应用的公共银行卡账户；第二个阶段是将用户充值的金额加到用户的虚拟钱包余额上；第三阶段是记录刚刚这笔交易流水。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/3915a6544403854d35678c81fe65f014.jpg" alt="img"></p>
<h3 id="2、支付"><a href="#2、支付" class="headerlink" title="2、支付"></a>2、支付</h3><p>​    用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户转钱到商家的虚拟钱包账户上，然后触发真正的银行转账操作，从应用的公共银行账户转钱到商家的银行账户（注意，这里并不是从用户的银行账户转钱到商家的银行账户）。除此之外，我们也需要记录这笔支付的交易流水信息。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322101917924.png" alt="image-20220322101917924"></p>
<h3 id="3、提现"><a href="#3、提现" class="headerlink" title="3、提现"></a>3、提现</h3><p>​    除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/66ede1de93d29b86a9194ea0f80d1e43.jpg" alt="img"></p>
<h3 id="4、查询余额"><a href="#4、查询余额" class="headerlink" title="4、查询余额"></a>4、查询余额</h3><p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p>
<h3 id="5、查询交易流水"><a href="#5、查询交易流水" class="headerlink" title="5、查询交易流水"></a>5、查询交易流水</h3><p>​    查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会生成记录响应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p>
<h2 id="钱包系统的设计思路"><a href="#钱包系统的设计思路" class="headerlink" title="钱包系统的设计思路"></a>钱包系统的设计思路</h2><p>​    根据刚刚讲的业务实现流程和数据流转图，我们可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。基于这样一个业务划分，我们可以将系统解耦、拆分成两个子系统：虚拟钱包系统和第三方支付系统。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/60d3cfec73986b52e3a6ef4fe147e562.jpg" alt="img"></p>
<p>而我们接下来将只聚焦于虚拟钱包系统的设计与实现。</p>
<p><strong>现在我们来看一下，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。</strong>下面这张图列出了这五个功能都会对应虚拟钱包的哪些操作。注意，交易流水的记录和查询，我暂时在图中打了个问号，因为这块比较特殊，我们在用到的时候再讲。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/d1a9aeb6642404f80a62293ab2e45630.jpg" alt="img"></p>
<p>从图中我们可以看出，虚拟钱包系统要支持的操作非常简单，就是余额的加加减减。其中，充值、提现、查询余额三个功能，只涉及一个账户余额的加减操作，而支付功能涉及两个账户余额的加减操作：一个账户加余额，另一个账户减余额。</p>
<p><strong>现在，我们再来看一下图中的问号部分，即交易流水应该如何记录和查询？</strong>我们先来看一下，交易流水都需要包含哪些信息。我觉得下面这几个信息是必需的。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/38b56bd1981d8b40ececa4d638e4a968.jpg" alt="img"></p>
<p>从图中我们可以发现，交易流水的数据格式包含两个钱包账号，一个是入账钱包账号，一个是出账钱包账号。为什么要有两个账号信息呢？这主要是为了兼容支付这种涉及两个账户的交易类型。不过，对于充值、提现这两种交易类型来说，我们只需要记录一个钱包账户信息就够了，所以，这样的交易流水数据格式的设计稍微有点浪费存储空间。</p>
<p>实际上，我们还有另外一种交易流水数据格式的设计思路，可以解决这个问题。我们把“支付”这个交易类型拆分为两个子类型：支付和被支付。支付单纯表示出账，余额扣减，被支付单纯表示入账，余额增加。这样我们在设计交易流水数据格式的时候，只需要记录一个账户信息即可。我画了一张两种交易流水数据格式的对比图，你可以看一下。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322102527802.png" alt="image-20220322102527802"></p>
<p><strong>那以上两种交易流水数据格式的设计思路，你觉得哪一个更好呢？</strong></p>
<p>答案是第一种设计思路更好一些。因为交易流水有两个功能：一个是业务功能，比如，提供用户查询交易流水信息；另一个是非业务功能，保证数据的一致性。这里主要指支付操作数据的一致性。</p>
<p>支付实际上就是一个转账的操作，在一个账户上加上一定的金额，在另一个账户上减去相应的金额。我们需要保证加金额和减金额这两个操作，要么都成功，要么都失败。如果一个成功，一个失败，就会导致数据的不一致，一个账户明明减掉了钱，另一个账户却没有收到钱。</p>
<p>保证数据一致性的方法有很多，比如，依赖数据库事务的原子性，将两个操作放在同一个事务中执行。但是，这样的做法不够灵活，因为我们有可能做了分库分表，支付涉及的两个账户存储在不同的库中，无法直接利用数据库本身的事务特性，在一个事务中执行两个账户的操作。当然，我们还有一些支持分布式事务的开源框架，但是，为了保证数据的强一致性，它们的实现逻辑一般比较复杂、本身的性能也不高，会影响业务的执行时间。所以，<u>更加权衡的一种做法就是，不保证数据的强一致性。只实现数据的最终一致性。</u></p>
<p>对于支付这样的类似转账的操作，我们在操作两个钱包账户余额之前，先记录交易流水，并且标记为“待执行”，当两个钱包的加减金额都完成之后，我们再回过头来，将交易流水标记为“成功”。在给两个钱包加减金额的过程中，如果有任意一个操作失败，我们就将交易记录的状态标记为“失败”。我们通过后台补漏Job，拉取状态为“失败”或者长时间处于“待执行”状态的交易记录，重新执行或者人工介入处理。</p>
<p>如果选择第二种交易流水的设计思路，使用两条交易流水来记录支付操作，那记录两条交易流水本身又存在数据一致性问题，有可能入账的交易流水记录成功，出账的交易流水信息记录失败。所以，权衡利弊，我们选择第一种稍微有些冗余的数据格式设计思路。</p>
<p><strong>现在，我们再思考这样一个问题：充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？换句话说，我们是否应该在虚拟钱包系统的交易流水中记录这三种类型？</strong></p>
<p>答案是否定的。虚拟钱包系统不应该感知具体的业务交易类型。我们前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务的概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。</p>
<p>但是，<strong>如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水时，如何显示每条交易流水的交易类型呢？</strong></p>
<p>从系统设计的角度，我们不应该在虚拟钱包系统的交易流水中记录交易类型。从产品需求的角度来说，我们又必须记录交易流水的交易类型。听起来比较矛盾，这个问题该如何解决呢？</p>
<p>我们可以通过记录两条交易流水信息来解决。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和第三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以我们在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。</p>
<p>为了让你更好地理解刚刚的设计思路，我画了一张图，可以对比着讲解一块儿来看。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322102706010.png" alt="image-20220322102706010"></p>
<p>我们通过查询上层钱包系统的交易流水信息，去满足用户查询交易流水的功能需求，而虚拟钱包中的交易流水就只是用来解决数据一致性问题。实际上，它的作用还有很多，比如用来对账等。</p>
<p>整个虚拟钱包系统的设计思路到此讲完了。接下来，我们来看一下，如何分别用基于贫血模型的传统开发模式和基于充血模型的DDD开发模式，来实现这样的一个虚拟钱包系统？</p>
<h2 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h2><p>设计采用典型的Web后端项目三层架构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法。在这里省略了具体的代码实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line">    <span class="keyword">private</span> VirtualWalletService virtualWalletService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">(Long walletId)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 查询余额</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 出账</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 入账</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 转账</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。Repository 这一层的代码实现比较简单，不是我们讲解的重点，所以我也省略掉了。Service 层的代码如下所示。注意，这里我省略了一些不重要的代码校验，比如，对 amount 是否小于0、钱包是否存在的校验等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletBo</span> &#123; <span class="comment">// 省略getter/setter/constructor方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long createTime;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TransactionType</span> &#123;</span><br><span class="line">    DEBIT,  <span class="comment">// 出账</span></span><br><span class="line">    CREDIT, <span class="comment">// 入账</span></span><br><span class="line">    TRANSFER <span class="comment">// 交易</span></span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line">    <span class="keyword">private</span> VirtualWalletRepository walletRepo; </span><br><span class="line">    <span class="keyword">private</span> VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> VirtualWalletBo <span class="title function_">getVirtualWallet</span><span class="params">(Long walletId)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">wallerEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">VirtualWalletBo</span> <span class="variable">walletBo</span> <span class="operator">=</span> convert(wallerEntity);</span><br><span class="line">        <span class="keyword">return</span> walletBo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">(Long walletId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> walletRepo.getBalance(walletId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> walletEntity.getBalance();</span><br><span class="line">        <span class="keyword">if</span> (balance.compareTo(amount) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSufficientBalanceException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        walletRepo.updateBalance(walletId, balance.subtract(amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> walletEntity.getBalance();</span><br><span class="line">        walletRepo.updateBalance(walletId, balance.add(amount));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录交易流水（含交易类型）</span></span><br><span class="line">        <span class="type">VirtualWalletTransactionEntity</span> <span class="variable">transactionEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualWalletTransactionEntity</span>();</span><br><span class="line">        transactionEntity.setAmount(amount);</span><br><span class="line">        transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">        transactionEntity.setType(TransactionType.TRANSFER);</span><br><span class="line">        transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">        transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">        transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行账户出/入账操作</span></span><br><span class="line">        debit(fromWalletId, amount);</span><br><span class="line">        credit(toWalletId, amount);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是利用基于贫血模型的传统开发模式实现的虚拟钱包系统，尽管我们对代码稍微做了一些简化，但整体的业务逻辑是类似的。并且代码逻辑都非常简单，理解起来没有难度。</p>
<h2 id="基于充血模型的DDD开发模式"><a href="#基于充血模型的DDD开发模式" class="headerlink" title="基于充血模型的DDD开发模式"></a>基于充血模型的DDD开发模式</h2><p>刚刚讲了如何利用基于贫血模型的传统开发模式来实现虚拟钱包系统，现在，我们再来看一下，如何利用基于充血模型的DDD开发模式来实现这个模式。</p>
<p>在上一节中我们讲过，基于充血模型的DDD开发模式，跟基于贫血模型的传统开发模式的主要区别就在Service层，Controller层和Repository层的代码基本上相同。所以，我们重点看一下，Service层按照基于充血模型的DDD开发模式该如何来实现。</p>
<p>在这种开发模式下，我们把虚拟钱包 VirtualWallet 类设计成一个 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的依赖 VirtualWallet 类。具体的实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWallet</span> &#123; <span class="comment">// Domain领域模型（充血模型）</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">createTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VirtualWallet</span><span class="params">(Long preAllocatedId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = preAllocatedId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance.compareTo(amount) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSufficientBalanceException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.add(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数或IOC框架注入</span></span><br><span class="line">    <span class="keyword">private</span> VirtualWalletRepository walletRepo;</span><br><span class="line">    <span class="keyword">private</span> VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> VirtualWallet <span class="title function_">getVirtualWallet</span><span class="params">(Long walletId)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">wallerEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">VirtualWallet</span> <span class="variable">wallet</span> <span class="operator">=</span> convert(wallerEntity);</span><br><span class="line">        <span class="keyword">return</span> wallet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">(Long walletId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> walletRepo.getBalance(walletId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">VirtualWallet</span> <span class="variable">wallet</span> <span class="operator">=</span> convert(wallerEntity);</span><br><span class="line">        wallet.debit(amount);</span><br><span class="line">        walletRepo.updateBalance(walletId, wallet.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(Long walletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWallerEntity(walletId);</span><br><span class="line">        <span class="type">VirtualWallet</span> <span class="variable">wallet</span> <span class="operator">=</span> convert(wallerEntity);</span><br><span class="line">        wallet.credit(amount);</span><br><span class="line">        walletRepo.updateBalance(walletId, wallet.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录交易信息</span></span><br><span class="line">        <span class="type">VirtualWalletTransactionEntity</span> <span class="variable">transactionEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualWalletTransactionEntity</span>();</span><br><span class="line">        transactionEntity.setAmount(amount);</span><br><span class="line">        transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">        transactionEntity.setType(TransactionType.TRANSFER);</span><br><span class="line">        transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">        transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">        transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行账户出/入账操作</span></span><br><span class="line">        debit(fromWalletId, amount);</span><br><span class="line">        credit(toWalletId, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    看了上面的代码，你应该会发现，在领域模型 VirtualWallet 类也并没有很丰满，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大的优势。你想的没错！这也正是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这时候，我们重新来看一下 VirtualWallet 类的实现代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWallet</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">createTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isAllowedOverdraft</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 是否允许透支</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">overdraftAmount</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">frozenAmount</span> <span class="operator">=</span> BigDecimal.ZERO; <span class="comment">// 冻结金额</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VirtualWallet</span><span class="params">(Long preAllocatedId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = preAllocatedId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">freeze</span><span class="params">()</span> (BigDecimal amount)&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfreeze</span><span class="params">()</span> (BigDecimal amount)&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseOverdraftAmount</span><span class="params">()</span> (BigDecimal amount)&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseOverdraftAmount</span><span class="params">()</span> (BigDecimal amount)&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeOverdraft</span><span class="params">()</span> ()&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openOverdraft</span><span class="params">()</span> ()&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getAvailableBalance</span><span class="params">()</span>&#123; <span class="comment">// 获取可用余额</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalAvailableBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance.subtract(frozenAmount);</span><br><span class="line">        <span class="keyword">if</span> (isAllowedOverdraft)&#123;</span><br><span class="line">            totalAvailableBalance += <span class="built_in">this</span>.overdraftAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalAvailableBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance.compareTo(amount) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSufficientBalanceException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.subtract(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(BigDecimal amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.add(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>领域模型 VirtualWallet 类添加了简单的冻结和透支逻辑之后，功能就看起来丰富了很多，代码也没有那么单薄了。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号自动生成的逻辑（而不是通过构造函数从外部传入ID，而是通过分布式ID算法来自动生成ID）等等。VirtualWallet 类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。</p>
<h2 id="辩证思考与灵活应用"><a href="#辩证思考与灵活应用" class="headerlink" title="辩证思考与灵活应用"></a>辩证思考与灵活应用</h2><p>对于虚拟钱包系统设计的两种开发模式的代码实现，相信你应该已经有一个比较清晰的了解了。不过，我觉得还有两个问题值得讨论一下。</p>
<p><strong>【问题一】在居于充血模型的DDD开发模式中，将业务逻辑移动到Domain中，Service类就会变得很单薄，但在我们的代码设计与实现中，并没有完全将Service类去掉，这是为什么？或者说，Service类在这种情况下担当的职责是神？哪些功能逻辑会放到Service类中？</strong></p>
<p>区别于 Domain 的职责，Service 类主要有下面这样几个职责。</p>
<ol>
<li><p>Service 类负责与 Repository 交流。在我的设计与代码实现中，VirtualWalletService 负责与 Repository 层打交道，调用 Repository 类的方法，获取数据库中的数据，转换成领域模型 VirtualWallet，然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用 Repository 类的方法，将数据存回数据库。</p>
<p> 之所以让 VirtualWalletService 类域 Repository 层打交道，而不是让领域模型 VirtualWallet 直接与 Repository 打交道，那是因为我们想保持领域模型的独立性，不与任何其它层的代码（Repository 层的代码）或开发框架（比如Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从DB中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。</p>
</li>
<li><p> Service 类负责跨领域模型的业务聚合功能。VirtualWalletService 类中的 transfer() 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，我们暂且把转账业务放到 VirtualWalletService 类中了。当然，随着功能演进，使得转账业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型。</p>
</li>
<li><p> Service 类负责一些非功能性及与第三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其它系统的 RPC 接口等，都可以放到 Service 类中。</p>
</li>
</ol>
<p><strong>【问题二】在基于充血模型的DDD开发模式中，尽管Service层被改造成了充血模型，但是Controller层和Repository层还是贫血模型，是否有必要也进行充血领域建模呢？</strong></p>
<p>答案是没有必要。Controller层主要负责接口的暴露，Repository层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没有必要做充血模型，即使设计成充血模型，类也非常单薄，看起来也很奇怪。</p>
<p>尽管这样的设计是一种面向过程的编程风格，但是只要我们控制好面向过程编程的副作用，照样可以开发出优秀的软件。那这里的副作用怎么控制呢？</p>
<p>就拿Repository的Entity来说，即便它被设计成贫血模型，违反面向对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。一般来讲，我们把它传递到 Service 层之后，就会转换成 BO 或 Domain 来继续后面的业务逻辑。Entity 的生命周期到此就结束了，所以也并不会被导出任意修改。</p>
<p>我们再来说说 Controller 层的 VO。实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输载体，将数据发送给其它系统，从功能上来讲，它不应该包含业务逻辑，只包含数据。所以，我们将它设计成贫血模型也是比较合理的。</p>
<hr>
<h1 id="13-实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析"><a href="#13-实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析" class="headerlink" title="13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析"></a>13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析</h1><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。在前面的章节中，我们主要介绍了这三者相关的方法论，目的是为了能让你先有一个宏观的了解，知道什么是 OOA、OOD、OOP。不过，光直到“是什么”是不够的，我们更重要的还是要知道“如何做”，也就是，如何进行面向对象分析、设计与编程。</p>
<p>大部分的初级开发工程师，本身并没有太多的项目经验，或者参与的项目都是基于框架填写 CRUD 模板似的代码，导致分析、设计能力比较欠缺。当他们拿到一个比较笼统的开发需求的时候，往往不知道从何入手。</p>
<p>对于“如何做需求分析，如何做职责划分？需要定义哪些类？每个类应该具有哪些属性、方法？类与类之间应该如何交互？如何组装类成为一个可执行的程序？”等等诸多问题，都没有清晰的思路，更别提利用成熟的设计原则、思想或者设计模式，开发出具有高内聚低耦合、易扩展、易读等优秀特性的代码了。</p>
<p>所以，接下来的两节课时间，我们将结合一个真实的开发案例，从基础的需求分析、职责划分、类的定义、交互、组装运行讲起，将最基础的面向对象分析、设计、编程的套路给你讲清楚，为后面学习设计原则、设计模式打好基础。</p>
<h2 id="案例介绍和难点剖析"><a href="#案例介绍和难点剖析" class="headerlink" title="案例介绍和难点剖析"></a>案例介绍和难点剖析</h2><p>假设，你正在参与开发一个微服务。微服务通过HTTP协议暴露接口给其它系统调用，也就是其它系统通过 URL 来调用微服务的接口。某天，你的 Leader 找到你说：为了保证接口调用的安全性，我们希望设计一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。</p>
<p>Leader 丢下这句话就走了。这个时候，你该如何来做呢？是不是脑子里一团浆糊，一时间无从下手。为什么会有这种感觉呢？我个人觉得主要有以下两点原因。</p>
<ol>
<li> <strong>需求不明确</strong></li>
</ol>
<p>Leader 给的需求过于模糊、笼统、不够具体、细化，离落地到设计、编码还有一定的距离。而人的大脑不擅长思考这种过于抽象的问题。这也是真实软件开发区别于应试教育的地方。应试教育中的考试题目，一般都是一个非常具体的问题，我们去解答就好了。而真实的软件开发中，需求几乎都不明确。</p>
<p>我们前面讲过，面向对象分析主要分析的对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”。实际上，不管是需求分析还是面向对象分析，我们首先要做的就是将笼统的需求细化到足够清晰、可执行。我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑的。</p>
<ol start="2">
<li> <strong>缺少锻炼</strong></li>
</ol>
<p>相比于单纯的业务CRUD开发，鉴权这个开发任务，要更有难度。鉴权作为一个跟具体业务无关的功能，我们完全可以把它开发成一个独立的框架，集成到很多业务系统中。而作为被很多系统复用的通用框架，比起普通的业务代码，我们对框架的代码质量要求更高。</p>
<p>开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力、甚至罗辑思维能力的要求，都是比较高的。如果你平时做的都是简单的 CRUD 业务开发，一旦遇到这种开发需求，很容易因为缺少锻炼，不知道从何入手，完全没有思路。</p>
<h2 id="对案例进行需求分析"><a href="#对案例进行需求分析" class="headerlink" title="对案例进行需求分析"></a>对案例进行需求分析</h2><p>实际上，需求分析的工作很琐碎，也没有太多固定的章法可寻，所以，我们不打算在这里讲很多那些听着有用、实际没用的方法论，而是希望通过鉴权这个例子，来给你展示一下，面对需求分析的时候，我的完整的思考路径是什么样的。希望你能自己去体会，举一反三地类比应用到其它项目的需求分析中。</p>
<p>尽管针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求，但这不代表我们就可以脱离具体的应用场景，闷头拍脑袋做分析。多跟业务团队沟通，甚至自己去参与几个业务系统的开发，只有这样，我们才能真正知道业务系统的痛点，才能分析出最有价值的需求。不对，针对鉴权这一功能的开发，最大的需求方还是我们自己，所以，我们也可以先从满足我们自己系统的需求开始，然后再迭代优化。</p>
<p>现在，我们来看一下，针对鉴权这个功能的开发，我们应该如何做需求分析？</p>
<p>实际上，这跟做算法题一样，先从简单的方案想起，然后再优化。所以，我把整个分析过程分为了循序渐进的四轮。每一轮都是对上一轮的迭代优化，最终形成一个可执行、可落地的需求列表。</p>
<h3 id="1、第一轮需求分析"><a href="#1、第一轮需求分析" class="headerlink" title="1、第一轮需求分析"></a>1、第一轮需求分析</h3><p>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过“用户名+密码”来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。如果一致，说明请求成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<h3 id="2、第二轮分析优化"><a href="#2、第二轮分析优化" class="headerlink" title="2、第二轮分析优化"></a>2、第二轮分析优化</h3><p>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。那如果我们借助加密算法（比如SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？实际上，这样也是不安全的，因为加密之后的密码和 AppID，照样可以被未认证系统（或者说黑客）截获，未认证系统就可以携带这个加密之后的密码以及对应的 AppID，伪装成已认证系统来访问我们的所有接口。这就是典型的“<strong>重放攻击</strong>”。</p>
<p>提出问题，然后再解决问题，这是一个非常好的迭代优化方法。对于刚刚这个问题，我们可以借助 OAuth 的验证思路来解决。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后再进行加密，生成一个 token。调用方在进行接口请求的时候，将这个 token 及 AppID，随 URL 一起传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法用 URL、AppID、密码生成另外一个 token。用这个新生成的 token 跟调用方传递过来的 token 进行比对。如果一致，则运行接口调用请求，否则，就拒绝接口调用请求。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322125659233.png" alt="image-20220322125659233"></p>
<h3 id="3、第三轮分析优化"><a href="#3、第三轮分析优化" class="headerlink" title="3、第三轮分析优化"></a>3、第三轮分析优化</h3><p>不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个 URL 拼接上 AppID、密码后生成的 token 都是固定的。未认证系统截获到 URL、AppID 和 token 之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个 URL <strong>对应</strong>的接口。 只不过此时未认证系统不能像之前一样在获取到 AppID 和密码后，一次性访问微服务端的所有接口罢了。但它还是可以通过多次拦截、记录，最终获取到所有接口的访问权限。</p>
<p>为了解决这个问题，我们可以进一步优化 token 生成算法，引入一个随机变量，让每次接口请求生成的 token 都不一样。我们可以选择时间戳作为随机变量。原来的 token 是对 URL、AppID、密码三者进行加密生成的，现在我们将 URL、AppID、密码、时间戳四者进行加密来生成 token。调用方在进行接口请求的时候，将 token、AppID、时间戳、随 URL 一并传递给微服务端。</p>
<p>微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过一分钟，则判定 token 过期，拒绝接口请求。如果没有超过一分钟，则说明 token 没有过期，就再通过同样的 token 算法，在服务端生成新的 token，与调用方的传递过来的 token 比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<p>优化之后的认证流程如下图所示：</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322155801827.png" alt="image-20220322155801827"></p>
<h3 id="4、第四轮分析优化"><a href="#4、第四轮分析优化" class="headerlink" title="4、第四轮分析优化"></a>4、第四轮分析优化</h3><p>不过，你可能还会说，这样还是不够安全啊。未认证系统还是可以在这一分钟的 token 失效窗口内，通过截获请求、重放请求，来调用我们的接口啊。</p>
<p>你说的没错。不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。</p>
<p>实际上，还有一个细节我们没有考虑到，那就是，如何在微服务端存储每个授权调用方的 AppID 和密码。当然，这个问题并不难。最容易想到的方案就是存储到数据库里，比如 MySQL。不过，开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。</p>
<p>针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。<u>我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</u></p>
<h3 id="5、最终确定需求"><a href="#5、最终确定需求" class="headerlink" title="5、最终确定需求"></a>5、最终确定需求</h3><p>到此，需求已经足够细化和具体了。现在，我们按照鉴权的流程，对需求再重新描述一下。如果你熟悉 UML，也可以用时序图、流程图来描述。不过，用什么描述不是重点，描述清楚才是最重要的。下面我会给出一个文字版本的流程描述。</p>
<ol>
<li> 调用方法进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。</li>
<li> 微服务端在接收到调用方的接口请求后，从请求中拆解出 token、AppID、时间戳。</li>
<li> 微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li>
<li> 如果 token 验证没有过期，微服务端再从自己的存储中，取出与 AppID 对应的密码。通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配。如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</li>
</ol>
<p>这就是我们需求分析的整个思考过程，从最粗糙、最模糊的需求开始，通过“提出问题-解决问题”的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。</p>
<h1 id="14-实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"><a href="#14-实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？" class="headerlink" title="14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？"></a>14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？</h1><p>在上一节课中，针对接口鉴权功能的开发，我们讲了如何进行面向对象分析（OOA），也就是需求分析。实际上，需求定义清楚之后，这个问题就已经解决一大半了。今天，我们再来看一下，针对面向对象分析产出的需求，如何来进行面向对象设计（OOD）和面向对象编程（OOP）。</p>
<h2 id="如何进行面向对象设计？"><a href="#如何进行面向对象设计？" class="headerlink" title="如何进行面向对象设计？"></a>如何进行面向对象设计？</h2><p>我们知道，<u>面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。</u>在面向对象设计环节，我们将需求描述转换为具体的类的设计。我们把这一环节拆解以下，主要包含以下几个部分：</p>
<ul>
<li>  划分职责进而识别出有哪些类；</li>
<li>  定义类及其属性和方法；</li>
<li>  定义类与类之间的交互关系；</li>
<li>  将类组装起来并提供执行入口。</li>
</ul>
<h3 id="1、划分职责进而识别出有哪些类"><a href="#1、划分职责进而识别出有哪些类" class="headerlink" title="1、划分职责进而识别出有哪些类"></a>1、划分职责进而识别出有哪些类</h3><p>在面向对象有关的书籍中经常讲到，类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都能与现实世界中的事务一一对应。对于一些抽象的概念，我们是无法通过映射现实世界中的事物的方式来定义类的。</p>
<p>所以，大多数面向对象的书籍中，还会讲到另一种识别类的方法，<u>那就是把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。</u>对于没有经验的初学者来说，这个方法比较简单、明确，可以直接照着做。</p>
<p>不过，我更喜欢另一个方法，那就是根据需求的描述，把其中涉及的功能点，一个一个罗列出来，然后再去查看哪些功能点的职责相近，操作同样的属性，是否应该归为同一个类。我们来看一下，针对鉴权这个例子，具体应该如何来做。</p>
<p>在上一节课中，我们已经做出了详细的需求描述，具体描述如下：</p>
<blockquote>
<ol>
<li> 调用方法进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。</li>
<li> 微服务端在接收到调用方的接口请求后，从请求中拆解出 token、AppID、时间戳。</li>
<li> 微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li>
<li> 如果 token 验证没有过期，微服务端再从自己的存储中，取出与 AppID 对应的密码。通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配。如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</li>
</ol>
</blockquote>
<p>首先，我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能要尽可能的小。每个功能只负责做一件很小的事情，符合单一职责原则。下面是我逐句拆解上述需求描述之后，得到的功能点列表。</p>
<ol>
<li> 把 AppID、密码、时间戳、URL 拼接成一个字符串；</li>
<li> 对字符串进行加密生成 token；</li>
<li> 将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li>
<li> 解析 URL，得到 token、AppID、时间戳等信息；</li>
<li> 校验 token 是否失效</li>
<li> 从存储中取出 AppID 和对应的密码</li>
<li> 验证两个 token 是否匹配。</li>
</ol>
<p>从上面的功能列表中，我们发现，1、2、5、7 都跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略的得到三个核心类：AuthToken、Url、CredentialStorage。</p>
<p>当然，这是一个初步的类的划分，其它一些不重要的、边边角角的类，我们可能暂时没办法一下子想全，但这也没有关系，面向对象分析、设计、编程本来就是一个循环迭代、不断优化的过程。根据需求，我们先给出一个粗糙版本的设计方案，然后基于这样一个基础，再去迭代优化，会更容易一些，思路也会更加清晰一些。</p>
<p>不过，我还要再强调一点，接口调用鉴权这个开发需求比较简单，所以，需求对应的面向对象设计并不复杂，识别出来的类也并不多。但如果我们面对的是更加大型的软件开发、更加复杂的需求开发，涉及的功能点可能会很多，对应的类也会比较多，像刚刚那样根据需求逐句罗列功能点的方法，最后会得到一个长长的列表，就会优点凌乱、没有规律。针对这种复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路。</p>
<h3 id="2、定义类及其属性和方法"><a href="#2、定义类及其属性和方法" class="headerlink" title="2、定义类及其属性和方法"></a>2、定义类及其属性和方法</h3><p>刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是 AuthToken、Url 和 CredentialStorage。现在我们来看下，每个类都有哪些属性和方法。</p>
<p><strong>AuthToken 类相关的功能点有四个：</strong></p>
<ul>
<li>  把 AppID、密码、时间戳、URL 拼接成一个字符串；</li>
<li>  对字符串进行加密生成 token；</li>
<li>  校验 token 是否失效；</li>
<li>  验证两个 token 是否匹配。</li>
</ul>
<p>对于方法的识别，很多面向对象的书籍中一般都是这么讲的，<u>识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。</u>类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。</p>
<p>借用这个思路，根据功能点描述，识别出来 AuthToken 类的属性和方法如下图所示。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322171228516.png" alt="image-20220322171228516"></p>
<p>从上面的类图中，我们可以发现这样几个小细节：</p>
<ol>
<li> 并不是所有的名字都被定义为了类的属性，比如 URL、AppID、密码、时间戳这几个名词，我们把它作为了方法的参数。</li>
<li> 我们还需要挖掘一些没有出现在功能点描述中的属性，比如 createTime，expireTimeInterval，它用在 isExpired() 函数中，用于判定 token 是否过期。</li>
<li> 我们还给 AuthToken 类添加了一个功能点描述中没有提到的方法 getToken()。</li>
</ol>
<p>第一个细节告诉我们，从业务模型上来说，不该属于这个类的属性和方法，不应该被放到这个类里。比如 URL、AppID 这些信息，从业务模型上来说，不应该属于 AuthToken，所以我们不应该放到这个类中。</p>
<p>第二、三个细节告诉我们，在设计类具有哪些属性和方法时，不能单纯地依赖当下的需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证类定义的完整性，另一方面不仅为当下的需求还为未来的需求做准备。</p>
<p><strong>Url 类相关的功能点有两个</strong></p>
<ul>
<li>  将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；</li>
<li>  解析 URL，得到 token、AppID、时间戳等信息；</li>
</ul>
<p>虽然需求描述中，我们都是以 URL 来代指接口请求，但是，接口请求并不一定是以 URL 的形式表达，还有可能是 Dubbo RPC 等其它形式。为了让这个类更加通用，命名更加贴切，我们把它命名为 ApiRequest。下面是我根据功能点设计的 ApiRequest 类。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322174037460.png" alt="image-20220322174037460"></p>
<p><strong>CredentialStorage 类相关的功能点只有一个：</strong></p>
<ul>
<li>  从存储中取出 AppID 和对应的密码</li>
</ul>
<p>CredentialStorage 类非常简单，类图如下所示。为了做到抽象封装具体的存储方式，我将 CredentialStorage 设计成了接口，基于接口编程而非具体的实现编程。</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322174247140.png" alt="image-20220322174247140"></p>
<h3 id="3、定义类与类之间的交互关系"><a href="#3、定义类与类之间的交互关系" class="headerlink" title="3、定义类与类之间的交互关系"></a>3、定义类与类之间的交互关系</h3><p>类与类之间存在哪些交互关系呢？UML统一建模语言中定义了六种类之间的关系。分别是：泛化、实现、关联、聚合、组合、依赖。关系比较多，而且有些还比较相近，比如聚合和组合，下面我们逐一讲解一下。</p>
<ul>
<li>  <strong>泛化（Generalization）</strong>可以简单理解为继承关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>实现（Realization）</strong>一般是指接口和实现类之间的关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>聚合（Aggregation）</strong>是一种包含关系，A类对象包含B类对象，B类对象的生命周期可以不依赖A类对象的生命周期，也就是说可以单独销毁A类对象而不影响B类对象。比如课程和学生之间的关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>组合（Composition）</strong>也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖于A类对象的生命周期，B类对象不可单独存在，比如鸟与翅膀的关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>关联（Association）</strong>是一种非常弱的关系。包含聚合、组合两种关系。具体到代码层面，如果B类对象是A类的成员变量，那B类和A类就是关联关系。具体到Java代码就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>依赖（Dependency）</strong>是一种比关联关系更加弱的关系，包含关联关系。不管B类对象是A类对象的成员变量，还是A类的方法使用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，我们都称它们有依赖关系。具体到Java代码中就是下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(B b)</span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于UML六种关系的详细介绍，我个人觉得这样拆分有点太细，增加了学习成本，对于指导编程开发没有太大意义。所以，我们从更加贴近编程的角度，对类与类之间的关系做了调整，只保留了四个关系：泛化、实现、组合、依赖。</p>
<p>其中，泛化、实现、依赖的定义不变，组合关系替代UML中的组合和聚合两个概念。之所以这样重新命名，是为了跟我们前面讲的“多用组合少用继承”设计原则中的“组合”统一含义。只要B类是对象是A类对象的成员变量，那我们就称，A类跟B类是组合关系。</p>
<p>理论的东西讲完了，让我们来看一下，刚刚我们定义的类之间都有哪些关系呢？因为目前只有三个核心的类，所以只用到了实现关系，也即 CredentialStorage 和 MysqlCredentialStorage 之间的关系。接下里讲到组装类的时候，我们还会用到依赖关系、组合关系，但是泛化关系暂时没有用到。</p>
<h3 id="4、将类组装起来并提供执行入口"><a href="#4、将类组装起来并提供执行入口" class="headerlink" title="4、将类组装起来并提供执行入口"></a>4、将类组装起来并提供执行入口</h3><p>类定义好了，类之间必要的交互关系也设计好了，接下来我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p>
<p>接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件。所以，我们封装所有的实现细节，设计了一个最顶层的 ApiAuthencator 接口类，暴露一组给外部调用者使用的 API 接口，作为触发执行鉴权逻辑的入口。具体的类的设计如下所示：</p>
<p><img src="/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part2%EF%BC%89/image-20220322185107325.png" alt="image-20220322185107325"></p>
<hr>
<h1 id="15-理论一：对于单一职责原则，如何判断某个类的职责是否足够“单一”？"><a href="#15-理论一：对于单一职责原则，如何判断某个类的职责是否足够“单一”？" class="headerlink" title="15 | 理论一：对于单一职责原则，如何判断某个类的职责是否足够“单一”？"></a>15 | 理论一：对于单一职责原则，如何判断某个类的职责是否足够“单一”？</h1><p>前面几节课，我们介绍了面向对象相关的知识。从今天起，我们开始学习一些经典的设计原则，其中包括，SOLID、KISS、YAGNI、DRY、LOD 等。</p>
<p>对于这些设计原则，三句话总结就是：一看就懂，一学就会，一用就懵。</p>
<p>这些原则从字面上理解都不难，但真正用到项目中的时候，你会发现，“看懂”和“会用”是两回事，而“用好”更是难上加难。如果对这些原则理解得不够透彻，会在使用的时候过于教条主义，拿原则当真理，生搬硬套，反而会适得其反。</p>
<p>所以，在接下来的学习中，我们的目的不仅仅是记住这些原则的定义，更重要的是要理解这些原则设计的初衷，能解决哪些问题，有哪些应用场景等。要知其然亦知其所以然，做到真正的活学活用。</p>
<h2 id="如何理解单一职责原则（SRP）"><a href="#如何理解单一职责原则（SRP）" class="headerlink" title="如何理解单一职责原则（SRP）"></a>如何理解单一职责原则（SRP）</h2><p>上面提到的 SOLID 原则，实际上是5个设计原则的合称。它们分别是：</p>
<blockquote>
<ul>
<li>  S：单一职责原则；Single Repository Principe；SRP</li>
<li>  O：开闭原则；Open Closed Principe；OCP</li>
<li>  L：里氏替换原则；L Substitution Principe；LSP</li>
<li>  I：接口隔离原则：Interface Segregation Principe</li>
<li>  D：依赖反转原则；</li>
</ul>
</blockquote>
<p>SRP 的英文描述是“A class or module should have a single reponsibility”，翻译过来就是“一个类或模块应该只负责完成一个功能”。</p>
<p>注意，原文中描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念，你其实可以把模块理解成比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。为了方便你理解，接下来我们将只从“类”设计的角度，来讲解如何应用这个设计原则，你可以类比着引申到“模块”中。</p>
<p>单一职责原则的定义描述非常简单，一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p>
<p>我们举个例子来解释一下，比如：一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。为了满足单一职责原则，我们需要将这个类拆分成两个粒度更细、功能更加单一的两个类：订单类和用户类。</p>
<h2 id="如何判断类的职责是否够单一？"><a href="#如何判断类的职责是否够单一？" class="headerlink" title="如何判断类的职责是否够单一？"></a>如何判断类的职责是否够单一？</h2><p>从刚刚这个例子来看，单一职责原则看似不难应用。那是因为我举的这个例子比较简单，一眼就能看出订单和用户毫不相关。但是大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。在真实的软件开发中，对于一个类是否职责单一的判定，是很难界定的。</p>
<p>比如，在一个社交产品中，我们用下面的 UserInfo 来记录用户的信息。你觉得 UserInfo 类的设计是否满足单一职责原则呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lastLoginTime;</span><br><span class="line">    <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">    <span class="keyword">private</span> String provinceOfAddress;</span><br><span class="line">    <span class="keyword">private</span> String cityOfAddress;</span><br><span class="line">    <span class="keyword">private</span> String regionOfAddress;</span><br><span class="line">    <span class="keyword">private</span> String detailedAddress;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个问题，有两种不同的观点。一种观点是：UserInfo 类包含的都是用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则。另一种观点是：地址信息在 UserInfo 类中所占的比重较高，可以继续拆分成独立的 UserAddress 类，UserInfo 只保留除 Address 之外的其它信息，拆分之后两个类的职责更加单一。</p>
<p>哪种观点更对呢？实际上，要从中作出选择，我们不能脱离具体的应用场景。如果在这个社交产品中，用户的地址信息跟其它信息一样，只是单纯地用来展示，那 UserInfo 现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从 UserInfo 中拆分出来，独立成用户物流信息（或叫地址信息、收货信息等）。</p>
<p>我们再进一步延伸一下。如果这个做社交产品的公司发展的越来越好，公司内部又开发出了许多其它产品。公司希望支持统一账号系统，也就是用户一个账号可以登录公司研发的所有产品。这个时候，我们就需要继续对 UserInfo 进行拆分，将跟用户身份认证相关的信息（比如 email、telephone等）抽取成独立的类。</p>
<p>从刚刚这个例子，我们可以总结出，不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。在某种应用场景下或者当前的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或者在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。</p>
<p>除此之外，从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。比如，例子中的 UserInfo 类。如果我们从“用户”这个业务层面来看，UserInfo 包含的信息都属于用户，满足单一职责原则。如果我们从更加细分的“用户展示信息”、“地址信息”、“登录认证信息”等等这些更细粒度的业务层面来看，那 UserInfo 就应该继续拆分。</p>
<p>综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、见仁见智的事情。实际上，在真正的软件开发中，我们也没有必要过于未雨绸缪，过度设计。所以，<strong>我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。</strong></p>
<p>讲到这里，那你可能又有点儿懵了。这个原则如此含糊不清，模棱两可，那到底该如何把握呢？下面我将介绍一些常用的小技巧，可以帮助你从侧面上判定一个类的职责是否足够单一。下面这几条原则，比起主观地去思考类是否职责单一，要更有指导意义、更具有可执行性。</p>
<ul>
<li>  如果类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分。</li>
<li>  类依赖的其它类过多，或者依赖类继续依赖的其它类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分。</li>
<li>  私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性。</li>
<li>  比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰。</li>
<li>  类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。</li>
</ul>
<h2 id="类的职责是否设计得越单一越好？"><a href="#类的职责是否设计得越单一越好？" class="headerlink" title="类的职责是否设计得越单一越好？"></a>类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细越好呢？答案是否定的。我们还是通过一个例子来说明。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Serialization</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">textBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">        textBuilder.append(gson.toJson(object));</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">deserialize</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING))&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gsonStr</span> <span class="operator">=</span> text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(gsonStr, Map.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想让类的职责更加单一，我们对 Serialization 类进一步拆分，拆分成一个只负责序列化工作的 Serializer 类和另一个只负责反序列化工作的 Deserializer 类。拆分后的具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Serialization</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">textBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">        textBuilder.append(gson.toJson(object));</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deserializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Serialization</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">deserialize</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING))&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gsonStr</span> <span class="operator">=</span> text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(gsonStr, Map.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，虽然经过拆分后，Serializer 类和 Deserializer 类的职责更加单一了，但也随之带来了新的问题。如果我们修改了协议的格式，数据表示从 “UEUEUE” 改为 “DFDFDF”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来的 Serialization 类高了。而且，如果我们仅仅对 Serializer 类做了协议修改，而忘记修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。</p>
<p>实际上，不管是设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个具体的设计原则是否合理的时候，也可以以此作为最终的考量标准。</p>
<hr>
<h1 id="16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h1><p>今天我们继续来学习 SLOID 中的第二个原则：开闭原则。可以说，开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。</p>
<p>之所以说这条原则难理解，那是因为：</p>
<blockquote>
<ul>
<li>  怎样的代码改动才被定义为“扩展”’？</li>
<li>  怎样的代码改动才被定义为“修改”？</li>
<li>  怎么才算满足或违反“开闭原则”？</li>
<li>  修改代码就一定意味着违反“开闭原则”吗？</li>
</ul>
</blockquote>
<p>等等这些问题，都比较难理解。</p>
<p>之所以说这条原则难掌握，那是因为：</p>
<blockquote>
<ul>
<li>  如何做到“对扩展开放、修改关闭”？</li>
<li>  如何在项目中灵活地应用“开闭原则”，以免在追求扩展性的同时影响到代码可读性？</li>
</ul>
</blockquote>
<p>等等这些问题，都比较难掌握。</p>
<p>之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。</p>
<p>所以说，学好“开闭原则”非常重要。</p>
<h2 id="如何理解“对扩展开放，修改关闭”？"><a href="#如何理解“对扩展开放，修改关闭”？" class="headerlink" title="如何理解“对扩展开放，修改关闭”？"></a>如何理解“对扩展开放，修改关闭”？</h2><p>开闭原则，Open Closed Principe（OCP），它的英文描述是：software entities（modules，classes，functions，etc.） should be open for extension，but closed for modification。翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p>
<p>这个描述比较简单。如果我们详细</p>
<hr>
<h1 id="17-理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？"><a href="#17-理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？" class="headerlink" title="17 | 理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？"></a>17 | 理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？</h1><p>今天，我们继续学习“SOLID ”中的“L”，即里氏替换原则。整体上来讲，这个设计原则是比较简单的。但是这条原则从定义上来看，跟“多态”有点类似，所以我们学习的重点是通过一些例子，将它跟多态区分开来。</p>
<h2 id="如何理解“里氏替换原则”？"><a href="#如何理解“里氏替换原则”？" class="headerlink" title="如何理解“里氏替换原则”？"></a>如何理解“里氏替换原则”？</h2><p>里氏替换原则是由 Liskov 提出的，并冠以他自己的名字，Liskov Substitution Principe（LSP）。这条原则的英文描述是：</p>
<blockquote>
<p>  If S is subtype of T，then objects of type T may be replaced with objects of type S, without breaking the program。</p>
</blockquote>
<p>翻译过来就是：在不破坏原来程序逻辑的情况下，子类对象需要能够在程序中的任何地方替换父类对象。</p>
<p>这么说比较抽象，我们继续通过一个例子来理解一下。如下代码中，父类 Transporter 使用 HttpClient 来传输网络数据。子类 SecurityTransporter 继承父类 Transporter，增加了额外的功能，支持传输 appId 和 appToken 安全认证信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(HttpClient httpClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.httpClient = httpClient;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span>&#123;</span><br><span class="line">        <span class="comment">// use httpClient to send request...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="keyword">private</span> String appToken;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(httpClient);</span><br><span class="line">        <span class="built_in">this</span>.appId = appId;</span><br><span class="line">        <span class="built_in">this</span>.appToken = appToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果request中不含appId和appToken，该方法与父类sendRequest方法的功能完全一样</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken))&#123;</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Transporter transporter)</span> &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>();</span><br><span class="line">        <span class="comment">// 省略设置request中数据值的代码</span></span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> transporter.sendRequest(request);</span><br><span class="line">        <span class="comment">// 省略其它逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LSP原则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    demo.fun(<span class="keyword">new</span> <span class="title class_">SecurityTransporter</span>(<span class="comment">/*省略参数*/</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，子类 SecurityTransporter 的设计完全符合 LSP 原则，子类对象可以替换父类出现的任何位置，并且原来代码的逻辑行为不变，正确性也没有被破坏。</p>
<p>【问题】不过，你可能会有这样的疑问，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里氏替换说的是不是一回事呢？从刚刚的例子和定义描述来看，它们的确很相似，但究其本质，它们完全是两回事。为什么这么说呢？</p>
<p>我们沿用上面的例子来解释一下。我们先对 SecurityTransporter 类中的 sendRequest() 方法简单改造一下。改造前，如果请求消息中没有设置 appId 或者 appToken，我们就不做校验；改造后，如果请求消息中没有设置 appId 或者 appToken，则直接抛出 NoAuthorizationRuntimeException 未授权异常。改造前后的代码对比如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造前：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span>&#123;</span><br><span class="line">	<span class="comment">// 省略其它代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken))&#123;</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">            request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span>&#123;</span><br><span class="line">	<span class="comment">// 省略其它代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(appId) &amp;&amp; StringUtils.isBlank(appToken))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoAuthorizationRuntimeException</span>(...);</span><br><span class="line">        &#125;</span><br><span class="line">        request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">        request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在改造之后的代码中，如果传递进 fun() 函数的是父类 Transporter 对象，那 fun() 函数并不会有异常抛出， 但如果传递给 fun() 函数的是子类 SecurityTransporter 对象，那 fun() 就<u>有可能</u>有异常抛出。尽管代码中抛出的是运行时异常，我们可以不在代码中显式地捕获处理，但子类替换父类传递进 fun() 函数之后，整个程序的逻辑行为就发生了变化。</p>
<p>虽然改造之后的代码仍然可以使用 Java 的多态语法，动态地调用子类 SecurityTransporter 来替换父类 Transporter，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，SecurityTransporter 的设计是不符合 LSP 原则的。</p>
<p><strong>总结：</strong>虽然从定义描述和代码实现上来看，多态和里氏替换有点类似，但它们关注的角度是不一样的。多态是 OOP 的一大特性，也是一种 OOPL，它是一种代码实现的思路。而<u>LSP 是一种设计原则，是用来指导继承关系中子类该如何设计的原则。</u>子类的设计要保证在替换父类的时候，不改变原有程序（即父类程序）的逻辑以及不破坏原有程序的正确性。</p>
<h2 id="哪些代码明显违背了LSP？"><a href="#哪些代码明显违背了LSP？" class="headerlink" title="哪些代码明显违背了LSP？"></a>哪些代码明显违背了LSP？</h2><p>实际上，LSP 还有一个更加能落地、更具指导意义的描述，那就是“Design By Contract”，翻译成中文就是“按照协议来设计”。</p>
<p>白话一点就是：子类在设计的时候，要遵守父类的行为约定（或叫协议）。对于父类中函数定义好的行为约定，子类可以通过重写改变父类中函数的内部逻辑实现，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类的之间的关系，也可以替换成接口和实现类的关系。【比如在接口的抽象方法中，可以进行功能描述，那其实现类就应该按描述去实现这个功能。但毕竟设计原则只是一种原则，即便你不遵循也不会有语法上的错误。】</p>
<p>一句话总结就是，父类方法中说要做的（抽象方法）和已经做了的（非抽象方法）子类都得有，我不管里子一不一样，但面子必须一样。在这个基础上，子类才可以添加自己的实现逻辑。</p>
<p>下面我们来举几个违反 LSP 的例子来加深一下理解。</p>
<h3>
    1、子类违背父类声明要实现的功能
</h3>

<p>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个函数后，是按照创建日期来给订单排序的。那子类的设计就违背了 LSP。</p>
<h3>
    2、子类违背父类对输入、输出、异常的约定
</h3>

<p>在父类中，某个函数约定：运行出错时返回 null；获取数据为空时返回空集合（empty collection）。而子类重写函数后，实现变成了：运行出错返回异常（Exception），获取不到数据时返回 null。那子类的设计就违背了 LSP。</p>
<h3>
    3、子类违背父类注释中所罗列的任何特殊说明
</h3>

<p>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额”，而子类重写 withdraw() 函数之后，针对 VIP 账户实现了透支提现的功能，也就是提现金额可以大于账户金额，那这个子类的设计也是不符合 LSP 的。</p>
<p>但是，如果你把父类中 withdraw() 方法注释修改为“提现”，不加任何限制，在子类中除了提供父类原有的功能外，新增实现了关于 VIP 用户的透支提现功能，那这是符合 LSP 的。</p>
<p>事实上，你有没有发现，LSP 这个原则是非常宽松的。一般情况下，我们写的代码都不怎么会违背它。所以，只要你能看懂上面讲的这些，这个原则就不难掌握，也不难应用。</p>
<hr>
<h1 id="18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"><a href="#18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？" class="headerlink" title="18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"></a>18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</h1><p>接口隔离原则对应 SOLID 中的“I”，Interface Segregation Principe（ISP）。它的一种英文定义是这样的</p>
<blockquote>
<p>  Clients should not be forced to depend upon interfaces that they do not use。</p>
</blockquote>
<p>翻译过来就是：客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，我们可以理解成接口调用者。</p>
<h3>如何理解接口隔离原则？

<p>理解接口原则的关键在于理解其中的“接口”二字。实际上，“接口”这个名词可以用在很多场合中，在软件开发中，我们既可以把它看做是一组抽象的约定，也可以具体指系统与系统之间的 API 接口，还可以特指 OOPL 中的接口等。</p>
<p>在这条原则中，我们可以把“接口”理解成下面三样东西：</p>
<ul>
<li>  一组 API 接口集合</li>
<li>  单个 API 接口或函数</li>
<li>  OOP 中接口的概念</li>
</ul>
<p>接下来，我们就按照这三种理解方式来详细讲一下，在不同的场景下，这条原则是如何解读和应用的。</p>
<h3> 把“接口”理解为一组 API 接口集合

<p>我们通过一个例子来讲解。微服务用户系统提供了一组跟用户相关的 API 给其它系统使用，比如：注册、登录、获取用户信息等。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户功能的接口。</p>
<p>当然，这个需求很简单。我们只需要在 UserService 接口中添加一个 deleteUserById() 或 deleteUserByCellphone() 方法就可以了。这的确可以解决问题，但是这样的添加方式也隐藏了一些安全隐患，不知道你发现了没有？</p>
<p>删除用户是一个非常慎重的操作，一般情况下，我们只希望通过后台管理系统来执行这个操作，所以这个接口最好只限定于给后台管理系统使用。如果我们把删除用户的方法放在 UserService 中，那所有使用到 UserService 的系统就都可以调用这个接口了，即使除了后台管理系统，其它系统本来就不需要这个接口。如果不加限制地被其它业务系统调用，就会导致误删用户的概率大大提高。</p>
<p>当然，最好的解决方案是从架构设计的层面，通过鉴权的方式来限制接口的调用。不过，我们还可以继续从代码设计的层面，来尽量避免接口被误用的概率，达到多重防护的效果。</p>
<p>我们参照接口隔离原则，调用者不应该被强迫依赖它不需要的接口（其实在这个例子中说的接口就是方法），将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只提供给后台管理系统来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RestrictedUserService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUserById</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUserByCellphone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>, RestrictedUserService &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚刚的这个例子中，我们把 ISP 中的“接口”理解为一组接口（或者叫函数）集合。它可以是某个微服务的接口，也可以是某个类库的接口。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其它调用者也依赖这部分不会被用到的接口。</p>
<h3>把“接口”理解成单个 API 接口或函数

<p>现在我们再换一种理解方式，把接口理解为单个接口或函数（为了方便讲解，下面将都简称为“函数”）。</p>
<p>那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。</p>
<p>其实可以想到的是，函数的功能越复杂，其复用性就越差，因为不会有很多地方都要使用特别复杂的功能。一般而言，复杂功能都是通过简单功能堆叠实现的，而不是直接实现一个非常复杂的功能。所以，你如果在某一个小单元内写了一段非常复杂的代码，实现了很多功能，但是每次调用的时候可能只是使用了其中一个或很少几个功能，那大多数的功能是用不到的，这也就相当于调用者 Client 虽然没用到，但是这个小单元内的程序确确实实要从头走到尾，这就相当于是一种强买强卖，是违反 ISP 的。</p>
<p>我们通过一个例子来理解一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Statistics</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> min;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> avg;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sum;</span><br><span class="line">    <span class="comment">// 省略 getter/setter/constructor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Statistics <span class="title function_">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span>&#123;</span><br><span class="line">    <span class="type">Statistics</span> <span class="variable">statistics</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Statistics</span>();</span><br><span class="line">    <span class="comment">// 省略计算逻辑</span></span><br><span class="line">    <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>接口隔离原则跟单一职责原则还有点类似，它们的区别和联系是什么？</p>
</h3></h3></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/16/%E4%B8%AD%E5%8F%B0%E5%AD%A6%E4%B9%A0%EF%BC%88Part1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/16/%E4%B8%AD%E5%8F%B0%E5%AD%A6%E4%B9%A0%EF%BC%88Part1%EF%BC%89/" class="post-title-link" itemprop="url">中台学习（Part1）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-16 20:47:35" itemprop="dateCreated datePublished" datetime="2022-03-16T20:47:35+08:00">2022-03-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/" class="post-title-link" itemprop="url">重学MySQL（Part1）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-16 13:43:05" itemprop="dateCreated datePublished" datetime="2022-03-16T13:43:05+08:00">2022-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-13 18:38:28" itemprop="dateModified" datetime="2022-04-13T18:38:28+08:00">2022-04-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="01-基础架构：一条SQL查询语句是如何执行的？"><a href="#01-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="01 | 基础架构：一条SQL查询语句是如何执行的？"></a>01 | 基础架构：一条SQL查询语句是如何执行的？</h1><p>人们经常说，看待一件事儿千万不要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从更高的维度理解问题。同样，对于 MySQL 的学习也是如此。平常我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这条查询语句的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID=10;</span><br></pre></td></tr></table></figure>

<p>我们看到的只是一条输入语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。</p>
<p>所以，今天我们要通过这条最简单的查询语句把 MySQL 拆解一下，看看里面都有哪些“零件”。借由这个拆解过程，可以让我们对 MySQL 能有更深刻的理解。这样，当我们碰到 MySQL 的一些异常或者问题时，就能够直指本质，能更快地定位并解决问题。</p>
<p>下图是 MySQL 的基本架构示意图，从中可以清楚地看到 SQL 语句在 MySQL 的各个模块中流转的过程。</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220316135623293.png" alt="image-20220316135623293"></p>
<p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p>
<ul>
<li>  Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 中大多数的核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），<u>所有跨存储引擎的功能都在这一层实现</u>，比如存储过程、触发器、视图等。</li>
<li>  而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多种存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL5.5.5 版本开始成为了默认存储引擎。</li>
</ul>
<p>也就是说，我们在执行 create table 建表的时候，如果不指定存储引擎类型，默认使用的就是 InnoDB。如果想要显式指定存储引擎，可以在 create table 语句中通过类似 <code>engine=memory</code> 的语句来指定创建表使用的存储引擎。不同存储引擎的表数据存储方式不同，支持的功能也不同，后续我们将一一深入讨论。</p>
<p>从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。接下来我们将结合开头提到的那条 SQL 语句，一起走一遍整个执行流程，捋一捋每个组件的作用。</p>
<h2 id="1、连接器"><a href="#1、连接器" class="headerlink" title="1、连接器"></a>1、连接器</h2><p>正常情况下，我们都是通过一个客户端连接到 MySQL 服务器上，去操作服务器上的数据库。</p>
<p>所以，第一步，我们首先要发送请求连接到一个数据库上，这时候处理请求的就是<strong>连接器</strong>。连接器负责与客户端建立连接、获取客户权限、维持和管理连接。连接命令一般是这么写的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure>

<p>输完命令后，我们接着还需要在交互对话里面输入密码。虽然密码也可以直接跟在 <code>-p</code> 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连接的是生产服务器，强烈建议你不要这么做。</p>
<p>连接命令中的 <code>mysql</code> 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证我们的身份，这时用的就是我们在命令行中输入的用户名和密码。</p>
<ul>
<li>  如果用户名或者密码不正确，我们就会收到一个 “Access denied for user” 的错误，然后客户端程序结束执行。</li>
<li>  如果用户密码认证通过，连接器将会继续到权限表中查出当前登录用户拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。【这就意味着，一个用户成功建立连接后，即使我们用管理员账号对这个用户的权限做了修改，也不会影响已存在连接的权限。修改完成后，只有重新建立的连接才会应用新的权限】</li>
</ul>
<p>连接完成后，如果我们没有后续的操作，这个连接就会一直处于空闲状态。我们可以用 <code>show processlist</code> 命令查看连接的状态。下面这张图就是 show processlist 命令的执行结果，其中 Command 列显示为 “Sleep” 的这行，就表示现在系统里有一个空闲连接。</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220316142834564.png" alt="image-20220316142834564"></p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间参数是由 <code>wait_timeout</code> 控制的，默认值是 8 小时。</p>
<p>如果连接断开之后，客户端再次发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候如果想要继续操作，就需要重新连接，然后再执行请求了。</p>
<h3>长连接 & 短连接</h3>

<p>数据库里面，</p>
<ul>
<li>  <strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</li>
<li>  <strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li>
</ul>
<p>连接的建立过程通常是比较复杂的，所以我们在使用中最好尽量减少建立连接的动作，也就是尽量使用长连接。</p>
<p>但是全部使用长连接后，可能又会导致 MySQL 内存占用涨得特别快，这是因为 <u>MySQL 在执行过程中临时使用的内存是管理在连接对象里面的</u>。也就是说：假设有 A、B、C 三个连接，这三个连接在使用过程中分别会创建自己使用的临时内存，这还是只有三个连接的情况下，实际上连接的数量远远不止这些。这些长连接占用的内存资源只会在连接断开时才释放。所以长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>
<p>怎么解决这个问题呢？主要有两种思路：</p>
<ol>
<li> 定期断开长连接。使用一段时间后，或者通过断言程序判断执行过一个占用内存的大查询后，断开连接，之后的查询需要重新建立连接。</li>
<li> 如果你使用了 MySQL5.7 及以上版本，可以在每次执行完一个比较大的操作后，手动执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完成时的状态。</li>
</ol>
<hr>
<h2 id="2、查询缓存"><a href="#2、查询缓存" class="headerlink" title="2、查询缓存"></a>2、查询缓存</h2><p>连接建立完成后，下一步就可以执行 select 语句了。这时，执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL 服务器拿到一个查询请求后，首先会到查询缓存中看看，之前是否执行过这条语句。<u>之前执行过的语句及其结果会以 key-value 的形式被缓存在内存中。key 是查询语句，value 是查询结果</u>。</p>
<ul>
<li>  如果能直接在缓存中找到 key，那么将对应的 value 直接返回给客户端即可完成这次查询。</li>
<li>  如果查询语句不在查询缓存中，才会继续执行后面的阶段。并在执行完成后，将执行结果存入查询缓存中。</li>
</ul>
<p>可以想到，如果查询缓存命中，就无需执行后面的复杂操作，效率会相当高。</p>
<blockquote>
<p>  『问题：』</p>
</blockquote>
<p>但是<strong>很多公司在大多数情况下往往禁止使用查询缓存，这是为什么呢？因为查询缓存往往弊大于利</strong>。</p>
<p>查询缓存的失效非常频繁，只要某一张表发生了更新，关于这张表所有的查询缓存就都会被清空。因此，可能你很费劲地把查询结果存到缓存中，还没使用呢，就被一个更新全部清空了。因此，对于更新压力大的数据库来说，查询缓存的命中率非常低。除非你的业务就是一张字典表，很长时间才更新一次，那么这类型表的查询才适合使用查询缓存。</p>
<blockquote>
<p>  『解决方案：』</p>
</blockquote>
<p>好在 MySQL 也提供了这种 “按需使用” 的方式。你可以将参数 <code>query_cache_type</code> 设置成 DEMAND，这样对于默认的 SQL 都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以使用 <code>SQL_CACHE</code> 关键字显式指定将其加入查询缓存。就像下面这条语句一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_CACHE * from T where ID=10;</span><br></pre></td></tr></table></figure>

<p>需要注意的是， MySQL 从 8.0 版本开始，直接将查询缓存的整块功能删掉了，也就是说从 8.0 开始就彻底没有这个功能了。</p>
<hr>
<h2 id="3、分析器"><a href="#3、分析器" class="headerlink" title="3、分析器"></a>3、分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。</p>
<p>首先，MySQL 需要知道你想要做什么，因此，首先需要使用『<strong>分析器</strong>』对 SQL 语句进行解析。</p>
<ul>
<li><p>分析器首先会对 SQL 语句进行『<strong>词法分析</strong>』。我们输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出其中的字符串分别是什么，代表什么意思。</p>
<ul>
<li>  比如，MySQL 从我们输入的 “select” 关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</li>
</ul>
</li>
<li><p>做完了这些分析后，接着要做『<strong>语法分析</strong>』。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这条 SQL 语句是否满足 MySQL 语法。</p>
<ul>
<li>  如果你的语法不对，就会收到 “You have an error in your SQL syntax” 的错误提醒，比如下面这条语句 select 少打了开头字母“s”。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elect * FROM t where ID=1;</span><br><span class="line"></span><br><span class="line">错误代码： 1064</span><br><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * FROM t where ID=1&#x27; at line 1</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="4、优化器"><a href="#4、优化器" class="headerlink" title="4、优化器"></a>4、优化器</h2><p>经过了分析器，MySQL 就知道你要做什么了。但是在真正开始执行之前，还会进入优化器进行优化处理。</p>
<p><u>优化器就是在表中存在多个索引时，决定使用哪个索引；或者在一个查询语句有多表关联（join）的时候，决定各张表的连接顺序。</u></p>
<p>比如执行下面这条语句（二表关联查询）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">from t1 join on t2 using(ID) </span><br><span class="line">where t1.c = 10 </span><br><span class="line">and t2.d = 20;</span><br></pre></td></tr></table></figure>

<ul>
<li>  这个查询既可以先从表 t1 里面取出 c=10 记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20.</li>
<li>  也可以先从表 t2 里面取出 d=20 记录的 ID 值，再根据 ID 值关联到表 t1，再判断 t1 里面 c 的值是否等于 10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p>
<hr>
<h2 id="5、执行器"><a href="#5、执行器" class="headerlink" title="5、执行器"></a>5、执行器</h2><p><u>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做</u>，于是就进入了执行器阶段，开始执行语句。</p>
<p><u>执行器执行时，首先会判断当前用户对这张表是否有执行查询的权限</u>，如果没有，就会返回没有权限的错误提示，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID &gt; 10;</span><br><span class="line"></span><br><span class="line">ERROR 1142(42000): SELECT command denied to user &#x27;xxx&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure>

<p><u>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口</u>。</p>
<p>比如我们例子中的表 T，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li> 调用 InnoDB 引擎接口获取这张表的第一行数据，判断 ID 是否大于 10，若不是则跳过，若是则将这行数据存储在结果集中。</li>
<li> 调用引擎接口获取“下一行”数据，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li> 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这条语句就执行完成了。</p>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。【与不加索引相比，加了索引之后调用的接口多了“满足条件”这四个字。这说明，不加索引就是遍历查询，而加完索引是先找到符合条件数据的引用，然后通过引用直接找到对应的数据】</p>
<p>我们会在数据库的慢查询日志中看到一个 <code>rows_examined</code> 字段，表示这个语句执行过程中扫描了多少行。这个值就是<u>执行器每次调用引擎</u>获取数据行的时候累加的。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的</strong>。</p>
<hr>
<h1 id="02-日志系统：一条SQL更新语句是如何执行的？"><a href="#02-日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="02 | 日志系统：一条SQL更新语句是如何执行的？"></a>02 | 日志系统：一条SQL更新语句是如何执行的？</h1><p>上一节我们学习了一条查询语句的执行流程，并介绍了执行过程中涉及到的处理模块。一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最终到达存储引擎。</p>
<p>那么，一条更新语句的执行流程又是怎么样的呢？</p>
<p>下面是一条建表语句，这张表有一个主键 ID 和一个整型字段 c。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table T(</span><br><span class="line">    ID int primary key,</span><br><span class="line">    c int</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果要将 ID=2 这一行的值加 1，SQL 语句应该这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>那么这条更新语句的执行流程是怎么样的呢？</p>
<p>首先，可以确定的说，<u>查询语句的那一套流程，更新语句同样也会走一遍</u>。因为更新的前提是你得先找到这条记录。</p>
<p>执行语句前要先连接数据库服务器，这是连接器的工作。</p>
<p>前面我们说过，当一张表上有更新操作时，与这张表相关的所有查询缓存都会失效，所以这条语句会把表 T 相关的所有缓存结构都清空，这是在查询缓存中的工作。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后进行更新。</p>
<p><strong>与查询流程不一样的是</strong>，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：<strong>redo log（重做日志）</strong>和 <strong>binlog（归档日志）</strong>。</p>
<h2 id="重做日志-redo-log"><a href="#重做日志-redo-log" class="headerlink" title="重做日志 redo log"></a>重做日志 redo log</h2><p>在正式学习 <code>redo log</code> 之前，我们先来回忆一个小故事，在中学课本中的《孔乙己》这篇文章中说到，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在粉板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜还有一个专门记录赊账的账本。</p>
<p>如果有人要赊账或还帐的话，掌柜一般有两种做法：</p>
<ul>
<li>  一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>
<li>  另一种做法是先在粉板上记下这次的帐，等打烊后再把账本翻出来核算。</li>
</ul>
<p>在生意红火柜台很忙的时候，掌柜一定会选择后者，因为前者操作实在太麻烦了。首先，你得找到这个人赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，找到之后再拿出算盘计算，最后再将结果写回账本上。整个过程想想都麻烦。相比之下，还是先简单在粉板上记一下比较方便。你想想，如果没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以接受。</p>
<p>同样，在 MySQL 中也有这个问题，<u>如果每一次的更新操作都要写进磁盘，就需要在磁盘中先找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高</u>。为了解决这个问题，MySQL 的设计者就用了类似“粉板”的思路来提升更新效率。</p>
<p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 <strong>WAL（Write Ahead Logging）</strong>技术，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<p>具体来说，就是当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存中的数据，这个时候更新就算完成了。同时，InnoDB 会在适当的时候，将这个记录更新到磁盘里面，这个更新往往是在系统比较空闲的时候做的，这就相当于打烊以后掌柜做的事。</p>
<blockquote>
<p>  『提问：』</p>
</blockquote>
<p>如果今天赊账的人不多，掌柜可以等打烊以后再整理。但如果某天赊账的人特别多，没下班之前粉板就写满了，又该怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后再把这些记录从粉板上擦掉，为记新账腾出空间。</p>
<p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。<u>从头开始写，写到末尾又回到开头循环写【环状结构】</u>。如下图所示。</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220317110516145.png" alt="image-20220317110516145"></p>
<ul>
<li>  <code>write pos</code> 是当前记录的位置，一边写一边往后移，写到第 3 号文件末尾后就回到 0 号文件开头。</li>
<li>  <code>checkpoint</code> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到磁盘中的数据文件。</li>
</ul>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 <code>write pos</code> 追上 <code>checkpoint</code>，表示“粉板”满了，这时候就不能再执行新的更新操作了，得先停下来擦掉一些记录，把 <code>checkpoint</code> 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失。要么落库成功，要么保存到了 redo log 中，可以在数据库重启后继续落库，这个能力称为 <strong>crash-safe</strong>。</p>
<p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘了，比如突然停业几天，恢复生意后仍然可以通过账本和粉板上的数据明确赊账账目。</p>
<hr>
<h2 id="归档日志-binlog"><a href="#归档日志-binlog" class="headerlink" title="归档日志 binlog"></a>归档日志 binlog</h2><p>前面我们讲过，MySQL 从整体来看，其实分为两块：一块是 Server 层，它主要负责 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。<u>上面我们讲的“粉板（redo log）”是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，叫做 binlog（归档日志）</u>。</p>
<blockquote>
<p>  『问题』：那么为什么 MySQL 要设计成两份日志呢？</p>
</blockquote>
<p>因为最开始 MySQL 并不支持 InnoDB 引擎。MySQL 最初自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。</p>
<p>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 才引入另一套日志系统——即 redo log 来实现 crash-safe 能力。</p>
<p>这两种日志有以下三点不同：</p>
<ul>
<li>  （1）redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有的引擎都可以使用。</li>
<li>  （2）redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给ID=2这一行的c字段加1”。</li>
<li>  （3）redo log 是『循环写』的，空间大小固定。binlog 是可以『追加写』的，“追加写”是指 binlog 文件写到一定大小后会切换到下一个文件继续写，并不会覆盖之前的日志。</li>
</ul>
<p>有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p>
<ol>
<li> 执行器先委托引擎找到 ID=2 这一行数据。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据也本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li> 执行器拿到引擎给的数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li> 引擎将这行数据更新到内存中，同时将这个操作记录到 redo log 中，此时 redo log 处于 prepare 状态。然后引擎再告知执行器执行完成了，随时可以提交事务。</li>
<li> 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li> 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<p>这条 update 语句的执行流程如下图所示，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220317122356838.png" alt="image-20220317122356838"></p>
<p>最后三步看起来有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是“两阶段提交”。</p>
<hr>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><blockquote>
<p>  『问题』：为什么必须有“两阶段提交”呢？</p>
</blockquote>
<p>这是为了让两份日志之间的逻辑一致。前面我们说了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。</p>
<p>也就是说，如果你的 DBA 承诺说半个月内的数据可以恢复，那么备份系统中一定会保存最近半个月内的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p>
<p>当需要恢复数据到指定某一秒时，比如某天下午两点发现中午十二点有一次误删除，需要找回数据，那你可以这么做：</p>
<ul>
<li>  （1）首先，找到最近一次的全量备份，如果你的运气好，可能就是昨天晚上的一个备份，先将这个备份恢复到临时库。</li>
<li>  （2）然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之间的那个时刻。</li>
</ul>
<p>这样，你的临时库就跟误删之前的线上数据库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p>
<p>说完了数据恢复过程，我们再来看看日志为什么需要“两阶段提交”。这里不妨使用反证法来进行解释。</p>
<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用相反的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中，在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p>
<ul>
<li>  <strong>Case1：先写 redo log 后写 binlog。</strong></li>
</ul>
<p>假设在 redo log 写完，binlog 还没写完的时候，MySQL 进程异常重启。由于我们之前说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行的 c 的值就是 1 了。</p>
<p>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这条语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</p>
<p>如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 缺失，这个临时库就会少了这一次更新，恢复出来这一行 c 的值就是 0，与原库的值不同。</p>
<ul>
<li>  <strong>Case2：先写 binlog 后写 redo log。</strong></li>
</ul>
<p>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了 “把 c 从 0 改成 1” 这个日志。所以，在之后使用 binlog 来恢复时就会多出一个事务，恢复出来这一行 c 的值就是 1，与原库的值不同。</p>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和它用户日志恢复出来的库的状态不一致。</p>
<p>而且在实际应用中，除了误操作后需要用这个过程来恢复数据。当数据库需要扩容时，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常用的做法也是用 <strong>全量备份+binlog</strong> 实现的。而上述“不一致”问题就会导致你的线上出现主从库数据不一致的情况。</p>
<p>简单来说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<ul>
<li>  <strong>小总结：</strong></li>
</ul>
<p>之所以要“两阶段提交”，是因为 redo log 和 binlog 的使用场景不同。binlog 一般用于一个新的库，它的作用是让新库与现有库有一样的数据，而 redo log 则用于当前库发生 crash 后数据恢复用。如果这两个日志不一致，就会导致当前库与新库中的数据不一致。</p>
<hr>
<h1 id="03-事务隔离：为什么你改了我还看不见"><a href="#03-事务隔离：为什么你改了我还看不见" class="headerlink" title="03 | 事务隔离：为什么你改了我还看不见"></a>03 | 事务隔离：为什么你改了我还看不见</h1><p>提到事务，最经典的例子就是转账，假设你要给张三转100块钱，而此时你的银行卡里只有100块钱。</p>
<p>转账过程具体到程序中涉及到一系列操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是原子性的。不然等程序刚查完余额后，还没做减法前，这100块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账。如果这么整，那银行不就亏死了么。这时候就需要用到“事务”这个概念了。</p>
<hr>
<h1 id="04-深入浅出索引（上）"><a href="#04-深入浅出索引（上）" class="headerlink" title="04 | 深入浅出索引（上）"></a>04 | 深入浅出索引（上）</h1><p>数据库索引在日常的工作中经常会接触到，比如某条 SQL 查询较慢，分析完原因后，往往就会采用“给某个字段加个索引吧”之类的解决方案。</p>
<p>简单来说，<strong>索引的出现就是为了提高数据查询的效率，就像书的目录一样</strong>。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那估计得找好一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p>
<h2 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h2><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，因此才出现了“索引模型”的概念。可用于提高数据读写效率的数据结构有很多种，这里我们介绍三种比较常见的数据结构，分别是『哈希表、有序数组和搜索树』。</p>
<p>下面我们从使用的角度，来简单介绍一下这三种模型的区别。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希表是一种以『键-值（key-value）』存储数据的结构，我们只要输入待查找的值（即 key），就可以找到其对应的值（即 value）。哈希的思路很简单，就是用一个哈希函数把 key 换算成一个确定的位置 index，然后把 value 放在数组的这个位置。</p>
<p>不可避免地，多个 key 经过哈希函数的换算，会出现同一个 index 的情况。处理这种情况的一种方法是，拉出一个链表。</p>
<p>假设，你现在维护者一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220412162803566.png" alt="image-20220412162803566"></p>
<p>图中，User2 和 User4 根据身份证号算出来的 index 都是 N，但是没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。</p>
<p>需要注意的是：图中的四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加即可。但缺点是，<strong>因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</strong></p>
<blockquote>
<ul>
<li>  如果数组是有序的，做区间查询时只需根据区间的两个边界值 min 和 max，在数组中找到第一个大于 min 的值以及第一个大于 max 的值，中间的所有值就是目的区间。</li>
<li>  但是如果数组是无序的，做区间查询时就必须进行一次全局扫描，判断每一个值是否在待查找的区间之内，显然是比较慢的。</li>
</ul>
</blockquote>
<p>你可以设想一下，如果你现在要找身份证号在 <code>[ID_card_X. ID_card_Y]</code> 这个区间内的所有用户，就必须全部扫描一遍才能找全。</p>
<p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>。比如 Memcached 及其它一些 NoSQL 引擎。</p>
<h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p>而<strong>有序数组在等值查询和范围查询场景中的性能都十分优秀</strong>。</p>
<blockquote>
<ul>
<li>  但是有序数组在写操作较多的场景中效率很低。因为每次插入元素都可能导致数组重排。</li>
<li>  而且，相较于哈希，数组需要占用更大的连续内存空间，所以对内存的要求较高。[哈希可通过哈希函数减少对连续空间的要求，可通过链表利用碎片内存空间]</li>
</ul>
</blockquote>
<p>还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220412164433876.png" alt="image-20220412164433876"></p>
<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，时间复杂度为 O(log n)。</p>
<p>同时很显然，这个索引模型支持范围查询。你要查身份证号在 <code>[ID_card_X, ID_card_Y]</code> 区间的 User，可以先用二分法找到 ID_card_X（如果 ID_card_X 不存在，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。</p>
<p>如果仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就太麻烦了，你往中间插入一条记录就必须挪动后面的所有记录，成本太高。</p>
<p>所以，<strong>有序数组只适用于静态存储引擎</strong>。比如，你要保存 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p>
<h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><p>还是上面根据身份证号查名字的例子，如果我们使用『二叉搜索树』来实现的话，示意图如下所示：</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220412165512818.png" alt="image-20220412165512818"></p>
<p>二叉搜索树的特点是：每个节点的左儿子的值小于父节点的值，而父节点的值又小于右儿子的值。这样，如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到的，时间复杂度为 O(log n)</p>
<p>当然，<u>为了维持 O(log n) 的时间复杂度，你就必须维持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也达到了 O(log n)</u>。</p>
<blockquote>
<p>  即每次更新先要先找到待插入的位置，时间复杂度是 O(log n)，再执行插入操作。</p>
</blockquote>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。<u>二叉树是树形结构中搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是：索引不止存储在内存中，还要写到磁盘上。</u></p>
<p>你可以想象一下，一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问某一行可能需要 20 个 10ms 的时间，速度非常慢。</p>
<p>为了让一个查询经量少的读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用『N 叉树』。这里，“N叉树”中的 “N” 取决于数据块的大小。</p>
<p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200（即一个节点（也就是一个 Block）中可以存 1200 个值）。这棵树高是 4 的时候，就可以存 1200^3 个值，这已经达到 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中，这里就不一一展开了。</p>
<p>但是我们心里要有一个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p>
<hr>
<h2 id="InnoDB-索引模型"><a href="#InnoDB-索引模型" class="headerlink" title="InnoDB 索引模型"></a>InnoDB 索引模型</h2><p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式是不一样的。而即使多个存储引擎支持同一种类型的索引，其底层实现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，我们下面就以 InnoDB 为例，分析一下它的索引模型。</p>
<hr>
<h1 id="05-深入浅出索引（下）"><a href="#05-深入浅出索引（下）" class="headerlink" title="05 | 深入浅出索引（下）"></a>05 | 深入浅出索引（下）</h1><p><strong>问题引出：</strong></p>
<p>在开始这篇文章之前，我们先来看一个问题。</p>
<p>在下面这张表中，如果我们执行 <code>SELECT * FROM T WHERE k BETWEEN 3 AND 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p>
<p>下面是这张表的初始化语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE T (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    k INT NOT NULL DEFAULT 0,</span><br><span class="line">    s VARCHAR(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">    INDEX k(k)</span><br><span class="line">)ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO T VALUES</span><br><span class="line">    (100, 1, &#x27;aa&#x27;),</span><br><span class="line">    (200, 2, &#x27;bb&#x27;),</span><br><span class="line">    (300, 3, &#x27;cc&#x27;),</span><br><span class="line">    (500, 5, &#x27;ee&#x27;),</span><br><span class="line">    (600, 6, &#x27;ff&#x27;),</span><br><span class="line">    (700, 7, &#x27;gg&#x27;),</span><br><span class="line">    (800, 8, &#x27;hh&#x27;);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/" class="post-title-link" itemprop="url">设计模式之美（Part1）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-14 12:02:18" itemprop="dateCreated datePublished" datetime="2022-03-14T12:02:18+08:00">2022-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-20 13:50:39" itemprop="dateModified" datetime="2022-03-20T13:50:39+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="03-面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"><a href="#03-面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？" class="headerlink" title="03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"></a>03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</h1><p>想要具备编写高质量代码的能力，首先要学习一些编程方法论，主要包含：</p>
<blockquote>
<ol>
<li> 面向对象（可以视为一种设计思想）</li>
<li> 设计原则</li>
<li> 设计模式</li>
<li> 编程规范</li>
<li> 重构技巧</li>
<li> …</li>
</ol>
</blockquote>
<p>这部分基础方法论的内容就相当于一个全局性大纲，你可以把学到的具体内容填充到这个大纲中，不断完善自己的知识结构体系。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>目前主流的编程风格有三种，分别是：</p>
<ol>
<li> 面向过程；</li>
<li> 面向对象；</li>
<li> 函数式编程。</li>
</ol>
<p>其中，面向对象编程又是其中最主流的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以较容易地实现很多复杂的设计思路，是很多设计原则，设计模式编码实现的基础。</p>
<p>在面向对象编程中，需要重点关注的知识点有以下7个：</p>
<ol>
<li> 面向对象的四大特性</li>
<li> 面向对象编程与面向过程编程的区别</li>
<li> 面向对象分析、面向对象设计、面向对象编程</li>
<li> 接口和抽象类的区别及各自应用的场景</li>
<li> 基于接口编程而非基于实现编程的思想</li>
<li> 多用组合少用继承的设计思想</li>
<li> 面向过程的贫血模型和面向对象的充血模型</li>
</ol>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计原则是指导我们代码设计的一些经验总结。这些原则听起来都非常抽象，定义描述比较模糊，不同的人会有不同的解读，所以，单纯的记忆定义意义不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活地应用这些原则。</p>
<p>一些常用的设计原则有：</p>
<ul>
<li>  SOLID原则——SRP单一职责原则</li>
<li>  SOLID原则——OCP开闭原则</li>
<li>  SOLID原则——LSP里氏替换原则</li>
<li>  SOLID原则——ISP接口隔离原则</li>
<li>  SOLID原则——DIP依赖倒置原则</li>
<li>  DRY原则</li>
<li>  KISS原则</li>
<li>  YAGNI原则</li>
<li>  LOD原则</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>​    设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或叫设计思路。大部分的设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，大部分都不难理解，代码实现也并不复杂。这部分的学习目标主要是：（1）了解它们都能解决哪些问题；（2）掌握典型的应用场景，并懂得不过度使用。</p>
<p>​    经典的设计模式共有23种，随着编程语言的演进，一些设计模式也随之过时，甚至成了反模式，一些则被内置在编程语言中（如Iterator），另外也有一些新的模式诞生。</p>
<p>​    这23中经典设计模式，又可分为三大类：（1）创建型、（2）行为型、（3）结构性。按照类型和是否常用，划分如下：</p>
<ol>
<li>创建型<ul>
<li>  常用：单例模式、工厂模式（工厂方法+抽象工厂）、建造者模式</li>
<li>  不常用：原型模式</li>
</ul>
</li>
<li>结构性<ul>
<li>  常用：代理模式、桥接模式、装饰者模式、适配器模式</li>
<li>  不常用：门面模式、组合模式、享元模式</li>
</ul>
</li>
<li>行为型<ul>
<li>  常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式</li>
<li>  不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式</li>
</ul>
</li>
</ol>
<h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><p>​    编程规范主要用于解决代码的可读性问题。相对于设计原则、设计模式，更加具体，更加偏重代码细节。</p>
<h2 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h2><p>​    在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必然会存在这样那样的问题。针对这些问题，代码重构是不可避免的。</p>
<p>​    而重构的工具就是前面罗列的哪些面向对象的设计思想、设计原则、设计模式、编码规范。</p>
<h2 id="五者之间的联系"><a href="#五者之间的联系" class="headerlink" title="五者之间的联系"></a>五者之间的联系</h2><p>​    面向对象编程因为其具有丰富的特性（封装、继承、抽象、多态），可以实现很多复杂的设计思路，因此是很多设计原则、设计模式等思路编程实现的基础。</p>
<p>​    实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这件事的。当我们看清这个本质后，很多选择怎么选就清楚了。比如，在某个场景下，该不该用这个设计模式，那就取决于能不能提高代码的可扩展性；要不要重构，那就取决于代码是否存在可读性，可维护性问题等。</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><hr>
<h1 id="04-理论一：当谈论面向对象的时候，我们到底在谈论什么？"><a href="#04-理论一：当谈论面向对象的时候，我们到底在谈论什么？" class="headerlink" title="04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？"></a>04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？</h1><h2 id="什么是面向对象编程和面向对象编程语言？"><a href="#什么是面向对象编程和面向对象编程语言？" class="headerlink" title="什么是面向对象编程和面向对象编程语言？"></a>什么是面向对象编程和面向对象编程语言？</h2><blockquote>
<p>  面向对象编程（OOP）：Object Oriented Programming</p>
<p>  面向对象编程语言（OOPL）：Object Oriented Programming Language</p>
</blockquote>
<p>​    面向对象编程有两个非常重要的概念，那就是类（class）和对象（object）。这两个概念最早出现在1960年，在Simula这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在Smalltalk这种编程语言中，Smalltalk被认为是第一个真正意义上的面向对象编程语言。</p>
<p>​    1980年左右，C++的出现，带动了面向对象编程的流行，也使得面向对象编程被越来越多的人认可。直到今天，如果不按照严格的定义来说，大部分的编程语言都是面向对象的编程语言，比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Scala、PHP、Perl 等。除此之外，大部分程序员在开发项目的时候，都是基于面向对象编程语言进行的面向对象编程。</p>
<p>​    以上是面向对象编程的大概发展历史，在上面的描述中，提到了两个相似的概念，“面向对象编程”和“面向对象编程语言”，那么究竟什么是面向对象编程，什么是面向对象编程语言呢？</p>
<ul>
<li>  面向对象编程是一种编程风格。它以类或对象作为组织代码的基本单元，并将封装、继承、抽象、多态四个特性，作为代码设计和实现的基石。</li>
<li>  面向对象编程语言是支持类或对象的语法机制，并提供了现成的语法机制，能方便地实现面向对象编程四大特性的编程语法。</li>
</ul>
<p>​    一般来讲，面向对象编程都是通过面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即使我们使用了面向对象编程语言，写出来的代码也不一定是面向对象编程风格的。</p>
<h2 id="如何判断某种编程语言是否是面向对象编程语言？"><a href="#如何判断某种编程语言是否是面向对象编程语言？" class="headerlink" title="如何判断某种编程语言是否是面向对象编程语言？"></a>如何判断某种编程语言是否是面向对象编程语言？</h2><p>​    在上一节中我提到了“如果不按照严格的定义来说，大部分的编程语言都是面向对象的编程语言”。但实际上，什么是“面向对象编程”，什么是“面向对象编程语言”并没有一个统一的官方定义，并且这两个概念从诞生到现在一直是变化的，无法给出一个明确的定义。当然也没有必要给出一个明确的定义。比如，按照上一节我给出的定义，JavaScript并不支持封装和继承特性，按照严格的定义，那么它就不算是一种面向对象编程语言，但是大多是时候我们都会把它看做一种面向对象编程语言。那么：到底如何判断一个编程语言是否是面向对象的编程语言呢？</p>
<p>​    实际上，面向对象编程从字面上，按照最简单的方式理解，就是将对象或类作为代码组织的基本单元来进行编程的一种编程风格，并不一定需要有封装、抽象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结发现，有了这四大特性后，我们就能更容易地实现各种面向对象的代码设计思路。</p>
<p>​    比如，我们在面向对象编程过程中，经常会遇到 is-a 这种类关系（比如狗是一种动物），而继承这个特性就能很好地支持这种 is-a 的代码设计思路，并解决代码复用的问题，所以，继承就成了面向对象编程的四大特性之一。但是，随着编程语言的不断迭代、演化，人们又发现继承这种特性容易造成层次不清、代码混乱，所以，很多编程语言在设计的时候就开始摒弃继承特性，比如 Go 语言。但是，我们不能因为它摒弃了继承特性，就一刀切地认为它不是面向对象的编程语言了。</p>
<p>​    实际上，我个人觉得，只要某种编程语言支持类或对象的语言概念，并以此作为组织代码的基本单元，那么就可以被粗略地认为是一种面向对象编程语言了。至于是否有现成的语法机制支持面向四大特性，是否对四大特性有所取舍和优化，可以不作为判断的标准。因为即使不直接支持四大特性，也可以手动通过编程手段复现出与四大特性类似的效果。基于此，我们才说“<strong>如果按照严格的定义，很多语言都不算是面向对象编程语言；但是不按照严格的定义来讲，现在流行的大多数语言都是面向对象编程语言</strong>。”</p>
<h2 id="什么是面向对象分析和面向对象设计？"><a href="#什么是面向对象分析和面向对象设计？" class="headerlink" title="什么是面向对象分析和面向对象设计？"></a>什么是面向对象分析和面向对象设计？</h2><p>​    前面我们讲了面向对象编程（OOP）和面向对象编程语言（OOPL），实际上跟OOP经常放到一块儿讲的还有另外两个概念：</p>
<blockquote>
<p>  面向对象分析（OOA）：Object Oriented Analysis</p>
<p>  面向对象设计（OOD）：Object Oriented Design</p>
</blockquote>
<p>OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、实现（编程），正好是面向对象软件开发要经历的三个阶段。</p>
<p>​    面向对象分析与设计中的“分析”与“设计”可简单类比与软件开发中的需求分析与系统设计。那么为什么要在前面加一个修饰词“面向对象”呢？</p>
<p>​    之所以在前面加“面向对象”这几个字，是因为我们是围绕着“对象或类”来进行需求分析和设计的。分析和设计两个阶段最终的产出就是类的设计，包括程序被拆解为哪些类，每个类有哪些属性、方法，类与类之间如何交互等。它比需求分析更贴近编码，更容易过渡到面向对象编程环节。</p>
<p>​    那么，面向对象分析、设计、编程到底负责哪些工作呢？简单来讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的结果翻译成代码的过程。</p>
<hr>
<h1 id="05-理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"><a href="#05-理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？" class="headerlink" title="05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"></a>05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？</h1><p>​    理解面向对象编程和面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。</p>
<h2 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h2><p>​    封装可以看做是一种信息隐藏，一种数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的函数来访问内部数据。</p>
<p>​    下面这段代码是金融系统中一个简化版的虚拟钱包代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录我们在系统中的虚拟货币数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/14 21:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> balanceLastModifiedTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wallet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = IdGenerator.getInstance().generate();</span><br><span class="line">        <span class="built_in">this</span>.createTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.balance = BigDecimal.ZERO;</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBalanceLastModifiedTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balanceLastModifiedTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 充值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> increaseAmount 充值金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseBalance</span><span class="params">(BigDecimal increaseAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (increaseAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;充值金额不能小于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.add(increaseAmount);</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> decreaseAmount 消费金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseBalance</span><span class="params">(BigDecimal decreaseAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (decreaseAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;消费金额不能小于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (decreaseAmount.compareTo(<span class="built_in">this</span>.balance) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientAmountException</span>(<span class="string">&quot;当前账户余额不足，请充值&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.subtract(decreaseAmount);</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    由代码知，Wallet类主要有四个属性，其中，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示钱包余额上次变更的时间。</p>
<p>​    我们参照封装特性，对钱包这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或修改钱包里的数据。</p>
<ul>
<li>  String getId()</li>
<li>  long getCreateTime()</li>
<li>  BigDecimal getBalance()</li>
<li>  long getBalanceLastModifiedTime()</li>
<li>  void increaseBalance(BigDecimal increaseAmount)</li>
<li>  void decreaseBalance(BigDecimal decreaseAmount)</li>
</ul>
<p>之所以这样设计，是因为：从业务的角度来讲，</p>
<p>（1）id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的修改方法，比如 set 方法。</p>
<p>（2）而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化好，而不是通过构造函数的入参来进行外部赋值。</p>
<p>（3）对于钱包余额 balance 这个属性，从业务的角度来讲，只能增或者减，不会被重新设置。所以，我们在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法。</p>
<p>（4）对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 和 decreaseBalance() 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。</p>
<p>​    对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是<strong>访问权限控制</strong>。如 Java 中的 private、public 等。如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那么任意代码都可以通过类型 <code>wallet.id=123;</code> 这样的方式直接访问、修改属性，那么也就没办法达到隐藏信息和保护数据的目的了，自然也就无法支持封装特性了。</p>
<h4>上面讲了封装的定义，那么封装的意义是什么呢？它又能解决什么编程问题？</h4>

<p>​    如果我们对类中属性的访问不做限制，那么任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但是从另一方面来说，过度灵活业意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如，某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 wallet 中的 balanceLastModifiedTime 属性，就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。</p>
<p>​    除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把所有的类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就必须要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就少很多。【多说多错，少说少错】</p>
<p>​    这就好比，如果一个冰箱有很多按钮，你就必须研究很长时间，还不一定能正确操作。相反，如果只有几个必要的按钮，如开、关、加减温度，你一眼就知道该如何操作，而且操作出错的概率也会降低很多。</p>
<h2 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h2><p>​    封装主要讲的是“如何隐藏信息，保护数据”，而抽象讲的是“如何隐藏方法的具体实现，让调用者只需要关心提供了哪些功能，并不需要知道这些功能是如何实现的”。</p>
<p>​    在面向对象编程中，我们常借助编程语言提供的接口或者抽象类（如Java中的 interface 和 abstract 关键字）这两种语法机制，来实现抽象这一特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPictureStorage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span>;</span><br><span class="line"></span><br><span class="line">    Image <span class="title function_">getPicture</span><span class="params">(String pictureId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deletePicture</span><span class="params">(String pictureId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PictureStorage</span> <span class="keyword">implements</span> <span class="title class_">IPictureStorage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 保存图片</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">getPicture</span><span class="params">(String pictureId)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 获取图片</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePicture</span><span class="params">(String pictureId)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 删除图片</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 修改元数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在上面的这段代码中，我们利用 Interface 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口中暴露的方法提供的功能就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑。</p>
<p>​    实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口或抽象类这些特殊的语法机制来支持。换句话说就是，并不是一定要为实现类抽象出接口（Interface）或抽象类（abstract）才叫做抽象。即使不编写 IPictureStorage 接口，单纯的 PictureStorage 本身就满足抽象特性。</p>
<p>​    之所以这么说，是因为，类中的方法是通过编程语言中的“函数”这一语法机制来实现的，通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或文档，了解其提供了什么功能，就可以直接使用了。比如，我们在调用某个具体实现方法 <code>new ArrayList().add()</code> 的时候，并不需要了解它的底层代码是怎么实现的。</p>
<p>​    需要注意的是，抽象有时候会被排除在“面向对象特性”之外，即面向对象只有三大特性（封装、继承、多态）。这是因为，抽象这个概念是一个非常通用的思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个性质也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，所以，它没有很强的“特异性”，有时并不被看做是面向对象编程的特性之一。【抽象：不够特殊】</p>
<h4>上面讲了抽象的定义，那么抽象的意义是什么？它又能解决什么编程问题呢？</h4>

<p>​    实际上，如果上升一个层面考虑的话，抽象及前面讲的封装都是<u>人类处理复杂性的有效手段</u>。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好可以帮我们的大脑过滤掉许多非必要的信息。</p>
<p>​    除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想。比如基于接口编程而非实现编程、开闭原则（对扩展开发，对修改关闭）、代码解耦（降低代码的耦合性）等。</p>
<p>​    <u>换一个角度来考虑，我们在定义（或者叫命名）类中的方法时，也要有抽象思维，不要在方法名定义中暴露太多的实现细节，以保证在未来某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。</u> 举个例子，比如 <code>getAliyunPictureUrl()</code> 就不是一个具有抽象思维的命名，因为如果有一天我们不再把图片存储在阿里云上，而是存储在腾讯云上，那么这个命名也要随之修改。相反，如果我们定义一个比较抽象的函数，比如叫做 <code>getPictureUrl()</code> ，那即使内部的存储方式修改了，我们也不需要修改这个函数名。</p>
<h2 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h2><p>​    继承用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上将，继承可分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。比如猫既是哺乳动物，又是爬行动物。</p>
<p>​    为了实现“继承”这一特性，编程语言需要提供特殊的语法机制来支持。比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : class A），Python 使用 paraentheses()。不过，有些编程语言只支持单继承，不支持多继承，比如 Java、PHP、C# 等，而有些编程语言支持多继承，如 C++、Python 等。</p>
<h4>继承的定义讲完了，那么，继承存在的意义是什么？它又能解决什么编程问题呢？</h4>

<p>​    继承最大的一个好处就是<strong>代码复用</strong>。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并非继承所独有的，我们也可以通过其它方式来解决代码复用的问题，比如使用组合关系而不是继承关系。</p>
<p>​    如果上升到思维层面，去思考继承这一特性，可以这么理解：我们的代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，这是一种 is-a 关系。我们通过继承来关联两个类，反映真实世界中的这种关系，非常符合人类的认知。而且，从设计的角度来讲，也有一种结构美感。</p>
<p>​    继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不经需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。</p>
<p>​    所以，继承这一特性非常有争议，很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。而是使用“组合”来代替。</p>
<h2 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h2><p>​    多态是指“<strong>子类可以替换父类</strong>”，在编码时使用父类，在实际的代码运行过程中，调用子类的方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 10:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">protected</span> Integer[] elements = <span class="keyword">new</span> <span class="title class_">Integer</span>[DEFAULT_CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 如果数组满了就扩容，代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortedDynamicArray</span> <span class="keyword">extends</span> <span class="title class_">DynamicArray</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//保证数组中的元素有序</span></span><br><span class="line">            <span class="keyword">if</span> (elements[i] &gt; e)&#123;</span><br><span class="line">                elements[i+<span class="number">1</span>] = elements[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elements[i+<span class="number">1</span>] = e;</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(DynamicArray dynamicArray)</span>&#123;</span><br><span class="line">        dynamicArray.add(<span class="number">5</span>);</span><br><span class="line">        dynamicArray.add(<span class="number">1</span>);</span><br><span class="line">        dynamicArray.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dynamicArray.size; i++) &#123;</span><br><span class="line">            System.out.println(dynamicArray.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DynamicArray</span> <span class="variable">dynamicArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortedDynamicArray</span>();</span><br><span class="line">        test(dynamicArray); <span class="comment">// 打印结果：1，3，5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。</p>
<ul>
<li>  第一个语法机制是编程语言要支持父类对象可以引用子类对象。也就是可以将 SortedDynamicArray 传递给 DynamicArray。</li>
<li>  第二个语法机制使编程语言支持继承，也就是 SortedDynamicArray  继承了 DynamicArray，才能将 SortedDynamicArray  传递给 DynamicArray。</li>
<li>  第三个语法机制使编程语言要支持子类可以重写（Override）父类中的方法，也就是 SortedDynamicArray  重写了 DynamicArray 中的 add() 方法。</li>
</ul>
<p>通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类  SortedDynamicArray  替换父类 DynamicArray，执行子类  SortedDynamicArray  中的 add() 方法，也就是实现了多态特性。</p>
<p>​    对于多态特性的实现方式，除了利用“继承+方法重写”这种方式外，我们还有其它两种比较常见的实现方式，一个是利用“接口+方法重写”方式，另一个是利用“duck-typing”语法。不过，并不是每种编程语言都支持接口或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。</p>
<p>​    对于如何利用“接口+方法重写”实现多态特性。我们可以看下面这段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 11:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Iterator iterator)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">arrayIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        print(arrayIterator);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">linkedListIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        print(linkedListIterator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，Iterator 是一个接口，定义了一个可以遍历集合数据的迭代器，Array 和 LinkedList 都实现了接口 Iterator。我们通过传递不同类型的实现类（Array/LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hashNext() 方法实现。</p>
<p>​    具体点讲就是，当我们向 print(Iterator iterator) 函数传递 Array 类型的对象时，print(Iterator iterator) 函数就会调用 Array 的 next()、hashNext() 的实现逻辑；当我们向 print(Iterator iterator) 函数传递 LinkedList 类型的对象时，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hashNext() 的实现逻辑。</p>
<p>​    上面的代码是在 Java 中用接口来实现多态特性。现在我们在来看一下在 Python 中如何用 duck-typing 来实现多态特性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I write a log into file.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I insert data into db.&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">recorder</span>):</span><br><span class="line">    recorder.record()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    logger = Logger();</span><br><span class="line">    db = DB()</span><br><span class="line">    test(logger)</span><br><span class="line">    test(db)</span><br></pre></td></tr></table></figure>

<p>​    从这段代码中，我们发现，duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是它们都定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法。</p>
<p>​    也就是说，只要两个类具有相同（同名、同参、同返回值）的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这种静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系；通过接口实现多态特性，类必须实现对应的接口。</p>
<h4>多态特性讲完了，那么多态存在的意义是什么？它能解决什么编程问题？</h4>

<p>​    <strong>多态特性能够提高代码的可扩展性和复用性</strong>。我们回过头去看以下多态特性中的第二个例子（Iterator例子），在那个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array/LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需要让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。</p>
<p>​    如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator)函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如对于 Array，我们要实现 print(Array array) 函数，对于 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性和可扩展性。</p>
<p>​    除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如：策略模式、基于接口编程而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的 if-else 语句等。</p>
<hr>
<h1 id="06，07-理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"><a href="#06，07-理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？" class="headerlink" title="06，07 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"></a>06，07 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？</h1><p>​    很多人编程的一个误区就是：以为使用面向对象的编程语言来做开发就是在面向对象编程了。而实际上，他们往往只是在用面向对象的编程语言，编程面向过程风格的代码而已，并没有发挥面向对象编程的优势。这相当于手握一把屠龙刀，却只是把它当做一把普通刀剑来用。想要搞清楚面向过程和面向对象这两种编程风格，首先要厘清下面这些问题：</p>
<blockquote>
<ol>
<li> 什么是面向过程编程与面向过程编程语言？</li>
<li> 面向对象编程相比面向过程编程有哪些优势？</li>
<li> 为什么说面向对象编程语言比面向过程编程语言更加高级？</li>
<li> 有哪些看似是面向对象实际是面向过程风格的代码？</li>
<li> 在面向对象编程中，为什么容易写出面向过程风格的代码？</li>
<li> 面向过程编程和面向过程 编程语言真的无用武之地了吗？</li>
</ol>
</blockquote>
<h2 id="什么是面向过程编程与面向过程编程语言？"><a href="#什么是面向过程编程与面向过程编程语言？" class="headerlink" title="什么是面向过程编程与面向过程编程语言？"></a>什么是面向过程编程与面向过程编程语言？</h2><p>​    通过前面的学习，我们可以类比面向对象编程和面向对象编程语言这两个概念来理解面向过程编程与面向过程编程语言。关于面向对象编程和面向对象编程语言的概念如下：</p>
<ul>
<li>  面向对象编程是一种编程风格，它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性作为代码设计和实现的基石。</li>
<li>  面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</li>
</ul>
<p>​    类比面向对象编程与面向对象编程语言的定义，对于面向过程编程和面向过程编程语言这两个概念，可以给出如下定义：</p>
<ul>
<li>  面向过程编程也是一种编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以<strong>数据</strong>（可以理解为成员变量、属性）<strong>与方法相离</strong>为最主要的特点。面向过程风格是一种流程化的编程风格，通过凭借一组顺序执行的方法来操作数据完成一项功能。</li>
<li>  面向过程编程语言首先是一种编程语言，它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、封装、多态），仅支持面向过程编程。</li>
</ul>
<p>​    不过，就像我们之间讲到的面向对象编程和面向对象编程语言并没有官方的定义一样，这里我们给出的面向过程编程和面向过程编程语言的定义，也并不是严格的官方定义。</p>
<p>​    定义比较抽象，所以，我们用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件 users.txt，没行文本的格式时 name&amp;age&amp;gender（比如：张三&amp;23&amp;男）。我们希望写一个程序。从 users.txt 文件中逐行读取用户信息，然后格式化成 <code>name\tage\tgender</code>（其中，<code>\t</code> 是分隔符） 这种文本格式，并且按照 age 从小到大排序之后，重新写入到另一个文本文件 formatted_users.txt 中。针对这样一个程序的开发，我们来看一下，用面向过程和面向对象两种风格，写出来的代码有何不同。</p>
<p>​    首先，我们先来看，用面向过程编程风格写出来的代码是什么样子的。注：下面这段代码使用C语言这种面向过程的编程语言编写的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> User <span class="title function_">parse_to_user</span><span class="params">(<span class="type">char</span>* text)</span>&#123;</span><br><span class="line">    <span class="comment">// 将 text(&quot;张三&amp;23&amp;男&quot;) 解析成结构体 struct user</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">format_to_text</span><span class="params">(<span class="keyword">struct</span> User user)</span>&#123;</span><br><span class="line">    <span class="comment">// 将结构体 struct User 格式化成文本(“张三\t23\t男”)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_users_by_age</span><span class="params">(<span class="keyword">struct</span> User users[])</span>&#123;</span><br><span class="line">    <span class="comment">// 按照年龄从小到大排序users</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">format_user_file</span><span class="params">(<span class="type">char</span>* origin_file_path, <span class="type">char</span>* new_file_path)</span>&#123;</span><br><span class="line">    <span class="comment">// open files...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">users</span>[1024];</span> <span class="comment">// 假设最大1024个用户</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">// read util the file is empty</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span> =</span> parse_to_user(line);</span><br><span class="line">        users[count++] = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort_users_by_age(users);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">        <span class="comment">// 逐行格式化</span></span><br><span class="line">        <span class="type">char</span>* formated_user_text = format_to_text(users[i]);</span><br><span class="line">        <span class="comment">// write to new file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close files</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    format_user_file(<span class="string">&quot;/tmp/users.txt&quot;</span>, <span class="string">&quot;/tmp/formatted_users.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后，我们再来看用面向对象这种编程风格写出来的代码是什么样子的。注：下面这段代码是使用Java这种面向对象的编程语言来编写的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 17:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">parseForm</span><span class="params">(String userInfoText)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 将 text(&quot;张三&amp;23&amp;男&quot;) 解析成User类对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">formatToText</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 将 User对象格式化成文本 (&quot;张三\t23\t男&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFileFormatter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(String userFile, String formattedUserFile)</span>&#123;</span><br><span class="line">        <span class="comment">// Open files...</span></span><br><span class="line">        ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123; <span class="comment">// read util the file is empty</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.parseForm(userFile);</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort users by age</span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">formattedUserText</span> <span class="operator">=</span> user.formatToText();</span><br><span class="line">            <span class="comment">// write to new file</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close files...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainApplication</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserFileFormatter</span> <span class="variable">userFileFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserFileFormatter</span>();</span><br><span class="line">        userFileFormatter.format(<span class="string">&quot;/tmp/users.txt&quot;</span>, <span class="string">&quot;/tmp/formatted_users.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    从上面的代码中，我们可以看出，面向过程和面向对象最明显的区别就是，代码的组织方式不同。<strong>面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的</strong>。面向对象风格的代码被组织成一组类，方法和数据结构被绑定在一起，定义在类中。</p>
<p>​    除了这个最明显的特点，两种风格的区别还有什么呢？我们继续往下看。</p>
<h2 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h2><p>​    上面我们介绍了面向过程编程及面向过程编程语言的定义，并跟面向对象编程及面向对象编程语言做了一个简单的对比。接下来，我们再来看一下，为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式的原因。</p>
<h4>1、OOP更加能够应对大规模复杂程序的开发</h4>

<p>​    单单从上面那个格式化文本文件的例子，你可能发现两种编程风格实现的代码貌似差不多呀，只是代码的组织方式有些区别，没有感觉到面向对象编程有什么明显的优势呀。之所以有这种感觉，主要是这个例子程序比较简单，不够复杂。</p>
<p>​    对于简单程序的开发来说，不管是用面向过程的编程风格，还是用面向对象的编程风格，差别确实不会很大，甚至有的时候，面向过程编程反倒更有优势。因为需求足够简单，整个程序的处理流程就只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程编程这种面条式的编程风格来实现。</p>
<p>​    但对于大规模复杂程序程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个流程的处理流程图画出来的话，会是一个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。</p>
<p>​    面向对象编程是以类为思考对象，在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</p>
<p>​    除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可定要定义数百个函数，数百个数据结构（struct），那么如何分门别类地组织这些函数和数据结构，才能不至于看起来比较混乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。</p>
<p>​    你可能想到，像C语言这种面向过程的编程语言，我们也可以按照功能不同，把函数和数据结构放到不同的文件中，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。这样当然也可以，只不过面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求。这也算是面向对象编程相对于面向过程编程的一个微创新吧。</p>
<p>​    实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过比直接用面向对象的编程语言可能需要付出的代价更高一些。而且，面向过程编程和面向对象编程并非完全对立的，很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。</p>
<h4>2、OOP风格的代码更易复用、易扩展、易维护</h4>

<p>​    在上一节的例子中，因为代码比较简单，所以只用到了类、对象这两个最基本的面向对象概念，并没有用到更加高级的四大特性，封装、抽象、继承、多态。因此，面向对象的优势其实并没有发挥出来。</p>
<p>​    面向过程编程是一种非常简单的编程风格，并没有向面向对象编程那样提供丰富的特性，而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。</p>
<p>​    首先，来看封装特性。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会向<strong>面向过程编程那样，数据可以被任意的方法随意修改</strong>。因此，面向对象提供的封装特性更有利于提高代码的已维护性。【对于调用者来说，知道的越少，需要维护的也就越少】</p>
<p>​    其次，对于抽象特性。我们知道，函数本身就是一种抽象，它隐藏了具体的实现。我们在使用函数的时候，只需要了解函数的功能，而不需要了解它是怎么实现的。从这一点上，不管是面向对象编程还是面向过程编程，都支持抽象特性。不过，面向对象编程还提供了其它抽象特性的实现方式。这些实现方式是面向过程编程所不具有的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性，提高了代码的可扩展性。【当然，这其实还用到了面向对象的多态特性】</p>
<p>​    再次，对于继承特性。继承特性时面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的属性和方法，抽取到父类中，让两个子类继承父类，这样两个子类就可以复用父类中的代码，避免代码冲虚写多遍，提高了代码的复用性。</p>
<p>​    最后，对于多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际代码的运行中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭，对扩展开放”的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码复用性。</p>
<p>​    所以说，基于这四大特性，利用面向对象编程，我们可以更轻松地写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些。</p>
<h4>3、OOP语言更加人性化、更加高级、更加智能</h4>









<h2 id="有哪些看似是面向对象实际是面向过程风格的代码？"><a href="#有哪些看似是面向对象实际是面向过程风格的代码？" class="headerlink" title="有哪些看似是面向对象实际是面向过程风格的代码？"></a>有哪些看似是面向对象实际是面向过程风格的代码？</h2><p>​    现如今，大部分的编程语言都是面向对象编程语言，大部分软件都是基于面向对象这种编程范式来开发的。不过，在实际开发中，很多开发者对面向对象编程都有误解，总是以为把所有代码都塞到类里面，自认为就是在进行面向对象编程了。实际上这样的认知是不正确的，有时候表面上看似是面向对象编程风格的代码 ，本质上却是面向过程风格的。</p>
<p>​    使用面向编程语言编写面向过程风格的代码，有时候是有意为之，并无不妥；而有些却是无意为之，会影响到代码质量。下面我们将通过三个典型的代码案例来具体展示一下，什么样的代码看似是面向对象风格，实际上是面向过程风格的。</p>
<h4>1、滥用 getter、setter 方法</h4>

<p>​    在很多项目开发中，一些开发者在定义完类的属性后，就顺手把这些属性的 getter、setter 方法都定义上，更有甚者直接用 Lombok 插件自动生成所有属性的 setter、getter 方法。这一行为的理由往往是：为了以后可能会用到，现在事先定义好，之后用起来就更加方便，而且即使用不到这些 getter、setter 方法，定义它们也无伤大雅。</p>
<p>​    实际上，这样的做法其实在一些大公司是非常不推荐的。<u>它违反了面向对象的封装特性</u>，相当于将面向对象编程风格退化为面向过程编程风格。我们通过一个例子来理解一下这句话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 21:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> itemsCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> totalPrice;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ShoppingCartItem&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemsCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItemsCount</span><span class="params">(<span class="type">int</span> itemsCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.itemsCount = itemsCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalPrice</span><span class="params">(<span class="type">double</span> totalPrice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.totalPrice = totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(ShoppingCartItem item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.add(item);</span><br><span class="line">        itemsCount++;</span><br><span class="line">        totalPrice += item.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其它方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，ShoppingCart 是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。对于 itemsCount、totalPrice 两个属性，我们定义了它的 getter、setter 方法，对于 items 属性，我们定义了它的 getter 方法和 addItem() 方法。代码很简单，理解起来不难。那么其中存在哪些问题呢？</p>
<p>​    首先我们来看前两个属性， itemsCount 和 totalPrice，虽然我们将它定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性完全没什么两样了。外部可以通过 setter 方法随意修改这两个属性的值。任意代码都可以随意调用 setter 方法，来重设 itemsCount、totalPrice 属性的值，这就会导致其跟 items 属性的值不一致。</p>
<p>​    而面向对象封装特性的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p>
<p>​    看完前两个属性，我们再来看看 items 这个属性，对于 items 这个属性，我们定义了它的 getter 方法和 addItem() 方法，并没有定义它的 setter 方法。这样的设计貌似看起来没有什么问题，但实际上不是。</p>
<p>​    对于 itemsCount 和 totalPrice 这两个属性来说，定义一个public 的 getter 方法，确实无伤大雅，毕竟 getter 方法不会修改数据。但是，对于 items 属性就不一样了，这是因为 items 属性的 getter 方法，返回的是一个 List 集合容器。外部调用者在拿到这个容器后，是可以在不改变容器地址的情况下操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据。比如像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">...</span><br><span class="line">cart.getItems.clear(); <span class="comment">// 清空购物车</span></span><br></pre></td></tr></table></figure>

<p>​    你可能会觉得，清空购物车这样的功能需求看上去合情合理呀。没错，这个需求是合理的，但是上面这种写法会导致 itemsCount、totalPrice、items 三者数据不一致。我们不应该将情况购物车的业务逻辑暴露给上层调用者。正确的做法应该是，在 ShoppingCart 类中定义一个 clear() 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart 类的 clear() 方法的具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">	<span class="comment">// 省略其它代码...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        items.clear();</span><br><span class="line">        <span class="built_in">this</span>.itemsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.totalPrice = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    你可能还会说，我有一个需求，就是要查看购物车中都买了哪些商品，那这个时候，ShoppingCart 类就不得不提供 items 属性的 getter 方法了，那又该怎么办才好呢？</p>
<p>​    在Java中，我们可以通过 <code>Collections.unmodifiableList()</code> 让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，这个容器类中重写了 List 容器中与修改数据相关的方法，如 add()、clear() 等。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改。具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(<span class="built_in">this</span>.items);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnmodifiableList 部分源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnmodifiableList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">UnmodifiableCollection</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">        List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line">        items.clear(); <span class="comment">// 抛出 UnsupportedOperationException 异常  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不过，这样的实现思路还是有一些问题。因为当调用者通过 ShoppingCart 的 getItems() 获取到 items 之后，虽然无法直接在容器层面修改数据，但是我们仍然可以从容器中单个对象的层面，修改每个对象（ShoppingCartItem ）的数据。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">    List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line">    <span class="type">ShoppingCartItem</span> <span class="variable">item</span> <span class="operator">=</span> items.get(<span class="number">0</span>);</span><br><span class="line">    item.setPrice(<span class="number">10.0</span>); <span class="comment">// 这里修改了 item 的价格属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题的解决方案就要用到之后的设计模式了。</p>
<p>​    总的来说，在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防备集合内部数据被修改的风险。</p>
<h4>2、滥用全局变量和全局方法</h4>

<p>​    我们再来看看，另一个违反面向对象编程的例子，那就是滥用全局变量和全局方法。</p>
<p>​    在C语言这种面向过程编程的语言中，全局变量、全局方法到处可见，但是在Java这种面向对象的编程语言中，全局变量和全局方法就比较少见了。</p>
<p>​    在面向对象编程中，常见的全局变量有：单例对象、静态成员变量、常量等；常见的全局方法有静态方法。单例对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。静态方法一般用来操作静态变量或外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程编程风格。【比如，Utils类中往往只包含方法，方法需要的数据都是从其它类中获取到的，数据结构与方法分离】</p>
<p>​    在刚刚介绍了全局变量和全局方法中，Constants类和Utils类最长用到。现在我们集合这两个类来深入探讨一下全局变量和全局方法的利与弊。</p>
<p>​    我们先来看一下，一种常见的 Constants 类的定义方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/16 10:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_ADDR_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_addr&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_DB_NAME_KEY</span> <span class="operator">=</span> <span class="string">&quot;db_name&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_USERNAME_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_username&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_PASSWORD_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_DEFAULT_ADDR</span> <span class="operator">=</span> <span class="string">&quot;192.168.1.101:6379&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_DEFAULT_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;rt:&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略更多的常量定义</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，我们把程序中用到的所有常量，都集中地放到这个 Constant 类中。不过，这样一个大而全的 Constants 类，并不是一种很好的设计思路。</p>
<p>​    首先，这样设计会<strong>影响代码的可维护性</strong>。如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类中添加常量，那么这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。</p>
<p>​    其次，这样的设计还会<strong>增加代码的编译时间</strong>。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那么每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。而对于一个非常大的项目来说，编译一次项目花费的时间可能是几分钟，甚至十几分钟。而在我们的开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就可能会影响到我们的开发效率。【单元测试编译过程是增量编译，只对发生修改的类重新编译，依赖 Constants 的类越多，修改 Constants 后重新编译的时间就越长】 </p>
<p>​    最后，这样的设计还会<strong>影响代码的复用性</strong>。如果我们要在另一个项目中复用本项目开发的某个类，而这个类又依赖于 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中。</p>
<p>​    那么如何改进 Constants 类的设计呢？下面有两种思路可以借鉴。</p>
<p>​    第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们就放到 MySqlConstants 类中，跟 Redis 配置相关的常量，我们就放到 RedisConstants 类中。另一种是更加面向对象的思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了哪个常量，我们就直接把这个常量定义在这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，我们就把这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。</p>
<p>​    讲完了 Constants 类，我们再来讨论一下 Utils 类。首先，我们应该思考一下：为什么需要 Utils 类？</p>
<p>​    实际上，Utils 类出现的背景是基于这样一个问题：如果我们有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复开发，我们不应该在两个类中，将这个相同的功能逻辑重复实现两遍。这个时候应该怎么办呢？</p>
<p>​    首先，你应该想到可以使用面向对象的继承特性。利用继承特性，我们可以把相同的属性和方法抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有时候，从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。如果仅仅为了代码复用，硬生生抽象出一个父类来，会影响代码的可读性。</p>
<p>​    既然继承解决不了这个问题，我们可以定义一个新的类，实现 URL 拼接和分割的方法。而<u>拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性</u>，这个时候，我们就可以把它定义为只包含静态方法的 Utils 类了。</p>
<p>​    实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，他在软件开发中还是挺有用的，能解决代码复用问题。所以，我们并不是说完全不能用 Utils 类，而是要尽量避免滥用，不要不加思考地随意去定义 Utils 类。</p>
<p>​    在定义 Utils 类之前，你要问一下自己，你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其它类中呢？如果在考虑完这些问题后，还是觉得有必要去定义这样一个 Utils 类，那么就大胆地去定义吧。因为在面向对象编程中，也并不是完全排斥面向过程风格的代码、只要它能为我们写出好的代码共享力量，我们就可以适度地去使用。【A需要，B需要，但A与B无关】</p>
<p>​    除此之外，类比 Constants 类的设计，我们设计 Utils 类的时候，最好也细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUitls、StringUtils、UrlUtils 等，不要设计一个大而全的 Utils 类。</p>
<h4>3、定义数据和方法分离的类</h4>

<p>​    我们再来看一下最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是“<strong>数据定义在一个类中，方法定义在另一个类中</strong>”。并且，这个问题在基于 MVC 三层架构做 Web 后端开发的代码中普遍存在。</p>
<p>​    传统的 MVC 结构分为 Model 层、Controller 层、View 层三层。不过，在前后端分离之后，三层结构在后端开发中调整为  Controller、Service、Mapper 三层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑处理，Mapper  层负责数据读写。而在每一次层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Mapper 类中。这就是典型的面向过程的编程风格。</p>
<p>​    实际上，这种开发模式叫做<strong>基于贫血模型的开发模式</strong>，也是现在非常常用的一种 Web 项目的开发模式。那么，既然这种开发模式明显违背了面向对象的编程风格，那么为什么大部分的 Web 项目都是基于这种开发模式来开发的呢？这个问题的答案，参见：TODO</p>
<h2 id="在面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#在面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="在面向对象编程中，为什么容易写出面向过程风格的代码？"></a>在面向对象编程中，为什么容易写出面向过程风格的代码？</h2><p>​    我们在进行面向对象编程的时候，很容易就不由自主地写出了面向过程编程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？</p>
<p>​    你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步步顺序执行一系列操作，最终完成整个任务。面向过程编程风格恰恰符合人的这种流程化的思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。这样的思考路径比较适合复杂程序的开发，但并不符合人类的思考习惯。</p>
<p>​    如果将类类比成角色，可以这么理解，张三是个产品经理，他会设计产品；李四是个UI，他可以根据原型图画出漂亮的界面；王五是个程序员，他会设计架构和敲代码。现在甲方提出需要一个网上购物平台，按照面向过程的思维就是，我得先去学产品设计，再学UI，最后学代码，全部学会之后我就可以把系统做出来了。而在面向对象的思维中，可能是这样，我什么都不会，但是我认识很多人，我知道有人会，我去沟通张三、李四、王五，我先让张三设计原型图，我拿到原型图之后再去找李四让他给我设计页面，最后我拿着李四设计的页面让王五去给我实现，这样系统也就做好了。</p>
<p>​    在这个例子中，总共就三个流程，张三、李四、王五每人只使用了一门手艺，看起来面向对象和面向过程在复杂度上并无太大的差距。但是把这个问题发散一下，完成某个任务需要三百个流程，并且这些流程互相调用呈网状结构，如果按照面向过程思维，确实十分复杂。而使用面向对象思维，我们可以使用三十个人，每人只要会十门手艺，并且让这些人能相互联系，这样程序的复杂度就能大大降低。</p>
<p>​    【面向对象编程就是粒度更大的编程，面向过程以函数和数据结构为基本单位，在函数或数据结构数量达到几百几千之后就变得不容易管理。而面向对象则是以类和对象为基本单位，将数据结构和函数归属于类内部，每个类包含多个数据结构和函数，这样就可以将面向过程的几百几千个函数按照一定规则减少到几十个，更加容易管理，更适合复杂系统】</p>
<p>​    除此之外，面向对象编程要比面向过程编程更难一些。在面向对象编程中，类的设计还是挺需要技巧和设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的交互关系等等诸多问题。</p>
<p>​    所以，基于这两点原因，很多程序员在开发的时候，更倾向于不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。</p>
<h2 id="面向过程编程和面向过程-编程语言真的无用武之地了吗？"><a href="#面向过程编程和面向过程-编程语言真的无用武之地了吗？" class="headerlink" title="面向过程编程和面向过程 编程语言真的无用武之地了吗？"></a>面向过程编程和面向过程 编程语言真的无用武之地了吗？</h2><hr>
<h1 id="08-理论五：接口-vs-抽象类的区别？如何用普通的类模拟抽象类和接口？"><a href="#08-理论五：接口-vs-抽象类的区别？如何用普通的类模拟抽象类和接口？" class="headerlink" title="08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？"></a>08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？</h1><p>​    在面向对象编程中，抽象类和接口是两个经常要用到的语句，是面向对象四大特性、以及很多设计模式、设计思想、设计原则编程实现的基础。比如，我们可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等等。</p>
<p>​    不过，并非所有的面向对象编程语言都支持这两个语法概念，比如，C++就只支持抽象类，不支持接口；Python既不支持接口，也不支持抽象类。尽管这些编程语言没有提供现成的语法来支持接口和抽象类，但是我们仍然可以通过一些手段来模拟实现这两个语法概念。在Java中，既支持抽象类，也支持接口。</p>
<h2 id="什么是抽象类和接口？区别在哪里？"><a href="#什么是抽象类和接口？区别在哪里？" class="headerlink" title="什么是抽象类和接口？区别在哪里？"></a>什么是抽象类和接口？区别在哪里？</h2><h4>Java中的抽象类</h4>

<p>​    下面这段代码是一个比较典型的抽象类的使用场景（模板设计模式）。Logger类是一个记录日志的抽象类，FileLogger和MessageQueueLogger继承Logger，分别实现两种不同的日志记录方式，记录到日志文件中和记录到消息队列中。FileLogger和MessageQueueLogger复用了父类Logger中的name、enabled、minPermittedLevel属性和log()方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的 doLog() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/16 11:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel; <span class="comment">// 日志的最小级别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">        <span class="keyword">if</span> (!loggable) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        doLog(level, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到消息中间件（如Kafka）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient messageQueueClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, MessageQueueClient messageQueueClient)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient = messageQueueClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到消息中间件</span></span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient.send(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这个例子，我们来总结一下，抽象类具有哪些特性：</p>
<ul>
<li>  抽象类不允许被实例化。</li>
<li>  抽象类可以包含属性和方法，方法既可以有实现（比如Logger中 log() 方法），也可以不包含实现（比如Logger中的 doLog() 方法）。不包含代码实现的方法叫做抽象方法。</li>
<li>  子类继承抽象类，必须实现抽象类中的所有抽象方法或继续声明为抽象类。对应到例子中就是，所有继承Logger抽象类的子类，都必须重写 doLog() 方法。</li>
</ul>
<h4>Java中的接口</h4>

<p>上面讲了Java中如何定义抽象类，我们再来看一下Java中如何定义接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/19 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthenticationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 鉴权逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 限流逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器使用demo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">    <span class="comment">// filters.add(new AuthenticationFilter())</span></span><br><span class="line">    <span class="comment">// filters.add(new RateLimitFilter())</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRpcRequest</span><span class="params">(RpcRequest req)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">                filter.doFilter(req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RpcException e)&#123;</span><br><span class="line">            <span class="comment">// 处理过滤结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略其它处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面这段代码是一个比较典型的接口的使用场景。我们通过 interface 关键字定义了一个 Filter 接口，AuthenticationFilter 和 RateLimitFilter 是接口的两个实现类，分别实现了对 RPC 请求鉴权和限流的过滤功能。</p>
<p>通过这个例子，我们再来总结以下，接口有哪些特性：</p>
<ol>
<li> 接口不能包含属性（也就是成员变量）。</li>
<li> 接口只能声明方法，方法不能包含代码实现。</li>
<li> 实现接口的时候，必须实现接口中声明的所有方法。</li>
</ol>
<p>​    前面我们讲了抽象类和接口的定义，以及各自的语法特性。从语法特性上比，这两者有较大的区别，但这种区别并不是绝对的，在不同的JDK版本中部分语法特性可能略有区别。我们今天主要的目的是要从设计的角度进行这两者的比较。</p>
<p>​    从设计角度来看，抽象类实际上实际上就是类，这种类不能被实例化成对象，只能被子类继承。我们知道，继承是一种 is-a 关系，那么抽象类既然属于类，也表示一种 is-a 的关系。相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是<strong>协议（contract）</strong>。</p>
<h2 id="抽象类和接口能解决什么问题？"><a href="#抽象类和接口能解决什么问题？" class="headerlink" title="抽象类和接口能解决什么问题？"></a>抽象类和接口能解决什么问题？</h2><p>​    上面我们学习了抽象类和接口的定义和区别，现在我们再来学习一下，抽象类和接口存在的意义。</p>
<h4>首先，我们来看一下，为什么需要抽象类？它能解决什么编程问题？</h4>

<p>​    刚刚我们讲到，抽象类不能被实例化，只能被<u>继承</u>。而在前面的章节中，我们还讲过<u>继承</u>能解决代码复用的问题。以此类推，抽象类也是用来解决代码复用问题的。多个子类可以继承抽象类中定义的共有属性和方法，避免在子类中，重复编写相同的代码。</p>
<p>​    【问题】不过，既然继承本身就能达到代码复用的目的，而继承也并不要求父类一定是抽象类，那么我们不使用抽象类，照样也可以实现继承和复用。从这个角度上讲，我们貌似并不需要抽象类这种语法呀。那么抽象类除了解决代码复用的问题，还有什么其它存在的意义吗？</p>
<p>​    我们还是拿之前那个打印日志的例子来讲，在改造之后的代码中，Logger不再是抽象类，只是一个普通的父类，删除了 Logger 中的 log()、doLog() 方法，新增了 isLoggable() 方法。FileLogger 和 MessageQueueLogger 还是继承 Logger 父类，已达到代码复用的目的。具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类，非抽象类，删除了log()、doLog()方法，新增了isLoggable()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel; <span class="comment">// 日志的最小级别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoggable</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level level)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">        <span class="keyword">return</span> loggable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：输出日志到消息中间件（如Kafka）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient messageQueueClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, MessageQueueClient messageQueueClient)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient = messageQueueClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到消息中间件</span></span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient.send(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设计虽然也能达到代码复用的目的，但是却无法使用多态特性了。像下面这种代码，就会出现编译错误，因为 Logger 中没有定义 log() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(<span class="string">&quot;access-log&quot;</span>, <span class="literal">true</span>, Level.WARN, <span class="string">&quot;/tmp/logFile&quot;</span>);</span><br><span class="line">logger.log(Level.ERROR, <span class="string">&quot;This is a test log message&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>你可能会说，这个问题解决起来很简单啊。我们在 Logger 父类中，定义一个空的 log() 方法，让子类重写父类的 log() 方法，实现自己记录日志的逻辑，不就可以了么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">		<span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">	<span class="comment">// 省略部分代码...   </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">	<span class="comment">// 省略部分代码...   </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到消息中间件</span></span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient.send(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实，这种设计思路是可以实现我们的目的的。但是，它显然没有之前通过抽象类的实现思路优雅。为什么这么说呢？主要有以下几点原因。</p>
<ul>
<li>  <strong>更优雅</strong>。在 Logger 中定义一个空的方法，会影响代码的可读性。如果我们不熟悉 Logger 背后的设计思想，代码注释又不怎么给力，我们在阅读 Logger 代码的时候，就可能会对为什么定义一个空的 log() 方法而感到疑惑，需要查看 Logger、FileLogger、MessageQueueLogger 之间的继承关系，才能明白其设计意图。</li>
<li>  <strong>更强制</strong>。当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记实现 log() 方法。而基于抽象类的设计思路，编译器会强制要求子类重写 log() 方法，否则会报编译错误。</li>
<li>  <strong>更安全</strong>。若使用非抽象类，则 Logger 类可以被实例化，我们可以 new 一个 Logger 对象出来，并且调用空的 log() 方法，这显然增加了类被误用的风险。当然，这个问题可以通过手动设置私有构造函数的方式来解决。不过，显然没有使用抽象类来得优雅。</li>
</ul>
<h4>其次，我们再来看一下，我们为什么要需要使用接口？它能解决什么编程问题？</h4>

<p>​    抽象类更多是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或契约。你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体实现，具体的实现代码对调用者透明。通过接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p>
<p>​    实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常听到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。</p>
<h5>
    如何模拟抽象类和接口两个语法概念？
</h5>

<p>​    【问题】在前面的例子中，我们使用的 Java 语言默认提供了抽象类和接口两种实现标准。不过，如果你使用的语言是 C++ 这种没有提供接口语法的编程语言，那从代码实现的角度上来讲，是不是就无法实现 Filter 过滤器的思路了呢？</p>
<p>​    实际上，我们可以通过抽象类来模拟接口。怎么模拟呢？我们先来回忆一下接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，其实现类必须实现接口中的所有方法。只要满足这几点，从设计的角度上来说，我们就可以把它叫做接口。实际上，要满足这些语法特性并不难。下面这段C++代码中，我们就用抽象类模拟了一个接口（下面这段代码实际上是策略模式中的一段代码）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>&#123; <span class="comment">// 用抽象类模拟接口</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	~<span class="built_in">Strategy</span>();</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">alhorithm</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="built_in">Strategy</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>抽象类 Strategy 中没有定义任何属性，并且所有的方法都声明为 virtual 抽象类型，这样，所有的方法都不能有代码实现，并且继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于是一个接口。</p>
<p>​    【问题】不过，如果你使用是类似 Python 这种既没有接口，又没有抽象类的编程语言，那该如何实现上面讲到的 Filter、Logger 的设计思路呢？实际上，除了使用抽象类来模拟接口之外，我们还可以用普通类来模拟接口。具体的 Java 代码实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mockInterface</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">mockInterface</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodUnSupportedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们知道方法必须包含实现，这不符合接口的定义。但是<u>我们可以让类中的方法抛出 MethodUnSupportedException 异常来模拟不包含实现类的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常</u>。那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为 private 访问权限就可以了。</p>
<p>​    实际上，对于动态编程语言，还有一种对接口支持的策略，那就是 duck-typing。这点在之前的章节中讲过。</p>
<h2 id="如何决定该用接口还是抽象类？"><a href="#如何决定该用接口还是抽象类？" class="headerlink" title="如何决定该用接口还是抽象类？"></a>如何决定该用接口还是抽象类？</h2><p>​    上面讲的都是一些方法论，那么，在实际设计、开发的时候，什么时候该用抽象类？什么时候该用接口呢？</p>
<p>​    实际上，判断的标准很简单。<strong>如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 的关系，，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</strong></p>
<p>​    <u>从类的继承层次来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象出上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计私立，我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</u></p>
<hr>
<h1 id="09-理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#09-理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h1><p>​    在平时的开发中我们经常会听到并用到“基于接口而非实现编程”，这是一种非常有效的提高代码质量的手段。但是并非每个人都能用好这一准则，不用或过度使用都会使你编写的代码不够优雅。为了让你理解透彻这条原则，接下来我们会结合一个图片存储的实战案例来讲解，告诉你如何权衡，怎样恰到好处地应用这条原则。</p>
<h2 id="如何理解原则中的“接口”二字？"><a href="#如何理解原则中的“接口”二字？" class="headerlink" title="如何理解原则中的“接口”二字？"></a>如何理解原则中的“接口”二字？</h2><p>​    我们在理解“基于接口而非实现编程”这条原则时，千万不要一开始就与某种具体的编程语言挂钩，局限在某种语言的“接口”语法中（比如Java中的interface接口语法）。要知道，这条原则最早出现在1994年GoF《设计模式》这本书中，它比很多编程语言（如Java）诞生得都要早，因此不可能是为了迎合某种编程语言而创建的概念，你需要把它提到的“接口”理解成一种比较抽象、泛化的概念。</p>
<p>​    实际上，理解这条原则的关键就在于“接口”二字。我们在上一节中说过，从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，前后端联调的“接口”，类库提供的“接口”。刚刚对“接口”的理解，都是比较偏上层、偏抽象的，如果落实到具体的编码，“基于接口编程而非实现编程”这条原则中的接口，可以理解为编程语言中的接口或者抽象类。</p>
<p>​    前面我们说过，这条原则能非常有效地提高代码质量，之所以这么说是因为，应用这条原则，可以将接口和实现相分离，封装（隐藏）不稳定的实现，暴露稳定的接口。<u>上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本不需要做改动，</u>以此来降低耦合性（一方的改变不强制要求另一方改变），提高扩展性。</p>
<p>​    <u>实际上，“基于接口而非实现编程”这条原则的另一个表示方式是“基于抽象而非实现编程”</u>。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍能够在不破坏原有代码设计的情况下灵活应对。</strong>而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p>
<h2 id="如何将这条原则应用到实战中？"><a href="#如何将这条原则应用到实战中？" class="headerlink" title="如何将这条原则应用到实战中？"></a>如何将这条原则应用到实战中？</h2><p>​    对于这条原则，我们结合一个具体的实战案例来进一步讲解一下。</p>
<p>​    假设我们的系统中有很多涉及图片处理和存储的相关业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/19 20:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> &#123;</span><br><span class="line">    <span class="comment">// 省略属性、构造函数等...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">// 失败会抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 根据accesskey/secretkey等生成access token...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadToAliyun</span><span class="params">(Image image, String bucketName, String accessToken)</span>&#123;</span><br><span class="line">        <span class="comment">// 上传图片到阿里云...</span></span><br><span class="line">        <span class="comment">// 返回图片存储在阿里云上的地址（url）...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">downloadFromAliyun</span><span class="params">(String url, String accessToken)</span>&#123;</span><br><span class="line">        <span class="comment">// 从阿里云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunImageStore类的使用案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;my_image_bucket&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">// 处理图片，并封装成Image对象</span></span><br><span class="line">        <span class="type">AliyunImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliyunImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> imageStore.generateAccessToken();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> imageStore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    整个上传流程包含三个步骤：创建 bucket、生成 accessToken 访问凭证、携带 accessToken 上传图片到指定的 bucket 中。代码实现非常简单，用起来也很清晰，乍一看没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p>
<p>​    不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到私有云上。为了满足这样一个需求的变化，我们应该如何修改代码呢？</p>
<p>​    我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说。“细节是魔鬼”，这句话在软件开发中尤其适用。实际上，刚刚设计的实现方式，就隐藏了很多容易出问题的“坏味道”，我们一起来看看都有哪些。</p>
<p>​    新的 PrivateImageStore 类需要设计哪些方法，才能在尽量<u>最小化代码修改</u>的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，主要有以下两点。</p>
<ul>
<li>  首先，AliyunImageStore 类中的有些函数名暴露了实现细节，比如 uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中对这些方法重新命名，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码的修改量就可能回很大。</li>
<li>  其次，将图片存储到阿里云的流程，可能并不是完全一致的，比如，阿里云在图片上传和下载过程中，需要携带 accessToken，而私有云则不需要。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法就不再适合照抄到 PrivateImageStore 类中了；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</li>
</ul>
<p>那这两个问题应该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则。具体来讲，我们要落实到以下3点：</p>
<ol>
<li> 函数的命名不应该暴露任何实现细节。比如，前面使用的 uploadToAliyun() 就不符合要求，应该改为更抽象的命名方式，比如 upload()。</li>
<li> 封装具体的实现细节。比如，跟阿里云相关的特殊流程（如获取accessToken）不应该暴露给调用者。我们应该将其封装到通用流程（上传和下载）中，只对调用者暴露通用流程。</li>
<li> 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>
</ol>
<p>我们照着这个思路，把代码重构以下。重构后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.lnd.designPrincipes._09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/19 20:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImageStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String url)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createBucketIfNotExisting(bucketName);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.generateAccessToken();</span><br><span class="line">        <span class="comment">// 上传图片到阿里云...</span></span><br><span class="line">        <span class="comment">// 返回图片存储在阿里云上的地址（url）...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.generateAccessToken();</span><br><span class="line">        <span class="comment">// 从阿里云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">// 失败会抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 根据accesskey/secretkey等生成access token...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createBucketIfNotExisting(bucketName);</span><br><span class="line">        <span class="comment">// 上传图片到私有云...</span></span><br><span class="line">        <span class="comment">// 返回图片存储在私有云上的地址（url）...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="comment">// 从私有云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">// 失败会抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageStore测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;my_image_bucket&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">// 处理图片，并封装成Image对象</span></span><br><span class="line">        <span class="type">ImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> imageStore.upload(image, BUCKET_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    除此之外，<u>很多人在定义接口的时候，希望能够通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。</u>这样的接口设计就没有意义了。不过，如果你觉得这种思维方式更为顺畅，那也没问题，只是将实现类的方法转移到接口定义中的时候，要有选择性的转移，不要将具体的实现相关的方法转移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。</p>
<p>​    总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。<u>接口的定义只表明做什么，而不是怎么做</u>。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够坐到在替换具体的接口实现的时候，不需要对接口的定义做任何改动。</p>
<h2 id="是否要为每个类都定义接口？"><a href="#是否要为每个类都定义接口？" class="headerlink" title="是否要为每个类都定义接口？"></a>是否要为每个类都定义接口？</h2><p>​    任何事情都要讲究一个“度”，同样，如果过度使用“面向接口而不是实现”这条原则，非得给每个类都定义接口，接口漫天飞，也会导致不必要的开发负担。至于什么时候，改为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</p>
<p>​    前面我们也提到，这条原则的设计初衷是，<u>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口</u>。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当代码发生变化的时候，上游系统的代码基本需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</p>
<p>​    从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其它实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程了，直接使用实现类就可以了。</p>
<p>​    除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性投入不必要的开发时间。</p>
<h2 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h2><p>​    在本节的代码例子中，尽管我们通过使用接口来隔离了两个具体实现。但是，在项目中很多地方，我们都是通过下面第7行代码的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片的存储方式，还是需要修改很多类似第7行那样的代码。这样的设计还是不够完美，对此，你有更好的思路吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageStore测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;my_image_bucket&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">// 处理图片，并封装成Image对象</span></span><br><span class="line">        <span class="type">ImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> imageStore.upload(image, BUCKET_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="10-理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？"><a href="#10-理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？" class="headerlink" title="10 | 理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？"></a>10 | 理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？</h1><p>在面向对象编程中，有一条非常经典的设计原则，那就是：<strong>组合优于继承，多用组合少用继承。</strong></p>
<blockquote>
<ul>
<li>  为什么不推荐使用继承？【继承的缺点】</li>
<li>  组合相比于继承有哪些优势？【组合的优点】</li>
<li>  如何判断该用组合还是继承？【如何抉择】</li>
</ul>
</blockquote>
<p>本节我们就围绕着这三个问题，来讨论一下这条设计原则。</p>
<h2 id="为什么不推荐使用继承？"><a href="#为什么不推荐使用继承？" class="headerlink" title="为什么不推荐使用继承？"></a>为什么不推荐使用继承？</h2><p>​    继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可读性、可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议，很多人觉得继承是一种反模式，应该尽量少用甚至不用。至于为什么会有这样的争议，我们通过一个例子来解释一下。</p>
<p>​    假设我们要设计一个“鸟类“。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子等，都继承这个类。</p>
<p>​    我们知道，大部分的鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分的鸟都会飞，但也有特例，比如鸵鸟就不会飞。如果鸵鸟继承具有 fly() 方法的父类，那鸵鸟就凭空出现了“飞”这样的行为，这显然不符合我们对现实世界中事物的认知。当然，你可能会说，我可以在鸵鸟这个子类中重写 fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractBird</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 鸟会飞...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">AbstractBird</span>&#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnSupportedMethodException</span>(<span class="string">&quot;I can&#x27;t fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这种设计思路虽然可以解决问题，但是不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法并抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了“最小知识原则（Least Knowledge Principe，也叫迪米特法则）”，暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p>
<p>​    你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、鸽子这些会飞的鸟继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟都继承 AbstractUnFlyableBird，不就可以了么。  </p>
<p><img src="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/image-20220320110025182.png" alt="image-20220320110025182"></p>
<p>​    从图中我们可以看出，继承关系变成了三层。不过，从整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度，在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p>
<p>​    是否会飞？是否会叫？两个行为搭配起来会产生四种行为：会飞会叫、会飞不会叫、不会飞会叫、不会飞不会叫。如果我们继续沿用刚才的思路，那就需要再定义四个抽象类：AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird。此时继承关系就变成了四层。</p>
<p>​    如果我们还要考虑“是否会下蛋”这一行为，那估计就要组合爆炸了。类的继承层次会越来深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码…一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装，将父类的实现细节暴露给了子类【从父类命名中就可以看出父类的实现细节】。子类依赖父类实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</p>
<p>​    总之，<u>继承最大的问题就在于：继承的层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。</u>这也是我们为什么不推荐使用继承的原因。那刚刚例子中的继承存在的问题，我们又该如何来解决呢？</p>
<h2 id="组合相比继承有哪些优势？"><a href="#组合相比继承有哪些优势？" class="headerlink" title="组合相比继承有哪些优势？"></a>组合相比继承有哪些优势？</h2><p>​    实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿解决刚刚继承存在的问题。</p>
<p>​    我们前面讲接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸵鸟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable&#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 麻雀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Tweetable, EggLayable&#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p>
<p>​    我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类，实现了 tweet() 方法的 TweetAbility 类，实现了 lagEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除重复。具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyAbility</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TweetAbility</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EggLayAbility</span> <span class="keyword">implements</span> <span class="title class_">EggLayable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸵鸟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TweetAbility</span> <span class="variable">tweetAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TweetAbility</span>(); <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EggLayAbility</span> <span class="variable">eggLayAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EggLayAbility</span>(); <span class="comment">// 组合</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其它技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来代替；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上来讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或少用继承关系，特别是一些复杂的继承关系。</p>
<h2 id="如何判断该用组合还是继承？"><a href="#如何判断该用组合还是继承？" class="headerlink" title="如何判断该用组合还是继承？"></a>如何判断该用组合还是继承？</h2><p>​    尽管我们鼓励多用组合少用继承，但组合也并非是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加了代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</p>
<p>​    如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来代替继承。</p>
<p>​    除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰器模式、策略模式、组合模式等都使用了组合关系，而模板模式使用了继承关系。</p>
<p>​    前面我们讲到了继承可以实现代码复用。利用继承特性，我们把相同的属性和方法抽取出来，定义到父类中，子类复用父类中的属性和方法，达到代码复用的目的，但是，有时候从业务含以上讲，A类和B类并不一定具有继承关系，比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。如果仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这种情况下，使用组合就更加合理、更加灵活。具体的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">    <span class="comment">// 省略属性和方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crawler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Url url; <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Crawler</span><span class="params">(Url url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = <span class="keyword">new</span> <span class="title class_">Url</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageAnalyzer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Url url; <span class="comment">// 组合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageAnalyzer</span><span class="params">(Url url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = <span class="keyword">new</span> <span class="title class_">Url</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采取继承实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们就只能采用继承来实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClient</span> &#123; <span class="comment">// FeignClient框架代码</span></span><br><span class="line">    <span class="comment">// 省略属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(String url)</span>&#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoFunction</span><span class="params">(FeignClient feignClient)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    feignClient.encode();</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomizedFeignClient</span> <span class="keyword">extends</span> <span class="title class_">FeignClient</span> &#123; <span class="comment">// FeignClient框架代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(String url)</span>&#123;</span><br><span class="line">        <span class="comment">// 重写encode的实现...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="type">FeignClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomizedFeignClient</span>();</span><br><span class="line">demoFunction(client);</span><br></pre></td></tr></table></figure>

<p>​    尽管有些人说，要杜绝继承，100%使用组合代替继承，但这种观点多少有点极端。之所以“多用组合少用继承”这句口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也并非一无是处。只要我们控制好它的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，才是我们追求的最终目标。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">HTTP实验环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-07 17:48:05 / Modified: 19:56:56" itemprop="dateCreated datePublished" datetime="2022-03-07T17:48:05+08:00">2022-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>搭建一个“最小化”的环境，在这个环境里仅有 HTTP 协议的两个端点：请求方和应答方，去除一切多余的环节，从而可以抓住重点，快速掌握 HTTP 的本质。</p>
<p><img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/85cadf90dc96cf413afaf8668689ef0b.png" alt="img"></p>
<p>简单说一下这个“最小化”环境用到的应用软件：</p>
<ul>
<li>  Wireshark</li>
<li>  Chrome/Firefox</li>
<li>  Telnet</li>
<li>  OpenResty</li>
</ul>
<p><strong>Wireshark</strong> 是著名的网络抓包工具，能够截获在 TCP/IP 协议栈中传输的所有流量，并按协议类型、地址、端口等任意过滤，功能非常强大，是学习网络协议的必备工具。它就像是网络世界里的一台“高速摄像机”，把只在一瞬间发生的网络传输过程如实地“拍摄”下来，事后再“慢速回放”，让我们能够静下心来仔细地分析那一瞬到底发生了什么。</p>
<p><strong>Chrome</strong> 是 Google 开发的浏览器，是目前的主流浏览器之一。它不仅上网方便，也是一个很好的调试器，对 HTTP/1.1、HTTPS、HTTP/2、QUIC 等的协议都支持得非常好，用 F12 打开“开发者工具”还可以非常详细地观测 HTTP 传输全过程的各种数据。如果你更习惯使用 Firefox，那也没问题，其实它和 Chrome 功能上都差不太多，选择自己喜欢的就好。与 Wireshark 不同，Chrome 和 Firefox 属于“事后诸葛亮”，不能观测 HTTP 传输的过程，只能看到结果。</p>
<p><strong>Telnet</strong> 是一个经典的虚拟终端，基于 TCP 协议远程登录主机，我们可以使用它来模拟浏览器的行为，连接服务器后手动发送 HTTP 请求，把浏览器的干扰也彻底排除，能够从最原始的层面去研究 HTTP 协议。</p>
<p>OpenResty 你可能比较陌生，它是基于 Nginx 的一个“强化包”，里面除了 Nginx 还有一大堆有用的功能模块，不仅支持 HTTP/HTTPS，还特别集成了脚本语言 Lua 简化 Nginx 二次开发，方便快速地搭建动态网关，更能够当成应用容器来编写业务逻辑。选择 OpenResty 而不直接用 Nginx 的原因是它相当于 Nginx 的“超集”，功能更丰富，安装部署更方便。我也会用 Lua 编写一些服务端脚本，实现简单的 Web 服务器响应逻辑，方便实验。</p>
<p>我在 GitHub 上为本专栏开了一个项目：http_study，可以直接用“git clone”下载，或者去 Release 页面，下载打好的压缩包。我使用的操作环境是 Windows 10，如果你用的是 Mac 或者 Linux，可以用 VirtualBox 等虚拟机软件安装一个 Windows 虚拟机，再在里面操作（或者可以到“答疑篇”的Linux/Mac 实验环境搭建中查看搭建方法）。首先你要获取最新的 http_study 项目源码，假设 clone 或解压的目录是“D:\http_study”，操作完成后大概是下图这个样子。</p>
<hr>
<p>如果无法正常启动 OpenResty，最大的可能就是端口 80 或 443被占用了（比如安装了 VMWare workstation）。先查看 <code>www/logs</code> 里的错误日志，我自己的情况就是 VMWare 占用了 443 端口导致启动失败，此时找到占用 443 端口的进程，结束掉即可。具体步骤如下：</p>
<ol>
<li><p>找到占用 443 端口的进程</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr <span class="string">&quot;443&quot;</span>    查看端口443被哪个进程占用；</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307123247611.png" alt="image-20220307123247611"></p>
</li>
<li><p>查看占用 443 进程的端口名</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | findstr <span class="string">&quot;4464&quot;</span>    查看进程号<span class="string">&quot;4464&quot;</span>对应的进程,找出被哪个程序占用;</span><br></pre></td></tr></table></figure></li>
<li><p>在任务管理器关闭进程</p>
<p> <img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307123158332.png" alt="image-20220307123158332"></p>
</li>
<li><p>在命令行窗口重新检查 443 端口的占用是否解除。如果解除则重新启动 OpenResty，即可正常启动。</p>
<p> <img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307123915274.png" alt="image-20220307123915274"></p>
</li>
</ol>
<hr>
<p>因为我们的实验环境运行在本机的 <code>127.0.0.1</code> 上，也就是 loopback “环回”地址。所以，需要安装 npcap 检测到这个地址。</p>
<p>在安装 Wireshark 时有一个选项会提醒我们安装 npcap，我们可以直接在这里安装 Npcap。安装完毕后一定要重启电脑让配置生效（重要！！！）</p>
<img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307194941346.png" alt="image-20220307194941346" style="zoom: 67%;">



<p>如果重启后在 Wireshark 中仍然找不到本地回环地址，则不要使用默认的 npcap，自己去官网找一个最新的 npcap 安装，之后重新安装 WireShark 即可。</p>
<ol>
<li> npcap 下载地址：<a target="_blank" rel="noopener" href="https://npcap.com/#download">https://npcap.com/#download</a></li>
</ol>
<p>以上工作全部完成后，在 Wireshark 的界面就可以检测到 “loopback” 环回地址了。</p>
<p><img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307194550899.png" alt="image-20220307194550899"></p>
<p><img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307195456658.png" alt="image-20220307195456658"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/02/SpringBoot%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E2%80%9C%E9%81%BF%E5%9D%91%E2%80%9D%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/02/SpringBoot%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E2%80%9C%E9%81%BF%E5%9D%91%E2%80%9D%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">SpringBoot实战开发“避坑”指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-02 20:05:15 / Modified: 21:12:44" itemprop="dateCreated datePublished" datetime="2022-03-02T20:05:15+08:00">2022-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="T1：-ComponentScan-扫描的是类而不是接口"><a href="#T1：-ComponentScan-扫描的是类而不是接口" class="headerlink" title="T1：@ComponentScan 扫描的是类而不是接口"></a>T1：@ComponentScan 扫描的是类而不是接口</h1><p>​    在SpringBoot项目中，我们习惯在启动类上使用 <code>@SpringBootApplication</code> 注解完成全自动的一站式配置。 <code>@SpringBootApplication</code> 注解包含了一个子注解 <code>@ComponentScan</code>，这个注解的默认作用是扫描当前主类及其子包下的所有类并将其注入到容器中。这里要注意的一个点是“类”，也就是说它只负责扫描类，而不负责扫描接口。如果我们在启动类的一个子包如 controller 包中定义一个<strong>接口</strong> TestController，再启动项目试一试，就会抛出如下错误：</p>
<ol>
<li><p>在 controller 包下创建一个接口 TestDao</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.gulimall.member.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/2 19:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>在另一个 controller 中引用这个对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;member/member&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动项目时抛出如下错误：TestDao对象找不到</p>
<p> <img src="/2022/03/02/SpringBoot%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E2%80%9C%E9%81%BF%E5%9D%91%E2%80%9D%E6%8C%87%E5%8D%97/image-20220302201437977.png" alt="image-20220302201437977"></p>
</li>
<li><p>如果我们把 TestDao 的类型改为 “class”，发现项目又可以正常启动了</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.gulimall.member.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/2 19:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    从这个例子我们可以得出，<code>@ComponentScan</code> 扫描的是类而不是接口。那么这一错误在哪些场景下容易出现呢？其实只要扫描的包下存在接口就都可能会遇到这种情况。就我个人目前的使用情况来看，主要有两种：一是在 MyBatis 中，二是在 Spring Cloud 项目总使用 Feign 时。</p>
<ol>
<li> 在 MyBatis 中，因为 mapper 包下都是一些接口，如果使用 <code>@ComponentScan</code> 注解，那么在必然无法将接口的实现类注入到Spring容器中。这也是为什么使用 MyBatis 时必须要在配置类上额外添加 <code>@MapperScan(&quot;xxx.xxx.dao&quot;)</code> 注解的原因，添加该注解后，就可以将指定包下的接口的实现类以接口类型添加到容器中，在依赖注入时直接使用接口类型就可以找到对应的实现类。</li>
<li> 在 Spring Cloud 项目中使用 Feign 进行远程调用时也是类似的场景，由于 feign 包下保存的都是一些接口，所以同样需要在配置类中添加 <code>@EnableFeignClients(basePackages = &quot;xxx.feign&quot;)</code> 注解指定接口所在的位置，其原理于 MyBatis 类似。</li>
</ol>
<ul>
<li>  <strong>配置类示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.gulimall.member;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.example.gulimall.member.feign&quot;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.gulimall.member.dao&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallMemberApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GulimallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  dao包和feign包内成员展示（都是接口）</li>
</ul>
<img src="/2022/03/02/SpringBoot%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E2%80%9C%E9%81%BF%E5%9D%91%E2%80%9D%E6%8C%87%E5%8D%97/image-20220302203035084.png" alt="image-20220302203035084" style="zoom:50%;">



<p><strong>总结：</strong> <code>@ComponentScan</code> 注解只扫描“类”而不扫描“接口”，如果想要让接口以接口的类型自动加入Spring容器，一般需要通过额外的注解来实现，比如 MyBatis 的 <code>@MapperScan(basePackages = &quot;xxx&quot;)</code> 或 Feign 的 <code>@EnableFeignClients(basePackages = &quot;xxx&quot;)</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/%E6%AF%95%E8%AE%BE%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/21/%E6%AF%95%E8%AE%BE%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">毕设相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-21 16:50:14" itemprop="dateCreated datePublished" datetime="2022-02-21T16:50:14+08:00">2022-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-24 11:28:48" itemprop="dateModified" datetime="2022-02-24T11:28:48+08:00">2022-02-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="论文遗留"><a href="#论文遗留" class="headerlink" title="论文遗留"></a>论文遗留</h1><h3 id="1-1-研究背景"><a href="#1-1-研究背景" class="headerlink" title="1.1   研究背景"></a>1.1   研究背景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1000字左右</span><br><span class="line">1、	钻井物料管理现在的发展情况</span><br><span class="line">2、	钻井物料管理现在存在的问题</span><br><span class="line">3、	物联网发展  数据日增长量增加 =&gt; 拥有大量数据</span><br><span class="line">4、	生产环境中产生大量的数据</span><br><span class="line">5、	企业要怎么做</span><br><span class="line">做了有什么用——大数据环境下企业信息化建设的作用</span><br></pre></td></tr></table></figure>

<h3 id="1-3-研究内容和意义"><a href="#1-3-研究内容和意义" class="headerlink" title="1.3   研究内容和意义"></a>1.3   研究内容和意义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">500</span><br><span class="line">1、大数据技术起到的作用</span><br><span class="line">2、微服务技术起到的作用</span><br><span class="line">3、机器学习技术起到的作用</span><br></pre></td></tr></table></figure>

<h2 id="第二章-相关理论技术介绍"><a href="#第二章-相关理论技术介绍" class="headerlink" title="第二章 相关理论技术介绍"></a>第二章 相关理论技术介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何集成分析分散且异构的钻井数据源中的钻井物料清单数据，如何进行系统部署和如何进行实时数据的更新等</span><br></pre></td></tr></table></figure>

<h2 id="2-3-微服务相关理论技术概述"><a href="#2-3-微服务相关理论技术概述" class="headerlink" title="2.3 微服务相关理论技术概述"></a>2.3 微服务相关理论技术概述</h2><table>
<thead>
<tr>
<th>相关术语：</th>
</tr>
</thead>
<tbody><tr>
<td>存储系统：MySQL、Redis  业务系统</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>1、 什么是微服务  2、 为什么要用微服务  1. （0）单体架构的缺点：水平扩展性低，大规模复杂业务会导致，难以维护  2. （1）需求越来越多 è 业务逻辑越来越复杂（当前系统使用微服务具有可行性）  3. （2）硬件水平的发展，为了安全性考虑  4. （3）高并发  3、本文中使用的微服务的落地实现</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<h3 id="3-1-2-功能性需求分"><a href="#3-1-2-功能性需求分" class="headerlink" title="3.1.2    功能性需求分"></a>3.1.2    功能性需求分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）    钻井物料管理现状  </span><br><span class="line">（2）    系统功能设计  </span><br></pre></td></tr></table></figure>





<h3 id="3-2-2"><a href="#3-2-2" class="headerlink" title="3.2.2"></a>3.2.2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先要在Hive中制定统一的主题（Topic）和视图（Schema）标准用于存储来自不同子系统的钻井物料异构数据。对于结构化数据，可以使用Sqoop工具在数据同步的过程中，根据源数据的特点会将同步策略分为全量更新和增量及变化更新，全量更新每次完全同步一遍原始数据，增量及变化更新每次只同步新增数据及发生更新的数据，所有的数据在第一次同步时都会执行一次全量更新。</span><br><span class="line">通过对多个油田子公司异构数据的整合，可以实现不同结构数据之间数据信息资源、硬件资源和人力资源的合并和共享，加强宏观层面上对数据的把控，为决策提供数据支撑。</span><br><span class="line"></span><br><span class="line">石油钻井物料消耗状况具有极强的地域性，不同地貌下钻井物料清单的成分具有很强的差异性。通过统计分析不同地区的各个钻井公司关于钻井物料的库存、使用及购买情况的多方面的信息，有利于帮助管理者合理分配物料资源，降低油田开发成本，实现企业效益的最大化。</span><br><span class="line"></span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/29/MySQL%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/29/MySQL%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">MySQL日志系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-29 19:33:06 / Modified: 19:34:00" itemprop="dateCreated datePublished" datetime="2022-01-29T19:33:06+08:00">2022-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E6%96%B0%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">MySQL新版</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="日志系统：一条SQL更新语句是如何执行的？"><a href="#日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="日志系统：一条SQL更新语句是如何执行的？"></a>日志系统：一条SQL更新语句是如何执行的？</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
