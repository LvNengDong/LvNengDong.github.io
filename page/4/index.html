<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/16/%E4%B8%AD%E5%8F%B0%E5%AD%A6%E4%B9%A0%EF%BC%88Part1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/16/%E4%B8%AD%E5%8F%B0%E5%AD%A6%E4%B9%A0%EF%BC%88Part1%EF%BC%89/" class="post-title-link" itemprop="url">中台学习（Part1）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-16 20:47:35" itemprop="dateCreated datePublished" datetime="2022-03-16T20:47:35+08:00">2022-03-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/" class="post-title-link" itemprop="url">重学MySQL（Part1）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-16 13:43:05" itemprop="dateCreated datePublished" datetime="2022-03-16T13:43:05+08:00">2022-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-13 18:38:28" itemprop="dateModified" datetime="2022-04-13T18:38:28+08:00">2022-04-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="01-基础架构：一条SQL查询语句是如何执行的？"><a href="#01-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="01 | 基础架构：一条SQL查询语句是如何执行的？"></a>01 | 基础架构：一条SQL查询语句是如何执行的？</h1><p>人们经常说，看待一件事儿千万不要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从更高的维度理解问题。同样，对于 MySQL 的学习也是如此。平常我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这条查询语句的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID=10;</span><br></pre></td></tr></table></figure>

<p>我们看到的只是一条输入语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。</p>
<p>所以，今天我们要通过这条最简单的查询语句把 MySQL 拆解一下，看看里面都有哪些“零件”。借由这个拆解过程，可以让我们对 MySQL 能有更深刻的理解。这样，当我们碰到 MySQL 的一些异常或者问题时，就能够直指本质，能更快地定位并解决问题。</p>
<p>下图是 MySQL 的基本架构示意图，从中可以清楚地看到 SQL 语句在 MySQL 的各个模块中流转的过程。</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220316135623293.png" alt="image-20220316135623293"></p>
<p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p>
<ul>
<li>  Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 中大多数的核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），<u>所有跨存储引擎的功能都在这一层实现</u>，比如存储过程、触发器、视图等。</li>
<li>  而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多种存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL5.5.5 版本开始成为了默认存储引擎。</li>
</ul>
<p>也就是说，我们在执行 create table 建表的时候，如果不指定存储引擎类型，默认使用的就是 InnoDB。如果想要显式指定存储引擎，可以在 create table 语句中通过类似 <code>engine=memory</code> 的语句来指定创建表使用的存储引擎。不同存储引擎的表数据存储方式不同，支持的功能也不同，后续我们将一一深入讨论。</p>
<p>从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。接下来我们将结合开头提到的那条 SQL 语句，一起走一遍整个执行流程，捋一捋每个组件的作用。</p>
<h2 id="1、连接器"><a href="#1、连接器" class="headerlink" title="1、连接器"></a>1、连接器</h2><p>正常情况下，我们都是通过一个客户端连接到 MySQL 服务器上，去操作服务器上的数据库。</p>
<p>所以，第一步，我们首先要发送请求连接到一个数据库上，这时候处理请求的就是<strong>连接器</strong>。连接器负责与客户端建立连接、获取客户权限、维持和管理连接。连接命令一般是这么写的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure>

<p>输完命令后，我们接着还需要在交互对话里面输入密码。虽然密码也可以直接跟在 <code>-p</code> 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连接的是生产服务器，强烈建议你不要这么做。</p>
<p>连接命令中的 <code>mysql</code> 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证我们的身份，这时用的就是我们在命令行中输入的用户名和密码。</p>
<ul>
<li>  如果用户名或者密码不正确，我们就会收到一个 “Access denied for user” 的错误，然后客户端程序结束执行。</li>
<li>  如果用户密码认证通过，连接器将会继续到权限表中查出当前登录用户拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。【这就意味着，一个用户成功建立连接后，即使我们用管理员账号对这个用户的权限做了修改，也不会影响已存在连接的权限。修改完成后，只有重新建立的连接才会应用新的权限】</li>
</ul>
<p>连接完成后，如果我们没有后续的操作，这个连接就会一直处于空闲状态。我们可以用 <code>show processlist</code> 命令查看连接的状态。下面这张图就是 show processlist 命令的执行结果，其中 Command 列显示为 “Sleep” 的这行，就表示现在系统里有一个空闲连接。</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220316142834564.png" alt="image-20220316142834564"></p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间参数是由 <code>wait_timeout</code> 控制的，默认值是 8 小时。</p>
<p>如果连接断开之后，客户端再次发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候如果想要继续操作，就需要重新连接，然后再执行请求了。</p>
<h3>长连接 & 短连接</h3>

<p>数据库里面，</p>
<ul>
<li>  <strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</li>
<li>  <strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li>
</ul>
<p>连接的建立过程通常是比较复杂的，所以我们在使用中最好尽量减少建立连接的动作，也就是尽量使用长连接。</p>
<p>但是全部使用长连接后，可能又会导致 MySQL 内存占用涨得特别快，这是因为 <u>MySQL 在执行过程中临时使用的内存是管理在连接对象里面的</u>。也就是说：假设有 A、B、C 三个连接，这三个连接在使用过程中分别会创建自己使用的临时内存，这还是只有三个连接的情况下，实际上连接的数量远远不止这些。这些长连接占用的内存资源只会在连接断开时才释放。所以长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>
<p>怎么解决这个问题呢？主要有两种思路：</p>
<ol>
<li> 定期断开长连接。使用一段时间后，或者通过断言程序判断执行过一个占用内存的大查询后，断开连接，之后的查询需要重新建立连接。</li>
<li> 如果你使用了 MySQL5.7 及以上版本，可以在每次执行完一个比较大的操作后，手动执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完成时的状态。</li>
</ol>
<hr>
<h2 id="2、查询缓存"><a href="#2、查询缓存" class="headerlink" title="2、查询缓存"></a>2、查询缓存</h2><p>连接建立完成后，下一步就可以执行 select 语句了。这时，执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL 服务器拿到一个查询请求后，首先会到查询缓存中看看，之前是否执行过这条语句。<u>之前执行过的语句及其结果会以 key-value 的形式被缓存在内存中。key 是查询语句，value 是查询结果</u>。</p>
<ul>
<li>  如果能直接在缓存中找到 key，那么将对应的 value 直接返回给客户端即可完成这次查询。</li>
<li>  如果查询语句不在查询缓存中，才会继续执行后面的阶段。并在执行完成后，将执行结果存入查询缓存中。</li>
</ul>
<p>可以想到，如果查询缓存命中，就无需执行后面的复杂操作，效率会相当高。</p>
<blockquote>
<p>  『问题：』</p>
</blockquote>
<p>但是<strong>很多公司在大多数情况下往往禁止使用查询缓存，这是为什么呢？因为查询缓存往往弊大于利</strong>。</p>
<p>查询缓存的失效非常频繁，只要某一张表发生了更新，关于这张表所有的查询缓存就都会被清空。因此，可能你很费劲地把查询结果存到缓存中，还没使用呢，就被一个更新全部清空了。因此，对于更新压力大的数据库来说，查询缓存的命中率非常低。除非你的业务就是一张字典表，很长时间才更新一次，那么这类型表的查询才适合使用查询缓存。</p>
<blockquote>
<p>  『解决方案：』</p>
</blockquote>
<p>好在 MySQL 也提供了这种 “按需使用” 的方式。你可以将参数 <code>query_cache_type</code> 设置成 DEMAND，这样对于默认的 SQL 都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以使用 <code>SQL_CACHE</code> 关键字显式指定将其加入查询缓存。就像下面这条语句一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_CACHE * from T where ID=10;</span><br></pre></td></tr></table></figure>

<p>需要注意的是， MySQL 从 8.0 版本开始，直接将查询缓存的整块功能删掉了，也就是说从 8.0 开始就彻底没有这个功能了。</p>
<hr>
<h2 id="3、分析器"><a href="#3、分析器" class="headerlink" title="3、分析器"></a>3、分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。</p>
<p>首先，MySQL 需要知道你想要做什么，因此，首先需要使用『<strong>分析器</strong>』对 SQL 语句进行解析。</p>
<ul>
<li><p>分析器首先会对 SQL 语句进行『<strong>词法分析</strong>』。我们输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出其中的字符串分别是什么，代表什么意思。</p>
<ul>
<li>  比如，MySQL 从我们输入的 “select” 关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</li>
</ul>
</li>
<li><p>做完了这些分析后，接着要做『<strong>语法分析</strong>』。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这条 SQL 语句是否满足 MySQL 语法。</p>
<ul>
<li>  如果你的语法不对，就会收到 “You have an error in your SQL syntax” 的错误提醒，比如下面这条语句 select 少打了开头字母“s”。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elect * FROM t where ID=1;</span><br><span class="line"></span><br><span class="line">错误代码： 1064</span><br><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * FROM t where ID=1&#x27; at line 1</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="4、优化器"><a href="#4、优化器" class="headerlink" title="4、优化器"></a>4、优化器</h2><p>经过了分析器，MySQL 就知道你要做什么了。但是在真正开始执行之前，还会进入优化器进行优化处理。</p>
<p><u>优化器就是在表中存在多个索引时，决定使用哪个索引；或者在一个查询语句有多表关联（join）的时候，决定各张表的连接顺序。</u></p>
<p>比如执行下面这条语句（二表关联查询）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">from t1 join on t2 using(ID) </span><br><span class="line">where t1.c = 10 </span><br><span class="line">and t2.d = 20;</span><br></pre></td></tr></table></figure>

<ul>
<li>  这个查询既可以先从表 t1 里面取出 c=10 记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20.</li>
<li>  也可以先从表 t2 里面取出 d=20 记录的 ID 值，再根据 ID 值关联到表 t1，再判断 t1 里面 c 的值是否等于 10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p>
<hr>
<h2 id="5、执行器"><a href="#5、执行器" class="headerlink" title="5、执行器"></a>5、执行器</h2><p><u>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做</u>，于是就进入了执行器阶段，开始执行语句。</p>
<p><u>执行器执行时，首先会判断当前用户对这张表是否有执行查询的权限</u>，如果没有，就会返回没有权限的错误提示，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID &gt; 10;</span><br><span class="line"></span><br><span class="line">ERROR 1142(42000): SELECT command denied to user &#x27;xxx&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure>

<p><u>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口</u>。</p>
<p>比如我们例子中的表 T，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li> 调用 InnoDB 引擎接口获取这张表的第一行数据，判断 ID 是否大于 10，若不是则跳过，若是则将这行数据存储在结果集中。</li>
<li> 调用引擎接口获取“下一行”数据，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li> 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这条语句就执行完成了。</p>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。【与不加索引相比，加了索引之后调用的接口多了“满足条件”这四个字。这说明，不加索引就是遍历查询，而加完索引是先找到符合条件数据的引用，然后通过引用直接找到对应的数据】</p>
<p>我们会在数据库的慢查询日志中看到一个 <code>rows_examined</code> 字段，表示这个语句执行过程中扫描了多少行。这个值就是<u>执行器每次调用引擎</u>获取数据行的时候累加的。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的</strong>。</p>
<hr>
<h1 id="02-日志系统：一条SQL更新语句是如何执行的？"><a href="#02-日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="02 | 日志系统：一条SQL更新语句是如何执行的？"></a>02 | 日志系统：一条SQL更新语句是如何执行的？</h1><p>上一节我们学习了一条查询语句的执行流程，并介绍了执行过程中涉及到的处理模块。一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最终到达存储引擎。</p>
<p>那么，一条更新语句的执行流程又是怎么样的呢？</p>
<p>下面是一条建表语句，这张表有一个主键 ID 和一个整型字段 c。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table T(</span><br><span class="line">    ID int primary key,</span><br><span class="line">    c int</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果要将 ID=2 这一行的值加 1，SQL 语句应该这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>那么这条更新语句的执行流程是怎么样的呢？</p>
<p>首先，可以确定的说，<u>查询语句的那一套流程，更新语句同样也会走一遍</u>。因为更新的前提是你得先找到这条记录。</p>
<p>执行语句前要先连接数据库服务器，这是连接器的工作。</p>
<p>前面我们说过，当一张表上有更新操作时，与这张表相关的所有查询缓存都会失效，所以这条语句会把表 T 相关的所有缓存结构都清空，这是在查询缓存中的工作。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后进行更新。</p>
<p><strong>与查询流程不一样的是</strong>，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：<strong>redo log（重做日志）</strong>和 <strong>binlog（归档日志）</strong>。</p>
<h2 id="重做日志-redo-log"><a href="#重做日志-redo-log" class="headerlink" title="重做日志 redo log"></a>重做日志 redo log</h2><p>在正式学习 <code>redo log</code> 之前，我们先来回忆一个小故事，在中学课本中的《孔乙己》这篇文章中说到，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在粉板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜还有一个专门记录赊账的账本。</p>
<p>如果有人要赊账或还帐的话，掌柜一般有两种做法：</p>
<ul>
<li>  一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>
<li>  另一种做法是先在粉板上记下这次的帐，等打烊后再把账本翻出来核算。</li>
</ul>
<p>在生意红火柜台很忙的时候，掌柜一定会选择后者，因为前者操作实在太麻烦了。首先，你得找到这个人赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，找到之后再拿出算盘计算，最后再将结果写回账本上。整个过程想想都麻烦。相比之下，还是先简单在粉板上记一下比较方便。你想想，如果没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以接受。</p>
<p>同样，在 MySQL 中也有这个问题，<u>如果每一次的更新操作都要写进磁盘，就需要在磁盘中先找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高</u>。为了解决这个问题，MySQL 的设计者就用了类似“粉板”的思路来提升更新效率。</p>
<p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 <strong>WAL（Write Ahead Logging）</strong>技术，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<p>具体来说，就是当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存中的数据，这个时候更新就算完成了。同时，InnoDB 会在适当的时候，将这个记录更新到磁盘里面，这个更新往往是在系统比较空闲的时候做的，这就相当于打烊以后掌柜做的事。</p>
<blockquote>
<p>  『提问：』</p>
</blockquote>
<p>如果今天赊账的人不多，掌柜可以等打烊以后再整理。但如果某天赊账的人特别多，没下班之前粉板就写满了，又该怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后再把这些记录从粉板上擦掉，为记新账腾出空间。</p>
<p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。<u>从头开始写，写到末尾又回到开头循环写【环状结构】</u>。如下图所示。</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220317110516145.png" alt="image-20220317110516145"></p>
<ul>
<li>  <code>write pos</code> 是当前记录的位置，一边写一边往后移，写到第 3 号文件末尾后就回到 0 号文件开头。</li>
<li>  <code>checkpoint</code> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到磁盘中的数据文件。</li>
</ul>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 <code>write pos</code> 追上 <code>checkpoint</code>，表示“粉板”满了，这时候就不能再执行新的更新操作了，得先停下来擦掉一些记录，把 <code>checkpoint</code> 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失。要么落库成功，要么保存到了 redo log 中，可以在数据库重启后继续落库，这个能力称为 <strong>crash-safe</strong>。</p>
<p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘了，比如突然停业几天，恢复生意后仍然可以通过账本和粉板上的数据明确赊账账目。</p>
<hr>
<h2 id="归档日志-binlog"><a href="#归档日志-binlog" class="headerlink" title="归档日志 binlog"></a>归档日志 binlog</h2><p>前面我们讲过，MySQL 从整体来看，其实分为两块：一块是 Server 层，它主要负责 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。<u>上面我们讲的“粉板（redo log）”是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，叫做 binlog（归档日志）</u>。</p>
<blockquote>
<p>  『问题』：那么为什么 MySQL 要设计成两份日志呢？</p>
</blockquote>
<p>因为最开始 MySQL 并不支持 InnoDB 引擎。MySQL 最初自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。</p>
<p>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 才引入另一套日志系统——即 redo log 来实现 crash-safe 能力。</p>
<p>这两种日志有以下三点不同：</p>
<ul>
<li>  （1）redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有的引擎都可以使用。</li>
<li>  （2）redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给ID=2这一行的c字段加1”。</li>
<li>  （3）redo log 是『循环写』的，空间大小固定。binlog 是可以『追加写』的，“追加写”是指 binlog 文件写到一定大小后会切换到下一个文件继续写，并不会覆盖之前的日志。</li>
</ul>
<p>有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p>
<ol>
<li> 执行器先委托引擎找到 ID=2 这一行数据。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据也本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li> 执行器拿到引擎给的数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li> 引擎将这行数据更新到内存中，同时将这个操作记录到 redo log 中，此时 redo log 处于 prepare 状态。然后引擎再告知执行器执行完成了，随时可以提交事务。</li>
<li> 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li> 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<p>这条 update 语句的执行流程如下图所示，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220317122356838.png" alt="image-20220317122356838"></p>
<p>最后三步看起来有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是“两阶段提交”。</p>
<hr>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><blockquote>
<p>  『问题』：为什么必须有“两阶段提交”呢？</p>
</blockquote>
<p>这是为了让两份日志之间的逻辑一致。前面我们说了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。</p>
<p>也就是说，如果你的 DBA 承诺说半个月内的数据可以恢复，那么备份系统中一定会保存最近半个月内的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p>
<p>当需要恢复数据到指定某一秒时，比如某天下午两点发现中午十二点有一次误删除，需要找回数据，那你可以这么做：</p>
<ul>
<li>  （1）首先，找到最近一次的全量备份，如果你的运气好，可能就是昨天晚上的一个备份，先将这个备份恢复到临时库。</li>
<li>  （2）然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之间的那个时刻。</li>
</ul>
<p>这样，你的临时库就跟误删之前的线上数据库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p>
<p>说完了数据恢复过程，我们再来看看日志为什么需要“两阶段提交”。这里不妨使用反证法来进行解释。</p>
<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用相反的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中，在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p>
<ul>
<li>  <strong>Case1：先写 redo log 后写 binlog。</strong></li>
</ul>
<p>假设在 redo log 写完，binlog 还没写完的时候，MySQL 进程异常重启。由于我们之前说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行的 c 的值就是 1 了。</p>
<p>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这条语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</p>
<p>如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 缺失，这个临时库就会少了这一次更新，恢复出来这一行 c 的值就是 0，与原库的值不同。</p>
<ul>
<li>  <strong>Case2：先写 binlog 后写 redo log。</strong></li>
</ul>
<p>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了 “把 c 从 0 改成 1” 这个日志。所以，在之后使用 binlog 来恢复时就会多出一个事务，恢复出来这一行 c 的值就是 1，与原库的值不同。</p>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和它用户日志恢复出来的库的状态不一致。</p>
<p>而且在实际应用中，除了误操作后需要用这个过程来恢复数据。当数据库需要扩容时，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常用的做法也是用 <strong>全量备份+binlog</strong> 实现的。而上述“不一致”问题就会导致你的线上出现主从库数据不一致的情况。</p>
<p>简单来说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<ul>
<li>  <strong>小总结：</strong></li>
</ul>
<p>之所以要“两阶段提交”，是因为 redo log 和 binlog 的使用场景不同。binlog 一般用于一个新的库，它的作用是让新库与现有库有一样的数据，而 redo log 则用于当前库发生 crash 后数据恢复用。如果这两个日志不一致，就会导致当前库与新库中的数据不一致。</p>
<hr>
<h1 id="03-事务隔离：为什么你改了我还看不见"><a href="#03-事务隔离：为什么你改了我还看不见" class="headerlink" title="03 | 事务隔离：为什么你改了我还看不见"></a>03 | 事务隔离：为什么你改了我还看不见</h1><p>提到事务，最经典的例子就是转账，假设你要给张三转100块钱，而此时你的银行卡里只有100块钱。</p>
<p>转账过程具体到程序中涉及到一系列操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是原子性的。不然等程序刚查完余额后，还没做减法前，这100块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账。如果这么整，那银行不就亏死了么。这时候就需要用到“事务”这个概念了。</p>
<hr>
<h1 id="04-深入浅出索引（上）"><a href="#04-深入浅出索引（上）" class="headerlink" title="04 | 深入浅出索引（上）"></a>04 | 深入浅出索引（上）</h1><p>数据库索引在日常的工作中经常会接触到，比如某条 SQL 查询较慢，分析完原因后，往往就会采用“给某个字段加个索引吧”之类的解决方案。</p>
<p>简单来说，<strong>索引的出现就是为了提高数据查询的效率，就像书的目录一样</strong>。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那估计得找好一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p>
<h2 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h2><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，因此才出现了“索引模型”的概念。可用于提高数据读写效率的数据结构有很多种，这里我们介绍三种比较常见的数据结构，分别是『哈希表、有序数组和搜索树』。</p>
<p>下面我们从使用的角度，来简单介绍一下这三种模型的区别。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希表是一种以『键-值（key-value）』存储数据的结构，我们只要输入待查找的值（即 key），就可以找到其对应的值（即 value）。哈希的思路很简单，就是用一个哈希函数把 key 换算成一个确定的位置 index，然后把 value 放在数组的这个位置。</p>
<p>不可避免地，多个 key 经过哈希函数的换算，会出现同一个 index 的情况。处理这种情况的一种方法是，拉出一个链表。</p>
<p>假设，你现在维护者一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220412162803566.png" alt="image-20220412162803566"></p>
<p>图中，User2 和 User4 根据身份证号算出来的 index 都是 N，但是没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。</p>
<p>需要注意的是：图中的四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加即可。但缺点是，<strong>因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</strong></p>
<blockquote>
<ul>
<li>  如果数组是有序的，做区间查询时只需根据区间的两个边界值 min 和 max，在数组中找到第一个大于 min 的值以及第一个大于 max 的值，中间的所有值就是目的区间。</li>
<li>  但是如果数组是无序的，做区间查询时就必须进行一次全局扫描，判断每一个值是否在待查找的区间之内，显然是比较慢的。</li>
</ul>
</blockquote>
<p>你可以设想一下，如果你现在要找身份证号在 <code>[ID_card_X. ID_card_Y]</code> 这个区间内的所有用户，就必须全部扫描一遍才能找全。</p>
<p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>。比如 Memcached 及其它一些 NoSQL 引擎。</p>
<h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p>而<strong>有序数组在等值查询和范围查询场景中的性能都十分优秀</strong>。</p>
<blockquote>
<ul>
<li>  但是有序数组在写操作较多的场景中效率很低。因为每次插入元素都可能导致数组重排。</li>
<li>  而且，相较于哈希，数组需要占用更大的连续内存空间，所以对内存的要求较高。[哈希可通过哈希函数减少对连续空间的要求，可通过链表利用碎片内存空间]</li>
</ul>
</blockquote>
<p>还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220412164433876.png" alt="image-20220412164433876"></p>
<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，时间复杂度为 O(log n)。</p>
<p>同时很显然，这个索引模型支持范围查询。你要查身份证号在 <code>[ID_card_X, ID_card_Y]</code> 区间的 User，可以先用二分法找到 ID_card_X（如果 ID_card_X 不存在，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。</p>
<p>如果仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就太麻烦了，你往中间插入一条记录就必须挪动后面的所有记录，成本太高。</p>
<p>所以，<strong>有序数组只适用于静态存储引擎</strong>。比如，你要保存 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p>
<h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><p>还是上面根据身份证号查名字的例子，如果我们使用『二叉搜索树』来实现的话，示意图如下所示：</p>
<p><img src="/2022/03/16/%E9%87%8D%E5%AD%A6MySQL%EF%BC%88Part1%EF%BC%89/image-20220412165512818.png" alt="image-20220412165512818"></p>
<p>二叉搜索树的特点是：每个节点的左儿子的值小于父节点的值，而父节点的值又小于右儿子的值。这样，如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到的，时间复杂度为 O(log n)</p>
<p>当然，<u>为了维持 O(log n) 的时间复杂度，你就必须维持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也达到了 O(log n)</u>。</p>
<blockquote>
<p>  即每次更新先要先找到待插入的位置，时间复杂度是 O(log n)，再执行插入操作。</p>
</blockquote>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。<u>二叉树是树形结构中搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是：索引不止存储在内存中，还要写到磁盘上。</u></p>
<p>你可以想象一下，一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问某一行可能需要 20 个 10ms 的时间，速度非常慢。</p>
<p>为了让一个查询经量少的读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用『N 叉树』。这里，“N叉树”中的 “N” 取决于数据块的大小。</p>
<p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200（即一个节点（也就是一个 Block）中可以存 1200 个值）。这棵树高是 4 的时候，就可以存 1200^3 个值，这已经达到 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中，这里就不一一展开了。</p>
<p>但是我们心里要有一个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p>
<hr>
<h2 id="InnoDB-索引模型"><a href="#InnoDB-索引模型" class="headerlink" title="InnoDB 索引模型"></a>InnoDB 索引模型</h2><p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式是不一样的。而即使多个存储引擎支持同一种类型的索引，其底层实现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，我们下面就以 InnoDB 为例，分析一下它的索引模型。</p>
<hr>
<h1 id="05-深入浅出索引（下）"><a href="#05-深入浅出索引（下）" class="headerlink" title="05 | 深入浅出索引（下）"></a>05 | 深入浅出索引（下）</h1><p><strong>问题引出：</strong></p>
<p>在开始这篇文章之前，我们先来看一个问题。</p>
<p>在下面这张表中，如果我们执行 <code>SELECT * FROM T WHERE k BETWEEN 3 AND 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p>
<p>下面是这张表的初始化语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE T (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    k INT NOT NULL DEFAULT 0,</span><br><span class="line">    s VARCHAR(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">    INDEX k(k)</span><br><span class="line">)ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO T VALUES</span><br><span class="line">    (100, 1, &#x27;aa&#x27;),</span><br><span class="line">    (200, 2, &#x27;bb&#x27;),</span><br><span class="line">    (300, 3, &#x27;cc&#x27;),</span><br><span class="line">    (500, 5, &#x27;ee&#x27;),</span><br><span class="line">    (600, 6, &#x27;ff&#x27;),</span><br><span class="line">    (700, 7, &#x27;gg&#x27;),</span><br><span class="line">    (800, 8, &#x27;hh&#x27;);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/" class="post-title-link" itemprop="url">设计模式之美（Part1）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-14 12:02:18" itemprop="dateCreated datePublished" datetime="2022-03-14T12:02:18+08:00">2022-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-20 13:50:39" itemprop="dateModified" datetime="2022-03-20T13:50:39+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="03-面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"><a href="#03-面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？" class="headerlink" title="03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？"></a>03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？</h1><p>想要具备编写高质量代码的能力，首先要学习一些编程方法论，主要包含：</p>
<blockquote>
<ol>
<li> 面向对象（可以视为一种设计思想）</li>
<li> 设计原则</li>
<li> 设计模式</li>
<li> 编程规范</li>
<li> 重构技巧</li>
<li> …</li>
</ol>
</blockquote>
<p>这部分基础方法论的内容就相当于一个全局性大纲，你可以把学到的具体内容填充到这个大纲中，不断完善自己的知识结构体系。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>目前主流的编程风格有三种，分别是：</p>
<ol>
<li> 面向过程；</li>
<li> 面向对象；</li>
<li> 函数式编程。</li>
</ol>
<p>其中，面向对象编程又是其中最主流的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以较容易地实现很多复杂的设计思路，是很多设计原则，设计模式编码实现的基础。</p>
<p>在面向对象编程中，需要重点关注的知识点有以下7个：</p>
<ol>
<li> 面向对象的四大特性</li>
<li> 面向对象编程与面向过程编程的区别</li>
<li> 面向对象分析、面向对象设计、面向对象编程</li>
<li> 接口和抽象类的区别及各自应用的场景</li>
<li> 基于接口编程而非基于实现编程的思想</li>
<li> 多用组合少用继承的设计思想</li>
<li> 面向过程的贫血模型和面向对象的充血模型</li>
</ol>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计原则是指导我们代码设计的一些经验总结。这些原则听起来都非常抽象，定义描述比较模糊，不同的人会有不同的解读，所以，单纯的记忆定义意义不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活地应用这些原则。</p>
<p>一些常用的设计原则有：</p>
<ul>
<li>  SOLID原则——SRP单一职责原则</li>
<li>  SOLID原则——OCP开闭原则</li>
<li>  SOLID原则——LSP里氏替换原则</li>
<li>  SOLID原则——ISP接口隔离原则</li>
<li>  SOLID原则——DIP依赖倒置原则</li>
<li>  DRY原则</li>
<li>  KISS原则</li>
<li>  YAGNI原则</li>
<li>  LOD原则</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>​    设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或叫设计思路。大部分的设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，大部分都不难理解，代码实现也并不复杂。这部分的学习目标主要是：（1）了解它们都能解决哪些问题；（2）掌握典型的应用场景，并懂得不过度使用。</p>
<p>​    经典的设计模式共有23种，随着编程语言的演进，一些设计模式也随之过时，甚至成了反模式，一些则被内置在编程语言中（如Iterator），另外也有一些新的模式诞生。</p>
<p>​    这23中经典设计模式，又可分为三大类：（1）创建型、（2）行为型、（3）结构性。按照类型和是否常用，划分如下：</p>
<ol>
<li>创建型<ul>
<li>  常用：单例模式、工厂模式（工厂方法+抽象工厂）、建造者模式</li>
<li>  不常用：原型模式</li>
</ul>
</li>
<li>结构性<ul>
<li>  常用：代理模式、桥接模式、装饰者模式、适配器模式</li>
<li>  不常用：门面模式、组合模式、享元模式</li>
</ul>
</li>
<li>行为型<ul>
<li>  常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式</li>
<li>  不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式</li>
</ul>
</li>
</ol>
<h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><p>​    编程规范主要用于解决代码的可读性问题。相对于设计原则、设计模式，更加具体，更加偏重代码细节。</p>
<h2 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h2><p>​    在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必然会存在这样那样的问题。针对这些问题，代码重构是不可避免的。</p>
<p>​    而重构的工具就是前面罗列的哪些面向对象的设计思想、设计原则、设计模式、编码规范。</p>
<h2 id="五者之间的联系"><a href="#五者之间的联系" class="headerlink" title="五者之间的联系"></a>五者之间的联系</h2><p>​    面向对象编程因为其具有丰富的特性（封装、继承、抽象、多态），可以实现很多复杂的设计思路，因此是很多设计原则、设计模式等思路编程实现的基础。</p>
<p>​    实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这件事的。当我们看清这个本质后，很多选择怎么选就清楚了。比如，在某个场景下，该不该用这个设计模式，那就取决于能不能提高代码的可扩展性；要不要重构，那就取决于代码是否存在可读性，可维护性问题等。</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><hr>
<h1 id="04-理论一：当谈论面向对象的时候，我们到底在谈论什么？"><a href="#04-理论一：当谈论面向对象的时候，我们到底在谈论什么？" class="headerlink" title="04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？"></a>04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？</h1><h2 id="什么是面向对象编程和面向对象编程语言？"><a href="#什么是面向对象编程和面向对象编程语言？" class="headerlink" title="什么是面向对象编程和面向对象编程语言？"></a>什么是面向对象编程和面向对象编程语言？</h2><blockquote>
<p>  面向对象编程（OOP）：Object Oriented Programming</p>
<p>  面向对象编程语言（OOPL）：Object Oriented Programming Language</p>
</blockquote>
<p>​    面向对象编程有两个非常重要的概念，那就是类（class）和对象（object）。这两个概念最早出现在1960年，在Simula这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在Smalltalk这种编程语言中，Smalltalk被认为是第一个真正意义上的面向对象编程语言。</p>
<p>​    1980年左右，C++的出现，带动了面向对象编程的流行，也使得面向对象编程被越来越多的人认可。直到今天，如果不按照严格的定义来说，大部分的编程语言都是面向对象的编程语言，比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Scala、PHP、Perl 等。除此之外，大部分程序员在开发项目的时候，都是基于面向对象编程语言进行的面向对象编程。</p>
<p>​    以上是面向对象编程的大概发展历史，在上面的描述中，提到了两个相似的概念，“面向对象编程”和“面向对象编程语言”，那么究竟什么是面向对象编程，什么是面向对象编程语言呢？</p>
<ul>
<li>  面向对象编程是一种编程风格。它以类或对象作为组织代码的基本单元，并将封装、继承、抽象、多态四个特性，作为代码设计和实现的基石。</li>
<li>  面向对象编程语言是支持类或对象的语法机制，并提供了现成的语法机制，能方便地实现面向对象编程四大特性的编程语法。</li>
</ul>
<p>​    一般来讲，面向对象编程都是通过面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即使我们使用了面向对象编程语言，写出来的代码也不一定是面向对象编程风格的。</p>
<h2 id="如何判断某种编程语言是否是面向对象编程语言？"><a href="#如何判断某种编程语言是否是面向对象编程语言？" class="headerlink" title="如何判断某种编程语言是否是面向对象编程语言？"></a>如何判断某种编程语言是否是面向对象编程语言？</h2><p>​    在上一节中我提到了“如果不按照严格的定义来说，大部分的编程语言都是面向对象的编程语言”。但实际上，什么是“面向对象编程”，什么是“面向对象编程语言”并没有一个统一的官方定义，并且这两个概念从诞生到现在一直是变化的，无法给出一个明确的定义。当然也没有必要给出一个明确的定义。比如，按照上一节我给出的定义，JavaScript并不支持封装和继承特性，按照严格的定义，那么它就不算是一种面向对象编程语言，但是大多是时候我们都会把它看做一种面向对象编程语言。那么：到底如何判断一个编程语言是否是面向对象的编程语言呢？</p>
<p>​    实际上，面向对象编程从字面上，按照最简单的方式理解，就是将对象或类作为代码组织的基本单元来进行编程的一种编程风格，并不一定需要有封装、抽象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结发现，有了这四大特性后，我们就能更容易地实现各种面向对象的代码设计思路。</p>
<p>​    比如，我们在面向对象编程过程中，经常会遇到 is-a 这种类关系（比如狗是一种动物），而继承这个特性就能很好地支持这种 is-a 的代码设计思路，并解决代码复用的问题，所以，继承就成了面向对象编程的四大特性之一。但是，随着编程语言的不断迭代、演化，人们又发现继承这种特性容易造成层次不清、代码混乱，所以，很多编程语言在设计的时候就开始摒弃继承特性，比如 Go 语言。但是，我们不能因为它摒弃了继承特性，就一刀切地认为它不是面向对象的编程语言了。</p>
<p>​    实际上，我个人觉得，只要某种编程语言支持类或对象的语言概念，并以此作为组织代码的基本单元，那么就可以被粗略地认为是一种面向对象编程语言了。至于是否有现成的语法机制支持面向四大特性，是否对四大特性有所取舍和优化，可以不作为判断的标准。因为即使不直接支持四大特性，也可以手动通过编程手段复现出与四大特性类似的效果。基于此，我们才说“<strong>如果按照严格的定义，很多语言都不算是面向对象编程语言；但是不按照严格的定义来讲，现在流行的大多数语言都是面向对象编程语言</strong>。”</p>
<h2 id="什么是面向对象分析和面向对象设计？"><a href="#什么是面向对象分析和面向对象设计？" class="headerlink" title="什么是面向对象分析和面向对象设计？"></a>什么是面向对象分析和面向对象设计？</h2><p>​    前面我们讲了面向对象编程（OOP）和面向对象编程语言（OOPL），实际上跟OOP经常放到一块儿讲的还有另外两个概念：</p>
<blockquote>
<p>  面向对象分析（OOA）：Object Oriented Analysis</p>
<p>  面向对象设计（OOD）：Object Oriented Design</p>
</blockquote>
<p>OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、实现（编程），正好是面向对象软件开发要经历的三个阶段。</p>
<p>​    面向对象分析与设计中的“分析”与“设计”可简单类比与软件开发中的需求分析与系统设计。那么为什么要在前面加一个修饰词“面向对象”呢？</p>
<p>​    之所以在前面加“面向对象”这几个字，是因为我们是围绕着“对象或类”来进行需求分析和设计的。分析和设计两个阶段最终的产出就是类的设计，包括程序被拆解为哪些类，每个类有哪些属性、方法，类与类之间如何交互等。它比需求分析更贴近编码，更容易过渡到面向对象编程环节。</p>
<p>​    那么，面向对象分析、设计、编程到底负责哪些工作呢？简单来讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的结果翻译成代码的过程。</p>
<hr>
<h1 id="05-理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"><a href="#05-理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？" class="headerlink" title="05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"></a>05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？</h1><p>​    理解面向对象编程和面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。</p>
<h2 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h2><p>​    封装可以看做是一种信息隐藏，一种数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的函数来访问内部数据。</p>
<p>​    下面这段代码是金融系统中一个简化版的虚拟钱包代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录我们在系统中的虚拟货币数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/14 21:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> balanceLastModifiedTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wallet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = IdGenerator.getInstance().generate();</span><br><span class="line">        <span class="built_in">this</span>.createTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.balance = BigDecimal.ZERO;</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBalanceLastModifiedTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balanceLastModifiedTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 充值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> increaseAmount 充值金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseBalance</span><span class="params">(BigDecimal increaseAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (increaseAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;充值金额不能小于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.add(increaseAmount);</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> decreaseAmount 消费金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseBalance</span><span class="params">(BigDecimal decreaseAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (decreaseAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;消费金额不能小于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (decreaseAmount.compareTo(<span class="built_in">this</span>.balance) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientAmountException</span>(<span class="string">&quot;当前账户余额不足，请充值&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance.subtract(decreaseAmount);</span><br><span class="line">        <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    由代码知，Wallet类主要有四个属性，其中，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示钱包余额上次变更的时间。</p>
<p>​    我们参照封装特性，对钱包这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或修改钱包里的数据。</p>
<ul>
<li>  String getId()</li>
<li>  long getCreateTime()</li>
<li>  BigDecimal getBalance()</li>
<li>  long getBalanceLastModifiedTime()</li>
<li>  void increaseBalance(BigDecimal increaseAmount)</li>
<li>  void decreaseBalance(BigDecimal decreaseAmount)</li>
</ul>
<p>之所以这样设计，是因为：从业务的角度来讲，</p>
<p>（1）id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的修改方法，比如 set 方法。</p>
<p>（2）而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化好，而不是通过构造函数的入参来进行外部赋值。</p>
<p>（3）对于钱包余额 balance 这个属性，从业务的角度来讲，只能增或者减，不会被重新设置。所以，我们在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法。</p>
<p>（4）对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 和 decreaseBalance() 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。</p>
<p>​    对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是<strong>访问权限控制</strong>。如 Java 中的 private、public 等。如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那么任意代码都可以通过类型 <code>wallet.id=123;</code> 这样的方式直接访问、修改属性，那么也就没办法达到隐藏信息和保护数据的目的了，自然也就无法支持封装特性了。</p>
<h4>上面讲了封装的定义，那么封装的意义是什么呢？它又能解决什么编程问题？</h4>

<p>​    如果我们对类中属性的访问不做限制，那么任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但是从另一方面来说，过度灵活业意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如，某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 wallet 中的 balanceLastModifiedTime 属性，就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。</p>
<p>​    除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把所有的类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就必须要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就少很多。【多说多错，少说少错】</p>
<p>​    这就好比，如果一个冰箱有很多按钮，你就必须研究很长时间，还不一定能正确操作。相反，如果只有几个必要的按钮，如开、关、加减温度，你一眼就知道该如何操作，而且操作出错的概率也会降低很多。</p>
<h2 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h2><p>​    封装主要讲的是“如何隐藏信息，保护数据”，而抽象讲的是“如何隐藏方法的具体实现，让调用者只需要关心提供了哪些功能，并不需要知道这些功能是如何实现的”。</p>
<p>​    在面向对象编程中，我们常借助编程语言提供的接口或者抽象类（如Java中的 interface 和 abstract 关键字）这两种语法机制，来实现抽象这一特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPictureStorage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span>;</span><br><span class="line"></span><br><span class="line">    Image <span class="title function_">getPicture</span><span class="params">(String pictureId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deletePicture</span><span class="params">(String pictureId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PictureStorage</span> <span class="keyword">implements</span> <span class="title class_">IPictureStorage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 保存图片</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">getPicture</span><span class="params">(String pictureId)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 获取图片</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePicture</span><span class="params">(String pictureId)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 删除图片</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 修改元数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在上面的这段代码中，我们利用 Interface 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口中暴露的方法提供的功能就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑。</p>
<p>​    实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口或抽象类这些特殊的语法机制来支持。换句话说就是，并不是一定要为实现类抽象出接口（Interface）或抽象类（abstract）才叫做抽象。即使不编写 IPictureStorage 接口，单纯的 PictureStorage 本身就满足抽象特性。</p>
<p>​    之所以这么说，是因为，类中的方法是通过编程语言中的“函数”这一语法机制来实现的，通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或文档，了解其提供了什么功能，就可以直接使用了。比如，我们在调用某个具体实现方法 <code>new ArrayList().add()</code> 的时候，并不需要了解它的底层代码是怎么实现的。</p>
<p>​    需要注意的是，抽象有时候会被排除在“面向对象特性”之外，即面向对象只有三大特性（封装、继承、多态）。这是因为，抽象这个概念是一个非常通用的思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个性质也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，所以，它没有很强的“特异性”，有时并不被看做是面向对象编程的特性之一。【抽象：不够特殊】</p>
<h4>上面讲了抽象的定义，那么抽象的意义是什么？它又能解决什么编程问题呢？</h4>

<p>​    实际上，如果上升一个层面考虑的话，抽象及前面讲的封装都是<u>人类处理复杂性的有效手段</u>。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好可以帮我们的大脑过滤掉许多非必要的信息。</p>
<p>​    除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想。比如基于接口编程而非实现编程、开闭原则（对扩展开发，对修改关闭）、代码解耦（降低代码的耦合性）等。</p>
<p>​    <u>换一个角度来考虑，我们在定义（或者叫命名）类中的方法时，也要有抽象思维，不要在方法名定义中暴露太多的实现细节，以保证在未来某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。</u> 举个例子，比如 <code>getAliyunPictureUrl()</code> 就不是一个具有抽象思维的命名，因为如果有一天我们不再把图片存储在阿里云上，而是存储在腾讯云上，那么这个命名也要随之修改。相反，如果我们定义一个比较抽象的函数，比如叫做 <code>getPictureUrl()</code> ，那即使内部的存储方式修改了，我们也不需要修改这个函数名。</p>
<h2 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h2><p>​    继承用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上将，继承可分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。比如猫既是哺乳动物，又是爬行动物。</p>
<p>​    为了实现“继承”这一特性，编程语言需要提供特殊的语法机制来支持。比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : class A），Python 使用 paraentheses()。不过，有些编程语言只支持单继承，不支持多继承，比如 Java、PHP、C# 等，而有些编程语言支持多继承，如 C++、Python 等。</p>
<h4>继承的定义讲完了，那么，继承存在的意义是什么？它又能解决什么编程问题呢？</h4>

<p>​    继承最大的一个好处就是<strong>代码复用</strong>。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并非继承所独有的，我们也可以通过其它方式来解决代码复用的问题，比如使用组合关系而不是继承关系。</p>
<p>​    如果上升到思维层面，去思考继承这一特性，可以这么理解：我们的代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，这是一种 is-a 关系。我们通过继承来关联两个类，反映真实世界中的这种关系，非常符合人类的认知。而且，从设计的角度来讲，也有一种结构美感。</p>
<p>​    继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不经需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。</p>
<p>​    所以，继承这一特性非常有争议，很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。而是使用“组合”来代替。</p>
<h2 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h2><p>​    多态是指“<strong>子类可以替换父类</strong>”，在编码时使用父类，在实际的代码运行过程中，调用子类的方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 10:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">protected</span> Integer[] elements = <span class="keyword">new</span> <span class="title class_">Integer</span>[DEFAULT_CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 如果数组满了就扩容，代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortedDynamicArray</span> <span class="keyword">extends</span> <span class="title class_">DynamicArray</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//保证数组中的元素有序</span></span><br><span class="line">            <span class="keyword">if</span> (elements[i] &gt; e)&#123;</span><br><span class="line">                elements[i+<span class="number">1</span>] = elements[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elements[i+<span class="number">1</span>] = e;</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(DynamicArray dynamicArray)</span>&#123;</span><br><span class="line">        dynamicArray.add(<span class="number">5</span>);</span><br><span class="line">        dynamicArray.add(<span class="number">1</span>);</span><br><span class="line">        dynamicArray.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dynamicArray.size; i++) &#123;</span><br><span class="line">            System.out.println(dynamicArray.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DynamicArray</span> <span class="variable">dynamicArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortedDynamicArray</span>();</span><br><span class="line">        test(dynamicArray); <span class="comment">// 打印结果：1，3，5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。</p>
<ul>
<li>  第一个语法机制是编程语言要支持父类对象可以引用子类对象。也就是可以将 SortedDynamicArray 传递给 DynamicArray。</li>
<li>  第二个语法机制使编程语言支持继承，也就是 SortedDynamicArray  继承了 DynamicArray，才能将 SortedDynamicArray  传递给 DynamicArray。</li>
<li>  第三个语法机制使编程语言要支持子类可以重写（Override）父类中的方法，也就是 SortedDynamicArray  重写了 DynamicArray 中的 add() 方法。</li>
</ul>
<p>通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类  SortedDynamicArray  替换父类 DynamicArray，执行子类  SortedDynamicArray  中的 add() 方法，也就是实现了多态特性。</p>
<p>​    对于多态特性的实现方式，除了利用“继承+方法重写”这种方式外，我们还有其它两种比较常见的实现方式，一个是利用“接口+方法重写”方式，另一个是利用“duck-typing”语法。不过，并不是每种编程语言都支持接口或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。</p>
<p>​    对于如何利用“接口+方法重写”实现多态特性。我们可以看下面这段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 11:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Iterator iterator)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">arrayIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        print(arrayIterator);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">linkedListIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        print(linkedListIterator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，Iterator 是一个接口，定义了一个可以遍历集合数据的迭代器，Array 和 LinkedList 都实现了接口 Iterator。我们通过传递不同类型的实现类（Array/LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hashNext() 方法实现。</p>
<p>​    具体点讲就是，当我们向 print(Iterator iterator) 函数传递 Array 类型的对象时，print(Iterator iterator) 函数就会调用 Array 的 next()、hashNext() 的实现逻辑；当我们向 print(Iterator iterator) 函数传递 LinkedList 类型的对象时，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hashNext() 的实现逻辑。</p>
<p>​    上面的代码是在 Java 中用接口来实现多态特性。现在我们在来看一下在 Python 中如何用 duck-typing 来实现多态特性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I write a log into file.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I insert data into db.&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">recorder</span>):</span><br><span class="line">    recorder.record()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    logger = Logger();</span><br><span class="line">    db = DB()</span><br><span class="line">    test(logger)</span><br><span class="line">    test(db)</span><br></pre></td></tr></table></figure>

<p>​    从这段代码中，我们发现，duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是它们都定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法。</p>
<p>​    也就是说，只要两个类具有相同（同名、同参、同返回值）的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这种静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系；通过接口实现多态特性，类必须实现对应的接口。</p>
<h4>多态特性讲完了，那么多态存在的意义是什么？它能解决什么编程问题？</h4>

<p>​    <strong>多态特性能够提高代码的可扩展性和复用性</strong>。我们回过头去看以下多态特性中的第二个例子（Iterator例子），在那个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array/LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需要让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。</p>
<p>​    如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator)函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如对于 Array，我们要实现 print(Array array) 函数，对于 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性和可扩展性。</p>
<p>​    除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如：策略模式、基于接口编程而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的 if-else 语句等。</p>
<hr>
<h1 id="06，07-理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"><a href="#06，07-理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？" class="headerlink" title="06，07 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？"></a>06，07 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？</h1><p>​    很多人编程的一个误区就是：以为使用面向对象的编程语言来做开发就是在面向对象编程了。而实际上，他们往往只是在用面向对象的编程语言，编程面向过程风格的代码而已，并没有发挥面向对象编程的优势。这相当于手握一把屠龙刀，却只是把它当做一把普通刀剑来用。想要搞清楚面向过程和面向对象这两种编程风格，首先要厘清下面这些问题：</p>
<blockquote>
<ol>
<li> 什么是面向过程编程与面向过程编程语言？</li>
<li> 面向对象编程相比面向过程编程有哪些优势？</li>
<li> 为什么说面向对象编程语言比面向过程编程语言更加高级？</li>
<li> 有哪些看似是面向对象实际是面向过程风格的代码？</li>
<li> 在面向对象编程中，为什么容易写出面向过程风格的代码？</li>
<li> 面向过程编程和面向过程 编程语言真的无用武之地了吗？</li>
</ol>
</blockquote>
<h2 id="什么是面向过程编程与面向过程编程语言？"><a href="#什么是面向过程编程与面向过程编程语言？" class="headerlink" title="什么是面向过程编程与面向过程编程语言？"></a>什么是面向过程编程与面向过程编程语言？</h2><p>​    通过前面的学习，我们可以类比面向对象编程和面向对象编程语言这两个概念来理解面向过程编程与面向过程编程语言。关于面向对象编程和面向对象编程语言的概念如下：</p>
<ul>
<li>  面向对象编程是一种编程风格，它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性作为代码设计和实现的基石。</li>
<li>  面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</li>
</ul>
<p>​    类比面向对象编程与面向对象编程语言的定义，对于面向过程编程和面向过程编程语言这两个概念，可以给出如下定义：</p>
<ul>
<li>  面向过程编程也是一种编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以<strong>数据</strong>（可以理解为成员变量、属性）<strong>与方法相离</strong>为最主要的特点。面向过程风格是一种流程化的编程风格，通过凭借一组顺序执行的方法来操作数据完成一项功能。</li>
<li>  面向过程编程语言首先是一种编程语言，它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、封装、多态），仅支持面向过程编程。</li>
</ul>
<p>​    不过，就像我们之间讲到的面向对象编程和面向对象编程语言并没有官方的定义一样，这里我们给出的面向过程编程和面向过程编程语言的定义，也并不是严格的官方定义。</p>
<p>​    定义比较抽象，所以，我们用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件 users.txt，没行文本的格式时 name&amp;age&amp;gender（比如：张三&amp;23&amp;男）。我们希望写一个程序。从 users.txt 文件中逐行读取用户信息，然后格式化成 <code>name\tage\tgender</code>（其中，<code>\t</code> 是分隔符） 这种文本格式，并且按照 age 从小到大排序之后，重新写入到另一个文本文件 formatted_users.txt 中。针对这样一个程序的开发，我们来看一下，用面向过程和面向对象两种风格，写出来的代码有何不同。</p>
<p>​    首先，我们先来看，用面向过程编程风格写出来的代码是什么样子的。注：下面这段代码使用C语言这种面向过程的编程语言编写的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> User <span class="title function_">parse_to_user</span><span class="params">(<span class="type">char</span>* text)</span>&#123;</span><br><span class="line">    <span class="comment">// 将 text(&quot;张三&amp;23&amp;男&quot;) 解析成结构体 struct user</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">format_to_text</span><span class="params">(<span class="keyword">struct</span> User user)</span>&#123;</span><br><span class="line">    <span class="comment">// 将结构体 struct User 格式化成文本(“张三\t23\t男”)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_users_by_age</span><span class="params">(<span class="keyword">struct</span> User users[])</span>&#123;</span><br><span class="line">    <span class="comment">// 按照年龄从小到大排序users</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">format_user_file</span><span class="params">(<span class="type">char</span>* origin_file_path, <span class="type">char</span>* new_file_path)</span>&#123;</span><br><span class="line">    <span class="comment">// open files...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">users</span>[1024];</span> <span class="comment">// 假设最大1024个用户</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">// read util the file is empty</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span> =</span> parse_to_user(line);</span><br><span class="line">        users[count++] = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort_users_by_age(users);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">        <span class="comment">// 逐行格式化</span></span><br><span class="line">        <span class="type">char</span>* formated_user_text = format_to_text(users[i]);</span><br><span class="line">        <span class="comment">// write to new file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close files</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    format_user_file(<span class="string">&quot;/tmp/users.txt&quot;</span>, <span class="string">&quot;/tmp/formatted_users.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后，我们再来看用面向对象这种编程风格写出来的代码是什么样子的。注：下面这段代码是使用Java这种面向对象的编程语言来编写的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 17:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">parseForm</span><span class="params">(String userInfoText)</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 将 text(&quot;张三&amp;23&amp;男&quot;) 解析成User类对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">formatToText</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// TODO 将 User对象格式化成文本 (&quot;张三\t23\t男&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFileFormatter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(String userFile, String formattedUserFile)</span>&#123;</span><br><span class="line">        <span class="comment">// Open files...</span></span><br><span class="line">        ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123; <span class="comment">// read util the file is empty</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.parseForm(userFile);</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort users by age</span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">formattedUserText</span> <span class="operator">=</span> user.formatToText();</span><br><span class="line">            <span class="comment">// write to new file</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close files...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainApplication</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserFileFormatter</span> <span class="variable">userFileFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserFileFormatter</span>();</span><br><span class="line">        userFileFormatter.format(<span class="string">&quot;/tmp/users.txt&quot;</span>, <span class="string">&quot;/tmp/formatted_users.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    从上面的代码中，我们可以看出，面向过程和面向对象最明显的区别就是，代码的组织方式不同。<strong>面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的</strong>。面向对象风格的代码被组织成一组类，方法和数据结构被绑定在一起，定义在类中。</p>
<p>​    除了这个最明显的特点，两种风格的区别还有什么呢？我们继续往下看。</p>
<h2 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h2><p>​    上面我们介绍了面向过程编程及面向过程编程语言的定义，并跟面向对象编程及面向对象编程语言做了一个简单的对比。接下来，我们再来看一下，为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式的原因。</p>
<h4>1、OOP更加能够应对大规模复杂程序的开发</h4>

<p>​    单单从上面那个格式化文本文件的例子，你可能发现两种编程风格实现的代码貌似差不多呀，只是代码的组织方式有些区别，没有感觉到面向对象编程有什么明显的优势呀。之所以有这种感觉，主要是这个例子程序比较简单，不够复杂。</p>
<p>​    对于简单程序的开发来说，不管是用面向过程的编程风格，还是用面向对象的编程风格，差别确实不会很大，甚至有的时候，面向过程编程反倒更有优势。因为需求足够简单，整个程序的处理流程就只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程编程这种面条式的编程风格来实现。</p>
<p>​    但对于大规模复杂程序程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个流程的处理流程图画出来的话，会是一个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。</p>
<p>​    面向对象编程是以类为思考对象，在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</p>
<p>​    除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可定要定义数百个函数，数百个数据结构（struct），那么如何分门别类地组织这些函数和数据结构，才能不至于看起来比较混乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。</p>
<p>​    你可能想到，像C语言这种面向过程的编程语言，我们也可以按照功能不同，把函数和数据结构放到不同的文件中，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。这样当然也可以，只不过面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求。这也算是面向对象编程相对于面向过程编程的一个微创新吧。</p>
<p>​    实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过比直接用面向对象的编程语言可能需要付出的代价更高一些。而且，面向过程编程和面向对象编程并非完全对立的，很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。</p>
<h4>2、OOP风格的代码更易复用、易扩展、易维护</h4>

<p>​    在上一节的例子中，因为代码比较简单，所以只用到了类、对象这两个最基本的面向对象概念，并没有用到更加高级的四大特性，封装、抽象、继承、多态。因此，面向对象的优势其实并没有发挥出来。</p>
<p>​    面向过程编程是一种非常简单的编程风格，并没有向面向对象编程那样提供丰富的特性，而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。</p>
<p>​    首先，来看封装特性。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会向<strong>面向过程编程那样，数据可以被任意的方法随意修改</strong>。因此，面向对象提供的封装特性更有利于提高代码的已维护性。【对于调用者来说，知道的越少，需要维护的也就越少】</p>
<p>​    其次，对于抽象特性。我们知道，函数本身就是一种抽象，它隐藏了具体的实现。我们在使用函数的时候，只需要了解函数的功能，而不需要了解它是怎么实现的。从这一点上，不管是面向对象编程还是面向过程编程，都支持抽象特性。不过，面向对象编程还提供了其它抽象特性的实现方式。这些实现方式是面向过程编程所不具有的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性，提高了代码的可扩展性。【当然，这其实还用到了面向对象的多态特性】</p>
<p>​    再次，对于继承特性。继承特性时面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的属性和方法，抽取到父类中，让两个子类继承父类，这样两个子类就可以复用父类中的代码，避免代码冲虚写多遍，提高了代码的复用性。</p>
<p>​    最后，对于多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际代码的运行中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭，对扩展开放”的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码复用性。</p>
<p>​    所以说，基于这四大特性，利用面向对象编程，我们可以更轻松地写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些。</p>
<h4>3、OOP语言更加人性化、更加高级、更加智能</h4>









<h2 id="有哪些看似是面向对象实际是面向过程风格的代码？"><a href="#有哪些看似是面向对象实际是面向过程风格的代码？" class="headerlink" title="有哪些看似是面向对象实际是面向过程风格的代码？"></a>有哪些看似是面向对象实际是面向过程风格的代码？</h2><p>​    现如今，大部分的编程语言都是面向对象编程语言，大部分软件都是基于面向对象这种编程范式来开发的。不过，在实际开发中，很多开发者对面向对象编程都有误解，总是以为把所有代码都塞到类里面，自认为就是在进行面向对象编程了。实际上这样的认知是不正确的，有时候表面上看似是面向对象编程风格的代码 ，本质上却是面向过程风格的。</p>
<p>​    使用面向编程语言编写面向过程风格的代码，有时候是有意为之，并无不妥；而有些却是无意为之，会影响到代码质量。下面我们将通过三个典型的代码案例来具体展示一下，什么样的代码看似是面向对象风格，实际上是面向过程风格的。</p>
<h4>1、滥用 getter、setter 方法</h4>

<p>​    在很多项目开发中，一些开发者在定义完类的属性后，就顺手把这些属性的 getter、setter 方法都定义上，更有甚者直接用 Lombok 插件自动生成所有属性的 setter、getter 方法。这一行为的理由往往是：为了以后可能会用到，现在事先定义好，之后用起来就更加方便，而且即使用不到这些 getter、setter 方法，定义它们也无伤大雅。</p>
<p>​    实际上，这样的做法其实在一些大公司是非常不推荐的。<u>它违反了面向对象的封装特性</u>，相当于将面向对象编程风格退化为面向过程编程风格。我们通过一个例子来理解一下这句话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/15 21:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> itemsCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> totalPrice;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ShoppingCartItem&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemsCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItemsCount</span><span class="params">(<span class="type">int</span> itemsCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.itemsCount = itemsCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalPrice</span><span class="params">(<span class="type">double</span> totalPrice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.totalPrice = totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(ShoppingCartItem item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.add(item);</span><br><span class="line">        itemsCount++;</span><br><span class="line">        totalPrice += item.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其它方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，ShoppingCart 是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。对于 itemsCount、totalPrice 两个属性，我们定义了它的 getter、setter 方法，对于 items 属性，我们定义了它的 getter 方法和 addItem() 方法。代码很简单，理解起来不难。那么其中存在哪些问题呢？</p>
<p>​    首先我们来看前两个属性， itemsCount 和 totalPrice，虽然我们将它定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性完全没什么两样了。外部可以通过 setter 方法随意修改这两个属性的值。任意代码都可以随意调用 setter 方法，来重设 itemsCount、totalPrice 属性的值，这就会导致其跟 items 属性的值不一致。</p>
<p>​    而面向对象封装特性的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p>
<p>​    看完前两个属性，我们再来看看 items 这个属性，对于 items 这个属性，我们定义了它的 getter 方法和 addItem() 方法，并没有定义它的 setter 方法。这样的设计貌似看起来没有什么问题，但实际上不是。</p>
<p>​    对于 itemsCount 和 totalPrice 这两个属性来说，定义一个public 的 getter 方法，确实无伤大雅，毕竟 getter 方法不会修改数据。但是，对于 items 属性就不一样了，这是因为 items 属性的 getter 方法，返回的是一个 List 集合容器。外部调用者在拿到这个容器后，是可以在不改变容器地址的情况下操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据。比如像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">...</span><br><span class="line">cart.getItems.clear(); <span class="comment">// 清空购物车</span></span><br></pre></td></tr></table></figure>

<p>​    你可能会觉得，清空购物车这样的功能需求看上去合情合理呀。没错，这个需求是合理的，但是上面这种写法会导致 itemsCount、totalPrice、items 三者数据不一致。我们不应该将情况购物车的业务逻辑暴露给上层调用者。正确的做法应该是，在 ShoppingCart 类中定义一个 clear() 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart 类的 clear() 方法的具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">	<span class="comment">// 省略其它代码...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        items.clear();</span><br><span class="line">        <span class="built_in">this</span>.itemsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.totalPrice = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    你可能还会说，我有一个需求，就是要查看购物车中都买了哪些商品，那这个时候，ShoppingCart 类就不得不提供 items 属性的 getter 方法了，那又该怎么办才好呢？</p>
<p>​    在Java中，我们可以通过 <code>Collections.unmodifiableList()</code> 让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，这个容器类中重写了 List 容器中与修改数据相关的方法，如 add()、clear() 等。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改。具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(<span class="built_in">this</span>.items);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnmodifiableList 部分源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnmodifiableList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">UnmodifiableCollection</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">        List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line">        items.clear(); <span class="comment">// 抛出 UnsupportedOperationException 异常  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不过，这样的实现思路还是有一些问题。因为当调用者通过 ShoppingCart 的 getItems() 获取到 items 之后，虽然无法直接在容器层面修改数据，但是我们仍然可以从容器中单个对象的层面，修改每个对象（ShoppingCartItem ）的数据。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">    List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line">    <span class="type">ShoppingCartItem</span> <span class="variable">item</span> <span class="operator">=</span> items.get(<span class="number">0</span>);</span><br><span class="line">    item.setPrice(<span class="number">10.0</span>); <span class="comment">// 这里修改了 item 的价格属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题的解决方案就要用到之后的设计模式了。</p>
<p>​    总的来说，在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防备集合内部数据被修改的风险。</p>
<h4>2、滥用全局变量和全局方法</h4>

<p>​    我们再来看看，另一个违反面向对象编程的例子，那就是滥用全局变量和全局方法。</p>
<p>​    在C语言这种面向过程编程的语言中，全局变量、全局方法到处可见，但是在Java这种面向对象的编程语言中，全局变量和全局方法就比较少见了。</p>
<p>​    在面向对象编程中，常见的全局变量有：单例对象、静态成员变量、常量等；常见的全局方法有静态方法。单例对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。静态方法一般用来操作静态变量或外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程编程风格。【比如，Utils类中往往只包含方法，方法需要的数据都是从其它类中获取到的，数据结构与方法分离】</p>
<p>​    在刚刚介绍了全局变量和全局方法中，Constants类和Utils类最长用到。现在我们集合这两个类来深入探讨一下全局变量和全局方法的利与弊。</p>
<p>​    我们先来看一下，一种常见的 Constants 类的定义方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/16 10:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_ADDR_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_addr&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_DB_NAME_KEY</span> <span class="operator">=</span> <span class="string">&quot;db_name&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_USERNAME_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_username&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_PASSWORD_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_DEFAULT_ADDR</span> <span class="operator">=</span> <span class="string">&quot;192.168.1.101:6379&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_DEFAULT_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;rt:&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略更多的常量定义</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在这段代码中，我们把程序中用到的所有常量，都集中地放到这个 Constant 类中。不过，这样一个大而全的 Constants 类，并不是一种很好的设计思路。</p>
<p>​    首先，这样设计会<strong>影响代码的可维护性</strong>。如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类中添加常量，那么这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。</p>
<p>​    其次，这样的设计还会<strong>增加代码的编译时间</strong>。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那么每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。而对于一个非常大的项目来说，编译一次项目花费的时间可能是几分钟，甚至十几分钟。而在我们的开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就可能会影响到我们的开发效率。【单元测试编译过程是增量编译，只对发生修改的类重新编译，依赖 Constants 的类越多，修改 Constants 后重新编译的时间就越长】 </p>
<p>​    最后，这样的设计还会<strong>影响代码的复用性</strong>。如果我们要在另一个项目中复用本项目开发的某个类，而这个类又依赖于 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中。</p>
<p>​    那么如何改进 Constants 类的设计呢？下面有两种思路可以借鉴。</p>
<p>​    第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们就放到 MySqlConstants 类中，跟 Redis 配置相关的常量，我们就放到 RedisConstants 类中。另一种是更加面向对象的思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了哪个常量，我们就直接把这个常量定义在这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，我们就把这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。</p>
<p>​    讲完了 Constants 类，我们再来讨论一下 Utils 类。首先，我们应该思考一下：为什么需要 Utils 类？</p>
<p>​    实际上，Utils 类出现的背景是基于这样一个问题：如果我们有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复开发，我们不应该在两个类中，将这个相同的功能逻辑重复实现两遍。这个时候应该怎么办呢？</p>
<p>​    首先，你应该想到可以使用面向对象的继承特性。利用继承特性，我们可以把相同的属性和方法抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有时候，从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。如果仅仅为了代码复用，硬生生抽象出一个父类来，会影响代码的可读性。</p>
<p>​    既然继承解决不了这个问题，我们可以定义一个新的类，实现 URL 拼接和分割的方法。而<u>拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性</u>，这个时候，我们就可以把它定义为只包含静态方法的 Utils 类了。</p>
<p>​    实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，他在软件开发中还是挺有用的，能解决代码复用问题。所以，我们并不是说完全不能用 Utils 类，而是要尽量避免滥用，不要不加思考地随意去定义 Utils 类。</p>
<p>​    在定义 Utils 类之前，你要问一下自己，你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其它类中呢？如果在考虑完这些问题后，还是觉得有必要去定义这样一个 Utils 类，那么就大胆地去定义吧。因为在面向对象编程中，也并不是完全排斥面向过程风格的代码、只要它能为我们写出好的代码共享力量，我们就可以适度地去使用。【A需要，B需要，但A与B无关】</p>
<p>​    除此之外，类比 Constants 类的设计，我们设计 Utils 类的时候，最好也细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUitls、StringUtils、UrlUtils 等，不要设计一个大而全的 Utils 类。</p>
<h4>3、定义数据和方法分离的类</h4>

<p>​    我们再来看一下最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是“<strong>数据定义在一个类中，方法定义在另一个类中</strong>”。并且，这个问题在基于 MVC 三层架构做 Web 后端开发的代码中普遍存在。</p>
<p>​    传统的 MVC 结构分为 Model 层、Controller 层、View 层三层。不过，在前后端分离之后，三层结构在后端开发中调整为  Controller、Service、Mapper 三层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑处理，Mapper  层负责数据读写。而在每一次层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Mapper 类中。这就是典型的面向过程的编程风格。</p>
<p>​    实际上，这种开发模式叫做<strong>基于贫血模型的开发模式</strong>，也是现在非常常用的一种 Web 项目的开发模式。那么，既然这种开发模式明显违背了面向对象的编程风格，那么为什么大部分的 Web 项目都是基于这种开发模式来开发的呢？这个问题的答案，参见：TODO</p>
<h2 id="在面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#在面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="在面向对象编程中，为什么容易写出面向过程风格的代码？"></a>在面向对象编程中，为什么容易写出面向过程风格的代码？</h2><p>​    我们在进行面向对象编程的时候，很容易就不由自主地写出了面向过程编程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？</p>
<p>​    你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步步顺序执行一系列操作，最终完成整个任务。面向过程编程风格恰恰符合人的这种流程化的思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。这样的思考路径比较适合复杂程序的开发，但并不符合人类的思考习惯。</p>
<p>​    如果将类类比成角色，可以这么理解，张三是个产品经理，他会设计产品；李四是个UI，他可以根据原型图画出漂亮的界面；王五是个程序员，他会设计架构和敲代码。现在甲方提出需要一个网上购物平台，按照面向过程的思维就是，我得先去学产品设计，再学UI，最后学代码，全部学会之后我就可以把系统做出来了。而在面向对象的思维中，可能是这样，我什么都不会，但是我认识很多人，我知道有人会，我去沟通张三、李四、王五，我先让张三设计原型图，我拿到原型图之后再去找李四让他给我设计页面，最后我拿着李四设计的页面让王五去给我实现，这样系统也就做好了。</p>
<p>​    在这个例子中，总共就三个流程，张三、李四、王五每人只使用了一门手艺，看起来面向对象和面向过程在复杂度上并无太大的差距。但是把这个问题发散一下，完成某个任务需要三百个流程，并且这些流程互相调用呈网状结构，如果按照面向过程思维，确实十分复杂。而使用面向对象思维，我们可以使用三十个人，每人只要会十门手艺，并且让这些人能相互联系，这样程序的复杂度就能大大降低。</p>
<p>​    【面向对象编程就是粒度更大的编程，面向过程以函数和数据结构为基本单位，在函数或数据结构数量达到几百几千之后就变得不容易管理。而面向对象则是以类和对象为基本单位，将数据结构和函数归属于类内部，每个类包含多个数据结构和函数，这样就可以将面向过程的几百几千个函数按照一定规则减少到几十个，更加容易管理，更适合复杂系统】</p>
<p>​    除此之外，面向对象编程要比面向过程编程更难一些。在面向对象编程中，类的设计还是挺需要技巧和设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的交互关系等等诸多问题。</p>
<p>​    所以，基于这两点原因，很多程序员在开发的时候，更倾向于不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。</p>
<h2 id="面向过程编程和面向过程-编程语言真的无用武之地了吗？"><a href="#面向过程编程和面向过程-编程语言真的无用武之地了吗？" class="headerlink" title="面向过程编程和面向过程 编程语言真的无用武之地了吗？"></a>面向过程编程和面向过程 编程语言真的无用武之地了吗？</h2><hr>
<h1 id="08-理论五：接口-vs-抽象类的区别？如何用普通的类模拟抽象类和接口？"><a href="#08-理论五：接口-vs-抽象类的区别？如何用普通的类模拟抽象类和接口？" class="headerlink" title="08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？"></a>08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？</h1><p>​    在面向对象编程中，抽象类和接口是两个经常要用到的语句，是面向对象四大特性、以及很多设计模式、设计思想、设计原则编程实现的基础。比如，我们可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等等。</p>
<p>​    不过，并非所有的面向对象编程语言都支持这两个语法概念，比如，C++就只支持抽象类，不支持接口；Python既不支持接口，也不支持抽象类。尽管这些编程语言没有提供现成的语法来支持接口和抽象类，但是我们仍然可以通过一些手段来模拟实现这两个语法概念。在Java中，既支持抽象类，也支持接口。</p>
<h2 id="什么是抽象类和接口？区别在哪里？"><a href="#什么是抽象类和接口？区别在哪里？" class="headerlink" title="什么是抽象类和接口？区别在哪里？"></a>什么是抽象类和接口？区别在哪里？</h2><h4>Java中的抽象类</h4>

<p>​    下面这段代码是一个比较典型的抽象类的使用场景（模板设计模式）。Logger类是一个记录日志的抽象类，FileLogger和MessageQueueLogger继承Logger，分别实现两种不同的日志记录方式，记录到日志文件中和记录到消息队列中。FileLogger和MessageQueueLogger复用了父类Logger中的name、enabled、minPermittedLevel属性和log()方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的 doLog() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/16 11:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel; <span class="comment">// 日志的最小级别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">        <span class="keyword">if</span> (!loggable) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        doLog(level, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到消息中间件（如Kafka）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient messageQueueClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, MessageQueueClient messageQueueClient)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient = messageQueueClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到消息中间件</span></span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient.send(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这个例子，我们来总结一下，抽象类具有哪些特性：</p>
<ul>
<li>  抽象类不允许被实例化。</li>
<li>  抽象类可以包含属性和方法，方法既可以有实现（比如Logger中 log() 方法），也可以不包含实现（比如Logger中的 doLog() 方法）。不包含代码实现的方法叫做抽象方法。</li>
<li>  子类继承抽象类，必须实现抽象类中的所有抽象方法或继续声明为抽象类。对应到例子中就是，所有继承Logger抽象类的子类，都必须重写 doLog() 方法。</li>
</ul>
<h4>Java中的接口</h4>

<p>上面讲了Java中如何定义抽象类，我们再来看一下Java中如何定义接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/19 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthenticationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 鉴权逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 限流逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器使用demo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">    <span class="comment">// filters.add(new AuthenticationFilter())</span></span><br><span class="line">    <span class="comment">// filters.add(new RateLimitFilter())</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRpcRequest</span><span class="params">(RpcRequest req)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">                filter.doFilter(req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RpcException e)&#123;</span><br><span class="line">            <span class="comment">// 处理过滤结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略其它处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面这段代码是一个比较典型的接口的使用场景。我们通过 interface 关键字定义了一个 Filter 接口，AuthenticationFilter 和 RateLimitFilter 是接口的两个实现类，分别实现了对 RPC 请求鉴权和限流的过滤功能。</p>
<p>通过这个例子，我们再来总结以下，接口有哪些特性：</p>
<ol>
<li> 接口不能包含属性（也就是成员变量）。</li>
<li> 接口只能声明方法，方法不能包含代码实现。</li>
<li> 实现接口的时候，必须实现接口中声明的所有方法。</li>
</ol>
<p>​    前面我们讲了抽象类和接口的定义，以及各自的语法特性。从语法特性上比，这两者有较大的区别，但这种区别并不是绝对的，在不同的JDK版本中部分语法特性可能略有区别。我们今天主要的目的是要从设计的角度进行这两者的比较。</p>
<p>​    从设计角度来看，抽象类实际上实际上就是类，这种类不能被实例化成对象，只能被子类继承。我们知道，继承是一种 is-a 关系，那么抽象类既然属于类，也表示一种 is-a 的关系。相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是<strong>协议（contract）</strong>。</p>
<h2 id="抽象类和接口能解决什么问题？"><a href="#抽象类和接口能解决什么问题？" class="headerlink" title="抽象类和接口能解决什么问题？"></a>抽象类和接口能解决什么问题？</h2><p>​    上面我们学习了抽象类和接口的定义和区别，现在我们再来学习一下，抽象类和接口存在的意义。</p>
<h4>首先，我们来看一下，为什么需要抽象类？它能解决什么编程问题？</h4>

<p>​    刚刚我们讲到，抽象类不能被实例化，只能被<u>继承</u>。而在前面的章节中，我们还讲过<u>继承</u>能解决代码复用的问题。以此类推，抽象类也是用来解决代码复用问题的。多个子类可以继承抽象类中定义的共有属性和方法，避免在子类中，重复编写相同的代码。</p>
<p>​    【问题】不过，既然继承本身就能达到代码复用的目的，而继承也并不要求父类一定是抽象类，那么我们不使用抽象类，照样也可以实现继承和复用。从这个角度上讲，我们貌似并不需要抽象类这种语法呀。那么抽象类除了解决代码复用的问题，还有什么其它存在的意义吗？</p>
<p>​    我们还是拿之前那个打印日志的例子来讲，在改造之后的代码中，Logger不再是抽象类，只是一个普通的父类，删除了 Logger 中的 log()、doLog() 方法，新增了 isLoggable() 方法。FileLogger 和 MessageQueueLogger 还是继承 Logger 父类，已达到代码复用的目的。具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类，非抽象类，删除了log()、doLog()方法，新增了isLoggable()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel; <span class="comment">// 日志的最小级别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoggable</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level level)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">        <span class="keyword">return</span> loggable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：输出日志到消息中间件（如Kafka）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient messageQueueClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, MessageQueueClient messageQueueClient)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient = messageQueueClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到消息中间件</span></span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient.send(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设计虽然也能达到代码复用的目的，但是却无法使用多态特性了。像下面这种代码，就会出现编译错误，因为 Logger 中没有定义 log() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(<span class="string">&quot;access-log&quot;</span>, <span class="literal">true</span>, Level.WARN, <span class="string">&quot;/tmp/logFile&quot;</span>);</span><br><span class="line">logger.log(Level.ERROR, <span class="string">&quot;This is a test log message&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>你可能会说，这个问题解决起来很简单啊。我们在 Logger 父类中，定义一个空的 log() 方法，让子类重写父类的 log() 方法，实现自己记录日志的逻辑，不就可以了么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">		<span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">	<span class="comment">// 省略部分代码...   </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">	<span class="comment">// 省略部分代码...   </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化level和message，输出到消息中间件</span></span><br><span class="line">        <span class="built_in">this</span>.messageQueueClient.send(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实，这种设计思路是可以实现我们的目的的。但是，它显然没有之前通过抽象类的实现思路优雅。为什么这么说呢？主要有以下几点原因。</p>
<ul>
<li>  <strong>更优雅</strong>。在 Logger 中定义一个空的方法，会影响代码的可读性。如果我们不熟悉 Logger 背后的设计思想，代码注释又不怎么给力，我们在阅读 Logger 代码的时候，就可能会对为什么定义一个空的 log() 方法而感到疑惑，需要查看 Logger、FileLogger、MessageQueueLogger 之间的继承关系，才能明白其设计意图。</li>
<li>  <strong>更强制</strong>。当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记实现 log() 方法。而基于抽象类的设计思路，编译器会强制要求子类重写 log() 方法，否则会报编译错误。</li>
<li>  <strong>更安全</strong>。若使用非抽象类，则 Logger 类可以被实例化，我们可以 new 一个 Logger 对象出来，并且调用空的 log() 方法，这显然增加了类被误用的风险。当然，这个问题可以通过手动设置私有构造函数的方式来解决。不过，显然没有使用抽象类来得优雅。</li>
</ul>
<h4>其次，我们再来看一下，我们为什么要需要使用接口？它能解决什么编程问题？</h4>

<p>​    抽象类更多是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或契约。你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体实现，具体的实现代码对调用者透明。通过接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p>
<p>​    实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常听到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。</p>
<h5>
    如何模拟抽象类和接口两个语法概念？
</h5>

<p>​    【问题】在前面的例子中，我们使用的 Java 语言默认提供了抽象类和接口两种实现标准。不过，如果你使用的语言是 C++ 这种没有提供接口语法的编程语言，那从代码实现的角度上来讲，是不是就无法实现 Filter 过滤器的思路了呢？</p>
<p>​    实际上，我们可以通过抽象类来模拟接口。怎么模拟呢？我们先来回忆一下接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，其实现类必须实现接口中的所有方法。只要满足这几点，从设计的角度上来说，我们就可以把它叫做接口。实际上，要满足这些语法特性并不难。下面这段C++代码中，我们就用抽象类模拟了一个接口（下面这段代码实际上是策略模式中的一段代码）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>&#123; <span class="comment">// 用抽象类模拟接口</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	~<span class="built_in">Strategy</span>();</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">alhorithm</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="built_in">Strategy</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>抽象类 Strategy 中没有定义任何属性，并且所有的方法都声明为 virtual 抽象类型，这样，所有的方法都不能有代码实现，并且继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于是一个接口。</p>
<p>​    【问题】不过，如果你使用是类似 Python 这种既没有接口，又没有抽象类的编程语言，那该如何实现上面讲到的 Filter、Logger 的设计思路呢？实际上，除了使用抽象类来模拟接口之外，我们还可以用普通类来模拟接口。具体的 Java 代码实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mockInterface</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">mockInterface</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodUnSupportedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们知道方法必须包含实现，这不符合接口的定义。但是<u>我们可以让类中的方法抛出 MethodUnSupportedException 异常来模拟不包含实现类的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常</u>。那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为 private 访问权限就可以了。</p>
<p>​    实际上，对于动态编程语言，还有一种对接口支持的策略，那就是 duck-typing。这点在之前的章节中讲过。</p>
<h2 id="如何决定该用接口还是抽象类？"><a href="#如何决定该用接口还是抽象类？" class="headerlink" title="如何决定该用接口还是抽象类？"></a>如何决定该用接口还是抽象类？</h2><p>​    上面讲的都是一些方法论，那么，在实际设计、开发的时候，什么时候该用抽象类？什么时候该用接口呢？</p>
<p>​    实际上，判断的标准很简单。<strong>如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 的关系，，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</strong></p>
<p>​    <u>从类的继承层次来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象出上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计私立，我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</u></p>
<hr>
<h1 id="09-理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#09-理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h1><p>​    在平时的开发中我们经常会听到并用到“基于接口而非实现编程”，这是一种非常有效的提高代码质量的手段。但是并非每个人都能用好这一准则，不用或过度使用都会使你编写的代码不够优雅。为了让你理解透彻这条原则，接下来我们会结合一个图片存储的实战案例来讲解，告诉你如何权衡，怎样恰到好处地应用这条原则。</p>
<h2 id="如何理解原则中的“接口”二字？"><a href="#如何理解原则中的“接口”二字？" class="headerlink" title="如何理解原则中的“接口”二字？"></a>如何理解原则中的“接口”二字？</h2><p>​    我们在理解“基于接口而非实现编程”这条原则时，千万不要一开始就与某种具体的编程语言挂钩，局限在某种语言的“接口”语法中（比如Java中的interface接口语法）。要知道，这条原则最早出现在1994年GoF《设计模式》这本书中，它比很多编程语言（如Java）诞生得都要早，因此不可能是为了迎合某种编程语言而创建的概念，你需要把它提到的“接口”理解成一种比较抽象、泛化的概念。</p>
<p>​    实际上，理解这条原则的关键就在于“接口”二字。我们在上一节中说过，从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，前后端联调的“接口”，类库提供的“接口”。刚刚对“接口”的理解，都是比较偏上层、偏抽象的，如果落实到具体的编码，“基于接口编程而非实现编程”这条原则中的接口，可以理解为编程语言中的接口或者抽象类。</p>
<p>​    前面我们说过，这条原则能非常有效地提高代码质量，之所以这么说是因为，应用这条原则，可以将接口和实现相分离，封装（隐藏）不稳定的实现，暴露稳定的接口。<u>上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本不需要做改动，</u>以此来降低耦合性（一方的改变不强制要求另一方改变），提高扩展性。</p>
<p>​    <u>实际上，“基于接口而非实现编程”这条原则的另一个表示方式是“基于抽象而非实现编程”</u>。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍能够在不破坏原有代码设计的情况下灵活应对。</strong>而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p>
<h2 id="如何将这条原则应用到实战中？"><a href="#如何将这条原则应用到实战中？" class="headerlink" title="如何将这条原则应用到实战中？"></a>如何将这条原则应用到实战中？</h2><p>​    对于这条原则，我们结合一个具体的实战案例来进一步讲解一下。</p>
<p>​    假设我们的系统中有很多涉及图片处理和存储的相关业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/19 20:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> &#123;</span><br><span class="line">    <span class="comment">// 省略属性、构造函数等...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">// 失败会抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 根据accesskey/secretkey等生成access token...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadToAliyun</span><span class="params">(Image image, String bucketName, String accessToken)</span>&#123;</span><br><span class="line">        <span class="comment">// 上传图片到阿里云...</span></span><br><span class="line">        <span class="comment">// 返回图片存储在阿里云上的地址（url）...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">downloadFromAliyun</span><span class="params">(String url, String accessToken)</span>&#123;</span><br><span class="line">        <span class="comment">// 从阿里云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunImageStore类的使用案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;my_image_bucket&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">// 处理图片，并封装成Image对象</span></span><br><span class="line">        <span class="type">AliyunImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliyunImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> imageStore.generateAccessToken();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> imageStore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    整个上传流程包含三个步骤：创建 bucket、生成 accessToken 访问凭证、携带 accessToken 上传图片到指定的 bucket 中。代码实现非常简单，用起来也很清晰，乍一看没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p>
<p>​    不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到私有云上。为了满足这样一个需求的变化，我们应该如何修改代码呢？</p>
<p>​    我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说。“细节是魔鬼”，这句话在软件开发中尤其适用。实际上，刚刚设计的实现方式，就隐藏了很多容易出问题的“坏味道”，我们一起来看看都有哪些。</p>
<p>​    新的 PrivateImageStore 类需要设计哪些方法，才能在尽量<u>最小化代码修改</u>的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，主要有以下两点。</p>
<ul>
<li>  首先，AliyunImageStore 类中的有些函数名暴露了实现细节，比如 uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中对这些方法重新命名，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码的修改量就可能回很大。</li>
<li>  其次，将图片存储到阿里云的流程，可能并不是完全一致的，比如，阿里云在图片上传和下载过程中，需要携带 accessToken，而私有云则不需要。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法就不再适合照抄到 PrivateImageStore 类中了；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</li>
</ul>
<p>那这两个问题应该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则。具体来讲，我们要落实到以下3点：</p>
<ol>
<li> 函数的命名不应该暴露任何实现细节。比如，前面使用的 uploadToAliyun() 就不符合要求，应该改为更抽象的命名方式，比如 upload()。</li>
<li> 封装具体的实现细节。比如，跟阿里云相关的特殊流程（如获取accessToken）不应该暴露给调用者。我们应该将其封装到通用流程（上传和下载）中，只对调用者暴露通用流程。</li>
<li> 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>
</ol>
<p>我们照着这个思路，把代码重构以下。重构后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.lnd.designPrincipes._09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/19 20:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImageStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String url)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createBucketIfNotExisting(bucketName);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.generateAccessToken();</span><br><span class="line">        <span class="comment">// 上传图片到阿里云...</span></span><br><span class="line">        <span class="comment">// 返回图片存储在阿里云上的地址（url）...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> <span class="built_in">this</span>.generateAccessToken();</span><br><span class="line">        <span class="comment">// 从阿里云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">// 失败会抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 根据accesskey/secretkey等生成access token...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createBucketIfNotExisting(bucketName);</span><br><span class="line">        <span class="comment">// 上传图片到私有云...</span></span><br><span class="line">        <span class="comment">// 返回图片存储在私有云上的地址（url）...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="comment">// 从私有云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">// 失败会抛出异常...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageStore测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;my_image_bucket&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">// 处理图片，并封装成Image对象</span></span><br><span class="line">        <span class="type">ImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> imageStore.upload(image, BUCKET_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    除此之外，<u>很多人在定义接口的时候，希望能够通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。</u>这样的接口设计就没有意义了。不过，如果你觉得这种思维方式更为顺畅，那也没问题，只是将实现类的方法转移到接口定义中的时候，要有选择性的转移，不要将具体的实现相关的方法转移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。</p>
<p>​    总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。<u>接口的定义只表明做什么，而不是怎么做</u>。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够坐到在替换具体的接口实现的时候，不需要对接口的定义做任何改动。</p>
<h2 id="是否要为每个类都定义接口？"><a href="#是否要为每个类都定义接口？" class="headerlink" title="是否要为每个类都定义接口？"></a>是否要为每个类都定义接口？</h2><p>​    任何事情都要讲究一个“度”，同样，如果过度使用“面向接口而不是实现”这条原则，非得给每个类都定义接口，接口漫天飞，也会导致不必要的开发负担。至于什么时候，改为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</p>
<p>​    前面我们也提到，这条原则的设计初衷是，<u>将接口和实现相分离，封装不稳定的实现，暴露稳定的接口</u>。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当代码发生变化的时候，上游系统的代码基本需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</p>
<p>​    从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其它实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程了，直接使用实现类就可以了。</p>
<p>​    除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性投入不必要的开发时间。</p>
<h2 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h2><p>​    在本节的代码例子中，尽管我们通过使用接口来隔离了两个具体实现。但是，在项目中很多地方，我们都是通过下面第7行代码的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片的存储方式，还是需要修改很多类似第7行那样的代码。这样的设计还是不够完美，对此，你有更好的思路吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageStore测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;my_image_bucket&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">// 处理图片，并封装成Image对象</span></span><br><span class="line">        <span class="type">ImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> imageStore.upload(image, BUCKET_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="10-理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？"><a href="#10-理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？" class="headerlink" title="10 | 理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？"></a>10 | 理论七：为和说要多用组合少用继承？如何决定该用组合还是继承？</h1><p>在面向对象编程中，有一条非常经典的设计原则，那就是：<strong>组合优于继承，多用组合少用继承。</strong></p>
<blockquote>
<ul>
<li>  为什么不推荐使用继承？【继承的缺点】</li>
<li>  组合相比于继承有哪些优势？【组合的优点】</li>
<li>  如何判断该用组合还是继承？【如何抉择】</li>
</ul>
</blockquote>
<p>本节我们就围绕着这三个问题，来讨论一下这条设计原则。</p>
<h2 id="为什么不推荐使用继承？"><a href="#为什么不推荐使用继承？" class="headerlink" title="为什么不推荐使用继承？"></a>为什么不推荐使用继承？</h2><p>​    继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可读性、可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议，很多人觉得继承是一种反模式，应该尽量少用甚至不用。至于为什么会有这样的争议，我们通过一个例子来解释一下。</p>
<p>​    假设我们要设计一个“鸟类“。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子等，都继承这个类。</p>
<p>​    我们知道，大部分的鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分的鸟都会飞，但也有特例，比如鸵鸟就不会飞。如果鸵鸟继承具有 fly() 方法的父类，那鸵鸟就凭空出现了“飞”这样的行为，这显然不符合我们对现实世界中事物的认知。当然，你可能会说，我可以在鸵鸟这个子类中重写 fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractBird</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 鸟会飞...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">AbstractBird</span>&#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnSupportedMethodException</span>(<span class="string">&quot;I can&#x27;t fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这种设计思路虽然可以解决问题，但是不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法并抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了“最小知识原则（Least Knowledge Principe，也叫迪米特法则）”，暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p>
<p>​    你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、鸽子这些会飞的鸟继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟都继承 AbstractUnFlyableBird，不就可以了么。  </p>
<p><img src="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%EF%BC%88Part1%EF%BC%89/image-20220320110025182.png" alt="image-20220320110025182"></p>
<p>​    从图中我们可以看出，继承关系变成了三层。不过，从整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度，在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p>
<p>​    是否会飞？是否会叫？两个行为搭配起来会产生四种行为：会飞会叫、会飞不会叫、不会飞会叫、不会飞不会叫。如果我们继续沿用刚才的思路，那就需要再定义四个抽象类：AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird。此时继承关系就变成了四层。</p>
<p>​    如果我们还要考虑“是否会下蛋”这一行为，那估计就要组合爆炸了。类的继承层次会越来深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码…一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装，将父类的实现细节暴露给了子类【从父类命名中就可以看出父类的实现细节】。子类依赖父类实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</p>
<p>​    总之，<u>继承最大的问题就在于：继承的层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。</u>这也是我们为什么不推荐使用继承的原因。那刚刚例子中的继承存在的问题，我们又该如何来解决呢？</p>
<h2 id="组合相比继承有哪些优势？"><a href="#组合相比继承有哪些优势？" class="headerlink" title="组合相比继承有哪些优势？"></a>组合相比继承有哪些优势？</h2><p>​    实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿解决刚刚继承存在的问题。</p>
<p>​    我们前面讲接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸵鸟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable&#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 麻雀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Tweetable, EggLayable&#123;</span><br><span class="line">    <span class="comment">// 省略其它属性和方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p>
<p>​    我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类，实现了 tweet() 方法的 TweetAbility 类，实现了 lagEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除重复。具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyAbility</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TweetAbility</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EggLayAbility</span> <span class="keyword">implements</span> <span class="title class_">EggLayable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸵鸟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TweetAbility</span> <span class="variable">tweetAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TweetAbility</span>(); <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EggLayAbility</span> <span class="variable">eggLayAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EggLayAbility</span>(); <span class="comment">// 组合</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">        tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其它技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来代替；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上来讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或少用继承关系，特别是一些复杂的继承关系。</p>
<h2 id="如何判断该用组合还是继承？"><a href="#如何判断该用组合还是继承？" class="headerlink" title="如何判断该用组合还是继承？"></a>如何判断该用组合还是继承？</h2><p>​    尽管我们鼓励多用组合少用继承，但组合也并非是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加了代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</p>
<p>​    如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来代替继承。</p>
<p>​    除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰器模式、策略模式、组合模式等都使用了组合关系，而模板模式使用了继承关系。</p>
<p>​    前面我们讲到了继承可以实现代码复用。利用继承特性，我们把相同的属性和方法抽取出来，定义到父类中，子类复用父类中的属性和方法，达到代码复用的目的，但是，有时候从业务含以上讲，A类和B类并不一定具有继承关系，比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。如果仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这种情况下，使用组合就更加合理、更加灵活。具体的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">    <span class="comment">// 省略属性和方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crawler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Url url; <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Crawler</span><span class="params">(Url url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = <span class="keyword">new</span> <span class="title class_">Url</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageAnalyzer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Url url; <span class="comment">// 组合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageAnalyzer</span><span class="params">(Url url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = <span class="keyword">new</span> <span class="title class_">Url</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采取继承实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们就只能采用继承来实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClient</span> &#123; <span class="comment">// FeignClient框架代码</span></span><br><span class="line">    <span class="comment">// 省略属性和方法...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(String url)</span>&#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoFunction</span><span class="params">(FeignClient feignClient)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    feignClient.encode();</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomizedFeignClient</span> <span class="keyword">extends</span> <span class="title class_">FeignClient</span> &#123; <span class="comment">// FeignClient框架代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(String url)</span>&#123;</span><br><span class="line">        <span class="comment">// 重写encode的实现...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="type">FeignClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomizedFeignClient</span>();</span><br><span class="line">demoFunction(client);</span><br></pre></td></tr></table></figure>

<p>​    尽管有些人说，要杜绝继承，100%使用组合代替继承，但这种观点多少有点极端。之所以“多用组合少用继承”这句口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也并非一无是处。只要我们控制好它的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，才是我们追求的最终目标。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">HTTP实验环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-07 17:48:05 / Modified: 19:56:56" itemprop="dateCreated datePublished" datetime="2022-03-07T17:48:05+08:00">2022-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>搭建一个“最小化”的环境，在这个环境里仅有 HTTP 协议的两个端点：请求方和应答方，去除一切多余的环节，从而可以抓住重点，快速掌握 HTTP 的本质。</p>
<p><img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/85cadf90dc96cf413afaf8668689ef0b.png" alt="img"></p>
<p>简单说一下这个“最小化”环境用到的应用软件：</p>
<ul>
<li>  Wireshark</li>
<li>  Chrome/Firefox</li>
<li>  Telnet</li>
<li>  OpenResty</li>
</ul>
<p><strong>Wireshark</strong> 是著名的网络抓包工具，能够截获在 TCP/IP 协议栈中传输的所有流量，并按协议类型、地址、端口等任意过滤，功能非常强大，是学习网络协议的必备工具。它就像是网络世界里的一台“高速摄像机”，把只在一瞬间发生的网络传输过程如实地“拍摄”下来，事后再“慢速回放”，让我们能够静下心来仔细地分析那一瞬到底发生了什么。</p>
<p><strong>Chrome</strong> 是 Google 开发的浏览器，是目前的主流浏览器之一。它不仅上网方便，也是一个很好的调试器，对 HTTP/1.1、HTTPS、HTTP/2、QUIC 等的协议都支持得非常好，用 F12 打开“开发者工具”还可以非常详细地观测 HTTP 传输全过程的各种数据。如果你更习惯使用 Firefox，那也没问题，其实它和 Chrome 功能上都差不太多，选择自己喜欢的就好。与 Wireshark 不同，Chrome 和 Firefox 属于“事后诸葛亮”，不能观测 HTTP 传输的过程，只能看到结果。</p>
<p><strong>Telnet</strong> 是一个经典的虚拟终端，基于 TCP 协议远程登录主机，我们可以使用它来模拟浏览器的行为，连接服务器后手动发送 HTTP 请求，把浏览器的干扰也彻底排除，能够从最原始的层面去研究 HTTP 协议。</p>
<p>OpenResty 你可能比较陌生，它是基于 Nginx 的一个“强化包”，里面除了 Nginx 还有一大堆有用的功能模块，不仅支持 HTTP/HTTPS，还特别集成了脚本语言 Lua 简化 Nginx 二次开发，方便快速地搭建动态网关，更能够当成应用容器来编写业务逻辑。选择 OpenResty 而不直接用 Nginx 的原因是它相当于 Nginx 的“超集”，功能更丰富，安装部署更方便。我也会用 Lua 编写一些服务端脚本，实现简单的 Web 服务器响应逻辑，方便实验。</p>
<p>我在 GitHub 上为本专栏开了一个项目：http_study，可以直接用“git clone”下载，或者去 Release 页面，下载打好的压缩包。我使用的操作环境是 Windows 10，如果你用的是 Mac 或者 Linux，可以用 VirtualBox 等虚拟机软件安装一个 Windows 虚拟机，再在里面操作（或者可以到“答疑篇”的Linux/Mac 实验环境搭建中查看搭建方法）。首先你要获取最新的 http_study 项目源码，假设 clone 或解压的目录是“D:\http_study”，操作完成后大概是下图这个样子。</p>
<hr>
<p>如果无法正常启动 OpenResty，最大的可能就是端口 80 或 443被占用了（比如安装了 VMWare workstation）。先查看 <code>www/logs</code> 里的错误日志，我自己的情况就是 VMWare 占用了 443 端口导致启动失败，此时找到占用 443 端口的进程，结束掉即可。具体步骤如下：</p>
<ol>
<li><p>找到占用 443 端口的进程</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr <span class="string">&quot;443&quot;</span>    查看端口443被哪个进程占用；</span><br></pre></td></tr></table></figure>

<p> <img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307123247611.png" alt="image-20220307123247611"></p>
</li>
<li><p>查看占用 443 进程的端口名</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | findstr <span class="string">&quot;4464&quot;</span>    查看进程号<span class="string">&quot;4464&quot;</span>对应的进程,找出被哪个程序占用;</span><br></pre></td></tr></table></figure></li>
<li><p>在任务管理器关闭进程</p>
<p> <img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307123158332.png" alt="image-20220307123158332"></p>
</li>
<li><p>在命令行窗口重新检查 443 端口的占用是否解除。如果解除则重新启动 OpenResty，即可正常启动。</p>
<p> <img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307123915274.png" alt="image-20220307123915274"></p>
</li>
</ol>
<hr>
<p>因为我们的实验环境运行在本机的 <code>127.0.0.1</code> 上，也就是 loopback “环回”地址。所以，需要安装 npcap 检测到这个地址。</p>
<p>在安装 Wireshark 时有一个选项会提醒我们安装 npcap，我们可以直接在这里安装 Npcap。安装完毕后一定要重启电脑让配置生效（重要！！！）</p>
<img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307194941346.png" alt="image-20220307194941346" style="zoom: 67%;">



<p>如果重启后在 Wireshark 中仍然找不到本地回环地址，则不要使用默认的 npcap，自己去官网找一个最新的 npcap 安装，之后重新安装 WireShark 即可。</p>
<ol>
<li> npcap 下载地址：<a target="_blank" rel="noopener" href="https://npcap.com/#download">https://npcap.com/#download</a></li>
</ol>
<p>以上工作全部完成后，在 Wireshark 的界面就可以检测到 “loopback” 环回地址了。</p>
<p><img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307194550899.png" alt="image-20220307194550899"></p>
<p><img src="/2022/03/07/HTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20220307195456658.png" alt="image-20220307195456658"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/02/SpringBoot%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E2%80%9C%E9%81%BF%E5%9D%91%E2%80%9D%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/02/SpringBoot%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E2%80%9C%E9%81%BF%E5%9D%91%E2%80%9D%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">SpringBoot实战开发“避坑”指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-02 20:05:15 / Modified: 21:12:44" itemprop="dateCreated datePublished" datetime="2022-03-02T20:05:15+08:00">2022-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">实战</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="T1：-ComponentScan-扫描的是类而不是接口"><a href="#T1：-ComponentScan-扫描的是类而不是接口" class="headerlink" title="T1：@ComponentScan 扫描的是类而不是接口"></a>T1：@ComponentScan 扫描的是类而不是接口</h1><p>​    在SpringBoot项目中，我们习惯在启动类上使用 <code>@SpringBootApplication</code> 注解完成全自动的一站式配置。 <code>@SpringBootApplication</code> 注解包含了一个子注解 <code>@ComponentScan</code>，这个注解的默认作用是扫描当前主类及其子包下的所有类并将其注入到容器中。这里要注意的一个点是“类”，也就是说它只负责扫描类，而不负责扫描接口。如果我们在启动类的一个子包如 controller 包中定义一个<strong>接口</strong> TestController，再启动项目试一试，就会抛出如下错误：</p>
<ol>
<li><p>在 controller 包下创建一个接口 TestDao</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.gulimall.member.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/2 19:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>在另一个 controller 中引用这个对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;member/member&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动项目时抛出如下错误：TestDao对象找不到</p>
<p> <img src="/2022/03/02/SpringBoot%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E2%80%9C%E9%81%BF%E5%9D%91%E2%80%9D%E6%8C%87%E5%8D%97/image-20220302201437977.png" alt="image-20220302201437977"></p>
</li>
<li><p>如果我们把 TestDao 的类型改为 “class”，发现项目又可以正常启动了</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.gulimall.member.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/2 19:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    从这个例子我们可以得出，<code>@ComponentScan</code> 扫描的是类而不是接口。那么这一错误在哪些场景下容易出现呢？其实只要扫描的包下存在接口就都可能会遇到这种情况。就我个人目前的使用情况来看，主要有两种：一是在 MyBatis 中，二是在 Spring Cloud 项目总使用 Feign 时。</p>
<ol>
<li> 在 MyBatis 中，因为 mapper 包下都是一些接口，如果使用 <code>@ComponentScan</code> 注解，那么在必然无法将接口的实现类注入到Spring容器中。这也是为什么使用 MyBatis 时必须要在配置类上额外添加 <code>@MapperScan(&quot;xxx.xxx.dao&quot;)</code> 注解的原因，添加该注解后，就可以将指定包下的接口的实现类以接口类型添加到容器中，在依赖注入时直接使用接口类型就可以找到对应的实现类。</li>
<li> 在 Spring Cloud 项目中使用 Feign 进行远程调用时也是类似的场景，由于 feign 包下保存的都是一些接口，所以同样需要在配置类中添加 <code>@EnableFeignClients(basePackages = &quot;xxx.feign&quot;)</code> 注解指定接口所在的位置，其原理于 MyBatis 类似。</li>
</ol>
<ul>
<li>  <strong>配置类示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.gulimall.member;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.example.gulimall.member.feign&quot;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.gulimall.member.dao&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallMemberApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GulimallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  dao包和feign包内成员展示（都是接口）</li>
</ul>
<img src="/2022/03/02/SpringBoot%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E2%80%9C%E9%81%BF%E5%9D%91%E2%80%9D%E6%8C%87%E5%8D%97/image-20220302203035084.png" alt="image-20220302203035084" style="zoom:50%;">



<p><strong>总结：</strong> <code>@ComponentScan</code> 注解只扫描“类”而不扫描“接口”，如果想要让接口以接口的类型自动加入Spring容器，一般需要通过额外的注解来实现，比如 MyBatis 的 <code>@MapperScan(basePackages = &quot;xxx&quot;)</code> 或 Feign 的 <code>@EnableFeignClients(basePackages = &quot;xxx&quot;)</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/21/%E6%AF%95%E8%AE%BE%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/21/%E6%AF%95%E8%AE%BE%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">毕设相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-21 16:50:14" itemprop="dateCreated datePublished" datetime="2022-02-21T16:50:14+08:00">2022-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-24 11:28:48" itemprop="dateModified" datetime="2022-02-24T11:28:48+08:00">2022-02-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="论文遗留"><a href="#论文遗留" class="headerlink" title="论文遗留"></a>论文遗留</h1><h3 id="1-1-研究背景"><a href="#1-1-研究背景" class="headerlink" title="1.1   研究背景"></a>1.1   研究背景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1000字左右</span><br><span class="line">1、	钻井物料管理现在的发展情况</span><br><span class="line">2、	钻井物料管理现在存在的问题</span><br><span class="line">3、	物联网发展  数据日增长量增加 =&gt; 拥有大量数据</span><br><span class="line">4、	生产环境中产生大量的数据</span><br><span class="line">5、	企业要怎么做</span><br><span class="line">做了有什么用——大数据环境下企业信息化建设的作用</span><br></pre></td></tr></table></figure>

<h3 id="1-3-研究内容和意义"><a href="#1-3-研究内容和意义" class="headerlink" title="1.3   研究内容和意义"></a>1.3   研究内容和意义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">500</span><br><span class="line">1、大数据技术起到的作用</span><br><span class="line">2、微服务技术起到的作用</span><br><span class="line">3、机器学习技术起到的作用</span><br></pre></td></tr></table></figure>

<h2 id="第二章-相关理论技术介绍"><a href="#第二章-相关理论技术介绍" class="headerlink" title="第二章 相关理论技术介绍"></a>第二章 相关理论技术介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何集成分析分散且异构的钻井数据源中的钻井物料清单数据，如何进行系统部署和如何进行实时数据的更新等</span><br></pre></td></tr></table></figure>

<h2 id="2-3-微服务相关理论技术概述"><a href="#2-3-微服务相关理论技术概述" class="headerlink" title="2.3 微服务相关理论技术概述"></a>2.3 微服务相关理论技术概述</h2><table>
<thead>
<tr>
<th>相关术语：</th>
</tr>
</thead>
<tbody><tr>
<td>存储系统：MySQL、Redis  业务系统</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>1、 什么是微服务  2、 为什么要用微服务  1. （0）单体架构的缺点：水平扩展性低，大规模复杂业务会导致，难以维护  2. （1）需求越来越多 è 业务逻辑越来越复杂（当前系统使用微服务具有可行性）  3. （2）硬件水平的发展，为了安全性考虑  4. （3）高并发  3、本文中使用的微服务的落地实现</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<h3 id="3-1-2-功能性需求分"><a href="#3-1-2-功能性需求分" class="headerlink" title="3.1.2    功能性需求分"></a>3.1.2    功能性需求分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）    钻井物料管理现状  </span><br><span class="line">（2）    系统功能设计  </span><br></pre></td></tr></table></figure>





<h3 id="3-2-2"><a href="#3-2-2" class="headerlink" title="3.2.2"></a>3.2.2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先要在Hive中制定统一的主题（Topic）和视图（Schema）标准用于存储来自不同子系统的钻井物料异构数据。对于结构化数据，可以使用Sqoop工具在数据同步的过程中，根据源数据的特点会将同步策略分为全量更新和增量及变化更新，全量更新每次完全同步一遍原始数据，增量及变化更新每次只同步新增数据及发生更新的数据，所有的数据在第一次同步时都会执行一次全量更新。</span><br><span class="line">通过对多个油田子公司异构数据的整合，可以实现不同结构数据之间数据信息资源、硬件资源和人力资源的合并和共享，加强宏观层面上对数据的把控，为决策提供数据支撑。</span><br><span class="line"></span><br><span class="line">石油钻井物料消耗状况具有极强的地域性，不同地貌下钻井物料清单的成分具有很强的差异性。通过统计分析不同地区的各个钻井公司关于钻井物料的库存、使用及购买情况的多方面的信息，有利于帮助管理者合理分配物料资源，降低油田开发成本，实现企业效益的最大化。</span><br><span class="line"></span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/29/MySQL%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/29/MySQL%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">MySQL日志系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-29 19:33:06 / Modified: 19:34:00" itemprop="dateCreated datePublished" datetime="2022-01-29T19:33:06+08:00">2022-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E6%96%B0%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">MySQL新版</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="日志系统：一条SQL更新语句是如何执行的？"><a href="#日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="日志系统：一条SQL更新语句是如何执行的？"></a>日志系统：一条SQL更新语句是如何执行的？</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/29/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/29/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">MySQL基础架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-29 19:29:05 / Modified: 19:32:37" itemprop="dateCreated datePublished" datetime="2022-01-29T19:29:05+08:00">2022-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E6%96%B0%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">MySQL新版</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础架构：一条SQL查询语句是如何执行的？"><a href="#基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="基础架构：一条SQL查询语句是如何执行的？"></a>基础架构：一条SQL查询语句是如何执行的？</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/28/MySQL-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/28/MySQL-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">MySQL-多版本并发控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-28 20:10:19" itemprop="dateCreated datePublished" datetime="2022-01-28T20:10:19+08:00">2022-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-07 21:39:44" itemprop="dateModified" datetime="2022-04-07T21:39:44+08:00">2022-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1 什么是MVCC"></a>1 什么是MVCC</h1><blockquote>
<p>  多版本并发控制，Multiversion Concurrency Control，MVCC</p>
</blockquote>
<p>顾名思义，MVCC 是通过表中记录的多个版本管理来实现数据库的并发控制。这项技术使得在 InnoDB 的事务隔离级别下执行一致性读操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<h1 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2 快照读与当前读"></a>2 快照读与当前读</h1><p>MVCC 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，<u>用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到不加锁</u>， 非阻塞并发读，而这个读指的就是快照读, 而非当前读。</p>
<p>当前读实际上是一种加锁的操作，是悲观锁的实现。而 MVCC 本质是采用乐观锁思想的一种方式。</p>
<h2 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h2><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的 SELECT 都属于快照读</strong>，即不加锁的非阻塞读。比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM player WHERE ...</span><br></pre></td></tr></table></figure>

<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p>
<p><u>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</u></p>
<p><u>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</u></p>
<h2 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h2><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），<u>读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</u></p>
<p>加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁</span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排它锁</span><br><span class="line">INSERT INTO student values ... # 排它锁</span><br><span class="line">DELETE FROM student WHERE ... # 排它锁</span><br><span class="line">UPDATE student SET ... # 排它锁</span><br></pre></td></tr></table></figure>





<h1 id="3-复习"><a href="#3-复习" class="headerlink" title="3 复习"></a>3 复习</h1><h2 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a>3.1 再谈隔离级别</h2><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p>
<p><img src="/2022/01/28/MySQL-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20220407211710668.png" alt="image-20220407211710668"></p>
<p>另图：</p>
<p><img src="/2022/01/28/MySQL-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20220407211810571.png" alt="image-20220407211810571"></p>
<h2 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a>3.2 隐藏字段、Undo Log版本链</h2><p>回顾一下 undo 日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p>
<ul>
<li>  <code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id 赋值给 trx_id 隐藏列。</li>
<li>  <code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p><img src="/2022/01/28/MySQL-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20220407212125650.png" alt="image-20220407212125650"></p>
<blockquote>
<p>  insert undo 只在事务回滚时起作用，当事务提交后，该类型的 undo 日志就没用了，它占用的 Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p>
</blockquote>
<p>假设之后两个事务id分别为10 、20 的事务对这条记录进行UPDATE 操作，操作流程如下：</p>
<table>
<thead>
<tr>
<th>发生时间顺序</th>
<th>事务10</th>
<th>事务20</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE student SET name=”李四” WHERE id=1;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>UPDATE student SET name=”王五” WHERE id=1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>UPDATE student SET name=”钱七” WHERE id=1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>UPDATE student SET name=”宋八” WHERE id=1;</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p>每次对记录进行改动，都会记录一条 undo 日志，每条 undo 日志也都有一个 roll_pointer 属性（INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表：</p>
<p><img src="/2022/01/28/MySQL-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20220407213039611.png" alt="image-20220407213039611"></p>
<p>对该记录每次更新后，都会将旧值放到一条 undo 日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。</p>
<p>每个版本中还包含生成该版本时对应的事务id 。</p>
<hr>
<h1 id="4-MVCC-实现原理之-ReadView"><a href="#4-MVCC-实现原理之-ReadView" class="headerlink" title="4 MVCC 实现原理之 ReadView"></a>4 MVCC 实现原理之 ReadView</h1><p>MVCC 的实现依赖于：<strong>隐藏字段、Undo Log、Read View</strong>。</p>
<h2 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h2><h2 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h2><ul>
<li>  使用 <code>READ UNCOMMITTED</code> 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</li>
<li>  使用 <code>SERIALIZABLE</code> 隔离级别的事务，InnoDB 规定使用加锁的方式来访问记录。</li>
<li>  使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到已经提交了的事务修改成功的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是 ReadView 要解决的主要问题。</li>
</ul>
<p>这个 ReadView 中主要包含 4 个比较重要的内容，分别如下：</p>
<ol start="3">
<li><p><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</p>
<blockquote>
<p>  说明：只有在对表中的记录做改动时（执行 INSERT、DELETE、UPDATE 这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务 id 值都默认为 0。</p>
</blockquote>
</li>
<li><p><code>trx_ids</code>，表示在生成 ReadView 时当前系统中活跃的读写事务的事务 id 列表。</p>
</li>
<li><p><code>up_limit_id</code>，活跃的事务中最小的事务 ID。</p>
</li>
<li><p><code>low_limit_id</code>，表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。low_limit_id 是系统最大的事务 id 值，这里要注意是系统中的事务 id，需要区别于正在活跃的事务ID。</p>
<blockquote>
<p>  注意：low_limit_id 并不是 trx_ids 中的最大值，事务 id 是递增分配的。比如，现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，trx_ids 就包括 1 和 2，up_limit_id 的值就是 1，low_limit_id 的值就是 4。</p>
</blockquote>
<h2 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a>4.3 ReadView的规则</h2><p> 有了这个 ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p>
<ul>
<li>  如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的 trx_id 属性值小于 ReadView 中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。<br>  如果被访问版本的trx_id属性值大于或等于ReadView中的low_limit_id 值，表明生成该版本的事<br>  务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。<br>  如果被访问版本的trx_id属性值在ReadView的up_limit_id 和low_limit_id 之间，那就需要判<br>  断一下trx_id属性值是不是在trx_ids 列表中。<br>  如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。<br>  如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。<br>  事务说明<br>  begin;<br>  select * from student where id &gt;2; 获取一次Read View<br>  ………<br>  select * from student where id &gt;2; 获取一次Read View<br>  commit;<br>  4.4 MVCC整体操作流程<br>  了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</li>
</ul>
</li>
<li><p>首先获取事务自己的版本号，也就是事务 ID；</p>
</li>
<li><p>获取 ReadView；</p>
</li>
<li><p>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</p>
</li>
<li><p>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</p>
</li>
<li><p>最后返回符合规则的数据。</p>
<pre><code>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次
Read View。
如表所示：
注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生
不可重复读或者幻读的情况。
当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会
获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：
</code></pre>
</li>
<li><p>举例说明<br>   5.1 READ COMMITTED隔离级别下<br>   READ COMMITTED ：每次读取数据前都生成一个ReadView。<br>   现在有两个事务id 分别为10 、20 的事务在执行：<br>   此刻，表student 中id 为1 的记录得到的版本链表如下所示：<br>   假设现在有一个使用READ COMMITTED 隔离级别的事务开始执行：<br>   之后，我们把事务id 为10 的事务提交一下：<br>   然后再到事务id 为20 的事务中更新一下表student 中id 为1 的记录：<br>   此刻，表student中id 为1 的记录的版本链就长这样：</p>
</li>
</ol>
<h1 id="Transaction-10"><a href="#Transaction-10" class="headerlink" title="Transaction 10"></a>Transaction 10</h1><p>BEGIN;<br>UPDATE student SET name=”李四” WHERE id=1;<br>UPDATE student SET name=”王五” WHERE id=1;</p>
<h1 id="Transaction-20"><a href="#Transaction-20" class="headerlink" title="Transaction 20"></a>Transaction 20</h1><p>BEGIN;</p>
<h1 id="更新了一些别的表的记录"><a href="#更新了一些别的表的记录" class="headerlink" title="更新了一些别的表的记录"></a>更新了一些别的表的记录</h1><p>…</p>
<h1 id="使用READ-COMMITTED隔离级别的事务"><a href="#使用READ-COMMITTED隔离级别的事务" class="headerlink" title="使用READ COMMITTED隔离级别的事务"></a>使用READ COMMITTED隔离级别的事务</h1><p>BEGIN;</p>
<h1 id="SELECT1：Transaction-10、20未提交"><a href="#SELECT1：Transaction-10、20未提交" class="headerlink" title="SELECT1：Transaction 10、20未提交"></a>SELECT1：Transaction 10、20未提交</h1><p>SELECT * FROM student WHERE id = 1; # 得到的列name的值为’张三’</p>
<h1 id="Transaction-10-1"><a href="#Transaction-10-1" class="headerlink" title="Transaction 10"></a>Transaction 10</h1><p>BEGIN;<br>UPDATE student SET name=”李四” WHERE id=1;<br>UPDATE student SET name=”王五” WHERE id=1;<br>COMMIT;</p>
<h1 id="Transaction-20-1"><a href="#Transaction-20-1" class="headerlink" title="Transaction 20"></a>Transaction 20</h1><p>BEGIN;</p>
<h1 id="更新了一些别的表的记录-1"><a href="#更新了一些别的表的记录-1" class="headerlink" title="更新了一些别的表的记录"></a>更新了一些别的表的记录</h1><p>…<br>UPDATE student SET name=”钱七” WHERE id=1;<br>UPDATE student SET name=”宋八” WHERE id=1;<br>然后再到刚才使用READ COMMITTED 隔离级别的事务中继续查找这个id 为1 的记录，如下：<br>5.2 REPEATABLE READ隔离级别下<br>使用REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView ，之<br>后的查询就不会重复生成了。<br>比如，系统里有两个事务id 分别为10 、20 的事务在执行：<br>此刻，表student 中id 为1 的记录得到的版本链表如下所示：<br>假设现在有一个使用REPEATABLE READ 隔离级别的事务开始执行：</p>
<h1 id="使用READ-COMMITTED隔离级别的事务-1"><a href="#使用READ-COMMITTED隔离级别的事务-1" class="headerlink" title="使用READ COMMITTED隔离级别的事务"></a>使用READ COMMITTED隔离级别的事务</h1><p>BEGIN;</p>
<h1 id="SELECT1：Transaction-10、20均未提交"><a href="#SELECT1：Transaction-10、20均未提交" class="headerlink" title="SELECT1：Transaction 10、20均未提交"></a>SELECT1：Transaction 10、20均未提交</h1><p>SELECT * FROM student WHERE id = 1; # 得到的列name的值为’张三’</p>
<h1 id="SELECT2：Transaction-10提交，Transaction-20未提交"><a href="#SELECT2：Transaction-10提交，Transaction-20未提交" class="headerlink" title="SELECT2：Transaction 10提交，Transaction 20未提交"></a>SELECT2：Transaction 10提交，Transaction 20未提交</h1><p>SELECT * FROM student WHERE id = 1; # 得到的列name的值为’王五’</p>
<h1 id="Transaction-10-2"><a href="#Transaction-10-2" class="headerlink" title="Transaction 10"></a>Transaction 10</h1><p>BEGIN;<br>UPDATE student SET name=”李四” WHERE id=1;<br>UPDATE student SET name=”王五” WHERE id=1;</p>
<h1 id="Transaction-20-2"><a href="#Transaction-20-2" class="headerlink" title="Transaction 20"></a>Transaction 20</h1><p>BEGIN;</p>
<h1 id="更新了一些别的表的记录-2"><a href="#更新了一些别的表的记录-2" class="headerlink" title="更新了一些别的表的记录"></a>更新了一些别的表的记录</h1><p>…<br>之后，我们把事务id 为10 的事务提交一下，就像这样：<br>然后再到事务id 为20 的事务中更新一下表student 中id 为1 的记录：<br>此刻，表student 中id 为1 的记录的版本链长这样：<br>然后再到刚才使用REPEATABLE READ 隔离级别的事务中继续查找这个id 为1 的记录，如下：</p>
<h1 id="使用REPEATABLE-READ隔离级别的事务"><a href="#使用REPEATABLE-READ隔离级别的事务" class="headerlink" title="使用REPEATABLE READ隔离级别的事务"></a>使用REPEATABLE READ隔离级别的事务</h1><p>BEGIN;</p>
<h1 id="SELECT1：Transaction-10、20未提交-1"><a href="#SELECT1：Transaction-10、20未提交-1" class="headerlink" title="SELECT1：Transaction 10、20未提交"></a>SELECT1：Transaction 10、20未提交</h1><p>SELECT * FROM student WHERE id = 1; # 得到的列name的值为’张三’</p>
<h1 id="Transaction-10-3"><a href="#Transaction-10-3" class="headerlink" title="Transaction 10"></a>Transaction 10</h1><p>BEGIN;<br>UPDATE student SET name=”李四” WHERE id=1;<br>UPDATE student SET name=”王五” WHERE id=1;<br>COMMIT;</p>
<h1 id="Transaction-20-3"><a href="#Transaction-20-3" class="headerlink" title="Transaction 20"></a>Transaction 20</h1><p>BEGIN;</p>
<h1 id="更新了一些别的表的记录-3"><a href="#更新了一些别的表的记录-3" class="headerlink" title="更新了一些别的表的记录"></a>更新了一些别的表的记录</h1><p>…<br>UPDATE student SET name=”钱七” WHERE id=1;<br>UPDATE student SET name=”宋八” WHERE id=1;</p>
<h1 id="使用REPEATABLE-READ隔离级别的事务-1"><a href="#使用REPEATABLE-READ隔离级别的事务-1" class="headerlink" title="使用REPEATABLE READ隔离级别的事务"></a>使用REPEATABLE READ隔离级别的事务</h1><p>BEGIN;</p>
<h1 id="SELECT1：Transaction-10、20均未提交-1"><a href="#SELECT1：Transaction-10、20均未提交-1" class="headerlink" title="SELECT1：Transaction 10、20均未提交"></a>SELECT1：Transaction 10、20均未提交</h1><p>SELECT * FROM student WHERE id = 1; # 得到的列name的值为’张三’</p>
<h1 id="SELECT2：Transaction-10提交，Transaction-20未提交-1"><a href="#SELECT2：Transaction-10提交，Transaction-20未提交-1" class="headerlink" title="SELECT2：Transaction 10提交，Transaction 20未提交"></a>SELECT2：Transaction 10提交，Transaction 20未提交</h1><p>SELECT * FROM student WHERE id = 1; # 得到的列name的值仍为’张三’<br>5.3 如何解决幻读<br>接下来说明InnoDB 是如何解决幻读的。<br>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图<br>所示。<br>假设现在有事务 A 和事务 B 并发执行， 事务 A 的事务 id 为 20 ， 事务 B 的事务 id 为 30 。<br>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。<br>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： trx_ids=<br>[20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20 。<br>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView<br>机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开<br>启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。<br>结论：事务 A 的第一次查询，能读取到一条数据，id=1。<br>步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。<br>此时表student 中就有三条数据了，对应的 undo 如下图所示：<br>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成<br>ReadView。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据<br>ReadView 机制，判断每条数据是不是都可以被事务 A 看到。<br>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。<br>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之<br>间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表<br>示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。<br>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。<br>select * from student where id &gt;= 1;<br>insert into student(id,name) values(2,’李四’);<br>insert into student(id,name) values(3,’王五’);<br>结论：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样<br>的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。<br>6. 总结<br>这里介绍了MVCC 在READ COMMITTD 、REPEATABLE READ 这两种隔离级别的事务在执行快照读操作时<br>访问记录的版本链的过程。这样使不同事务的读-写、写-读操作并发执行，从而提升系统性能。<br>核心点在于 ReadView 的原理， READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同<br>就是生成ReadView的时机不同：<br>READ COMMITTD 在每一次进行普通SELECT操作前都会生成一个ReadView<br>REPEATABLE READ 只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复<br>使用这个ReadView就好了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/27/Spring-Boot-Starter%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/27/Spring-Boot-Starter%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Spring-Boot-Starter详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-27 22:51:06 / Modified: 22:57:07" itemprop="dateCreated datePublished" datetime="2022-01-27T22:51:06+08:00">2022-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
