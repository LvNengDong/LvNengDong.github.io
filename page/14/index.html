<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/14/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/14/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/14/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Java中print、println、printf的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-27 14:25:02" itemprop="dateCreated datePublished" datetime="2021-06-27T14:25:02+08:00">2021-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-02 20:51:50" itemprop="dateModified" datetime="2021-08-02T20:51:50+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaExt/" itemprop="url" rel="index"><span itemprop="name">JavaExt</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1    前置知识"></a>1    前置知识</h2><h3 id="1-1-常见的转义字符"><a href="#1-1-常见的转义字符" class="headerlink" title="1.1    常见的转义字符"></a>1.1    常见的转义字符</h3><ul>
<li><p><code>\t</code>，<code>\r </code>，<code>\n</code> 都是转义字符。空格就是单纯的空格，输入时可以输入空格</p>
</li>
<li><p><code>\t</code> 的意思是 <strong>横向跳到下一制表符位置（一个制表符就是一个 Tab）</strong></p>
</li>
<li><p><code>\r</code> 的意思是 <strong>回车</strong></p>
</li>
<li><p><code>\n</code> 的意思是 <strong>回车换行</strong></p>
</li>
</ul>
<blockquote>
<p>  所有的转义字符和所对应的意义：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td align="center">\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td align="center"><strong>\n</strong></td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td align="center"><strong>\r</strong></td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td align="center"><strong>\t</strong></td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td align="center">\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td align="center">\</td>
<td>代表一个反斜线字符’’&#39;</td>
<td>092</td>
</tr>
<tr>
<td align="center">&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td align="center">&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td align="center">?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td align="center">\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td align="center">\ooo</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td align="center">\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td>二位十六进制</td>
</tr>
</tbody></table>
<ul>
<li>  Tip：转义符使用的是反斜杠 <code>\</code> 而不是斜杠 <code>/</code> 。</li>
</ul>
<hr>
<h3 id="1-2-System-out-println-与-PrintStream-的关系"><a href="#1-2-System-out-println-与-PrintStream-的关系" class="headerlink" title="1.2    System.out.println() 与 PrintStream 的关系"></a>1.2    System.out.println() 与 PrintStream 的关系</h3><blockquote>
<p>  <strong>提出问题：</strong></p>
</blockquote>
<p>​        在 Java 程序中，我们总是使用 <code>System.out.println();</code> 用于展示输出结果，但是追踪源码我们会发现 <code>print()</code> 方法位于 <strong>PrintStream</strong> 类中，而我们却总是使用 System 中的 out 属性（即 <code>System.out</code> ）来调用 <code>print()</code> 方法，这就说明 <code>System.out</code> 其实指向了一个 PrintStream 类对应的实例对象。查看 <strong>System</strong> 类的源码可以看到：<strong>out</strong> 是一个 PrintStream 类型的实例对象，并且在 System 类中提供了 set 方法用于创建该对象。</p>
<p><img src="/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/image-20210627151759843.png" alt="image-20210627151759843"></p>
<p>​        所以可以得出一个结论：<code>System.out</code> 就等价于一个 PrintStream 类的实例对象。</p>
<hr>
<h2 id="2-print、println、printf-的区别"><a href="#2-print、println、printf-的区别" class="headerlink" title="2    print、println、printf 的区别"></a>2    print、println、printf 的区别</h2><ul>
<li><code>print</code> 是一般的标准输出，不会自动换行。</li>
<li><code>println</code> 和 <code>print</code> 基本没什么差别，但是会<strong>自动换行</strong>。</li>
<li><code>printf</code> 继承了C语言的 <code>printf</code> 的一些特性，可以进行<strong>格式化输出</strong>，与 C 语言用法相同。可以同时输出多个值，由 <code>%</code> 控制格式。</li>
<li>以上3个方法都可以添加转义字符。</li>
</ul>
<h3 id="2-1-print、println、printf-源码分析"><a href="#2-1-print、println、printf-源码分析" class="headerlink" title="2.1    print、println、printf 源码分析"></a>2.1    print、println、printf 源码分析</h3><blockquote>
<p>  <strong>PrintStream#print()</strong></p>
<p>  <strong>PrintStream#println()</strong></p>
<p>  <strong>PrintStream#printf()</strong></p>
</blockquote>
<p><code>print()</code> 、<code>println()</code> 和 <code>printf()</code> 方法都是 PrintStream 类中的普通方法，如图所示我们可以看到，</p>
<ul>
<li>  <code>print()</code> 和 <code>println()</code> 方法最多只有一个参数，也就是说这两个方法会把方法参数按照指定的格式直接输出。</li>
<li>  对于 <code>println()</code> 这个空参的方法，输出结果仅仅起到一个换行的作用。</li>
<li>  而对于 <code>printf()</code> 方法，最少都有两个参数，一个参数用于接收含有占位符的字符串，而另一个参数则主要用于给占位符赋值等操作。</li>
</ul>
<p><img src="/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/image-20210627145315659.png" alt="image-20210627145315659"></p>
<blockquote>
<p>  <strong>部分源码（JDK8）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">        write(b ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        write(String.valueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        write(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">        write(String.valueOf(l));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> f)</span> &#123;</span><br><span class="line">        write(String.valueOf(f));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">        write(String.valueOf(d));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">        write(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        write(String.valueOf(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// println() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">()</span> &#123;</span><br><span class="line">        newLine();	<span class="comment">// newLine() 是一个换行的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">boolean</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">float</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> x[])</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(s);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf() 方法</span></span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String format, Object ... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(format, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(Locale l, String format, Object ... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(l, format, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-printf-格式化输出"><a href="#2-2-printf-格式化输出" class="headerlink" title="2.2    printf  格式化输出"></a>2.2    printf  格式化输出</h3><blockquote>
<p>  十六进制，hexadecimal</p>
<p>  十进制，decimalism</p>
<p>  八进制，octal</p>
<p>  二进制，binary</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;d&#x27; 将整数结果格式化为十进制整数</span><br><span class="line">&#x27;o&#x27; 将整数结果格式化为八进制整数</span><br><span class="line">&#x27;x&#x27;, &#x27;X&#x27; 将整数结果格式化为十六进制整数</span><br><span class="line">&#x27;e&#x27;, &#x27;E&#x27; 将浮点结果格式化为用计算机科学记数法表示的十进制数</span><br><span class="line">&#x27;f&#x27; 将浮点结果格式化为十进制数</span><br><span class="line">&#x27;g&#x27;, &#x27;G&#x27; 将浮点根据精度和舍入运算后的值，使用计算机科学记数形式或十进制格式对结果进行格式化。</span><br><span class="line">&#x27;a&#x27;, &#x27;A&#x27; 将浮点结果格式化为带有效位数和指数的十六进制浮点数</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>%d</code> 是一个 int 类型数据的占位符，这个占位符的值在 <code>printf()</code> 方法的第二个参数中提供。</p>
</li>
<li><p><code>%f</code> 是一个 double 或 float 类型数据的占位符，这个占位符的值在 <code>printf()</code> 方法的第二个参数中提供。</p>
</li>
<li><p>举例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果想要只输出两位小数？</span><br><span class="line">	System.out.printf(<span class="string">&quot;输出一个两位小数 %.2f&quot;</span>, num);</span><br><span class="line">这里的<span class="string">&quot;%.2f&quot;</span>的意思是输出两位小数点。如果想输出三位那就<span class="string">&quot;%.3f&quot;</span>。</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3    总结"></a>2.3    总结</h3><ul>
<li><code>print()</code> 方法会将方法中的参数打印输出在控制台上，并将输出光标定位在所显示的最后一个字符之后。</li>
<li><code>println()</code> 方法将它的参数打印显示在命令窗口，并在结尾加上换行符，将输出光标定位在下一行的开始。(自动换行)</li>
<li><code>print()</code> 方法接收 2 个参数，一个参数用于指定输出格式并保留插值表达式，另一个参数用于将插值表达式的值按顺序插入到插值表达式的留空中。</li>
</ul>
<hr>
<h2 id="3-测试用例"><a href="#3-测试用例" class="headerlink" title="3    测试用例"></a>3    测试用例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">7.36</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  println() 方法：标准输出 + 自动换行  */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;CCC\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  print() 方法：标准输出（不自动换行）    */</span></span><br><span class="line">        System.out.print(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;ccc\n&quot;</span>);	<span class="comment">// 可以加转义字符进行手动换行</span></span><br><span class="line"></span><br><span class="line">        System.out.println();   <span class="comment">// 直接输出空的 println() 方法就相当于自动换行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  printf() 方法：格式化输出  */</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;树上吊着%d只大马猴\n&quot;</span>, num1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/image-20210510105800973.png" alt="image-20210510105800973"></p>
<h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4    构造方法"></a>4    构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * print() 方法：  直接在控制台上打印参数中的字符串，不换行</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * println() 方法：  在控制台上打印参数中的字符串，并且在打印完成后末尾加上换行</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * printf() 方法：  在控制台上打印格式化输出后的字符串。</span></span><br><span class="line"><span class="comment">         *      可以接收两个参数：</span></span><br><span class="line"><span class="comment">         *          String format   要打印在控制台上的内容，参数部分用指定的格式保留（类似于插值表达式）</span></span><br><span class="line"><span class="comment">         *          Object args    将真正的参数 args 按顺序插入到 format 中保留的位置中</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> format</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String format, Object ... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(format, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">JVM——垃圾收集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-23 09:47:57" itemprop="dateCreated datePublished" datetime="2021-06-23T09:47:57+08:00">2021-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-11 18:58:49" itemprop="dateModified" datetime="2021-10-11T18:58:49+08:00">2021-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><blockquote>
<p>  <strong>垃圾收集；垃圾回收；Garbage Collection；GC</strong></p>
</blockquote>
<p>​        垃圾收集并非 Java 语言的伴生产物，垃圾收集的历史远比 Java 久远。早在 1960 年，第一门开始使用<strong>动态内存分配</strong>和<strong>垃圾收集技术</strong>的 Lisp 语言就诞生了。</p>
<ul>
<li>  <strong>内存动态分配</strong>是相对于 C/C++ 等需要开发人员手动分配内存的语言来讲的，JVM 内存动态分配的特性大大减轻了开发人员在内存分配方面的工作量。</li>
<li>  <strong>垃圾收集技术</strong>在不同的语言中均有不同的实现，在 Java 语言中的实现是由 JVM 进行的垃圾自动收集。</li>
</ul>
<p>垃圾收集机制是 Java 的招牌能力，因为其特有的内存动态分配和垃圾自动收集机制，让开发人员可以不必过于关注内存分配和垃圾回收的相关问题，将更多的精力投入到业务开发中，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战。</p>
<h2 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1  什么是垃圾"></a>1  什么是垃圾</h2><blockquote>
<p>  <strong>什么是垃圾（Garbage）？</strong></p>
</blockquote>
<ul>
<li>  垃圾指<strong>在应用程序中没有任何指针指向的对象</strong>，这些对象就是需要被回收的垃圾。</li>
</ul>
<p>如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占用的内存空间就会一直保留直到应用程序结束，被保留的空间无法被其它对象使用，就会增加内存溢出的概率。</p>
<h2 id="2-为什么需要-GC"><a href="#2-为什么需要-GC" class="headerlink" title="2  为什么需要 GC"></a>2  为什么需要 GC</h2><p>GC = 内存清理+内存整理</p>
<ul>
<li><p>  对于一个应用程序来说，如果不进行垃圾回收，内存迟早都会被消耗完，因为程序只会不断的分配内存空间而不进行回收。</p>
</li>
<li><p>  除了释放不再被使用的对象，垃圾回收也会清除内存中的记录碎片。碎片整理将所占用的堆内存移动到堆的一端，以便 JVM 将整理出的内存分配给新的对象。</p>
</li>
<li><p>  随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序的正常进行。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p>
</li>
</ul>
<h2 id="3-早期的垃圾回收（C-C-垃圾回收）"><a href="#3-早期的垃圾回收（C-C-垃圾回收）" class="headerlink" title="3  早期的垃圾回收（C/C++垃圾回收）"></a>3  早期的垃圾回收（C/C++垃圾回收）</h2><blockquote>
<p>  <strong>Before</strong></p>
</blockquote>
<p>​        在早期的 C/C++ 时代，垃圾回收基本上是手工进行的。开发人员可以使用 <code>new</code> 关键字申请内存空间，在使用完毕之后使用 <code>delete</code> 关键字进行内存的释放。这种方式的优点是可以<strong>灵活</strong>的控制内存申请、释放的时间，但是频繁地申请和释放内存会给开发人员带来额外内存管理的负担。如果某块内存空间由于开发人员疏忽而忘记被回收，那么就会产生内存泄露，这块内存空间中的垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象消耗的内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p>
<p>​        <em>[垃圾对象消耗的内存为什么可能会持续上升？某块内存空间由于开发人员疏忽而忘记回收，如果该块内存中保存的是一个单例对象，并且该对象关联的其它对象也都是单例对象，那么在程序运行中对象消耗的内存会一直保持不变。但是如果该块内存中保存的是一个非单例对象（或者该块内存中存储的是一个单例对象，但该单例对象引用了其它非单例对象），那么在程序运行的过程中，每访问一次该块内存中保存的对象，都会有新的对象被创建，并且被该块内存中一个长期存在的对象引用，不能被销毁，所以随着系统运行时间的增长，垃圾对象占用的内存就可能会持续上升，直至出现内存溢出]</em></p>
<blockquote>
<p>  <strong>After</strong></p>
</blockquote>
<p>​        有了垃圾回收机制后，开发人员只需要关注内存的申请，在对象使用完毕之后由垃圾回收器自动进行内存的释放。目前，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，这也是未来发展的趋势。可以说，这种自动化的内存分配和垃圾回收的方式已经成为现代开发语言必备的标准。</p>
<hr>
<h2 id="4-JVM-垃圾收集机制"><a href="#4-JVM-垃圾收集机制" class="headerlink" title="4  JVM 垃圾收集机制"></a>4  JVM 垃圾收集机制</h2><p>自动内存管理机制：无需开发人员手动参与内存的<strong>分配</strong>与<strong>回收</strong>。</p>
<ul>
<li>  可以降低内存泄漏和内存溢出的风险。</li>
<li>  将开发人员从复杂的内存管理中释放出来，可以更将更多的精力专注于业务开发。</li>
</ul>
<hr>
<h2 id="5-应该关心哪些区域的回收？"><a href="#5-应该关心哪些区域的回收？" class="headerlink" title="5    应该关心哪些区域的回收？"></a>5    应该关心哪些区域的回收？</h2><blockquote>
<p>  <strong>1、堆区    2、方法区</strong></p>
</blockquote>
<p>首先，线程的伴生区域（程序计数器、虚拟机栈、本地方法栈）无需考虑垃圾回收。</p>
<ul>
<li>  Java 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭。栈中的栈帧随着随着方法的进入和退出同步执行出栈和入栈操作。每一个栈帧中分配多少内存是在类结构确定下来时就已知的（即前端编译期就可知了）。因此这几个区域的内存分配都具有确定性；当方法结束或者线程结束时，内存也就跟着回收了。所以这几个区域无需过多考虑内存回收问题。 </li>
</ul>
<p>而 Java 堆和方法区这两个区域存在很大的不确定性，只有程序在运行期间，我们才知道程序究竟会创建哪些对象，创建多少个对象。这部分的内存分配和回收是动态的。垃圾收集器关注的也正是这部分内存该如何管理。</p>
<p>只有堆区和方法区才存在 GC。其中， <strong>Java 堆是垃圾回收器的工作重点。</strong> </p>
<blockquote>
<p>  <strong>垃圾分代收集</strong></p>
</blockquote>
<p>垃圾收集器可以只对年轻代收集，也可以只对老年代收集，甚至是在 整个堆+方法区 范围内收集。从次数上讲：</p>
<ul>
<li>  频繁收集 Young 区</li>
<li>  较少收集 Old 区</li>
<li>  基本不动 Perm 区（或 MetaSpace）</li>
</ul>
<p><strong>《JVM虚拟机规范》并没有强制规定方法区一定要进行 GC。只是 HotSpot 在方法区实现了 GC。</strong></p>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">内存区域 / 行为</th>
<th align="center">OOM</th>
<th align="center">GC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆（Heap）</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">方法区（MetaSpace）</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">程序计数器（PC Register）</td>
<td align="center">✖</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center">虚拟机栈（Java Virtual Machine Stack）</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center">本地方法栈（Native Method Stack）</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6    总结"></a>6    总结</h2><blockquote>
<p>  <strong>垃圾收集需要完成哪些事情（垃圾回收经典三问）？</strong></p>
</blockquote>
<ol>
<li>哪些内存需要回收？<ul>
<li>  标记阶段</li>
</ul>
</li>
<li> 什么时候回收？</li>
<li>如何回收？<ul>
<li>  清除阶段 + 整理阶段</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>现如今，内存动态分配和内存回收技术已经非常成熟，作为开发人员为什么还要去了解垃圾收集和内存分配？</strong></p>
</blockquote>
<p>​    对于Java 开发人员而言，自动内存管理就像是一个“黑盒”，如果过度依赖于“自动”，就会 <strong>弱化 Java 开发人员面对内存溢出或内存泄漏时定位、解决问题的能力。</strong> 因此，了解 JVM 的自动内存分配和内存回收原理尤为重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇到 OOM 异常时，快速的根据错误异常日志定位问题和解决问题。</p>
<ol>
<li> 当应用程序出现内存泄漏，内存溢出等问题时，需要开发人员去定位、解决这些问题；</li>
<li> 当垃圾收集成为系统达到更高并发量的瓶颈时，需要开发人员通过优化 GC 来让系统的性能更上一层楼；</li>
<li> 而这些操作的前提是必须了解内存分配和内存回收的底层实现原理。</li>
</ol>
<hr>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><blockquote>
<ol>
<li>标记阶段<ul>
<li>  引用计数算法</li>
<li>  可达性分析算法（HotSpot 使用）</li>
<li>  对象的复活机制</li>
</ul>
</li>
<li>清除阶段<ul>
<li>  标记-清除算法</li>
<li>  复制算法</li>
<li>  标记-压缩算法</li>
</ul>
</li>
<li> 小结</li>
<li> 分代收集算法</li>
<li> 增量收集算法</li>
<li> 分区算法</li>
</ol>
</blockquote>
<h2 id="1-标记阶段"><a href="#1-标记阶段" class="headerlink" title="1    标记阶段"></a>1    标记阶段</h2><blockquote>
<p>  <strong>垃圾标记阶段：判断对象是否存活</strong></p>
</blockquote>
<p>​    Java 堆中存放着几乎所有的 Java 对象实例，垃圾收集器在进行内存回收之前，第一件事就是要<strong>确定待回收内存空间中的对象哪些是“存活”的，哪些是“死亡”的</strong>，垃圾收集时只会释放已死亡对象占用的内存空间。我们把确定对象存活状态的阶段称为 <strong>垃圾标记阶段。</strong> </p>
<blockquote>
<p>  <strong>那么在 JVM 中如何标记一个死亡对象呢？</strong></p>
</blockquote>
<ul>
<li>  简单来说，当一个对象已经不再被任何存活的对象继续引用时，就可以认为已经死亡。 </li>
<li>  判断对象存活常用的两种方式： <strong>引用计数算法</strong> 和 <strong>可达性分析算法</strong> 。</li>
</ul>
<h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1    引用计数算法"></a>1.1    引用计数算法</h3><blockquote>
<p>  <strong>引用计数算法；Reference_Counting</strong></p>
</blockquote>
<p>​    Reference_Counting 算法比较简单，就是<strong>在对象中添加一个引用计数器，用于记录对象被引用的情况。每当有一个地方引用该对象的时候，计数器值就 +1；当引用失效时，计数器值就 -1。任何时候计数器为零时就说明该对象已死亡，</strong>可被回收。</p>
<p><strong>优点：</strong></p>
<ul>
<li>  实现简单，垃圾对象便于辨识；</li>
<li>  标记效率高，标记延迟性低。（相对于可达性分析算法而言）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  需要单独的字段存储计数器的值，增加了对象<strong>存储空间的开销</strong>。</li>
<li>  每次 被引用/引用失效 时都需要更新计数器，伴随着加法和减法操作，增加了<strong>时间开销</strong> 。</li>
<li>  引用计数器有一个严重的问题，即 <strong>无法处理循环引用</strong> 的情况。这是一条致命的缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li>
</ul>
<h4 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h4><p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623661340601-63c12150-dfe7-454a-8044-9ba4dbea6d55.png" alt="循环引用.png"></p>
<blockquote>
<p>  <strong>什么是循环引用？</strong></p>
</blockquote>
<p>就是多个对象之间的依赖关系形成了一个环，就会导致每个对象的引用计数器的值始终不会减少到0，也就不会被回收。会造成内存泄露。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = Object A;</span><br><span class="line"></span><br><span class="line">a.field = Object B;</span><br><span class="line">b.field = Object C;</span><br><span class="line">c.field = Object A;</span><br></pre></td></tr></table></figure>

<ul>
<li>  如上图，现有某一外部对象通过指针 p 引用了对象A，对象A引用了对象B，对象B引用了对象C，对象C又引用了对象A。所以对象A、B、C 各自维护的引用计数器的值分别为 2，1，1 。 </li>
<li>  当外部对象不再需要使用对象A时，会设置为 <code>p=null</code>，A对象不再被使用，此时按理来说，对象A失效后，其内部变量指向的 B、C 都应该被回收，但是由于这三个对象之间形成了一个闭环引用，所以这三个对象的引用计数器的值最小始终为1，不会减小到0，也就是说，在引用计数算法的标准下，这三个对象始终不会死亡，这就会造成内存的泄漏。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>  JVM 并没有选择引用计数算法作为垃圾标记阶段的算法，是因为引用计数算法很难处理循环引用的问题。</li>
<li>引用计数算法被很多语言作为垃圾回收算法使用，例如 Python ，它支持引用计数算法的垃圾回收机制。<ul>
<li>Python 如何解决循环引用？<ul>
<li>  手动解除。在合适的实际，手动解除引用关系、</li>
<li>  使用弱引用 weakref ，weakref 是 Python 提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ul>
</li>
<li>  具体哪种标记算法最优是要看场景的，业界有大规模实践中仅保留引用计数算法，以提高吞吐量的尝试。</li>
</ul>
<hr>
<h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2    可达性分析算法"></a>1.2    可达性分析算法</h3><blockquote>
<p>  <strong>可达性分析算法；根搜索算法；追踪性垃圾收集；Tracing_Garbage_Collection</strong></p>
<p>  <strong>引用链；Reference_Chain</strong></p>
</blockquote>
<p>相较于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决循环引用问题</strong>，避免内存泄漏的发生。  当前主流的 JVM 虚拟机采用的垃圾标记算法就是可达性分析算法。</p>
<h4 id="可达性分析算法原理"><a href="#可达性分析算法原理" class="headerlink" title="可达性分析算法原理"></a>可达性分析算法原理</h4><p>可达性分析算法的基本原理就是通过一系列称为“<strong>GC_Roots</strong>”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索所走过的路径称为 <strong>Reference_Chain</strong>，如果某个对象到 GC_Roots 之间没有任何 Reference_Chain 相连，则证明此对象可被回收。</p>
<ul>
<li>  可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上到下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</li>
<li>  使用可达性分析算法后，内存中存活的对象都会被根对象集合直接或间接的引用到，搜索所走过的路径称为 Reference_Chain。</li>
<li>  如果 GC_Roots 到某个对象之间没有任何引用链相连，则称该对象是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。</li>
<li>  在可达性分析算法中，只有能够被根对象集合直接或间接引用的对象才是存活对象。</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623664602146-14c005db-f325-47f4-abef-9342102adccc.png" alt="可达性分析算法.png"></p>
<p>可达性分析算法可以有效解决循环依赖问题，即使存在多个对象之间形成“引用闭环”，但只要它到 GC_Roots 之间没有引用链相连，就可以判断这些对象是不可达对象。</p>
<h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>所谓 “GC_Roots” 集合就是<strong>一组活跃的对象的集合</strong>。固定可作为 GC_Roots 的对象包括以下几种：</p>
<ul>
<li>  虚拟机栈（栈帧中的本地变量表）中引用的对象。比如，各个线程被调用的方法中使用到的参数、局部变量、临时变量等。</li>
<li>  本地方法栈内 JNI（通常说的 Native 方法）引用的对象。</li>
<li>  方法区中类静态属性引用的对象。比如，Java类的引用类型静态变量。</li>
<li>  方法区中常量引用的对象。比如，字符串常量池（String_Pool）里的引用。</li>
<li>  所有被同步锁（synchronized 关键字）持有的对象。【就是锁对象】</li>
<li>  Java 虚拟机内部的引用。如基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError）等，还有系统类加载器。</li>
<li>  反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li>
</ul>
<p>除了这些固定的 GC Roots 集合以外，根据回收的内存区域的不同，还<strong>可以有其它对象“临时性”地加入，共同构成完整的 GC Roots 集合</strong>。比如在分代收集和局部回收（Partial GC）中，如果只是只针对堆中的某一块区域进行垃圾回收（如最典型的只针对新生代的垃圾收集），必须考虑到内存区域不是孤立封闭的，所以某个区域里的对象完全有可能被堆中其它区域的对象所引用，这时就需要将这些关联区域的对象也一并加入到 GC Roots 集合中去，才能保证可达性分析的准确性。</p>
<blockquote>
<p>  <strong>小结</strong></p>
</blockquote>
<p><strong>GC_Roots = 固定可作为 GC_Roots 的对象 + 临时性对象</strong></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>  如果要使用可达性分析算法来标记对象是否存活，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性也就无法保证了。【可达性分析的缺点】</li>
<li>  这也是进行 GC 时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要 STW 的。</li>
</ul>
<hr>
<h3 id="1-3-对象的复活机制（对象的-finalization-机制）"><a href="#1-3-对象的复活机制（对象的-finalization-机制）" class="headerlink" title="1.3    对象的复活机制（对象的 finalization 机制）"></a>1.3    对象的复活机制（对象的 finalization 机制）</h3><h4 id="finalize-方法源码分析"><a href="#finalize-方法源码分析" class="headerlink" title="finalize() 方法源码分析"></a>finalize() 方法源码分析</h4><ul>
<li>  <code>finalize()</code> 方法是 <code>Object</code> 类中的方法，也就是说任何对象都可以调用该方法。</li>
<li>  <code>finalize()</code> 方法没有被 <strong>final</strong> 修饰，也就说可以在其子类（也就是任何类）中重写该方法。</li>
<li>  <code>finalize()</code> 方法虽然不是一个抽象方法，但在 <code>Object</code> 类中并没有对该方法做任何逻辑处理，也就是说该方法默认是一个空的方法。</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623686120808-d854840d-99c8-4d74-ba32-8cabed87d347.png" alt="image.png"></p>
<hr>
<h4 id="虚拟机中对象的三种状态"><a href="#虚拟机中对象的三种状态" class="headerlink" title="虚拟机中对象的三种状态"></a>虚拟机中对象的三种状态</h4><p>由于 <code>finalize()</code> 方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong>。 如果从所有的根节点都无法访问到这个对象，说明该对象已经死亡了，需要在下一 次 GC 时被回收。但事实上，也不一定“非死不可”，这时它暂时处于一个“缓刑”阶段。 <strong>一个可复活的对象有可能在某一条件下“复活”自己</strong> ，如果触发了“复活”机制，那么对它进行回收就是不合理的，为此，虚拟机中定义了对象的三种状态：</p>
<ul>
<li>  <strong>可触及的</strong>：存在根节点可以到达这个对象。</li>
<li>  <strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在 <code>finalize()</code> 方法中复活。</li>
<li>  <strong>不可触及的</strong>：对象的 <code>finalize()</code> 方法已被调用过一次（即已复活过一次），并且对象的引用又一次被全部释放，那么就会进入不可触及状态。<strong>不可触及状态的对象不可能被复活，因为 <code>finalize()</code> 方法只会被调用一次。</strong>（假设某个对象是通过 <code>finalize()</code> 方法复活的，那么该对象就失去了再次复活的机会，因为<code>finalize()</code> 方法只能被调用一次）</li>
</ul>
<p>以上3种状态，是根据 <code>finalize()</code> 方法进行的划分。<strong>只有对象处于不可触及状态时才会被真正地回收</strong>。</p>
<ul>
<li>  Java 语言提供了对象终止机制（finalization）来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。  </li>
<li>  当垃圾回收器发现没有任何引用指向某个对象时（即回收器回收此对象之前），总会先调用这个对象的 <code>finalize()</code> 方法。</li>
<li>  <code>finalize()</code> 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li>
</ul>
<hr>
<h4 id="二次标记过程"><a href="#二次标记过程" class="headerlink" title="二次标记过程"></a>二次标记过程</h4><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时它们暂时处于一个“缓刑”阶段。要真正宣告一个对象死亡，至少要经过两次标记过程。</p>
<ol>
<li> 如果对象 obj 在进行可达性分析后发现没有与 GC_Roots 相连的引用链，那它将会被第一次标记。</li>
<li>随后对被标记的对象再进行一次筛选，判断该对象是否有必要执行 <code>finalize()</code> 方法：<ul>
<li>  如果对象 obj 没有重写 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已经被虚拟机调用过一次，则虚拟机视为“没有必要执行”，obj 被判定为不可触及状态。</li>
<li>如果对象 obj 被判定为有必要执行 <code>finalize()</code> 方法，那么 obj 会被插入到一个名为 <strong>F-Queue</strong> 的队列中，并在稍后由 <strong>Finalizer 线程</strong>去执行队列中所有对象的 <code>finalize()</code> 方法。（JVM 进程在运行时会创建多个线程，finalizer 线程就是一个虚拟机自动创建的、优先级较低的线程）<ul>
<li>  这里说的“执行”是指虚拟机会触发 <code>finalize()</code> 方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的 <code>finalize()</code> 方法执行缓慢，甚至更极端地发生了死循环，将很可能导致 F-Queue 队列中的其它对象永久处于等待状态，甚至导致整个内存回收子系统的崩溃。</li>
</ul>
</li>
</ul>
</li>
<li> <code>finalize()</code> 方法是对象复活的最后机会，稍后垃圾回收器会对 F-Queue 中的对象进行二次标记。如果 obj 在 <code>finalize()</code> 方法中复活成功——即与引用链上的任何一个对象建立了联系（譬如把自己（this 关键字）赋值给某个类变量或者存活对象的成员变量），那么在第二次标记时，obj 会被移出 “即将回收”的集合。如果 obj 没有复活成功，这时候就真的要被回收了。</li>
<li> 之后，如果 obj 对象再次出现成为不可达对象的情况，<code>finalize()</code> 方法不会再次被调用，该对象会直接变成不可触及的状态。也就是说，一个对象的 <code>finalize()</code> 方法只会被调用一次。</li>
</ol>
<h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h4><p>建议开发人员不要主动调用某个对象的 <code>finalize()</code> 方法，应该交给垃圾回收机制调用。理由如下：</p>
<ul>
<li>  在执行 <code>finalize()</code> 方法时可能会导致对象复活，这在某些场景下并不是好事。（<code>finalize()</code> 方法的实现细节都是由开发人员后定义的，如果操作不当就有可能导致对象复活）。</li>
<li>  <code>finalize()</code> 方法是否能得到执行是没有保障的。<code>finalize()</code> 方法是由 finalizer 线程执行的，而 finalizer 线程是一个低优先级线程，并不能保证能马上得到执行的机会，并且 finalizer 线程执行时会依次执行 F-Queue 队列中所有对象的 <code>finalize()</code> 方法，如果在执行某个对象的 <code>finalize()</code> 方法时陷入长时间等待，那么在其之后所有对象的 <code>finalize()</code> 方法都有可能无法被执行。</li>
<li>  一个糟糕的 <code>finalize()</code> 方法会严重影响 GC 的性能。（<code>finalize()</code> 方法的实现细节都是由开发人员后定义的，如果定义的细节不合适就有可能影响 GC 性能，比如在 <code>finalize()</code> 方法中写死循环）</li>
</ul>
<hr>
<h2 id="2-清除阶段"><a href="#2-清除阶段" class="headerlink" title="2  清除阶段"></a>2  清除阶段</h2><p>当成功划分出待回收内存中的存活对象和死亡对象后，接下来的任务就是回收这些已死亡的对象，释放已死亡对象占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在 JVM 中比较常见的三种垃圾清除算法是：</p>
<blockquote>
<ol>
<li> <strong>标记-清除算法（Mark_Sweep）</strong>  </li>
<li> <strong>复制算法（Copying）</strong>  </li>
<li> <strong>标记-压缩算法（Mark_Sweep_Compact）</strong></li>
</ol>
</blockquote>
<h3 id="2-1-标记-清除算法-（Mark-Sweep）"><a href="#2-1-标记-清除算法-（Mark-Sweep）" class="headerlink" title="2.1    标记-清除算法 （Mark-Sweep）"></a>2.1    标记-清除算法 （Mark-Sweep）</h3><p><strong>Mark-Sweep</strong> 是最早出现也是最基础的垃圾回收算法，该算法被 J.McCarthy 等人在 1960 年提出并应用于 Lisp 语言。正如其名字一样，Mark-Sweep 算法分为“标记”和“清除”两个阶段。</p>
<h4 id="Mark-Sweep-执行过程"><a href="#Mark-Sweep-执行过程" class="headerlink" title="Mark-Sweep 执行过程"></a>Mark-Sweep 执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（Stop The World），然后进行两项工作：①标记    ②清除。</p>
<ul>
<li><p><strong>标记</strong>：垃圾收集器从 GC_ROOTS 开始遍历，标记所有需要被回收的对象（不可触及对象）。</p>
<blockquote>
<p>  一般是在对象的对象头（Header）中标记当前对象是否可达。</p>
</blockquote>
</li>
<li><p>  <strong>清除</strong>：在标记完成后，统一回收掉所有被标记的对象。</p>
</li>
</ul>
<p>也可以反过来，标记所有存活的对象，统一回收所有未被标记的对象（如无特殊说明，本文中所有的 Mark-Sweep 算法默认都是标记垃圾对象）。标记过程其实就是对象是否属于垃圾的判定过程。之所以说它是最基础的算法，是因为后续的垃圾收集算法大多都是以 Mark-Sweep 为基础改进而来的。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>  <strong>优点：</strong></p>
</blockquote>
<ul>
<li>  原理简单，实现方便</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong></p>
</blockquote>
<ul>
<li>  <strong>执行效率不稳定</strong>。如果 Java 堆中包含大量对象，且其中大部分对象是需要被回收的，这时候就必须进行大量标记和清除的动作。也就是说，标记和清除两个过程的执行效率都会随着对象数量的增长而降低。</li>
<li>  <strong>存在内存碎片化问题</strong>。使用 Mark-Sweep 算法进行垃圾收回收时会产生大量不连续的内存碎片，会导致接下来程序运行过程中需要分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。而每次进行 GC 的时候，在标记阶段需要停止整个应用程序（STW），频繁地触发 GC 会导致用户体验差。</li>
<li>  并且对于产生的内存碎片，需要额外维护一个空闲列表。</li>
</ul>
<hr>
<h4 id="“垃圾清除”-的本质"><a href="#“垃圾清除”-的本质" class="headerlink" title="“垃圾清除” 的本质"></a>“垃圾清除” 的本质</h4><p>JVM 中的垃圾回收的本质并不是真正意义上的“擦除”。</p>
<p>垃圾对象被回收后，实际上并没有擦除垃圾对象在内存中留下的痕迹，只是不再有指针指向垃圾对象对应的内存空间，并且记载这块内存可用，下次有新对象需要分配内存时，就可以直接让新对象的数据直接覆盖这块内存空间。</p>
<ul>
<li>  如果垃圾清除算法含有内存整理，则会记载一个可用内存地址的<strong>起始地址</strong>，该地址之后的内存均为可用内存。</li>
<li>  如果垃圾清除算法不包含内存整理，则会维护一个<strong>空闲列表</strong>，把所有被清除对象的内存起始地址及所占内存大小保存在这个列表中，下次创建新对象时，先根据空闲列表判断表中是否有足够的空闲内存用于容纳新对象。如果有，就可以直接让新对象的数据直接覆盖这块内存空间。</li>
</ul>
<hr>
<h3 id="2-2-标记-复制算法"><a href="#2-2-标记-复制算法" class="headerlink" title="2.2    标记-复制算法"></a>2.2    标记-复制算法</h3><blockquote>
<p>  <strong>复制算法；Copying</strong></p>
</blockquote>
<p>为了解决 <strong>标记-清除算法</strong> 在垃圾回收效率方面的缺陷（内存碎片化问题），M.L.Minsky 于 1963 年发表了著名的论文，提出了 <strong>复制（Copying）算法</strong>。</p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>复制算法的核心思想就是：它将可用的内存空间分为大小相等两块，每次只使用其中的一块。当这一块的内存用完了（触发垃圾回收），就将还存活着的对象复制到另一块上去，然后再把已使用的内存空间一次清理掉。最后交换两个内存块的角色。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623825679196-d22ee959-c0ba-4ae8-89b6-cc0a426f58a7.png" alt="复制算法.png"></p>
<ol>
<li> 首先，将可用的内存空间平均分成两块较小的内存空间 A 和 B，其中必须有一块内存空间为空。</li>
<li> 从 GC Roots 开始向下遍历，查找所有根节点的可达对象（存活对象）。</li>
<li> <strong>找到存活对象</strong>后，不再需要将其标记为可达对象（标记-清除算法需要标记），而是直接将该对象复制一份到 B 空间中。遍历完 GC Roots 后，内存 A 中所有存活的对象就全部被复制到内存 B 空间中了。而且由于空间 B 初始为空，所以可以将从空间 A 中复制过去的对象按顺序依次紧凑的插入空间 B 中，即空间 B 中所有对象的物理空间是规整的。</li>
<li> 完成上述第 3 步后，直接销毁整个 A 空间。</li>
<li> 交换 A 、B 两块内存区域的角色。此时，新建对象的内存分配在 A 区，进行 GC 发生在 B 区，以此类推，每 GC 一次就交换一次角色。</li>
</ol>
<hr>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>  <strong>优点：</strong></p>
</blockquote>
<ul>
<li>  没有标记和清除的过程，实现简单，运行高效。（发现可达对象直接移动，无需标记）</li>
<li>  复制过去的对象在新的空间中连续的，不会出现内存碎片化的问题。复制算法每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只需要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效。</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong></p>
</blockquote>
<ul>
<li><p><strong>执行效率不稳定</strong>。如果内存中多数的对象都是存活的，这种算法将会产生大量的内存间复制的开销；但是如果内存中多数对象都是的垃圾对象的话，算法需要复制的就只是占很少比例的存活对象。</p>
<p>  <em>如果内存中垃圾对象很少，复制算法的效果就不会很理想，复制算法需要在内存中存活对象数量不太大的情况下才会更高效。在某种极端情况下，遍历 GC Roots 后发现，A 区中所有的对象都是存活对象，也就是说需要把 A 区中所有对象都复制一遍到 B 区中，显然这是没有任何意义的。</em></p>
</li>
<li><p>  <strong>空间利用率低</strong>。复制算法的缺点十分明显，就是牺牲空间换取时间。可用内存直接缩小为了原来的一半。</p>
</li>
</ul>
<hr>
<h4 id="HotSpot-中的应用"><a href="#HotSpot-中的应用" class="headerlink" title="HotSpot 中的应用"></a>HotSpot 中的应用</h4><ul>
<li>  在新生代中，绝大多数对象都是“朝生夕灭”的，IBM 曾有研究表明——新生代中的对象有 98% 熬不过第一轮收集。也就是说存活对象的占比很低，此时使用复制算法的性价比就很高。所以目前主流的 Java 虚拟机大多都是采用了用复制算法来回收新生代。</li>
<li>  在具体的虚拟机中不必一定按照 1：1 的比例来划分新生代的内存空间。</li>
<li>  1989 年，Andrew Appel 针对具备“朝生夕灭”特点的对象，提出了一种更优的<strong>半区复制分代策略</strong>，现在称为“Appel 式回收”。HotSpot 的 Serial、ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局。Appel 式回收的具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor（from） 中存活的对象一次性复制到另外一块 Survivor（to） 空间上，然后直接清理掉 Eden 和 Survivor（from）空间。HotSpot 中默认 Eden 和 Survivor 的比例是 8：1，即每次新生代的可用内存空间为整个新生代空间的 90%，只有一个 Survivor（to）空间，即 10% 的新生代空间是会被浪费的。</li>
<li>当然，98% 的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法保证每次存活的对象不超过 10%，因此 Appel 式回收还设有一个充当罕见情况的“<strong>逃生门</strong>”，当 Survivor（to）空间不足以容纳一次 Minor_GC 后存活的对象时，就需要依赖其他内存区域（实际上大多都是老年代）进行分配担保（Handle Promotion），容纳不下的对象将通过分配担保机制直接进入老年代。</li>
</ul>
<hr>
<h3 id="2-3-标记-压缩算法"><a href="#2-3-标记-压缩算法" class="headerlink" title="2.3    标记-压缩算法"></a>2.3    标记-压缩算法</h3><blockquote>
<p>  <strong>Mark-Compact；标记-压缩算法；标记-整理算法；标记-压缩-清除；Mark-Compact-Sweep</strong></p>
</blockquote>
<ul>
<li>  <strong>复制算法</strong>在对象存活率较高时就需要进行更多的复制操作，效率将会降低。更关键的是，如果不想浪费 50% 的空间，就要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况。所以在老年代一般不会选择这种算法。</li>
<li>  <strong>标记-清除算法</strong>的确可以应用在老年代中，但是该算法的执行效率与堆空间的大小成反比，老年代是 Java 堆中内存最大的一块区域，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者在此基础之上进行了改正，也就产生了——<strong>标记-压缩（Mark-Compact）算法</strong>，或称为 标记-压缩-清除（Mark-Compact-Sweep）算法。</li>
<li>  在许多现代的垃圾回收器中，人们都使用了标记-压缩算法或其改进版本。</li>
</ul>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ol>
<li> <strong>第一阶段：标记</strong>。采用可达性分析算法，从根节点开始向下遍历，标记所有存活对象。</li>
<li> <strong>第二阶段：压缩。</strong>将所有存活的对象压缩到内存的一端，按顺序排放。</li>
<li> <strong>第三阶段：清除。</strong>直接清理掉边界以外的所有内存。</li>
</ol>
<p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的对象所占内存将会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个空闲内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623845046673-e64913aa-22a9-4c90-9ba5-ab7f96c9445f.png" alt="标记-压缩算法.png"></p>
<p>标记-压缩算法的<strong>最终效果</strong>等同于 <code>标记-清除算法</code> 执行完成以后，再进行一次内存碎片整理，因此，也可以把它称为 <strong>标记-压缩-清除（Mark-Compact-Sweep）算法</strong> 。二者的本质差别在于 <code>标记-清除算法</code> 是一种非移动式的回收算法，而 <code>标记-压缩算法</code> 是移动式的。是否移动回收后存活的对象是一项优缺点并存的风险决策。</p>
<ul>
<li>  如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活对象并更新所有的引用这些对象的地方是一项负担很重的操作，而且这种对象移动操作必须暂停用户应用程序才能进行（STW）。</li>
<li>  但如果不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决，比如通过“空闲列表”来解决内存分配问题，但这又会导致无法再继续创建大对象，会提前触发 Full_GC，势必会直接影响程序的吞吐率。</li>
</ul>
<p>基于以上 2 点，是否移动对象都会存在弊端。</p>
<ul>
<li>  移动对象则内存回收时会更复杂，不移动对象则内存分配时会更复杂。</li>
<li>  从用户程序的停顿时间（STW）上来看，不移动对象单次停顿时间会更短，甚至可以不需要停顿。</li>
<li>  从整个程序的吞吐量上来看，移动对象会更划算。（移动对象后触发 GC 的频率会显著降低，整体 GC 的停顿时间之和反而会更少，吞吐量也就更高）</li>
</ul>
<p>还有一种折中的解决办法就是：让虚拟机平时多数时间都采用 <code>标记-清除算法</code>，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用 <code>标记-压缩算法</code> 收集一次，以获得规整的内存空间。HotSpot 中使用过的 <strong>CMS</strong> 收集器面临碎片空间过多时采用的就是这种处理办法。</p>
<hr>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>  <strong>优点：</strong></p>
</blockquote>
<ul>
<li>  消除了<code>标记-清除算法</code>中，内存区域分散的缺点，我们给新对象分配内存时，JVM 只需要持有一个空闲内存的起始地址值即可。</li>
<li>  消除了复制算法中，内存减半的高额代价。</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong> </p>
</blockquote>
<ul>
<li>  从效率上来说，标记-压缩算法要低于复制算法。</li>
<li>  移动对象的同时，如果对象被其它对象引用，则还需调整引用的地址。</li>
<li>  移动过程中，需要全程暂停用户应用程序（STW）。</li>
</ul>
<hr>
<h2 id="3-三种算法对比"><a href="#3-三种算法对比" class="headerlink" title="3    三种算法对比"></a>3    三种算法对比</h2><table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要存活对象的2倍大小</td>
</tr>
<tr>
<td>是否移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li>  效率上来说，复制算法是最快的，但是却浪费了大量的内存。</li>
<li>  而为了尽量兼顾以上三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记阶段，比标记-清除算法多了一个整理内存阶段。</li>
</ul>
<hr>
<h2 id="4-分代收集理论"><a href="#4-分代收集理论" class="headerlink" title="4  分代收集理论"></a>4  分代收集理论</h2><p>分代收集算法并不是一种真正意义上的算法。前面所讲的这些算法中，并没有一种算法可以完全替代其它算法，它们都具有自己独特的优势和特点，因此分代收集算法应运而生。</p>
<p>分代收集理论建立在两个分代收集假说之上：</p>
<ol>
<li> <strong>弱分代假说</strong>：绝大多数对象都是朝生夕灭的。</li>
<li> <strong>强分代假说</strong>：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>这两个分代假说共同奠定了常用垃圾回收器一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象根据其年龄分配到不同的区域中存储。显然，</p>
<ul>
<li>  如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集的话，那么把它们集中放在一起，每次回收<strong>只关注如何保留少量存活对象</strong>而不是去标记那些大量将要被回收的对象，就能以较低的代价回收到大量的空间。[新生代]</li>
<li>  如果某个区域中保存的都是难以消亡的对象，把他们集中放在一块，虚拟机<strong>只需用较低的频率来回收这个区域</strong>，就可以减少垃圾收集的时间开销。[老年代]</li>
</ul>
<p>目前几乎所有的 Java 虚拟机都是基于分代收集（Generational Collecting）理论设计垃圾收集算法的，设计者一般至少会把 Java 堆划分为新生代（Young_Generation）和老年代（Old_Generation）两个区域。根据各个区域对象的特点使用不同的回收算法，可以提高垃圾回收的效率。</p>
<blockquote>
<p>  <strong>新生代（Young_Gen）特点：</strong></p>
<ul>
<li>  内存空间相对于老年代较小</li>
<li>  对象生命周期短，存活率低</li>
<li>  回收频繁</li>
</ul>
</blockquote>
<p>新生代中，使用<strong>复制算法</strong>进行垃圾收集速度是最快的。①复制算法的效率只和当前区域存活对象占用的内存大小有关，存活对象越少效率越高，而新生代对象的存活率低。②复制算法的对内存利用率低，通过 HotSpot 中的两个 Survivor 区的设计可以得到缓解。堆中新生代和老年代的内存占比为 <code>1 : 2</code>，而新生代中 Eden 区、Survivor 区的占比为 <code>8 : 1</code>，就整体堆空间而言，大约只有 1/30 的空间没有得到很好地利用，处于一个可以接受的范围。</p>
<blockquote>
<p>  <strong>老年代（Tenured Gen）特点：</strong></p>
<ul>
<li>  区域较大（相较于新生代）</li>
<li>  对象生命周期长，存活率高</li>
<li>  回收次数不及新生代频繁</li>
</ul>
</blockquote>
<p>老年代中，对象生命周期长且存活率高，复制算法明显不合适。所以该区域一般由 <strong>标记-清除算法</strong> 和 <strong>标记-压缩算法</strong> 的混合实现。</p>
<ul>
<li>  Mark 阶段的开销与存活对象的数量成正比；</li>
<li>  Sweep 阶段的开销与所管理区域的大小成正比。（Sweep 阶段会将要 GC 的区域全部遍历一遍，并清除未被标记对象所占的内存空间）</li>
<li>  Compact 阶段的开销与存活对象的数量成正比。</li>
</ul>
<p>​    在 Java 堆划分出不同的区域后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，因此才有了 “Minor GC”、“Major GC”、“Full GC” 这样的回收类型的划分，也才能够针对不同的区域使用不同的垃圾收集算法。</p>
<p>​    在 Java 程序运行的过程中，会产生大量对象，其中有些对象与业务信息相关，比如 Http 请求中的 Session 对象、线程、Socket 连接对象，这类对象跟业务直接挂钩，生命周期较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象的生命周期会比较短，比如：String 对象，由于其不变类的特性，系统会产生大量的这种对象，有些对象甚至只用一次就会被回收。</p>
<p>​    分代收集并非只是简单划分一下内存区域这么简单，它至少存在一个明显的困难：<strong>对象不是孤立的，对象之间存在跨代引用</strong>。假如现在要进行一次只局限于新生代的收集（Minor GC），但是新生代的对象是完全有可能被老年代引用的，为了找出该区域存活的对象，不得不在固定的 GC_Roots 之外，再额外遍历整个老年代中所有的对象来确保可达性分析的正确性，反过来也是一样（老年代中的对象也有可能被新生代引用）。遍历整个老年代的方案虽然理论上可行，但无疑会给内存回收带来很大的性能负担。为了解决这个问题，就需要对分代理论添加第三条经验法则：</p>
<ol start="3">
<li> <strong>跨代引用假说</strong>：跨代引用相较于同代引用来说仅占极少数。</li>
</ol>
<p>​    依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需<strong>在新生代上建立一个全局的数据结构（该结构被称为“记忆集 ”，Remembered Set）</strong>，这个结构把老年代划分成若干小块，并记录老年代的哪一块内存存在跨代引用。此后，当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC_Roots 中进行扫描（包含跨代引用的小块只是极少数）。虽然这种方法需要在对象改变引用关系时维护记录数据的正确性，会增加一些额外的运行时开销，但是比起收集时扫描整个老年代来说仍然是划算的。</p>
<ul>
<li>  <em>使用记忆集前：收集新生代需要额外扫描整个老年代空间。</em></li>
<li>  <em>使用记忆集后：收集新生代只需扫描老年代空间中的极少数内存块，但是会增加额外维护记忆集的开销。</em></li>
</ul>
<h3 id="分代收集衍生出来的-GC-分类"><a href="#分代收集衍生出来的-GC-分类" class="headerlink" title="分代收集衍生出来的 GC 分类"></a>分代收集衍生出来的 GC 分类</h3><ul>
<li>部分收集（Partial_GC）：指目标不是完整回收整个 Java 堆的垃圾收集，其中又分为：<ul>
<li>  新生代收集（Young_GC / Minor_GC）：指目标只是新生代的垃圾收集。</li>
<li>  老年代收集（Old_GC / Major_GC）：指目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独收集老年代的行为。（Tip：Major_GC 在不同的资料上含义有点混淆，读者需按上下文区分到底是指老年代回收还是整堆收集）</li>
<li>  混合收集（Mixed_GC）：指目标是收集<strong>整个新生代</strong>和<strong>部分老年代</strong>的垃圾收集。目前只有 G1 收集器会有这种行为。</li>
</ul>
</li>
<li>  整堆收集（Full  GC）：回收整个 Java 堆和方法区的垃圾收集。</li>
</ul>
<hr>
<h1 id="垃圾收集相关概念"><a href="#垃圾收集相关概念" class="headerlink" title="垃圾收集相关概念"></a>垃圾收集相关概念</h1><h2 id="1-根节点枚举"><a href="#1-根节点枚举" class="headerlink" title="1    根节点枚举"></a>1    根节点枚举</h2><ul>
<li>  在可达性分析算法中，需要从 GC_Roots 集合开始查找引用链。固定可作为 GC_Roots 对象的主要有全局性的引用（例如常量引用或者类变量引用）与执行上下文（例如栈帧中的本地变量表）中的引用。但是现在的 Java 应用越来越大，若要逐个检查以 GC_ROOTS 为起点的引用必然耗时很长。 </li>
<li>  迄今为止，所有的收集器在执行根节点枚举这一步骤时都是<strong>必须暂停用户线程</strong>的（STW）。虽然现在可达性分中析耗时最长的查找引用链的过程已经可以做到和用户线程一起并发执行，但是根节点枚举还是<strong>必须在一个能保障一致性的快照中才能得以进行</strong>，若这点不能满足的话，分析的准确性也就不发保证。这也是垃圾收集过程必须停顿用户线程的一个重要原因。</li>
<li>  目前主流的 Java 虚拟机使用的都是准确式垃圾收集，意思就是当用户线程停下来以后，并不需要遍历检查所有的执行上下文引用和全局引用所在的区域，而是让每个区域维护一张 Map 类型的数据结构，通过这张表虚拟机就可以直接得到在该区域中哪些地方存放着对象引用的。在 HotSpot 中，是使用一组 OopMap 的数据结构来达到这个目的，这样收集器直接扫描 OopMap 就可以得到 GC_Roots 中包含的对象信息了，并不需要从方法区或者局部变量表中去挨个查找。</li>
</ul>
<hr>
<h2 id="2-安全点与安全区域"><a href="#2-安全点与安全区域" class="headerlink" title="2    安全点与安全区域"></a>2    安全点与安全区域</h2><h3 id="2-1-安全点（SafePoint）"><a href="#2-1-安全点（SafePoint）" class="headerlink" title="2.1    安全点（SafePoint）"></a>2.1    安全点（SafePoint）</h3><p>程序在执行时并非在代码指令流的任何位置都能够停下来开始垃圾收集，而是强制要求用户线程必须执行到特定位置后停顿下来，垃圾收集线程才能进行 GC，这些位置称为“安全点（Safepoint）”。</p>
<p>Safe_Point 的选择很重要，<strong>如果太稀疏可能导致垃圾收集线程等待的时间太长，如果太密集可能导致程序的吞吐量降低</strong>。</p>
<ul>
<li>  安全点间隔过远，两个安全点间用户线程执行的时间段就会较长（垃圾收集线程从开始等待到执行的时间段就会相对变长），必然导致会出现更多的垃圾对象，垃圾收集时单次停顿时间（STW）就会变长。</li>
<li>  安全点间隔过近，安全点太多就会导致垃圾收集的频率上升，并且每次垃圾收集都会发生 STW，导致程序频繁停顿，整体吞吐量降低。</li>
</ul>
<p>安全点位置的选取通常是根据<em>“是否具有让程序长时间执行的特征”</em>为标准进行选定的。因为大部分指令的执行时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，选择执行时间较长的指令作为 SafePoint 是比较合适的。比如，方法调用、循环跳转和异常跳转等。【保证了长指令流可以在一次两个安全点之间一次性执行完毕】</p>
<p>对于安全点，另一个需要考虑的问题就是：<strong>在发生垃圾收集时，如何保证所有的用户线程都跑到下一个最近的安全点停顿下来呢？</strong> </p>
<blockquote>
<ol>
<li> <strong>抢先式中断：（目前没有虚拟机采用了）</strong> </li>
</ol>
</blockquote>
<p>在发生垃圾收集前，系统要中断所有用户线程。首先第一次中断用户线程，如果用户线程正好停在了安全点上，则中断用户线程。如果用户线程中断的地方不在安全点上，就恢复这些线程，让它们一会儿再重新中断，反复多次，直到所有的用户线程都停在安全点上。 </p>
<blockquote>
<ol start="2">
<li> <strong>主动式中断</strong>（标志位中断）</li>
</ol>
</blockquote>
<p>当发生垃圾收集前，需要中断用户线程的时候，不直接对用户线程进行操作，仅仅简单设置一个（中断）标志位，各个线程执行过程中不停地主动轮询这个标志，一旦发现中断标志为 true 时就将自己停在下一个最近的安全点上。轮询标志和安全点是重合的。</p>
<hr>
<h3 id="2-2-安全区域（SafeRegion）"><a href="#2-2-安全区域（SafeRegion）" class="headerlink" title="2.2    安全区域（SafeRegion）"></a>2.2    安全区域（SafeRegion）</h3><p>SafePoint 机制保证了<strong>程序执行时</strong>，用户线程在不太长的时间内就可以到达安全点并停顿。但是，<strong>程序“不执行”</strong>的时候呢？例如用户线程处于 Sleep 状态或者 Blocked 状态，这时候用户线程是不会向前执行的，也就无法响应虚拟机的中断请求，无法执行到安全点去挂起自己，虚拟机也显然也不可能等待用户线程被唤醒后再走到最近的安全点将自己挂起（因为用户线程 Sleep 或 Blocked 的时间无法确定）。对于这种情况，就需要引入安全区域（SafeRegion）来解决。</p>
<p><strong>安全区域是指能够确保在某一段代码片段中，对象的引用关系不会发生变化</strong>。因此在这个区域中的任何位置开始 GC 都是安全的。我们可以把 SafeRegion 看作是被拉伸了的 SafePoint 。</p>
<ol>
<li> 当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，如果这段时间内发生 GC，就不必处理这些已经位于安全区域内的线程了（虚拟机会忽略标识为 SafeRegion 状态的线程）（但是没有进入安全区域的线程还是要做额外处理）。</li>
<li> 当用户线程即将离开安全区域时，会先检查虚拟机是否已经完成根节点枚举（或者是垃圾收集过程中其它需要暂停用户线程的阶段），如果完成了，则用户线程继续执行；否则用户线程必须继续等待，直到收到可以离开 SafeRegion 的信号为止。</li>
</ol>
<hr>
<h2 id="3-记忆集与卡表"><a href="#3-记忆集与卡表" class="headerlink" title="3    记忆集与卡表"></a>3    记忆集与卡表</h2><p>讲解分代收集理论的时候，提到了为了解决对象跨代引用所带来的的问题，垃圾收集器在新生代中建立了名为<strong>记忆集（Remembered Set）</strong>的数据结构，用于避免把整个老年代加入 GC_Roots 的扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的垃圾收集器（典型的如 G1、ZGC 和 Shenandoah）都会面临相同的问题。</p>
<p>记忆集用于<strong>记录从非收集区域指向收集区域的对象的地址的集合</strong>，是一种抽象的数据结构。</p>
<p>如果不考虑效率和成本的话，最简单的实现方式可以用非收集区域中所有包含跨代引用的对象数组来实现这个数据结构。但是这种记录全部含跨代引用的对象的实现方案，无论是内存占用还是维护成本都相当高。而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针就可以了。那么设计者在实现记忆集的时候，就可以选择更为粗粒度的记录来节省记忆集的存储和维护成本。常见的有：</p>
<ul>
<li>  <strong>字节精度</strong>：每个记录精确到一个机器字长，该字长的位置上包含跨代指针。</li>
<li>  <strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li>  <strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>采用“卡精度”实现的记忆集列表被称为“<strong>卡表（Card_Table）</strong>”，这是目前最常用的一种记忆集实现形式（HotSpot 也采用了这种形式），一些资料中甚至直接把它和记忆集混为一谈。其实<strong>记忆集是一种“抽象”的数据结构，而卡表则是记忆集的一种落地实现</strong>，它定义了记忆集的记录精度。</p>
<p>卡表最简单的形式可以只是一个字节数组（数组中的每个元素只能是 0 或 1，默认为 0），而 HotSpot 也确实是这样做的。字节数组 CARD_TABLE 的每一个元素都对应着内存区域中一块特定大小的内存块，这个内存块被称为“<strong>卡页（Card_Page）</strong>”。一个卡页的内存中通常包含不只一个对象，只要卡页内有一个（或更多）对象的字段存在跨代指针，那么就将卡表的数组元素的值标识为 1，称这个卡页变脏（Dirty），没有则标识为 0。在发生垃圾收集时，只要筛选出卡表中变脏的卡页，就能轻易得出哪些内存区域包含跨代指针，把它们加入 GC_Roots 中一并扫描。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/%E8%AE%B0%E5%BF%86%E9%9B%86_%E5%8D%A1%E8%A1%A8.png" alt="记忆集_卡表"></p>
<p>一般来说，卡页的大小都是以 2^N^ 字节数，HotSpot 中使用的卡页大小是 2^9^ ，即 512 字节。</p>
<ul>
<li><p>如果卡表标识的内存区域的起始地址是 <code>0x0000</code> 的话，数组 Card_Table 的第0、1、2 号元素，分别对应了地址范围为 <code>0x0000~0x01FF</code>、<code>0x0200~0x03FF</code>、<code>0x0400~0x05FF</code> 的卡页内存块。</p>
<p>  <em>卡表只需知道：1、对应卡页的起始位置地址。   2、每个卡页的大小。  就可以推算出整个卡表中每个元素代表的内存块范围了。</em></p>
</li>
<li><p>  如果卡页中存在一个或多个对象存在跨代引用的话，就将该卡页对应的卡表元素标识为 1。</p>
</li>
<li><p>  在发生垃圾收集时，只需要遍历一遍卡表，就可以得到哪些内存块中含有跨代引用的对象，直接扫描对应的内存块即可，而不用遍历整个老年代空间。</p>
</li>
</ul>
<hr>
<h2 id="4-写屏障"><a href="#4-写屏障" class="headerlink" title="4    写屏障"></a>4    写屏障</h2><p>我们已经解决了如何使用记忆集来缩小 GC_Roots 扫描范围的问题。但还没有解决卡表如何维护的问题。即卡页何时变脏、谁来把它们变脏等。</p>
<p><strong>卡页何时变脏</strong>的答案是很明确的——有非收集区域中的对象引用了待收集区域的对象时，非收集区域对应的卡表元素就应该变脏，变脏的时间点原则上应该发生在引用类型赋值的那一刻。但如何在引用类型赋值的那一刻去更新维护卡表呢？ 假如是解释执行的字节码，还相对好处理，虚拟机负责每条字节码指令的执行，有充分的介入空间；但是在编译执行的场景中，经过即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作中。</p>
<p>在 HotSpot 中是通过<strong>写屏障（Write_Barrier）</strong>技术来维护卡表状态的。写屏障可以看做在虚拟机层面对“引用类型字段赋值”这个动作的 AOP 切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作。也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的写屏障叫做<strong>写前屏障（Pre_Write_Barrier）</strong>，在赋值后的写屏障叫做<strong>写后屏障（Post_Write_Barrier）</strong>。HotSpot 虚拟机的很多收集器都用到了写屏障。</p>
<p>应用了写屏障后，虚拟机就会为所有赋值操作生成响应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与 Minor GC 时扫描整个老年代的代价相比还是低得多的。</p>
<hr>
<h2 id="5-并发条件下的可达性分析"><a href="#5-并发条件下的可达性分析" class="headerlink" title="5    并发条件下的可达性分析"></a>5    并发条件下的可达性分析</h2><blockquote>
<p>  <strong>为什么要有并发条件下的可达性分析？</strong></p>
</blockquote>
<ol>
<li> 目前主流的垃圾收集器都采用了可达性分析算法。</li>
<li> 可达性分析过程要求虚拟机处于一个能保持一致性的快照中，即需要暂停所有的用户线程。</li>
<li> 如果垃圾回收的时间很长，那么 STW 的时间就很长，影响用户体验。</li>
<li> 为了缩短停顿时间，就研究出了垃圾回收线程中的可达性标记过程和用户线程并发执行。</li>
<li> 并发条件下的可达性分析算法包括<strong>增量收集算法</strong>和<strong>原始快照算法</strong>两种方式。</li>
</ol>
<h3 id="5-1-基本思想"><a href="#5-1-基本思想" class="headerlink" title="5.1    基本思想"></a>5.1    基本思想</h3><p>如果一次性将所有的垃圾进行处理，就可能会造成系统长时间的停顿，这种情况下，可以考虑让垃圾回收线程和应用程序线程交替执行。 <strong>垃圾回收线程每次只回收一小片区域的内存空间，接着切换到应用程序线程。以此类推，多次重复直到垃圾收集完成</strong> 。</p>
<h3 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2    缺点"></a>5.2    缺点</h3><p>使用这种方式，由于在垃圾回收过程中，间断性的还执行了应用程序代码，所以能减少系统停顿的时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p>
<h3 id="5-3-流程分析"><a href="#5-3-流程分析" class="headerlink" title="5.3    流程分析"></a>5.3    流程分析</h3><p>当前主流的垃圾收集器大多都是依靠可达性分析算法来判定对象是否存活的。可达性分析算法理论上要求在枚举可达对象的整个过程都要基于一个能保障一致性的快照中才能够进行分析，这就意味着分析过程中必须暂停所有的用户线程。在根节点枚举这一步骤中，由于 GC_Roots 相较于整个 Java 堆中的全部对象毕竟还算极少数，且在各种优化技巧（如 OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从 GC_Roots 再继续向下遍历对象图，这一步骤的停顿时间就必定会与 Java 堆容量成正比了：堆越大，存储的对象越多，对象图结构越复杂，要标记的对象更多，停顿的时间自然也就更长了。</p>
<p>包含“标记”阶段是所有追踪式垃圾回收算法的共同特征，如果这个阶段会随着堆变大而增加停顿时间的话，其影响将会波及几乎所有的垃圾收集器。同理，如果能够削减这部分的停顿时间的话，那收益也将会是系统性的。</p>
<p>想要解决或者降低用户线程的停顿，首先要搞清楚<strong>为什么必须要在一个能保障一致性的快照中才能进行对象图的遍历？</strong>为了能解释清这个问题，我们引入三色标记作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色。</p>
<ul>
<li>  白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li>  黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其它对象引用指向了黑色对象，无需重新扫描一遍。黑色对象不可能直接（不经过黑色对象）指向某个白色对象。</li>
<li>  灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。（扫描了，但没扫描完）</li>
</ul>
<p>关于可达性分析的扫描过程，可以想象成对象图上一股以黑色为波峰的波纹从黑向白推进的过程，如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。但如果用户线程与收集器线程并发工作，就会出现收集器线程在对象图上标记颜色，同时用户线程在修改引用关系。这样可能出现两种后果：一种是把原本要死亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的<strong>浮动垃圾</strong>而已，下次收集清理掉即可。另一种情况是把原本存活的对象错误标记为死亡，这就是非常致命的错误了，程序肯定会因此发生错误，甚至崩溃 。</p>
<blockquote>
<p>  并发出现“对象消失”问题的示意图</p>
</blockquote>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="并发的可达性分析"></p>
<p>经证明，当且仅当以下两个条件<strong>同时</strong>满足时，会产生“对象消失”的问题。即原本应该是黑色的对象被误标为白色。</p>
<ul>
<li><p><strong>（用户线程）赋值器插入了一条或多条从黑色对象到白色对象的新引用</strong>。</p>
<p>  <em>由于用户线程和垃圾收集线程是并发执行的，所以存在这样一种情况，垃圾回收线程扫描过程中，已经被标记为黑色的对象被用户线程使用，并且新增了一条或多条引用指向白色对象，但是在标记阶段结束后，黑色对象不会再被重新扫描一遍，也就是说，这些新增的白色对象，如果只被该黑色对象引用，那么它仍然会是一个白色对象，而实际上这些新增的对象应该是黑色对象。</em></p>
</li>
<li><p><strong>（用户线程）赋值器删除了全部从灰色对象到该白色对象的直接引用或间接引用</strong>。</p>
<p>  <em>由于用户线程和垃圾收集线程是并发执行的，所以存在这样一种情况，垃圾回收器线程访问到某个对象，先将该对象从白色变为灰色，接下来要扫描该灰色对象所关联的其它所有对象，但是此时程序切换到用户线程去执行了，用户线程删除了该灰色对象关联的某个白色对象（并且该白色对象只被该灰色对象引用），那么标记结束后，该白色对象就不会被标记成黑色对象，但是该对象理论上在收集开始时的快照中是应该作为一个黑色对象的。</em></p>
</li>
</ul>
<p>因此，我们要解决并发扫描时的对象消失问题，只需要破坏这两个条件中的任意一个即可。由此分别产生了两种解决方案：<strong>①增量更新（Incremental Update）    ②原始快照（Snapshot At The Beginning，SATB）</strong></p>
<blockquote>
<p>  <strong>增量更新</strong></p>
</blockquote>
<p><strong>增量更新</strong>是要破坏第一个条件，当黑色对象插入指向白色对象的新的引用关系时，就将这个新引用关系记录下来，等并发扫描结束后 ，再以这些记录过引用关系的黑色对象为根，重新扫描。简言之就是，黑色对象一旦新插入了指向白色对象的引用后，它就重新变为灰色对象了。</p>
<blockquote>
<p>  <strong>原始快照</strong></p>
</blockquote>
<p><strong>原始快照</strong>要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再以这些记录过的引用关系的灰色对象为根，按照记录下来的引用关系再重新扫描一次。简言之就是，无论引用关系删除与否，都会按照刚开始扫描那一刻的对象图快照来进行搜索 。    </p>
<p>以上无论是对引用关系的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在 HotSpot 中，增量更新和原始快照这两种解决方案都有实际的应用，譬如，CMS 是基于增量更新来做并发标记的，G1、Shenandoah 则是用原始快照来实现。</p>
<hr>
<h2 id="6-分区算法"><a href="#6-分区算法" class="headerlink" title="6    分区算法"></a>6    分区算法</h2><p>分区算法的目的和并发条件下的可达性分析算法目的相同，都是<strong>为了更好的控制用户线程 STW 的时间</strong>。</p>
<p>一般来说，堆空间越大，堆中对象越多，垃圾对象也就越多，单次回收垃圾所需的时间就越长，用户线程单次停顿的时间也就越长。为了更好的控制内存回收产生的停顿时间，分区算法采用将一块大的内存区域分割成多个小块，根据预设定的目标停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而达到减少用户线程单次停顿时间的目的。</p>
<p><strong>分代算法是按照对象生命周期的长短将堆划分成两个部分，分区算法是将整个堆空间划分成多个不同的小区间（region）</strong>。</p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<hr>
<h2 id="7-System-gc-的理解"><a href="#7-System-gc-的理解" class="headerlink" title="7    System.gc() 的理解"></a>7    System.gc() 的理解</h2><blockquote>
<p>  <strong>源码：<code>System.gc()</code></strong></p>
</blockquote>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623921665668-70b6c909-16f7-4eed-be86-9eeb22c86b3f.png" alt="image.png"></p>
<ul>
<li><p>  默认情况下，调用 <code>System.gc()</code> 或者 <code>Runtime.getRuntime().gc()</code> 方法， <strong>会显式地触发 Full GC</strong> ，对整个堆和方法区进行回收，尝试释放失效对象占用的内存空间。</p>
</li>
<li><p>  然而调用 <code>System.gc()</code> 方法时会附带一个免责声明，即无法保证垃圾回收器能即时被调用。</p>
</li>
<li><p>  <code>System.gc()</code> 方法仅仅是通知虚拟机，希望调用一次 GC ，但是由于具体调用 GC 涉及到垃圾收集线程，只有等到垃圾收集线程执行时，才会真正的去执行 GC 。</p>
</li>
<li><p>  开发人员可以通过调用 <code>System.gc()</code> 方法来决定 JVM 的 GC 行为。而<strong>一般情况下，垃圾回收应该是自动进行的，无需手动触发</strong>。</p>
</li>
</ul>
<blockquote>
<p>  <strong>显式 GC 与 JVM 自动 GC 的区别</strong></p>
</blockquote>
<ul>
<li>  由于垃圾收集线程的优先级要远低于用户线程的优先级，所以在 JVM 自动 GC 的情况下，一般只会在某个区域内存不足（达到设定的阈值）时才会由垃圾收集线程调用垃圾收集器尝试释放已死亡对象占用的内存。 </li>
<li>  也就是说，在应用程序运行的很长一段时间内，即使垃圾收集线程轮询了到 CPU 资源，但是由于堆空间未达到 GC 的标准，垃圾回收线程也不会去执行 GC 过程，而是让出 CPU 资源给优先级更高的线程。</li>
<li>  而手动调用 <code>System.gc()</code> 方法之后，只要下一次垃圾收集线程轮询到了 CPU 资源，那么不管堆空间有没有达到 GC 的标准，就会直接去执行 GC 行为回收堆中已死亡的对象。  </li>
</ul>
<hr>
<h2 id="8-内存溢出与内存泄漏"><a href="#8-内存溢出与内存泄漏" class="headerlink" title="8    内存溢出与内存泄漏"></a>8    内存溢出与内存泄漏</h2><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><ul>
<li>  JavaDoc 中对于 OutOfMemory 的解释是：<strong>①没有空闲的内存空间    ②并且通过垃圾回收后也无法提供更多内存</strong></li>
<li>  内存溢出是相对于内存泄漏来讲的。</li>
<li>  由于 GC 一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收跟不上内存消耗的速度，否则不太容易出现 OOM 的情况。</li>
<li>  大多数情况下，GC 会分别进行各种年龄段的垃圾回收，某些情况下甚至会进行一次独占式的 Full GC 操作，这时会释放大量的内存，供应用程序继续使用。</li>
</ul>
<blockquote>
<ol>
<li> <strong>没有空闲的内存空间</strong></li>
</ol>
</blockquote>
<p>首先说没有空闲内存的情况，说明 Java 虚拟机的堆内存不够。原因有二：</p>
<ol>
<li><p>Java 虚拟机的堆内存设置不够。</p>
<p> 比如：可能存在内存泄漏问题；也有可能就是堆的大小不合理，比如我们要处理比较大的数据量，没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数 <code>-Xms</code> 、 <code>-Xmx</code> 来调整。</p>
</li>
<li><p> 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p>
</li>
</ol>
<p>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemory 也非常常见，尤其是在运行时存在大量动态类型生成的场合；类似于 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息。会标记出来和永久代相关： <strong>java.lamg.OutOfMemoryError: PermGen space</strong> </p>
<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改变，出现 OOM，异常信息则变成了：<strong>java.lamg.OutOfMemoryError: Metaspace 。</strong>直接内存不足，也会导致 OOM。</p>
<blockquote>
<ol start="2">
<li> <strong>并且通过垃圾回收后也无法提供更多内存</strong></li>
</ol>
</blockquote>
<ul>
<li>  意思是说，在抛出 OOM 之前，通常垃圾回收器会被触发。尽其所能去清理出空间。</li>
<li>  例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。</li>
<li>  当然，也不是在任何情况下垃圾回收器都会被触发的。比如，我们去分配一个超大的对象，例如分配一个超大数组超过堆的最大值，JVM 可以判断出垃圾回收并不能解决这个问题，所以直接抛出 OOM。</li>
</ul>
<h3 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h3><ul>
<li>  Memory_Leak 也称作“存储渗漏”。严格来说， <strong>只有对象不会再被程序用到了，但是 GC 又无法回收它们的情况，才叫做内存泄漏</strong> 。但是实际上很多时候由于一些不太好的实现或疏忽会导致<strong>一些对象的生命周期变得很长甚至 OOM，也可以叫做宽泛意义上的“内存泄漏”</strong>。 </li>
<li>  尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory 异常，导致程序崩溃。（内存泄漏最终还是会导致内存溢出），</li>
</ul>
<p>Tip：这里的存储空间并不是指物理内存，而是值虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<h4 id="Java-中内存泄漏举例"><a href="#Java-中内存泄漏举例" class="headerlink" title="Java 中内存泄漏举例"></a>Java 中内存泄漏举例</h4><blockquote>
<ol>
<li> <strong>单例模式</strong> </li>
</ol>
</blockquote>
<p>单例对象的生命周期是非常长的，一旦被创建了之后就不会被自动回收。在含有单例对象的应用程序中，如果一个单例对象持有某个外部对象的引用的话，因为单例对象在程序运行时一定不会被回收，那么与之相连的外部对象自然也不会被回收的，但是这个外部对象可能并不是在整个程序运行过程中都需要使用，这时候我们就称发生了内存泄漏。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623936681185-27ef20bd-43f6-47d0-a355-ee40952eee7f.png" alt="内存泄漏.png"></p>
<blockquote>
<ol start="2">
<li> <strong>一些提供 close() 方法的资源未关闭导致内存泄漏</strong></li>
</ol>
</blockquote>
<p>一些提供了 <code>close()</code> 方法的资源<strong>如果不主动调用 close() 方法的话，JVM 是不会去自动回收这些对象的</strong>，这中情况也会造成内存泄漏。如：数据库连接（ <code>dataSource.getConnection()</code> ）、网络连接（ <code>socket</code>）和 IO 连接等，必须手动调用 <code>cloes()</code> 方法，否则是不会被回收的。</p>
<hr>
<h2 id="9-Stop-The-World"><a href="#9-Stop-The-World" class="headerlink" title="9    Stop The World"></a>9    Stop The World</h2><blockquote>
<p>  <strong>什么是 STW ？</strong></p>
</blockquote>
<p>Stop The World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。 <strong>停顿产生时整个应用程序的用户线程都会被暂停，没有任何响应</strong>，这个停顿被称为 STW。 </p>
<blockquote>
<p>  <strong>STW 发生在什么时候？</strong></p>
</blockquote>
<p><strong>可达性分析算法中枚举根节点（GC Roots）会导致所有用户线程停顿。</strong></p>
<ul>
<li>  分析工作必须在一个能确保一致性的快照中进行。</li>
<li>  一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上。</li>
<li>  如果出现分析过程中对象的引用关系还在不断变化，则分析结果的准确性无法得到保证。</li>
</ul>
<p>被 STW 中断的应用程序会在完成 GC 之后恢复运行，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p>
<blockquote>
<p>  <strong>注意</strong></p>
</blockquote>
<ul>
<li>  STW  事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</li>
<li>  哪怕是 G1 也不能完全避免 STW 情况的发生，只能说垃圾回收器越优秀，回收效率越高，尽可能地缩短了暂停时间。</li>
<li>  <strong>STW 是 JVM 在后台自动发起和自动完成的</strong>。在用户不可见的情况下，把用户的正常线程全部停掉。</li>
<li>  开发中不建议使用 <code>System.gc()</code> 方法，因为这会导致 Stop-the-World 的发生。</li>
</ul>
<hr>
<h2 id="10-垃圾回收的并行与并发"><a href="#10-垃圾回收的并行与并发" class="headerlink" title="10    垃圾回收的并行与并发"></a>10    垃圾回收的并行与并发</h2><h3 id="10-1-操作系统的并行与并发"><a href="#10-1-操作系统的并行与并发" class="headerlink" title="10.1    操作系统的并行与并发"></a>10.1    操作系统的并行与并发</h3><blockquote>
<p>  <strong>并发（Concurrent）</strong></p>
</blockquote>
<ul>
<li>  一个 CPU 同时执行多个 <code>线程/进程</code>。</li>
<li>  并发并不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段，然后在这几个时间片段之间来回切换，由于 CPU 处理速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序在同时进行。</li>
</ul>
<blockquote>
<p>  <strong>并行（Parallel）</strong></p>
</blockquote>
<ul>
<li>  多个 CPU 同时执行多个<code>线程/进程</code>，两个<code>线程/进程</code>之间互不抢占 CPU 资源。</li>
<li>  决定并行的因素并不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</li>
</ul>
<h3 id="10-2-垃圾回收的并行与并发"><a href="#10-2-垃圾回收的并行与并发" class="headerlink" title="10.2    垃圾回收的并行与并发"></a>10.2    垃圾回收的并行与并发</h3><p>并行与并发，在垃圾回收器的上下文语境中，可以理解为：</p>
<blockquote>
<p>  <strong>并行（Parallel）：</strong></p>
</blockquote>
<ul>
<li>  并行描述的是多条垃圾收集线程之间的关系，指同一时间有多条垃圾收集线程在协同工作。通常默认此时用户线程处于等待状态。 </li>
<li>  如 ParNew、Parallel Scavenge、Parallel Old</li>
</ul>
<blockquote>
<p>  <strong>串行（Serial）：</strong></p>
</blockquote>
<ul>
<li>  相较于并行的概念，指同一时间只有一个垃圾收集线程工作，且用户线程处于等待状态。</li>
<li>  如果内存不够，则程序暂停，启动 JVM 垃圾收集器线程进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
<blockquote>
<p>  <strong>并发（Concurrent）：</strong></p>
</blockquote>
<ul>
<li>  并发描述的是<strong>垃圾收集线程与用户线程之间的关系</strong>，指同一时间垃圾收集线程和用户线程都在运行（但不一定是并行的，可能会交替执行）。</li>
<li>  由于用户线程并未被冻结，所以程序此时仍能响应服务请求，但由于垃圾收集线程占用了一部分系统资源，此时应用线程处理的吞吐量将受到一定的影响。 </li>
<li>  如 CMS、G1 </li>
</ul>
<hr>
<h2 id="11-引用分类"><a href="#11-引用分类" class="headerlink" title="11    引用分类"></a>11    引用分类</h2><blockquote>
<ul>
<li>  强引用</li>
<li>  软引用</li>
<li>  弱引用</li>
<li>  虚引用</li>
<li>  终结器引用</li>
</ul>
</blockquote>
<blockquote>
<p>  <strong>面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</strong></p>
</blockquote>
<p>在 JDK1.2 之前，Java 里面的引用是很传统的定义：如果 <code>reference</code> 类型的数据中存储的数值代表的是另一块内存的起始地址，就称该 <code>reference</code> 数据是代表某个内存、某个对象的引用。</p>
<p>但是，我们还希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存在进行<strong>垃圾回收后</strong>还是很紧张，则可以抛弃这些对象。（类似于缓存）</p>
<p>在 JDK1.2 之后，Java 对引用的概念进行了扩充，将引用分为 <code>强引用（Strong Reference）&gt; 软引用（Soft Reference）&gt; 弱引用（Weak Reference）&gt; 虚引用（Phantom Reference）</code> 4 种，这 4 种引用强度依次逐渐减弱。（强软弱虚）</p>
<ul>
<li>  <strong>强引用（StrongReference）</strong>：最传统的引用的定义，在程序代码之中普遍存在的引用赋值，即类似于“<code>Object obj = new Object()</code>”这种引用关系<strong>。无论任何情况下，只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象。</strong></li>
<li>  <strong>软引用（SoftReference）</strong>：软引用用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行二次回收（即使这些对象的软引用关系还存在）。如果这次回收后还没有足够的内存，才会抛出 OOM 异常。</li>
<li>  <strong>弱引用（WeakReference）</strong>：只被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li>  <strong>虚引用（PhantomReference）</strong>：一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过这个虚引用获得到一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾回收器回收时收到一个系统通知。</li>
</ul>
<p>除了强引用外，其它 3 种引用均可在 <code>java.lang.ref</code> 包下找到。如下图，开发人员可以直接在应用程序中使用它们。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623993190508-8050a81c-0648-4d05-98a0-b95da344d942.png" alt="image.png"></p>
<p>Reference 子类中只有 <code>FinalReference(终结器引用)</code> 是包内可见的（使用默认空修饰符，只能在当前包下使用），其它 3 种引用类型均为 public ，可以在应用程序中直接使用。</p>
<h3 id="1、强引用（Strong-Reference）——不回收"><a href="#1、强引用（Strong-Reference）——不回收" class="headerlink" title="1、强引用（Strong Reference）——不回收"></a>1、强引用（Strong Reference）——不回收</h3><ul>
<li>  在 Java 程序中，最常见的引用就是强引用，也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。当在 Java 语言中使用 new 关键字创建一个新的对象，并将其赋值给一个变量的时候，这个变量就称为指向该对象的一个强引用。</li>
<li>  强引用的对象是可触及的（可达的），垃圾回收器永远不会回收被强引用关联的对象。</li>
<li>  对于一个普通的对象而言，如果没有其它的引用关系，只要超过了强引用的作用域或者显式地将相应的强引用赋值为 null，就可以将该对象当做垃圾回收了，当然具体的回收时机还是要看垃圾回收的策略。</li>
<li>  相对的，软引用、弱引用和虚引用关联的对象分别是软可触及、弱可触及、虚可触及的，在一定条件下，这些引用关联的对象都是可以被回收的（而强引用关联的对象则在强引用未失效之前是绝对不可以回收的）。所以，<strong>强引用是造成 Java 内存泄漏的主要原因之一</strong>。</li>
</ul>
<p><strong>强引用特点</strong></p>
<ul>
<li>  强引用可以直接访问目标对象</li>
<li>  强引用所关联的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向的对象。</li>
<li>  强引用可能会导致内存泄漏。</li>
</ul>
<hr>
<h3 id="2、软引用（Soft-Reference）——内存不足时回收"><a href="#2、软引用（Soft-Reference）——内存不足时回收" class="headerlink" title="2、软引用（Soft Reference）——内存不足时回收"></a>2、软引用（Soft Reference）——内存不足时回收</h3><ul>
<li>  软引用是用来描述一些还有用，但非必需的对象。</li>
<li>  <strong>只被软引用关联的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围进行二次回收，如果这次回收还没有得到足够的内存，才会抛出 OOM 异常</strong>。</li>
<li>  软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用，如果还有空闲内存，就可以暂时保留缓存数据，当内存不足时，就清理掉缓存数据，这样就保证了使用缓存的同时，不会耗尽内存。</li>
<li>  垃圾回收器在某个时刻决定回收软可触及对象的时候，会清理软引用，并可选的把软引用放到一个引用队列（Reference Queue），通过这个队列可以追踪到对象的回收情况。</li>
<li>  软引用类似于弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。（当内存足够时，不会回收软引用对象，当内存不足时，才会回收软引用对象）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建 obj 对象，用强引用关联</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line"><span class="comment">// 2、创建一个软引用，并关联到 obj 对象</span></span><br><span class="line">SoftReference&lt;Object&gt; sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);    </span><br><span class="line"><span class="comment">/* 此时，强引用 和 软引用 同时关联到 obj 对象 */</span></span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 销毁强引用</span></span><br><span class="line"><span class="comment">/* 此时，就只剩软引用指向 obj 对象了 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价方式----------------------------------------</span></span><br><span class="line">SoftReference&lt;Object&gt; sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="3、弱引用（Weak-Reference）——发现即回收"><a href="#3、弱引用（Weak-Reference）——发现即回收" class="headerlink" title="3、弱引用（Weak Reference）——发现即回收"></a>3、弱引用（Weak Reference）——发现即回收</h3><ul>
<li>  弱引用也是用来描述那些非必需的对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集为止</strong>。在系统 GC 时，只要发现弱引用，不管系统堆空间是否充足，都会回收掉只被弱引用关联的对象。</li>
<li>  但是，由于垃圾回收线程的优先级很低，因此，并不一定能很快的发现只持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li>
<li>  弱引用和软引用一样，在构造弱引用时，也可以指定一个弱引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以追踪到对象的回收情况。</li>
<li>  软引用、弱引用都适合用来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以保留较长的时间，从而起到加速系统的作用。</li>
</ul>
<p>在 JDK1.2 之后，Java 提供了 <code>java.lang.ref.WeakReference</code> 类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">WeakReference&lt;Object&gt; sr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);    </span><br><span class="line">obj = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价方式----------------------------------------</span></span><br><span class="line">WeakReference&lt;Object&gt; sr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>  弱引用对象与软引用对象最大的不同就在于：在进行 GC 时，对于软引用对象，GC 需要通过算法检查是否回收软引用对象；而对于弱引用对象，GC 总是进行回收。弱引用对象更容易、更快被 GC 回收。</li>
</ul>
<blockquote>
<p>  <strong>面试题：你开发中使用过 WeakHashMap 吗 ？</strong></p>
</blockquote>
<hr>
<h3 id="4、虚引用（Phantom-Reference）——对象回收跟踪"><a href="#4、虚引用（Phantom-Reference）——对象回收跟踪" class="headerlink" title="4、虚引用（Phantom Reference）——对象回收跟踪"></a>4、虚引用（Phantom Reference）——对象回收跟踪</h3><ul>
<li>  虚引用也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</li>
<li>  一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li>
<li>  <strong>虚引用不能单独使用，也无法通过虚引用来获取关联的对象</strong>。当试图通过虚引用的 <code>get()</code> 方法取的对象时，结果总是为 null。</li>
<li>  为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<blockquote>
<p>  <strong>引用队列</strong></p>
</blockquote>
<ul>
<li>  虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，用于告知程序对象的回收情况。</li>
<li>  <strong>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录</strong>。</li>
<li>  在 JDK1.2 之后，Java 提供了 <code>java.lang.ref.PhantomReference</code> 类来实现虚引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个只有虚引用连接的对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">ReferenceQueue&lt;Object&gt; phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; pr = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用虚引用调用对象，发现结果为 null</span></span><br><span class="line">System.out.println(pr);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5、终结器引用"><a href="#5、终结器引用" class="headerlink" title="5、终结器引用"></a>5、终结器引用</h3><ul>
<li>  它用于实现对象的 <code>finalize()</code> 方法，也可以称为终结器引用。</li>
<li>  无需手动编码，其内部需要配合引用队列使用。（构造方法中必须传入一个引用队列）</li>
<li>  在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用的对象并调用它的 <code>finalize()</code> 方法，第二次 GC 时才能回收被引用对象。</li>
</ul>
<hr>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="1-垃圾收集器分类"><a href="#1-垃圾收集器分类" class="headerlink" title="1    垃圾收集器分类"></a>1    垃圾收集器分类</h2><ul>
<li>  由于《Java虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器可能会有很大的差别。</li>
<li>  由于 JDK 的版本处于高速迭代的过程中，因此 Java 发展至今已经衍生出了众多的 GC 版本。</li>
</ul>
<p>从不同的角度分析垃圾回收器，可将 GC 分为不同的类型。  </p>
<blockquote>
<ol>
<li> 按垃圾收集的线程数分，可以分为<strong>串行垃圾收集器</strong>和<strong>并行垃圾收集器</strong>。</li>
</ol>
</blockquote>
<ul>
<li>串行回收指的是在同一时间段内只允许有一个垃圾收集线程用于执行垃圾回收操作，此时所有用户线程将被暂停，直至垃圾收集工作结束。<ul>
<li>  在只有单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的 Client 模式下的 JVM 中。</li>
<li>  在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
</li>
<li>  和串行收集相反，并行收集可以同时使用多个垃圾收集线程执行垃圾回收，因此提升了应用的吞吐量，不过并行回收与串行回收一样仍然采用了<strong>独占式</strong>的方式，即会产生 STW 。</li>
</ul>
<blockquote>
<ol start="2">
<li> 按工作模式分，可分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong>。</li>
</ol>
</blockquote>
<ul>
<li>  并发式垃圾回收指垃圾收集线程与用户线程交替运行，以尽可能减少应用程序的单次停顿时间。</li>
<li>  独占式垃圾回收器（Stop The World）一旦运行，就停止应用程序中所有的用户线程，直至垃圾回收过程完全结束。</li>
</ul>
<blockquote>
<ol start="3">
<li> 按碎片处理方式分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。</li>
</ol>
</blockquote>
<ul>
<li>压缩式垃圾回收指在回收完成后，对存活对象进行压缩整理，消除回收后的内存碎片。<ul>
<li>  再给新对象分配内存空间时使用策略：指针碰撞</li>
</ul>
</li>
<li>非压缩式垃圾回收器不进行内存整理的操作。<ul>
<li>  再给对象分配内存空间时使用：空闲列表 </li>
</ul>
</li>
</ul>
<blockquote>
<ol start="4">
<li> 按工作的内存区间分，可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</li>
</ol>
</blockquote>
<hr>
<h2 id="2-GC性能指标"><a href="#2-GC性能指标" class="headerlink" title="2    GC性能指标"></a>2    GC性能指标</h2><h3 id="评估垃圾收集器性能的指标"><a href="#评估垃圾收集器性能的指标" class="headerlink" title="评估垃圾收集器性能的指标"></a>评估垃圾收集器性能的指标</h3><ul>
<li>  <strong>吞吐量：用户线程执行的时间占总运行时间的比例</strong>。（总运行时间 = 用户线程执行时间 + 垃圾回收线程执行时间）</li>
<li>  垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li>  <strong>暂停时间：执行垃圾回收时，用户线程单次暂停的时间</strong>。</li>
<li>  <strong>内存占用：Java 堆区所占的内存大小</strong>。</li>
<li>  收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>  快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>上述指标中加粗的三项共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。但是一款优秀的收集器通常最多只能同时满足其中的两项。  </p>
<p>这三项中，暂停时间的重要性日益凸显。因为随着硬件的发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量，而内存的扩大，对延迟反而带来负面效果。</p>
<blockquote>
<p>  <em>内存空间越大，能容纳的对象也就越多，那么 GC 的间隔时间也就越长（默认情况下只有可用内存达到了一定的阈值之后才会进行 GC，当内存空间足够大时，相应的这个阈值也就会增长），并且每次要回收的对象也就越多，那么此时 STW 的时间显然也会增加。</em></p>
</blockquote>
<p>简单来说，主要抓住两点：  </p>
<ul>
<li>  吞吐量</li>
<li>  暂停时间</li>
</ul>
<h4 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）<img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624101790607-b6effada-59c2-41df-8182-7cc9860a09ad.png" alt="吞吐量与暂停时间.png"></h4><ul>
<li><p>  吞吐量就是 CPU 用于运行用户线程的时间与 CPU 总消耗时间的比值，即 <code>吞吐量 = 运行用户线程时间 /（运行用户线程时间 + 垃圾收集时间）</code>。</p>
</li>
<li><p>  某一段时间内，吞吐量越高（越接近100%），垃圾收集的总耗时就越短，垃圾收集的次数比较少，但单次垃圾收集耗时反而会变长。</p>
</li>
<li><p>  吞吐量越低，垃圾收集的总耗时就越长，垃圾回收越频繁（垃圾回收频繁是因为堆内存空间较小），但单次垃圾收集的时间反而会变短。</p>
</li>
<li><p>  低延迟（低停顿时间）情况下，用户线程和垃圾回收线程频繁切换，切换线程也会产生一定的额外时间花销。</p>
</li>
<li><p>  高吞吐量情况下，应用程序能容忍较高的暂停时间。因此说，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
</li>
<li><p>  吞吐量优先，意味着在<strong>单位时间</strong>内，STW 的时间最短。</p>
</li>
</ul>
<hr>
<h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><ul>
<li>  暂停时间优先，意味着尽可能让单次 STW 的时间最短。但是在较长的一段时间内，STW 的总时间反而会更长（因为频繁切换应用程序线程和垃圾回收线程之间会有额外的时间开销），吞吐量自然也随之下降，也就是说，吞吐量优先和暂停时间优先是相互矛盾的。</li>
</ul>
<hr>
<h4 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h4><p>“高吞吐量”和“低暂停时间”是一对相互竞争的目标（矛盾）：</p>
<ul>
<li>  如果选择吞吐量优先，那么必然<strong>需要降低内存回收的执行频率</strong>，但是这样会导致单次 GC 需要更长的暂停时间来执行内存回收。</li>
<li>  相反的，如果选择低延迟优先的原则，那么为了降低每次执行内存回收的暂停时间，也只能<strong>频繁的执行内存回收</strong>，但这又会引起年轻代内存的缩减和程序吞吐量的下降。</li>
</ul>
<blockquote>
<p>  <strong>举例</strong></p>
</blockquote>
<p><em>采用控制变量法，假设在某一段固定的时间内（比如 10s），运行同一应用程序会产生 100M 的垃圾对象。</em></p>
<ul>
<li>  <em>如果采用“高吞吐量”原则，回收频率低（假设共回收了 4 次），那么单次回收 25M 的对象，每次回收花费 100ms</em></li>
<li>  <em>如果采用“低暂停时间”原则，则单次暂停时间较短（假设为 80ms），但相应的回收频率就会增加（假设共回收了 5 次），单次回收 20M 的垃圾，</em></li>
<li>  <em>引起年轻代内存下降是因为单次回收的垃圾量变少了，那么 JVM 就不会在年轻代分配过多的空间，好让年轻代能频繁的触发 GC</em></li>
</ul>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<p><strong>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只能针对两个目标之一（即只专注于“高吞吐量”或“最小暂停时间”），或者尝试找到一个二者的折中。</strong></p>
<hr>
<h2 id="3-不同的垃圾回收器概述"><a href="#3-不同的垃圾回收器概述" class="headerlink" title="3    不同的垃圾回收器概述"></a>3    不同的垃圾回收器概述</h2><p>​    垃圾收集机制是 Java  的招牌能力，极大地提高了开发效率。有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p>
<h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><ul>
<li>  2020 年 3 月，JDK14 发布。删除了 CMS 垃圾回收器，扩展 ZGC 在 macOS 和 Windows 上的应用。</li>
</ul>
<h3 id="7-款经典的垃圾回收器"><a href="#7-款经典的垃圾回收器" class="headerlink" title="7 款经典的垃圾回收器"></a>7 款经典的垃圾回收器</h3><ul>
<li>  串行回收器：Serial、Serial Old</li>
<li>  并行回收器：ParNew、Parallel Scavenge、Parallel Old</li>
<li>  并发回收器：CMS、G1</li>
</ul>
<h4 id="七款垃圾回收器与垃圾分代之间的关系"><a href="#七款垃圾回收器与垃圾分代之间的关系" class="headerlink" title="七款垃圾回收器与垃圾分代之间的关系"></a>七款垃圾回收器与垃圾分代之间的关系</h4><p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624106917861-943a5a11-8e99-4d7d-9ecb-c104bd8ff813.png" alt="7款经典收集器.png"></p>
<ul>
<li>  新生代垃圾回收器：Serial、Parallel Scavenge、ParNew</li>
<li>  老年代垃圾回收器：Serial Old、Parallel Old、CMS</li>
<li>  整堆垃圾回收器：G1</li>
</ul>
<h4 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h4><p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624107922035-37d34be3-ec03-4b2f-86de-f7114309d6a8.png" alt="垃圾回收器的组合关系.png"></p>
<ul>
<li>  两个收集器之间有连线，表示它们可以搭配使用。</li>
<li>  其中 Serial Old 作为 CMS 出现“Concurrent Mode Failure”失败时的候选方案。</li>
<li>  （红色虚线）由于维护和兼容性测试的成本，在 JDK8 时将 <code>Serial + CMS</code> 、 <code>ParNew + Serial Old</code> 这两个组合声明为废弃，并在 JDK9 中完全移除了这两个组合。</li>
<li>  （绿色虚线）JDK14 中：弃用 <code>Parallel Scavenge + Serial Old</code> 组合。</li>
<li>  （绿色虚线）JDK14 中，删除 CMS 垃圾回收器。</li>
</ul>
<blockquote>
<p>  <strong>为什么要有很多收集器，一个不够吗？</strong></p>
</blockquote>
<ul>
<li>  因为 Java 的使用场景很多，移动端、服务器等。所以就需要针对不用的场景，提供不同的垃圾回收器，提高垃圾回收的性能。 </li>
<li>  没有一种在任何场景下都适用的完美的垃圾回收器存在，所以我们选择的只是在具体的应用场景下最合适的垃圾收集器。</li>
</ul>
<h4 id="如何查看默认的垃圾回收器"><a href="#如何查看默认的垃圾回收器" class="headerlink" title="如何查看默认的垃圾回收器"></a>如何查看默认的垃圾回收器</h4><ul>
<li>  命令行参数（包含使用的垃圾回收器）：<code>-XX:+PrintCommandLineFlags</code> </li>
<li>  使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code> </li>
</ul>
<hr>
<h2 id="4-Serial-收集器：串行回收"><a href="#4-Serial-收集器：串行回收" class="headerlink" title="4    Serial 收集器：串行回收"></a>4    Serial 收集器：串行回收</h2><ul>
<li><p>  Serial 收集器是最基本、历史最悠久的垃圾回收器。在 HotSpot 在 JDK3 之前回收新生代唯一的选择。</p>
</li>
<li><p>  Serial 收集器是一个单线程工作的串行收集器。是 HotSpot 中 Client 模式下默认的新生代垃圾回收器。</p>
</li>
<li><p>  <strong>Serial 垃圾回收器采用复制算法、串行回收和“Stop The World”机制的方式执行内存回收。</strong></p>
</li>
<li><p>除了年轻代之外，Serial 收集器还提供了用于执行老年代垃圾回收的 Serial Old 垃圾回收器。<strong>Serial Old 回收器同样采用了串行回收和“Stop The World”机制，但是内存回收算法使用的是标记-压缩算法。</strong></p>
<ul>
<li>  Serial Old 是运行在 Client 模式下默认的老年代垃圾回收器。</li>
<li>  Serial Old 在 Server 模式下主要有两个用途：①与新生代的 Parallel Scavenge 垃圾回收器配合使用    ②作为老年代的 CMS 垃圾回收器的备选垃圾回收器。</li>
</ul>
</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624113654891-30ee59bc-ff69-4073-b21f-70e640fa3240.png" alt="Serial_SerialOld垃圾回收器.png"></p>
<p>Serial 是一个单线程的独占式垃圾回收器。①“单线程”是指在进行垃圾收集时只会使用一个垃圾回收线程去完成垃圾收集的工作。  ②“独占式”是指在进行垃圾收集时，必须暂停其它所有的用户线程，直至垃圾收集工作结束。</p>
<ul>
<li>  优势：简单高效（与其它垃圾回收器在单线程下的运行效率相比）。对于限定单个 CPU 的环境来说，Serial 由于没有多个线程间交互的开销，专心做垃圾回收自然可以获得最高的单线程回收效率。</li>
<li>  在用户的桌面应用场景中，可用内存一般不大（几十MB到一俩百MB），可以在较短的时间内完成垃圾回收，只要不频繁发生，使用串行回收器是可以接受的。</li>
<li>  在 HotSpot 虚拟机中，使用 <code>-XX:+UserSerialGC</code> 参数可以指定年轻代和老年代都使用串行垃圾回收器。（新生代使用 Serial GC，且老年代使用 Serial Old GC）</li>
</ul>
<blockquote>
<p>  <strong>总结</strong></p>
</blockquote>
<ul>
<li>  目前已经很少使用串行垃圾回收器了，而且限定在单核 CPU 才可以使用。现在的处理器大都不是单核了。</li>
<li>  对于<strong>强交互</strong>较的应用而言，这种垃圾回收器是不能接受的。一般在 JavaWeb 应用程序中是不会采用串行垃圾回收器的。</li>
</ul>
<hr>
<h2 id="5-ParNew-收集器：并行回收"><a href="#5-ParNew-收集器：并行回收" class="headerlink" title="5    ParNew 收集器：并行回收"></a>5    ParNew 收集器：并行回收</h2><blockquote>
<p>  <strong>ParNew；Parallel New；Par 是 Parallel 的缩写，New 代表回收的内存区域是新生代。</strong></p>
</blockquote>
<ul>
<li>  如果说 Serial 是针对新生代的单线程垃圾回收器，那么 ParNew 则是 Serial 收集器的多线程版本。ParNew 除了采用并行方式执行内存回收外，两款垃圾回收器几乎没有任何区别。ParNew 在新生代中同样也是采用复制算法、STW机制。</li>
<li>  ParNew 是很多虚拟机 Server 模式下默认的新生代的垃圾收集器。 </li>
<li>  除了 Serial 外，目前只有 ParNew 能与 CMS 配合工作。</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624113581528-c91f6b00-e722-4053-8de0-a3f2fed6c96f.png" alt="ParNew_SerialOld垃圾回收器.png"></p>
<ul>
<li>  对于新生代，回收次数频繁，使用并行方式高效</li>
<li>  对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<blockquote>
<p>  <strong>问题：由于 ParNew 回收器是并行收集的，那么是否可以断定 ParNew 回收器的回收效率在任何情况下都会比 Serial 回收器更高效？</strong></p>
</blockquote>
<ul>
<li><p>  在多 CPU 的环境下，ParNew 收集器可以充分利用多 CPU、多核心等物理硬件的资源优势，可以更快速地完成垃圾回收，提升程序的吞吐量。</p>
</li>
<li><p>但是在单 CPU 的环境下，Serial 比 ParNew 更高效，虽然 Serial 是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效的避免多线程交互过程中产生的一些额外开销。</p>
<p>  ​    <em>在单 CPU 环境下，Serial 只会产生一个线程，该线程对 CPU 的利用率可以达到很高甚至 100%；若采用 ParNew（假设有 4 个 GC 线程），每个 GC 线程只能占 &lt;25% 的CPU性能，因为还要留一部分性能用于完成线程间的切换。</em></p>
</li>
</ul>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li>  在程序中，开发人员可以通过参数 <code>-XX:+UseParNewGC</code>手动指定使用 ParNew 执行内存回收任务。它表示新生代使用并行收集器，不影响老年代（老年代需单独设置）</li>
<li>  由于 ParNew 是一个并行的垃圾回收器，所以还可以额外指定线程数量，参数为：<code>-XX:ParallelGCThreads 线程数量</code> ，默认开启和服务器 CPU 数相同的线程数。</li>
<li>  如一台 8 核的服务器，默认开始 8 个线程效率最高，每个核心分配一个线程，若线程数高于核心数，则还涉及到多个线程抢占 CPU 的消耗，单个 CPU 内多个线程间切换的消耗。</li>
</ul>
<hr>
<h2 id="6-Parallel-Scavenge-收集器：吞吐量优先"><a href="#6-Parallel-Scavenge-收集器：吞吐量优先" class="headerlink" title="6    Parallel Scavenge 收集器：吞吐量优先"></a>6    Parallel Scavenge 收集器：吞吐量优先</h2><p>HotSpot 的新生代中除了可以使用 ParNew 外，还可以使用 Parallel_Scavenge。Parallel_Scavenge 同样也采用了<strong>复制算法</strong>、<strong>并行回收</strong>和“<strong>Stop The World</strong>”机制。</p>
<blockquote>
<p>  <strong>问题：既然 ParNew 和 Parallel_Scavenge 效率相仿，作用区域相同，那么 Parallel_Scavenge 是否还有必要出现呢？</strong></p>
</blockquote>
<ul>
<li>  和 ParNew 不同，Parallel Scavenge 回收器的目标是<strong>达到一个可控制的吞吐量</strong>。它也被称为<strong>吞吐量优先</strong>的垃圾收集器。</li>
<li>  自适应调节策略也是 Parallel Scavenge 和 ParNew 的一个重要区别。</li>
</ul>
<p><strong>应用场景不同</strong></p>
<ul>
<li>  停顿时间越短就越适合需要频繁与用户交互或者需要保证服务器响应速度的程序，良好的响应速度提升用户体验；</li>
<li>  而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</li>
</ul>
<p>​    Parallel Scavenge 在 JDK1.6 时提供了用于执行老年代垃圾回收的 Parallel Old 垃圾回收器，用来代替老年代原先的 Serial Old 回收器。Parallel Scavenge 多用于服务器环境中，而服务器环境大多性能较好（多为多核 CPU），使用 Serial Old 串行回收显然很浪费服务器的性能，所以在 JDK1.6 中新增了 Parallel_Old 回收器用于并行回收老年代内存空间。Parallel_Old 采用了<strong>标记-压缩算法</strong>，<strong>并行回收</strong>和“<strong>Stop-The-World</strong>”机制。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624120059763-c41b9104-37a5-44c0-b314-1fbd8d5d16ba.png" alt="Parallel Scavenge_Parallel Old垃圾回收器.png"></p>
<ul>
<li>  在要求程序吞吐量优先的应用场景中，Parallel Scavenge 和 Parallel Old 的组合，在 Server 模式下内存回收性能很不错。</li>
<li>  在 Java8 中，默认是此垃圾回收器。（Parallel Scavenge + Parallel Old）</li>
</ul>
<h3 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li><p>  <code>-XX:+UseParallelGC</code> ：手动指定新生代使用 Parallel Scavenge 执行内存回收任务。</p>
</li>
<li><p><code>-XX:+UseParallelOldGC</code> ：手动指定老年代使用 Parallel Old 执行内存回收任务。</p>
<blockquote>
<ul>
<li>  以上 2 个参数分别适用于新生代和老年代，JDK8 中默认是开启的。</li>
<li>  以上 2 个参数，如果开启一个，则另一个就会被自动开启（互相激活，互相绑定）。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>-XX:ParallelGCThreads</code> ：设置新生代并行回收器的线程数。最好设置与 CPU 数量相等，以避免过多的线程数影响垃圾回收性能。</p>
<blockquote>
<ul>
<li>  默认情况下，当 CPU 数量小于等于 8 个，ParallelGCThreads 的值等于 CPU 数量。</li>
<li>  当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 <code>3+[5*CPU_Count]/8</code> 。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>-XX:MaxGCPauseMillis</code> ：设置垃圾回收的最大停顿时间，即 STW 的时间。单位：ms</p>
<blockquote>
<ul>
<li>  为了尽可能地把 STW 时间控制在 MaxGCPauseMillis 以内，垃圾回收器在工作时会调整 Java 堆大小或者其它一些参数。</li>
<li>  对于用户来讲，停顿时间越短体验越好。但是在服务器端，整体的吞吐量越高越好，所以服务器端适合使用 Parallel Scavenge 进行垃圾回收。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>-XX:GCTimeRatio</code> ：设置衡量吞吐量的大小。</p>
<blockquote>
<ul>
<li>  吞吐量范围（0，100）。默认值是 99，也就是说垃圾回收的时间不超过 1%。</li>
<li>  与前一个 <code>MaxGCPauseMillis</code> 参数有一定的冲突，暂停时间越长， <code>GCTimeRatio</code> 参数就越容易超过设定的比例。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>-XX:+UseAdaptiveSizePolicy</code> ：设置 Parallel Scavenge 具有自适应调节策略。</p>
<blockquote>
<ul>
<li>  在自适应调节模式下，新生代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大、吞吐量和停顿时间之间的平衡点。</li>
<li>  在手动调优比较困难的情况下，可以直接使用这种自适应的方式。只需要指定虚拟机的最大堆、目标吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），就可以让虚拟机自己完成调优工作。</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h2 id="7-CMS-收集器：低延迟"><a href="#7-CMS-收集器：低延迟" class="headerlink" title="7    CMS 收集器：低延迟"></a>7    CMS 收集器：低延迟</h2><blockquote>
<p>  <strong>CMS（Concurrent-Mark-Sweep）；强交互；低延迟；单次STW间隔短</strong></p>
</blockquote>
<p>在 JDK1.5 中，HotSpot 推出了一款在<strong>强交互应用</strong>中几乎可认为有划时代意义的垃圾收集器：CMS，这款垃圾回收器是 HotSpot 中第一款真正意义上的<strong>并发收集器</strong>，它第一次实现了让垃圾回收线程与用户线程同时工作。</p>
<ul>
<li><p>  CMS 的目标是尽可能缩短垃圾收集时用户线程的单次停顿时间。单次停顿时间（延迟）越低就越适合与用户交互频繁的程序，良好的响应速度能提升用户体验。</p>
</li>
<li><p>  目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以带给用户更好的体验。CMS 就非常符合这类应用的需求。</p>
</li>
<li><p>  CMS 垃圾回收器采用了<strong>标记-清除算法</strong>（上面提到的几种垃圾收集器均采用的是标记-压缩算法），并且也会发生“Stop-The-World”。</p>
</li>
</ul>
<p>不幸的是，<strong>CMS 作为老年代的垃圾回收器</strong>，无法与 JDK1.4 中新增的新生代收集器 Parallel Scavenge 配合工作（底层的实现框架不兼容），所以在 JDK1.5 中使用 CMS 来回收老年代内存的时候，新生代只能选择 ParNew 或者 Serial 中的一个。在 G1 出现之间，CMS 的使用还是非常广泛的。直到今天，仍然有很多系统使用 CMS 垃圾回收器。</p>
<h3 id="CMS-工作过程"><a href="#CMS-工作过程" class="headerlink" title="CMS 工作过程"></a>CMS 工作过程</h3><p>CMS 垃圾回收的整个过程可分为 4 个阶段，包括：</p>
<ol>
<li> <strong>初始标记（Initial-Mark）</strong></li>
<li> <strong>并发标记（Concurrent-Mark）</strong></li>
<li> <strong>重新标记（Remark）</strong></li>
<li> <strong>并发清除（Concurrent-Sweep）</strong></li>
</ol>
<blockquote>
<ol>
<li> <strong>初始标记</strong></li>
</ol>
</blockquote>
<p>这个阶段的<strong>主要任务就是标记出 GC Roots 能直接关联到的对象</strong>。标记过程中垃圾收集线程是独占式的，所有用户线程都将会发生 STW，一旦标记完成之后就会恢复之前被暂停的所有用户线程。由于 GC_Roots 直接关联的对象比较少，所以此阶段暂停的时间非常短。</p>
<blockquote>
<ol start="2">
<li> <strong>并发标记</strong>：</li>
</ol>
</blockquote>
<p><strong>从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要暂停用户线程</strong>，可以与垃圾回收线程一起并发运行。</p>
<blockquote>
<ol start="3">
<li> <strong>重新标记</strong>：</li>
</ol>
</blockquote>
<p><strong>为了修正并发标记期间，因用户线程继续工作而导致标记产生变动的那一部分对象的标记记录</strong>，需要重新进行一次标记（CMS 使用增量更新）。这个阶段的停顿时间通常回比初始阶段稍长一些，但也远比并发标记阶段的时间要短。</p>
<blockquote>
<ol start="4">
<li> <strong>并发清除</strong>：</li>
</ol>
</blockquote>
<p><strong>清理掉标记阶段判定已死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发进行的</strong>（不需 要移动存活对象就意味着不会对现有的正在使用的对象作出任何改变，所以不会对运行着的程序产生任何影响。如果需要移动存活对象，则程序中所有使用到对象引用的地方（如局部变量表或方法区的静态变量）必然也要发生改变，这就会导致运行着的程序出错）。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/CMS%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="CMS 垃圾回收器"></p>
<blockquote>
<p>  <strong>CMS 会产生 STW 吗？</strong></p>
</blockquote>
<p>尽管 CMS 是一款并发式（非独占式）垃圾回收器，但是在其<strong>初始化标记和重新标记这两个阶段仍需要执行 STW 机制</strong>暂停所有用户线程，不过暂停时间并不会太长。可以说目前所有的垃圾回收器都做不到完全不需要“Stop-The-World”，只能是尽可能地缩短暂停时间。 </p>
<blockquote>
<p>  <strong>为什么需要重新标记？</strong></p>
</blockquote>
<ul>
<li>  只要用户线程和垃圾回收线程并发执行，那么就不可避免地会出现：①产生新的垃圾对象    ②将未死亡的对象回收。</li>
<li>  前者还是可以接受的，只不过是产生了一些浮动垃圾而已，而后者则可能会直接导致程序崩溃，所以是一定要避免的。</li>
<li>  这样就还需要重新进行垃圾标记，所以说不可能完全消除“Stop-The-World”。*</li>
</ul>
<blockquote>
<p>  <strong>CMS 的停顿时间长吗？</strong></p>
</blockquote>
<ul>
<li>  由于最耗时的并发标记（遍历 GC_ROOTS 关联的所有对象）与并发清除阶段都不需要暂停用户线程，所以整体的回收过程还是低停顿的。</li>
</ul>
<blockquote>
<p>  <strong>CMS 需要预留一定的老年代空间用于保存并发的用户线程创建的新的对象</strong></p>
</blockquote>
<ul>
<li><p>  另外，由于在垃圾回收阶段用户线程没有中断，所以<strong>在 CMS 回收过程中，还应确保应用程序的用户线程有足够的内存可用</strong>。</p>
</li>
<li><p>  因此，CMS 不能像其它垃圾回收器那样等到老年代几乎完全被填满了再进行回收，而是<strong>当堆内存使用率达到一定阈值时，便开始进行垃圾回收</strong>，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。</p>
</li>
<li><p>要是 CMS 运行期间预留的内存无法满足程序需要，就会出现“<strong>Concurrent Mode Failure</strong>”失败，这时虚拟机将启动后备方案：临时启用 Serial Old 收集器来重新进行老年代的垃圾回收，这时停顿时间就会很长了。</p>
<p>  ​    <em>提前进行垃圾收集是所有的并发垃圾收集器的一个通病。因为并发过程中用户线程会和垃圾收集线程同时执行，那么就存在这样一种情况：用户线程消耗内存的速度远快于垃圾收集线程回收内存的速度。这种情况下，如果垃圾收集器每次都等到可用内存不足时再进行垃圾收集，那么将极有可能出现内存溢出的情况，这时程序就会报“<strong>Concurrent Mode Failure</strong>” 错误。对于 CMS 如果出现该错误，虚拟机将启用 Serial Old 回收器作为后备方案。</em></p>
<p>  ​    <em>而对于并行/串行的回收器，在执行垃圾回收的时候会完全暂停用户线程，只允许垃圾回收线程工作，即用户线程在垃圾回收的过程中不会产生新的垃圾，所以可以在可用内存不足时再启动垃圾回收。</em></p>
</li>
</ul>
<blockquote>
<p>  <strong>CMS在垃圾收集后使用空闲列表为新对象进行内存分配</strong></p>
</blockquote>
<p>CMS 采用的垃圾收集算法是<strong>标记-清除</strong>算法，这意味着每次执行完内存回收后，不可避免的会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞技术（Bump the Point），而只能够使用空闲列表（Free List）进行内存分配。</p>
<blockquote>
<p>  <strong>问题：CMS 为什么使用标记-清除算法而不使用标记-压缩算法？</strong></p>
</blockquote>
<ul>
<li>  <strong>移动对象与并发是矛盾的。</strong></li>
</ul>
<p>CMS 在标记完可回收对象后，清除阶段的是并发执行的，如果采用标记-压缩算法，将会改变内存中存活对象的内存地址，也就是说所有使用到该对象引用的地方都需要被更新，而在一个运行着的程序中显然是不可能完成的，这就会导致程序执行失败。而采用标记-清除算法，只会清除已死亡对象的内存，而不会对存活对象的内存地址产生任何影响，其运行资源不会收到任何影响，不会影响正在执行的程序。Mark-Compact 更适合“Stop_The_World”这种场景下使用，即暂停用户线程，等所有内存重新分配、赋值后再启动用户线程让其继续执行。</p>
<h3 id="CMS-优缺点"><a href="#CMS-优缺点" class="headerlink" title="CMS 优缺点"></a>CMS 优缺点</h3><blockquote>
<p>  <strong>优点：</strong></p>
</blockquote>
<ul>
<li>  并发回收</li>
<li>  低延迟</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong></p>
</blockquote>
<ol>
<li> <strong>会产生内存碎片</strong>。这会导致并发清除后，用户线程的可用连续空间不足，在碰到需要给大对象分配内存时，无法完成任务。在这种情况下，会提前触发下一次的 Full GC。</li>
<li> <strong>CMS 对 CPU 资源非常敏感</strong>。事实上，面向并发设计的收集器对处理器的资源都比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢（垃圾收集线程占用了用户线程的资源），总吞吐量降低。</li>
<li> <strong>CMS 无法处理浮动垃圾</strong>。可能出现“Concurrent Mode Failure”失败而导致下一次 Full GC 的产生。在 CMS 的并发标记和并发清理阶段，由于程序的用户线程和垃圾回收线程是同时运行或交叉运行的，那么<strong>在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记（因为标记的对象是某一时刻内存的一个快照），最终会导致这些新产生的垃圾对象不能被及时回收</strong>，只能等到下一次 GC 时释放这些垃圾对象的内存空间。</li>
</ol>
<h3 id="CMS-参数设置"><a href="#CMS-参数设置" class="headerlink" title="CMS 参数设置"></a>CMS 参数设置</h3><ul>
<li><p><code>-XX:+UseConcMarkSweepGC</code> ：显式地设置使用 CMS 垃圾回收器执行内存回收任务。</p>
<blockquote>
<ul>
<li>  启用该参数后会自动设置新生代的垃圾回收器为 ParNew ，等价于 <code>-XX:+UseParNewGC</code> 。即：ParNew（新生代）+CMS/Serial Old（老年代） 的组合。</li>
</ul>
</blockquote>
</li>
<li><p><code>-XX:CMSInitiatingOccupanyFraction</code> ：设置堆内存使用率的阈值。一旦达到该阈值，便开始进行回收。</p>
<blockquote>
<ul>
<li>  JDK1.6 之前默认值为 68，即当老年代的空间使用率达到 68% 时，就会触发一次 CMS 回收。<strong>从 JDK1.6 开始这个默认值变成了 92</strong>。</li>
<li>  如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 GC 的触发频率，减少老年代回收的次数，改善应用程序的性能。反之，如果应用程序内存使用率增长很快（大于垃圾回收的速度），则应该降低这个阈值，以避免频繁触发老年代的串行收集器。因此<strong>通过该参数可以有效降低 Full GC 的执行次数</strong>。</li>
</ul>
</blockquote>
</li>
<li><p>  <code>-XX:+UseCMSCompactAtFullCollection</code> ：用于指定在执行完 Full GC 后对内存空间进行空间压缩整理，以避免内存碎片的产生。不过由于内存压缩整理无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li><p>  <code>-XX:CMSFullGCsBeforeCompaction</code> ：设置在执行多少次 Full GC 后对内存空间进行压缩整理。</p>
</li>
<li><p><code>-XX:ParallelCMSThreads</code> ：设置 CMS 的线程数量。（垃圾回收线程的数量）</p>
<blockquote>
<ul>
<li>  CMS 默认启动的线程数量是： <code>(ParallelGCThreads + 3) / 4</code> 。ParallelGCThreads 是新生代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。（垃圾回收线程抢占了用户线程的资源）</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>  <strong>Serial GC 、Parallel GC 、Concurrent Mark Sweep GC 这三个 GC 有什么不同呢？</strong></p>
</blockquote>
<ul>
<li>  如果想要最小化地使用内存和并行开销，选择 Serial GC；</li>
<li>  如果想要最大化应用程序的吞吐量，选择 Parallel GC；</li>
<li>  如果想要最小化 GC 的停顿时间，选择 CMS GC</li>
</ul>
<ul>
<li>  JDK9 新特性：CMS 被标记为 Deprecate 了（废弃了）</li>
<li>  JDK14 新特性：删除了 CMS 垃圾回收器</li>
</ul>
<hr>
<h2 id="8-G1-回收器：区域化分代式"><a href="#8-G1-回收器：区域化分代式" class="headerlink" title="8    G1 回收器：区域化分代式"></a>8    G1 回收器：区域化分代式</h2><blockquote>
<p>  <strong>Garbage First；G1</strong></p>
<p>  <strong>回收集；Collection_Set；CSet</strong></p>
</blockquote>
<p>随着应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有垃圾回收机制就不能保证应用程序正常进行，而经常造成 STW 的垃圾收集器又跟不上实际的需求，所以才会不断地尝试对垃圾收集器进行优化。</p>
<p>G1（Garbage First）垃圾回收器是在 Java7 之后引入的一个新的垃圾回收器，是当今收集技术发展的最前沿的成果之一。</p>
<p>G1 收集器开创了面向局部收集的设计思路和基于 Region 的内存布局形式。被 Oracle 官方称为“全功能的垃圾收集器”。</p>
<blockquote>
<p>  <strong>问题：什么是面向局部的设计思路？</strong></p>
</blockquote>
<p>在 G1 收集器出现之前所有的其它收集器，垃圾收集的目标范围要么是整个新生代，要么是整个老年代，要么就是整个 Java 堆。而 G1 跳出了这个樊笼，它可以面向堆的任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是 G1 收集器的 Mixed_GC 模式。</p>
<blockquote>
<p>  <strong>问题：什么是基于 Region 的内存布局形式？</strong></p>
</blockquote>
<p>G1 开创性的使用了基于 Region 的内存布局，虽然它也是遵循分代收集理论设计的，但其堆内存布局与其它收集器有非常明显的差异：</p>
<ul>
<li>  G1 不再坚持固定大小及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 根据需要，可以是 Eden 区空间、Survivor 区空间、或者是老年代空间。收集器能够对不同角色的 Region 采用不同的策略去处理。  </li>
<li>  虽然 G1 仍然保留新生代和老年代的概念，但新生代和老年代的概念不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。</li>
<li>  G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量。</li>
<li>  G1 是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器。能以极高概率满足停顿时间的同时，还兼具高吞吐量的性能特征。</li>
<li>  G1 作为 CMS 收集器的替代者和继承人，设计者希望能做出一款能够建立起“<strong>停顿时间模型</strong>”的收集器。停顿时间模型是指：能够实现<strong>在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间大概率不会超过 N 毫秒</strong>这样的目标。</li>
</ul>
<blockquote>
<p>  <strong>问题：G1 收集器如何实现“停顿时间模型”？</strong></p>
</blockquote>
<ul>
<li>  首先要明确，能够以极高的概率满足指定停顿时间，并不等价于能 100% 满足指定停顿时间。也就是说假如设置停顿时间为 10ms ，那么大部分情况下都会 <code>&lt;=10ms</code>，但是不排除有超过 10ms 的情况。</li>
<li>  G1 之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次收集到的内存空间都是 Region 大小的整数倍。这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。更具体的思路是让 G1 收集器去跟踪各个 Region 里面的 Region 的垃圾堆积的“价值”大小，然后在后台维护一个优先级列表，每次根据用户设定的允许收集停顿时间优先处理回收价值收益最大的那些 Region。这种使用 Region 划分内存空间，以及优先回收价值高的 Region 的回收方式，保证了 G1 收集器在有限的时间内可以获得尽可能高的收集效率。</li>
<li>  那么 G1 如何实现低停顿时间呢？就是通过控制每次回收的 Region 数量来控制停顿时间，Region 数量越多，回收的内存就越大，停顿时间自然也就越长。</li>
</ul>
<blockquote>
<p>  <strong>问题：该垃圾收集器为什么叫做 Garbage First（G1）呢？</strong></p>
</blockquote>
<ul>
<li>  Garbage_First 中的 First 是第一的意思，这就暗示了 G1 收集器是具有优先级的。</li>
<li>  因为 G1 是一个并行垃圾回收器，它把堆内存分割成很多不相关的区域（Region），这些区域在物理上是不连续的。使用不同的 Region 来表示 Eden区、Survivor区、老年代等。</li>
<li>  G1 GC 有计划的避免在整个 Java 堆中进行全区域的垃圾回收。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收可获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的回收时间，优先回收价值最大的 Region</strong>。</li>
<li>  G1 垃圾回收的侧重点在于回收垃圾最大量的区间（Region）。所以我们将其命名为：Garbage First，垃圾优先。</li>
</ul>
<p>G1 在 JDK7 中被加入，在 JDK9 中被设为默认，移除了 Experimental 的标识，是 JDK9 之后的默认垃圾回收器。与此同时，CMS 在 JDK9 中被标记为废弃（deprecated）。在 JDK9 之前若想使用 G1 ，需要使用 <code>-XX:+UserG1GC</code> 来显式地启用。</p>
<h3 id="G1-的特点"><a href="#G1-的特点" class="headerlink" title="G1 的特点"></a>G1 的特点</h3><p>与其它垃圾回收器相比，G1 使用了全新的分区算法，其特点如下：</p>
<ul>
<li><p><strong>兼具并行与并发</strong></p>
<ul>
<li>  并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程停顿（STW）。</li>
<li>  并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行。因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li>
</ul>
</li>
<li><p><strong>分代收集</strong></p>
<ul>
<li>  从分代上看，G1 仍属于分代型垃圾回收器，它会区分新生代和老年代，新生代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、新生代或者老年代是连续的，也不在坚持固定大小和固定数量。</li>
<li>  <strong>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</strong>。</li>
<li>  和之前的几种垃圾回收器不同，G1 同时<strong>兼顾新生代和老年代</strong>。对比其它回收器，或者服务于新生代，或者服务于老年代。</li>
</ul>
</li>
<li><p><strong>空间整合</strong></p>
<ul>
<li><p>  CMS：采用“标记-清除”算法，存在内存碎片，并在若干次 GC 后进行一次碎片整理</p>
</li>
<li><p>G1 将内存划分为一个个的 Region，内存的回收可以是以 Region 作为基本单位的。<strong>Region块之间采用复制算法，整体结构上采用标记-压缩算法（Mark-Compact）</strong>，两种算法都可以避免产生内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续的内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</p>
<blockquote>
<p>  如何理解“Region 之间采用复制算法，整体采用标记-压缩算法”？ </p>
<ul>
<li>  G1 垃圾回收器的基本单位是 Region，在 Region 级别，回收的时候会将内存中存活的对象移动到另一个空闲的 Region 中去。但是从整体内存考虑，每次回收后产生的空闲 Region 都会有序地放在整体内存的一端。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>可预测的停顿时间模型</strong>（即：软实时soft real-time）</p>
<ul>
<li>  这是 G1 相较于 CMS 的另一大的优势。G1 除了追求低停顿时间外，还能建立可预测的时间停顿模型，能让使用者明确指定<strong>在一个长度为 M 毫秒的时间片段内，消耗在垃圾回收上的时间不得超过 N 毫秒</strong>。  </li>
<li>  由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿的时间也能得到较好的控制。</li>
<li>  G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收可获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的回收时间，优先回收价值最大的 Region</strong>。保证了 G1 <strong>在有限的时间内可以获取尽可能高的回收效率</strong>。</li>
<li>  相较于 CMS，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<blockquote>
<ul>
<li>  实时：规定了10ms，就一定要在10ms以内完成垃圾的收集。 </li>
<li>  软实时：规定了10ms，就尽可能地在10ms以内完成垃圾的回收，但允许出现例外。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>相较于 CMS，G1 还不具备全方位、压倒性的优势。比如在用户线程运行过程中，G1 无论是为了垃圾回收产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 高。</p>
<p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则优势更大。平衡点在 6~8GB 之间。</p>
<h3 id="G1-参数设置"><a href="#G1-参数设置" class="headerlink" title="G1 参数设置"></a>G1 参数设置</h3><ul>
<li>  <code>-XX:+UseG1GC</code> ：显式指定使用 G1 垃圾回收器。 </li>
<li>  <code>-XX:G1HeapRegionSize</code> ：设置每个 Region 的大小。值只能是2的次幂（如 1，2，4，8，…），范围是 1MB~32MB 之间，目标是根据最小的 Java 堆大小分出约 2048 个区域，默认是堆内存的 1/2000 。</li>
<li>  <code>-XX:MaxGCPauseMillis</code> ：设置期望达到的最大 GC 停顿时间（JVM 会尽力实现，但不保证实现）。默认值是 200ms 。</li>
<li>  <code>-XX:ParallelGCThreads</code> ：设置 STW 时垃圾回收线程的数量。最多设置为 8。（G1 可以并行，也可以并发）</li>
<li>  <code>-XX:ConcGCThreads</code> ：设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li>
<li>  <code>-XX:InitiatingHeapOccupancyPercent</code> ：设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li>
</ul>
<h3 id="如何使用-G1"><a href="#如何使用-G1" class="headerlink" title="如何使用 G1"></a>如何使用 G1</h3><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需简单的三步即可完成调优。</p>
<ul>
<li>  第一步：启用 G1 垃圾回收器</li>
<li>  第二步：设置堆的最大内存</li>
<li>  第三步：设置最大停顿时间</li>
</ul>
<p>G1 提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p>
<h3 id="G1-的适用场景"><a href="#G1-的适用场景" class="headerlink" title="G1 的适用场景"></a>G1 的适用场景</h3><ul>
<li>  面向服务端的应用，针对具有大内存、多处理器的机器。（在普通大小的堆中表现并不惊喜）</li>
<li>  应用需要低 GC 延迟，并且具有大堆</li>
</ul>
<ul>
<li>  <strong>HotSpot 的垃圾回收器里，除了 G1 以外，其它的垃圾回收器执行内存回收时都需要使用专门的垃圾回收线程进行回收操作，而 G1 在回收内存时还可以采用用户线程来执行 GC 任务</strong>。当 JVM 的 GC 线程处理速度过慢时，系统就会调用用户线程帮助加速垃圾回收的过程。</li>
</ul>
<hr>
<h3 id="分区-Region：化整为零"><a href="#分区-Region：化整为零" class="headerlink" title="分区 Region：化整为零"></a>分区 Region：化整为零</h3><p>使用 G1 垃圾回收器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块的大小根据堆空间的实际大小而定，整体控制在 1MB~32MB 之间，且每块的大小只能为 2 的 N 次幂，即 1MB，2MB，8MB，16MB，32MB。可通过 <code>-XX:G1HeapRegionSize</code> 手动设置块内存的大小。所有的 Region 大小相同，且在 JVM 声明周期内不会被改变。</p>
<p>虽然还保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了（逻辑上隔离，物理上交叉），它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配实现逻辑上的连续。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624208032167-d3376a9c-fca8-4b7a-9df4-81c1b6cd08ec.png" alt="G1回收器.png"></p>
<p>一个 Region 有可能属于 Eden、Survivor 或者 Old 中的任一种。但是一个 Region 只能属于一个角色（一个 Region 中不能既存储新生代对象，又存储老年代对象）。每次内存被回收后空闲出来的 Region 下次充当的角色是随机的。</p>
<p>G1 还增加了一种新的内存区域 Humongous，主要用户存储大对象，如果超过 1.5 个 Region，就放到 Humongous 区。</p>
<ul>
<li>  <strong>设置</strong> <strong>Humongous 区的原因</strong> ：  </li>
</ul>
<p>对于堆中的大对象，默认直接会分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾回收器造成负面影响（因为老年代回收频率低，所以本来一个短期的对象就会在堆中存活很长时间）。为了解决这个问题，G1 专门划分了一个 Humongous 区，它专门用来存放大对象。如果一个 H 区装不下一个大对象，那么 G1 就会寻找连续的 H 区来存储。如果堆中最大的连续 H 区都存不下大对象，就会触发 Full GC 来创造出更大的 H 区。G1 的大多数行为都会把 H 区作为老年代的一部分来看待。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624208903694-2edead3f-d53b-4726-b0f3-a818d1a53400.png" alt="Region的指针碰撞.png"></p>
<ul>
<li>  一个 Region 中可以保存多个对象，每次有新对象加入时，使用“指针碰撞”的方法分配内存。（因为单个 Region 采用复制算法回收，内存规整）</li>
<li>  TLAB：针对某一个 Region，若有多个线程都需要使用，可以在 Region 中在进行细分，给每个线程分配 Region 中的一小块空间，提高分配对象的效率。</li>
</ul>
<h3 id="G1-垃圾回收过程"><a href="#G1-垃圾回收过程" class="headerlink" title="G1 垃圾回收过程"></a>G1 垃圾回收过程</h3><p>G1 的垃圾回收过程主要包括如下几个环节：</p>
<ul>
<li>  年轻代 GC（Young GC）</li>
<li>  老年代并发标记过程（Concurrent Marking）</li>
<li>  混合回收（Mixed GC）</li>
<li>  （如果有需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png" alt="G1垃圾回收过程"></p>
<p>顺时针，Young GC –&gt; Young GC + Concurrent Mark + Mixed GC 顺序，进行垃圾回收。</p>
<ol>
<li> 应用程序分配内存，<strong>当年轻代的 Eden 区用尽时开始新生代的回收过程</strong>：G1 的新生代回收阶段是一个<strong>并行</strong>的<strong>独占式</strong>回收器。在新生代回收期间，暂停所有的用户线程，启动多线程执行新生代的内存回收。然后<strong>从 Eden/from 区移动存活对象到 to 区或者老年代，也有可能两个区间都会涉及</strong>。</li>
<li> 当堆内存使用达到一定阈值（默认是 45%）时，开始老年代并发标记过程。</li>
<li> 标记完成后马上开始混合回收的过程。在混合回收期间，G1 从老年代移动存活对象到空闲 Region，这些空闲 Region 自然也就成为了新的老年代区间。和新生代不同，老年代的 G1 回收器和其它垃圾回收器不同，<strong>G1 的老年代垃圾回收器不需要整个老年代被回收，一次只需要回收一小部分老年代的 Region 就可以了</strong>。同时，这个老年代 Region 是和新生代一起被回收的。</li>
</ol>
<ul>
<li>  G1 垃圾回收的过程中每个阶段都有 Young GC 的参与，这也从一方面验证了新生代回收频繁，老年代回收不频繁这一特点。</li>
</ul>
<hr>
<h3 id="G1-垃圾回收过程：Remembered-Set"><a href="#G1-垃圾回收过程：Remembered-Set" class="headerlink" title="G1 垃圾回收过程：Remembered Set"></a>G1 垃圾回收过程：Remembered Set</h3><p><strong>一个对象被不同区域引用的问题：</strong></p>
<ul>
<li>  一个 Region 不可能是孤立的，一个 Region 中的对象有可能被其它 Region 中的对象引用，判断对象是否存活时，是否需要扫描整个 Java 堆才能保证准确？</li>
<li>在其它的分代垃圾回收器中，也存在这样的问题（而 G1 更加突出）。<ul>
<li>  回收新生代不得不同时扫描老年代？</li>
</ul>
</li>
<li>  <em>如果想要回收某个区域的对象，那么非这个区域的所有引用都可以作为 GC Roots。比如现在想要回收 Eden 区，但是老年代中可能存在对象引用了 Eden 区中的对象，那么就不得不全盘扫描整个堆空间。</em></li>
<li>  这样的话会降低 Minor GC 的效率？</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>  无论是 G1 还是其它分代垃圾回收器，JVM 都是采用<strong>记忆集（Remembered Set）</strong>来避免全局扫描。</li>
<li>  <strong>每个 Region 都有一个对应的 Remembered Set</strong>。</li>
<li>  每次 Reference 类型数据进行写操作时，都会产生一个<strong>写屏障（Write Barrier）</strong>暂时中断操作；</li>
<li>  然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其它垃圾回收器：检查老年代对象是否引用了新生代对象）；</li>
<li>  如果不同，通过 CardTable 把相关引用信息记录到引用指向对象所在 Region 对应的 Remembered Set 中；</li>
<li>  当进行垃圾回收时，在 GC Roots 的枚举范围加入 Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624246838963-ac9f133c-0436-418b-9f8b-3ef5715c3838.png" alt="Remembered Set.png"></p>
<p>在 Region2 中给新对象分配内存，并新建一个引用指向该对象。每次新添加引用时，会先暂停，检查这个引用发起的对象来自当前 Region 还是其它 Region。如果是当前 Region，则不做任何处理，因为 G1 是按照 Region 为基本单位进行回收的；如果来自其它 Region，则在 Region2 维护的 Remembered Set 中记录引用发起对象的地址。之后在进行垃圾收集时，就无需再进行全局扫描，只需在 GC Roots 的基础上，加上要回收的 Region 对应的 Remembered Set 中关联的对象，就可以保证不会有遗漏。 </p>
<p>Remembered Set 中记录哪些地址引用了 Region 中的对象。</p>
<hr>
<h3 id="G1-回收过程"><a href="#G1-回收过程" class="headerlink" title="G1 回收过程"></a>G1 回收过程</h3><h4 id="一、新生代-GC"><a href="#一、新生代-GC" class="headerlink" title="一、新生代 GC"></a>一、新生代 GC</h4><p>程序在运行过程中会不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次新生代垃圾回收的过程（Survivor 区满的时候不会触发 YGC）。</p>
<p>新生代的垃圾回收只回收 Eden 区和 Survivor 区。</p>
<p>YGC 时，G1 首先会暂停所有用户线程（STW）（独占式的），G1 创建回收集（Collection Set），回收集就是需要被回收的 Region 的集合，新生代回收过程的回收集包括 Eden 区和 Survivor 区所有的 Region。</p>
<ul>
<li><p>  <strong>第一阶段：扫描GC_Roots（GC_Roots 中包含了 RSet）</strong></p>
</li>
<li><p><strong>第二阶段：更新 RSet</strong></p>
<ul>
<li><p>  处理“脏卡表（dirty card queue）”中的 card，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代 Region 对新生代 Region 中对象的引用。</p>
</li>
<li><p>  对于应用程序的引用赋值语句 <code>object.field = object</code> ，JVM 会在之前和之后执行特殊的操作以在 dirty card queue 中入队一个保存了对象引用信息的 card。在新生代回收的时候，G1 会对 Dirty Card Queue 中所有的 card 进行处理，以更新 RSet，保证 RSet 实时准确地反映引用关系。</p>
</li>
<li><p>  那么为什么不在引用赋值语句处直接更新 RSet 呢？这是处于性能优化的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多</p>
</li>
</ul>
</li>
<li><p><strong>第三阶段：处理 RSet</strong></p>
<ul>
<li>  识别被老年代对象指向的 Eden 中的指针，这些被指向的 Eden 中的对象被认为是存活的对象。</li>
</ul>
</li>
<li><p><strong>第四阶段：复制对象</strong></p>
<ul>
<li>  此阶段，对象树被遍历，Eden 中存活的对象会被复制到 Survivor 中的 to 区；Survivor 中存活的对象如果年龄未达到阈值，年龄+1，达到阈值的对象会被复制到老年代中空的 Region。如果 Survivor 空间不够，Eden 中的部分对象会直接晋升到老年代空间。</li>
</ul>
</li>
<li><p><strong>第五阶段：处理引用</strong></p>
<ul>
<li>  当内存不足时，进行垃圾回收的之后还会处理非强引用的引用关系。如处理 Soft、Weak、Phantom、Final、JNI Weak 等引用。最终 Eden 中的数据为空，GC 停止工作，并且目标内存中的对象都是连续存储的，没有内存碎片。所以复制过程可以达到内存整理的效果，减少内存碎片。</li>
</ul>
</li>
</ul>
<h4 id="二、并发标记过程"><a href="#二、并发标记过程" class="headerlink" title="二、并发标记过程"></a>二、并发标记过程</h4><ul>
<li><p><strong>第一阶段：初始标记阶段</strong></p>
<ul>
<li>  标记根节点的<strong>直接</strong>可达对象。这个阶段是独占式的（会触发 STW），并且会触发一次 YGC。</li>
</ul>
</li>
<li><p><strong>第二阶段：根区域扫描（Root Region Scanning）</strong></p>
<ul>
<li>  扫描 Survivor 区直接可达的老年代区域对象（在第一阶段触发 YGC 后所有的存活对象都会被复制到 Survivor（to）区），并标记被引用的对象。这一过程必须在 YGC 之前完成（因为 YGC 会改变 Survivor 区对象在内存中的位置）。</li>
</ul>
</li>
<li><p><strong>第三阶段：并发标记（Concurrent Marking）</strong></p>
<ul>
<li>  在整个堆中进行并发标记（并发：垃圾收集线程和用户线程并发执行），此过程可能被 YGC 中断。<strong>在并发标记阶段，若发现某个 Region 中的所有对象都是垃圾对象，那么这个 Region 会被立即回收</strong>。同时，在并发标记的过程中，会计算每个区域的对象活性（区域中存活对象的比例）（计算不同 Region 回收的性价比）</li>
</ul>
</li>
<li><p><strong>第四阶段：再次标记</strong></p>
<ul>
<li>  由于在上一阶段“并发标记”过程中。用户线程也一直在同步运行，所以需要通过“再次标记”修正上一阶段的标记结果。这一阶段是独占式的（STW）。G1 采用了比 CMS 更快的初始快照算法：Snapshot-at-the-beginning（SATB）。</li>
</ul>
</li>
<li><p><strong>第五阶段：独占式清理</strong></p>
<ul>
<li>  统计各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域，为下一阶段做准备。是独占式的（STW）。</li>
<li>  这个阶段并不会实际上去做垃圾的回收。</li>
</ul>
</li>
<li><p><strong>第六阶段：并发清理阶段</strong>  </p>
<ul>
<li>  识别并清理完全空闲的区域。</li>
</ul>
</li>
</ul>
<h4 id="三、混合回收"><a href="#三、混合回收" class="headerlink" title="三、混合回收"></a>三、混合回收</h4><p>当越来越多的对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一种混合回收机制，即 Mixed_GC，该算法并不是一个 Old_GC，除了回收整个 Young_Region 之外，还会回收部分 Old_Region。</p>
<ul>
<li>  Tip1：是一部分老年代，而不是全部老年代。可以选择对哪些 Old_Region 进行回收，从而达到对 STW 时间的控制。</li>
<li>  Tip2：是 Mixed_GC，而不是 Full_GC。</li>
</ul>
<ul>
<li>  并发标记结束以后，老年代中全部是垃圾的 Region 被回收了，部分是垃圾的 Region 被标记了出来。默认情况下，老年代中这些被标记的 Region 会分 8 次被回收（根据优先级从高到低）（可以通过 <code>-XX:G1MixedGCCountTarget</code> 参数设置）</li>
<li>  混合回收的回收集（Collection Set）包括 1/8 的老年代 Region，Eden 区所有的 Region、Survivor（from）区的所有 Region。混合回收的算法和新生代的回收算法完全一样，只是回收集多了老年代的部分 Region。具体过程参考上面新生代回收过程。</li>
<li>  由于老年代 Region 默认分 8 次回收，G1 默认先回收垃圾多的 Region。垃圾占 Region 比例越高的，越会先被回收。并且有一个阈值会决定 Region 是否被回收。 <code>-XX:G1MixedGCLiveThresholdPercent</code> ，默认为 65%，意思是垃圾内存占 Region 比例要达到 65% 才会被回收。如果垃圾内存占比太低，意味着存活对象的占比高，在复制的时候会花费更多的时间。</li>
<li>  混合回收并不一定非要进行 8 次。有一个阈值 <code>-XX:G1HeapWastePercent</code> ，默认值为 10%，意思是允许整个堆内存中有 10% 的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例小于 10%，则无需进行混合回收，因为 GC 会花费很多时间但是回收到的内存却很少。</li>
</ul>
<h4 id="四、Full-GC"><a href="#四、Full-GC" class="headerlink" title="四、Full_GC"></a>四、Full_GC</h4><p>G1 的初衷就是要避免 Full_GC 的出现，但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop_The_World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序的暂停时间会很长。</p>
<p>要避免 Full_GC 的发生，一旦发生需要进行调整。什么时候会发生 Full_GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的 Region 可用，则会回退到 Full_GC，这种情况可以通过增大内存解决。</p>
<p>导致 Full_GC 的原因可能有两个：</p>
<ol>
<li> Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li>
<li> 并发处理过程完成之前内存耗尽。</li>
</ol>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>从 Oracle 官方透露出来的信息可知，回收阶段（Evacuation）其实本来也想过设计成与用户线程一起并发执行，但是这件事情做起来比较复杂，考虑到 G1 只是回收一部分的 Region，停顿时间是用户可控制的，所以并不迫切去实现，而是选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h4 id="G1-回收器优化建议"><a href="#G1-回收器优化建议" class="headerlink" title="G1 回收器优化建议"></a>G1 回收器优化建议</h4><ul>
<li><p>  新生代大小</p>
</li>
<li><ul>
<li>  避免使用 <code>-Xmn</code> 或 <code>-XX:NewRatio</code> 等相关选项显式设置新生代的大小。</li>
<li>  固定新生代的大小会覆盖暂停时间目标。</li>
</ul>
</li>
<li><p>  暂停时间目标不要太过严苛</p>
</li>
<li><ul>
<li>  G1 的吞吐量目标是 90% 的应用程序执行时间和 10% 的垃圾回收时间。</li>
<li>  评估 G1 GC 的吞吐量时，暂停时间不太严苛。目标太过严苛表示你愿意承担更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
</li>
</ul>
<h2 id="9-垃圾回收器总结"><a href="#9-垃圾回收器总结" class="headerlink" title="9    垃圾回收器总结"></a>9    垃圾回收器总结</h2><h3 id="7款经典垃圾回收器总结"><a href="#7款经典垃圾回收器总结" class="headerlink" title="7款经典垃圾回收器总结"></a>7款经典垃圾回收器总结</h3><table>
<thead>
<tr>
<th align="left">垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用的算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Serial</td>
<td>串行运行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="left">ParNew</td>
<td>并行运行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多 CPU 下的 Server 模式，<br>与 CMS 配合使用</td>
</tr>
<tr>
<td align="left">Parallel</td>
<td>并行运行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要<br>太多交互的场景</td>
</tr>
<tr>
<td align="left">Serial Old</td>
<td>串行运行</td>
<td>老年代</td>
<td>标记-压缩算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="left">Parallel Old</td>
<td>并行运行</td>
<td>老年代</td>
<td>标记-压缩算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要<br>太多交互的场景</td>
</tr>
<tr>
<td align="left">CMS</td>
<td>并发运行</td>
<td>老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>使用互联网或B/S服务</td>
</tr>
<tr>
<td align="left">G1</td>
<td>并发/并行运行</td>
<td>新生代+老年代</td>
<td>复制算法+标记-压缩算法</td>
<td>响应速度优先</td>
<td>面向服务端应用</td>
</tr>
</tbody></table>
<blockquote>
<p>  速记：</p>
<ul>
<li>  新生代全部使用<code>复制算法</code>。</li>
<li>  老年代只有 CMS 使用了 <code>标记-清除算法</code>，其余均为 <code>标记-压缩算法</code>。</li>
<li>  总结：只有 CMS 使用了<strong>标记-清除算法</strong>。</li>
</ul>
</blockquote>
<h3 id="怎样选择垃圾回收器"><a href="#怎样选择垃圾回收器" class="headerlink" title="怎样选择垃圾回收器"></a>怎样选择垃圾回收器</h3><p>Java 垃圾回收器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾回收器可以让 JVM 的性能有一个很大的提升。</p>
<p>怎样选择垃圾回收器？</p>
<ol>
<li><p> 优先调整堆的大小让 JVM 自适应完成。</p>
</li>
<li><p> 如果内存小于 100MB，使用串行的垃圾回收器。</p>
</li>
<li><p> 如果是单核、单机程序，并且没有停顿时间的要求，选择串行垃圾回收器</p>
</li>
<li><p> 如果是多 CPU、需要高吞吐量、允许停顿时间超过 1s ，选择并行回收器或让 JVM 自行选择。</p>
</li>
<li><p> 如果是多 CPU、追求低停顿时间，需要快速响应（比如延迟不能超过 1s，如互联网应用）。使用并发收集器。</p>
</li>
<li><p> 官方推荐使用 G1 收集器，性能较好。现在的互联网项目，基本都是使用 G1 。</p>
</li>
</ol>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><ul>
<li>  垃圾回收的算法有哪些？</li>
<li>  如何判断一个对象可回收？</li>
<li>  垃圾回收器工作的基本流程？</li>
</ul>
<h2 id="10-GC-日志分析"><a href="#10-GC-日志分析" class="headerlink" title="10    GC 日志分析"></a>10    GC 日志分析</h2><p>通过阅读 GC 日志，我们可以了解 Java 虚拟机内存分配与回收策略。</p>
<p>常见的参数设置：</p>
<ul>
<li>  <code>-XX:+PrintGC</code> ：输出 GC 日志</li>
<li>  <code>-XX:+PrintGCDetails</code> ：输出 GC 日志的详细信息</li>
<li>  <code>-XX:+PrintGCTimeStamps</code> ：输出 GC 的时间戳（以基准时间的形式）</li>
<li>  <code>-XX:+PrintGCDateStamps</code> ：输出 GC 的时间戳（以日期的形式，如 2021-06-20T18:45:32.234+0800）</li>
<li>  <code>-XX:+PrintHeapAtGC</code> ：在进行 GC 的前后打印出堆的信息</li>
<li>  <code>-Xloggc:../logs/gc.log</code> ：将日志文件输出到指定路径</li>
</ul>
<h2 id="10-垃圾回收器新发展"><a href="#10-垃圾回收器新发展" class="headerlink" title="10  垃圾回收器新发展"></a>10  垃圾回收器新发展</h2><p>垃圾回收器仍然处于飞速发展之中，目前的默认选项 G1 在不断的进行改进，很多我们原来认为的缺点。例如串行的 Full GC、Card Table 扫描的低效性等，都已经被大幅改进，例如，JDK10 之后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行实现。</p>
<p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关的数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<strong>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台</strong>。</p>
<p>比较不幸的是 CMS，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但是在 JDK9 中就已经被标记为废弃，并在 JDK14 中被完全移出。</p>
<h3 id="Open-JDK12-中的-Shenandoah-GC"><a href="#Open-JDK12-中的-Shenandoah-GC" class="headerlink" title="Open_JDK12 中的 Shenandoah_GC"></a>Open_JDK12 中的 Shenandoah_GC</h3><blockquote>
<p>  Open_JDK12 中的 Shenandoah_GC：低停顿时间的垃圾回收器（实验性）</p>
</blockquote>
<p>Shenandoah_GC 无疑众多 GC 中最孤独的一个。是第一款不由 Oracle 公司团队领导开发的 HotSpot 垃圾收集器，不可避免的受到官方的排挤。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司拒绝在 OracleJDK12 中支持 Shenandoah。</p>
<p>Shenandoah 垃圾回收器最初是由 RedHat 进行的一项垃圾回收器研究项目 Pauseless_GC 的实现。旨在针对 JVM 上的内存回收实现低停顿的需求。在 2014 年贡献给 OpenJDK。</p>
<p>Red_Hat 研发 Shenandoah 的团队对外<strong>宣称，****Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9% 的目标都可以把垃圾收集的停顿时间限制在 10ms 以内</strong>。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>  Shenandoah_GC 的弱项：高运行负载下的吞吐量下降</li>
<li>  Shenandoah_GC 的强项：低延迟时间</li>
</ul>
<h3 id="令人震惊、革命性的ZGC"><a href="#令人震惊、革命性的ZGC" class="headerlink" title="令人震惊、革命性的ZGC"></a>令人震惊、革命性的ZGC</h3><ul>
<li>  ZGC 与 Shenandoah 目标高度相似，<strong>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在 10ms 以内的低延迟</strong>。</li>
<li>  ZGC 是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记-压缩算法</strong>的，以<strong>低延迟为首要目标</strong>的一款垃圾收集器。</li>
<li>  ZGC 的工作过程可分为 4 个阶段：<strong>1、并发标记  2、并发预备重分配  3、并发重分配  4、并发重映射</strong></li>
<li>  ZGC 几乎在所有的地方都是并发执行的，除了<strong>初始标记是 STW 的</strong>。所以停顿时间几乎就耗费在初始标记上，这部分时间实际是非常少的。</li>
<li>  JDK15 将 ZGC 加入了生产环境。</li>
<li>  使用： <code>-XX:+UseZGC</code> </li>
</ul>
<h1 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h1><blockquote>
<p>  蚂蚁金服</p>
</blockquote>
<ol>
<li> 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms 和 g1</li>
<li> JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法</li>
<li> G1 回收器讲一下回收过程</li>
<li> GC 是什么？为什么要有 GC ？</li>
<li> GC 的两种判定方法？ CMS 收集器与 G1 收集器的特点？</li>
</ol>
<blockquote>
<p>  百度</p>
</blockquote>
<ol>
<li> 说一下GC算法？分代回收说一下？</li>
<li> 垃圾收集策略和算法？</li>
</ol>
<blockquote>
<p>  天猫</p>
</blockquote>
<ol>
<li> JVM GC 原理？JVM 怎么回收内存？</li>
<li> CMS 特点，垃圾收集算法有哪些？各自的优缺点，它们共同的缺点是什么？</li>
</ol>
<blockquote>
<p>  滴滴</p>
</blockquote>
<ol>
<li> Java的垃圾收集器有哪些？说一下 G1 的应用场景，平时你是如何搭配使用垃圾收集器的？</li>
</ol>
<blockquote>
<p>  京东</p>
</blockquote>
<ol>
<li> 你知道哪几种垃圾收集器？各自的优缺点？重点讲下 cms 和 g1 ，包括原理、流程、优缺点。</li>
<li> 垃圾收集器算法的实现原理</li>
</ol>
<blockquote>
<p>  阿里</p>
</blockquote>
<ol>
<li> 讲一下垃圾回收算法</li>
<li> 什么情况下触发垃圾回收</li>
<li> 如何选择合适的垃圾回收算法</li>
<li> JVM有哪几种垃圾回收器</li>
</ol>
<blockquote>
<p>  字节跳动</p>
</blockquote>
<ol>
<li> 常见的垃圾收集器算法有哪些？各有什么优缺点？</li>
<li> system.gc() 和 runtime.gc() 会做什么事情？</li>
<li> Java GC 机制？GC Roots 有哪些？</li>
<li> Java 对象的回收方式，回收算法</li>
<li> GMC 和 G1，CMS解决什么问题，说一下回收的过程。</li>
<li> CMS 回收停顿了几次？为什么要停顿两次？</li>
</ol>
<p>​        对于 G1 这种分拆成为大量 region 的垃圾收集器，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小。</p>
<p>​        在栈空间中保存堆中对象的引用，若使用复制算法，每进行一次 GC 就会导致堆中对象的地址值发生一次变化，这时就必须重新维护栈中对象的地址，这个开销也是很大的。</p>
<hr>
<p>​        以 CMS（Concurrent-Mark-Sweep）回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高（相较于 Mark-Sweep-Compact 算法）。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure）时，将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</p>
<p>分代思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分老年代和新生代。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/14/%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-14 12:34:55" itemprop="dateCreated datePublished" datetime="2021-06-14T12:34:55+08:00">2021-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-06-16 22:47:16" itemprop="dateModified" datetime="2021-06-16T22:47:16+08:00">2021-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/2021/06/14/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8.png" alt="链表"></p>
<h1 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h1><h2 id="单链表节点定义"><a href="#单链表节点定义" class="headerlink" title="单链表节点定义"></a>单链表节点定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object data;	<span class="comment">//  节点#data域</span></span><br><span class="line">    <span class="keyword">public</span> LNode next;	<span class="comment">//  节点#next域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><h2 id="为什么要有双链表（单链表的缺点）"><a href="#为什么要有双链表（单链表的缺点）" class="headerlink" title="为什么要有双链表（单链表的缺点）"></a>为什么要有双链表（单链表的缺点）</h2><ul>
<li><p>  单链表，查找的方向只能是一个方向（从头到尾），而双向链表可以向前或向后查找</p>
</li>
<li><p>单向链表，不能自我删除，需要靠辅助节点；而双向链表则可以自我删除。</p>
<p>  单链表删除时，总会找到 temp（temp 是待删除节点的前一个节点）节点来帮助删除。</p>
</li>
</ul>
<h2 id="双链表节点的定义"><a href="#双链表节点的定义" class="headerlink" title="双链表节点的定义"></a>双链表节点的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object data;		<span class="comment">//  节点#data域</span></span><br><span class="line">    <span class="keyword">public</span> DLNode prior;	<span class="comment">//  指向前驱节点的指针</span></span><br><span class="line">    <span class="keyword">public</span> DLNode next;		<span class="comment">//  指向后继节点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双链表的基础操作"><a href="#双链表的基础操作" class="headerlink" title="双链表的基础操作"></a>双链表的基础操作</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>​    双向链表的遍历方式和单链表一样，只是在遍历的过程中可以向前查找，也可以向后查找。单向链表只能向后查找，例如我们当前遍历到链表的第5个节点，在单向链表中我们只能够继续向后查找5之后的节点，但是在双向链表中，我们既可以查找5之后的节点，也可以返回去查找5之前的节点。</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><h4 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h4><ol>
<li> 首先，找到当前链表的尾节点 temp；</li>
<li> 让尾节点的 next 指针指向要添加的新节点，即 <code>temp.next = newDLNode</code>；</li>
<li> 让新节点的 prior 指针指向尾节点，即 <code>newDLNode.prior = temp</code></li>
</ol>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>​    修改思路也和单向链表一致</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>​    因为是双向链表，因此，我们可以实现自我删除某个节点。</p>
<ol>
<li> 找到待删除的节点 temp；</li>
<li> 让待删除节点前一个节点的 next 指针指向待删除节点后一个节点，即 <code>temp.prior.next = temp.next</code>；</li>
<li>让待删除节点后一个节点的 prior 指针指向待删除节点的前一个节点，即 <code>temp.next.prior = temp.prior</code> 。<ul>
<li>  如果待删除的节点是链表的尾节点，就不需要执行第 3 步了，否则会出现空指针异常。</li>
</ul>
</li>
</ol>
<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h2 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h2><blockquote>
<p>  <strong>应用场景：约瑟夫（Josephu）问题</strong></p>
</blockquote>
<p>​        Josephu 问题：设编号为 1，2，3，…….，n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，他的下一位又从 1 开始报数，数到 m 的那个人又出列。以此类推，直到所有人都出列为止。据此产生一个出队编号的序列。</p>
<blockquote>
<p>  <strong>思路</strong></p>
</blockquote>
<p>​        用一个不带头结点的循环链表来处理 Josephu 问题，先构成一个有 n 个节点的单循环链表，然后由 k 节点起从 1 开始计数，记到 m 时，对应节点从链表中删除，然后再从被删除节点的下一个节点又从 1 开始计数，直到最后一个节点从链表中删除算法结束。</p>
<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
<p>​        根据用户的输入，要形成一个小朋友出队的顺序。假设 </p>
<ul>
<li>  <code>n=5</code>，即共有 5 人</li>
<li>  <code>k=1</code>，编号为 1 的人从 1 开始报数</li>
<li>  <code>m=2</code>，报数为 2 的人出列，他的下一位又从 1 开始报数</li>
</ul>
<ol>
<li><p> 因为存在出队行为，所以需要执行单链表的删除操作，也就是说需要一个辅助指针 <code>helper</code> 指向待删除节点的前一个节点。 <code>first</code> 指针从头开始遍历，所以 <code>helper</code> 指针需要事先指向 <code>first</code> 指向节点的前一个节点（即单向链表的最后一个节点），并且 <code>helper</code> 指针紧跟 <code>first</code> 指针同步遍历。</p>
</li>
<li><p> 报数前，先让 <code>first</code> 和 <code>helper</code> 移动 <code>k-1</code> 次。</p>
</li>
<li><p> 当小朋友报数时，让 <code>first</code> 和 <code>helper</code> 指针同时移动 <code>m-1</code> 次，因为小朋友报数时，自己需要占一次。</p>
</li>
<li><p>这时就可以将 <code>first</code> 指向的节点出队。两种方式：</p>
<ol>
<li> <code>first = first.next;  helper.next = first</code></li>
<li><code>helper.next = first.next;  first = first.next</code></li>
</ol>
</li>
</ol>
<h2 id="单向环形链表的操作"><a href="#单向环形链表的操作" class="headerlink" title="单向环形链表的操作"></a>单向环形链表的操作</h2><h3 id="构建一个单向环形链表"><a href="#构建一个单向环形链表" class="headerlink" title="构建一个单向环形链表"></a>构建一个单向环形链表</h3><ol>
<li> 先创建链表的第一个节点，让 <code>first</code> 指针指向该节点，让第一个节点的 <code>next</code> 指针指向自己，自我连接形成环状。</li>
<li> 每增加一个新的节点，就把新节点加入到已有的环形链表中即可。</li>
</ol>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li> 创建一个辅助指针 <code>current</code> 与 <code>first</code> 指针指向同一个节点。</li>
<li> 通过 while 循环遍历环形链表，但 <code>current</code> 指针再次与 <code>first</code> 指向同一个节点时循环结束。</li>
</ol>
<h3 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h3><h2 id="双向环形链表"><a href="#双向环形链表" class="headerlink" title="双向环形链表"></a>双向环形链表</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/13/String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/13/String/" class="post-title-link" itemprop="url">String</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-13 11:42:39" itemprop="dateCreated datePublished" datetime="2021-06-13T11:42:39+08:00">2021-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-07-31 17:57:19" itemprop="dateModified" datetime="2021-07-31T17:57:19+08:00">2021-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  本文默认使用 HotSpot 虚拟机 + JDK8 ，如有其它情况会具体指出。</p>
</blockquote>
<h1 id="1-String-的基本特性"><a href="#1-String-的基本特性" class="headerlink" title="1  String 的基本特性"></a>1  String 的基本特性</h1><blockquote>
<p>  <strong>String；字符串；</strong></p>
</blockquote>
<p>顾名思义，就是把一个个的字符串在一起，所以说<strong>字符串的底层实现就是一个字符数组</strong>。</p>
<img src="/2021/06/13/String/1623398509911-a4c2e130-bfc9-4aa7-9a9d-531df6e1cdee.png" alt="image.png">

<ul>
<li>  String 被声明为 <strong>final</strong> 的表示类不可被继承。</li>
<li>  String 实现了 <strong>Serializable</strong> 接口，表示字符串是支持序列化的。</li>
<li>  String 实现了 <strong>Comparable</strong> 接口，表示 String 可以比较大小。</li>
<li>  在 JDK8 中，String 使用字符数组 <strong>final char[] value</strong> 数组来存储字符串数据。</li>
</ul>
<h2 id="1-1-String-存储结构的演变"><a href="#1-1-String-存储结构的演变" class="headerlink" title="1.1    String 存储结构的演变"></a>1.1    String 存储结构的演变</h2><ul>
<li>  在 JDK9 之前，String 底层是通过<strong>字符数组 <code>char[]</code></strong> 来保存字符串的。</li>
<li>  从 <strong>JDK9</strong> 开始，String 底层变成了通过<strong>字节数组 <code>byte[]</code></strong> 来保存字符串数据。【字符型 char 编码后都可以用数字（byte型）表示】</li>
</ul>
<blockquote>
<p>  <strong>为什么要变化？</strong></p>
</blockquote>
<p>String 底层将 <code>char[]</code> 变成 <code>byte[]</code> 来存储字符串数据，可以节约一些空间。</p>
<p>同时，String 的一些衍生对象，如 StringBuffer、StringBuilder 等也作出了同样的改变，将存储结构变更为了 byte[] 。</p>
<hr>
<h2 id="1-2-String-的不可变性"><a href="#1-2-String-的不可变性" class="headerlink" title="1.2    String 的不可变性"></a>1.2    String 的不可变性</h2><blockquote>
<p>  String：<strong>不可变的字符序列</strong></p>
</blockquote>
<ul>
<li>  当对字符串<strong>重新赋值</strong>时，会重新分配内存区域，重新赋值，而不是在原先 <code>value[]</code> 的基础上进行更新。</li>
<li>  当对现有的字符串进行<strong>拼接</strong>操作时，也是重新分配内存区域，重新赋值，而不是在原先 <code>value[]</code> 的基础上进行拼接、赋值。</li>
<li>  当<strong>调用 <code>String replace(char oldChar, char newChar)</code> 方法</strong>使用新字符串替换当前字符串指定的子串时，也是重新分配内存区域并重新赋值，而不能在原先字符串数组 <code>value[]</code> 的基础上进行操作。</li>
</ul>
<blockquote>
<p>  <strong>String 字符串为什么不能直接拼接字符串？【==String为什么设计成不可变的？】</strong></p>
</blockquote>
<p>String 的底层数据结构是 <code>char[]</code> 或 <code>byte[]</code>，由于<strong>数组的定长性</strong>，即一旦被创建出来，它的长度就就确定了，不能再被更改。在进行字符串拼接操作时，原数组的容量显然是不足以容纳拼接后的新数组的，所以只能新开辟一块更大的空间保存新的字符串，而不是去改变原有的字符串。【如果新数组的长度小于原数组，又会导致数组存在多个空白区域，造成内存的浪费，也是不合理的】</p>
<hr>
<h1 id="2-String-的内存分配"><a href="#2-String-的内存分配" class="headerlink" title="2  String 的内存分配"></a>2  String 的内存分配</h1><h2 id="String-对象可以保存在内存中的哪些位置"><a href="#String-对象可以保存在内存中的哪些位置" class="headerlink" title="String 对象可以保存在内存中的哪些位置"></a>String 对象可以保存在内存中的哪些位置</h2><blockquote>
<p>  <strong>String 对象可以保存在内存中的哪些位置?</strong></p>
</blockquote>
<ol>
<li> 字符串常量池中；</li>
<li> 堆中(的非字符串常量池空间)；</li>
<li> 二者都保存</li>
</ol>
<hr>
<h2 id="不同版本-JDK-中-StringPool-在内存中的调整"><a href="#不同版本-JDK-中-StringPool-在内存中的调整" class="headerlink" title="不同版本 JDK 中 StringPool 在内存中的调整"></a>不同版本 JDK 中 StringPool 在内存中的调整</h2><ul>
<li>  在 JDK7 之前，字符串常量池存放在<strong>方法区</strong>中（在 HotSpot 中就是永久代）。</li>
<li>  JDK7，HotSpot 将字符串常量池的位置调整到了<strong>堆</strong>中。</li>
<li>  JDK8：字符串常量池存储在方法区（元空间）</li>
</ul>
<blockquote>
<p>  <strong>问题：String Pool 为什么要从方法区调整到堆空间中？</strong></p>
</blockquote>
<p><strong>保存在方法区的缺点</strong>：</p>
<ol>
<li> 方法区（永久代/元空间）默认占用的内存空间较小，如果在方法区中保存大量的 String 对象，极易导致方法区空间出现 OOM  异常。</li>
<li> 即使将方法区初始的内存空间设置为一个较高的值，但是由于方法区进行 GC 的频率极低，这也就意味着在方法区中，String 对象在使用完后，无法做到及时的 GC，也会导致方法区频繁出现 OOM 异常。</li>
</ol>
<p><strong>保存在堆空间的优点</strong>：</p>
<ol>
<li> 首先堆空间解决了保存在方法区时的两个问题：①内存空间小。  ②GC不及时。</li>
<li> 所有的 String 字面量对象都保存在堆（Heap）中，它就和其它普通对象一样，这样的好处就是在进行 JVM 调优时只需调整堆的大小就可以了。【原来保存在元空间中时还要特意为了 String 常量池去进行元空间的性能调优】</li>
</ol>
<hr>
<h2 id="2-1-字符串常量池的数据结构"><a href="#2-1-字符串常量池的数据结构" class="headerlink" title="2.1    字符串常量池的数据结构"></a>2.1    字符串常量池的数据结构</h2><blockquote>
<p>  <strong>字符串常量池数据结构</strong></p>
</blockquote>
<ul>
<li>  通过字面量的方式<strong>（区别于 new）</strong>给一个字符串赋值，此时字符串的值保存在堆空间的字符串常量池中。</li>
<li>  <strong>字符串常量池的底层数据结构是一个 HashTable，所以说字符串常量池中不会存储相同内容的字符串</strong> 。</li>
<li>  String 的 StringPool 是一个固定大小的 HashTable，数组的默认长度在不同的 JDK 版本中均有所不同。</li>
<li>  如果放进 StringPool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后就会导致调用 <code>String.intern()</code> 时性能大幅下降。</li>
</ul>
<p><strong>参数信息：</strong></p>
<ul>
<li>  使用 <code>-XX:StringTableSize</code> 可以设置 StringPool 的长度。</li>
<li>  JDK6中，StringPool 的默认长度为 1009，可以任意设置大小；</li>
<li>  从 JDK7 开始，StringPool 的默认长度增加到了 60013 ；</li>
<li>  从 JDK8 开始，可设置的最小长度为 1009 。</li>
</ul>
<blockquote>
<p>  <strong>具体代码分析</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol>
<li> 由于字符串常量池在堆空间中，所以一个程序中所有的线程用的是同一个字符串常量池；</li>
<li> 由于字符串常量池底层是 HashTable 结构，所以池中不会出现重复的字符串，所以上述代码中的变量 <code>s1</code> 和 <code>s2</code> 指向的是同一个地址。</li>
<li> 由于字符串的不可变性，第 5 行代码中等号右边的语句会在字符串常量池中新开辟一块内存空间用于保存字符串“hello”，并将其赋值给等号左边的变量 s1。</li>
<li> 所以此时 s1 指向的是 “hello”  的地址，而 s2 指向的 “abc” 的地址，两者不相等。</li>
</ol>
<hr>
<h2 id="2-2-如何将字符串对象保存到字符串常量池中"><a href="#2-2-如何将字符串对象保存到字符串常量池中" class="headerlink" title="2.2    如何将字符串对象保存到字符串常量池中"></a>2.2    如何将字符串对象保存到字符串常量池中</h2><p>​        对于 Java 中的 8 种基本数据类型和引用类型 String，这些类型在程序中的使用是非常频繁的（二八原则），为了使这些类型的数据在内存中速度更快、更节省内存，都提供了一种常量池的概念。    </p>
<p>​        常量池就类似于一个 Java 系统级别提供的缓存。8 种基本类型数据的常量池都是系统协调的，String类型的常量池比较特殊，想要<strong>将字符串对象保存在字符串常量中主要方法有两种</strong> ：</p>
<ol>
<li>直接使用双引号声明出来的 String 对象（字符串字面量对象）会直接存储在常量池中。<ul>
<li>  比如： <code>String info = &quot;HelloWorld&quot;;</code> </li>
</ul>
</li>
<li> 如果不是通过双引号声明的 String 对象，也可以使用 String 提供的 <strong>intern()</strong> 方法将某个字符串对象加入到字符串常量池中。</li>
</ol>
<hr>
<h1 id="4-字符串拼接操作"><a href="#4-字符串拼接操作" class="headerlink" title="4  字符串拼接操作"></a>4  字符串拼接操作</h1><blockquote>
<ul>
<li>  字符串常量 + 字符串常量</li>
<li>  字符串常量 + 字符串变量</li>
<li>  字符串变量 + 字符串变量</li>
</ul>
</blockquote>
<h2 id="常量-常量"><a href="#常量-常量" class="headerlink" title="常量 + 常量"></a>常量 + 常量</h2><ul>
<li>  常量与常量的拼接结果还保存在字符串常量池中，原理是编译期优化。</li>
<li>  编译期优化：</li>
</ul>
<blockquote>
<p>  <strong>问题：如何理解“编译期优化”？</strong></p>
</blockquote>
<p>答：两个字符串常量相加，在被编译成 <code>.class</code> 字节码文件时就已经将这两个常量拼接为一个常量字面量了，所以加载到内存中的只有一个字符串字面量来，所以会将这个字符串字面量保存到字符串常量池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;    <span class="comment">// 在编译后，就等同于 &quot;abc&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  .java 文件需要先被编译成 .class 字节码文件，再被加载到JVM中执行。</span></span><br><span class="line"><span class="comment">     *      在 .class 文件中，s1 已经是一个拼接过的常量了。即</span></span><br><span class="line"><span class="comment">     *          String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     *          String s2 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     *      所以在将字节码文件加载到 JVM 中运行时这两个常量都会保存在堆空间的常量池中，</span></span><br><span class="line"><span class="comment">     *	 并且常量池中不允许出现重复的元素，所以说 s1 和 s2 指向同一个对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2);   <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s2));      <span class="comment">// true</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<hr>
<h2 id="常量-变量-变量"><a href="#常量-变量-变量" class="headerlink" title="常量/变量 +变量"></a>常量/变量 +变量</h2><ul>
<li>  常量池中不会保存相同内容的字面量对象。</li>
</ul>
<blockquote>
<p>  <strong>结论：</strong></p>
</blockquote>
<ul>
<li>  在多个字符串拼接操作中，只要存在变量，结果就<strong>只会</strong>保存在堆中的非常量池区域。</li>
<li>  <strong>Tip：此时拼接后的 String 对象只会保存在堆中的非常量池区域，而不会同步保存到字符串常量池中！！！</strong></li>
</ul>
<blockquote>
<p>  <strong>原理：</strong>字符串拼接操作底层是通过 <code>StringBuilder#append()</code> 方法实现的。</p>
</blockquote>
<p>在多个字符串拼接操作中，只要存在变量，那么 JVM 在进行字符串拼接的时候，</p>
<ol>
<li> 首先会 <code>new StringBuilder()</code> 对象，</li>
<li> 然后调用该对象中的 <code>append()</code> 方法拼接字符串，</li>
<li> 最后再调用  <code>StringBuilder#toString()</code> 方法，将拼接后的字符串对象转换成 String 对象，并将这个 String 对象保存在堆中(的非常量池区域)。</li>
</ol>
<blockquote>
<p>  <strong>代码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + s2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        s1 + s2 的执行细节：</span></span><br><span class="line"><span class="comment">            1、StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="comment">            2、sb.append(s1);</span></span><br><span class="line"><span class="comment">            3、sb.append(s2);</span></span><br><span class="line"><span class="comment">            4、sb.toString();  --&gt;&gt; 类似于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  最终 s4 指向的地址是在第 4 步的 <code>sb.toString()</code> 中确定的，这个方法类似于 <code>new String()</code>，但是并不相同。</li>
<li>  <strong>使用 <code>new String()</code> 创建出来的 String 对象会同时保存在堆和字符串常量池中</strong>，而 <code>StringBuilder#toString()</code> 方法生成的 String 对象只保存在堆中(的非常量池区域)。</li>
</ul>
<blockquote>
<p>  <strong>Tip</strong>：</p>
</blockquote>
<ul>
<li>  在 JDK5 之前，含有变量的字符串拼接操作，底层使用的类是 StringBuffer，<em>因为 JDK5 之前并没有 StringBuilder 这个类</em>；</li>
<li>  从 JDK5 开始，才使用 StringBuilder 代替 StringBuffer 来完成含有变量的字符串拼接操作。</li>
</ul>
<blockquote>
<p>  <strong>字节码文件</strong></p>
</blockquote>
<p><img src="/2021/06/13/String/1623478701279-d327aa0f-fdc0-47a9-a63e-e310317f7271.png" alt="test.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">2</span> &lt;a&gt;   <span class="comment">// 在字符串常量池中创建一个字面量对象&lt;a&gt;，并得到该字面量对象的内存地址</span></span><br><span class="line"> <span class="number">2</span> astore_1     <span class="comment">// 将字面量&lt;a&gt;的内存地址保存到栈中栈帧的局部变量表中下标为 1 的位置上</span></span><br><span class="line"> <span class="number">3</span> ldc #<span class="number">3</span> &lt;b&gt;  </span><br><span class="line"> <span class="number">5</span> astore_2     </span><br><span class="line"> <span class="number">6</span> ldc #<span class="number">4</span> &lt;ab&gt;  </span><br><span class="line"> <span class="number">8</span> astore_3    </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/* 创建 StringBuilder 对象开始 */</span></span><br><span class="line"> <span class="number">9</span> <span class="keyword">new</span> #<span class="number">5</span> &lt;java/lang/StringBuilder&gt; </span><br><span class="line"><span class="number">12</span> dup</span><br><span class="line"><span class="number">13</span> invokespecial #<span class="number">6</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="comment">/*  创建 StringBuilder 对象结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span> aload_1  <span class="comment">// 取出局部变量表中下标为1的位置上的值，即常量池中字面量对象&lt;a&gt;的地址值</span></span><br><span class="line"><span class="number">17</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;    <span class="comment">// 调用 StringBuilder#append() 将该值追加到 StringBuilder 对象中</span></span><br><span class="line"><span class="number">20</span> aload_2  </span><br><span class="line"><span class="number">21</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">     </span><br><span class="line"><span class="number">24</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.toString&gt;  <span class="comment">// 调用 StringBuilder#toString() 将StringBuilder对象转化为String对象</span></span><br><span class="line"><span class="number">27</span> astore <span class="number">4</span> <span class="comment">// 将上一条指令得到的String对象的内存地址值保存到局部变量表下标为4的位置上</span></span><br><span class="line"></span><br><span class="line"><span class="number">29</span> <span class="keyword">new</span> #<span class="number">5</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">32</span> dup</span><br><span class="line"><span class="number">33</span> invokespecial #<span class="number">6</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">36</span> ldc #<span class="number">2</span> &lt;a&gt;   <span class="comment">// 从常量池中得到字符串常量&lt;a&gt;</span></span><br><span class="line"><span class="number">38</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;    </span><br><span class="line"><span class="number">41</span> aload_2      </span><br><span class="line"><span class="number">42</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;    </span><br><span class="line"><span class="number">45</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.toString&gt;  </span><br><span class="line"><span class="number">48</span> astore <span class="number">5</span>     </span><br><span class="line">     </span><br><span class="line"><span class="number">50</span> <span class="keyword">return</span>   <span class="comment">// 返回</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="特殊情况：final-修饰的变量"><a href="#特殊情况：final-修饰的变量" class="headerlink" title="特殊情况：final 修饰的变量"></a>特殊情况：final 修饰的变量</h2><p>使用 <code>final</code> 修饰的变量等价于常量，因为在 <code>.java</code> 源文件在编译成 <code>.class</code> 字节码文件的时候就已经把 <code>final</code> 修饰的变量转换成常量值了（编译期优化）。也就是说加载到内存中的就是字符串字面量常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);  <span class="comment">// true</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用 final 修饰的变量，在编译成字节码文件的时候就已经把这些变量转换成常量了（编译期优化），</span></span><br><span class="line"><span class="comment">        也就是说加载到内存中的是常量字符串，常量与常量的拼接自然保存在常量池中。</span></span><br><span class="line"><span class="comment">        所以可以得到 s3==s4 为 true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>如果拼接的结果调用 <code>intern()</code> 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象在常量池中的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;   <span class="comment">// String Pool；poolAddress[0]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;   <span class="comment">// String Pool；poolAddress[1]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;     <span class="comment">// String Pool；poolAddress[2]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;    <span class="comment">// String Pool；poolAddress[2]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;  <span class="comment">// Not String Pool； heapAddress[0]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;  <span class="comment">// Not String Pool; heapAddress[1]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;    <span class="comment">// Not String Pool; heapAddress[2]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();    <span class="comment">// String Pool；poolAddress[2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     *      s1 保存在字符串常量池中，地址为 poolAddress[0]；</span></span><br><span class="line"><span class="comment">     *      s2 保存在字符串常量池中，地址为 poolAddress[1]；</span></span><br><span class="line"><span class="comment">     *      s3 保存在字符串常量池中，地址为 poolAddress[2]；</span></span><br><span class="line"><span class="comment">     *      s4 是两个常量的拼接，由于编译期优化，结果仍保存在常量池中，并且地址为 poolAddress[2]；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      s5 是 变量+常量 的拼接，结果只会保存在堆中的非常量池区域，所以 s5 的地址为 heapAddress[0]；</span></span><br><span class="line"><span class="comment">     *      s6 也是 变量+常量 的拼接，结果会保存在堆中的非常量池区域，并且在非常量池区域并没有要求相同的值只能保存一份数据，所以 s6 会占用一块新的内存空间，地址为 heapAddress[1]；</span></span><br><span class="line"><span class="comment">     *      s7 也是 变量+变量 的拼接，结果会保存在堆中的非常量池区域，原理同 s6 一样，s7 的地址为 heapAddress[2]；</span></span><br><span class="line"><span class="comment">     *      s8 是 s6 调用 intern() 方法得到的返回值，由于s6对应的字符串字面量在常量池中已经存在了，所以 s8 的地址值为 poolAddress[2];</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);   <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s5);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s6);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s7);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s6);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s7);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s6 == s7);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s8);   <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="5-intern-方法"><a href="#5-intern-方法" class="headerlink" title="5  intern() 方法"></a>5  intern() 方法</h1><h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><blockquote>
<p>  <strong>源码分析</strong></p>
</blockquote>
<p><img src="/2021/06/13/String/1623488782339-dd95c67e-52d3-4dfd-887b-52ed4e499a47.png" alt="image.png"></p>
<p>​        <strong>intern()</strong> 方法是 String 类中的一个方法，查看源码可知，<code>String#intern()</code> 方法是一个 <code>native</code> 修饰的本地方法。也就是说，其具体实现是由 C/C++ 编写的。</p>
<blockquote>
<p>  <strong>主要作用：</strong></p>
</blockquote>
<p>现有一个字符串对象 <code>String s1</code> ，当调用 <code>s1.intern()</code> 方法时，</p>
<ol>
<li> 首先要去判断字符串常量池中是否已经存在一个 String 对象其字面量与 s1 的字面量相同；</li>
<li> 如果存在，那么就返回字符串常量池中该 String 对象的地址；</li>
<li> 如果不存在，就将 s1 对象的字面量值拷贝一份到字符串常量池中，并返回该 String 对象在字符串常量池中的地址。</li>
</ol>
<blockquote>
<p>  <strong>Tip：</strong></p>
</blockquote>
<p>调用 <code>String#intern()</code> 方法可以确保字符串在内存中只有一份数据，这样可以节约内存空间，加快字符串操作任务的执行速度。</p>
<p><strong>分析：</strong></p>
<ul>
<li>  调用 <code>String#intern()</code> 方法后，如果 String 对象原本就保存在字符串常量池中，那不会有任何改变；</li>
<li>  如果 String 对象原本保存在堆(的非字符串常量池区域)中，那么调用此方法后，就会返回一个字符串常量池中对象的地址。</li>
<li>  这时就可以把原来堆(的非字符串常量池区域)中的 String 对象回收掉，让内存中只保留一份字符串字面量数据。【这一步不是必须的】</li>
</ul>
<hr>
<h2 id="intern-的使用场景"><a href="#intern-的使用场景" class="headerlink" title="intern() 的使用场景"></a>intern() 的使用场景</h2><p>如果不是通过字符串字面量（即双引号）创建的 String 对象，如果想要将其保存到字符串常量池中，可以使用 String 提供的 intern() 方法。</p>
<blockquote>
<p>  <strong>问题：如何保证字符串变量 s 指向的字符串是字符串常量池中的数据而不是堆中非常量池区域的数据呢？</strong></p>
</blockquote>
<p>答：有2种方式</p>
<ol>
<li> 直接通过双引号而不是 new 关键字来创建 String 对象。如：<code>String s = &quot;HelloWorld&quot;;</code></li>
<li> 对堆中的字符串对象，调用 <code>intern()</code> 方法，得到的返回值就是指向字符串常量池中对应字符串字面量的地址。</li>
</ol>
<blockquote>
<p>  <strong>问题：<code>new String(&quot;HelloWorld&quot;)</code> 会创建几个对象？</strong> </p>
</blockquote>
<p>答：如果在此之前，字符串常量池中已有字面量对象 <code>“HelloWorld”</code>，则只会在堆中新建 1 个对象；否则会新建 2 个对象，一个保存在堆中非字符串常量池区域（和普通对象一样），另一个保存在字符串常量池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	创建动作分解：</span></span><br><span class="line"><span class="comment">    	1、new String()  堆中；</span></span><br><span class="line"><span class="comment">    	2、&quot;HelloWorld&quot;  字符串常量池中；</span></span><br><span class="line"><span class="comment">    	3、执行堆中的 String 对象的初始化方法；</span></span><br><span class="line"><span class="comment">    	4、将等式左边的地址赋值给等式右边的变量。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 首先，在堆中非常量池区域中创建一个 String 对象。</li>
<li> 其次，在字符串常量池中创建字面量为 <code>&quot;HelloWorld&quot;</code> 的字面量对象。</li>
<li> 再次，调用 String 类的构造方法，对字符串对象 s 进行显式初始化；</li>
<li> 最后，将结果地址保存到局部变量表下标为 1 的位置上。</li>
<li> <strong>注意：虽然现在字符串常量池和堆中都有“HelloWorld”这个字符串对象，但是此时 s 得到的地址是堆中的！！！</strong></li>
</ol>
<p><img src="/2021/06/13/String/1623491535138-3562077b-906b-41ae-aaee-49806b528949.png" alt="image.png"></p>
<blockquote>
<p>  <strong>扩展：<code>String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> 会创建多少个对象？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/13/String/1623492457552-7821a5f9-93b5-44b1-aabf-11514fb0ba93.png" alt="image.png"></p>
<p>分析：</p>
<ul>
<li>  对象1：<code>new StringBuilder()</code>， 首先，两个字符串变量拼接时，需要一个辅助对象 StringBuilder 。</li>
<li>  对象2：<code>new String(&quot;a&quot;)</code>，</li>
<li>  对象3：常量池中的字面量对象 “a”</li>
<li>  对象4：<code>new String(&quot;b&quot;)</code>，</li>
<li>  对象5：常量池中的字面量对象 “b”</li>
<li>  对象6：在调用 <code>StringBuilder.toString()</code> 方法时，根据 <code>toString()</code> 方法的源码，还要创建一个 String 对象。</li>
</ul>
<blockquote>
<p>  <strong>toString() 方法</strong></p>
</blockquote>
<p><strong>虽然 toString() 方法底层调用了 new String() 方法，但是却不会在字符串常量池中创建对应的字符串对象，只会在堆中创建字符串对象。</strong></p>
<p><img src="/2021/06/13/String/1623492807620-7f60184d-4382-4830-b450-95b9019c6051.png" alt="image.png"></p>
<blockquote>
<p>  <code>StringBuilder#toString()</code> 的字节码文件</p>
</blockquote>
<ul>
<li>  我们可以看到并没有在字符串常量池中创建 String 对象。</li>
</ul>
<p><img src="/2021/06/13/String/image-20210613173632473.png" alt="image-20210613173632473"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);    <span class="comment">// s1 --&gt;&gt; Not String Pool ；heapAddr[0]</span></span><br><span class="line">    s1.intern();    <span class="comment">// s1 --&gt;&gt; Not String Pool ；heapAddr[0]</span></span><br><span class="line">    			   <span class="comment">// s1.intern() 的返回值 --&gt;&gt; String Pool ； poolAddr[0]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;    <span class="comment">// s2 --&gt;&gt; String Pool ； poolAddr[0]</span></span><br><span class="line">    System.out.println(s1 == s2);   <span class="comment">// False</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ol>
<li><p>使用 <code>new</code> 关键字创建对象，</p>
<ul>
<li>  首先会在堆中非常量池区域分配内存保存字符串对象 “1” ；</li>
<li>  并且之后还会在常量池中分配内存保存字面量对象 “1” ;</li>
<li>  但是此时栈中局部变量表中的 s1 保存的是堆中非常量池区域的字符串对象的内存地址；</li>
</ul>
</li>
<li><p>调用 <code>s1.intern()</code> 方法，JVM 尝试在字符串常量池中创建值为 “1” 的字面量对象，发现已存在，得到该字面量对象的地址，作为方法的返回值。<code>intern()</code> 方法是有返回值的，返回值就是字面量对象 “1” 在字符串常量池中的内存地址，但是在本例中并没有接收这个地址，也就是说目前为止，s1 指向的仍然是堆中非常量池区域中那个字符串对象的内存地址。</p>
</li>
<li><p>直接使用双引号创建 String 对象，JVM 会尝试在字符串常量池中创建值为 “1” 的字面量对象，发现已存在，得到该字面量对象的地址，并将此字面量对象的内存地址保存在栈的局部变量表中，即此时 s2 指向字符串常量池中对应字面量对象的地址。</p>
</li>
<li><p>所以，<code>s1==s2</code> 结果为 False</p>
</li>
</ol>
<h3 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// s3 --&gt;&gt; Not String Pool ；heapAddr[1]</span></span><br><span class="line">       s3.intern();    <span class="comment">// // s3 --&gt;&gt; Not String Pool ；heapAddr[1]</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;    <span class="comment">// JDK6：String Pool ； poolAddr[1]  JDK7：Not String Pool ；heapAddr[1]</span></span><br><span class="line">       System.out.println(s3 == s4);   <span class="comment">// JDK6：False  JDK7：True</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>s3</code> 指向的对象是由两个字符串对象拼接而成的，在进行字符串拼接时，底层要借助 <code>StingBuilder</code> 实现。其中有一步需要使用 <code>StringBuilder#toString()</code> 方法将 <code>Stringbuilder</code> 对象转换成 <code>String</code> 对象，在使用 <code>toString()</code> 方法时，<strong>只</strong>会在堆中的非常量池区域创建一个 <code>String</code> 对象，并不会在常量池中创建这个对象对应的字面量对象（类似于 new，但不会同步到常量池中）。所以第 2 行代码在执行完毕后 <code>s3</code> 指向一个堆中的字符串对象。</li>
<li>由于此时字符串常量池中没有字面量对象 <code>“11”</code>，所以调用 <code>intern()</code> 方法会在常量池中创建一个字符串对象<code>“11&quot;</code>并返回其地址值。<ul>
<li>  在 JDK7 之前，由于字符串常量池不在堆空间中，所以会真正意义上的在字符串常量池创建一个字符串对象<code>“11”</code>并返回其地址值。</li>
<li>  从 JDK7 开始，由于字符串常量池也保存在堆空间中，所以这时不会在常量池中创建真正的字符串对象<code>“11”</code>了，而是直接拿来了 s3 对象的地址值。</li>
</ul>
</li>
<li>此处没有使用 <code>intern()</code> 方法的返回值，所以 s3 仍然指向堆中非常量池空间中的那个字符串对象的地址。</li>
<li>直接使用字面量创建String对象。由于此时字符串常量池中已有该字面量对象，所以不再新建对象，只是返回字面量对象的地址，而显然该字面量对象的地址是一个地址值，最后真正指向的对象还是堆中非常量池区域的那个String对象，而返回地址按照对象的就近原则也是堆中非常量池区域的String对象的地址值。</li>
<li>所以说， 在JDK7之前，<code>s3 == s4</code> 为 False；而从JDK7开始，<code>s3 == s4</code> 为 True</li>
</ol>
<img src="/2021/06/13/String/1623508433062-ce767a2e-fba1-4f8d-bd53-374635e01625.png" alt="intern的使用 (1).png" style="zoom: 67%;">





<h2 id="不同版本JDK中不同方式创建字符串对象的先后顺序的影响"><a href="#不同版本JDK中不同方式创建字符串对象的先后顺序的影响" class="headerlink" title="不同版本JDK中不同方式创建字符串对象的先后顺序的影响"></a>不同版本JDK中不同方式创建字符串对象的先后顺序的影响</h2><ol>
<li> 如果只想在堆的非字符串常量池区域创建对象： <code>String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> 此时字符串常量池中没有“ab”对应的字面量对象。</li>
<li>如果这时继续在常量池中也保存一份 “ab” 字符串对应的字面量对象。可以调用 <code>s1.intern();</code> 方法。<ul>
<li>  从 JDK7 开始，为了节省内存，在常量池中创建字符串对象这一步，如果在堆的非常量池区域存在相同字面量值的对象，就不再创建一个“真正”的字面量对象了，而是在常量池的字面量对象的地址中保存堆中非常量池区域那个对象的地址值。</li>
<li>  而在 JDK7 之前，在常量池中创建的对象时真正意义上的字面量对象，保存的是真正的数据值，而不是对象的引用。</li>
</ul>
</li>
<li> 如果使用 <code>String s1 = new String(&quot;1&quot;);</code> 创建对象，这时会创建两个对象，即字符串常量池中的字面量对象和 Java 堆的非字符串常量池区域的对象，这两个对象都是真正意义上的对象。上述1，2的规则就不再使用了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK8 中测试</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// Not String Pool ；heapAddr[1]</span></span><br><span class="line">       s3.intern();    <span class="comment">// String Pool ； poolAddr[1]</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;    <span class="comment">// Not String Pool ；heapAddr[1]</span></span><br><span class="line">       System.out.println(s3 == s4);   <span class="comment">// True</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       调换了2、3行代码的执行顺序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// Heap&#x27;s Not String Pool ；heapAddr[0]</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;    <span class="comment">// String Pool ; poolAddr[0]</span></span><br><span class="line">       s3.intern();    <span class="comment">// String Pool ； poolAddr[0]</span></span><br><span class="line">       System.out.println(s3 == s4);   <span class="comment">// False</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>总结：String中intern()的使用：</strong></p>
</blockquote>
<ul>
<li><p>  在 JDK7 之前，将字符串对象尝试放入字符串常量池中时：</p>
</li>
<li><ul>
<li>  如果字符串常量池中已经含有，则并不会放入，并返回已有对象的内存地址；</li>
<li>  如果字符串常量池中没有，则会将当前对象的值复制一份，放入字符串常量池，并返回字符串常量池中该对象的内存地址；</li>
</ul>
</li>
<li><p>  从 JDK7 开始，将字符串对象尝试放入字符串常量池中时：</p>
</li>
<li><ul>
<li>  如果字符串常量池中已经含有该字面量对象，则直接返回该字面量对象的内存地址即可；</li>
<li>  如果没有，则会把<strong>对象的引用地址复制一份</strong>，放入字符串常量池，并返回字符串常量池中的引用地址。</li>
</ul>
</li>
</ul>
<h2 id="intern-的练习"><a href="#intern-的练习" class="headerlink" title="intern 的练习"></a>intern 的练习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//      String x = &quot;ab&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// 在上一行代码执行完毕之后，字符串常量池中并没有字面量对象 &quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">        <span class="comment">// JDK6中，在字符串常量池中创建字面量对象 &quot;ab&quot; ，并将地址值赋给 s2</span></span><br><span class="line">        <span class="comment">// JDK8中，在字符串常量池中没有创建字面量对象 &quot;ab&quot;，而是创建了一个引用对象，指向堆中非字符串常量池中的地址并将地址返回</span></span><br><span class="line">        System.out.println(s1 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false（JDK6）；true（JDK8）</span></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);  <span class="comment">// &quot;ab&quot; --&gt;&gt; Heap   执行完以后，在字符串常量池中不会生成 &quot;ab&quot;</span></span><br><span class="line">    s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   <span class="comment">// s2 --&gt;&gt; String Pool --&gt;&gt; Heap</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);   <span class="comment">// &quot;ab&quot; --&gt;&gt; Heap, SringPool    执行完以后，在字符串常量池中会生成 &quot;ab&quot;，但是s1指向的是Heap中的那个</span></span><br><span class="line">    s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   <span class="comment">// s2 --&gt;&gt; String Pool</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="7-G1-中的-String-去重操作"><a href="#7-G1-中的-String-去重操作" class="headerlink" title="7  G1 中的 String 去重操作"></a>7  G1 中的 String 去重操作</h1><p>字符串常量池中本就不允许存储重复元素，所以 String 的去重操作针对的是堆中非字符串常量池的区域。</p>
<p>String s1 = new String(“hello”);</p>
<p>String s1 = new String(“hello”);</p>
<p>什么是去重操作？（图）</p>
<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><blockquote>
<p>  背景</p>
</blockquote>
<p>通过对大量 Java 应用的研究测试表明：</p>
<ul>
<li>  堆中存活的数据集合中 String 对象占据了约 25%；</li>
<li>  其中 String 对象中重复的对象又占了约 13.5%；重复的意思就是： <code>string1.equals(string2) == true</code> </li>
<li>  堆上存在重复的String对象必然是一种内存资源的浪费。</li>
<li>  String 对象的平均长度是 45</li>
</ul>
<p>许多大规模Java应用的瓶颈在于内存，而这些项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样能避免浪费内存。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JVM——类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-10 17:26:39" itemprop="dateCreated datePublished" datetime="2021-06-10T17:26:39+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-01 17:41:49" itemprop="dateModified" datetime="2021-09-01T17:41:49+08:00">2021-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1    概述"></a>1    概述</h1><blockquote>
<p>  <strong>什么是类加载机制？</strong></p>
</blockquote>
<p>在 <code>.class</code> 文件中保存的描述类型的信息，最终都需要被加载到虚拟机之后才能被运行和使用。而</p>
<ol>
<li> <strong>虚拟机如何将 <code>.class</code> 文件加载到内存中？</strong></li>
<li> <strong><code>.class</code> 文件中的信息进入到虚拟机后会发生什么变化？</strong></li>
</ol>
<p>就是类加载机制关注的内容。简而言之，<strong>类加载机制就是将 <code>.class</code> 文件中的信息按照虚拟机的制定规范加载到内存中保存</strong>。</p>
<h2 id="1-1-类的主动使用和被动使用"><a href="#1-1-类的主动使用和被动使用" class="headerlink" title="1.1    类的主动使用和被动使用"></a>1.1    类的主动使用和被动使用</h2><p>JVM 对 <code>.class</code> 文件采用的是<strong>懒加载</strong>的方式，也就是说只有需要使用某个类的时候才会将该类对应的 <code>.class</code> 文件加载到内存中生成 Class 对象。所以 Java 程序对类的使用方式又可分为：主动使用和被动使用。<strong>主动使用会导致类的初始化，而被动使用则不会导致类的初始化</strong>。</p>
<p><strong>主动使用</strong>，又分7种情况：</p>
<blockquote>
<ol>
<li>创建类的实例</li>
<li>读取或设置某个类或接口中的静态字段时（常量除外，被 final static 修饰的字段也视为常量）。</li>
<li>调用类的静态方法。</li>
<li>使用 java.lang.reflect 包的方法被类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化（比如：Class.forName(“com.example.Test”)）</li>
<li>当初始化类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个类。</li>
<li>JDK7 开始提供的动态语言支持：</li>
</ol>
</blockquote>
<p>类的主动使用情况下，都会先判断类是否被加载，如果没有被加载，则会触发其进行加载。</p>
<ul>
<li>除了以上7种情况，其它使用 Java 类的方式都被看做是 <strong>类的被动使用</strong>，都<strong>不会导致类的初始化</strong>。</li>
</ul>
<hr>
<h2 id="1-2-类加载器"><a href="#1-2-类加载器" class="headerlink" title="1.2    类加载器"></a>1.2    类加载器</h2><p>类加载器（ClassLoader）负责从文件系统或网络中加载二进制字节流（如<code>.class</code>二进制字节码文件）<strong>到方法区中</strong>，至于该二进制字节流是否可以运行，则由执行引擎（Execution Engine）决定。</p>
<p>加载到 JVM 内存中的类信息存放在方法区。除了类本身的信息外，方法区中还会存放<strong>运行时常量池</strong>信息（包括字符串字面量和数字常量，这部分常量信息是 Class 文件中常量池部分的内存映射）、<strong>静态成员</strong>、以及<strong>即时编译器编译后的热点代码</strong>。</p>
<blockquote>
<p>运行时常量池对应 <code>.class</code> 文件中的常量池，通过对字节码文件的反编译我们发现字节码文件中存在常量池。常量池在程序运行时会被加载到方法区的运行时常量池中。</p>
</blockquote>
<p>类在被加载到内存中时依赖于运行时常量池（类中的常量、符号引用等都保存在常量池中，在加载类到内存中时就保存在运行时常量池中了）。</p>
<h3 id="1-2-1-类加载器-ClassLoader-对象"><a href="#1-2-1-类加载器-ClassLoader-对象" class="headerlink" title="1.2.1    类加载器 ClassLoader 对象"></a>1.2.1    类加载器 ClassLoader 对象</h3><ol>
<li><code>.class</code> 字节码文件一般保存在本地硬盘上，可以理解为实例对象的模板，这个模板首先要加载到虚拟机中，然后在创建实例对象的时候才能根据这个模板创建出 n 个实例对象。</li>
<li><code>.class</code> 字节码文件被加载到虚拟机中时，会在方法区中划分一块内存保存这部分类数据，我们称之为<strong>DNA 元数据模板</strong>。</li>
<li>从 <code>.class字节码文件 --&gt; 元数据模板</code> 的过程中，需要一个运输工具承担一个快递员的角色完成这一过程，这个工具就是<strong>类加载器 （Class Loader）</strong>。</li>
</ol>
<p><img src="/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/ClassLoader.png" alt="ClassLoader"></p>
<hr>
<h1 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2    类的生命周期"></a>2    类的生命周期</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1    概述"></a>2.1    概述</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止。整个生命周期将会经历七个阶段。这七个阶段发生的顺序如下图所示。</p>
<p><img src="/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p>
<p>这七个阶段按照生命周期可分为：<strong>类加载阶段 –&gt; 类使用阶段 –&gt; 类卸载阶段</strong>。类加载阶段中的验证、准备、解析三个阶段合称为连接（Linking）。</p>
<p>其中，加载、验证、准备、初始化和卸载这五个阶段的顺序是可以确定的，类型的加载过程必须按部就班地按照这种顺序开始。而<strong>解析阶段则不一定（解析阶段主要负责将符号引用转换为直接引用），它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定特性</strong>。</p>
<hr>
<h2 id="2-2-类加载阶段"><a href="#2-2-类加载阶段" class="headerlink" title="2.2    类加载阶段"></a>2.2    类加载阶段</h2><h3 id="阶段1：Loading"><a href="#阶段1：Loading" class="headerlink" title="阶段1：Loading"></a>阶段1：Loading</h3><p>“加载（Loading）”是整个“类加载（Class_Loading）”过程中的一个阶段，这两个概念比较容易混淆。</p>
<ol>
<li>通过类的全限定类名获取定义此类的二进制字节流。<ul>
<li>  说明：字节码文件以二进制格式保存，通过IO方式将<code>.class</code>字节码文件中的内容以字节流的形式传输到JVM内存中。</li>
</ul>
</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<ul>
<li>  说明：加载阶段结束之后，Java虚拟机外部的二进制字节码文件对应的内容就会按照虚拟机规定的格式存储在方法区中了。</li>
</ul>
</li>
<li><strong>在方法区生成一个代表这个类的 java.lang.Class 对象</strong>，作为方法区中这个类的各种数据的访问入口。<ul>
<li>  说明：类型数据妥善安置在方法区之后，就会在Java 内存中实例化一个<code>java.lang.Class</code>类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</li>
</ul>
</li>
</ol>
<h4 id="补充：加载-class-文件的方式"><a href="#补充：加载-class-文件的方式" class="headerlink" title="补充：加载 .class 文件的方式"></a>补充：加载 .class 文件的方式</h4><p>《Java虚拟机规范》对这三点要求并不是特别具体。例如“通过一个全限定类名来获取定义此类的二进制字节流”这条规则，并没有指明二进制字节流必须要从某个 <code>.class</code> 文件中获取。基于此发展出了各种各样的获取二进制字节流的方式，如：</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取。典型场景：Web Applet</li>
<li>从 zip 压缩包中读取。这很常见，是常见的 jar、war 格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型的场景就是 JSP 应用，由 JSP 文件生成对应的 Class 文件。</li>
<li>从专有数据库中提取。</li>
<li>从加密文件中获取。典型的防止 Class 文件被反编译的保护措施。</li>
</ul>
<hr>
<h3 id="阶段2：Verify"><a href="#阶段2：Verify" class="headerlink" title="阶段2：Verify"></a>阶段2：Verify</h3><p><strong>验证</strong>是连接阶段的第一步，这一阶段的目的是确保从<code>.class</code> 文件加载到方法区中的二进制字节流数据信息符合当前虚拟机的全部约束要求，确保这些信息被当做代码运行后不会危害虚拟机自身的安全。</p>
<p>Java 语言是相对安全的编程语言，当代码发生语法层面的错误时（前端）编译器会拒绝编译，并抛出异常。但是 <code>.class</code> 文件并不是只能由 Java 语言编译而来，它可以使用包括靠键盘 0  和 1 直接在二进制编辑器中敲出 Class 文件在内的任何途径产生。Java 虚拟机如果不检查输出的字节流，对其完全信任的话，很可能会因为载入了有错误或者有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是 Java 虚拟机保护自身的一项必要措施。</p>
<p>验证阶段大致上会完成以下4个阶段的检验动作：</p>
<ol>
<li><p><strong>文件格式验证</strong>：验证二进制字节流是否符合 Class 文件格式规范，并且能被当前版本的虚拟机处理。主要包括：</p>
<ul>
<li>  是否以魔数 <code>0xCAFEBABE</code> 开头</li>
<li>  主、次版本号是否在当前 Java 虚拟机接受的范围之内</li>
<li>  常量池中的常量是否有不被支持的常量类型（检查常量 tag 标志）</li>
<li>  指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量</li>
<li>  ……</li>
</ul>
</li>
<li><p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其信息符合《Java虚拟机规范》的要求。包括：</p>
<ul>
<li>  这个类是否有父类</li>
<li>  这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）</li>
<li>  如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>  类中的字段、方法是否与父类产生矛盾（例如覆盖了父类中的 final 字段，或者出现了不符合规则的方法重载）</li>
<li>  ……</li>
</ul>
</li>
<li><p> <strong>字节码验证</strong>：通过对数据流分析和控制流分析，确定语义是合法的。</p>
</li>
<li><p><strong>符号引用验证</strong>：发生在虚拟机将符号引用转化为直接引用的时候。这个转化动作将在 Linking 的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外的各类信息进行匹配性校验。即检验该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。主要校验的内容有：</p>
<ul>
<li><p>  符号引用中通过字面量描述的全限定类名是否能找到对应的类。</p>
</li>
<li><p>找到对应的类后，在指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段。</p>
<p>  就是 A 类依赖了 B 类，并调用了 B 类中的 test() 方法，首先要检查通过符号引用转化成的直接引用能不能找到 B，找到 B 之后还要检查 B 中有没有一个叫做 test() 的方法。</p>
</li>
<li><p>  符号引用中的类、字段、方法的可访问性，是否可被当前类访问。</p>
</li>
<li><p>  ……</p>
</li>
</ul>
</li>
</ol>
<p>如果无法通过符号引用的验证，Java 虚拟机将会抛出一个 <strong>java.lang.IncompatibleClassChangeError</strong> 的子类异常，典型的如：<strong>java.lang.IllegalAccessError</strong>、<strong>java.lang.NoSuchFieldError</strong>、<strong>java.lang.NoSuchMethodError</strong> 等。</p>
<p>验证阶段对于 Java 虚拟机来说，是一个非常重要但又非必须的阶段。如果运行程序的全部代码都已经被反复验证和使用过，在生产阶段就可以考虑使用 <strong>-Xverify:none</strong> 参数来关闭大部分的验证措施，以缩短类加载的时间。  </p>
<hr>
<h3 id="阶段3：Prepare"><a href="#阶段3：Prepare" class="headerlink" title="阶段3：Prepare"></a>阶段3：Prepare</h3><ul>
<li>Prepare 阶段的主要工作就是：为类变量（静态变量）分配内存并且设置该变量的默认初始零值[如果有类变量的话]，类变量会分配在方法区中。</li>
<li><strong>Prepare 阶段不会为实例变量分配内存和初始化变量值</strong>，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</li>
<li>如果类变量使用 final 修饰，即 <strong>final static</strong> 修饰的变量，在 Prepare 阶段直接就会显式初始化。</li>
</ul>
<blockquote>
<p>  <strong>例子</strong></p>
</blockquote>
<p>假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>那么 value 的值在 Prepare 阶段过后的初始值就是 0（默认零值），而把 value 赋值为 123 的动作要到类的初始化阶段（Initialization）才会被执行。</p>
<p>在某些“特殊情况”下，即如果类字段的字段属性表中存在 ConstantValue 属性（即类字段是一个常量），那么在 Prepare 阶段变量值就会被初始化为 ConstantValue 属性所指定的初始值。假设上面的变量 value 的定义修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;	<span class="comment">// 被 final static 修饰的变量就相当于一个常量 ConstantValue</span></span><br></pre></td></tr></table></figure>

<p>（前端）编译时 javac 将会为 value 生成 ConstantValue 属性，在 Prepare 阶段虚拟机就会将 value 赋值为 123.</p>
<blockquote>
<p>  <strong>方法区只是一个逻辑上的区域</strong></p>
</blockquote>
<p>从概念上讲，这些类变量所使用的内存都应该在方法区中进行分配。但是必须要注意方法区只是一个逻辑概念，在 JDK8 之前，HotSpot 用永久代来实现方法区；从 JDK8 开始，类变量则是会随着 Class 对象一起存放在 Java 堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。因为 JDK8 之后，方法区是用元空间实现的，但是类变量和Class对象也没有保存在元空间中。</p>
<hr>
<h3 id="阶段4：Resolve"><a href="#阶段4：Resolve" class="headerlink" title="阶段4：Resolve"></a>阶段4：Resolve</h3><p><strong>解析阶段是虚拟机将常量池内的符号引用转换为直接引用的过程</strong>。</p>
<blockquote>
<p>  <strong>JVM 中的符号引用和直接引用</strong>：</p>
</blockquote>
<ol>
<li><p><strong>符号引用（Symbolic_Reference）</strong>：</p>
<ul>
<li><p>  符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到引用目标即可。</p>
</li>
<li><p>  符号引用与虚拟机实现的内存布局无关。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用都必须一致。因为符号引用的字面量形式明确定义在《Java虚拟机规范》的 Class 文件格式中。</p>
</li>
<li><p>引用目标不一定是已经加载到虚拟机内存中的内容。</p>
<p>  <em>符号引用的目标可能已被来加载器加载到内存中了，也可能没有。因为符号引用只是一种声明，只有在转换成直接引用时才会去真正的把要引用的目标加载到内存中</em></p>
</li>
<li><p>  符号引用在 <code>.class</code> 文件中以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的字面量出现。</p>
</li>
<li><p>  符号引用是一串字面量，所以被保存在常量池中。</p>
</li>
</ul>
<p> ​        <em>在 Java 中，一个类会被编译成一个 <code>.class</code> 文件；在编译时，还不能确定类中引用到的对象的实际地址，因此只能用符号引用来代替。比如 com.example.People 引用了 com.example.Sleep 这个类，在编译时 People 类是不知道 Sleep 这个类或者这个类对应的实例在内存中的实际地址的，因此只能用符号引用 com.example.Sleep（假设是这个，当然实际上是由类似于 CONSTANT_Class_info 的常量来表示的）来表示 Sleep 的地址。</em></p>
</li>
<li><p><strong>直接引用（Direct Reference）</strong>：</p>
<ul>
<li>  直接引用可以是：1、直接指向目标的指针  2、相对偏移量  3、一个能间接定位到目标的句柄。</li>
<li>  直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实现上翻译出来的直接引用一般不会相同。</li>
<li>  <strong>如果有了直接引用，那引用的目标必然已经被加载到虚拟机内存中了</strong>。</li>
</ul>
</li>
<li><p><strong>小结</strong>：</p>
<p> ​        <strong>符号引用是一种声明，而直接引用则是具体的实现</strong>。假设有两个对象 A 和 B，A 依赖了 B（在 A 中使用到了 B）。在符号引用的角度看来是：A 对虚拟机说：我要使用 B 了，但是 B 在哪儿它自己也找不到，它仅仅只是知道 B 的存在。在直接引用的角度看来就是：它找到了 B ，并将 B 的地址给了 A ，这时候 A 才可以真正的使用 B 。</p>
</li>
</ol>
<hr>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，所以虚拟机实现可以根据需要来自行判断。到底是在被类加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</p>
<hr>
<h3 id="阶段5：Initialization"><a href="#阶段5：Initialization" class="headerlink" title="阶段5：Initialization"></a>阶段5：Initialization</h3><p>在 Prepare 阶段时，类变量已经被系统赋过一次零值了；而<strong>在 Initialization 阶段，则会根据开发人员通过程序编码制定的主观计划去初始化类变量和其它资源</strong>。</p>
<p>从另一种角度来看，<strong>Initialization 阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code> 的过程。</strong>[Class Init ]</p>
<blockquote>
<p>  <strong><code>&lt;clinit&gt;()</code> 方法与 <code>&lt;init&gt;()</code> 方法的区别</strong>：</p>
</blockquote>
<ul>
<li><p>  <code>&lt;clinit&gt;()</code> 方法是 javac 编译器通过自动收集类中<strong>所有类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并产生的。（前端）编译器收集的顺序是由语句在源文件中出现的顺序决定的。</p>
</li>
<li><p>  <strong><code>&lt;clinit&gt;()</code> 方法与类的构造器方法不同。</strong>在 JVM 视角中，类的构造方法是 <code>&lt;init&gt;()</code> 方法。</p>
</li>
<li><p>与 <code>&lt;init&gt;()</code> 方法相比，<code>&lt;clinit&gt;()</code> 方法不需要显式地调用父类的<code>&lt;clinit&gt;()</code> 方法，Java <strong>虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的<code>&lt;clinit&gt;()</code> 方法已经执行完毕</strong>。因此在 Java 虚拟机中第一个被执行的 <code>&lt;clinit&gt;()</code> 方法的类型肯定是 java.lang.Object。</p>
<p>  ​    <em><code>&lt;init&gt;()</code> 方法都是需要显式地调用父类的 <code>&lt;init&gt;()</code> 方法的，我们通过构造方法中的 <code>super()</code> 方法去显式地调用父类的 <code>&lt;init&gt;()</code> 方法。当然 <code>spuer()</code> 方法在我们编写代码时可以省略不写，因为它是默认存在的，所以在被 javac 编译后，这个 <code>super()</code> 方法是一定存在的。</em></p>
</li>
<li><p>  由于父类的<code>&lt;clinit&gt;()</code> 方法先执行，这也就意味着<strong>父类中定义的静态语句要优先于子类中静态语句的执行</strong>。</p>
</li>
<li><p>  <code>&lt;clinit&gt;()</code> 方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么（前端）编译器可以不为这个类生成<code>&lt;clinit&gt;()</code> 方法。</p>
</li>
</ul>
<blockquote>
<p>  <strong>Java 虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁同步。</strong> </p>
</blockquote>
<ul>
<li>  原因：<strong>clinit</strong> 方法本质上就是初始化静态变量，但是静态变量在理论上只能被初始化一次。在不加锁的情况下，如果有多个线程同时执行 <strong>clinit</strong> 方法，就会创建出多个相同的静态变量，但是如果加了同步锁，那么无论有多少个线程，每个静态变量都只会被初始化一次。</li>
<li>  如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<code>&lt;clinit&gt;()</code> 方法，其它线程都需要阻塞等待，直到活动线程执行完毕<code>&lt;clinit&gt;()</code> 方法。如果在一个类的<code>&lt;clinit&gt;()</code> 方法有耗时很长的操作，那么就有可能造成多个线程阻塞。</li>
</ul>
<blockquote>
<p>  <strong>静态语句代码块中只能访问到定义在静态语句代码块之前的变量。定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(num);  <span class="comment">// 静态代码块中可以访问到定义在静态代码块之前的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">20</span>;  <span class="comment">// 给定义在静态代码块之后的变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.println(num);    <span class="comment">// 但是引用定义在静态代码块之后的变量编译器会直接提示：“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   num 在 Prepare 阶段就已经分配好内存空间并初始化为零值了，所以在 Initialization 阶段可以在任意位置给其显式地赋值，</span></span><br><span class="line"><span class="comment">* 因为 num 变量一定是存在的，只不过 num 的最终值由最后一次赋值操作决定。</span></span><br><span class="line"><span class="comment">*   而访问语句则应该放到 num 确定最终值之后再进行，如果直接将 num 赋值过程中的某个中间结果暴露给外部访问的话，</span></span><br><span class="line"><span class="comment">* 那得到的结果一定是错误的。</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure>



<p><img src="/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20210701093804902.png" alt="image-20210701093804902"></p>
<hr>
<h1 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3    类加载器"></a>3    类加载器</h1><p>类加载器用于实现类的加载动作，将二进制文件中的类数据加载到内存中生成 Class 对象。<strong>不同的类需要使用不同的类加载器来加载</strong>。</p>
<blockquote>
<p>  <strong>JVM 中判断两个 Class 对象是否为同一个类的两个必要条件？</strong></p>
</blockquote>
<ol>
<li> 类的全限定类名必须一致，包括包名</li>
<li> 加载这个类的 ClassLoader（指ClassLoader 的实例对象）必须相同。</li>
</ol>
<p>换句话说，在 JVM 中，即使这两个类对象（Class 对象）来源于同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相同的。</p>
<blockquote>
<p>  <strong>如果一个类是由用户类加载器加载的，那么 JVM 会将这个类加载器的引用作为 Class 信息的一部分保存在方法区中。</strong></p>
</blockquote>
<ul>
<li>  AppClassLoader 负责将 .class 文件中的类信息加载到方法区中形成一个 Class 对象，除了 .class 文件中的类基本信息， Class 对象中还保存了加载这个类的类加载器的引用信息。</li>
<li>  当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</li>
</ul>
<h2 id="3-1-类加载器分类"><a href="#3-1-类加载器分类" class="headerlink" title="3.1    类加载器分类"></a>3.1    类加载器分类</h2><p>站在 Java 虚拟机的角度来看，只存在两种两种不同的类加载器：1、<strong>启动类加载器（BootStrap ClassLoader）</strong>   2、<strong>自定义类加载器（User-Defined ClassLoader）</strong>。</p>
<table>
<thead>
<tr>
<th align="center">BootStrap ClassLoader</th>
<th align="center">其它</th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用 C++ 语言实现（HotSpot）</td>
<td align="center">使用 Java 语言实现</td>
</tr>
<tr>
<td align="center">内嵌在虚拟机中</td>
<td align="center">独立存在于虚拟机外部</td>
</tr>
<tr>
<td align="center">无父类</td>
<td align="center">全部继承自抽象类 java.lang.ClassLoader</td>
</tr>
</tbody></table>
<p>站在开发人员的角度来看，类加载器的分类要更细致一些，如下图，可分为“<strong>三层类加载器</strong>”。</p>
<img src="/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/类加载器分类-1621267020284.png" alt="类加载器分类" style="zoom: 67%;">





<h3 id="3-1-1-BootStrap-ClassLoader"><a href="#3-1-1-BootStrap-ClassLoader" class="headerlink" title="3.1.1    BootStrap ClassLoader"></a>3.1.1    BootStrap ClassLoader</h3><blockquote>
<p>  启动类加载器；引导类加载器；BootStrap ClassLoader</p>
</blockquote>
<ul>
<li>引导类加载器是用 C++ 语言实现的，内嵌在 JVM 内部。</li>
<li>它负责加载 Java 的核心类库（即存放在 <code>&lt;JAVA_HOME&gt;/jre/lib/rt.jar、resource.jar 或 sun.boot.class.path</code> 路径下的内容）到内存中，用于提供 JRE 运行时需要的类。</li>
<li>并不继承自 <strong>java.lang.ClassLoader</strong> ，没有父类加载器。</li>
<li>可以加载 Extension ClassLoader 和 Application ClassLoader，并指定为它们的父类加载器。</li>
<li>出于安全考虑，BootStrap ClassLoader 只加载包名为 java、javax、sun 等开头的类。</li>
<li>BootStrap ClassLoader 无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那么直接使用 null 代替即可。下图所示就是 <strong>java.lang.Class#getClassLoader()</strong> 方法的代码，其中的注释和代码实现都说明了以 null 值来代表引导类加载器的约定规则。</li>
</ul>
<p><img src="/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20210701102620816.png" alt="image-20210701102620816"></p>
<hr>
<h3 id="3-1-2-Extension-ClassLoader"><a href="#3-1-2-Extension-ClassLoader" class="headerlink" title="3.1.2    Extension ClassLoader"></a>3.1.2    Extension ClassLoader</h3><blockquote>
<p>  扩展类加载器；Extension ClassLoader</p>
</blockquote>
<ul>
<li><p>扩展类加载器是用 Java 语言编写的，由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现。</p>
</li>
<li><p>派生于 ClassLoader</p>
</li>
<li><p>父类加载器为 BootStrap ClassLoader</p>
</li>
<li><p>负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径中的类库。</p>
<p>  <em>JDK 的开发团队允许用户将具有通用性的类库放在 ext 目录下以扩展 JavaSE 的功能。即如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</em></p>
</li>
</ul>
<p>​    </p>
<h3 id="3-1-2-Application-ClassLoader"><a href="#3-1-2-Application-ClassLoader" class="headerlink" title="3.1.2    Application ClassLoader"></a>3.1.2    Application ClassLoader</h3><blockquote>
<p>  应用程序类加载器；系统类加载器；Application ClassLoader</p>
</blockquote>
<ul>
<li><p>Java 语言编写，由 <code>sun.misc.Launcher$AppClassLoader</code> 实现。</p>
</li>
<li><p>派生于 ClassLoader</p>
</li>
<li><p>父类加载器为扩展类加载器</p>
</li>
<li><p>由于 Application ClassLoader 可以通过 <code>java.lang.ClassLoader#getSystemClassLoader()</code> 方法得到，所以该类加载器又被称为“系统类加载器”。</p>
</li>
<li><p>它负责加载用户路径（ClassPath）或系统变量 <code>java.class.path</code> 指定路径下的所有类库。</p>
<p>  <em>ClassPath 一般就是我们开发目录的 src 目录。</em></p>
<p>  <img src="/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20210701103654441.png" alt="image-20210701103654441"></p>
</li>
<li><p><strong>Application ClassLoader 是应用程序默认的类加载器</strong>。如果应用程序中没有自定义过自己的类加载器，一般情况下 Java 应用中自定义的类都是由它来完成加载的。</p>
</li>
</ul>
<hr>
<h3 id="3-1-4-用户自定义类加载器"><a href="#3-1-4-用户自定义类加载器" class="headerlink" title="3.1.4    用户自定义类加载器"></a>3.1.4    用户自定义类加载器</h3><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
<h3 id="3-2-1-为什么要自定义类加载器？"><a href="#3-2-1-为什么要自定义类加载器？" class="headerlink" title="3.2.1    为什么要自定义类加载器？"></a>3.2.1    为什么要自定义类加载器？</h3><ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
<h3 id="3-2-2-用户自定义类加载器实现步骤："><a href="#3-2-2-用户自定义类加载器实现步骤：" class="headerlink" title="3.2.2    用户自定义类加载器实现步骤："></a>3.2.2    用户自定义类加载器实现步骤：</h3><ol>
<li>开发人员可以通过继承抽象类 <code>java.lang.ClassLoader</code> 类的方式，实现自己的类加载器，以满足一些特殊的需求。</li>
<li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 <code>loadClass()</code> 方法，从而实现自定义的类加载器，但是在 JDK1.2 之后已经不再建议用户去覆盖 <code>loadClass()</code> 方法，而是建议把自定义的类加载逻辑写在 <code>findClass()</code> 方法中。</li>
<li>在编写自定义的类加载器时，如果没有太过于复杂的需求，可以直接继承 <strong>URLClassLoader</strong> 类，这样可以避免自己去编写 <code>findClass()</code> 方法及其获取字节流码的方式，使自定义类加载器编写更加简洁。</li>
</ol>
<hr>
<h2 id="3-2-ClassLoader"><a href="#3-2-ClassLoader" class="headerlink" title="3.2    ClassLoader"></a>3.2    ClassLoader</h2><h3 id="3-2-1-关于-ClassLoader"><a href="#3-2-1-关于-ClassLoader" class="headerlink" title="3.2.1    关于 ClassLoader"></a>3.2.1    关于 ClassLoader</h3><ul>
<li>  ClassLoader 类，它是一个抽象类，声明了类加载器对象中共有的方法。</li>
<li>  除了启动类加载器外所有的类加载器都继承自 ClassLoader。</li>
</ul>
<blockquote>
<p>  <strong>常用方法：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public final ClassLoader getParent()</code></td>
<td>获取该类加载器的父类加载器</td>
</tr>
<tr>
<td><code>public Class&lt;?&gt; loadClass(String name)</code></td>
<td>加载指定名称的类，返回该类的 Class 对象实例</td>
</tr>
<tr>
<td><code>protected Class&lt;?&gt; findClass(String name)</code></td>
<td>查找指定名称的类，返回该类的 Class 对象实例</td>
</tr>
<tr>
<td><code>protected final Class&lt;?&gt; findLoadedClass(String name)</code></td>
<td>查找名称为 name 的已经被加载过的类，返回该类的 Class 对象实例</td>
</tr>
<tr>
<td><code>protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)</code></td>
<td>把字节数组b中的内容转换为一个Java类，返回该类的 Class 对象实例</td>
</tr>
<tr>
<td><code>protected final void resolveClass(Class&lt;?&gt; c)</code></td>
<td>连接指定的一个Java类</td>
</tr>
</tbody></table>
<h3 id="3-2-2-获取-ClassLoader-的途径"><a href="#3-2-2-获取-ClassLoader-的途径" class="headerlink" title="3.2.2    获取 ClassLoader 的途径"></a>3.2.2    获取 ClassLoader 的途径</h3><ul>
<li><p>获取某个类的 ClassLoader</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxClass.getClassLoader()</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader;</span><br></pre></td></tr></table></figure>

</li>
<li><p>获取当前线程上下文的 ClassLoader</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure></li>
<li><p>获取系统的 ClassLoader</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure></li>
<li><p>获取调用者的 ClassLoader</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-3-双亲委派机制"><a href="#3-3-双亲委派机制" class="headerlink" title="3.3    双亲委派机制"></a>3.3    双亲委派机制</h2><p>在将某个类的 <code>.class</code> 文件加载到内存中时，JVM 采用的是 <strong>双亲委派模式</strong> 。即把请求交由父类处理，这是一种任务委派模式。</p>
<blockquote>
<p><strong>双亲委派模式的工作原理</strong>：</p>
</blockquote>
<ol>
<li> 如果一个类加载器收到了加载某个类的请求，首先它并不会直接自己尝试去加载这个类，而是把这个请求委托给父类加载器去执行；</li>
<li> 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归。因此所有的加载请求最终都应该传递到最顶层的 BootStrap_ClassLoader 中；</li>
<li> 如果最顶级父类加载器可以完成类加载任务，就加载并返回。如果父类加载器无法完成此加载任务，下一级的子类加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ol>
<p><img src="/2021/06/10/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6-1621267020284.png" alt="双亲委派机制"></p>
<p>双亲委派模型的好处就是 Java 中的类随着它的加载器一起具备了一种优先级的层次关系。例如类 <code>java.lang.Object</code> ，它存放在 <code>rt.jar</code> 中。无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的 <code>BootStrap ClassLoader </code>进行加载，因此 Object 类在程序的各种类加载环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为 <code>java.lang.Object</code> 的类，并放在程序的 ClassPath 中，那么系统中就会出现多个不同的 Object 类，Java 体系中最基础的行为也就无法保证了</p>
<blockquote>
<p><strong>举例</strong></p>
</blockquote>
<ol>
<li> 程序运行时需要使用到 SPI 接口，SPI 接口属于核心API，需要使用双亲委派机制一直到 <code>BootStrapClassLoader</code> 中加载 <code>rt.jar</code>。</li>
<li> SPI 核心类存在大量的接口，这些接口需要具体实现类实现后才能调用其中的方法。而这些方法一般都是第三方 jar 包，不属于核心API，所以就应该由 <code>AppClassLoader</code> 来加载。</li>
<li> 接口是由 <code>BootStrapClassLoader</code> 加载的，而接口的具体实现类是由 <code>ApplicationClassLoader</code> 加载的。</li>
</ol>
<blockquote>
<p><strong>优势</strong></p>
</blockquote>
<ul>
<li><p>避免类重复加载</p>
</li>
<li><p>保护程序安全，防止核心 API 被随意篡改</p>
<p>​    </p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/07/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-07%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/07/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-07%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">JVM——运行时数据区:07对象实例化过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-07 11:34:22" itemprop="dateCreated datePublished" datetime="2021-06-07T11:34:22+08:00">2021-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-01 17:44:49" itemprop="dateModified" datetime="2021-09-01T17:44:49+08:00">2021-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
</blockquote>
<p>对象的创建：</p>
<ul>
<li>  对象分配</li>
<li>  对象内存布局</li>
<li>  对象的访问</li>
</ul>
<h1 id="1-对象的实例化"><a href="#1-对象的实例化" class="headerlink" title="1    对象的实例化"></a>1    对象的实例化</h1><p><img src="/2021/06/07/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-07%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/1623036700337-191886ae-39e7-4254-83c7-77fd7788e9da.jpeg" alt="img"></p>
<h2 id="1-1-创建对象的方式"><a href="#1-1-创建对象的方式" class="headerlink" title="1.1    创建对象的方式"></a>1.1    创建对象的方式</h2><blockquote>
<ol>
<li> <strong>new</strong> </li>
</ol>
</blockquote>
<p>​        使用 new 关键字创建对象本质上是调用对象的构造方法，但是在有些类中构造方法是私有的，这时我们就无法通过new关键字来创建对象了。</p>
<p>​        一般这时候类会提供一个（或多个） <code>public static</code> 修饰的方法，我们可以通过 <code>类名.静态方法</code> 的方式来创建对象。</p>
<p>常见的衍生方式有：</p>
<ul>
<li>  Xxx静态方法</li>
<li>  XxxBuilder静态方法</li>
<li>  XxxFactory静态方法</li>
</ul>
<p>这些静态方法本质上与 new 关键字一致，都是调用类的构造方法。</p>
<blockquote>
<ol start="2">
<li> <strong>Class.newInstance()</strong> </li>
</ol>
</blockquote>
<p>​        <code>Class.newInstance()</code> 方法是通过反射的方式来创建对象，但是这个方法从 JDK9 开始就已经被标记为过时了。其主要原因是：这个方法只能调用空参构造器，并且构造器方法的权限只能是 <code>public</code> 。</p>
<blockquote>
<ol start="3">
<li> <strong>Constructor.newInstance()</strong></li>
</ol>
</blockquote>
<p>​        <code>Constructor.newInstance()</code> 方法也是通过反射的方式来创建对象，这个方法从 JDK9 开始使用，它可以调用空参或带参的构造方法，并且可以调用任何权限的构造方法。</p>
<blockquote>
<ol start="4">
<li> <strong>clone()</strong> </li>
</ol>
</blockquote>
<p>​        通过 <code>clone()</code> 方法创建对象时不会调用任何构造器。但是要求当前类实现 Cloneable 接口，并重写接口中的 clone() 方法。</p>
<blockquote>
<ol start="5">
<li> <strong>反序列化</strong> </li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li> <strong>第三方库</strong> </li>
</ol>
</blockquote>
<hr>
<h2 id="1-2-创建对象的步骤"><a href="#1-2-创建对象的步骤" class="headerlink" title="1.2    创建对象的步骤"></a>1.2    创建对象的步骤</h2><p><img src="/2021/06/07/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-07%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4.png" alt="对象创建步骤"></p>
<h3 id="1、判断对象对应的类是否加载、链接、初始化"><a href="#1、判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1、判断对象对应的类是否加载、链接、初始化"></a>1、判断对象对应的类是否加载、链接、初始化</h3><p>​        虚拟机在执行指令集时遇到了 new 指令后，首先会去检查这个指令的参数能否在方法区的运行时常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过（即判断类元信息是否存在）。如果没有，那么必须先执行相应的类加载过程。</p>
<ul>
<li>  类加载过程：在双亲委派模式下，使用类加载器以 <code>ClassLoader+包名+类名</code> 为Key查找对应的 <code>.class</code> 文件，如果找到文件，则进行类加载，并生成对应的Class对象；如果没有找到文件，则抛出 ClassNotFoundException 异常，。</li>
</ul>
<hr>
<h3 id="2、为对象分配内存"><a href="#2、为对象分配内存" class="headerlink" title="2、为对象分配内存"></a>2、为对象分配内存</h3><p>在类加载检查通过后，接下来虚拟机将会为新生对象分配内存。</p>
<ul>
<li>  首先计算对象所需内存大小，在堆中划分一块内存给该对象。对象所需内存的大小在类加载完成之后便可以确定。</li>
<li>   在新对象的内存空间中，如果对象的成员变量是基本类型数据，则根据数据类型的字节分配内存，如int占4个字节，double占8个字节；如果对象的成员变量是引用数据类型，仅分配引用变量所占的空间即可，即4个字节。</li>
</ul>
<h4 id="内存规整-vs-内存不规整"><a href="#内存规整-vs-内存不规整" class="headerlink" title="内存规整 .vs 内存不规整"></a>内存规整 .vs 内存不规整</h4><p>​        为对象分配内存就是把一块确定大小的内存块从Java堆中划分出来。</p>
<blockquote>
<p>  <strong>指针碰撞（Bump The Pointer）</strong></p>
</blockquote>
<p>假设Java堆中的内存是绝对规整的，即所有被使用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为两块内存分界点的指示器，那么分配内存仅仅就是将指针向空闲的那边移动一段与新对象大小相等的距离罢了。这种分配方式称为<strong>指针碰撞法（Bump The Pointer）</strong></p>
<blockquote>
<p>  <strong>空闲列表（Free List）</strong></p>
</blockquote>
<p>如果Java堆中的内存并不是规整的，即已被使用的内存和空闲的内存互相交错，那么虚拟机就无法进行简单的指针碰撞了，虚拟机必须维护一个列表，记录内存中哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。这种分配方式称为<strong>空闲列表（FreeList）</strong>。</p>
<p>​        </p>
<p>​        选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由虚拟机具体的落地产品所采用的垃圾收集器是否带有压缩整理（Compact）的功能决定。因此，如果虚拟机使用的是 Serial、ParNew 这种基于压缩算法的垃圾收集器时，虚拟机采用的对象分配方式就是指针碰撞。而如果虚拟机使用的是 CMS 这种基于清除（Sweep）算法的垃圾收集器时，理论上就只能使用空闲列表方式来为对象分配内存。</p>
<hr>
<h3 id="3、处理线程安全问题"><a href="#3、处理线程安全问题" class="headerlink" title="3、处理线程安全问题"></a>3、处理线程安全问题</h3><p>​        创建对象在虚拟机中是一个非常频繁的行为，创建后的对象保存在堆空间中，而堆空间又是多个线程共享的，所以说创建对象的行为在并发情况下并不是线程安全的。</p>
<p>​        使用空闲列表或指针碰撞方法给对象分配内存时，每个对象的首地址值都会被记录。可能出现正在给对象A分配内存空间，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p>​        解决这个问题主要有2种方案：</p>
<ol>
<li>一种是对分配内存空间的动作进行同步处理。<ul>
<li>  实际上，HotSpot 虚拟机通过采用 CAS 配上失败重试的方式保证对象分配内存的原子性。</li>
</ul>
</li>
<li>另一种是把内存分配的动作按照线程划分在不同的空间中进行。<ul>
<li>  即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区（TLAB），哪个线程创建对象时要分配内存，就在哪个线程的TLAB中分配一块内存给实例对象，只有TLAB内存满了，给新的实例对象分配内存时才会需要进行同步锁定。</li>
<li>  虚拟机是否开启使用TLAB，可以通过参数 <code>-XX:+/UserTLAB</code> 来设定。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4、初始化对象的内存空间（默认初始化）"><a href="#4、初始化对象的内存空间（默认初始化）" class="headerlink" title="4、初始化对象的内存空间（默认初始化）"></a>4、初始化对象的内存空间（默认初始化）</h3><p>​        内存分配完毕之后，虚拟机必须先将分配到的内存空间（但不包括对象头）都初始化为零值。如果使用了 TLAB 的话，这一项工作也会提前到 TLAB 分配内存空间时顺便进行。这步操作保证了对象的实例字段在Java代码中不赋初值就可以直接使用，使程序能访问到这些字段的数据类型对应的零值。</p>
<hr>
<h3 id="5、设置对象的对象头"><a href="#5、设置对象的对象头" class="headerlink" title="5、设置对象的对象头"></a>5、设置对象的对象头</h3><p>​        接下来，Java虚拟机还会对对象进行必要的设置。例如这个对象是哪个类的实例、如何才能找到对象的元数据信息、对象的哈希码（实际上对象的 HashCode 会延后到真正调用 Object::hashCode() 方法时才计算）、对象的GC分代年龄等信息。根据虚拟机当前运行状态的不同，如是否启用偏向锁等。这些信息存放在对象的对象头（Object Header）中。</p>
<hr>
<h3 id="6、执行init方法进行初始化（显式初始化）"><a href="#6、执行init方法进行初始化（显式初始化）" class="headerlink" title="6、执行init方法进行初始化（显式初始化）"></a>6、执行init方法进行初始化（显式初始化）</h3><p>​        在上面的工作都完成之后，从虚拟机视角来看，一个新的对象就已经产生了。但是从开发者的视角来看，对象的创建才刚刚开始——构造函数，即 Class 文件中的 <code>&lt;init&gt;()</code> 方法还没有执行，所有的字段都还只有一个默认零值。一般来说，new 指令之后会接着执行 <code>&lt;init&gt;()</code> 方法，按照开发者的意愿对对象进行初始化，这样一个真正可用的对象才算被完全构造出来。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给对象属性赋值的操作：</span><br><span class="line">1、默认初始化</span><br><span class="line">--&gt;&gt;</span><br><span class="line">2、显示初始化/静态代码块初始化        // 显式初始化和静态代码块初始化处于同一级别，真正决定它俩谁先执行的因素是在代码中的顺序，谁在前面谁先执行。</span><br><span class="line">--&gt;&gt;</span><br><span class="line">3、构造器中初始化</span><br><span class="line">--&gt;&gt;</span><br><span class="line">4、根据对象的公共属性或set方法赋值</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2    对象的内存布局"></a>2    对象的内存布局</h1><blockquote>
<p>  对象在堆空间中的内存布局：</p>
<p>  可分为3部分：1、对象头  2、实例数据  3、对齐填充</p>
</blockquote>
<p><img src="/2021/06/07/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-07%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%84%91%E5%9B%BE.png"></p>
<h2 id="2-1-对象头（Header）"><a href="#2-1-对象头（Header）" class="headerlink" title="2.1    对象头（Header）"></a>2.1    对象头（Header）</h2><blockquote>
<ol>
<li> <strong>运行时元数据（Mark Word）</strong></li>
</ol>
</blockquote>
<p>​        用于存储对象自身的运行时数据。这部分数据的长度在32位和64位的虚拟机中分别为 32bit 和 64bit 。常见的保存的数据有：</p>
<ul>
<li>  <em>哈希值（HashCode）</em>：new出来的对象保存在堆中，有时候我们在栈中使用对象的时候需要得到这个对象在堆空间中的地址，这个地址值就是 <code>对象头.运行时元数据.哈希值</code>，也叫做对象的首地址值。</li>
<li>  <em>GC分代年龄</em>：对象中保存了从年轻代晋升到老年代的年龄的阈值。</li>
<li>  <em>锁状态标志</em>：标志了当前对象是否是一个锁对象。</li>
<li>  <em>线程持有的锁</em></li>
<li>  <em>偏向线程ID</em></li>
<li>  <em>偏向时间戳</em></li>
<li>  <em>……</em></li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>类型指针</strong>：</li>
</ol>
</blockquote>
<p>​        对象头的另一部分数据是类型指针，即对象指向它的类型元数据的指针。Java虚拟机通过这个指针来确定该对象是哪个类的实例。如 <code>obj.getClass()</code> 方法就是通过这个指针才可以根据对象定位到对象的类型信息。但是并不是所有的虚拟机实现都会在实例对象的对象头数据中保留类型指针。也就是说，查找对象的元数据信息并不一定要经过对象本身。</p>
<blockquote>
<ol start="3">
<li> <strong>数组长度</strong></li>
</ol>
</blockquote>
<p>​        如果对象是一个数组，那么在对象头中还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，进而可以确定分配给该对象的堆内存空间大小。但对于数组对象，如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组对象的大小，所以在对象头中加上一个数组长度借此就可以推断出数组对象占用的堆内存大小了。</p>
<hr>
<h2 id="2-2-实例数据（Instance-Data）"><a href="#2-2-实例数据（Instance-Data）" class="headerlink" title="2.2    实例数据（Instance Data）"></a>2.2    实例数据（Instance Data）</h2><p>​        <strong>实例数据部分保存的是对象真正存储的有效信息</strong>。即开发人员在代码中定义的各种类型的字段内容，<em>无论是从父类继承下来的，还是在当前类中定义的字段都必须记录起来。</em></p>
<p>​        这部分数据的存储顺序会受到虚拟机分配策略参数 <code>-XX:FieldAllocationStyle</code> 和字段在Java源码中定义顺序的影响。</p>
<ul>
<li>  HotSpot 虚拟机默认的分配顺序为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span>/<span class="type">double</span> &gt; <span class="type">int</span> &gt; <span class="type">short</span> &gt; <span class="type">char</span> &gt; <span class="type">byte</span>/<span class="type">boolean</span> &gt; oops(Ordinary Object Points)</span><br></pre></td></tr></table></figure>

<p>​        从以上默认的分配策略中可以看出，<em>相同宽度的字段总是被分配到一起存放。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</em></p>
<hr>
<h2 id="2-3-对齐填充（Padding）"><a href="#2-3-对齐填充（Padding）" class="headerlink" title="2.3    对齐填充（Padding）"></a>2.3    对齐填充（Padding）</h2><p>​        对象的第三部分是对齐填充，对齐填充不是必须的，仅仅起到占位填充的作用。由于 HotSpot 的自动内存管理系统要求对象的起始地址必须是 8 字节的整数倍，即任何对象的大小都必须是 8 字节的整数倍。由于对象头部分已经被精心设计为正好是 8 字节的整数倍，因此，如果对象的实例数据部分没有达到 8 字节的整数倍的话，就需要通过对齐填充来进行补全。</p>
<hr>
<hr>
<h1 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3    对象的访问定位"></a>3    对象的访问定位</h1><p>​        创建对象自然是为了后续使用该对象，我们在Java程序中会通过栈上的 reference 数据来访问堆上的具体对象。在《Java虚拟机规范》中，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问的方式是由具体的虚拟机实现来确定的。主流的访问方式主要有<strong>句柄访问</strong>和<strong>直接指针访问</strong>两种。</p>
<h2 id="句柄访问-vs-直接指针访问"><a href="#句柄访问-vs-直接指针访问" class="headerlink" title="句柄访问 .vs 直接指针访问"></a>句柄访问 .vs 直接指针访问</h2><blockquote>
<p>  <strong>句柄访问</strong></p>
</blockquote>
<p>​        句柄访问就是在Java堆区中划分出一块内存作为句柄池，<code>栈帧.局部变量表.reference</code> 中保存的就是对象的句柄地址，而句柄中包含了对象的实例数据地址信息和对象的类型数据的地址信息。 </p>
<p><img src="/2021/06/07/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-07%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt="句柄访问"></p>
<blockquote>
<p>  <strong>直接指针访问</strong></p>
</blockquote>
<p>​        如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何保存到对象类型数据的指针，如通过在对象头中保留类型指针来访问类型信息。而 reference 中存储的直接就是实例对象的地址，当然这时如果只是访问实例对象本身的话，就不需要多一次间接访问句柄池的开销。</p>
<p><img src="/2021/06/07/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-07%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png"></p>
<blockquote>
<p>  <strong>对比</strong></p>
</blockquote>
<p>​        这两种对象访问方式各有优势。</p>
<ul>
<li>  使用句柄访问最大的好处就是 reference 中存储的是稳定句柄地址，在对象被移动（GC时移动对象是很普遍的行为）时只需改变句柄池中实例数据指针即可，而 reference 本身不需修改。</li>
<li>  使用直接指针访问最大的优点就是速度更快，它节省了一次指针定位的时间开销（即reference指针定位句柄池的时间开销），由于对象访问在程序运行时十分频繁，因此这类开销积少成多也是一项极为可观的执行成本。</li>
</ul>
<p>就 HotSpot 而言，它主要使用的是<strong>直接指针访问</strong>，但有极少部分对象也使用了句柄访问。</p>
<hr>
<h1 id="4-对象创建过程举例"><a href="#4-对象创建过程举例" class="headerlink" title="4    对象创建过程举例"></a>4    对象创建过程举例</h1><blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Department</span> <span class="variable">dep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String depId;</span><br><span class="line">    <span class="keyword">private</span> String depName;</span><br><span class="line">    <span class="keyword">private</span> Employee employee;</span><br><span class="line">	<span class="comment">// get/set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>分析</strong></p>
</blockquote>
<ol>
<li> 程序开始执行，<code>main()</code> 方法对应的栈帧入栈。</li>
<li> 依次执行栈帧中的指令，直到遇到 new 指令，这时，首先根据指令后的符号引用定位到运行时常量池中的 <code>Department</code> 类，并检测到这个类已经被加载、解析和初始化过，然后根据元数据信息推断出该类对应的实例对象占用的内存大小。</li>
<li> 在堆空间中为 <code>dep</code> 对象分配内存空间，执行默认初始化（赋零值），更新栈帧中局部变量表的值，新增<code>dep</code>对象在堆内存中的地址指针。（栈帧的局部变量表中的地址值即为堆内存中对象的对象头中的哈希值。）</li>
<li> 执行显式初始化（即构造函数初始化），发现在 <code>dep</code>对象中还包含一个 <code>emp</code> 对象，这时需要以递归的方式执行创建对象的过程，即堆空间中再开辟一块空间用于保存 <code>emp</code> 对象。</li>
<li> 完毕。</li>
</ol>
<ul>
<li>  对象头中的类型指针保存的是方法区中对象对应的类型信息。</li>
</ul>
<p><img src="/2021/06/07/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-07%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="对象的内存布局"></p>
<h1 id="5-面试题"><a href="#5-面试题" class="headerlink" title="5    面试题"></a>5    面试题</h1><blockquote>
<p>  面试题</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">美团：</span><br><span class="line">    对象在JVM中是怎么存储的？</span><br><span class="line">    对象头信息里面有哪些东西？</span><br><span class="line"></span><br><span class="line">蚂蚁金服：</span><br><span class="line">    Java对象头里有什么？</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  问题：如何通过栈帧中的对象引用访问到堆内存空间中真正的实例对象呢？</p>
</blockquote>
<p>答：栈帧中的局部变量表中保存了对象在堆空间中的真实地址，通过这个地址可以访问到真正的对象。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-06%E6%96%B9%E6%B3%95%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-06%E6%96%B9%E6%B3%95%E5%8C%BA/" class="post-title-link" itemprop="url">JVM——运行时数据区:06方法区</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 10:18:07" itemprop="dateCreated datePublished" datetime="2021-06-02T10:18:07+08:00">2021-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 21:18:22" itemprop="dateModified" datetime="2021-08-03T21:18:22+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>方法区；Method Area</strong></p>
</blockquote>
<h1 id="1-栈、堆、方法区三者之间的交互关系"><a href="#1-栈、堆、方法区三者之间的交互关系" class="headerlink" title="1    栈、堆、方法区三者之间的交互关系"></a>1    栈、堆、方法区三者之间的交互关系</h1><p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-06%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210524212516071.png" alt="image-20210524212516071"></p>
<p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-06%E6%96%B9%E6%B3%95%E5%8C%BA/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E4%BA%A4%E4%BA%92.png" alt="运行时数据区交互"></p>
<hr>
<h1 id="2-方法区的理解"><a href="#2-方法区的理解" class="headerlink" title="2    方法区的理解"></a>2    方法区的理解</h1><p>《Java虚拟机规范》中明确规定：方法区在<strong>逻辑</strong>上是属于堆的一部分，但在一些 JVM 的落地产品中，方法区并不属于堆区的一部分。    对于 HotSpot 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。</p>
<p>所以，<strong>方法区可以看做是一块独立于Java堆的内存空间</strong>。</p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动时被创建，它的实际物理内存空间和堆区一样都是可以不连续的。</li>
<li>方法区的大小，跟堆区一样，可以选择<strong>固定大小</strong>或<strong>自适应大小</strong>。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<strong>java.lang.OutOfMemoryError: PermGen spaca</strong> 或者 <strong>java.lang.OutOfMemoryError: Metaspace</strong></li>
<li>关闭JVM就会释放方法区的内存。</li>
</ul>
<hr>
<h2 id="HotSpot中方法区的演变"><a href="#HotSpot中方法区的演变" class="headerlink" title="HotSpot中方法区的演变"></a>HotSpot中方法区的演变</h2><ul>
<li>从 JDK8 开始，HotSpot 完全废弃了<strong>永久代</strong>的概念，改成了与 JRockit、J9 一样在本地内存中实现的<strong>元空间（Metaspace）</strong>。</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间占用的不是JVM虚拟机的内存空间，而是本地内存</strong>。</li>
<li>永久代和元空间二者不只是名字变了，而且内存结构也调整了。</li>
<li>《Java虚拟机规范》中规定，如果方法区无法满足新的内存分配需求时，将会抛出OOM异常。</li>
</ul>
<hr>
<h1 id="3-设置方法区大小"><a href="#3-设置方法区大小" class="headerlink" title="3    设置方法区大小"></a>3    设置方法区大小</h1><p>方法区的大小不是固定的，JVM虚拟机可以根据实际需要动态调整。</p>
<blockquote>
<p><strong>在 JDK8 之前：</strong></p>
</blockquote>
<ul>
<li>通过 <code>-XX:PermSize</code> 来设置永久代的初始分配的内存空间，默认值是 20.75M 。</li>
<li>通过 <code>-XX:MaxPermSize</code> 来设置永久代的最大可用的内存空间，32位机器的默认值是 64M ，64位机器的默认值是 82M 。</li>
<li>当 JVM 加载的类信息的容量超过了最大可用内存空间时，就会抛出OOM异常： <code>OutOfMemoryError:PermGen space</code> 。</li>
</ul>
<blockquote>
<p><strong>从 JDK8 开始：</strong></p>
</blockquote>
<ul>
<li>元数据区的初始内存大小和最大内存大小可以使用<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 来查看或指定。</li>
<li>这两个参数的默认值依赖于平台。在 Win 下的缺省值分别为：<code>-XX:MetaspaceSize=21M</code> 和 <code>-XX:MaxMetaspaceSize=-1</code> ，-1表示没有限制。</li>
<li>与永久代不同，如果不指定元空间的大小，默认情况下，元空间会耗尽所有可用的系统内存。如果元空间发生溢出，虚拟机一样会抛出 OOM 异常。</li>
<li><code>-XX:MetaspaceSize</code>：该参数用于设置初始元空间的大小，对于一个64位服务器上的JVM来说，默认值为 <code>-XX:MetaspaceSize=21M</code>。这就是初始的<strong>高水位线</strong>，一旦元空间的内存达到这个水位线，就会触发 Full GC ，回收已失效的类（如果一个类对应的类加载器对象不再存活即为已失效的类），并重置高水位线的值，新的高水位线值取决于GC后释放了多少元空间。如果释放的空间不足，那么新的高水位线值在不超过 <code>MaxMetaspaceSize</code> 的情况下会适当提高；如果释放的空间过多，那么新的高水位线值在不超过 <code>MaxMetaspaceSize</code> 的情况下会适当降低。</li>
<li>如果初始的高水位线设置过低，上述高水位线调整的情况就会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 被多次调用，为了避免频繁的GC，建议将 <code>XX:MaxMetaspaceSize</code>设置为一个相对较高的值。</li>
</ul>
<hr>
<h1 id="4-方法区的内部结构"><a href="#4-方法区的内部结构" class="headerlink" title="4    方法区的内部结构"></a>4    方法区的内部结构</h1><p><strong>问题：方法区中存储什么？</strong></p>
<p>方法区用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<blockquote>
<ul>
<li>类型信息</li>
<li>域信息</li>
<li>方法信息</li>
<li>静态变量</li>
<li>运行时常量池</li>
<li>JIT代码缓存</li>
</ul>
</blockquote>
<h2 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h2><p>对每个加载的类型（类Class、接口Interface、枚举Enum、注解Annotation），JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li><p>这个类型的全限定类名。</p>
</li>
<li><p>这个类型直接父类的全限定类名（对于 Interface 或 java.lang.Object ，都没有父类）。</p>
</li>
<li><p>这个类型的修饰符集合（public、abstract、final 的某个子集）。</p>
</li>
<li><p>这个类型直接实现的接口的一个有序列表。</p>
<p> 说明：接口是可以多实现的。如现有 Class A ，它可以同时实现 Interface B 和 Interface C ，即 <code>class A implements B,C</code> ，所以说 Class A 所有实现的接口是一个列表，Interface B 保存在列表索引为0的位置上，Interface C 保存在列表索引为1的位置上。</p>
</li>
</ol>
<hr>
<h2 id="域信息（Field）"><a href="#域信息（Field）" class="headerlink" title="域信息（Field）"></a>域信息（Field）</h2><blockquote>
<p>域信息；Field；成员变量；</p>
</blockquote>
<ul>
<li>JVM 必须在方法区中保存类型中所有的域信息以及域的声明顺序。</li>
<li>域的相关信息包括：<ol>
<li>域名称</li>
<li>域类型（数据类型）</li>
<li>域修饰符（ [public、private、protected、static、final、volatile、transient] 中的某个子集）</li>
</ol>
</li>
</ul>
<hr>
<h2 id="方法信息（Method）"><a href="#方法信息（Method）" class="headerlink" title="方法信息（Method）"></a>方法信息（Method）</h2><p>JVM 必须在方法区中保存类型中所有方法的以下信息包括声明顺序：</p>
<ul>
<li><p>方法名称</p>
</li>
<li><p>方法的返回类型（包括 void）</p>
</li>
<li><p>方法参数的数量和类型（保存在数组中，按顺序存储）</p>
</li>
<li><p>方法的修饰符集合（[public、private、protected、static、final、synchronized、native、abstract] 的一个子集）</p>
</li>
<li><p>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</p>
</li>
<li><p>异常表（abstract 和 native 方法除外）</p>
</li>
<li><ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常的常量池索引   </li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java 源代码中如果没有显式声明构造方法就会使用JVM默认提供的无参构造方法；</span><br><span class="line">JVM 提供的默认构造方法在源代码被编译成字节码文件后就已经存在了。</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p>静态变量和类关联在一起，随着类的加载而加载，静态变量被称为类数据在逻辑上的一部分。</p>
<p>类变量被类的所有实例共享，即使没有类实例时你也可以访问它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        a.hello();</span><br><span class="line">        System.out.println(a.count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ---------------------结果：</span></span><br><span class="line"><span class="comment">   不会报错，即使让实例对象指向 null 也不会报错，因为类变量是直接从线程共享的方法区取出来的数据。</span></span><br><span class="line"><span class="comment">     hello</span></span><br><span class="line"><span class="comment">     1</span></span><br><span class="line"><span class="comment"> ---------------------结果分析：</span></span><br><span class="line"><span class="comment">     即使没有类实例，也可以访问类变量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="补充说明：全局常量-static-final"><a href="#补充说明：全局常量-static-final" class="headerlink" title="补充说明：全局常量[ static+final ]"></a>补充说明：全局常量[ static+final ]</h3><p>被声明为 final 的类变量的处理方法则不同，每个全局变量在编译的时候就会被分配了。即在字节码文件中就已经被确定下来了，可以认为是一个常量。</p>
<hr>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><h3 id="运行时常量池-vs-常量池"><a href="#运行时常量池-vs-常量池" class="headerlink" title="运行时常量池 vs. 常量池"></a>运行时常量池 vs. 常量池</h3><ul>
<li>字节码文件，内部包含了常量池。</li>
<li>方法区，内部包含了运行时常量池。</li>
<li>字节码文件中包含了常量池，通过类加载器将这个常量池加载到方法区中就变成了运行时常量池。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚<code>.class</code>字节码文件中的常量池。</li>
</ul>
<h3 id="class-字节码文件"><a href="#class-字节码文件" class="headerlink" title=".class 字节码文件"></a>.class 字节码文件</h3><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），里面包括各种字面量，和对类型、域和方法的<strong>符号引用</strong>。</p>
<p>常量池中呈现出来的都是符号引用，而真正执行程序时，字节码文件中的<strong>符号引用</strong>在被加载到方法区之后会被转化成<strong>直接引用</strong>。</p>
<h3 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池 ?"></a>为什么需要常量池 ?</h3><ul>
<li>  一个<code>.java</code>源程序编译后会产生一个（或多个） <code>.class</code>字节码文件，而字节码文件除了自身内部定义的信息外，还需要加载父类（或接口）中的数据，以及类内部对象及其父类的数据，所以说一个字节码文件通常需要加载很多类的数据。</li>
<li>  如果直接把这些数据保存到一个字节码文件中，该文件就会很大且需要在每个使用到类的字节码文件都需要保存一遍，达不到复用的效果。</li>
<li>  所以在 JVM 中我们会把关于引用数据的字符引用保存到常量池中，每个字节码文件在使用引用类时只需记录符号引用即可，在程序运行时通过动态链接会将符号引用转变成指向运行时常量池的直接引用即可。</li>
<li>  关于这些符号引用保存在常量池中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        比如上面这段代码，在硬盘中占的内存只有几百字节，但是里面却还使用了 String、System、PrintStream、Object 等类型及其相关类型。如果把要使用的相关类型都编译到字节码文件中去，显然字节码文件将会非常大。为了避免这种情况，就需要使用到常量池了。常量池中保存的也不是对应的相关类型，而只是指向对应相关类型的地址值。</p>
<blockquote>
<p>  <strong>常量池的好处：</strong></p>
</blockquote>
<ol>
<li> 可以复用。在常量池中只需定义一次，在其它地方需要使用时直接使用地址值访问即可。</li>
</ol>
<hr>
<h3 id="常量池中有什么？"><a href="#常量池中有什么？" class="headerlink" title="常量池中有什么？"></a>常量池中有什么？</h3><blockquote>
<p>  <strong>常量池中常见的数据类型信息：</strong></p>
</blockquote>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类型引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的 类名、方法名、参数类型、  字面量 等信息</p>
<hr>
<h2 id="JIT-代码缓存"><a href="#JIT-代码缓存" class="headerlink" title="JIT 代码缓存"></a>JIT 代码缓存</h2><hr>
<h1 id="5-方法区的演变"><a href="#5-方法区的演变" class="headerlink" title="5    方法区的演变"></a>5    方法区的演变</h1><p>​    首先明确一点，只有 HotSpot 才有”永久代”的概念。对于 JRockit、J9 等虚拟机来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机的实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
<h2 id="HotSpot中方法区的演变过程"><a href="#HotSpot中方法区的演变过程" class="headerlink" title="HotSpot中方法区的演变过程"></a>HotSpot中方法区的演变过程</h2><ul>
<li>在 JDK8 以前，把方法区称为<strong>永久代</strong>。从 JDK8 开始，使用<strong>元空间</strong>取代了永久代。</li>
<li><strong>理论上，方法区和永久代并不等价</strong>。《Java虚拟机规范》对如何实现方法区并没有做统一的要求，例如：Jrockit，J9 中都不存在永久代的概念。<strong>但是在HotSpot虚拟机中，我们可以认为方法区就是永久代</strong> </li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>JDK之前</td>
<td>有永久代（Permanent Generation），静态变量存放在永久代中</td>
</tr>
<tr>
<td>JDK7</td>
<td>有永久代，但已经逐步“去永久代”，将字符串常量池、静态变量保存在堆中</td>
</tr>
<tr>
<td>JDK8开始</td>
<td>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间中，但字符串常量池、静态变量却保存在堆中</td>
</tr>
</tbody></table>
<hr>
<h2 id="永久代为什么要被元空间替换-？"><a href="#永久代为什么要被元空间替换-？" class="headerlink" title="永久代为什么要被元空间替换 ？"></a>永久代为什么要被元空间替换 ？</h2><blockquote>
<p>  官方解释：因为Oracle公司在2008年收购了JRockit。而在JRockit虚拟机中是没有永久代这一概念的，JRockit使用的是元空间。在融合JRockit和HotSpot这两个虚拟机的过程中，Oracle规定了统一使用元空间。</p>
</blockquote>
<p>在Java8中，HotSpot虚拟机中的永久代彻底被移除了，相应的，原来保存在永久代中的数据被移到了一个<strong>与虚拟机空间不相关的本地内存区域——元空间（MetaSpace）</strong>。</p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用的内存空间。</p>
<p>这项改动是很有必要的，原因是：</p>
<ol>
<li>永久代的空间大小是很难确定的。<ul>
<li>  在某些场景下，如果动态加载的类过多，就很容易产生永久代空间的OOM。比如某个大型的Web工程，在运行过程中需要动态的加载很多类，就很有可能会出现OOM异常。</li>
<li>  而永久代和元空间之间的最大区别自安于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</li>
</ul>
</li>
<li> 对永久代进行调优是非常困难的。</li>
</ol>
<hr>
<h2 id="字符串常量池（String-Table）为什么要调整？"><a href="#字符串常量池（String-Table）为什么要调整？" class="headerlink" title="字符串常量池（String Table）为什么要调整？"></a>字符串常量池（String Table）为什么要调整？</h2><p>JDK7 将 StringTable 从永久代移动到了堆空间中。因为永久代的回收效率很低，只有触发 Full GC 的时候才会回收，而只有老年代或永久代空间不足时才会触发 Full GC 。</p>
<p>这就导致了 StringTable 回收效率很低，而我们在开发过程中会有大量的字符串被创建，回收效率低就会导致永久代内存不足。放到堆里就能及时回收内存。</p>
<hr>
<h2 id="不同版本下静态引用在内存中位置"><a href="#不同版本下静态引用在内存中位置" class="headerlink" title="不同版本下静态引用在内存中位置"></a>不同版本下静态引用在内存中位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    结论：</span></span><br><span class="line"><span class="comment">        1、静态引用对应的对象实体始终都保存在堆空间。</span></span><br><span class="line"><span class="comment">        2、而静态引用保存的位置则随着JDK版本的不同而不同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">100</span>];    <span class="comment">// 100MB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="7-方法区的垃圾回收"><a href="#7-方法区的垃圾回收" class="headerlink" title="7    方法区的垃圾回收"></a>7    方法区的垃圾回收</h1><p>​        《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现GC。事实上也确实有未实现或未能完整实现方法区类型卸载的虚拟机存在（例如 JDK11 时期的 ZGC 收集器就不支持类型卸载）。</p>
<p>​        有些人认为方法区是没有垃圾收集行为的，其实不然。一般来说<strong>方法区的垃圾回收效果比较难以令人满意，尤其是类型的卸载，条件相当苛刻。但是这个区域的GC又确实是有必要的</strong>。以前Sun公司的Bug列表中，曾出现过若干个严重的Bug就是由于低版本的HotSpot虚拟机在对方法区进行GC时未完全回收到所有失效数据而导致内存泄露。</p>
<blockquote>
<p>  <strong>方法区的GC主要回收两部分内容：</strong></p>
</blockquote>
<ol>
<li> <strong>常量池中废弃的常量</strong>。</li>
<li> <strong>不再使用的类型</strong>。</li>
</ol>
<blockquote>
<p>  <strong>废弃常量：</strong></p>
</blockquote>
<p>方法区的常量池之中主要存放两大类常量：字面量和符号引用</p>
<ul>
<li>  字面量是比较接近Java语言层次常量的概念，如：文本字符串、被声明为final的常量值等。</li>
<li>而符号引用则属于编译原理方面的概念，包括以下三类常量：<ol>
<li> 类和接口的全限定类名</li>
<li> 字段的名称和描述符</li>
<li> 方法的名称和描述符</li>
</ol>
</li>
<li>  HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量在任何地方都不再被引用，就可以被回收</strong>。</li>
<li>  回收废弃常量与回收Java堆中的对象非常类似。</li>
</ul>
<blockquote>
<p>  <strong>废弃类型：</strong></p>
</blockquote>
<p>判断一个常量是否“废弃”比较简单，而要判断一个类型是否属于“不再被使用的类”条件就非常苛刻了。需要同时满足以下三个条件：</p>
<ol>
<li> 该类所有实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li> 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景。如 OSGI、JSP 的重加载等，否则通常是很难达成的。</li>
<li> 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<p>​        JVM 虚拟机允许满足上述三个条件的类进行回收，但也仅仅是“允许”，而不是必然。关于是否要对类型进行回收，HotSpot虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:+TraceClassUnLoading</code> 查看类加载和卸载信息。</p>
<p>​        在大量使用反射、动态代理、CGLib 等字节码的框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<hr>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8    总结"></a>8    总结</h1><h2 id="运行时数据区：常见面试题"><a href="#运行时数据区：常见面试题" class="headerlink" title="运行时数据区：常见面试题"></a>运行时数据区：常见面试题</h2><ul>
<li>  百度</li>
</ul>
<p>JVM内存模型，有哪些区？分别干什么的？</p>
<ul>
<li>  蚂蚁金服</li>
</ul>
<p>Java8 的内存分代改进？</p>
<p>JVM内存分哪些区？每个区的作用是什么？</p>
<p>JVM内存分布/内存机构？堆和栈的区别？堆的结构？为什么两个Survivor区？</p>
<p>Eden和Survivor的比例分配？</p>
<ul>
<li>  小米</li>
</ul>
<p>JVM内存分区，为什么要有新生代和老年代？</p>
<ul>
<li>  字节跳动</li>
</ul>
<p>Java的内存分区？</p>
<p>JVM运行时数据区？</p>
<p>什么时候对象会进入老年代？</p>
<ul>
<li>  京东</li>
</ul>
<p>JVM内存结构，Eden和Survivor比例？</p>
<p>JVM内存为什么要分成新生代、老年代、永久代。新生代中为什么要分成Eden和Survivor？</p>
<ul>
<li>  天猫</li>
</ul>
<p>JVM内存模型以及分区，需要详细到每个区放什么？</p>
<p>JVM的内存模型，Java8 做了什么修改？</p>
<ul>
<li>  拼多多</li>
</ul>
<p>JVM内存分哪几个区？每个区的作用是什么？</p>
<ul>
<li>  美团</li>
</ul>
<p>Java内存分配？</p>
<p>JVM的永久代中会发生垃圾回收吗？</p>
<p>JVM内存分区，为什么要有新生代和老年代？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/" class="post-title-link" itemprop="url">JVM——运行时数据区:05堆</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-02 10:17:58" itemprop="dateCreated datePublished" datetime="2021-06-02T10:17:58+08:00">2021-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 20:13:09" itemprop="dateModified" datetime="2021-08-03T20:13:09+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-堆的核心概述（Heap）"><a href="#1-堆的核心概述（Heap）" class="headerlink" title="1    堆的核心概述（Heap）"></a>1    堆的核心概述（Heap）</h1><ul>
<li>堆空间用于存储Java对象实例。</li>
<li>一个 JVM 进程只存在一个堆空间，该进程下的所有线程共享该堆空空间。</li>
<li>《Java虚拟机规范》规定，<strong>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</strong>。</li>
<li>堆区空间在JVM启动时就被创建出来了，并且在创建时就已经确定好了其空间的大小。</li>
<li>堆空间是JVM内存中最大的一块空间。</li>
<li>堆空间的大小是可以调节的。</li>
<li><strong>堆空间中还可以划分出线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</strong> </li>
<li>“几乎”所有的对象实例以及数组都应当在运行时分配在堆上。</li>
<li>数组和对象可能永远不会存储在栈中，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>在方法结束后，堆中的对象并不会马上被移除，仅仅在GC时才会被移除。</li>
<li>堆是GC执行垃圾回收的重点区域。</li>
</ul>
<h2 id="堆空间的内存布局"><a href="#堆空间的内存布局" class="headerlink" title="堆空间的内存布局"></a>堆空间的内存布局</h2><p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E7%A9%BA%E9%97%B4.png" alt="堆空间"></p>
<p>现代垃圾回收器大部分都基于<strong>分代收集理论</strong>设计，堆空间细分为：</p>
<blockquote>
<p><strong>Java8 之前</strong>堆空间在逻辑上分为三部分：<strong>年轻代 + 老年代 + 永久代</strong></p>
</blockquote>
<ul>
<li>Young Generation Space  年轻代   Young/New</li>
<li>新生代又可划分为 Eden 区和 Survivor 区</li>
<li>Tenure generation space  老年代    Old/Tenure</li>
<li>Permanent Space        永久代    Perm</li>
</ul>
<blockquote>
<p>从 <strong>Java8 开始</strong>堆空间逻辑在上分为三部分：<strong>新生代 + 老年代 + 元空间</strong> </p>
</blockquote>
<ul>
<li><p>Young Generation Space  年轻代    Young/New</p>
<ul>
<li>  新生代又可划分为 Eden 区和 Survivor 区</li>
</ul>
</li>
<li><p>Tenure generation space  老年代    Old/Tenure</p>
</li>
<li><p>Meta Space            元空间    Meta</p>
</li>
</ul>
<blockquote>
<p>  堆空间的演变仅仅是针对于方法区而言的，从Java8开始将 <code>永久代--&gt;&gt; 元空间</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆空间在逻辑上可分为三部分：1、年轻代 2、老年代 3、永久代/元空间</span><br><span class="line">但是在物理上，堆空间只有：1、年轻代 2、老年代</span><br></pre></td></tr></table></figure>





<p><strong>约定</strong>：</p>
<ul>
<li>新生区 &lt;=&gt; 新生代 &lt;=&gt; 年轻代</li>
<li>养老区 &lt;=&gt; 养老区 &lt;=&gt; 老年代</li>
<li>永久区 &lt;=&gt; 永久代</li>
</ul>
<hr>
<h1 id="2-设置堆空间大小"><a href="#2-设置堆空间大小" class="headerlink" title="2    设置堆空间大小"></a>2    设置堆空间大小</h1><h2 id="堆空间大小的设置"><a href="#堆空间大小的设置" class="headerlink" title="堆空间大小的设置"></a>堆空间大小的设置</h2><p>堆空间的大小在JVM进程启动时就已经确定好了，但是开发人员仍可以通过参数 <code>-Xmx</code> 和 <code>Xms</code> 来显式的指定这个空间的大小。</p>
<ul>
<li><strong>-Xms</strong> 用于设置堆空间的初始内存，等价于 <code>-XX:InitialHeapSize</code> </li>
<li><strong>-Xmx</strong> 用于设置堆空间的最大内存，等价于 <code>-XX:MaxHeapSize</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-X 是JVM的运行参数</span><br><span class="line">    ms 是 memory start</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 查看堆设置的参数</span></span><br><span class="line">    方式一：jps /   jstat -gc 进程id</span><br><span class="line">    方式二：-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一旦堆空间中的所有内存之和的大小超过 <code>-Xmx</code> 所指定的最大内存时，将会抛出 <strong>OutOfMemoryError</strong> 异常。</p>
</li>
<li><p>通常会将 <code>-Xms</code> 和 <code>-Xmx</code> 两个参数配置相同的值，其<strong>目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</strong></p>
</li>
<li><p>默认情况下：</p>
<p><code>初始内存大小 = 物理内存大小 / 64</code></p>
<p><code>最大内存大小 = 物理电脑内存大小 / 4</code> </p>
</li>
</ul>
<hr>
<h2 id="OOM说明与举例"><a href="#OOM说明与举例" class="headerlink" title="OOM说明与举例"></a>OOM说明与举例</h2><ul>
<li>堆空间内存溢出错误信息：<code>java.lang.OutOfMemoryError: Java heap space</code></li>
</ul>
<hr>
<h1 id="3-年轻代与老年代"><a href="#3-年轻代与老年代" class="headerlink" title="3    年轻代与老年代"></a>3    年轻代与老年代</h1><p>存储在堆空间中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</li>
<li>另外一类对象的生命周期非常长，在某些极端的情况下甚至与JVM线程的生命周期保持一致。</li>
</ul>
<p>按照上述标准，将Java堆空间进一步细分的话，又可划分为 <strong>年轻代（YoungGen）</strong> 和 <strong>老年代（OldGen）</strong>。</p>
<blockquote>
<p>其中 <strong>年轻代</strong> 又可以划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>；</p>
<ul>
<li>  <strong>Survivor区</strong> 又可划分为 <strong>Survivor0区</strong> 和 <strong>Survivor1区</strong>（有时也叫做from区、to区）</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>年轻代保存的是生命周期较短的对象，这类对象由于生命周期较短，所以经常需要被GC回收；</span><br><span class="line">    <span class="number">1.1</span>	Eden区被翻译为伊甸园区，伊甸园在西方神话中就是最早出现的人类亚当和夏娃居住的地方，对应在JVM内存中Eden区就是Java对象</span><br><span class="line">    创建出来时最先在堆中的位置。</span><br><span class="line"><span class="number">2</span>、老年代保存的是生命周期较长的对象，这类对象生命周期较长，所以被GC回收回收的频率较低。</span><br></pre></td></tr></table></figure>



<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E7%A9%BA%E9%97%B4%E9%BB%98%E8%AE%A4%E5%88%86%E9%85%8D%E6%AF%94%E4%BE%8B.png" alt="堆空间默认分配比例"></p>
<p><strong>配置新生代与老年代在堆结构的占比：</strong></p>
<ul>
<li><p>默认值是 <code>-XX:NewRatio=2</code>，表示新生代占1份，老年代占2份，新生代占整个堆的 1/3 。</p>
</li>
<li><p>可以修改 <code>-XX:NewRatio=4</code>，表示新生代占1份，老年代占4份，新生代占整个堆的 1/5。</p>
</li>
<li><p><strong>NewRatio = 老年代/新生代</strong> </p>
</li>
<li><p>在 HotSpot 中，Eden区和另外两个Survivor取所占堆空间的默认比例是：8：1：1</p>
</li>
<li><p>当然也可以通过参数<code>-XX:SurvivorRatio</code> 来调整这个空间比例。比如：SurvivorRatio = 8 。</p>
</li>
<li><p><strong>几乎所有的 Java 对象都是在 Eden 区被出生的。</strong></p>
<blockquote>
<p><strong>问题：什么时候Java对象不是在Eden区出生的？</strong></p>
<p>答：如果我们New了一个对象，并且这个对象所占内存非常大，大到伊甸园区都放不下，可以直接把对象存储到老年代。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>绝大多数的Java对象的销毁都是在新生代中进行的。据统计，绝大多数的对象生命周期都非常短，大部分在未晋升到老年代之前就已经被GC了。</p>
</li>
<li><p>可以使用参数 <code>-Xmn</code> 设置新生代最大内存的大小。（这个参数一般使用默认值即可） </p>
</li>
</ul>
<hr>
<h1 id="4-对象分配过程"><a href="#4-对象分配过程" class="headerlink" title="4    对象分配过程"></a>4    对象分配过程</h1><p>为新创建的对象分配内存空间是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配，在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑GC执行完垃圾回收后是否会在内存空间产生内存碎片等问题。</p>
<h2 id="对象分配一般过程"><a href="#对象分配一般过程" class="headerlink" title="对象分配一般过程"></a>对象分配一般过程</h2><ol>
<li><p><code>new</code> 出的新对象首先保存在 <code>Eden</code> 区。（此区有大小限制）</p>
</li>
<li><p>当伊甸园区的空间已被填满，并且程序又需要创建对象时，这时将会触发垃圾回收器对 <code>Eden</code>区中的对象进行一次 Minor GC：</p>
<ul>
<li>将 <code>Eden</code> 区中已失效的对象进行回收；</li>
<li>将 <code>Eden</code>区中未失效的对象移动到 <code>Survivor0</code> 区，并且为每一个移动到幸存者区的对象分配一个年龄计数器。</li>
<li>此时，<code>Eden</code> 区就已经被完全清空了，也就可以创建新的对象保存到 <code>Eden</code> 区。</li>
</ul>
</li>
<li><p>继续往伊甸园区保存新创建的对象，如果伊甸园区满，将再次触发 Minor GC：</p>
<ul>
<li>将 <code>Eden</code> 区中已失效的对象进行销毁；</li>
<li>将 <code>Eden</code> 区中未失效的对象，移动到 <code>Survivor1</code> 区，年龄计数器+1；</li>
<li>并且将 <code>Survivor0</code> 区中经过 Minor GC 筛选后没有被回收的对象 ，也要移动到 <code>Survivor1</code> 区，并将年龄计数器+1。</li>
<li>也就是说，对于 <code>Eden</code> 区和 <code>Survivor</code> 区中的对象，每次 Minor GC 后，都要将筛选后留下来的对象移动到空的 <code>Survivor </code>区中（即如果S0区为空，就将伊甸园区和S1区中的有效对象移动到S0区，如果S1区为空，就将伊甸园区和S0区中的有效对象移动到S1区中）。</li>
<li>此时，<code>Eden</code> 区和 <code>Survivor0</code> 区就都被清空了。</li>
</ul>
</li>
<li><p>继续往伊甸园区保存新创建的对象，如果伊甸园区满，再次触发 Minor GC，此时会将 GC 筛选后留下来的对象重新放回 <code>Survivor0</code>区，年龄计数器+1。以此类推，下次 GC 接着再放回 <code>Survivor1</code> 区，并累加年龄计数器。</p>
</li>
<li><p>啥时候能去养老区呢？可以设置 <strong>GC 次数的阈值，默认是 15 次</strong>。当年龄计数器大于等于 15 之后，即经历 15 次GC仍然存活在幸存者区的对象，就可以进入养老区了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以通过参数 -XX:MaxTenuringThreshold=&lt;N&gt; 来设置进入养老区的GC次数。</span><br></pre></td></tr></table></figure></li>
<li><p>在老年代相对安全，不会频繁的触发 GC。<strong>即 Minor GC 不会对老年代空间进行垃圾回收</strong>，只有当养老区空间内存不足时，触发了 <strong>Major GC 后才会对老年代进行垃圾回收的操作</strong>。</p>
</li>
<li><p>若老年代在执行了 Major GC 后发现仍然没有足够空间保存新进入老年代的对象，就会产生 OOM 异常。</p>
<p><code>java.lang.OutOfMemoryError: Java heap space</code></p>
</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<ol>
<li> <strong><code>from区</code> 和 <code>to区</code> 是相对的：</strong></li>
</ol>
</blockquote>
<ul>
<li><code>to区</code> 永远是内存为空的幸存者区，<code>from区</code> 永远是内存不为空的幸存者区。</li>
<li>即：如果幸存者1区为空，则该区就是 to区；如果幸存者1区不为空，则该区就是 from区。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>GC</strong></li>
</ol>
</blockquote>
<ul>
<li>伊甸园区满的时候会触发 YGC/Minor GC；</li>
<li>幸存者区满的时候不会触发 YGC/Minor GC</li>
<li>但是当 YGC/Minor GC 被触发的时候，会将伊甸园区和幸存者区一起进行GC。 </li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>关于垃圾回收：</strong></li>
</ol>
</blockquote>
<p>频繁在新生区，很少在养老区，几乎不在永久代（/元空间 ）。</p>
<hr>
<h2 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h2><p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%A0%86%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="堆中对象分配过程"></p>
<ol>
<li><p>使用 <code>new</code> 关键字在堆中创建出一个对象；</p>
</li>
<li><p>如果 Eden 放得下，就在 Eden 分配一块内存保存对象；</p>
</li>
<li><p>如果 Eden 放不下，就会触发 YGC 进行垃圾回收，GC 结束后会清空 Eden 空间，</p>
<ul>
<li>如果此时 Eden 放得下，就在 Eden 分配一块内存保存对象。</li>
<li>如果要创建的对象是一个超大的对象，所需要分配的内存大于 Eden 本身的内存空间。则跳过 Eden 和 Survivor ，直接去判断 Old 区能否放得下该对象；<ul>
<li>如果 Old 区能放得下该对象，就直接在 Old 区分配一块内存保存对象。</li>
<li>如果 Old 区放不下该对象，就会触发 FGC 对 Old 区的空间进行垃圾回收，GC 结束后会清理 Old 区已失效的对象。<ul>
<li>如果经过 FGC 后，Old 区剩余的内存空间大于创建新对象需要的内存空间，即可以放得下了，就在 Old 区分配一块内存保存对象。</li>
<li>如果经过 FGC 后，Old 区剩余的内存空间仍不足以支持新对象的创建，则抛出 OOM 异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>YGC 的详细过程：</strong></p>
</blockquote>
<p>当 Eden 满时触发 YGC，</p>
<ol>
<li>首先会回收 Eden 中失效的对象的内存空间；</li>
<li>如果 Survivor 放得下：<ol>
<li>将 Eden 中未失效的对象移动至 Survivor ；</li>
<li>将 Survivor 中 from 区的对象移动至 to 区。</li>
<li>如果 Survivor 中对象的存活时间超过阈值，就晋升为老年代，移动至 Old 区；</li>
<li>如果对象的存活时间未超过阈值，则继续从 from 区移动到 to 区；</li>
</ol>
</li>
<li>如果 Survivor 放不下：<ul>
<li>直接晋升到老年代，移动至 Old 区。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="5-Minor-GC、Major-GC、Full-GC"><a href="#5-Minor-GC、Major-GC、Full-GC" class="headerlink" title="5    Minor GC、Major GC、Full GC"></a>5    Minor GC、Major GC、Full GC</h1><blockquote>
<p>  Minor，未成年人</p>
<p>  Major：成年人</p>
</blockquote>
<p>JVM在进行GC时，并非每次GC都会对堆空间的三个内存区域（新生代、老年代、方法区）全部进行回收。</p>
<p>在 HotSpot 中，GC 按照回收区域又可分为两大种类型：①部分回收（Partial GC）    ②整堆回收（Full GC）</p>
<ul>
<li>部分回收：不是完整回收整个Java堆的垃圾回收。其中又可分为：<ol>
<li>新生代回收（Minor GC / Young GC）：只针对新生代区（Eden 和 Survivor）的GC。</li>
<li>老年代回收（Major GC / Old GC）：只针对老年代区的GC。</li>
<li>混合回收（Mixed GC）：针对整个新生代和部分老年代的GC。</li>
</ol>
</li>
<li>整堆回收（Full GC）：针对整个Java堆和方法区的垃圾回收</li>
</ul>
<ul>
<li><input checked disabled type="checkbox"> <strong>注意：很多时候 Major GC 和 Full GC 会混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></li>
</ul>
<hr>
<h2 id="分代式GC的触发条件"><a href="#分代式GC的触发条件" class="headerlink" title="分代式GC的触发条件"></a>分代式GC的触发条件</h2><blockquote>
<p>  <strong>Minor GC 的触发条件</strong></p>
</blockquote>
<ul>
<li>当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是 Eden 区满，Survivor 区满不会触发GC。（每次触发 Minor GC 会清理整个年轻代的内存空间）</li>
<li>因为 Java 对象<strong>大多都具备朝生夕灭</strong>的特性，所以 Minor GC 触发非常频繁，一般回收速度也比较快。</li>
<li>触发 Minor GC 后会引发 STW（Stop The Work），暂停其它用户的线程，等到垃圾回收结束，用户线程才会恢复运行。 </li>
</ul>
<blockquote>
<p>  <strong>Major GC / Full GC的触发条件</strong></p>
</blockquote>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC” 或 “Full GC” 就发生了。</li>
<li>发生了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。</li>
<li>Major GC 的速度一般会比 Minor GC 慢10倍以上，STW 的时间更长。</li>
<li>如果 Major GC 后，内存还不足，就会报 OOM 了。</li>
</ul>
<blockquote>
<p>  <strong>Full GC 的触发机制</strong></p>
</blockquote>
<p>触发 Full GC 执行的情况有以下5种：</p>
<ol>
<li>手动调用 <code>System.gc()</code> 方法，</li>
<li>老年代空间不足时；</li>
<li>方法区空间不足时；</li>
<li>某次 Minor GC 后进入老年代的对象的平均内存的大小大于老年代的可用内存；</li>
<li>由 Eden、from 区向 to 区复制时，如果待复制内容的大小大于 to 区的可用内存，就会把超出部分的对象转存到老年代，若此时老年代的可用内存小于待加入内存的大小，则会触发 Full GC 。</li>
</ol>
<p><strong>说明：Full GC 是开发或调优中尽量要避免的，这样暂停时间会短一些。</strong></p>
<hr>
<h1 id="6-堆空间分代思想"><a href="#6-堆空间分代思想" class="headerlink" title="6    堆空间分代思想"></a>6    堆空间分代思想</h1><p>研究表明，不同的对象生命周期不同，其中 70%~99% 的对象都是临时对象。</p>
<blockquote>
<p>  <strong>问题：Java堆空间为什么需要分代保存对象？不分代就不能正常工作了吗？</strong></p>
</blockquote>
<p>答：其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。</p>
<ul>
<li>  如果没有分代，那么所有的对象都会保存在一整块堆内存中，就如同把一个学校所有的人都关在一个教室。此时，每次GC的时候都需要把堆的所有的对象扫描一遍，才能够判断哪些对象已失效，哪些对象未失效。</li>
<li>  而在堆空间中，大部分的对象都是一些临时对象，生命周期很短。如果分代保存的话，把新创建的对象集中保存在某一块内存区域，当 GC 的时候只需扫描这块保存新对象的区域即可，而对于那些已经晋升到老年代的对象，只需要隔很久去GC一次即可。这样可以极大的节省CPU资源。</li>
</ul>
<hr>
<h1 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7    内存分配策略"></a>7    内存分配策略</h1><h2 id="对象晋升规则"><a href="#对象晋升规则" class="headerlink" title="对象晋升规则"></a>对象晋升规则</h2><ul>
<li><p>如果对象出生在 Eden 并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。</p>
</li>
<li><p>对象在 Survivor 中每熬过一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（HotSpot VM 默认为15岁，但是每个JVM、每个GC都有所不同）时，就会被晋升到养老区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于晋升到养老区的年龄阈值，可以通过参数： -XX:MaxTenuringThreshold 来设置。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到 Eden</li>
<li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li>
<li>长期存活的对象分配到老年代</li>
<li><strong>动态对象年龄判断</strong><ul>
<li>如果 Survivor 中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入养老区，无需等到 MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保<ul>
<li><code>-XX:HandlePromotionFailure</code></li>
</ul>
</li>
</ul>
<hr>
<h1 id="8-为对象分配内存：TLAB"><a href="#8-为对象分配内存：TLAB" class="headerlink" title="8    为对象分配内存：TLAB"></a>8    为对象分配内存：TLAB</h1><blockquote>
<p><strong>TLAB；Thread Local Allocation Buffer；本地线程缓存区</strong></p>
</blockquote>
<h2 id="为什么会有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么会有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么会有TLAB（Thread Local Allocation Buffer）？"></a>为什么会有TLAB（Thread Local Allocation Buffer）？</h2><ul>
<li><p>堆空间是所有线程共享的区域，任何线程都可以访问到堆空间中的共享数据。</p>
</li>
<li><p><strong>由于对象是在堆空间中创建的，所以在高并发条件下为新创建对象分配内存空间是线程不安全的。</strong></p>
<blockquote>
<p>假设有3个线程同时创建对象，这三个线程同时进入分配内存空间的环节，</p>
<ol>
<li> 首先，线程A申请到了一块内存地址为<code>0x1101</code>的内存空间，但是还没来得及创建对象，就被切换到线程B执行了；</li>
<li> 线程B经检查后，发现地址为<code>0x1101</code>的内存空间是空闲的 ，所以线程B也得到了这块内存空间用于保存创建的对象；</li>
<li> 同理，线程C也得到了地址为<code>0x1101</code>的内存空间。</li>
</ol>
<p>这三个线程在申请堆空间时都被JVM分配到了编号为<code>0x1101</code>的内存空间，但是在创建对象时这三个对象使用同一块内存就会产生冲突了。</p>
</blockquote>
</li>
<li><p>为了避免多个线程操作同一地址，在创建对象时还需要使用加锁等机制。显然，加锁是非常影响分配速度的。</p>
</li>
</ul>
<hr>
<h2 id="什么是TLAB-？"><a href="#什么是TLAB-？" class="headerlink" title="什么是TLAB ？"></a>什么是TLAB ？</h2><ul>
<li>从内存模型的角度来讲，对 <strong>Eden</strong> 继续进行划分，JVM <strong>在 Eden 区中划分出一块区域作为 TLAB 区</strong>，这块区域为每个线程都分配了一个私有缓存区域。</li>
<li>多线程同时创建对象时，使用 TLAB 可以避免一系列的线程不安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
</ul>
<hr>
<h2 id="TLAB-说明"><a href="#TLAB-说明" class="headerlink" title="TLAB 说明"></a>TLAB 说明</h2><ul>
<li><strong>尽管不是所有的对象实例都能在 TLAB 中成功创建，但JVM确实是将TLAB作为内存分配的首选。</strong></li>
<li>默认情况下，TLAB 空间的内存非常小，仅占整个 Eden 的 1%，所以当这个空间容纳不下我们要创建的对象实例时，就无法在 TLAB中成功创建对象。当然我们可以通过参数 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间占用 Eden 的百分比大小。</li>
<li><strong>一旦对象在 TLAB 空间中创建失败时，JVM 就会尝试着通过使用加锁机制确保创建对象时的原子性，直接在 Eden 空间中创建对象。</strong></li>
<li>在程序中，开发人员可以通过参数 <code>-XX:UseTLAB</code> 来设置是否开启 TLAB 空间。</li>
</ul>
<h3 id="对象分配过程（含TLAB）"><a href="#对象分配过程（含TLAB）" class="headerlink" title="对象分配过程（含TLAB）"></a>对象分配过程（含TLAB）</h3><p><img src="/2021/06/02/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-05%E5%A0%86/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="对象分配过程"></p>
<hr>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote>
<p>  <strong>问题：堆空间一定都是共享的吗？</strong></p>
</blockquote>
<p>答：不是。堆空间中 Eden 区中的 TLAB 区是每个线程私有的。</p>
<hr>
<h1 id="9-小结堆空间参数设置"><a href="#9-小结堆空间参数设置" class="headerlink" title="9    小结堆空间参数设置"></a>9    小结堆空间参数设置</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial		<span class="comment">// 查看所有参数使用的默认值</span></span><br><span class="line">-XX:+PrintFlagsFinal		<span class="comment">// 查看所有参数的最终值（可能存在修改，不再是初始值）</span></span><br><span class="line"></span><br><span class="line">-XX:NewRatio		<span class="comment">// 配置新生代与老年代在堆结构中的占比</span></span><br><span class="line"></span><br><span class="line">-Xms		<span class="comment">// 设置初始堆空间的内存（默认为物理内存的1/64）</span></span><br><span class="line">-Xmx		<span class="comment">// 设置最大堆空间的内存（默认为物理内存的1/64）</span></span><br><span class="line">-Xmn		<span class="comment">// 设置新生代内存的大小（初始值和最大值）</span></span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio=[size]		<span class="comment">// 设置新生代中 Eden 和 S0/S1 空间的比例</span></span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold	<span class="comment">// 设置新生代垃圾的最大年龄，超过阈值进入养老区</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails		<span class="comment">// 输出详细的GC处理日志</span></span><br><span class="line">-XX:+PrintGC	<span class="comment">// 打印GC简要信息</span></span><br><span class="line"></span><br><span class="line">-XX:HandlePromotionFailure	<span class="comment">// 是否设置空间分配担保</span></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="10-空间分配担保"><a href="#10-空间分配担保" class="headerlink" title="10    空间分配担保"></a>10    空间分配担保</h1><p>在发生 Minor GC 之前，虚拟机会<strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p>
<ul>
<li>如果大于，则此次 Minor GC 是安全的。（最极端的情况就是新生代所有的对象都在这一次GC后进入到养老区）</li>
<li>如果小于，则虚拟机会查看参数 <code>-XX:HandlePromotionFailure</code> 的值是否允许担保失败。<ul>
<li>如果 <code>-XX:HandlePromotionFailure=true</code>，表示允许担保失败，那么会继续<strong>检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul>
<li><input checked disabled type="checkbox"> 如果大于，则尝试进行一次 Minor GC ，但这个 Minor GC  依然是有风险的。因为平均数据并不能决定本次数据。</li>
<li><input checked disabled type="checkbox"> 如果小于，则改为进行一次 Full GC。</li>
</ul>
</li>
<li>如果 <code>-XX:HandlePromotionFailure=false</code>，表示不允许担保失败，直接进行一次 Full GC。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<p>执行 Minor GC 前需要进行担保：</p>
<ul>
<li>  若担保成功，则继续执行 Minor GC；</li>
<li>  若担保失败，则直接进行 Full GC。</li>
</ul>
<blockquote>
<p>  <strong>担保机制在不同 JDK 版本中的变化：</strong></p>
</blockquote>
<ul>
<li>  JDK7 之前，担保机制需要手动开启或关闭；</li>
<li>  从 JDK7 开始，担保机制变更为自动开启的了。</li>
</ul>
<p>从 JDK7 开始，<strong>HandlePromotionFailure</strong>参数不再会影响到虚拟机的空间分配担保策略，即默认<code>-XX:HandlePromotionFailure=true</code>。虽然在源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。规则变为：<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升老年代对象的平均大小就会进行 Minor GC，否则将进行 Full GC</strong>。</p>
<hr>
<h1 id="11-堆是分配对象存储的唯一选择吗？"><a href="#11-堆是分配对象存储的唯一选择吗？" class="headerlink" title="11    堆是分配对象存储的唯一选择吗？"></a>11    堆是分配对象存储的唯一选择吗？</h1><ul>
<li>随着 JIT 编译器的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 </li>
<li>在 Java 虚拟机中，对象是在 Java 堆中分配的。但是有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这就就无需在堆上分配内存，也无需进行垃圾回收了，这就是最常见的<strong>堆外存储技术</strong>。</li>
<li>此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现了 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC的回收效率的目的。  </li>
</ul>
<h2 id="逃逸分析概述"><a href="#逃逸分析概述" class="headerlink" title="逃逸分析概述"></a>逃逸分析概述</h2><ul>
<li><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
</li>
<li><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
</li>
<li><p>通过逃逸分析，HotSpot 编译器能够分析出一个新的对象引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
</li>
<li><p><strong>逃逸分析的基本行为就是分析对象动态作用域</strong>：</p>
</li>
<li><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p>
</li>
<li><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生了逃逸。例如作为调用参数传递到其它方法中。</p>
</li>
<li><p><strong>没有发生逃逸的对象，可以分配到栈上，随着方法执行的结束，栈空间就被移出</strong>。</p>
</li>
</ul>
<h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><ul>
<li><p>从 JDK7 开始，HotSpot 就默认开启了逃逸分析。</p>
</li>
<li><p>如果是更早的版本，开发人员可以通过：</p>
</li>
<li><ul>
<li><code>-XX: +DoEscapeAnalysis</code> 参数显式的开启逃逸分析。</li>
<li><code>-XX: +PrintEscapeAnalysis</code> 查看逃逸分析的筛选结果。</li>
</ul>
</li>
</ul>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><ul>
<li>开发中能使用局部变量的，就不要在方法外定义。</li>
</ul>
<hr>
<h2 id="逃逸分析代码优化"><a href="#逃逸分析代码优化" class="headerlink" title="逃逸分析代码优化"></a>逃逸分析代码优化</h2><p>使用逃逸分析，编译器可以对代码作如下优化：</p>
<blockquote>
<ol>
<li>栈上分配</li>
<li>同步省略 </li>
<li>分离对象或标量替换</li>
</ol>
</blockquote>
<h3 id="一、栈上分配"><a href="#一、栈上分配" class="headerlink" title="一、栈上分配"></a>一、栈上分配</h3><ul>
<li>将堆分配转换为栈分配，分配在栈上的对象不需要进行垃圾回收，方法出栈后对象自动被销毁，可以提高程序的性能。</li>
<li>JIT 编译器在编译期间会根据逃逸分析的结果，如果发现一个对象并没有逃逸出当前方法的话，就可能被优化成栈上分配。分配完成后，调用在栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</li>
</ul>
<h3 id="二、同步省略"><a href="#二、同步省略" class="headerlink" title="二、同步省略"></a>二、同步省略</h3><p>如果发现一个对象只能被一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<ul>
<li>  线程同步的代价是非常高的，同步的后果是降低并发性和性能。</li>
<li>  在动态编译同步代码块的时候，JIT 编译器可以借助逃逸分析来判断同步代码块所使用的锁对象是否只能被一个线程访问而没有被发布到其它线程。</li>
<li>  如果没有，那么JIT编译器在编译这个同步代码块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做同步省略，也叫锁消除。</li>
</ul>
<h3 id="三、分离对象或标量替换"><a href="#三、分离对象或标量替换" class="headerlink" title="三、分离对象或标量替换"></a>三、分离对象或标量替换</h3><p>有的对象可能不需要作为一个连续的内存结构存在也能被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<ul>
<li>  标量（Scalar）是指一个无法再分解成更小数据的数据。</li>
<li>  Java 中的基本数据类型就是标量。</li>
<li>  相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为它可以分解成其它聚合量和标量。</li>
<li>  在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个成员变量来代替。这个过程就是标量替换。</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x + <span class="string">&quot;;point.y=&quot;</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码经过标量替换后，就会变成：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x + <span class="string">&quot;;point.y=&quot;</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    可以看到，Point这个聚合量经过逃逸分析后，发现它并没有逃逸，就会替换成两个非聚合量了。</span></span><br><span class="line"><span class="comment">    那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。</span></span><br><span class="line"><span class="comment">    因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</span></span><br><span class="line"><span class="comment">    这些临时变量不需要创建对象来保存，直接保存在栈中的临时变量表中即可。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    标量替换为栈上分配提供了很好的基础。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>标量替换参数设置</strong></p>
</blockquote>
<p>使用参数 <code>-XX:+EliminateAllocations</code> 开启标量替换（默认就是打开的），允许将对象打散成标量对象分配在栈上。</p>
<hr>
<h2 id="逃逸分析小结：逃逸分析并不成熟"><a href="#逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="逃逸分析小结：逃逸分析并不成熟"></a>逃逸分析小结：逃逸分析并不成熟</h2><ul>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是<strong>无法保证逃逸分析节省的性能消耗一定能高于它的消耗</strong>。虽然经过逃逸分析可以做标量替换、栈上分配和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相当耗时的过程。</li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的，那这个逃逸分析的过程就白白浪费了。</li>
<li>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</li>
<li>有一些观点认为：通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。Oracle HotSpot JVM 中就并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li>
<li>目前很多书籍还是基于 JDK7 之前的版本，JDK 已经发生了很大的变化，intern 字符串的缓存和静态变量曾经都被分配在永久代中，而永久代已经被元数据区取代，但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</li>
</ul>
<hr>
<h1 id="12-小结"><a href="#12-小结" class="headerlink" title="12    小结"></a>12    小结</h1><ul>
<li>年轻代是大部分对象诞生、成长、消亡的区域，大部分对象在这里产生、应用、最后被垃圾回收器回收，结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从 Survivor 区筛选拷贝过来的 Java对象。当然，也会有特殊情况，我们知道普通的对象会被分配在TLAB上，但是如果对象太大，JVM会试图直接分配在Eden 其它位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li>当GC只发生在年轻代中，回收年轻代对象的行为被称为 Minor GC。当GC发生在老年代时则被称为 Major GC 或者 Full GC 。一般的，Minor GC 的发生频率要比 Major GC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-04%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-04%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/" class="post-title-link" itemprop="url">JVM——运行时数据区:04本地方法栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-31 22:08:17" itemprop="dateCreated datePublished" datetime="2021-05-31T22:08:17+08:00">2021-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-06-01 12:21:16" itemprop="dateModified" datetime="2021-06-01T12:21:16+08:00">2021-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h1><ul>
<li><p><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</strong></p>
</li>
<li><p>本地方法栈，也是线程私有的。</p>
</li>
<li><p>本地方法栈允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面和Java虚拟机栈是相同的）</p>
<blockquote>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，JVM将会抛出一个 <code>StackOverflowError</code> 异常。</li>
<li>如果本地方法栈设置为允许动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区创建对应的本地方法栈，那么Java虚拟机将会抛出一个 <code>OutofMemoryError</code> 异常。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>本地方法是使用C语言实现的。</p>
</li>
<li><p>它的具体做法是在 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p>
</li>
<li><p><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</strong></p>
<blockquote>
<ul>
<li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区</strong>。</li>
<li>它甚至可以直接使用本地处理器中的寄存器。</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、Java线程调用本地方法，</span><br><span class="line">2、本地方法是用C语言实现的；</span><br><span class="line">3、C语言可以直接与操作系统或硬件进行交互；</span><br><span class="line">4、所以 Java语言可以通过本地方法直接与操作系统交互，而JVM正是直接与操作系统交互的，所以说本地方法和虚拟机拥有同样的权限。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈使用的语言、具体实现方式、数据结构等</strong>。如果JVM产品不打算支持 native 方法，也可以无需实现本地方法栈。</p>
</li>
<li><p>在 HotSpot JVM 中，直接将本地方法栈和虚拟机栈合二为一了。</p>
</li>
<li></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-03%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-03%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/" class="post-title-link" itemprop="url">JVM——运行时数据区:03虚拟机栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-31 22:06:53" itemprop="dateCreated datePublished" datetime="2021-05-31T22:06:53+08:00">2021-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-23 09:26:12" itemprop="dateModified" datetime="2021-09-23T09:26:12+08:00">2021-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>虚拟机栈内存结构简图</strong></p>
</blockquote>
<p><img src="/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-03%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="虚拟机栈内存结构"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|--栈</span><br><span class="line">	|--栈帧1</span><br><span class="line">		|--局部变量表</span><br><span class="line">			|--Slot1</span><br><span class="line">			|--Slot2</span><br><span class="line">			|--......</span><br><span class="line">		|--操作数栈</span><br><span class="line">		|--方法返回地址</span><br><span class="line">		|--动态链接</span><br><span class="line">		|--附加信息</span><br><span class="line">	|--栈帧2</span><br><span class="line">	|--栈帧3</span><br><span class="line">	|--....</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h1><h2 id="虚拟机栈出现的背景"><a href="#虚拟机栈出现的背景" class="headerlink" title="虚拟机栈出现的背景"></a>虚拟机栈出现的背景</h2><ul>
<li>  由于 JVM 跨平台的设计，所以 JVM 的指令都是根据栈来设计的。</li>
<li>  不同平台 CPU 架构不同，所以 JVM 指令不能设计为基于寄存器的。</li>
</ul>
<blockquote>
<p>  <strong>栈式指令的优缺点：</strong></p>
</blockquote>
<ul>
<li>  <strong>优点是跨平台，指令集小，编译器容易实现，</strong></li>
<li>  <strong>缺点是性能下降（与寄存器相比），实现同样的功能需要更多的指令。</strong></li>
</ul>
<hr>
<h2 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h2><p><strong>栈是运行时的单位，而堆是存储的单位。</strong></p>
<ul>
<li>即：栈解决程序运行问题，即程序如何执行，或者说如何处理数据；</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放在哪儿。</li>
</ul>
<hr>
<h2 id="虚拟机栈的基本内容"><a href="#虚拟机栈的基本内容" class="headerlink" title="虚拟机栈的基本内容"></a>虚拟机栈的基本内容</h2><blockquote>
<p>  <strong>是什么 ？</strong></p>
</blockquote>
<ul>
<li><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。</p>
</li>
<li><p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的方法调用。</p>
</li>
</ul>
<blockquote>
<p>  <strong>生命周期</strong></p>
</blockquote>
<ul>
<li>生命周期与线程一致。</li>
</ul>
<blockquote>
<p>  <strong>作用</strong></p>
</blockquote>
<ul>
<li><p>主要负责管理 Java 线程的运行。它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<blockquote>
<p>局部变量：如果局部变量是属于 8 种基本数据类型的，则保存的是数据值；如果局部变量是引用数据类型，则保存的是对象的引用地址。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>  <strong>栈的优点</strong></p>
</blockquote>
<ul>
<li><p>栈是一种快速有效的分配存储方式，其访问速度仅仅次于程序计数器。</p>
</li>
<li><p>JVM对<code>虚拟机栈</code>的操作只有两个：</p>
<ol>
<li>每个方法开始执行，伴随着入栈</li>
<li>执行结束后出栈。</li>
</ol>
</li>
<li><p><strong>对于栈来说不存在垃圾回收问题，出栈就等同于垃圾回收。</strong></p>
<hr>
</li>
</ul>
<blockquote>
<p>  <strong>栈中可能出现的异常</strong></p>
</blockquote>
<p>Java 虚拟机规范允许 <strong>Java栈的大小可以是动态的或者是固定不变的</strong>。</p>
<ul>
<li>如果采用固定大小的虚拟机栈，那每一个线程的对应的虚拟机栈的容量在线程创建之初就已经确定了，如果线程请求分配的栈容量超过虚拟机栈允许的最大容量，JVM将会抛出一个 <strong>StackOverflowError</strong> 异常。</li>
<li>如果虚拟机栈设置为可动态扩展，并且在尝试扩展时无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那JVM将会抛出一个 <strong>OutOfMemoryError</strong> 异常。</li>
</ul>
<blockquote>
<p>  <strong>设置栈内存的大小</strong></p>
</blockquote>
<ul>
<li><p>我们可以使用参数 <code>-Xss</code> 来设置线程的最大栈空间，栈空间的大小直接决定了函数调用的最大可达深度。</p>
</li>
<li><p>在 IDEA 中，通过 <code>顶部导航栏 --&gt;&gt; Run --&gt;&gt; Edit Configurations...</code> 找到如下图配置信息，并设置线程的最大栈空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置 -Xss 参数常见的值：</span><br><span class="line">-Xss1m		<span class="comment">// 以 M 作为基本单位</span></span><br><span class="line">-Xss1024k	<span class="comment">// 以 kb 作为基本单位</span></span><br><span class="line">-Xss1048576		<span class="comment">// 默认基本单位，字节</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-03%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210517000602364.png" alt="image-20210517000602364"></p>
<hr>
<h1 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h1><h2 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h2><ul>
<li>每个线程都有自己的栈，栈中的数据都是以 <strong>栈帧（Stack Frame）</strong> 为基本单位存储的。</li>
<li>在这个线程上，每个正在执行的方法都有各自对应的一个栈帧（Stack Frame）。</li>
<li>栈帧是一个内存区域，是一个数据集，保存了方法执行过程中的各种数据信息。</li>
</ul>
<hr>
<h2 id="栈的运行原理"><a href="#栈的运行原理" class="headerlink" title="栈的运行原理"></a>栈的运行原理</h2><blockquote>
<p>  <strong>当前栈帧</strong>、<strong>当前方法</strong> 和 <strong>当前类</strong> 的说明：</p>
</blockquote>
<ul>
<li>在一个线程中，同一时刻，只能有一个栈帧正在执行操作，即只有当前正在执行方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧对应的方法就是<strong>当前方法（Current Method）</strong>，这个方法所在的类就是<strong>当前类（Current Class）</strong>。</li>
</ul>
<blockquote>
<p>  <strong>执行原理：</strong></p>
</blockquote>
<ul>
<li>JVM对<code>虚拟机栈</code>的直接操作只有两个，就是对栈帧进行<strong>压栈</strong>和<strong>出栈</strong>。</li>
<li>如果在当前方法中调用了其它方法，那么对应的新的栈帧会被创建出来，放在栈的顶端，变成了新的当前栈帧。</li>
</ul>
<p><img src="/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-03%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt="栈运行原理"></p>
<p>在某个线程中，</p>
<blockquote>
<ol>
<li>首先执行方法1，方法1被压入栈中。</li>
<li>在方法1中调用方法2，方法2被压入栈中；</li>
<li>在方法2中调用方法3，方法3被压入栈中；</li>
<li>在方法3中调用方法4，方法4被压入栈中。</li>
</ol>
</blockquote>
<ul>
<li>此时，方法4对应的栈帧4位于栈顶，所以栈帧4就被称为当前栈帧，对应的方法被称为当前方法，方法4所在的类被称为当前类。</li>
<li>当方法4出栈后，方法3就位于了栈顶，栈帧3就变成了新的当前栈帧，方法3变成了新的当前方法，方法3所在的类就成了新的当前类。</li>
<li>以此类推。</li>
</ul>
<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>不同线程中的栈帧是不允许互相引用的，即不可以在一个线程的栈帧之中引用另一个线程的栈帧。</li>
<li>如果<code>当前方法</code>调用了其它方法，那么这个“其它方法”就会成为<code>新的当前方法</code>，这个<code>新的当前方法</code>在执行完毕出栈时，当前栈帧会传回此方法的执行结果给上一个栈帧。接着，虚拟机会丢弃当前栈帧，使上一个栈帧重新成为当前栈帧。</li>
<li>方法的结束方法时有两种：<strong>一种是正常的函数返回，使用 return 指令；另一种是抛出异常。不管使用哪种方式，都会导致当前栈帧出栈。</strong></li>
</ul>
<hr>
<h1 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a>局部变量表（Local Variables）</h1><blockquote>
<p><strong>局部变量表；局部变量数组；本地变量表。</strong></p>
</blockquote>
<p><strong>局部变量表的逻辑结构是一个一维数字数组，主要用于存储栈帧对应方法的参数和方法内部的局部变量。</strong></p>
<ul>
<li>方法参数和方法内局部变量的数据类型可以是：<ol>
<li> 各种基本类型数据</li>
<li> 对象引用（reference）</li>
<li> returnAddress 类型</li>
</ol>
</li>
</ul>
<blockquote>
<p>  <strong>问题：为什么说局部变量表存储的是一个数字数组呢？</strong></p>
</blockquote>
<p>答：</p>
<ul>
<li>  首先明确，局部变量表中主要保存了栈帧对应方法的<strong>方法参数、方法内的局部变量、和方法返回值</strong>。</li>
<li>  这些数据的类型无外乎就是基本数据类型和引用数据类型。在基本数据类型中：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>double</code>、<code>float </code>本来就是数字类型，<code>boolean</code>、<code>char </code>可以通过 ASCII 码表转化成数字类型；同理，引用类型数据也可以转成为数字表示。</li>
<li>  所以说，局部变量表存储的是一个数字数组。</li>
</ul>
<blockquote>
<p>  <strong>问题：局部变量表存在线程安全问题吗？</strong></p>
</blockquote>
<p>答：由于局部变量表是建立在虚拟机栈的栈帧上，而虚拟机栈是线程私有的数据，因此不存在线程安全问题。</p>
<blockquote>
<p>  <strong>知识点：</strong></p>
</blockquote>
<ul>
<li><strong>局部变量表所需的容量大小是在前端编译期就已经确定了的</strong>，并保存在方法的 Code 属性的 <code>maximum local variable</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li><strong>方法可嵌套调用的次数由栈的大小（深度）决定</strong>。一般来说，<strong>栈越大，方法可嵌套调用的次数就越多</strong>。对于一个方法而言，它的参数和局部变量越多，就会使得局部变量表膨胀，它的栈帧也就越大，为满足方法调用所需传递的信息量增大的需求，函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</li>
</ul>
<hr>
<h2 id="关于-Slot-的理解"><a href="#关于-Slot-的理解" class="headerlink" title="关于 Slot 的理解"></a>关于 Slot 的理解</h2><p><strong>Slot（变量槽）是局部变量表最基本的存储单元</strong>。</p>
<ul>
<li><p>参数值的保存范围从局部变量表的 <code>index[0]</code> 开始，到<code>index[-1]</code> 结束。</p>
</li>
<li><p>局部变量表中存放的是编译期可知的各种 <code>基本数据类型（8种）</code>、<code>引用类型（reference）</code> 和 <code>returnAddress 类型</code> 的变量。</p>
</li>
<li><p>在局部变量表里，<strong>32位以内的数据类型只占用一个 Slot（包括 reference 和 returnAddress 类型），64位的数据类型（long 和 double）占用两个 Slot</strong>。</p>
<blockquote>
<p>因为局部变量表是一维<strong>数字数组</strong>，所以所有数据类型在保存到局部变量表时都会转换成数字类型：</p>
<ul>
<li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非0 表示 true。（转换成int是因为int刚好有32bit，而少于32bit的数据需要被填充到32bit）</li>
<li>long 和 double 则占据两个 Slot。</li>
<li>引用数据类型 reference 和 returnAddress 也占用一个Slot。</li>
</ul>
</blockquote>
</li>
<li><p>JVM 会为局部变量表中的每一个 Slot 都分配一个<strong>访问索引</strong>，通过这个索引即可成功访问到局部变量表中每个 Slot 中保存的的值。</p>
</li>
<li><p>当一个<strong>实例方法</strong>被调用时，它的<code>方法参数</code>和<code>方法内部的局部变量</code>将会<strong>按照顺序被复制</strong>到局部变量表中的每一个Slot上。</p>
<blockquote>
<ul>
<li>构造方法也是一种实例方法。</li>
<li>如果当前栈帧是由构造方法或者实例方法创建的，那么<strong>该对象引用的 <code>this</code> 变量将会存放在局部变量表 index[0] 的 Slot 上</strong>，其余参数（方法参数和方法内部的局部变量）继续按照出现的顺序插入局部变量表的每一个Slot中。</li>
<li><strong>因为静态方法的局部变量表中没有保存 this 这个对象引用，所以我们代码中的静态方法就不能使用 this 变量。</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用一个索引即可。</strong>（比如：访问 long 或 double 类型的变量）</p>
<p><img src="/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-03%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/Slot-1621265523329.png" alt="Slot"></p>
</li>
</ul>
<hr>
<h2 id="Slot-的重复利用"><a href="#Slot-的重复利用" class="headerlink" title="Slot 的重复利用"></a>Slot 的重复利用</h2><p><strong>栈帧中局部变量表的槽位是可以重复利用的</strong>。</p>
<p>如果一个局部变量超出了其作用域，那么在其作用域之外新声明的局部变量就很有可能会复用过期的局部变量的槽位，从而<strong>达到节省资源的目的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	分析：</span></span><br><span class="line"><span class="comment">		首先，这是一个非静态方法，所以在局部变量数组中 this 占一个槽位，下标为0；</span></span><br><span class="line"><span class="comment">		变量a 占一个槽位，下标为1；</span></span><br><span class="line"><span class="comment">		变量b 占一个槽位，下标为2；</span></span><br><span class="line"><span class="comment">		但是，b在超过了其作用域范围之后，所占的槽位会被回收，也就是说：</span></span><br><span class="line"><span class="comment">		变量c 在声明的时候 ，占用的仍然是 下标为2 的槽位。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="静态变量-和-局部变量-的对比"><a href="#静态变量-和-局部变量-的对比" class="headerlink" title="静态变量 和 局部变量 的对比"></a>静态变量 和 局部变量 的对比</h2><blockquote>
<p>变量的分类：</p>
<ul>
<li>按照数据类型分类：1、基本类型变量  2、引用类型变量</li>
<li>按照在类中的位置分类：<ol>
<li>成员变量：按照有无 static 修饰又可分为：1️⃣类变量  2️⃣实例变量</li>
<li>局部变量</li>
</ol>
</li>
</ul>
</blockquote>
<ol>
<li>成员变量，在使用前是有默认初始化值的。<ul>
<li>类变量：类变量表有两次初始化的机会。第一次是在 <strong>linking 的 prepare 阶段</strong>，执行系统初始化，给类变量赋零值 <code>--&gt;&gt;</code> 另一次则是在 <strong>initialization 阶段</strong>，给类变量显式赋值（如果有的话）。</li>
<li>实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值。</li>
</ul>
</li>
<li>局部变量：在使用前，必须要进行显式赋值，否则在编译时就会直接报错。<ul>
<li>和类变量初始化不同，局部变量表不存在系统初始化的过程，这就意味着一旦定义了局部变量必须人为进行初始化，否则就无法使用。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><ul>
<li>在栈帧中，与性能调优关系最密切的部分就是<strong>局部变量表</strong>。<ol>
<li>首先，局部变量表在一个栈帧中占据的内存往往是较多的，当涉及到栈内存溢出时，往往要考虑优化栈帧中局部变量表的内存。</li>
<li>其次，局部变量表中保存了大量的对象指针，这些指针指向的对象存储在堆空间中，当局部变量表中的指针失效后，如何回收，什么时候回收 等等条件都影响着堆空间的利用，所以说：在栈帧中，与性能调优关系最密切的部分就是局部变量表。</li>
</ol>
</li>
</ul>
<ul>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></li>
</ul>
<hr>
<h1 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h1><blockquote>
<p><strong>操作数栈；表达式栈</strong></p>
</blockquote>
<ul>
<li><p>操作数栈也是栈帧中的一个重要组成部分。</p>
</li>
<li><p>根据指令对局部变量表中的变量进行运算。局部变量表负责保存变量，而操作数栈则负责变量间的运算。</p>
</li>
<li><p><strong>操作数栈的作用就是：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/ 出栈（pop）</strong></p>
<blockquote>
<ul>
<li>某些字节码指令的作用是将值压入操作数栈；某些字节码指令的作用是将操作数取出栈，使用它们计算后再把结果压入栈。</li>
<li>比如：执行复制、交换、求和等操作。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>操作数栈，主要用于保存计算程序的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p>
</li>
<li><p>当一个方法刚开始执行时，一个新的栈帧也随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong>。</p>
</li>
<li><p>每一个操作数栈都会拥有一个明确的栈深度，这个最大深度值在编译期就定义好了，保存在方法的 Code 对象的 <code>max_stack</code> 属性中。</p>
</li>
<li><p>栈中的任何一个元素都可以是任意的 Java 数据类型。</p>
<blockquote>
<p>32bit 的类型占用一个栈单位深度。</p>
<p>64bit 的类型占用两个栈单位深度。</p>
</blockquote>
</li>
</ul>
<ul>
<li>操作数栈不能采用访问索引的方式来进行数据访问，而只能通过标准的 入栈 / 出栈 操作完成一次数据访问。 </li>
<li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并且更新 <code>程序计数器</code> 中下一条需要执行的字节码指令的地址。</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li>
<li>另外，我们说 JVM 的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</li>
</ul>
<hr>
<h1 id="栈顶缓存技术（Top-of-Stack-Cashing）"><a href="#栈顶缓存技术（Top-of-Stack-Cashing）" class="headerlink" title="栈顶缓存技术（Top-of-Stack Cashing）"></a>栈顶缓存技术（Top-of-Stack Cashing）</h1><p>基于栈式架构的虚拟机所使用的<strong>零地址指令</strong>更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要使用更多的指令分派（instruction dispatch）次数和内存读写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁的读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者提出了 栈顶缓存技术（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong>。</p>
<hr>
<h1 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h1><p><strong>动态链接：指向运行时常量池中方法的引用</strong>【目的是将方法（栈帧）中用到的符号引用转换为直接引用】</p>
<ul>
<li>大部分字节码指令在执行时都需要借助运行时常量池，所以 HotSpot 在设计之初，就在栈帧数据区保存了一个能够访问运行时常量池的指针，方便程序访问运行时常量池。</li>
<li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接（Dynamic Linking）</strong>。比如：<code>invokedynamic</code> 指令。</li>
<li>在<code>.java</code>源文件被编译成<code>.class</code>字节码文件时，所有的变量和方法引用都会先以符号引用（Symbolic Reference）的形式保存在 <code>.class</code> 文件的常量池里。    比如：描述一个方法调用了其它方法时，就是通过常量池中指向方法的符号引用来表示的，而<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。</li>
</ul>
<p><img src="/2021/05/31/JVM%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-03%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" alt="动态链接"></p>
<h2 id="为什么需要常量池呢？"><a href="#为什么需要常量池呢？" class="headerlink" title="为什么需要常量池呢？"></a>为什么需要常量池呢？</h2><p>常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p>
<ul>
<li>一般来讲，我们的字节码文件所占的空间都比较小，但是每个字节码文件引用的内容却很多，比如类的父类信息、各种数据类型的信息、等等等等。这些信息如果都保存在字节码文件中，显然字节码文件空间就非常臃肿了，并且重复的信息会保存多份。那么这些信息保存在哪儿呢？常量池中！</li>
<li>我们在字节码文件中只需要保存常量池中具体数据对象的引用，就可以在程序运行去具体的运行时常量池中找到程序运行所需要的数据信息。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>常量池：保存指向方法和变量的符号引用；</li>
<li>运行时常量池：保存指向方法和变量的直接引用</li>
<li>动态链接：将符号引用转换成直接引用。</li>
</ul>
<hr>
<h1 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h1><blockquote>
<p>  <strong>问题：Java 语言具有多态性，那么 JVM 在运行时如何知道应该调用父类的方法还是子类的方法呢 ？</strong></p>
</blockquote>
<p>在 JVM 中，将符号引用转换为调用方法时的直接引用与方法的绑定机制相关。</p>
<ul>
<li><p><strong>静态链接</strong>：</p>
<p>当一个字节码文件被加载进 JVM 内存中时，如果<strong>被调用的方法在编译期就可以确定下来</strong>，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接。</p>
</li>
<li><p><strong>动态链接</strong>：</p>
<p>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
</li>
</ul>
<p>对应的方法的绑定机制为：<strong>早期绑定（Early Binding）</strong>和 <strong>晚期绑定（Late Binding）</strong>。</p>
<p><strong>绑定是：一个字段、方法或者类从符号引用被转换为直接引用的过程，这仅仅发生一次</strong>。</p>
<ul>
<li><p><strong>早期绑定</strong>：</p>
<p>早期绑定就是指 <strong>被调用的目标方法如果在编译期可知，且运行时保持不变</strong>时，即可将这个方法与所属的类进行绑定。这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</li>
<li><p><strong>晚期绑定</strong>：</p>
<p>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
</li>
</ul>
<p>面向对象的语言的共性就是都支持 封装、继承和多态 等面向对象特性。既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p>Java 中任何一个普通方法都具备虚函数的特征，它相当于C++语言中的虚函数（C++语言中需要使用关键字 virtual 来显示定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用 final 关键字来标记这个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚函数：运行期才能确定下来</span><br></pre></td></tr></table></figure>







<h2 id="虚方法-amp-非虚方法"><a href="#虚方法-amp-非虚方法" class="headerlink" title="虚方法 &amp; 非虚方法"></a>虚方法 &amp; 非虚方法</h2><ul>
<li>如果方法在编译期就确定了具体的调用版本，且这个版本在运行时是不可变的。这样的方法就称为<strong>非虚方法</strong>。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li>
<li>其它方法称为虚方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果在编译阶段就能够明确确定将要调用哪个类中的方法，这种方法叫做非虚方法；</span><br><span class="line">如果在编译期不能确定，只有在运行时才能确定调用哪个类中的方法，这种方法叫做虚方法。</span><br></pre></td></tr></table></figure>



<p>虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li><p>普通调用指令：</p>
<blockquote>
<ol>
<li><p><code>invokestatic</code>：调用静态方法，解析阶段确定唯一方法版本。</p>
</li>
<li><p><code>invokespecial</code>：调用<code>&lt;init&gt;</code>方法、私有方法及父类方法，解析阶段确定唯一方法版本。</p>
<p>【父类方法就是<code>super.xxx()</code>】</p>
</li>
<li><p><code>invokevirtual</code>：调用所有虚方法。</p>
</li>
<li><p><code>invokeinterface</code>：调用接口方法。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li><p>动态调用指令：</p>
<blockquote>
<ol start="5">
<li><code>invokedynamic</code>：动态接续出需要调用的方法，然后执行。</li>
</ol>
</blockquote>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 <code>invokedynamic</code> 指令则支持由用户确定方法版本，其中 <strong>invokestatic指令 和 invokespecial指令 调用的方法称为非虚方法，其余的（final 修饰的除外）称为虚方法</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果父类 Father 中定义了 final 关键字修饰的方法，在子类中直接调用该方法：</span><br><span class="line"></span><br><span class="line">我们会发现该方法是使用 invokevirtual 指令调用的，但本质上这还是一个非虚方法，</span><br><span class="line">因为被 final 修饰的方法在编译期就可以确定唯一的方法版本，不能被子类重写。</span><br></pre></td></tr></table></figure>

<ul>
<li>JVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 <code>invokedynamic</code> 指令，这是 Java 为了实现动态类型语言支持而做的一种改进。</li>
<li>但是在 Java7 中并没有提供直接生成 <code>invokedynamic</code> 指令的方法，需要借助 ASM 这种底层字节码工具来产生 <code>invokedynamic</code> 指令。<strong>直到 Java8 的 Lambda 表达式的出现，invokedynamic指令才在 Java 中有了直接的生成方式</strong>。</li>
<li>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li>
</ul>
<hr>
<h2 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h2><ul>
<li><strong>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期</strong>。满足前者就是静态类型语言，反之就是动态类型语言。 </li>
<li>也就是说，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息。变量没有类型信息，变量值才有类型信息。这是动态语言的一个重要特性。</li>
<li>Java 是一种静态类型语言，静态类型语言就是强类型语言，动态类型语言就是弱类型语言，如：Js、Python 等。</li>
</ul>
<hr>
<h2 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h2><ol>
<li> 当我们调用一个对象的方法的时候，首先会将这个对象的实际类型压入操作数栈记做 C 。</li>
<li> 然后 JVM 就会去这个类型对应的 Class 中去查找是否含有 <code>返回值、名称和请求参数</code> 与调用方法都相同的方法；</li>
<li> 如果找到了，继续进行访问权限校验，若校验通过，就返回该方法的直接引用；若校验失败，则返回 java.lang.IllegalAccessError 异常。</li>
<li> 如果在 Class C 中找不到符合条件的方法，则按照继承关系从下往上依次对 C 的父类进行第2、3步的检索和验证过程。</li>
<li> 如果始终没有找到对应的方法，则抛出 <code>java.lang.AbstractMethodError</code> 异常。</li>
</ol>
<blockquote>
<p>  <strong>IllegalAccessError</strong></p>
</blockquote>
<ul>
<li>  程序试图访问或修改一个属性或调用一个方法，如果这个属性或方法，你没有权限访问，一般会引起编译期异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li>
</ul>
<hr>
<h2 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h2><ul>
<li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话可能影响到执行效率。因此，为了提高性能，JVM 采用<strong>在方法区为每个 Class 对象建立一个虚方法表</strong>（virtual method table）（非虚方法不会出现在表中）来实现，虚方法表中的每个虚方法通过索引来代替递归查找。</li>
<li>每个类都对应有一个虚方法表，表中存放着各个方法的实际入口。</li>
</ul>
<blockquote>
<p>  <strong>那么虚方法表什么时候创建呢？</strong></p>
</blockquote>
<p>虚方法表会在<strong>链接阶段</strong>被创建并开始初始化，类的变量<strong>初始</strong>值准备完成之后，JVM 会把该类的虚方法表也初始化完毕。</p>
<hr>
<h1 id="方法返回地址（Return-Address）"><a href="#方法返回地址（Return-Address）" class="headerlink" title="方法返回地址（Return Address）"></a>方法返回地址（Return Address）</h1><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<p><strong>方法返回地址</strong>保存的是程序计数器的值（即执行引擎将要执行的字节码指令的地址）。</p>
<blockquote>
<p>  <strong>举例</strong></p>
</blockquote>
<p>假设在某一栈中，先调用了A方法 ，A方法中又调用了B方法：</p>
<ol>
<li> A方法首先入栈，</li>
<li> 在A方法的某一行代码中调用了B方法，B方法入栈，<strong>B方法在执行完毕后，要跳转回A方法中去，就需要用到这个方法返回地址</strong>。</li>
<li> 方法返回地址的值就是程序计数器的值，即下一条JVM指令的地址，这样执行引擎就能根据这个地址跳转回A方法中去，继续执行A方法中的代码。</li>
</ol>
<blockquote>
<p>  <strong>方法的两种结束方式：</strong></p>
</blockquote>
<p>一个方法的结束有两种方式：①正常执行完成    ②出现未处理的异常，非正常退出。  无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。  </p>
<ul>
<li>方法正常退出时，<strong>会将调用者的程序计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。</li>
<li>而通过异常退出的，返回地址要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li>执行引擎收到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>。</li>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。<ul>
<li>在字节码指令中，返回指令包含 <code>ireturn</code> （当返回值是 boolean、byte、char、short 和 int 类型时使用）、 <code>lreturn</code> 、 <code>freturn</code> 、 <code>dreturn</code> 以及 <code>areturn</code> ，另外还有一个 <code>return</code> 指令供声明为 void 的方法、实例构造方法（ <code>&lt;init&gt;</code> ）、类和接口的构造方法（ <code>&lt;clinit&gt;</code> ）使用。</li>
</ul>
</li>
<li>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</li>
<li>方法执行过程中抛出异常时的异常处理方案，存储在一个异常处理表，方便在发生异常时找到处理异常的代码。<ul>
<li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上一个栈帧中方法的局部变量表、操作数栈、将返回值压入调用者的操作数栈、设置PC寄存器值等，让调用者的方法能继续执行下去。</li>
</ul>
</li>
</ol>
<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的程序不会给它的上层调用者产生任何的返回值</strong>。</p>
<hr>
<h1 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h1><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<hr>
<h1 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h1><blockquote>
<ol>
<li> <strong>举例栈溢出的情况？</strong></li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">栈溢出：StackOverflowError</span><br><span class="line">内存溢出：OutOfMemoryError</span><br></pre></td></tr></table></figure>

<ol>
<li> 如果设置栈帧内存为自适应的话，假设某个方法入栈时需要占用的内存为2M，那么这时候JVM就会自动分配栈帧内存大于等于2M的空间给方法使用。这种情况下不会出现 StackOverflowError ，但是会当栈的内存不足以满足新的栈帧需要的内存时，会出现OutOfMemoryError。</li>
<li> 如果设置栈帧内存为手动指定的话，假设某个方法入栈时需要占用的内存为2M，但是我们手动设置的栈帧的最大内存为1M，那么这时就会出现 StackOverflowError。</li>
</ol>
<blockquote>
<ol start="2">
<li> <strong>调整栈大小，就能保证不出现溢出吗？</strong></li>
</ol>
</blockquote>
<p>答：不能。如果入栈的方法是一个死循环的递归方法，那么增加栈的内存只能保证栈溢出的时间出现的晚一些，最终还是会出现栈溢出。</p>
<blockquote>
<ol start="3">
<li> <strong>分配的栈内存越大越好吗？</strong></li>
</ol>
</blockquote>
<p>答：不是。会挤占其它内存空间。</p>
<blockquote>
<ol start="4">
<li> <strong>垃圾回收是否会涉及到虚拟机栈？</strong></li>
</ol>
</blockquote>
<p>答：不会。</p>
<ul>
<li>  程序计数器：不存在Error，不存在GC；</li>
<li>  虚拟机栈：存在Error，不存在GC（通过出栈的方式来完成类似于垃圾回收的功能）；</li>
<li>  本地方法栈：存在Error，不存在GC（类似于虚拟机栈）；</li>
<li>  堆：存在Error，存在GC；</li>
<li>  方法区：存在Error，存在GC；</li>
</ul>
<blockquote>
<ol start="5">
<li> <strong>方法中定义的局部变量是否线程安全？</strong></li>
</ol>
</blockquote>
<p>答：不一定。具体问题具体分析。</p>
<p>​    </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
