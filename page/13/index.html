<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/13/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/13/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/03/JUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/03/JUC/" class="post-title-link" itemprop="url">JUC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-03 10:00:06" itemprop="dateCreated datePublished" datetime="2021-07-03T10:00:06+08:00">2021-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-22 20:27:59" itemprop="dateModified" datetime="2021-10-22T20:27:59+08:00">2021-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>JUC；java.util.concurrent；</strong></p>
</blockquote>
<p>JUC 是 <code>java.util.concurrent</code> 工具包的简称，这是一个专门处理线程的工具包。</p>
<p>JUC 一般指以下三个包：</p>
<ul>
<li>  <strong>java.util.concurrent</strong></li>
<li>  <strong>java.util.concurrent.atomic</strong></li>
<li>  <strong>java.util.concurrent.locks</strong></li>
</ul>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h2><p>进程：CPU 分配资源的最小单元</p>
<p>线程：CPU 执行任务的最小单元</p>
<p>进程：QQ.exe、office.exe</p>
<p>线程：</p>
<ol>
<li> 在运行的 QQ 程序中同时开着聊天窗口、视频聊天、语音聊天，这些分别都是一个个线程；</li>
<li> 在 Word 中，提供输入页面的是一个线程，打字中如果输出不合法检测并提示的也是一个线程，未保存强制退出后下次可以恢复的功能也需要一直维持一个线程。</li>
</ol>
<h2 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发/并行"></a>并发/并行</h2><ul>
<li>  并发：多个线程蜂拥而入抢同一份资源。秒杀、抢票</li>
<li>  并行：多件事情同时进行</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul>
<li>  3个售票员    卖出    100张票。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/3 20:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  题目：三个售票员  卖出  20张票。 如何编写企业级的多线程代码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 企业级代码固定的编程套路——</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1、在高内聚低耦合的情况下，  线程      操作      资源类</span></span><br><span class="line"><span class="comment"> *      1.1 一言不合，先创建一个资源类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>(<span class="number">30</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                ticket.saleTicket();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer ticketNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ticket</span><span class="params">(Integer ticketNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ticketNum = ticketNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;正在卖出第&quot;</span>+ticketNum+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticketNum--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="线程的执行时机"><a href="#线程的执行时机" class="headerlink" title="线程的执行时机"></a>线程的执行时机</h3><ol>
<li> <code>start()</code> 方法被调用之后线程并不会立即执行，具体什么时候执行要看什么时候能得到CPU资源，这是由底层操作系统决定的。</li>
</ol>
<h3 id="线程的状态（6种）"><a href="#线程的状态（6种）" class="headerlink" title="线程的状态（6种）"></a>线程的状态（6种）</h3><p><strong>线程有6种状态</strong>。可以通过 <code>Thread.State</code> 进入源码查看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    WAITING,	<span class="comment">// 不见不散 </span></span><br><span class="line"></span><br><span class="line">    TIMED_WAITING,	<span class="comment">// 过时不候</span></span><br><span class="line"></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程的4种实现方式"><a href="#线程的4种实现方式" class="headerlink" title="线程的4种实现方式"></a>线程的4种实现方式</h3><ol>
<li> 继承 Thread 类并重写类中的 run() 方法</li>
<li> 实现 Runnable 接口并重写接口中的 run() 方法</li>
<li> 实现 Callable 接口并重写接口中的 run() 方法</li>
<li> 通过线程池分配一个线程</li>
</ol>
<p>但是我们在上面的代码中，既没有继承 Thread 类和实现 Runnable/Callable 接口，更没有出现过线程池，那么是如何实现线程的呢？</p>
<p><strong>匿名内部类 + Lambda表达式</strong> 。在代码中看起来我们并没有实现 Runnable 接口，但其实是实现了的，只是通过一些语法糖让其不直接在源代码中显示出来罢了，在编译成二进制字节码文件时实现 Runnable 接口的这个操作是真实存在的。</p>
<p>匿名内部类实现的细节：1、实现了 Runnable 接口，并重写了接口中的 run() 方法。    2、多态，用一个 Runnable 类型的变量接收重写后匿名对象的地址。</p>
<h3 id="加锁的3种方式"><a href="#加锁的3种方式" class="headerlink" title="加锁的3种方式"></a>加锁的3种方式</h3><ol>
<li> 直接在方法上使用 synchronized 加锁</li>
<li> 使用 synchronized 代码块</li>
<li> 使用 Java 中专门提供的锁对象 Lock</li>
</ol>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock 是 java.util.concurrent.locks 包下的一个接口，实现类有 3 个：</p>
<ul>
<li>  Class ReentrantLock</li>
<li>  Class ReentrantReadWriteLock.WriteLock</li>
<li>  Class ReentrantReadWriteLock.ReadLock</li>
</ul>
<p>常见的使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Xxx</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); </span><br><span class="line">        <span class="comment">// block until condition holds </span></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="comment">// ... method body </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock() </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="Synchronized-和-Lock-有什么区别？用新的-Lock-有什么好处？"><a href="#Synchronized-和-Lock-有什么区别？用新的-Lock-有什么好处？" class="headerlink" title="Synchronized 和 Lock 有什么区别？用新的 Lock 有什么好处？"></a>Synchronized 和 Lock 有什么区别？用新的 Lock 有什么好处？</h4><p><img src="/2021/07/03/JUC/image-20210714112703545.png" alt="image-20210714112703545"></p>
<blockquote>
<ol>
<li> <strong>原始构成</strong></li>
</ol>
</blockquote>
<ul>
<li><p>synchronized 是关键字，属于 JVM 层面的锁。</p>
<p>  底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象，只有在同步代码块或同步方法中才能调用 wait/notify 等方法。</p>
<p>   monitorenter 指令代表进入锁对象，monitorexit 代表退出锁对象。</p>
<p>  为什么会有两个 monitorexit 呢？一个是正常退出，一个是异常退出</p>
</li>
<li><p>  Lock 是具体类（<code>java.util.concurrent.locks.Lock</code>），是 API 的层面的锁</p>
</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>使用方法</strong></li>
</ol>
</blockquote>
<ul>
<li>  <strong>synchronized 不需要用户去手动释放锁</strong>，当 synchronized 代码执行完后，系统会自动让线程释放对锁的占用</li>
<li>  ReentrantLock 则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁现象。需要 lock 和 unlock 方法配合 try…finally 语句块来完成</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>等待是否可中断</strong></li>
</ol>
</blockquote>
<ul>
<li>  synchronized 不可中断，除非是抛出异常或者正常运行完成</li>
<li>ReentrantLock 可中断：<ol>
<li> 设置超时方法 <code>trylock（long timeout, TimeUnit unit）</code></li>
<li> <code>lockInterruptibly()</code> 放在代码块中，调用 interrupt() 方法可以中断。</li>
</ol>
</li>
</ul>
<blockquote>
<ol start="4">
<li> <strong>加锁是否公平</strong></li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li> <strong>锁绑定多个条件 Condition</strong></li>
</ol>
</blockquote>
<ul>
<li>  synchronized 没有</li>
<li>  ReentrantLock 用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像 synchronized 一样要么随机唤醒一个线程要么唤醒全部的线程。</li>
</ul>
<hr>
<h1 id="Synchronized（8锁）"><a href="#Synchronized（8锁）" class="headerlink" title="Synchronized（8锁）"></a>Synchronized（8锁）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>  对象锁；全局锁（静态锁/类锁）</p>
</blockquote>
<p>synchronized 实现同步的基础：Java 中每一个对象都可以作为锁。具体表现为以下 3 种形式：</p>
<ol>
<li><p> 对于同步方法，锁对象是当前实例对象（this）</p>
</li>
<li><p>对于同步代码块，锁对象是 synchronized 括号里配置的对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (&lt;锁对象&gt;)&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>对于静态同步方法，锁对象是当前类的 Class 对象</p>
</li>
</ol>
<blockquote>
<p>  <strong>锁对象是当前对象this</strong></p>
</blockquote>
<p>锁对象是当前对象 this 的情况有 2 种：</p>
<ol>
<li> 如果对象中存在被 <strong>synchronized</strong> 修饰的普通成员方法，那么该方法默认的锁对象就是当前对象 this。</li>
<li> 如果对象中存在 synchronized 代码块，也可以让当前对象 this 作为锁对象，但这不是唯一的。因为锁对象可以是任意对象。</li>
</ol>
<blockquote>
<p>  <strong>锁对象是当前类的 Class 对象</strong></p>
</blockquote>
<p>锁对象是当前类的 Class 对象的情况也有 2 种：</p>
<ol>
<li> 如果类中存在被 <strong>static synchronized</strong> 修饰的静态成员方法，那么该方法默认的锁对象就是当前类的 Class 对象。</li>
<li> 如果对象中存在 synchronized 代码块，同样也可以在同步代码块中指定锁对象为当前类的 Class 对象，这同样也不是唯一的。</li>
</ol>
<blockquote>
<p>  <strong>synchronized 机制</strong></p>
</blockquote>
<p><strong>如果一个方法被 synchronized 修饰，它锁的范围不仅仅是当前方法，而是包含这个方法的整个锁对象。</strong></p>
<ul>
<li>  即如果 synchronized 作用在一个普通成员方法/变量上，synchronized 锁的就是这个 this 对象。</li>
<li>  即如果 synchronized 作用在一个静态成员方法/变量上。synchronized 锁的就是这个类的 Class 对象。</li>
</ul>
<p>在一个对象里面，不管这个对象中有多少个同步方法，只要一个线程先访问了该对象中的任一同步方法，那么它锁的不仅仅是它访问的这一个同步方法，它锁的是该对象中的所有同步方法【因为该对象中的所有同步方法都需要该对象锁】。</p>
<p>一个对象里如果有多个 synchronized 方法，某一时刻，只要有任意一个线程去调用其中任一个 synchronized 方法，其它的线程就只能等待。换句话说就是，某一时刻，只能有唯一一个线程去访问这个对象中的 synchronized 方法。而对于对象中的非加锁方法则无限制。</p>
<p>如果锁对象是当前对象 this，被锁定后，其它线程都不能进入到当前对象的其它 synchronized 方法，但可以进入当前对象的非加锁方法。</p>
<p>如果锁对象是 Class 对象，被锁定后，其它线程就不能进入到该 Class 对象中执行其它的被  synchronized 修饰的方法，同样也可以执行非加锁方法。</p>
<hr>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><strong>资源类</strong></p>
<p>定义一个手机类，有三个功能：发邮件、发短信、sayHello</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*static*/</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// TimeUnit.SECONDS.sleep(3);	// 暂停3s</span></span><br><span class="line">            System.out.println(<span class="string">&quot;*****sendEmail&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*static*/</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>  <strong>测试类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁。问题：</span></span><br><span class="line"><span class="comment"> *  1、标准访问：请问先发送邮件、还是先发送短信</span></span><br><span class="line"><span class="comment"> *      先发送邮件</span></span><br><span class="line"><span class="comment"> *  2、暂停 3s 邮件方法，请问先发送邮件还是短信</span></span><br><span class="line"><span class="comment"> *      先发送邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3、新增普通 sayHello 方法，请问先发送邮件还是先说 hello</span></span><br><span class="line"><span class="comment"> *		先说hello</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  4、两部手机，请问先发送邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发短信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  5、两个静态同步方法，同一部手机，请问先发邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  6、两个静态同步方法，两部部手机，请问先发邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  7、一个静态同步方法，一个普通同步方法，同一部手机，请问先发邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发短信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  8、一个静态同步方法，一个普通同步方法，两部手机，请问先发邮件还是短信</span></span><br><span class="line"><span class="comment"> *		先发短信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoSafeArrayList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程--&gt;&gt; 操作 --&gt;&gt; 资源类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;phone.sendEmail();&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);	<span class="comment">// main线程暂停100ms，确保A线程能先于B线程创建</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            phone.sendSMS();  </span></span><br><span class="line"><span class="comment">//            phone.sayHello();</span></span><br><span class="line">            phone2.sendSMS();</span><br><span class="line">            &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mian 线程按顺序从上往下执行，A 线程先被创建出来（New），B 线程再被创建出来（New）</p>
<blockquote>
<ol>
<li> <strong>标准访问：请问先发送邮件、还是先发送短信？</strong></li>
</ol>
</blockquote>
<p>线程 A 先获得锁对象（this 对象，在这里是 phone 对象），在线程 A 未释放锁对象之前，整个资源类中的其它加锁方法也是不能被其它线程访问的。所以线程 A 会先执行 <code>Phone#sendEmail</code> 方法，再释放锁对象，此时线程 B 才有机会去得到锁对象，所以线程 B 后执行 <code>Phone#sendSMS</code> 方法。</p>
<blockquote>
<ol start="2">
<li> <strong>发邮件前暂停 3s ，请问先发送邮件还是短信？</strong></li>
</ol>
</blockquote>
<p>同情况 1 类似。并不是说线程 A 暂停了 3s 线程 B 就能趁着这 3s 时间去执行自己的发短信的方法。因为 <code>Phone#sendEmail</code> 和 <code>Phone#sendSMS</code> 用的是同一个锁对象，而线程 A 只是暂停 3s ，并没有归还锁对象，所以线程 B 的发短信方法还不能执行。只有等到线程 A 3s 后被唤醒，执行发邮件的方法，再释放锁对象后，线程 B 才能得到锁对象并执行发短信方法。</p>
<blockquote>
<ol start="3">
<li> <strong>新增 sayHello 方法，请问是先发送邮件还是先说 hello？</strong></li>
</ol>
</blockquote>
<p>此时，测试类作出一些改动：线程 B 不再发短信，而是改成说 hello 了，并且 sayHello 方法是不加锁的。</p>
<p>此时的情况变成了，A 线程仍率先拿到锁对象，准备去执行<code>Phone#sendEmail</code> 方法，但在这个方法内部需要先暂停 4s；这时候其它线程仍然是不能执行当前锁对象中的加锁方法的，但是对于非加锁方法并没有这个限制。也就是说，在发邮件方法等待的 4s 内，线程 B 已经执行完了 sayHello 方法了。也就是<code>Phone#sayHello</code> 方法先于 <code>Phone#sendEmail</code> 方法执行。</p>
<blockquote>
<ol start="4">
<li> <strong>两部手机，请问先发送邮件还是短信？</strong></li>
</ol>
</blockquote>
<p>再次回到 <code>Phone#sendEmail</code> 和 <code>Phone#sendSms</code> 方法，这时候创建两个手机实例对象 phone 和 phone2。</p>
<p>首先线程 A 率先拿到锁对象 phone，并在释放锁对象之前拒绝其它线程进入该对象执行加锁的方法；然后 B 线程也拿到了自己的锁对象 phone2 ，注意此时是有两个不同的锁对象的。线程 A 禁止其它线程执行 phone 对象中的加锁方法，而线程 B 则进制其它线程执行 phone2 对象中的加锁方法。这两个锁对象是不同的，所以执行中互不相关。由于线程 A 的发邮件方法要暂停 3s，那么显然线程 B 的发短信服务会先被执行。</p>
<blockquote>
<ol start="5">
<li> <strong>两个静态同步方法，同一部手机，请问先发邮件还是短信？</strong></li>
</ol>
</blockquote>
<p>修改 <code>Phone#sendEmail</code> 和 <code>Phone#sendSms</code> 方法均为静态方法。</p>
<p>由于静态加锁方法默认的锁是 Class 对象，Class 对象在类加载阶段就已经被创建出来了，是一个单例对象。所以不管通过该 Class 对象创建出来多少个实例，其锁对象始终只有一个，即 Class 对象。</p>
<p>程序执行过程中，线程 A 拿到锁对象 Phone_Class 对象；100ms 后线程 B 意图进入 Phone_Class 对象，但发现此时这个锁对象已经被线程 A 占用了，就只能等待直到 A 线程用完（执行完<code>Phone.sendEmail</code>方法）释放锁对象后，再去争夺锁对象来执行<code>Phone.sendSms</code> 方法。所以这种情况下会先发邮件。</p>
<blockquote>
<ol start="6">
<li> <strong>两个静态同步方法，两部部手机，请问先发邮件还是短信？</strong></li>
</ol>
</blockquote>
<p>类似于第 5 种情况，虽然是通过两个不同的实例对象 phone 和 phone2 来分别执行发邮件和发短信的方法的，但是由于发邮件和发短信的方法都是静态的，所以它们争夺的锁对象是同一个，自然也就会出现在某个线程争夺到锁对象后锁住对象内的其它加锁方法的情况了。所以这种情况下还是线程A会先抢到锁对象，也即发邮件会先于发短信执行。</p>
<blockquote>
<ol start="7">
<li> <strong>一个静态同步方法，一个普通同步方法，同一部手机，请问先发邮件还是短信</strong></li>
</ol>
</blockquote>
<p>静态同步方法要争夺的是 Class 对象锁，普通同步方法要争夺的是 this 对象锁，它们各自锁定的范围互不相关，所以不会存在争夺锁对象的情况。但是发邮件的速度要慢于发短信，所以发短信的方法先执行。</p>
<blockquote>
<ol start="8">
<li> <strong>一个静态同步方法，一个普通同步方法，两部手机，请问先发邮件还是短信?</strong></li>
</ol>
</blockquote>
<p>同第 7 种情况类似，两个线程使用两个不同的锁对象，不存在竞争关系。发短信的速度快于发邮件，所以发短信的操作先执行。</p>
<h2 id="小结（重要）"><a href="#小结（重要）" class="headerlink" title="小结（重要）"></a>小结（重要）</h2><p>加锁机制其实就是一个锁对象争夺的问题。</p>
<p>首先我们要明确<strong>锁对象是一个单例</strong>，如果一个类中只含有一个锁对象，并且该类中所有被 synchronized 修饰的方法用的都是同一把锁，那么显然同一时刻只能有一个线程持有这把锁，其它线程没有锁就只能等待锁被释放后再去争夺了。</p>
<p>在上面举的例子中，每个对象中就只设置了一个锁对象。那么自然该对象中所有被 synchronized 修饰的方法用的就是这把锁，就会出现线程 A 未释放锁前线程 B 不能执行其它被 synchronized 修饰的方法这种情况（因为其它 synchronized 方法执行所需要的锁还是线程 A 正在持有的锁）。</p>
<p>那么如果我们在一个对象中定义多把锁，每个加锁方法（被 synchronized 修饰的方法）用不同的锁。假设为：</p>
<ul>
<li>  定义两把锁 A、B</li>
<li>  定义两个加锁的方法 methodA()、methodB()。methodA() 方法用 A 锁，methodB() 方法用 B 锁，</li>
</ul>
<p>那么会出现一种情况就是：让线程1先被创建，线程2再被创建，执行同一个对象中的两个加锁方法methodA() 和 methodB()，但是线程1 执行方法 A 的时候，线程 B 也能执行方法 B，而不用等到线程 A 归还锁对象后线程 B 再执行方法 B，因为这两个加锁方法虽然在同一个类中，但是使用的不是一个锁对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/6 13:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MulLock</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;obj.methodA();&#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;obj.methodB();&#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法B 先于 方法A 执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulLock</span>&#123;</span><br><span class="line">    <span class="comment">// 在一个对象中定义两把锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;方法A被执行了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方法B被执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也就是<strong>判断一个对象中的多个方法能否被多个线程同时执行的最根本的依据就是这些方法使用的是不是同一把锁</strong>。</p>
<hr>
<h1 id="多线程间通信"><a href="#多线程间通信" class="headerlink" title="多线程间通信"></a>多线程间通信</h1><p>​    多线程并发执行时，默认情况下 CPU 是随机切换线程的，当我们需要多个线程能<strong>有规律</strong>的执行任务时，就需要通过线程来协调任务进度。</p>
<h2 id="宗旨："><a href="#宗旨：" class="headerlink" title="宗旨："></a>宗旨：</h2><ol>
<li> <strong>高内聚低耦合的情况下，线程  操作  资源类。</strong></li>
<li> <strong>线程执行体内的结构：判断/干活/通知</strong></li>
<li> <strong>防止虚假唤醒</strong></li>
</ol>
<p>​    </p>
<p>​        在实际的多线程应用中，多个线程不可能仅仅只是卖票（卖票是多个线程操作同一份资源，但执行的动作是相同的，也就是说无论哪个线程先执行对结果都不会影响，即使有一个线程特别牛逼，它一个人把票都卖完了也可以）。</p>
<p>​        通常情况会是：多个线程会操作同一资源，但是线程的执行顺序是有先后要求的。典型的就是生产消费线程，一个线程生产，另一个线程消费。这时候如果还是让 CPU 随机调度线程的话，就可能会出现供不应求（一直消费很少生产）或供过于求（一直生产很少消费）的情况，这都是不合适的。为了能让线程能按我们设计的顺序执行（比如生产线程执行一次，消费线程再执行一次，交替循环执行），达到供给平衡，我们就必须通过线程间的通信，通过频繁的挂起/唤醒线程来让线程按指定的顺序执行。</p>
<p>​        在一个线程执行体内，以生产/消费为例，最核心的代码当然是干活的代码，在生产线程中就是生产产品，在消费线程中就是消费产品。但是我们不能让线程直接去执行干活的代码，如果产品数量为0了，消费线程还去执行的话，显然是不合理的；同理，产品已经多到卖不完了，生产线程还一直生产产品也是不合适的。</p>
<p>​        在一个<strong>标准的线程执行体</strong>内，</p>
<ol>
<li> 第一步代码代码应该是<strong>判断</strong>。主要是根据实际需求判断当前线程进入后应该被挂起还是干活。在生产消费线程中，即使生产线程抢到了锁对象，在执行方法的时候首先也会判断当前产品是否足够，如果当前产品是充足的，它也不会去干活，而是把自己挂起，让消费线程去干活。消费线程也类似。</li>
<li> 只有判断之后才能开始<strong>干活</strong>。对于生产线程而言干活就是生产，对于消费线程而言干活就是消费。</li>
<li> 在干完活之后需要<strong>通知</strong>其它线程。这里的通知其实就是唤醒其它线程，因为在该线程干活之前可能存在为了让出锁资源而让自己陷入 Waiting 状态的线程，这种线程只有通过 notify 方法才能将其唤醒。这里的通知并不是把修改后的数据通知给其它线程，把修改后的数据通知给其它线程是通过 synchronized 的原子性来保证的。</li>
</ol>
<hr>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>​        实现：两个线程可以操作初始为 0 的一个变量，一个线程对变量进行 +1 操作，另一个线程对变量进行 -1 操作。加减操作交替执行 10 轮。最后结果仍为 0。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>​        根据题目可以看出这是一个经典的多线程通信问题。</p>
<ol>
<li> 多个线程操作同一份资源</li>
<li> 并且要求线程的执行顺序必须交替执行</li>
</ol>
<p>显然这需要通过多线程间通信来协调对资源的调度。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><ol>
<li> 定义一个操作类 Operator，类中有两个加锁的方法 add 和 sub 分别实现 +1 操作和 -1 操作。</li>
<li> 定义一个测试类 Demo ，创建两个线程 A、B 分别执行 add 方法和 sub 方法。每个方法执行 10 次。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">/*生产（+1）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、判断</span></span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、干活</span></span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+num);</span><br><span class="line">        <span class="comment">// 3、通知</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*消费（-1）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、判断</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、干活</span></span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+num);</span><br><span class="line">        <span class="comment">// 3、通知</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.day01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/6 14:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1、高内聚低耦合的前提下，线程 操作 资源类</span></span><br><span class="line"><span class="comment"> *  2、判断/干活/通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Operator</span> <span class="variable">ope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Operator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程A负责变量 +1，线程B负责变量 -1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.add();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.sub();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 测试结果如下，完全正确。我们可以看到 +1 操作和 -1 操作依次执行，交替 10 次。</li>
</ol>
<img src="/2021/07/03/JUC/image-20210706214541876.png" alt="image-20210706214541876" style="zoom: 67%;">



<h2 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h2><ol start="4">
<li> 我们在这里修改一下上面的代码，新增两个线程 C 和 D，让线程 C 负责加操作，线程 D 负责减操作。ABCD 交替执行 10 次。（只修改测试类的代码）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Operator</span> <span class="variable">ope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Operator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程A（+1）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.add();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程B（-1）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.sub();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程C（+1）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.add();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程D（-1）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ope.sub();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li> 我们想象中的代码的执行结果应该是：<code>1 -&gt; 0 -&gt; 1 -&gt; 0</code> 这样依次执行的。那么我们来看看真实的执行结果是什么呢？</li>
</ol>
<img src="/2021/07/03/JUC/image-20210706215410137.png" alt="image-20210706215410137" style="zoom:67%;">

<ol start="6">
<li><p>在结果中竟然看到了 <strong>2</strong> ，这与我们设计的程序不符。我们想象中的程序应该是：</p>
<ul>
<li>  每次当 add() 方法发现 num 为 1 时，不会干活，直接就把锁对象让出去了，只有 <code>num==0</code> 时，才会干活，进行 +1 操作。</li>
<li>  同理，每次当 sub() 方法发现 <code>num==0</code> 时，不会干活，直接就把锁对象让出去了，只有 <code>num==1</code> 时，才会干活，进行 +1 操作。</li>
</ul>
<p> 这样程序的执行结果永远只会是 0 和 1，且 0、1 交替出现，那么为什么会出现 2 呢？这种情况就叫做<strong>虚假唤醒</strong>，那么造成虚假唤醒的原因是什么呢？</p>
</li>
</ol>
<h3 id="虚假唤醒原理"><a href="#虚假唤醒原理" class="headerlink" title="虚假唤醒原理"></a>虚假唤醒原理</h3><blockquote>
<ol>
<li> <strong>只有两个线程的情况：</strong></li>
</ol>
</blockquote>
<p>在只有两个线程的情况下，线程 A 负责加操作，线程 B 负责减操作。</p>
<ol>
<li><p>当线程 A 获取到锁和 CPU 资源后，开始执行 add 方法。首先要判断当前 num 是否为 0，</p>
<ul>
<li>  如果 <code>num == 0</code> 才进行 +1 操作；</li>
<li>  否则，直接释放锁对象，自己进入 Waiting 状态。</li>
</ul>
</li>
<li><p>同理，当线程 B 获取到锁和 CPU 资源后，开始执行 sub 方法。首先判断当前 num 是否为 0，、</p>
<ul>
<li>  如果 <code>num == 0</code> 直接释放锁对象，自己进入 Waiting 状态；</li>
<li>  否则才进行 -1 操作。</li>
</ul>
<p> ​        但是请注意（以线程 A 进入 Waiting 状态为例）：假设线程 A 进入了 Waiting 状态，就会释放锁对象，并且此时 <code>num == 1</code> 恒成立，然后线程 B 必然会进入 Runnable 状态，并在随后得到 CPU 资源执行 sub 方法：1、进行 -1 操作  2、唤醒 A 线程。</p>
<p> ​        重点来了！！！线程 B 唤醒 A 线程后，B 与 A 此时都处于 Runnable 状态，然后开始竞争锁对象，假设这时候 A 获得了锁对象（当然如果 B 获得了锁对象也没有关系，因为此时 <code>num==0</code>，即使 B 获得了锁对象最终还是会执行 wait 方法归还锁对象），那么<strong>线程 A 并不会从头开始重新执行一遍 add 方法，而是直接续着上次执行的位置继续执行。 也就是判读操作在线程睡眠之前已经执行过一次了，线程醒来后就不再判断了，而是直接从上次断开的位置往下走。</strong></p>
</li>
</ol>
<p><img src="/2021/07/03/JUC/image-20210706222059608.png" alt="image-20210706222059608"></p>
<p>​    在只有 2 个线程的环境中这是 OK 的，因为只有两种状态，不会对结果产生影响。那么如果有 4 个线程呢？我们来分析一下。</p>
<blockquote>
<ol start="2">
<li> <strong>四个线程并发执行的情况</strong>：</li>
</ol>
</blockquote>
<ol>
<li><p> 初始情况，<code>num == 0</code>，ABCD 四个线程开始抢夺锁对象；</p>
</li>
<li><p> 假设 A+ 线程抢到了锁对象，执行 add 方法，由于<code>num==0</code>，开始干活，更新 <code>num==1</code>，唤醒其它线程，最后释放锁对象。</p>
</li>
<li><p> 接着 C+ 线程抢到了锁对象，执行 add 方法，由于<code>num==1</code>，不干活，进入 Waiting 状态，直接释放锁对象。</p>
</li>
<li><p> 此时 A+ 又抢到了锁对象，执行 add 方法，由于<code>num==1</code>，也不干活，进入 Waiting 状态，直接释放锁对象。</p>
</li>
<li><p>接下来线程 B- 终于抢到锁对象了。执行 sub 方法，由于<code>num==1</code>，开始干活，更新 <code>num==0</code>，唤醒其它线程，最后释放锁对象。</p>
<p> 请注意：这时候 A+ 和 C+ 线程又重新被唤醒了，进入了 Runnable 状态，ABCD 四个线程又处于同一起跑线上准备抢夺锁对象。</p>
</li>
<li><p> 这时因为 C+ 线程已经等了很久了，所以它又得到了锁对象，执行 add 方法，注意，它是从上一次断开的位置继续执行的，也就是 wait() 方法的后一行，也就是说这次 if 判断不再执行了，它直接就得干活，更新 <code>num==1</code>，然后唤醒其它线程，释放锁对象。</p>
</li>
<li><p> 接着 A+ 线程得到锁对象，执行 add 方法，同样它也会从上一次断开的位置继续执行，没有 if 判断，直接干活。诶，这时候你就会发现，num++ 执行后 <strong>num==2</strong>，if 判断失效了，这是不对的。我们想要的代码应该是发现 num==1 后就不再 +1 了，而是让 sub 方法去执行 -1 操作。这就是传说中的<strong>虚假唤醒原理</strong>。</p>
</li>
</ol>
<p><img src="/2021/07/03/JUC/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92.png" alt="虚假唤醒"></p>
<h3 id="如何解决虚假唤醒问题？"><a href="#如何解决虚假唤醒问题？" class="headerlink" title="如何解决虚假唤醒问题？"></a>如何解决虚假唤醒问题？</h3><p>虚假唤醒的问题管方很早就给出了解决的答案，在 Java8_API_Doc 中明确指出[<strong>java.lang.Object#wait</strong>]：</p>
<blockquote>
<p>  As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop</p>
<p>  中断和虚假唤醒是可能存在的，所以 <strong>wait()</strong> 方法应该总是在循环 <strong>while</strong> 中使用。</p>
</blockquote>
<p><img src="/2021/07/03/JUC/image-20210707110323903.png" alt="image-20210707110323903"></p>
<p>​        <strong>if</strong> 只起到判断的作用，而 <strong>while</strong> 则能起到<strong>循环判断</strong>的作用。只需要在上面代码中调用 wait 方法的地方用 while 语句替换 if 语句，即可解决虚假唤醒的问题。即每次线程从 Waiting 状态重新进入 Runnable 状态时，还是会进行一次判断的过程，判断成功则干活，不成功则再次进入 Waiting 状态。</p>
<blockquote>
<p>  <strong>修改代码</strong></p>
</blockquote>
<p>修改 Operator 类中的代码为：（只需要将所有使用 wait 方法的判断条件从 if 改为 while 即可）</p>
<p><img src="/2021/07/03/JUC/image-20210707111358025.png" alt="image-20210707111358025"></p>
<p>修改后的代码即可按照 <code>1-&gt;0-&gt;1_&gt;0</code> 的顺序交替执行。</p>
<h2 id="新版写法（Lock版）"><a href="#新版写法（Lock版）" class="headerlink" title="新版写法（Lock版）"></a>新版写法（Lock版）</h2><p>首先要明确一点，在 synchronized 的写法中，wait 和 notify 都是由 this 锁对象调用的。</p>
<p>而在 Lock 的写法中，this 对象不再是锁对象了，那么继续使用 this 调用 wait 和 notify 也就不合适了。在 JavaDoc 中，专门推出了一个接口类型 Condition 用于让线程进入等待/唤醒状态。接口中定义了 <strong>await()</strong> 、<strong>signal()<strong>、</strong>signalAll()</strong> 方法对标 Object 类中的 <strong>wait</strong>、<strong>notify</strong>、<strong>notifyAll</strong> 方法。对应方法的作用是一样的，但是 Condition 接口中的方法专门用于 Lock 锁对象。</p>
<p><img src="/2021/07/03/JUC/image-20210707120201254.png" alt="image-20210707120201254"></p>
<p><img src="/2021/07/03/JUC/image-20210707120803646.png" alt="image-20210707120803646"></p>
<ul>
<li>  官方的使用说明案例</li>
</ul>
<p><img src="/2021/07/03/JUC/image-20210707121613702.png" alt="image-20210707121613702"></p>
<blockquote>
<p>  <strong>修改代码（Operator类）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operator</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span>  <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*生产（+1）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、判断</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、干活</span></span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+num);</span><br><span class="line">            <span class="comment">// 3、通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">     <span class="comment">/*消费（-1）*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+num);</span><br><span class="line"></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>总结</strong></p>
</blockquote>
<p><img src="/2021/07/03/JUC/Lock%E9%94%81.png" alt="Lock锁"></p>
<h2 id="精准唤醒"><a href="#精准唤醒" class="headerlink" title="精准唤醒"></a>精准唤醒</h2><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><p><strong>要求</strong>：多线程之间按顺序调用，3个线程按照 <code>A-&gt;B-&gt;C</code> 的顺序执行。A线程打印5次“AA”，B 线程打印10次“BB”，C线程打印15次“CC”；重复10轮</p>
<p><strong>分解</strong>：</p>
<ol>
<li> A 线程打印5次“AA”，A线程进入 Waiting 状态，并通知B线程；</li>
<li> B 线程被唤醒，打印10次“BB”，B线程进入 Waiting 状态，并通知C线程；</li>
<li> C 线程被唤醒，打印10次“CC”，C线程进入 Waiting 状态，并通知A线程；</li>
<li> 这就是一轮，重复10轮。</li>
</ol>
<h3 id="分析1："><a href="#分析1：" class="headerlink" title="分析1："></a>分析1：</h3><blockquote>
<p>  <strong>前置知识：</strong></p>
</blockquote>
<p>每个锁对象会维护一个等待队列用于存储正在争夺该锁的线程实例。</p>
<blockquote>
<p>  <strong>过程分析：</strong></p>
</blockquote>
<p>​        要想实现三个线程ABC依次执行，可以为每一个线程设置唯一的<strong>标志位</strong>，假设为：<strong>线程A：1</strong>；<strong>线程B：2</strong>；<strong>线程C：3</strong>。</p>
<ol>
<li> 假设线程 A 先得到了锁对象，线程 A 执行完之后，先修改标志位（指定下一个要执行的线程），再将锁抛出；</li>
<li> 这时候按照需求本应该线程 B 来执行了，但是由于线程 A 将锁抛出之前唤醒了所有线程，所以此时线程 A、B、C 会一起争夺锁对象，谁得到锁谁就执行。</li>
<li> 假设 C 得到了锁对象，由于标志位不匹配，线程 C 会进入 Waiting 状态，并将锁抛出，让线程 AB 重新争夺锁对象；</li>
<li> 假设接下来 B 得到了锁对象，由于标志位不匹配，线程 B 也会进入 Waiting 状态，并将锁抛出；</li>
<li> 接下来只有线程 B 是活跃的了，线程 B 直接得到锁对象，B 执行完方法后，修改标志位，唤醒其它所有线程，抛出锁对象。</li>
<li> 又开始新一轮的 ABC 抢占锁对象。</li>
<li> 所以如果我们这么设计代码的话，在电脑上正常是可以按需求顺利执行的。但是<strong>每次都是抢占式调度的话，每次让正确的线程得到锁对象的时间都会花费较多的时间</strong>。</li>
</ol>
<h3 id="代码实现1："><a href="#代码实现1：" class="headerlink" title="代码实现1："></a>代码实现1：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                cpu.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                cpu.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                cpu.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志位。线程A：1；线程B：2；线程C：3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">// 默认线程A先执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lock锁，每个锁可以设置多个监听器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>)&#123;</span><br><span class="line">                c.await(); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">2</span>;   <span class="comment">// 干完活后修改标志位</span></span><br><span class="line">            c.signalAll();	<span class="comment">// 唤醒所有线程</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>)&#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">3</span>;   </span><br><span class="line">            c.signalAll();    </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>)&#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">1</span>;   </span><br><span class="line">            c.signalAll();    </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="分析2："><a href="#分析2：" class="headerlink" title="分析2："></a>分析2：</h3><p>​        如果多个线程间能实现<strong>精准通知</strong>，即 A 干完活唤醒 B，B 干完活唤醒 C，C 干完活唤醒 A，形成一个闭环。而不是 ABC 每次干完活后进行广播式的通知，唤醒所有线程进行抢占式的资源争夺。那么显然程序的执行速度能得到极大的提升，因为这样就减少了每次线程抢占锁对象成功但在方法体中的判断不成功导致线程重新被挂起和重新被唤醒的时间。</p>
<p>​        为了能满足这个条件，首先 <strong>Object#notifyAll</strong> 和 <strong>Condition#signalAll</strong> 方法是肯定不能使用的。那么 <strong>Object#notify</strong> 和 <strong>Condition#signal</strong> 该选择哪一个呢？首先我们来看下 <strong>Object#notify</strong> 的源码。</p>
<p><img src="/2021/07/03/JUC/image-20210707143619075.png" alt="image-20210707143619075"></p>
<p>​        具体就是说：唤醒此对象监视的等待队列中的一个线程，如果这个对象有多个等待中的线程，就会选择其中一个被唤醒。这个选择是任意的，由实现自行决定。也就是说，<strong>如果我们不自己手动去实现，那么调用 notify 方法唤醒的线程是随机的</strong>。那么显然，要想做到精准唤醒就不适合是用 notify 方法了，当然也不是不可以用，只是要自己去重写 notify 方法比较复杂，而且在 JUC 包下已经提供了现成的可以实现精准唤醒的方法，你自己实现也不见得能比人家写得好。这个方法就是 signal 方法，我们来看一下。</p>
<p><img src="/2021/07/03/JUC/image-20210707144208656.png" alt="image-20210707144208656"></p>
<p>​        <strong>signal()</strong> 方法的作用就是唤醒一个等待的线程，但是这里它是<strong>可以自行选择</strong>的。也就是说如果有多个线程BCD都处于 Waiting 状态，A线程正在使用锁对象，A在使用完锁后，不再是把锁往出一扔就不管了，它是可以指定下一个给谁，通过这个方法我们就可以实现将处于 Waiting 状态的多个线程精准唤醒了。</p>
<h3 id="Condition-接口"><a href="#Condition-接口" class="headerlink" title="Condition 接口"></a>Condition 接口</h3><ul>
<li>  Lock 锁与监听器（Condition）是<strong>一对多</strong>的，一个 Lock 锁可以有多个监听器，Condition 与线程也是<strong>一对多</strong>的，每个 Condition 都可以监视该锁对象锁住的所有线程，即每个 Condition 都维护一个线程等待队列。</li>
<li>  <strong>Condition 维护了一个等待队列</strong>，默认情况下它会将等待时间最长的线程优先级设置为最高（即放在队首元素），但是可以手动绑定一个线程作为某个 Condition 优先级最高的线程，看起来的效果就是只要通过该监听器唤醒的线程是确定的。</li>
<li>  如果想要实现线程间的精准唤醒，Condition 数量最好设置成与线程数相等的，即每个 Condition 的最高优先级的名额绑定一个线程。</li>
<li>  <strong>线程在第一次调用 wait() 方法的时候与监听器绑定</strong>。</li>
</ul>
<p><img src="/2021/07/03/JUC/%E9%94%81%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8.png" alt="锁和监听器"></p>
<h3 id="代码实现2："><a href="#代码实现2：" class="headerlink" title="代码实现2："></a>代码实现2：</h3><p>只需修改 CPU 类中代码即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志位。线程A：1；线程B：2；线程C：3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">// 默认线程A先执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lock锁，每个锁可以设置多个监听器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>)&#123;</span><br><span class="line">                c1.await(); <span class="comment">// 持有 c1 钥匙的线程进入 Waiting</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">2</span>;   <span class="comment">// 干完活后修改标志位</span></span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>)&#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">3</span>;   <span class="comment">// 干完活后修改标志位</span></span><br><span class="line">            c3.signal();    <span class="comment">// 唤醒</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断、干活、通知</span></span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>)&#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">1</span>;   <span class="comment">// 干完活后修改标志位</span></span><br><span class="line">            c1.signal();    <span class="comment">// 唤醒</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h4><p>在 CPU 类中，定义了一个锁对象，锁对象分配了 3 个监听器。注意此时监听器还尚未与线程绑定。初始标志位为 1</p>
<ol>
<li><p>首先 A 线程得到了锁对象，</p>
<ul>
<li>经标志位判断后应该干活，</li>
<li>就去干活了，</li>
<li>干完活后修改了<strong>标志位为 2</strong>，</li>
<li>最后通知 c2 监听的阻塞队列中优先级最高的线程，让它来获取锁对象。  <em>注意：此时 c2 监听器还未手动指定优先级最高的线程，即 c2 监听的阻塞队列是按照默认的线程等待时间划分优先级的。虽然此时 ABC 三个线程都是 Runnable 的，但是 B 和 C 等待时间一定长于 A，所以 c2 此时会将锁对象分配给 B 和 C 中等待时间较长的线程。</em></li>
</ul>
</li>
<li><p>假设接下来 C 线程得到锁对象，</p>
<ul>
<li>经判断后发现没有轮到它干活，需要被挂起。调用 <code>c3.await</code> 方法让线程C进入 Waiting 状态，并释放锁对象。  <em>注意，此时<strong>监听器 c3 维护的阻塞队列队首元素就被写死为线程 C 了</strong>，以后再调用 c3.signal 唤醒的一定是线程 C。</em></li>
</ul>
</li>
<li><p>由于线程 C 被挂起了，线程 A、B 抢夺锁对象，假设 B 抢到了锁对象，</p>
<ul>
<li>  经标志位判断后应该干活，</li>
<li>  就去干活了，</li>
<li>  干完活后修改了<strong>标志位为 3</strong>，</li>
<li>  最后将锁对象分配给 c3 监听的阻塞队列中优先级最高的线程，即线程 C。</li>
</ul>
</li>
<li><p>线程 C 得到锁对象。</p>
<ul>
<li>  经标志位判断后应该干活，</li>
<li>  就去干活了，</li>
<li>  干完活后修改了<strong>标志位为 1</strong>，</li>
<li>  最后将锁对象分配给 c1 监听的阻塞队列中优先级最高的线程。</li>
<li>  由于 c3 已经与线程 C 绑定了，所以此时就相当于唤醒线程 C。</li>
<li>  此时线程 B 和 C 都处于 Runnable 状态，均可争夺锁对象。</li>
</ul>
</li>
<li><p>假如 B 争夺到了锁对象，</p>
<ul>
<li>  经判断后发现没有轮到它干活，需要被挂起。调用 <code>c2.await</code> 方法让线程 B 进入 Waiting 状态，并释放锁对象。</li>
<li>  此时<strong>监听器 c2 就真正与线程 B 绑定了</strong>。</li>
<li>  <strong>至此，线程ABC就分别于 c1、c2、c3监听器绑定了</strong>。</li>
</ul>
</li>
<li><p>此时只剩 C 还处于 Runnable 状态，线程 C 得到锁对象。</p>
<ul>
<li>  经标志位判断后应该干活，</li>
<li>  就去干活了，</li>
<li>  干完活后修改了<strong>标志位为 1</strong>，</li>
<li>  最后唤醒监听器 c1 监听的线程（线程A），让它来获取锁对象。</li>
</ul>
</li>
<li><p> ……</p>
</li>
</ol>
<blockquote>
<p>  <strong>一些疑问</strong></p>
</blockquote>
<ol>
<li><p>假设线程 A、B、C分别绑定了c1、c2、c3 监听器，线程A正在执行，线程B、C 处于 Waiting 状态，线程A执行完毕后，释放锁对象，通过 c2 唤醒线程B。那么这个时候线程 A 到底该不该和线程 B 去抢夺锁对象呢？</p>
<p> <em>答：由于 c2 监听器监听的线程阻塞队列中优先级最高的已经是 B 线程了，所以监听器 c2 监听到线程 A 释放锁对象后，c2 会直接把锁对象分配给线程 B。即使这时候线程 A 和线程 B 都处于 Runnable 状态，但是由于线程 B 的优先级一定是最高的，所以不会考虑线程 A。</em></p>
</li>
</ol>
<p>​        从理论上来讲，线程 B 被唤醒后处于 Runnable 状态，而线程 A 顺利执行完毕后并不会进入 Waiting 状态，并且 run() 方法中的代码没有执行完（要循环10次，假设目前只循环了1次），线程 A 也不会变成 Teminated 状态，那么我觉得线程 A 就也会变成 Runnable 状态，那么此时还是会有两个线程抢占式地争夺锁对象，自然也就称不上是精准唤醒了。</p>
<p>​        此块好像用到了 CAS ，先这样处理。等弄清楚后再补充。</p>
<hr>
<h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><ul>
<li>  Callable 是 Java 中实现多线程的四种方式之一。</li>
<li>  Callable 是一个函数式接口 <code>--&gt;&gt;</code> 支持 Lambda 表达式。</li>
</ul>
<h2 id="1-Callable-和-Runnable-的区别（3-点）"><a href="#1-Callable-和-Runnable-的区别（3-点）" class="headerlink" title="1    Callable 和 Runnable 的区别（3 点）"></a>1    Callable 和 Runnable 的区别（3 点）</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Runnable</th>
<th align="center">Callable</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现的方法不同</td>
<td align="center"><code>run()</code></td>
<td align="center"><code>call()</code></td>
</tr>
<tr>
<td align="center">是否抛出异常</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">有无返回值</td>
<td align="center">无</td>
<td align="center">有</td>
</tr>
</tbody></table>
<h2 id="2-通过Callable-实现多线程"><a href="#2-通过Callable-实现多线程" class="headerlink" title="2    通过Callable 实现多线程"></a>2    通过Callable 实现多线程</h2><p>首先我们来看一下标准的通过 Runnable 接口实现多线程的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;==========Runnable Starting&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Runnable线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        那么我们继续通过这种方式来通过 Callable 接口实现多线程可以吗？答案是不可以的。我们可以看到，在 Thread 的构造函数这一步出错了。</p>
<img src="/2021/07/03/JUC/image-20210708205927767.png" alt="image-20210708205927767" style="zoom: 80%;">

<p>来看一下 Thread 的构造函数。</p>
<p><img src="/2021/07/03/JUC/image-20210708210157359.png" alt="image-20210708210157359"></p>
<p>​        <strong>Thread 的构造方法有多种重载形式，但是没有一种可以直接接收 Callable 类型的参数</strong>，所以我们就不能直接在构造 Thread 对象的时候就绑定 Callable 接口。那么如何通过 Thread 关联到 Callable 呢？这就需要有一个中间的传递者，它既能认识 Thread，又能认识 Callable。</p>
<ol>
<li><p> 首先要明确一点，Thread 的构造器不能接收 Callable 类型的参数，但是可以接收 Runnable 类型的参数。根据类的多态性，Thread 的构造方法同样可以接收 Runnable 的子类类型对象，比如 <strong>RunnableFuture</strong> ，这是 Runnable 接口的一个子接口。</p>
</li>
<li><p>在 RunnableFuture 接口的实现类中有一个 <strong>FutureTask</strong> 类，我么来看一下它的构造方法。</p>
<p> <img src="/2021/07/03/JUC/image-20210708210859384.png" alt="image-20210708210859384"></p>
<p> 发现创建 FutureTask 时构造方法中可以传入一个 Runnable 对象或是 Callable 对象。 </p>
</li>
<li><p>  这时我们再来捋一捋，Thread 对象在创建时可以传入一个 Runnable 类型的对象，FutureTask 类的爷爷辈是 Runnable 接口，而 FutureTask 对象在创建时又需要一个 Callable 对象，这样我们就可以把 Callable 对象与 Thread 联系起来了。</p>
</li>
</ol>
<img src="/2021/07/03/JUC/image-20210708211522773.png" alt="image-20210708211522773" style="zoom:80%;">

<p>​    接下来改写我们的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、FutureTask 中的泛型类型应与 Callable 中线程执行体的返回值类型一致</span></span><br><span class="line"><span class="comment"> * 2、通过 FutureTask#get() 方法来获得 Callable 中线程执行体的返回值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;==========Callable Start&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;==========Callable end&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;Callable线程&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (!futureTask.isDone())&#123;	</span><br><span class="line">            <span class="comment">// 如果 Callable 线程没有计算完毕，则 main 线程等待其算完后再进行下一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();	<span class="comment">// 获得Callable线程的返回结果，如无必要，放在程序执行的最后，避免堵塞main线程</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><blockquote>
<p>  <strong>CountDownLatch；倒计时锁</strong></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>  <code>CountDownLatch</code> 是一种同步辅助工具，作用是<strong>让一个或多个线程挂起，直到另一些线程完成了一系列操作后被挂起的线程再被唤醒</strong>。</li>
<li>  <code>CountDownLatch</code> 对象是用给定的计数器初始化的。<strong>调用 await 方法会使当前线程阻塞</strong>，调用 <strong>countDown()</strong> 方法会减少计数值，直到当前计数减为零之后，所有等待的线程都会被释放， await 方法的后面的代码会继续执行。</li>
</ul>
<p><img src="/2021/07/03/JUC/image-20210713124120349.png" alt="image-20210713124120349"></p>
<hr>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="/2021/07/03/JUC/image-20210713130528886.png" alt="image-20210713130528886"></p>
<ul>
<li>  <strong>CountDownLatch#await()</strong> ：让当前线程进入等待，直到 latch 锁减到 0 再唤醒线程（每次减 1）。</li>
<li>  <strong>CountDownLatch#countDown()</strong> ：减少 latch 锁的计数，如果计数达到 0  则释放所有等待的线程。</li>
</ul>
<hr>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><blockquote>
<p>  <strong>场景模拟：</strong></p>
</blockquote>
<p>火箭发射前需要先执行 5 项准备工作，这 5 个任务是并发执行的，无先后顺序，但是必须等到这 5 个任务准备就绪后，才能发射火箭。</p>
<blockquote>
<p>  <strong>原始代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;=====准备就绪&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;火箭发射成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果：</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> * 火箭发射成功</span></span><br><span class="line"><span class="comment"> * 任务4=====准备就绪</span></span><br><span class="line"><span class="comment"> * 任务3=====准备就绪</span></span><br><span class="line"><span class="comment"> * 任务2=====准备就绪</span></span><br><span class="line"><span class="comment"> * 任务1=====准备就绪</span></span><br><span class="line"><span class="comment"> * 任务5=====准备就绪</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  在上面代码中，6个线程并发执行，所以并不能保证火箭发射一定会在 5 个准备工作之后进行。</li>
<li>  面对这种情况，我们之前的做法一般是让 <code>main</code> 线程先休眠足够长的时间，这段时间内让  5 个准备工作先执行完毕，最后再执行发射火箭的操作。这种操作虽然能解决问题，但是由于休眠时间是手动设定的，并不能保证一定精准。</li>
<li>  在这种情况下最好的方法就是使用 <strong>CountDownLatch</strong> 类。</li>
</ul>
<blockquote>
<p>  <strong>使用 CountDownLatch 优化后代码</strong></p>
</blockquote>
<p><img src="/2021/07/03/JUC/image-20210713131401299.png" alt="image-20210713131401299"></p>
<p>首先创建一个 <code>CountDownLatch</code> 对象，初始化值计数为 5，下面的操作都是并发执行的。</p>
<ul>
<li>  假设先执行 for 循环，创建了第一个线程，之后线程被挂起，而去执行 mian 线程了；</li>
<li>  main 线程执行到 <code>countDownLatch.await();</code> 时发现 CountDownLatch 对象的计数值不为 0，就会让当前线程（main）进入睡眠。</li>
<li>  for 循环中每个线程执行完毕时都会将 <code>CountDownLatch</code> 对象中的计数器 <code>-1</code>，当 for 循环中的五个线程全部执行完毕后，计数器值就会变成 0 ，这时由于 <code>countDownLatch.await();</code> 方法而挂起的线程会全部被唤醒（这里只有一个等待的线程，所以只唤醒了一个）</li>
</ul>
<blockquote>
<p>  <strong>执行结果：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">任务<span class="number">4</span>=====准备就绪</span><br><span class="line">任务<span class="number">5</span>=====准备就绪</span><br><span class="line">任务<span class="number">1</span>=====准备就绪</span><br><span class="line">任务<span class="number">3</span>=====准备就绪</span><br><span class="line">任务<span class="number">2</span>=====准备就绪</span><br><span class="line">火箭发射成功</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 个准备工作线程是没有指定的工作顺序的，但是 发射操作 一定会在 5 个准备工作全部完成之后才进行</span></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><blockquote>
<p>  <strong>CyclicBarrier；循环屏障</strong></p>
</blockquote>
<ul>
<li>  <code>CyclicBarrier</code> 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。</li>
<li>  它的主要作用是：让一组线程一起通过屏障点（也可以叫同步点）。每当有线程到达屏障点时，该线程就停止运行，直到所有的线程都到达了这个点，所有线程才重新运行。</li>
<li>  它的构造方法可以指定一个目标值，只有当到达屏障点的线程数量等于目标值时，屏障才会开门，所有停住的线程会同时继续运行。</li>
<li>  线程通过通过 <strong>Cyclic#await</strong> 方法停止运行，每调用一次 <code>await()</code> 方法，目标值+1。</li>
<li>  集齐七颗龙珠，才能召唤神龙。</li>
<li>  与 CountDownLatch 恰恰相反，CyclicBarrier 初始值为 0，只有达到指定值，才能开始执行。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><img src="/2021/07/03/JUC/image-20210713141702447.png" alt="image-20210713141702447"></p>
<blockquote>
<p>  <strong>两个参数的含义</strong>：</p>
</blockquote>
<ol>
<li> <strong>int parties</strong>：目标值</li>
<li> <strong>Runnable barrierAction</strong>：达到目标值后要执行的线程</li>
</ol>
<h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, ()-&gt;&#123; System.out.println(<span class="string">&quot;=======召唤神龙&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收集到了&quot;</span>+ temp +<span class="string">&quot;星龙珠&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();  <span class="comment">// 七个线程每个线程收集一颗龙珠，收集完成后，挂起</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;测试是否执行后续代码&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, Thread.currentThread().getName()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当七个线程全部执行完毕后，目标值就达到了，可以破开屏障，先执行 CyclicBarrier 构造方法中指定的线程，</span></span><br><span class="line">        <span class="comment">// 再执行之前被挂起的七个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果展示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 收集到了1星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了7星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了6星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了5星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了4星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了3星龙珠</span></span><br><span class="line"><span class="comment"> * 收集到了2星龙珠</span></span><br><span class="line"><span class="comment"> * =======召唤神龙</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> * 测试是否执行后续代码</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><blockquote>
<p>  <strong>Semaphore；信号量；抢车位</strong></p>
</blockquote>
<ul>
<li>  多个线程抢多个资源</li>
<li>  Semaphore 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于<strong>控制并发的线程数</strong>。</li>
</ul>
<blockquote>
<p>  <strong>Semaphore 中的方法：</strong></p>
</blockquote>
<p><strong>Semaphore(int permits)</strong> 构造方法中指定了当前进程中最多只能允许几个线程同时运行。意思就是一个萝卜一个坑，线程就是萝卜，萝卜可以有多个，但是坑位是有限的，线程数可以远大于坑位数，但是同时（并发）运行的只能与坑位数量相同。</p>
<ul>
<li>  <code>Semaphore # acquire()</code>：占有坑位</li>
<li>  <code>Semaphore # release()</code>：释放坑位</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.other;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 14:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 模拟3个车位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;  <span class="comment">// 模拟6部汽车</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();    <span class="comment">/*抢到资源*/</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;====抢到车位&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;====停车3s后离开&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();    <span class="comment">/*释放资源*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/07/03/JUC/image-20210713144925160.png" alt="image-20210713144925160" style="zoom:80%;">

<blockquote>
<p>  <strong>结果分析：</strong></p>
</blockquote>
<ul>
<li>  线程 2、4、1 先抢到车位资源，每占用一分资源，Semaphore 信号量的值减少 1。线程使用完后，需要将占用的资源释放，每释放一份资源。Semaphore 信号量的值增加 1。</li>
<li>  当信号量值大于 0 时，表示还有资源（车位）可以使用，当为 0 时则表示没有资源能被使用了，这时每当有资源被释放，被阻塞的线程就可以去争夺资源了。</li>
<li>  我们在本地中设置每个线程对车位的使用时间都是 3s，所以基本上出现的是几乎 3 个线程同时占用，3 个线程同时释放的情况。如果我们将每个线程对车位的使用时间都设为随机值，就可以模拟，汽车走一辆，进来一辆的情况。</li>
</ul>
<hr>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><ul>
<li>  <a href>超链接：阻塞队列</a></li>
</ul>
<hr>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><ul>
<li><p>  lock() 方法 底层调用的是 sync.lock(); 方法；</p>
</li>
<li><p>  sync 是一个 Sync 类的对象，继承自 AbstractQueuedSynchronizer（AQS），实现类包括：</p>
</li>
<li><p>在非公平锁的实现方法中：</p>
<ol>
<li> 先进行 CAS 操作，如果 CAS 操作失败才去取同步队列中的第一个元素。</li>
</ol>
</li>
<li><p>  在公平锁的 lock 方法中：直接获取同步队列的第一个元素</p>
</li>
<li><p>  非公平锁和公平锁都没有重写 unlock 方法，所以用的是 Sync 对象中的同一个 unlock 方法</p>
</li>
<li><p>unlock() 方法 底层调用的是 sync.release(1); 方法</p>
<ul>
<li>  检查同步队列头结点是否为 null + 头结点状态设置为 </li>
</ul>
</li>
</ul>
<hr>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><img src="/2021/07/03/JUC/%E6%AD%BB%E9%94%81.png" alt="死锁"></p>
<p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种<strong>互相等待的现象</strong>，若无外力干涉那它们都将无法推进下去。如果系统资源充足，线程的资源请求都能满足，死锁出现的可能性就很低，否则就会因为争夺优先的资源而陷入死锁。</p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ul>
<li>  系统资源不足</li>
<li>  进程运行推进的顺序不合适</li>
<li>  资源分配不当</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/16 11:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造注入*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String lockA, String lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;****自己持有&quot;</span> + lockA + <span class="string">&quot;，尝试获得：&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;****自己持有&quot;</span> + lockB + <span class="string">&quot;，尝试获得：&quot;</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockA, lockB), <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockB, lockA), <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/03/JUC/image-20210716115243510.png" alt="image-20210716115243510"></p>
<p><strong>代码分析</strong></p>
<ol>
<li> main 线程启动，创建两个子线程 T1 和 T2。</li>
<li> 假设 T1 先执行，T1 先去争夺锁对象 lockA，此时无人争夺该锁对象，T1 得到 lockA 后在控制台上打印输出，然后进入睡眠状态。</li>
<li> T1 睡眠的时间足够长，足够 T2 线程获取到 lockB 对象并在控制台上打印输出，然后 T2 也进入睡眠状态。</li>
<li> 当 T1 睡醒后，只有得到了 lockB 锁才能继续执行下去，而 lockB 正在被 线程 T2 持有；当 T2 睡醒后，只有得到 lockA 才能继续执行下去，而 lockA 被线程 T1 持有。</li>
<li> 两个线程想要能继续执行的锁都被彼此所持有，这就造成了死锁的现象。</li>
</ol>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/" class="post-title-link" itemprop="url">Java面经——JavaSE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-28 13:14:51" itemprop="dateCreated datePublished" datetime="2021-06-28T13:14:51+08:00">2021-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-07-03 09:56:37" itemprop="dateModified" datetime="2021-07-03T09:56:37+08:00">2021-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">Java面经</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-类的初始化和实例化过程"><a href="#1-类的初始化和实例化过程" class="headerlink" title="1    类的初始化和实例化过程"></a>1    类的初始化和实例化过程</h1><blockquote>
<p>  <strong>问题：</strong>下图所示代码的输出结果是什么？</p>
</blockquote>
<p><img src="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/image-20210628141649356.png" alt="image-20210628141649356"></p>
<ul>
<li>  输出结果：</li>
</ul>
<p><img src="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/image-20210628141540786.png" alt="image-20210628141540786"></p>
<blockquote>
<p>  <strong>考点：</strong></p>
</blockquote>
<ul>
<li>  类初始化过程</li>
<li>  实例初始化过程</li>
<li>  方法的重写</li>
</ul>
<h2 id="1-1-类初始化过程"><a href="#1-1-类初始化过程" class="headerlink" title="1.1    类初始化过程"></a>1.1    类初始化过程</h2><blockquote>
<p>  <strong>类的初始化过程？</strong></p>
</blockquote>
<p>一个类的加载和初始化其实就是执行类的 <code>&lt;clinit&gt;()</code> 方法。</p>
<ul>
<li>  <code>&lt;clinit&gt;()</code> 方法由<strong>静态类变量显式赋值代码</strong>和<strong>静态代码块</strong>组成</li>
<li>  类变量显式赋值代码和静态代码块代码按从上到下的顺序执行</li>
<li>  <code>&lt;clinit&gt;()</code>方法只会执行一次，即类只会被加载和初始化一次。</li>
</ul>
<blockquote>
<p>  <strong>注意事项</strong>：</p>
</blockquote>
<ol>
<li>一个类要创建实例对象时首先要先加载并初始化该类。<ul>
<li>  无论要创建的实例对象对应的类是什么，首先 <code>main()</code> 方法所在的类需要被加载和初始化。也就是说，即使 <code>main()</code> 方法中什么也不写，JVM 也会加载并初始化 <code>main()</code> 方法所在的类。</li>
</ul>
</li>
<li> 一个子类在初始化之前需要先初始化父类。</li>
</ol>
<hr>
<h2 id="1-2-实例初始化过程"><a href="#1-2-实例初始化过程" class="headerlink" title="1.2    实例初始化过程"></a>1.2    实例初始化过程</h2><blockquote>
<p>  <strong>实例的初始化过程？</strong></p>
</blockquote>
<p>实例对象的初始化就是执行对象 <code>&lt;init&gt;()</code> 方法。</p>
<ul>
<li>  <code>&lt;init&gt;()</code> 方法可能重载有多个，有几个构造器就有几个 <code>&lt;init&gt;()</code> 方法。</li>
<li>  <code>&lt;init&gt;()</code> 方法由<strong>非静态实例变量显式赋值代码</strong>和<strong>非静态代码块</strong>、对应<strong>构造器代码</strong>组成。</li>
<li>  非静态实例变量显式赋值代码和非静态代码块代码从上到下顺序执行，而<strong>对应构造器的代码最后执行</strong>。</li>
<li>  每次创建实例对象，调用对应构造器，都会执行一次对应的 <code>&lt;init&gt;()</code> 方法。</li>
<li>  <code>&lt;init&gt;()</code> 方法中，首行一定是 <code>super()</code> 或 <code>super(实参列表)</code>，即对应父类的<code> &lt;init&gt;()</code> 方法。也就是说，在执行子类的 <code>init</code> 方法之前，必然会先执行父类的 <code>init</code> 方法。</li>
</ul>
<hr>
<h2 id="1-3-方法重写"><a href="#1-3-方法重写" class="headerlink" title="1.3    方法重写"></a>1.3    方法重写</h2><blockquote>
<ol>
<li> 哪些方法不可以被重写？</li>
</ol>
</blockquote>
<p>答：不会产生歧义的方法。</p>
<ul>
<li>  final 方法</li>
<li>  静态方法</li>
<li>  <strong>private 等子类中不可见的方法</strong></li>
</ul>
<blockquote>
<ol start="2">
<li> 对象的多态性</li>
</ol>
</blockquote>
<ul>
<li>  子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码。</li>
<li>  非静态方法默认的调用对象是 this。</li>
<li>  this 对象在构造器或者说 <code>&lt;init&gt;()</code> 方法中就是正在创建的对象。</li>
</ul>
<h2 id="1-4-代码分析"><a href="#1-4-代码分析" class="headerlink" title="1.4    代码分析"></a>1.4    代码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  1、先进行父类的初始化（即执行父类的 &lt;clinit&gt;() 方法）（Father 默认继承 Object）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2、再进行当前类的类初始化方法（即执行当前类的 &lt;clinit&gt;() 方法）。</span></span><br><span class="line"><span class="comment"> *		输出：（5）（1）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3、执行父类的实例化过程（即执行父类的 &lt;init&gt;() 方法）。子类在实例化之前需先对父类进行实例化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  4、再执行当前类的实例化方法。</span></span><br><span class="line"><span class="comment"> *		输出：（9）（3）（2）</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Tip：非静态方法在执行时必须要有一个 this 对象，它表示正在创建的对象。在本例中，正在创建的对象是 main() 方法中的 Son 对象，</span></span><br><span class="line"><span class="comment"> *  所以这里的 i = test() 等价于 i = this.test()，也就是 i = Son的实例对象.test()，真正执行的是子类中重写的 test() 方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="comment">/*this.*/</span>test();</span><br><span class="line">    <span class="comment">// 类变量赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;（1）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Father()&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;（2）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;（3）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;（4）&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;（5）&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  1、先对 main() 方法所在的类进行类初始化。[这里 main() 方法所在的类就是 Son 类]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2、对 Son 类进行类初始化，即执行 &lt;clinit&gt;() 方法</span></span><br><span class="line"><span class="comment"> *      2.1 子类类初始化之前先对父类进行类初始化（即对 Son类的父类 Father 类进行类初始化）：（5）（1）</span></span><br><span class="line"><span class="comment"> *      2.2 再对子类（Son）进行类初始化：（10）（6）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3、子类的实例化方法 &lt;init&gt;()</span></span><br><span class="line"><span class="comment"> *      3.1 子类实例化之前先对父类进行实例化，即执行 &lt;init&gt;() 方法（最先执行）</span></span><br><span class="line"><span class="comment"> *      3.2 i = test()</span></span><br><span class="line"><span class="comment"> *      3.3 子类的非静态代码块</span></span><br><span class="line"><span class="comment"> *      3.4 子类的构造方法（最后执行）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  4、因为创建了两个 Son 对象，因此实例化方法 &lt;init&gt;() 执行两次</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="comment">// 类变量赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;（6）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Son()&#123;</span><br><span class="line"><span class="comment">//        super();  // 无论是否显式写出来该方法都存在，在子类构造器中一定会调用父类的构造器</span></span><br><span class="line">        System.out.print(<span class="string">&quot;（7）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;（8）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;（9）&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;（10）&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-5-进阶要求"><a href="#1-5-进阶要求" class="headerlink" title="1.5    进阶要求"></a>1.5    进阶要求</h2><blockquote>
<ol>
<li> Override 和 Overload 的区别？</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li> Override 重写的要求？</li>
</ol>
</blockquote>
<ul>
<li>  方法名</li>
<li>  形参列表</li>
<li>  返回值类型</li>
<li>  抛出的异常列表</li>
<li>  修饰符</li>
</ul>
<blockquote>
<ol start="3">
<li> 了解《Java虚拟机规范》中关于 <code>&lt;clinit&gt;</code> 和 <code>&lt;init&gt;</code> 方法的说明、invokespecial 指令。</li>
</ol>
</blockquote>
<h1 id="2-自增变量"><a href="#2-自增变量" class="headerlink" title="2    自增变量"></a>2    自增变量</h1><blockquote>
<p>  <strong>问题：如下代码运行的结果？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + ++i * i++;</span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;j=&quot;</span> + j);</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span> + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	答案：</span></span><br><span class="line"><span class="comment"> *      i=4</span></span><br><span class="line"><span class="comment"> *      j=1</span></span><br><span class="line"><span class="comment"> *      k=11</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<p>i、j、k 都是局部变量，且均为基本类型的数据，所以都保存在栈中，随着栈帧入栈被加载，栈帧出栈被卸载</p>
<p><img src="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/%E8%87%AA%E5%A2%9E%E5%8F%98%E9%87%8F.png" alt="自增变量"></p>
<ol>
<li><code>int i = 1</code><ul>
<li>  在栈帧的局部变量表中分配一个插槽，用于保存整型变量 i 的值。</li>
<li>  先进行等号右边的计算：将常量值 1 压入操作数栈</li>
<li>  再进行等号左边的计算：将操作数栈的栈顶元素 1 赋值给局部变量表中的 i 。</li>
<li>  栈顶元素出栈。 </li>
</ul>
</li>
<li><code>i = i++</code><ul>
<li>先进行等号右边的计算。<ul>
<li>  将局部变量表中当前 i 的值 1 压入操作数栈；</li>
<li>  局部变量表中的整型变量 i 进行自增运算，从 1 变为 2；</li>
</ul>
</li>
<li>再进行等号左边的运算：<ul>
<li>  将操作数栈中栈顶元素 1 赋值给局部变量表中的 i ，此时局部变量表中的 i 再次从 2 变为 1 。</li>
</ul>
</li>
<li>  栈顶元素出栈。</li>
</ul>
</li>
<li><code>int j = i++</code><ul>
<li>  首先在局部变量中分配一块空间用于保存变量 j 的值；</li>
<li>再进行等号右边的运算。<ol>
<li> 将当前局部变量表中 i 的值 1 压入操作数栈</li>
<li> 局部变量表中的 i 进行自增运算，从 1 变为 2</li>
</ol>
</li>
<li>最后进行等号左边的运算：<ul>
<li>  将操作数栈中的栈顶元素 1 赋值给局部变量表中的 j ，此时  j = 1。</li>
</ul>
</li>
<li>  栈顶元素出栈。</li>
</ul>
</li>
<li><code>int k = i + ++i * i++</code><ul>
<li>  首先在局部变量中分配一块空间用于保存变量 k 的值；</li>
<li>再进行等号右边的运算。<ol>
<li> <code>i</code>：将局部变量表中当前 i 的值 2 压入操作数栈；</li>
<li> <code>+</code>：将 + 压入操作数栈</li>
<li> <code>++i</code>：先将局部变量表中的 i 自增变为 3 ，再压入操作数栈；</li>
<li> <code>*</code>：将 * 压入操作数栈</li>
<li> <code>i++</code>：先将局部变量表中 i 的值 3 压入操作数栈，再让 i 在局部变量表中自增变为 4； </li>
<li> 依次取出栈顶的元素（出栈）：<code>3</code>、<code>*</code>、<code>3</code> 进行乘法运算：3*3=9；</li>
<li> 将临时变量 9 再压入操作数栈；</li>
<li> 依次取出栈顶的元素：<code>9</code> 、 <code>+</code> 、<code>2</code>，进行加法运算：9+2=11</li>
<li> 将临时变量 11 再压入操作数栈中</li>
</ol>
</li>
<li>再进行等到左边的运算：<ul>
<li>  将栈顶元素的值 11 赋值给局部变量表中的 k ，得到 k=11。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>所以最终的输出结果为：<strong>i=4  j=1  k=11</strong></p>
<h2 id="2-1-小结"><a href="#2-1-小结" class="headerlink" title="2.1    小结"></a>2.1    小结</h2><ul>
<li>  赋值操作<code>=</code>，最后再计算。即先进行 <code>=</code> 右边的运算，再进行 <code>=</code> 左边的运算。</li>
<li>  <code>=</code> 右边的运算按从左到右的顺序依次压入操作数栈。</li>
<li>  实际先算哪个，是按照运算符的优先级来的。</li>
<li>  <strong>自增、自减都是直接修改局部变量表中变量的值，不经过操作数栈。</strong></li>
<li>  在进行最后的赋值操作之前，产生的临时结果也是存储在操作数栈中。</li>
<li>  <strong><code>i++</code> 就是先把 i  的值压入操作数栈，再自增；<code>++i</code> 就是先自增，再把自增后的结果压入操作数栈。</strong></li>
</ul>
<h1 id="3-方法参数传递机制"><a href="#3-方法参数传递机制" class="headerlink" title="3    方法参数传递机制"></a>3    方法参数传递机制</h1><blockquote>
<p>  <strong>问题：求下图中代码的输出结果</strong></p>
</blockquote>
<p><img src="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/image-20210702153407582.png" alt="image-20210702153407582"></p>
<blockquote>
<p>  <strong>答案：</strong></p>
</blockquote>
<p><img src="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/image-20210702153426620.png" alt="image-20210702153426620"></p>
<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">// i，局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;	<span class="comment">// str，局部变量</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">200</span>;	<span class="comment">// num，局部变量</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;	<span class="comment">// arr，局部变量</span></span><br><span class="line">        <span class="type">MyData</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();	<span class="comment">// my，局部变量</span></span><br><span class="line"></span><br><span class="line">        change(i, str, num, arr, my);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;my.a = &quot;</span> + my.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> j, String s, Integer n, <span class="type">int</span>[] a, MyData m)</span>&#123;	<span class="comment">// j, s, n, a, m 都是局部变量</span></span><br><span class="line">        j += <span class="number">1</span>;		</span><br><span class="line">        s += <span class="string">&quot; world&quot;</span>;		</span><br><span class="line">        n += <span class="number">1</span>;		</span><br><span class="line">        a[<span class="number">0</span>] += <span class="number">1</span>;		</span><br><span class="line">        m.a =+ <span class="number">1</span>;		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  栈帧中局部变量表中保存的数据分为基本类型和引用数据类型。基本类型保存的是数据值，引用类型保存的是对象的地址。</li>
<li>  在方法进行参数传递（实参 –&gt;&gt; 形参）时，是将要传递的参数从局部变量表复制一份到新方法的栈帧中的局部变量表中去。</li>
<li>  方法中的变量均为局部变量，类中方法外的变量为成员变量。局部变量的作用范围仅仅在当前方法（当前栈帧）中。</li>
</ul>
<p><img src="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6.png" alt="方法的参数传递机制"></p>
<p>程序开始执行，main() 方法首先被压入栈中，</p>
<ul>
<li>在 main() 方法中所在栈帧中，基础数据类型的变量直接保存在局部变量表中，其它类型的数据都只是把变量空间的地址值保存在变量表中。即：<ol>
<li> <strong>i</strong> 的值直接保存在局部变量表中</li>
<li> str、num 、arr、my 都是将引用保存在局部变量表中。</li>
<li> <strong>str</strong> 的真实值保存在方法区的字符串常量池中。</li>
<li> <strong>num</strong> 的真实值保存在堆中（Integer 按照普通对象来处理）</li>
<li> <strong>arr</strong> 的真实值保存在堆中；</li>
<li> <strong>my</strong> 的真实值保存在堆中。</li>
</ol>
</li>
</ul>
<p>在给 main() 方法中的局部变量表赋完值后，程序继续向下执行，change() 方法入栈，并将方法形参中的所有参数都在自己栈帧中的局部变量表中分配空间和赋值。</p>
<ul>
<li>在 change() 方法所在的栈帧中，<ol>
<li>首先形参接收实参传递过来的所有值。<ul>
<li>  j 接收到的是真实值 1；</li>
<li>  s、n、a、m 接收到的都是地址值</li>
</ul>
</li>
<li> j 执行操作，自增 1，改变当前栈帧局部变量表中的值，变为 2。</li>
<li> s 执行字符串拼接操作，由于 String 的不可变性，会在字符串常量池中新建 “world” 和 “hello wordl” 字符串，并更新前栈帧的局部变量表中 s 的引用地址。</li>
<li> 同理，包装类型数据也具有不可变性，会在堆中新分配一块内存空间保存 201，并更新局部变量表中 n  的引用地址。</li>
<li> 对于普通的引用类型变量（引用的对象不具有不可变性），根据引用地址修改堆中对象的数据。在本例中，对于 a 就是直接在其对应地址上修改对象的内容，将 <code>&#123;1,2,3,4,5&#125;</code> 改为 <code>&#123;2,2,3,4,5&#125;</code>。</li>
<li> 同理，对于 m 就是通过局部变量表中的地址找到堆空间中的对象，并修其内容。从 <code>a=10</code> 变为 <code>a=11</code></li>
</ol>
</li>
</ul>
<p>change() 方法执行结束后，对应的栈帧出栈，栈帧中保存的数据也就一并销毁。main() 方法重新成为当前方法，其栈帧内局部变量表中的数据如上图的黑色实线所示，变量对应的值分别是：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">int</span> <span class="string">i = 1;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">str = 0x1000 --&gt; &quot;hello&quot;</span></span><br><span class="line"><span class="attr">Integer</span> <span class="string">num = 0x1001 --&gt; 200;</span></span><br><span class="line"><span class="attr">int[]</span> <span class="string">arr = 0x1002 --&gt; &#123;2, 2, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="attr">MyData</span> <span class="string">my = 0x1003 --&gt; my.a=11</span></span><br></pre></td></tr></table></figure>







<h2 id="3-1-考点"><a href="#3-1-考点" class="headerlink" title="3.1    考点"></a>3.1    考点</h2><blockquote>
<p>  <strong>方法的参数传递机制</strong></p>
</blockquote>
<ol>
<li>实参是基本数据类型：<ul>
<li>  传递的是数据值</li>
</ul>
</li>
<li>实参是引用数据类型：<ul>
<li>  传递的是地址值</li>
<li>  特殊的类型：String、包装类对象的不可变性</li>
</ul>
</li>
</ol>
<ul>
<li>  String、包装类对象的不可变性</li>
</ul>
<hr>
<h1 id="4-成员变量与局部变量"><a href="#4-成员变量与局部变量" class="headerlink" title="4    成员变量与局部变量"></a>4    成员变量与局部变量</h1><blockquote>
<p>  <strong>问题：下图中代码的输出结果</strong></p>
</blockquote>
<p><img src="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/image-20210702154631649.png" alt="image-20210702154631649"></p>
<blockquote>
<p>  <strong>答案：</strong></p>
</blockquote>
<p><img src="/2021/06/28/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaSE/image-20210702154708484.png" alt="image-20210702154708484"></p>
<blockquote>
<p>  <strong>分析</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>考点</strong></p>
</blockquote>
<ul>
<li>  就近原则</li>
<li>变量的分类<ul>
<li>  成员变量：1、类变量    2、实例变量</li>
<li>  局部变量</li>
</ul>
</li>
<li>  非静态代码块的执行：每次创建实例对象都会执行</li>
<li>  方法的调用规则：每次调用都会执行</li>
</ul>
<h2 id="4-1-成员变量与局部变量的区别"><a href="#4-1-成员变量与局部变量的区别" class="headerlink" title="4.1    成员变量与局部变量的区别"></a>4.1    成员变量与局部变量的区别</h2><ol>
<li>声明的位置<ul>
<li>  局部变量：1、方法体中    2、（方法上）形参    3、非静态代码块<code>&#123;&#125;</code>中</li>
<li>成员变量：类中方法外<ul>
<li>  类变量：有 static 修饰</li>
<li>  实例变量：无 static 修饰</li>
</ul>
</li>
</ul>
</li>
<li>可使用的修饰符<ul>
<li>  局部变量：final</li>
<li>  类变量：public、protected、private、static、final、volatile、transient</li>
</ul>
</li>
<li>值存储的位置<ul>
<li>  局部变量：栈中的局部变量表中</li>
<li>  类变量：方法区中</li>
<li>  实例变量：堆中</li>
</ul>
</li>
<li>作用域：<ul>
<li>  局部变量：从声明处开始，到所属的 <code>&#125;</code> 处结束</li>
<li>  实例变量：无作用域，在当前类中通过 <code>this.</code>（有时<code>this.</code>可以省略）访问，在其它类中通过 <code>对象名.</code> 访问。</li>
<li>  类变量：无作用域，在当前类中通过 <code>类名.</code>（有时<code>类名.</code>可以省略）访问，在其它类中通过 <code>类名.</code> 或 <code>对象名.</code> 访问。</li>
</ul>
</li>
<li>生命周期：<ul>
<li>  局部变量：<strong>每一次调用执行的都是新的生命周期</strong>。</li>
<li>  实例变量：随着对象的创建而初始化，随着对象被回收而消亡，每一个对象的实例变量是独立的，</li>
<li>  类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的。</li>
</ul>
</li>
</ol>
<h2 id="4-2-当局部变量与类变量-实例变量重名时，如何区分？"><a href="#4-2-当局部变量与类变量-实例变量重名时，如何区分？" class="headerlink" title="4.2    当局部变量与类变量/实例变量重名时，如何区分？"></a>4.2    当局部变量与类变量/实例变量重名时，如何区分？</h2><ol>
<li>局部变量与实例变量重名：<ul>
<li>  在实例变量前加 “this.”</li>
</ul>
</li>
<li>局部变量与类变量重名：<ul>
<li>  在类变量前面加 “类名.”</li>
</ul>
</li>
</ol>
<h2 id="4-3-就近原则"><a href="#4-3-就近原则" class="headerlink" title="4.3    就近原则"></a>4.3    就近原则</h2><p>在作用域范围内，如果存在多个同名的变量，某个变量 A 在引用  这多个同名变量的时候真正引用的是离 A ，之间的引用距离越近的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式——单例模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-28 13:01:17 / Modified: 22:47:57" itemprop="dateCreated datePublished" datetime="2021-06-28T13:01:17+08:00">2021-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-什么是单例模式？"><a href="#1-什么是单例模式？" class="headerlink" title="1    什么是单例模式？"></a>1    什么是单例模式？</h1><blockquote>
<p>  单例模式；Singleton</p>
</blockquote>
<ul>
<li>Singleton：在 Java 中即指单例设计模式，它是软件开发中最常用的设计模式之一。<ul>
<li>  单：唯一</li>
<li>  例：实例</li>
</ul>
</li>
<li>  单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用。</li>
<li>例如：代表JVM运行环境的Runtime类</li>
</ul>
<h1 id="2-要点"><a href="#2-要点" class="headerlink" title="2    要点"></a>2    要点</h1><blockquote>
<ol>
<li> <strong>怎样保证某个类只能有一个实例？</strong></li>
</ol>
</blockquote>
<ol>
<li> 将构造方法私有化。</li>
<li> 将实例对象的创建提前到类加载阶段。</li>
</ol>
<p>分析：</p>
<ul>
<li>  将构造方法私有化，即不对外提供创建该类的实例对象的入口。那么创建实例对象的时机只能提前到类加载阶段。</li>
<li>  一个类只能被加载一次，每个类 <code>&lt;clinit&gt;()</code> 方法只会被执行一次，只要在 <code>&lt;clinit&gt;()</code> 方法中执行创建对象的行为，该对象就一定会被创建出来一个，且我们已经关闭了外部创建该对象的入口，那么该对象就有且仅有一个了。</li>
<li>  <code>&lt;clinit&gt;()</code> 方法只会执行类中的静态变量赋值和静态代码块，所以要创建的对象必须通过一个静态变量来保存。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>该类必须向整个系统提供这个实例。</strong></li>
</ol>
</blockquote>
<ol>
<li> 直接对外暴露该对象在内存中的地址。</li>
<li> 通过一个静态的 get() 方法获取该对象实例。</li>
</ol>
<hr>
<h1 id="3-几种单例模式的常见形式"><a href="#3-几种单例模式的常见形式" class="headerlink" title="3    几种单例模式的常见形式"></a>3    几种单例模式的常见形式</h1><p><strong>饿汉式</strong></p>
<ul>
<li>  介绍：不管该单例对象在程序运行中是否会被使用，都会创建该对象。</li>
<li>  优点：不存在线程问题。因为创建对象是在类加载阶段进行的，这个阶段不会存在线程安全问题。</li>
<li>几种实现方式：<ol>
<li> 直接实例化饿汉式（简单直观）</li>
<li> 枚举式（最简单）</li>
<li> 静态代码块饿汉式（适合较为复杂实例化场景）</li>
</ol>
</li>
</ul>
<p><strong>懒汉式</strong></p>
<ul>
<li>  介绍：程序运行时不会立即创建对象，知道该单例对象要被使用时才创建对象</li>
<li>几种实现方式：<ol>
<li> 线程不安全（适用于单线程）</li>
<li> 线程安全（适用于多线程）</li>
<li> 静态内部类形式（适用于多线程）</li>
</ol>
</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li>  如果是饿汉式，枚举形式最简单</li>
<li>  如果是懒汉式，静态内部类形式最简单</li>
</ul>
<hr>
<h1 id="4-代码"><a href="#4-代码" class="headerlink" title="4    代码"></a>4    代码</h1><h2 id="4-1-饿汉式"><a href="#4-1-饿汉式" class="headerlink" title="4.1    饿汉式"></a>4.1    饿汉式</h2><h3 id="4-1-1-基础款"><a href="#4-1-1-基础款" class="headerlink" title="4.1.1    基础款"></a>4.1.1    基础款</h3><ul>
<li>  单例类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式：</span></span><br><span class="line"><span class="comment"> *  在类初始化时直接创建实例对象，不管程序运行中是否会用到这个对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1、将构造方法私有化</span></span><br><span class="line"><span class="comment"> *  2、将创建对象的动作提前到类加载阶段</span></span><br><span class="line"><span class="comment"> *  3、提供外部访问该单例对象的入口</span></span><br><span class="line"><span class="comment"> *      3.1 可以直接对外暴露类变量</span></span><br><span class="line"><span class="comment"> *      3.2 也可以选择对外暴露一个 get() 方法。</span></span><br><span class="line"><span class="comment"> *      3.3 这里我把这两个入口都暴露了。</span></span><br><span class="line"><span class="comment"> *  4、强调这是一个单例对象，我们可以用 final 修饰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将创建对象的动作提前到类加载阶段（使用 final 修饰符用于声明该类是一个单例对象，不能被修改）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton01</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  将构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton01</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供外部访问单例对象的入口</span></span><br><span class="line">    <span class="keyword">public</span> Singleton01 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：分别获取两个单例对象，查看这两个对象是否相同，如果相同则证明获取的同一个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton01</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton01.INSTANCE;</span><br><span class="line">        <span class="type">Singleton01</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton01.INSTANCE.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1 == instance2);     <span class="comment">// 运行结果为：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="4-1-2-枚举式"><a href="#4-1-2-枚举式" class="headerlink" title="4.1.2    枚举式"></a>4.1.2    枚举式</h3><ul>
<li>  单例类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  1、枚举类型，表示该类对应的实例对象是有限的几个。</span></span><br><span class="line"><span class="comment"> *  2、我们可以限定为一个，就成了单例</span></span><br><span class="line"><span class="comment"> *  3、枚举重写了类的 toString() 方法，使用 PrintStream#print() 方法打印出来的字符串就是举对象的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton02</span> &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：分别获取两个单例对象，查看这两个对象是否相同，如果相同则证明获取的同一个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton02</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton02.INSTANCE;</span><br><span class="line">        <span class="type">Singleton02</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton02.INSTANCE;</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1);  <span class="comment">// 运行结果为：INSTANCE</span></span><br><span class="line">        System.out.println(instance1 == instance2);     <span class="comment">// 运行结果为：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="4-1-3-静态代码块式（复杂场景使用）"><a href="#4-1-3-静态代码块式（复杂场景使用）" class="headerlink" title="4.1.3    静态代码块式（复杂场景使用）"></a>4.1.3    静态代码块式（复杂场景使用）</h3><ul>
<li><p>  使用静态代码块创建单例对象与直接使用静态变量保存单例对象无本质上的区别，只不过如果某个单例对象的构造方法足够复杂的话，将全部的代码直接写在构造函数中可读性较差，可以借助静态代码块提高程序的可读性。</p>
</li>
<li><p><strong>设定一个复杂的场景</strong>：</p>
<ol>
<li> 某个单例的构造函数是有参的。</li>
<li> 并且这个参数是一个变量，该变量的具体值要从配置文件中读取。</li>
<li> 那么显然，我们的构造函数比较复杂，我们就可以将获取构造器需要的参数这一步骤放在静态代码块中执行。</li>
</ol>
</li>
</ul>
<ul>
<li>  单例类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton03</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton03 INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，只会在类加载的时候执行一次。将创建单例对象的动作放到静态代码块中（即将创建单例对象的动作提前到类加载阶段）</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*  指定从当前类的根目录下读取 single.properties 配置文件，并且规定该配置文件中应该存在 key 为 name 的值   */</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(Singleton03.class.getClassLoader().getResourceAsStream(<span class="string">&quot;single.properties&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">            <span class="comment">/*  获取到配置文件中指定 key 对应的 value，并作为当前类单例对象的构造方法的参数创建该单例对象  */</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton03</span>(info);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  将构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton03</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供外部访问单例对象的入口</span></span><br><span class="line">    <span class="keyword">public</span> Singleton03 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Singleton03&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;info=&#x27;&quot;</span> + info + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  配置文件：<code>src/single.properties</code></li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key=value</span></span><br><span class="line"><span class="attr">info</span>=<span class="string">Singleton</span></span><br></pre></td></tr></table></figure>



<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：分别获取两个单例对象，查看这两个对象是否相同，如果相同则证明获取的同一个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton03</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton03.INSTANCE;</span><br><span class="line">        <span class="type">Singleton03</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton03.INSTANCE.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1);  <span class="comment">// 输出结果：Singleton03&#123;info=&#x27;Singleton&#x27;&#125;</span></span><br><span class="line">        System.out.println(instance1 == instance2);     <span class="comment">// 运行结果为：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-2-懒汉式"><a href="#4-2-懒汉式" class="headerlink" title="4.2    懒汉式"></a>4.2    懒汉式</h2><p><strong>注意事项：</strong></p>
<ul>
<li>  <strong>在使用懒汉式的设计模式创建单例对象时，引用单例对象的静态变量就不合适公有化了。</strong>因为在懒汉式单例设计模式中，该对象只有在调用静态方法 <code>getInstance()</code> 方法时才会被创建，如果在没有创建对象之前就直接调用该属性则结果一定为空，这是不合适的。</li>
</ul>
<h3 id="4-2-1-单线程款"><a href="#4-2-1-单线程款" class="headerlink" title="4.2.1    单线程款"></a>4.2.1    单线程款</h3><ul>
<li>  单例类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式：</span></span><br><span class="line"><span class="comment"> *  延迟创建这个实例对象的时间，在需要使用时再创建。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1、将构造方法私有化</span></span><br><span class="line"><span class="comment"> *  2、用一个静态变量保存这个唯一的单例对象</span></span><br><span class="line"><span class="comment"> *  3、提供外部访问该单例对象的入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton04</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton04</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个方法，当该方法被调用时才会创建单例对象（懒汉式）</span></span><br><span class="line"><span class="comment">     *  当某个线程调用了 Singleton04.getInstance() 方法时，</span></span><br><span class="line"><span class="comment">     *      * 若该单例对象不存在，则创建</span></span><br><span class="line"><span class="comment">     *      * 若该单例对象存在，则返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton04 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == INSTANCE)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton04</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：分别获取两个单例对象，查看这两个对象是否相同，如果相同则证明获取的同一个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton04</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton04.getInstance();</span><br><span class="line">        <span class="type">Singleton04</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton04.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1 == instance2);     <span class="comment">// 运行结果为：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>  缺点：上述代码，在单线程下测试是完全正确的，但是在多线程下是线程不安全的，无法保证只会创建出来一个对象。</li>
</ul>
<h4 id="线程不安全测试："><a href="#线程不安全测试：" class="headerlink" title="线程不安全测试："></a>线程不安全测试：</h4><ol>
<li> 修改单例类的代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton04</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton04</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton04 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == INSTANCE)&#123;</span><br><span class="line">            <span class="comment">// 此处是线程不安全的，如果有多个线程同时进入，则会创建多个 INSTANCE 对象，就不能保证单例对象的唯一性了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">/* 让每个线程进入的线程都先都睡眠 1000ms*/</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton04</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 修改测试类代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：分别获取两个单例对象，查看这两个对象是否相同，如果相同则证明获取的同一个对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      该单例对象在单线程环境下不会有任何问题，但是在多线程环境下运行，则是线程不安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest04_02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  创建线程的任务执行体  */</span></span><br><span class="line">        Callable&lt;Singleton04&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Singleton04&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Singleton04 <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> Singleton04.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  使用线程池创建 2 个子线程，并启动子线程执行指定的任务，得到任务的返回结果 */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Future&lt;Singleton04&gt; future1 = es.submit(callable);</span><br><span class="line">        Future&lt;Singleton04&gt; future2 = es.submit(callable);</span><br><span class="line"></span><br><span class="line">        <span class="type">Singleton04</span> <span class="variable">instance1</span> <span class="operator">=</span> future1.get();</span><br><span class="line">        <span class="type">Singleton04</span> <span class="variable">instance2</span> <span class="operator">=</span> future2.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(instance1 == instance2);     <span class="comment">// 运行结果为：false</span></span><br><span class="line"></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="4-2-1-多线程款"><a href="#4-2-1-多线程款" class="headerlink" title="4.2.1    多线程款"></a>4.2.1    多线程款</h3><ul>
<li>  单例类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  DCL单例（Double Checked Lock Singleton）——双重校验锁单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton05</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton05</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton05</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton05 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == INSTANCE)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">/* 让每个线程进入的线程都先都睡眠 1000ms，用于模拟多线程同时进入*/</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 允许多个线程进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton05.class)&#123;</span><br><span class="line">                <span class="comment">// 双重校验——DCL单例（Double Checked Lock Singleton）</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == INSTANCE)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton05</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：分别获取两个单例对象，查看这两个对象是否相同，如果相同则证明获取的同一个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  创建线程的任务执行体  */</span></span><br><span class="line">        Callable&lt;Singleton05&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Singleton05&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Singleton05 <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> Singleton05.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  使用线程池创建 2 个子线程，并启动子线程执行指定的任务，得到任务的返回结果 */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Future&lt;Singleton05&gt; future1 = es.submit(callable);</span><br><span class="line">        Future&lt;Singleton05&gt; future2 = es.submit(callable);</span><br><span class="line"></span><br><span class="line">        <span class="type">Singleton05</span> <span class="variable">instance1</span> <span class="operator">=</span> future1.get();</span><br><span class="line">        <span class="type">Singleton05</span> <span class="variable">instance2</span> <span class="operator">=</span> future2.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(instance1 == instance2);     <span class="comment">// 运行结果为：true</span></span><br><span class="line"></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-1-多线程款简化版：静态内部类形式"><a href="#4-2-1-多线程款简化版：静态内部类形式" class="headerlink" title="4.2.1    多线程款简化版：静态内部类形式"></a>4.2.1    多线程款简化版：静态内部类形式</h3><ul>
<li>  单例类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1、静态内部类不会自动随着外部类的加载和初始化而初始化，它是需要单独去加载和初始化的。</span></span><br><span class="line"><span class="comment"> *  2、因为单例对象是在内部类加载和初始化时创建的，因此线程是安全的。</span></span><br><span class="line"><span class="comment"> *  3、内部类只有在被使用时，才会被加载，这时候才会创建 INSTANCE 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton06</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton06</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Singleton06</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton06</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton06 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>  测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javase.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/28 20:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 测试：分别获取两个单例对象，查看这两个对象是否相同，如果相同则证明获取的同一个对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1、Singleton06.getInstance() 方法被调用时，才会去加载内部类；</span></span><br><span class="line"><span class="comment">        * 2、内部类加载的时候，才会去创建 INSTANCE 这个单例对象</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">Singleton06</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton06.getInstance();</span><br><span class="line">        <span class="type">Singleton06</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton06.getInstance();</span><br><span class="line">        System.out.println(instance1 == instance2);     <span class="comment">// 运行结果为：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">设计模式——概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-27 22:14:47 / Modified: 22:34:15" itemprop="dateCreated datePublished" datetime="2021-06-27T22:14:47+08:00">2021-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1    概述"></a>1    概述</h1><h2 id="1-1-什么是设计模式"><a href="#1-1-什么是设计模式" class="headerlink" title="1.1    什么是设计模式"></a>1.1    什么是设计模式</h2><blockquote>
<p>  设计模式；Design_Pattern</p>
</blockquote>
<p>​        在软件工程中，<strong>设计模式</strong>是对<strong>软件设计中普遍存在（反复出现）</strong>的各种问题，提出的<strong>解决方案</strong>。</p>
<p>​        <strong>设计模式</strong>是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p>
<p>​        1995年，<strong>GoF</strong>（Gang of Four）合作出版了《设计模式：可复用面向对象软件基础》一书，共收录了23种设计模式，从此树立了软件设计模式领域的里程碑，被称为<strong>GoF设计模式</strong></p>
<hr>
<h2 id="1-2-为什么要学习设计模式"><a href="#1-2-为什么要学习设计模式" class="headerlink" title="1.2    为什么要学习设计模式"></a>1.2    为什么要学习设计模式</h2><ul>
<li>设计模式的本质是<strong>面向对象设计原则的实际应用</strong>，是对类的封装、继承和多态以及关联关系和组合关系的充分理解。</li>
<li>正确使用设计模式具有以下优点：<ol>
<li>可以提高程序员的思维能力，编程能力和设计能力。</li>
<li>使程序更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="1-3-设计模式的基本要素"><a href="#1-3-设计模式的基本要素" class="headerlink" title="1.3    设计模式的基本要素"></a>1.3    设计模式的基本要素</h2><ol>
<li>模式名称</li>
<li>问题</li>
<li>解决方案</li>
<li>效果</li>
</ol>
<hr>
<h2 id="1-4-GoF23"><a href="#1-4-GoF23" class="headerlink" title="1.4    GoF23"></a>1.4    GoF23</h2><blockquote>
<ul>
<li>创建型模式<ol>
<li>单例模式</li>
<li>工厂模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ol>
</li>
<li>结构型模式<ol start="6">
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ol>
</li>
<li>行为型模式<ol start="13">
<li>模板方法模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>职责链模式</li>
<li>访问者模式</li>
</ol>
</li>
</ul>
</blockquote>
<hr>
<h1 id="2-设计模式七大原则"><a href="#2-设计模式七大原则" class="headerlink" title="2    设计模式七大原则"></a>2    设计模式七大原则</h1><p>设计模式原则，就是 23 种设计模式为什么这样设计的依据，是设计模式的基础。也是程序员在编程时应该遵守的原则，</p>
<blockquote>
<p>  设计模式常用的<strong>七大原则</strong>有：</p>
</blockquote>
<ol>
<li><strong>单一职责原则</strong><ul>
<li>控制类的粒度大小，将对象解耦、提高其内聚性</li>
</ul>
</li>
<li><strong>接口隔离原则</strong><ul>
<li>要为各个类建立它们专用的接口。</li>
</ul>
</li>
<li><strong>依赖倒置原则</strong><ul>
<li>要面向接口编程，不要面向实现编程</li>
</ul>
</li>
<li><strong>里氏替换原则</strong><ul>
<li>继承必须确保超类所拥有的性质在子类中仍然成立</li>
</ul>
</li>
<li><strong>开闭原则</strong><ul>
<li>  对扩展开放，对修改关闭</li>
</ul>
</li>
<li><strong>迪米特法则</strong><ul>
<li>只与你的直接朋友交谈，不跟“陌生人”说话</li>
</ul>
</li>
<li><strong>合成复用原则</strong><ul>
<li>尽量先使用组合或聚合等关联关系来实现，其次再考虑使用继承关系来实现。</li>
</ul>
</li>
</ol>
<h2 id="2-1-单一职责原则"><a href="#2-1-单一职责原则" class="headerlink" title="2.1    单一职责原则"></a>2.1    单一职责原则</h2><h3 id="2-1-1-基本介绍"><a href="#2-1-1-基本介绍" class="headerlink" title="2.1.1    基本介绍"></a>2.1.1    基本介绍</h3><p>​        对类来说的，<strong>一个类应该只负责一项职责</strong>。</p>
<p>​        如果类 A 负责两个不同职责：职责1，职责2。那么就有可能出现这样一种情况：因职责 1 的需求变更而需要修改类 A 时，就可能导致修改后的类 A 再执行职责 2 时发生错误。所以需要将类 A 的粒度分解为 A1 和 A2，类 A1 负责职责 1，类 A2 负责职责 2，无论修改 A1 或 A2 都不会影响到另外一个类。</p>
<h3 id="2-1-2-应用实例"><a href="#2-1-2-应用实例" class="headerlink" title="2.1.2    应用实例"></a>2.1.2    应用实例</h3><ol>
<li> 以交通工具案例讲解</li>
<li> 代码演示</li>
<li> 方 案 1 [ 分析说明</li>
<li> 方 案 2 [ 分析说明</li>
<li> 方 案 3 [ 分析说明</li>
</ol>
<h3 id="单一职责原则注意事项和细节"><a href="#单一职责原则注意事项和细节" class="headerlink" title="单一职责原则注意事项和细节"></a>单一职责原则注意事项和细节</h3><ol>
<li> 降低类的复杂度，一个类只负责一项职责。</li>
<li> 提高类的可读性，可维护性</li>
<li> 降低变更引起的风险</li>
<li> 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。</li>
</ol>
<p>​        <em>类级别的单一职责原则是比方法级别的单一职责原则更细的粒度。方法级别的单一职责只要每个方法只负责一个职责，即一个类还有可能负责多想职责（只有类中方法足够少时才建议使用），而在类级别的单一职责则要求每个类只能负责一项职责。</em></p>
<p>​        <em>慎用 <code>if...else if ...else</code> 这种代码，因为其耦合度很高，新的修改可能会导致原先的代码逻辑被破话，最好的办法就是拆分成多个方法或直接拆分到多个类中</em>。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li> 客户端不应该依赖它不需要的接口，即如果一个类通过接口依赖（使用）另一个类，那么一个类对另一个类的依赖应该建立在最小的接口上。</li>
<li> 先看一张图</li>
<li> 类 A 通过接口 Interface1 依赖类 B ，类 C 通过接口 Interface1 依赖类 D ，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</li>
<li>按隔离原则应当这样处理：<br> 将接口 Interface1 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</li>
</ol>
<p><img src="/2021/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/image-20210626165355427.png" alt="image-20210626165355427"></p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><ol>
<li> 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D。请编写代码完成此应用实例。</li>
<li> 看老师代码</li>
</ol>
<h3 id="用传统方法的问题和使用接口隔离原则改进"><a href="#用传统方法的问题和使用接口隔离原则改进" class="headerlink" title="用传统方法的问题和使用接口隔离原则改进"></a>用传统方法的问题和使用接口隔离原则改进</h3><ol>
<li> 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</li>
<li> 将接口 Interface1 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</li>
<li> 接口 Interface1 中出现的方法，根据实际情况拆分为三个接口</li>
<li> 代码实现</li>
</ol>
<p>图片</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>依赖倒转原则（Dependence Inversion Principle）是指：</p>
<ol>
<li> 高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li> 抽象不应该依赖细节，细节应该依赖抽象</li>
<li> 依赖倒置的中心思想是面向接口编程</li>
<li> 依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定得多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类。</li>
<li> 使用接口或抽象类的目的是<strong>制定好规范</strong>，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li>
</ol>
<h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><ol>
<li> 请编程完成 Person 接收消息的功能。</li>
<li> 实现方案 1 + 分析说明</li>
<li> 实现方案 2 + 分析说明</li>
</ol>
<h3 id="依赖关系传递的三种方式和应用案例"><a href="#依赖关系传递的三种方式和应用案例" class="headerlink" title="依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h3><ol>
<li>接口传递<br> 应用案例代码</li>
<li>构造方法传递<br> 应用案例代码</li>
<li>setter 方式传递<br> 应用案例代码</li>
</ol>
<h3 id="依赖倒转原则的注意事项和细节"><a href="#依赖倒转原则的注意事项和细节" class="headerlink" title="依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h3><ol>
<li> 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。（底层模块——子类）</li>
<li> 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。（变量——方法中的形参；类中的变量；接口中的变量等等）</li>
<li> 继承时遵循里氏替换原则</li>
</ol>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h3 id="面向对象中的继承性的思考和说明"><a href="#面向对象中的继承性的思考和说明" class="headerlink" title="面向对象中的继承性的思考和说明"></a>面向对象中的继承性的思考和说明</h3><ol>
<li> 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些 已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li> 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性。如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。</li>
<li> 问题提出：在编程中，如何正确的使用继承? =&gt; *<em>里氏替换原则</em></li>
</ol>
<h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li> 里氏替换原则（Liskov Substitution Principle）</li>
<li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象 。<ul>
<li>  所有引用基类的地方必须能透明地使用其子类的对象：基类就是父类，这句话的意思就是说：在所有使用父类的地方，如果用其子类代替的话不会产生歧义。</li>
</ul>
</li>
<li> 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</li>
<li> 里氏替换原则告诉我们，<strong>继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题</strong>。</li>
</ol>
<h3 id="一个程序引出的问题和思考"><a href="#一个程序引出的问题和思考" class="headerlink" title="一个程序引出的问题和思考"></a>一个程序引出的问题和思考</h3><p>看个程序，思考下问题和解决思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;1-8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li> 我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。</li>
<li>通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。</li>
</ol>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li> 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则。</li>
<li> 一个软件实体如类、模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节。</li>
<li> 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化 。</li>
<li> 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li>
</ol>
<h1 id="几个经典的面试题"><a href="#几个经典的面试题" class="headerlink" title="几个经典的面试题"></a>几个经典的面试题</h1><h2 id="原型设计模式问题"><a href="#原型设计模式问题" class="headerlink" title="原型设计模式问题"></a>原型设计模式问题</h2><ol>
<li><p> 请使用 UML 类图画出原型模式核心角色</p>
</li>
<li><p> 原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种实现方式的源码[1、重写<code>clone()</code>方法实现深拷贝  2、使用序列化来实现深拷贝]</p>
</li>
<li><p>在 Spring 框架中哪里使用到原型模式，并对源码进行分析：</p>
<p> <code>beans.xml</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;id01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.spring.bean.Monster&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p> Spring 中原 型 bean 的创建，就是原型模式的应用。代码分析 +Debug 源码</p>
</li>
</ol>
<h2 id="设计模式7大设计原则"><a href="#设计模式7大设计原则" class="headerlink" title="设计模式7大设计原则"></a>设计模式7大设计原则</h2><ol>
<li> 七大设计原则核心思想</li>
<li> 能够以类图的形式说明设计原则</li>
<li> 在项目实际开发中，你在哪里使用到了 ocp 原则</li>
</ol>
<h2 id="实际应用题"><a href="#实际应用题" class="headerlink" title="实际应用题"></a>实际应用题</h2><p>​        <strong>金融借贷平台项目</strong>：借贷平台的订单，有 审核-发布-抢单 等等步骤，随着操作的不同，会改变订单的状态 , 项目中的这个模块的实现就会使用到状态模式，请你使用状态模式进行设计，并完成实际代码。</p>
<p>​        <strong>问题分析</strong>：这类代码难以应对变化，在添加一种状态时，我们需要手动添加 if/else ，在添加一种功能时要对所有的状态进行判断。因此代码会变得越来越臃肿，并且一旦没有处理某个状态，便会发生极其严重的 BUG ，难以维护。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">Java面经——计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-27 21:46:04" itemprop="dateCreated datePublished" datetime="2021-06-27T21:46:04+08:00">2021-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-24 20:02:30" itemprop="dateModified" datetime="2022-06-24T20:02:30+08:00">2022-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">Java面经</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-什么是通信协议？"><a href="#1-什么是通信协议？" class="headerlink" title="1    什么是通信协议？"></a>1    什么是通信协议？</h1><p>通信协议就是通信的双方共同规定的都要实现的标准。</p>
<h1 id="2-TCP-和-UDP-有什么区别-？TCP-为什么是三次握手，而不是两次？"><a href="#2-TCP-和-UDP-有什么区别-？TCP-为什么是三次握手，而不是两次？" class="headerlink" title="2    TCP 和 UDP 有什么区别 ？TCP 为什么是三次握手，而不是两次？"></a>2    TCP 和 UDP 有什么区别 ？TCP 为什么是三次握手，而不是两次？</h1><h2 id="2-1-TCP-和-UDP-的区别："><a href="#2-1-TCP-和-UDP-的区别：" class="headerlink" title="2.1    TCP 和 UDP 的区别："></a>2.1    TCP 和 UDP 的区别：</h2><ul>
<li>TCP（Transfer Control Protocol）是一种 <strong>面向连接的、可靠的</strong> 传输层通信协议。<ul>
<li>  类似于 打电话，点对点的通信，高可靠的，效率比较低，占用的系统资源比较多</li>
</ul>
</li>
<li>UDP（User Datagram Protocol）是一种 <strong>无连接的、不可靠的</strong> 传输层通信协议<ul>
<li>  类似于 广播，不需要建立连接，发送方不管接收方有没有准备好，直接发送消息；可以进行广播发送。传输不可靠，有可能丢失消息。效率比较高；协议比较简单，占用的系统资源比较少。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-2-TCP-为什么是三次握手，而不是两次"><a href="#2-2-TCP-为什么是三次握手，而不是两次" class="headerlink" title="2.2    TCP 为什么是三次握手，而不是两次"></a>2.2    TCP 为什么是三次握手，而不是两次</h2><p>答：如果是两次握手，可能会造成连接资源浪费的情况。</p>
<p><img src="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="TCP两次握手存在的问题"></p>
<p>网络是一种非常不稳定的资源，TCP 建立连接三次握手，断开连接四次挥手。</p>
<p>假设只有两次握手，</p>
<ul>
<li>第一次握手：客户端向服务器端发送消息，请求建立连接；</li>
<li>第二次握手：服务端同意/拒绝建立连接，并将同意/拒绝消息发送给客户端；</li>
</ul>
<p>​        此时若服务器同意与客户端建立连接，就会将“同意建立连接”的消息发送给客户端并建立服务器与客户端之间的网络通道。由于网络是一种非常不稳定的资源，假设这个在过程中由于网络波动服务器发出的“同意建立连接”消息丢失了，客户端就无法收到服务器“同意建立连接”的消息，也就不会知道其实它与服务器间通信的信道已经建立好了。客户端在这次请求超时后，会做出两种选择：</p>
<ol>
<li> 重新发送请求与服务器建立连接；</li>
<li> 不再发送请求放弃与服务器建立连接。</li>
</ol>
<p>​        假设请求超时后客户端放弃与服务器建立连接：我们可以看到，此时服务器与客户端之间的网络通道其实是存在的，只不过客户端没并不知道这个网络通道的存在，就不会去用这个通道与服务器交互。在无其它操作的情况下，这个网络通道就会一直存在并浪费客户端和服务器的资源。</p>
<hr>
<h1 id="3-Java-有哪几种-IO-模型-？有什么区别？"><a href="#3-Java-有哪几种-IO-模型-？有什么区别？" class="headerlink" title="3    Java 有哪几种 IO 模型 ？有什么区别？"></a>3    Java 有哪几种 IO 模型 ？有什么区别？</h1><h2 id="3-1-什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"><a href="#3-1-什么是同步？什么是异步？什么是阻塞？什么是非阻塞？" class="headerlink" title="3.1    什么是同步？什么是异步？什么是阻塞？什么是非阻塞？"></a>3.1    什么是同步？什么是异步？什么是阻塞？什么是非阻塞？</h2><blockquote>
<p>  <strong>同步</strong></p>
</blockquote>
<ul>
<li>指的是用户进程触发 IO 操作后可以去干别的事情，但是要时不时的回来轮询的去查看 IO 操作是否就绪。</li>
</ul>
<blockquote>
<p>  <strong>异步</strong></p>
</blockquote>
<ul>
<li>异步指的是用户进程触发IO操作后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知）。类似于 Ajax 请求。</li>
</ul>
<blockquote>
<p>  <strong>阻塞</strong></p>
</blockquote>
<ul>
<li>阻塞是指：当试图对文件进行读写时，首先会在线程的内存空间进行读写数据，首先要交给内核处理，在内核处理的过程中，进程就进入阻塞状态, 直到有东西可读或者可写为止。</li>
</ul>
<blockquote>
<p>  <strong>非阻塞</strong></p>
</blockquote>
<ul>
<li>非阻塞状态下，如果没有东西可读，或者不可写，读写函数马上返回，而不会等待。</li>
</ul>
<blockquote>
<p>同步 和 异步 最大的区别是是否有 <strong>通知</strong> 。</p>
<p>而 阻塞 和 非阻塞 最大的区别就是是否 <strong>等待</strong> 。</p>
</blockquote>
<p>同步 &amp; 异步：针对请求</p>
<p>阻塞 &amp; 非阻塞：针对客户端</p>
<p>在一个网络请求中，客户端会发送一个请求到服务端：</p>
<ol>
<li>客户端发送请求后，就一直等待服务端的响应。<ul>
<li>  客户端：阻塞！  请求：同步</li>
</ul>
</li>
<li>客户端在发送请求后，就去干别的事情了。但是还需要时不时的过来检查服务器端是否给出了响应。<ul>
<li>  客户端：非阻塞！  请求：同步</li>
</ul>
</li>
<li>客户端在发送请求后，就歇下了，也不会去干别的事，但是也不会一直监听服务器的响应。服务器在处理完数据后，会发送给客户端一个通知，告诉客户端该接收响应了。<ul>
<li>  客户端：阻塞    请求：异步</li>
</ul>
</li>
</ol>
<ol>
<li>同步阻塞IO（BIO）<ul>
<li>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>
</ul>
</li>
<li>同步非阻塞IO（NIO）<ul>
<li>同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。</li>
</ul>
</li>
<li>异步阻塞IO（NIO）<ul>
<li>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！</li>
</ul>
</li>
<li>异步非阻塞IO（AIO）<ul>
<li>在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。</li>
</ul>
</li>
</ol>
<blockquote>
<p>  BIO    同步阻塞IO</p>
</blockquote>
<p><img src="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BIO.png"></p>
<ol>
<li><p>当有一个客户端向服务器发起请求时，服务器就调用一个线程去处理这个请求。</p>
</li>
<li><p>存在的问题：</p>
<p> 当有多个客户端同时访问服务器时，每个客户端请求都会占用一个进程，服务器就需要启动多个线程处理这些请求。当一次进入服务器的请求非常多时，对服务器的压力就会非常大。</p>
</li>
</ol>
<blockquote>
<p>缺点：</p>
<ol>
<li>可靠性差，当线程丢失时，请求就会丢失。</li>
<li>吞吐量低。线程不能建立太多，线程太多服务器容易崩溃。</li>
<li>适用于连接比较少的场景。</li>
<li>在 JDK 1.4 之前，BIO 是唯一的IO模型。</li>
</ol>
</blockquote>
<blockquote>
<p>  NIO    同步非阻塞IO</p>
</blockquote>
<p><img src="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NIO.png"></p>
<p>为了解决服务器一次开启多个线程压力过大的问题。JDK 1.4 中新增了 <strong>Selector</strong>，用于接收多个请求，并决定处理这些请求的优先级。这样就可以实现服务端线程与客户端请求的一对多关系，在一定程度上解决了BIO模式下服务器压力过大的问题。</p>
<blockquote>
<p>可靠性比较好</p>
<p>吞吐量比较高</p>
<p>适用于连接比较多并且连接比较短的场景（轻操作）</p>
</blockquote>
<blockquote>
<p>  <strong>AIO    异步非阻塞IO</strong></p>
</blockquote>
<p><img src="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/AIO.png"></p>
<p>AIO 又解决了 NIO 模型服务端需要一直守着线程的这个问题。可靠性最好，吞吐量也是非常高的，适用于连接比较多，并且连接比较长的场景（重操作）。例如：相册服务器。从JDK 7版本开始支持。</p>
<p>客户端在发送完请求后，可以执行任何操作，不需要一直等待或每隔一段时间来询问服务器请求是否处理完毕。相应的服务器在处理完请求后，会将处理结果保存到一个队列中，并逐一发送通知给请求的客户端，客户端在接收到通知后获取返回消息即可。</p>
<blockquote>
<p>可靠性是最好的</p>
<p>吞吐量也非常高</p>
<p>适用于连接比较多，并且连接比较长的的操作（重操作）</p>
</blockquote>
<h1 id="3、Java-NIO-的几个核心组件是什么？分别有什么作用-？"><a href="#3、Java-NIO-的几个核心组件是什么？分别有什么作用-？" class="headerlink" title="3、Java NIO 的几个核心组件是什么？分别有什么作用 ？"></a>3、Java NIO 的几个核心组件是什么？分别有什么作用 ？</h1><p>Channel</p>
<p>Buffer</p>
<p>Selector</p>
<h1 id="4、select，poll-和-epoll-有什么区别-？"><a href="#4、select，poll-和-epoll-有什么区别-？" class="headerlink" title="4、select，poll 和 epoll 有什么区别 ？"></a>4、select，poll 和 epoll 有什么区别 ？</h1><blockquote>
<p>waiting…</p>
</blockquote>
<h1 id="5、描述-HTTP-和-HTTPS-的区别"><a href="#5、描述-HTTP-和-HTTPS-的区别" class="headerlink" title="5、描述 HTTP 和 HTTPS 的区别"></a>5、描述 HTTP 和 HTTPS 的区别</h1><p>HTTP：是互联网上应用最为广泛的一种网络通信协议，基于 TCP，可以使浏览器工作更为高效，减少网络传输。</p>
<p>HTTPS：是 HTTP 的加强版，可以认为是 HTTP + SSL（Secure Socket Layer）。在 HTTP 的基础上增加了一系列的安全机制。一方面保证了数据在网络中传输的安全性，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。</p>
<p>主要区别：</p>
<ol>
<li>HTTP 的连接是简单无状态的，HTTPS 的数据传输是经过证书加密的，安全性更更高。</li>
<li>HTTP 是免费的，而 HTTPS 需要申请证书，而证书通常是需要收费的。</li>
<li>它们的传输协议不同，所以它们使用的端口也是不一样的，HTTP 默认使用 80 端口，而 HTTPS 默认使用 443 端口</li>
</ol>
<blockquote>
<p>HTTPS 的缺点：</p>
</blockquote>
<ul>
<li><p>HTTPS 的握手协议比较费时，所以会影响服务的响应速度及吞吐量。</p>
<p>  （HTTP 协议是基于 TCP 的“三次握手，四次挥手”，而 HTTPS 则是再 HTTP 的基础上，又增加了一系列证书校验的操作，所以耗时更长）</p>
</li>
<li><p>HTTPS 也并不是完全安全的。它的证书体系其实并不是完全安全的，并且 HTTPS 在面对 DDOS 这样的攻击时，几乎起不到任何作用。</p>
</li>
<li><p>证书需要收费，并且功能越强大的证书费用越高。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Java面经——多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-27 15:41:30" itemprop="dateCreated datePublished" datetime="2021-06-27T15:41:30+08:00">2021-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-27 10:23:30" itemprop="dateModified" datetime="2021-09-27T10:23:30+08:00">2021-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">Java面经</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  ReentrantLock，重进入锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *      如果将同步代码块的关键字放在最外层，即 synchronized (lock)&#123;while()&#123;....&#125;&#125; ，这时只有一个线程会进入到 while 循环中执行，</span></span><br><span class="line"><span class="comment">         *  直到票卖完才放开锁。</span></span><br><span class="line"><span class="comment">         *      如果将同步代码块的关键字放在 while 循环内，当每执行一次循环体后，其它两个线程也有机会争夺到锁对象去执行 while 循环内的代码。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      所以 为了让其它线程也有机会执行循环体内的代码，我们都会将 同步代码块放在循环内。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*  这个位置多个线程对象都可以进来，在这个位置争夺锁对象，每执行一次 sellTickets() 方法后，</span></span><br><span class="line"><span class="comment">            *   多个线程对象重新争夺锁对象。</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                sellTickets();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sellTickets</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟出票时间</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> tickets--;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;正在出票，余票还有：&quot;</span> + left + <span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h1><p>进程是操作系统进行<strong>资源分配</strong>的最小单元，线程是操作系统进行<strong>任务分配</strong>的最小单元。</p>
<blockquote>
<ol>
<li> 如何理解“资源分配的最小单元和任务分配的最小单元”？</li>
</ol>
</blockquote>
<p>​        保存在硬盘上程序运行以后，会在内存空间中形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源。操作系统只负责把系统资源分配给线程，而线程在继续把系统资源分配给谁是线程自己决定的，操作系统不会干涉这一行为。所以我们说，进程是操作系统进行资源分配的最小单位。</p>
<p>​        进程可以认为是一个资源管理者的角色，但是在程序运行的过程中，进程并不会亲自去执行任务，而是把任务下发给线程去执行，并分配给线程执行任务需要的资源。所以说，线程是操作系统进行任务分配的最小单元。</p>
<h1 id="1-Java-如何开启线程？怎样保证线程安全？"><a href="#1-Java-如何开启线程？怎样保证线程安全？" class="headerlink" title="1    Java 如何开启线程？怎样保证线程安全？"></a>1    Java 如何开启线程？怎样保证线程安全？</h1><h2 id="1-1-进程和线程的区别？"><a href="#1-1-进程和线程的区别？" class="headerlink" title="1.1    进程和线程的区别？"></a>1.1    进程和线程的区别？</h2><ul>
<li>  进程是操作系统进行资源分配的最小单元，线程是操作系统进行任务分配的最小单元，线程隶属于进程。</li>
</ul>
<h2 id="1-2-如何开启线程？"><a href="#1-2-如何开启线程？" class="headerlink" title="1.2    如何开启线程？"></a>1.2    如何开启线程？</h2><ol>
<li>定义线程执行体（4种方法）</li>
<li>调用 <code>Thread#start()</code> 方法让线程开始执行。</li>
</ol>
<h3 id="1-2-1-定义线程执行体有哪4种方法？"><a href="#1-2-1-定义线程执行体有哪4种方法？" class="headerlink" title="1.2.1    定义线程执行体有哪4种方法？"></a>1.2.1    定义线程执行体有哪4种方法？</h3><ul>
<li>继承 Thread 类，重写 <code>run()</code> 方法</li>
<li>实现 Runnable 接口，实现 <code>run()</code> 方法</li>
<li>实现 Callable 接口，实现 <code>call()</code> 方法</li>
<li>通过线程池来开启线程</li>
</ul>
<h4 id="1-2-1-1-继承-Thread-类-和-实现-Runnable-接口的区别-？（单继承和多实现的优劣）"><a href="#1-2-1-1-继承-Thread-类-和-实现-Runnable-接口的区别-？（单继承和多实现的优劣）" class="headerlink" title="1.2.1.1    继承 Thread 类 和 实现 Runnable 接口的区别 ？（单继承和多实现的优劣）"></a>1.2.1.1    继承 Thread 类 和 实现 Runnable 接口的区别 ？（单继承和多实现的优劣）</h4><h4 id="1-2-1-2-实现-Runnable-接口-和-实现-Callable-接口的区别-？"><a href="#1-2-1-2-实现-Runnable-接口-和-实现-Callable-接口的区别-？" class="headerlink" title="1.2.1.2    实现 Runnable 接口 和 实现 Callable 接口的区别 ？"></a>1.2.1.2    实现 Runnable 接口 和 实现 Callable 接口的区别 ？</h4><ul>
<li>实现 Runnable 接口，接口中的 <code>run()</code> 方法是没有返回值的。     </li>
<li>实现 Callable 接口，接口中的 <code>call()</code> 方法则可以设置返回值。  </li>
<li>如果新开启的线程想要获得返回值，知道线程执行的结果，则可以实现 Callable 接口。通过 FutureTask 创建一个线程，获取到线程执行的返回值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	实现 Runnable 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO	</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	实现 Callable 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;	<span class="comment">/*	实现 Callable 接口时要指定 call() 方法返回值的数据类型	*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个Callable线程&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;callable 线程执行成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 ---------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTests</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1、创建一个线程对象（使用 FutureTask 对象构建线程对象）</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);		<span class="comment">// FutureTask 实现了 Runnable 接口，所以可以传入到线程中执行</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、线程执行</span></span><br><span class="line">        thread.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3、从 futureTask 对象中获取线程执行后的返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">returnVale</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(returnVale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-3-怎么保证线程安全？"><a href="#1-3-怎么保证线程安全？" class="headerlink" title="1.3    怎么保证线程安全？"></a>1.3    怎么保证线程安全？</h2><h3 id="1-3-1-什么是线程安全？"><a href="#1-3-1-什么是线程安全？" class="headerlink" title="1.3.1    什么是线程安全？"></a>1.3.1    什么是线程安全？</h3><h3 id="1-3-2-怎么保证线程安全？"><a href="#1-3-2-怎么保证线程安全？" class="headerlink" title="1.3.2    怎么保证线程安全？"></a>1.3.2    怎么保证线程安全？</h3><p>答：加锁。</p>
<ol>
<li> JVM 提供的锁：<strong>synchronized</strong> 关键字</li>
<li> JDK 提供的各种锁：基于 <strong>Lock</strong> 接口的多种实现类。</li>
</ol>
<hr>
<h1 id="2-Volatile-和-Synchronized-有什么区别-？Volatile-能不能保证线程安全-？DCL（Double-Check-Lock）单例为什么要加-Volatile-？"><a href="#2-Volatile-和-Synchronized-有什么区别-？Volatile-能不能保证线程安全-？DCL（Double-Check-Lock）单例为什么要加-Volatile-？" class="headerlink" title="2    Volatile 和 Synchronized 有什么区别 ？Volatile 能不能保证线程安全 ？DCL（Double Check Lock）单例为什么要加 Volatile ？"></a>2    Volatile 和 Synchronized 有什么区别 ？Volatile 能不能保证线程安全 ？DCL（Double Check Lock）单例为什么要加 Volatile ？</h1><h2 id="2-1-Volatile-和-Synchronized-有什么区别-？"><a href="#2-1-Volatile-和-Synchronized-有什么区别-？" class="headerlink" title="2.1    Volatile 和 Synchronized 有什么区别 ？"></a>2.1    Volatile 和 Synchronized 有什么区别 ？</h2><blockquote>
<p>  [volatile，可挥发性的]</p>
<p>  作用：1、保持线程间变量的可见性    2、防止指令重排</p>
</blockquote>
<ol>
<li>Synchronized 关键字用来加锁。</li>
<li>Volatile 只是保持线程间变量的可见性。通常适用于一个线程写，多个线程读的场景。</li>
</ol>
<hr>
<h2 id="2-2-DCL（Double-Check-Lock）单例为什么要加-Volatile-？"><a href="#2-2-DCL（Double-Check-Lock）单例为什么要加-Volatile-？" class="headerlink" title="2.2    DCL（Double Check Lock）单例为什么要加 Volatile ？"></a>2.2    DCL（Double Check Lock）单例为什么要加 Volatile ？</h2><ul>
<li>Volatile 关键字可以防止指令重排。单线程环境下，指令重排不会造成大的影响；但是在多线程环境下，指令重排有可能造成变量的读取错误。在 DCL 单例中，Volatile 主要用于防止高并发情况下，指令重排造成的线程安全问题。</li>
</ul>
<h3 id="2-2-1-什么是-DCL-单例？"><a href="#2-2-1-什么是-DCL-单例？" class="headerlink" title="2.2.1    什么是 DCL 单例？"></a>2.2.1    什么是 DCL 单例？</h3><p>DCL（Double Check Lock）：双重检查锁</p>
<blockquote>
<ol>
<li>普通单例</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个单例对象：</span></span><br><span class="line"><span class="comment"> *      1、在类加载时就创建一个实例对象</span></span><br><span class="line"><span class="comment"> *      2、将构造方法私有化（不提供从外部创建对象的接口）</span></span><br><span class="line"><span class="comment"> *      3、提供一个公共的方法用于获取这个单例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleExample</span> <span class="variable">singleExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这种单例模式的弊端：无论这个单例对象在程序中是否会使用，在类加载阶段都会创建这个单例对象。会浪费服务器的性能。</li>
</ul>
<blockquote>
<ol start="2">
<li>单例优化：类加载阶段不创建实例对象，在使用时才创建实例对象。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 线程不安全。假设在这个位置同时进入了多个线程</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">            singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这种单例模式的弊端：线程不安全！！！</li>
<li>如果同时有多个线程进入了第8行的位置，显然这些线程都会执行 <code>new SingleExample()</code> 方法，就会创建多个对象实例。</li>
</ul>
<blockquote>
<ol start="3">
<li>继续优化：想要实现线程安全，就需要加锁。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;	<span class="comment">// 使用 synchronized 关键字加锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">            singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这种单例模式的弊端：锁的粒度太大。<ol>
<li> 除了第一次调用 <code>getInstance()</code> 方法时会执行创建 SingleExample 对象的动作外，以后的每一次调用都是直接返回 singleExample 对象，返回对象这个操作的耗时是很小的，绝大部分的耗时都用在 synchronized 修饰符的同步准备上，因此从性能上来说很不划算。</li>
<li> 也就是说，如果我们还想在 <code>getInstance()</code> 方法的 if 模块之外添加其它业务逻辑，并且这些业务逻辑不会产生线程安全问题。这时候直接在最外层的方法上加锁，每次仍然需要进行锁对象的争夺，就会影响程序执行的性能了。</li>
</ol>
</li>
</ul>
<blockquote>
<ol start="4">
<li>继续优化：降低锁的粒度。将同步锁加在具体某一行或几行代码上。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// TODO 支持多线程操作且线程安全的代码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample) &#123;</span><br><span class="line">            <span class="comment">// 允许多个线程同时进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample.class) &#123;</span><br><span class="line">                singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>弊端：违背了单例的原则。</li>
<li>分析：第11行允许有多个线程同时进入，即使在第12行进行了加锁，也只能保证多个线程不会<strong>同时</strong>创建 SingleExample 对象，但是这多个线程最终还是会创建出来多个 SingleExample 对象，违背了单例的原则。</li>
</ul>
<blockquote>
<ol start="5">
<li>继续优化：DCL（Double Check Lock），双重检查锁。在锁的前面和后面都进行一次判断</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 支持多线程操作且线程安全的代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample) &#123;    <span class="comment">/*第一次检查，如果已有实例对象就不会触发多线程操作，作用是节省性能*/</span></span><br><span class="line">            <span class="comment">// 允许多个线程同时进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample.class) &#123;    <span class="comment">/*第二次检查，作用是保证创建出来的实例对象只能有一个*/</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">                    singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双重检查锁可以解决锁的粒度大且线程不安全的问题。</li>
<li>分析：<ol>
<li> 第一次检查的目的：如果 singleExample 对象已经被创建了出来，那么就不会进入到多个线程争夺锁对象的阶段，节省性能。</li>
<li> 第二次检查的目的：保证创建出来的实例对象只能有一个。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-2-2-什么是指令重排？"><a href="#2-2-2-什么是指令重排？" class="headerlink" title="2.2.2    什么是指令重排？"></a>2.2.2    什么是指令重排？</h3><p><img src="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png"></p>
<ol>
<li>在计算机中，CPU 负责数据的计算功能，可以直接从内存中读取数据。</li>
<li>假设 CPU 按照上图 1~4 序号的顺序执行，在执行完第 1 阶段后，CPU 需要从内存中读取数据，从向内存发送读取数据的请求到内存返回数据给 CPU 需要花费一定的时间，那么这段时间 CPU 就是处于空闲状态的。</li>
<li>上图中第 3 阶段是 CPU 自给自足，根据自身有的数据进行计算，也需要花费一定的时间。</li>
<li>那什么是指令重排呢？就是将本来第3阶段要执行的任务提前到1、2阶段之间，因为这段时间CPU是空闲的。实际上 CPU 也是这么干的。</li>
</ol>
<h4 id="2-2-2-1-Java创建对象过程中CPU进行的操作"><a href="#2-2-2-1-Java创建对象过程中CPU进行的操作" class="headerlink" title="2.2.2.1    Java创建对象过程中CPU进行的操作"></a>2.2.2.1    Java创建对象过程中CPU进行的操作</h4><p><img src="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%843%E4%B8%AA%E9%98%B6%E6%AE%B5.png"></p>
<p>Java 创建对象的过程：</p>
<ol>
<li>在堆中划分一块空间用于存储对象并赋初值。</li>
<li>根据对象的构造函数进行初始化（显式赋值）。</li>
<li>在栈中建立指针与对象的对应关系。</li>
</ol>
<p>Java 创建对象的每一步都需要 CPU 提供相应的指令，且对象数据保存在堆内存中，CPU 需要从内存中去读取这部分数据并拿回来运算，这就有可能会发生指令重排。</p>
<ul>
<li>如果发生指令重排，则原本执行顺序可能变为<code>1-&gt; 3-&gt; 2</code>，指令重排在单线程下是不会对程序产生大的影响的，因为单线程操作的过程中不会有其它线程来访问程序执行的某个中间阶段，最终的结果不会改变。</li>
<li>但是如果在多线程的情况下（假设指令重排后顺序变为<code>1-&gt; 3-&gt; 2</code>），线程 1 创建单例对象，执行了1，3步骤后，切换到线程 2 执行读取单例对象并返回的操作，那么这时候线程 2 读取到的单例对象的值就是分配堆空间时的默认初始值，而不是构造器中显式指定的初始值，显然这是不对的。之后线程1再执行第2步骤，即使这样最终线程 1 完成了构造器显式赋值，并且之后也不会再出现读取到默认初值的情况，但是起码存在这样一种出错的可能性。</li>
<li>而 **volatile ** 关键字的作用就是保证指令不被重排。当创建单例对象时，保证指令的执行顺序一定是是 <code>1-&gt; 2 -&gt;3</code>。</li>
</ul>
<hr>
<h1 id="3-Java-线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别-？锁机制是如何升级的？"><a href="#3-Java-线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别-？锁机制是如何升级的？" class="headerlink" title="3    Java 线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别 ？锁机制是如何升级的？"></a>3    Java 线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别 ？锁机制是如何升级的？</h1><ul>
<li>  Java 中每个对象都可作为锁，Java 中的锁就是在对象的对象头的 MarkWord 中记录一个标识，用于记录锁的状态。</li>
<li>  锁状态有四种级别，按照量级从轻到重分为：<code>无锁-&gt; 偏向锁-&gt; 轻量级锁-&gt; 重量级锁</code></li>
<li>  锁只能升级不能降级，Java 的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。</li>
</ul>
<h2 id="3-1-前置知识"><a href="#3-1-前置知识" class="headerlink" title="3.1    前置知识"></a>3.1    前置知识</h2><h3 id="3-1-1-自旋"><a href="#3-1-1-自旋" class="headerlink" title="3.1.1    自旋"></a>3.1.1    自旋</h3><ul>
<li><p>场景设定：</p>
<p>  ​        有两个线程A、B在竞争一个锁，假设 A 拿到了锁对象，这个时候 B 就会被挂起阻塞，一直等到 A 释放了锁 B 才得到使用权。在操作系统中阻塞和唤醒其实也是一个耗时操作，如果线程 A 在很短的时间内就使用完并释放了锁，当这个时间比 <code>阻塞B线程 + 唤醒B 线程</code> 的总耗时更短的时候，我们将线程 B 挂起，其实并不是一个最优的选择。</p>
</li>
<li><p><strong>自旋</strong>的概念：</p>
<p>  ​        自旋是指某线程需要获取锁，但该锁对象已经被其他线程占用时，这时这个线程不会被挂起，而是在不停的试图获取锁，不断的消耗 CPU 的时间。虽然 CPU 的时间被消耗了，但是相比线程上下文切换时间要少，这个时候使用自旋就是划算的。 </p>
<p>  ​        而偏向锁、轻量锁、重量锁也是一个锁围绕着如何使得程序运行的更加“划算”而进行改变的。</p>
</li>
</ul>
<h3 id="3-1-2-对象头"><a href="#3-1-2-对象头" class="headerlink" title="3.1.2    对象头"></a>3.1.2    对象头</h3><p><img src="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/20190415101813830.png"></p>
<p>HotSpot 中，对象在堆内存中的布局可以分为三块部分：</p>
<blockquote>
<ol>
<li> 对象头（Header）</li>
<li> 实例数据（Instance Data） </li>
<li> 对齐填充（Padding）</li>
</ol>
</blockquote>
<p>​        其中对象头（Object Header）主要包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为 32bits 和 64Bits，官方称它为“Mark Word”。</p>
<p>​        在 HotSpot 虚拟机中对象未被锁定的状态下，Mark Word 的32个Bits 空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits 用于存储锁标志位，1Bit 固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如上图所示。 </p>
<p><img src="/2021/06/27/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210507174841595.png" alt="image-20210507174841595"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- OFFSET 代表偏移量（其实就是相对于起点的位置）</span></span><br><span class="line"><span class="comment">-- SIZE 代表每一部分的字节数（这里每一部分为4bytes）</span></span><br><span class="line"><span class="comment">-- TYPE DESCRIPTION 类型描述：1、object header，对象头  2、loss due to the next object alignment 补位数据，为了补满一个对象占用的64bits设置的空数据</span></span><br><span class="line"></span><br><span class="line">一个对象占<span class="number">16</span>字节（<span class="number">16</span>bytes），共 <span class="number">128</span> 位（<span class="number">16</span><span class="operator">*</span><span class="number">8</span> bits）</span><br><span class="line"></span><br><span class="line">第一个 <span class="number">4</span>bytes 就是对象在堆内存中的标志位，也叫做 MarkWord，作用就是记录整个对象的一些状态信息，其中也包括锁的状态信息。</span><br><span class="line">	MarkWord 占 <span class="number">32</span>bits（<span class="number">4</span>bytes），</span><br><span class="line">	锁状态的标志位在 <span class="number">31</span><span class="operator">~</span><span class="number">32</span> 位，可以看到，对象加锁和未加锁的区别仅仅是在 <span class="number">31</span><span class="operator">~</span><span class="number">32</span>bit 之间不同，剩余其它部分都是相同的。</span><br><span class="line">	在上图中，未加锁时 <span class="number">30</span><span class="operator">~</span><span class="number">32</span> 比特的二进制编码是 “<span class="number">01</span>”，加锁后变成了 “<span class="number">00</span>”，也就是说，我们通过 synchronized 关键字给对象加了一个轻量级锁。</span><br><span class="line">	</span><br><span class="line">第二个 <span class="number">4</span>bytes 的作用就是指向方法区的一个 Class 对象；</span><br><span class="line">第三个 <span class="number">4</span>bytes 保存一些成员变量的信息</span><br><span class="line">第四个 <span class="number">4</span>bytes 保存一些补位数据，保证对象能被 <span class="number">8</span>bits 整除。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>​        引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。<br>​        当只有一个线程去竞争锁的时候，我们不需要阻塞，也不需要自旋，因为只有一个线程在竞争，我们只要去判断该偏向锁中的ThreadID 是否为当前线程即可。如果是就执行同步代码，不是就尝试使用CAS修改ThreadID，修改成功执行同步代码，不成功就将偏向锁升级成轻量锁。</p>
<h2 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h2><p>​        获取轻量锁的过程与偏向锁不同，竞争锁的线程首先需要拷贝对象头中的Mark Word到帧栈的锁记录中。拷贝成功后使用CAS操作尝试将对象的Mark Word更新为指向当前线程的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁。如果更新失败，那么意味着有多个线程在竞争。<br>当竞争线程尝试占用轻量级锁失败多次之后（使用自旋）轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。</p>
<h2 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h2><p>​        重量级锁的加锁、解锁过程和轻量级锁差不多，区别是：竞争失败后，线程阻塞，释放锁后，唤醒阻塞的线程，不使用自旋锁，不会那么消耗CPU，所以重量级锁适合用在同步块执行时间长的情况下。</p>
<p>基础知识之一：锁的类型<br>锁从宏观上分类，分为悲观锁与乐观锁。</p>
<p>乐观锁<br>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<p>悲观锁<br>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p>
<p>基础知识之二：java线程阻塞的代价<br>java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p>
<p>如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；<br>如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。<br>synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。</p>
<p>明确java线程切换的代价，是理解java中各种锁的优缺点的基础之一。</p>
<p>重量级锁Synchronized</p>
<p>在JDK1.5之前都是使用synchronized关键字保证同步的，Synchronized的作用相信大家都已经非常熟悉了；</p>
<p>它可以把任意一个非NULL的对象当作锁。</p>
<p>作用于方法时，锁住的是对象的实例(this)；<br>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；<br>synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。<br>Synchronized的实现<br>实现如下图所示；</p>
<p>它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p>
<p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
<p>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</p>
<p>Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；</p>
<p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck；</p>
<p>Owner：当前已经获取到所资源的线程被称为Owner；</p>
<p>!Owner：当前释放锁的线程。</p>
<p>JVM每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList会被大量的并发线程进行CAS访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程。Owner线程会在unlock时，将ContentionList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程（一般是最先进去的那个线程）。Owner线程并不直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM中，也把这种选择行为称之为“竞争切换”。</p>
<p>OnDeck线程获取到锁资源后会变为Owner线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify或者notifyAll唤醒，会重新进去EntryList中。</p>
<p>处于ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。</p>
<p>Synchronized是非公平锁。 Synchronized在线程进入ContentionList时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占OnDeck线程的锁资源。</p>
<p>Synchronized的底层原理<br>对于普通同步方法，锁是当前实例对象。<br>对于静态同步方法，锁是当前类的Class对象。<br>对于同步方法块，锁是Synchonized括号里配置的对象。</p>
<p>实现的原理：<br>synchronized是基于Monitor来实现同步的。<br>Monitor从两个方面来支持线程之间的同步：互斥执行、协作</p>
<p>1、Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行。<br>2、使用 notify/notifyAll/wait 方法来协同不同线程之间的工作。<br>3、Class和Object都关联了一个Monitor。<br>Monitor 的工作机理</p>
<p>1：线程进入同步方法中。<br>2：为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）<br>3：拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。<br>4：其他线程调用 notify() / notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要重新获取监视锁后才能执行 wait() 之后的代码。<br>5：同步方法执行完毕了，线程退出临界区，并释放监视锁<br>synchronized的锁优化</p>
<p>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。其中主要就是偏向锁，轻量级锁，重量级锁。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Java中print、println、printf的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-27 14:25:02" itemprop="dateCreated datePublished" datetime="2021-06-27T14:25:02+08:00">2021-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-02 20:51:50" itemprop="dateModified" datetime="2021-08-02T20:51:50+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaExt/" itemprop="url" rel="index"><span itemprop="name">JavaExt</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1    前置知识"></a>1    前置知识</h2><h3 id="1-1-常见的转义字符"><a href="#1-1-常见的转义字符" class="headerlink" title="1.1    常见的转义字符"></a>1.1    常见的转义字符</h3><ul>
<li><p><code>\t</code>，<code>\r </code>，<code>\n</code> 都是转义字符。空格就是单纯的空格，输入时可以输入空格</p>
</li>
<li><p><code>\t</code> 的意思是 <strong>横向跳到下一制表符位置（一个制表符就是一个 Tab）</strong></p>
</li>
<li><p><code>\r</code> 的意思是 <strong>回车</strong></p>
</li>
<li><p><code>\n</code> 的意思是 <strong>回车换行</strong></p>
</li>
</ul>
<blockquote>
<p>  所有的转义字符和所对应的意义：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td align="center">\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td align="center"><strong>\n</strong></td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td align="center"><strong>\r</strong></td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td align="center"><strong>\t</strong></td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td align="center">\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td align="center">\</td>
<td>代表一个反斜线字符’’&#39;</td>
<td>092</td>
</tr>
<tr>
<td align="center">&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td align="center">&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td align="center">?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td align="center">\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td align="center">\ooo</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td align="center">\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td>二位十六进制</td>
</tr>
</tbody></table>
<ul>
<li>  Tip：转义符使用的是反斜杠 <code>\</code> 而不是斜杠 <code>/</code> 。</li>
</ul>
<hr>
<h3 id="1-2-System-out-println-与-PrintStream-的关系"><a href="#1-2-System-out-println-与-PrintStream-的关系" class="headerlink" title="1.2    System.out.println() 与 PrintStream 的关系"></a>1.2    System.out.println() 与 PrintStream 的关系</h3><blockquote>
<p>  <strong>提出问题：</strong></p>
</blockquote>
<p>​        在 Java 程序中，我们总是使用 <code>System.out.println();</code> 用于展示输出结果，但是追踪源码我们会发现 <code>print()</code> 方法位于 <strong>PrintStream</strong> 类中，而我们却总是使用 System 中的 out 属性（即 <code>System.out</code> ）来调用 <code>print()</code> 方法，这就说明 <code>System.out</code> 其实指向了一个 PrintStream 类对应的实例对象。查看 <strong>System</strong> 类的源码可以看到：<strong>out</strong> 是一个 PrintStream 类型的实例对象，并且在 System 类中提供了 set 方法用于创建该对象。</p>
<p><img src="/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/image-20210627151759843.png" alt="image-20210627151759843"></p>
<p>​        所以可以得出一个结论：<code>System.out</code> 就等价于一个 PrintStream 类的实例对象。</p>
<hr>
<h2 id="2-print、println、printf-的区别"><a href="#2-print、println、printf-的区别" class="headerlink" title="2    print、println、printf 的区别"></a>2    print、println、printf 的区别</h2><ul>
<li><code>print</code> 是一般的标准输出，不会自动换行。</li>
<li><code>println</code> 和 <code>print</code> 基本没什么差别，但是会<strong>自动换行</strong>。</li>
<li><code>printf</code> 继承了C语言的 <code>printf</code> 的一些特性，可以进行<strong>格式化输出</strong>，与 C 语言用法相同。可以同时输出多个值，由 <code>%</code> 控制格式。</li>
<li>以上3个方法都可以添加转义字符。</li>
</ul>
<h3 id="2-1-print、println、printf-源码分析"><a href="#2-1-print、println、printf-源码分析" class="headerlink" title="2.1    print、println、printf 源码分析"></a>2.1    print、println、printf 源码分析</h3><blockquote>
<p>  <strong>PrintStream#print()</strong></p>
<p>  <strong>PrintStream#println()</strong></p>
<p>  <strong>PrintStream#printf()</strong></p>
</blockquote>
<p><code>print()</code> 、<code>println()</code> 和 <code>printf()</code> 方法都是 PrintStream 类中的普通方法，如图所示我们可以看到，</p>
<ul>
<li>  <code>print()</code> 和 <code>println()</code> 方法最多只有一个参数，也就是说这两个方法会把方法参数按照指定的格式直接输出。</li>
<li>  对于 <code>println()</code> 这个空参的方法，输出结果仅仅起到一个换行的作用。</li>
<li>  而对于 <code>printf()</code> 方法，最少都有两个参数，一个参数用于接收含有占位符的字符串，而另一个参数则主要用于给占位符赋值等操作。</li>
</ul>
<p><img src="/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/image-20210627145315659.png" alt="image-20210627145315659"></p>
<blockquote>
<p>  <strong>部分源码（JDK8）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">        write(b ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        write(String.valueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        write(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">        write(String.valueOf(l));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> f)</span> &#123;</span><br><span class="line">        write(String.valueOf(f));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">        write(String.valueOf(d));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">        write(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        write(String.valueOf(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// println() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">()</span> &#123;</span><br><span class="line">        newLine();	<span class="comment">// newLine() 是一个换行的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">boolean</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">float</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> x[])</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(s);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf() 方法</span></span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String format, Object ... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(format, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(Locale l, String format, Object ... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(l, format, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-printf-格式化输出"><a href="#2-2-printf-格式化输出" class="headerlink" title="2.2    printf  格式化输出"></a>2.2    printf  格式化输出</h3><blockquote>
<p>  十六进制，hexadecimal</p>
<p>  十进制，decimalism</p>
<p>  八进制，octal</p>
<p>  二进制，binary</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;d&#x27; 将整数结果格式化为十进制整数</span><br><span class="line">&#x27;o&#x27; 将整数结果格式化为八进制整数</span><br><span class="line">&#x27;x&#x27;, &#x27;X&#x27; 将整数结果格式化为十六进制整数</span><br><span class="line">&#x27;e&#x27;, &#x27;E&#x27; 将浮点结果格式化为用计算机科学记数法表示的十进制数</span><br><span class="line">&#x27;f&#x27; 将浮点结果格式化为十进制数</span><br><span class="line">&#x27;g&#x27;, &#x27;G&#x27; 将浮点根据精度和舍入运算后的值，使用计算机科学记数形式或十进制格式对结果进行格式化。</span><br><span class="line">&#x27;a&#x27;, &#x27;A&#x27; 将浮点结果格式化为带有效位数和指数的十六进制浮点数</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>%d</code> 是一个 int 类型数据的占位符，这个占位符的值在 <code>printf()</code> 方法的第二个参数中提供。</p>
</li>
<li><p><code>%f</code> 是一个 double 或 float 类型数据的占位符，这个占位符的值在 <code>printf()</code> 方法的第二个参数中提供。</p>
</li>
<li><p>举例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果想要只输出两位小数？</span><br><span class="line">	System.out.printf(<span class="string">&quot;输出一个两位小数 %.2f&quot;</span>, num);</span><br><span class="line">这里的<span class="string">&quot;%.2f&quot;</span>的意思是输出两位小数点。如果想输出三位那就<span class="string">&quot;%.3f&quot;</span>。</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3    总结"></a>2.3    总结</h3><ul>
<li><code>print()</code> 方法会将方法中的参数打印输出在控制台上，并将输出光标定位在所显示的最后一个字符之后。</li>
<li><code>println()</code> 方法将它的参数打印显示在命令窗口，并在结尾加上换行符，将输出光标定位在下一行的开始。(自动换行)</li>
<li><code>print()</code> 方法接收 2 个参数，一个参数用于指定输出格式并保留插值表达式，另一个参数用于将插值表达式的值按顺序插入到插值表达式的留空中。</li>
</ul>
<hr>
<h2 id="3-测试用例"><a href="#3-测试用例" class="headerlink" title="3    测试用例"></a>3    测试用例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">7.36</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  println() 方法：标准输出 + 自动换行  */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;CCC\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  print() 方法：标准输出（不自动换行）    */</span></span><br><span class="line">        System.out.print(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;ccc\n&quot;</span>);	<span class="comment">// 可以加转义字符进行手动换行</span></span><br><span class="line"></span><br><span class="line">        System.out.println();   <span class="comment">// 直接输出空的 println() 方法就相当于自动换行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  printf() 方法：格式化输出  */</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;树上吊着%d只大马猴\n&quot;</span>, num1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Java%E4%B8%ADprint%E3%80%81println%E3%80%81printf%E7%9A%84%E5%8C%BA%E5%88%AB/image-20210510105800973.png" alt="image-20210510105800973"></p>
<h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4    构造方法"></a>4    构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * print() 方法：  直接在控制台上打印参数中的字符串，不换行</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * println() 方法：  在控制台上打印参数中的字符串，并且在打印完成后末尾加上换行</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * printf() 方法：  在控制台上打印格式化输出后的字符串。</span></span><br><span class="line"><span class="comment">         *      可以接收两个参数：</span></span><br><span class="line"><span class="comment">         *          String format   要打印在控制台上的内容，参数部分用指定的格式保留（类似于插值表达式）</span></span><br><span class="line"><span class="comment">         *          Object args    将真正的参数 args 按顺序插入到 format 中保留的位置中</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> format</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String format, Object ... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(format, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">JVM——垃圾收集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-23 09:47:57" itemprop="dateCreated datePublished" datetime="2021-06-23T09:47:57+08:00">2021-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-11 18:58:49" itemprop="dateModified" datetime="2021-10-11T18:58:49+08:00">2021-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><blockquote>
<p>  <strong>垃圾收集；垃圾回收；Garbage Collection；GC</strong></p>
</blockquote>
<p>​        垃圾收集并非 Java 语言的伴生产物，垃圾收集的历史远比 Java 久远。早在 1960 年，第一门开始使用<strong>动态内存分配</strong>和<strong>垃圾收集技术</strong>的 Lisp 语言就诞生了。</p>
<ul>
<li>  <strong>内存动态分配</strong>是相对于 C/C++ 等需要开发人员手动分配内存的语言来讲的，JVM 内存动态分配的特性大大减轻了开发人员在内存分配方面的工作量。</li>
<li>  <strong>垃圾收集技术</strong>在不同的语言中均有不同的实现，在 Java 语言中的实现是由 JVM 进行的垃圾自动收集。</li>
</ul>
<p>垃圾收集机制是 Java 的招牌能力，因为其特有的内存动态分配和垃圾自动收集机制，让开发人员可以不必过于关注内存分配和垃圾回收的相关问题，将更多的精力投入到业务开发中，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战。</p>
<h2 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1  什么是垃圾"></a>1  什么是垃圾</h2><blockquote>
<p>  <strong>什么是垃圾（Garbage）？</strong></p>
</blockquote>
<ul>
<li>  垃圾指<strong>在应用程序中没有任何指针指向的对象</strong>，这些对象就是需要被回收的垃圾。</li>
</ul>
<p>如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占用的内存空间就会一直保留直到应用程序结束，被保留的空间无法被其它对象使用，就会增加内存溢出的概率。</p>
<h2 id="2-为什么需要-GC"><a href="#2-为什么需要-GC" class="headerlink" title="2  为什么需要 GC"></a>2  为什么需要 GC</h2><p>GC = 内存清理+内存整理</p>
<ul>
<li><p>  对于一个应用程序来说，如果不进行垃圾回收，内存迟早都会被消耗完，因为程序只会不断的分配内存空间而不进行回收。</p>
</li>
<li><p>  除了释放不再被使用的对象，垃圾回收也会清除内存中的记录碎片。碎片整理将所占用的堆内存移动到堆的一端，以便 JVM 将整理出的内存分配给新的对象。</p>
</li>
<li><p>  随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序的正常进行。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p>
</li>
</ul>
<h2 id="3-早期的垃圾回收（C-C-垃圾回收）"><a href="#3-早期的垃圾回收（C-C-垃圾回收）" class="headerlink" title="3  早期的垃圾回收（C/C++垃圾回收）"></a>3  早期的垃圾回收（C/C++垃圾回收）</h2><blockquote>
<p>  <strong>Before</strong></p>
</blockquote>
<p>​        在早期的 C/C++ 时代，垃圾回收基本上是手工进行的。开发人员可以使用 <code>new</code> 关键字申请内存空间，在使用完毕之后使用 <code>delete</code> 关键字进行内存的释放。这种方式的优点是可以<strong>灵活</strong>的控制内存申请、释放的时间，但是频繁地申请和释放内存会给开发人员带来额外内存管理的负担。如果某块内存空间由于开发人员疏忽而忘记被回收，那么就会产生内存泄露，这块内存空间中的垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象消耗的内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p>
<p>​        <em>[垃圾对象消耗的内存为什么可能会持续上升？某块内存空间由于开发人员疏忽而忘记回收，如果该块内存中保存的是一个单例对象，并且该对象关联的其它对象也都是单例对象，那么在程序运行中对象消耗的内存会一直保持不变。但是如果该块内存中保存的是一个非单例对象（或者该块内存中存储的是一个单例对象，但该单例对象引用了其它非单例对象），那么在程序运行的过程中，每访问一次该块内存中保存的对象，都会有新的对象被创建，并且被该块内存中一个长期存在的对象引用，不能被销毁，所以随着系统运行时间的增长，垃圾对象占用的内存就可能会持续上升，直至出现内存溢出]</em></p>
<blockquote>
<p>  <strong>After</strong></p>
</blockquote>
<p>​        有了垃圾回收机制后，开发人员只需要关注内存的申请，在对象使用完毕之后由垃圾回收器自动进行内存的释放。目前，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，这也是未来发展的趋势。可以说，这种自动化的内存分配和垃圾回收的方式已经成为现代开发语言必备的标准。</p>
<hr>
<h2 id="4-JVM-垃圾收集机制"><a href="#4-JVM-垃圾收集机制" class="headerlink" title="4  JVM 垃圾收集机制"></a>4  JVM 垃圾收集机制</h2><p>自动内存管理机制：无需开发人员手动参与内存的<strong>分配</strong>与<strong>回收</strong>。</p>
<ul>
<li>  可以降低内存泄漏和内存溢出的风险。</li>
<li>  将开发人员从复杂的内存管理中释放出来，可以更将更多的精力专注于业务开发。</li>
</ul>
<hr>
<h2 id="5-应该关心哪些区域的回收？"><a href="#5-应该关心哪些区域的回收？" class="headerlink" title="5    应该关心哪些区域的回收？"></a>5    应该关心哪些区域的回收？</h2><blockquote>
<p>  <strong>1、堆区    2、方法区</strong></p>
</blockquote>
<p>首先，线程的伴生区域（程序计数器、虚拟机栈、本地方法栈）无需考虑垃圾回收。</p>
<ul>
<li>  Java 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭。栈中的栈帧随着随着方法的进入和退出同步执行出栈和入栈操作。每一个栈帧中分配多少内存是在类结构确定下来时就已知的（即前端编译期就可知了）。因此这几个区域的内存分配都具有确定性；当方法结束或者线程结束时，内存也就跟着回收了。所以这几个区域无需过多考虑内存回收问题。 </li>
</ul>
<p>而 Java 堆和方法区这两个区域存在很大的不确定性，只有程序在运行期间，我们才知道程序究竟会创建哪些对象，创建多少个对象。这部分的内存分配和回收是动态的。垃圾收集器关注的也正是这部分内存该如何管理。</p>
<p>只有堆区和方法区才存在 GC。其中， <strong>Java 堆是垃圾回收器的工作重点。</strong> </p>
<blockquote>
<p>  <strong>垃圾分代收集</strong></p>
</blockquote>
<p>垃圾收集器可以只对年轻代收集，也可以只对老年代收集，甚至是在 整个堆+方法区 范围内收集。从次数上讲：</p>
<ul>
<li>  频繁收集 Young 区</li>
<li>  较少收集 Old 区</li>
<li>  基本不动 Perm 区（或 MetaSpace）</li>
</ul>
<p><strong>《JVM虚拟机规范》并没有强制规定方法区一定要进行 GC。只是 HotSpot 在方法区实现了 GC。</strong></p>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">内存区域 / 行为</th>
<th align="center">OOM</th>
<th align="center">GC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆（Heap）</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">方法区（MetaSpace）</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">程序计数器（PC Register）</td>
<td align="center">✖</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center">虚拟机栈（Java Virtual Machine Stack）</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center">本地方法栈（Native Method Stack）</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6    总结"></a>6    总结</h2><blockquote>
<p>  <strong>垃圾收集需要完成哪些事情（垃圾回收经典三问）？</strong></p>
</blockquote>
<ol>
<li>哪些内存需要回收？<ul>
<li>  标记阶段</li>
</ul>
</li>
<li> 什么时候回收？</li>
<li>如何回收？<ul>
<li>  清除阶段 + 整理阶段</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>现如今，内存动态分配和内存回收技术已经非常成熟，作为开发人员为什么还要去了解垃圾收集和内存分配？</strong></p>
</blockquote>
<p>​    对于Java 开发人员而言，自动内存管理就像是一个“黑盒”，如果过度依赖于“自动”，就会 <strong>弱化 Java 开发人员面对内存溢出或内存泄漏时定位、解决问题的能力。</strong> 因此，了解 JVM 的自动内存分配和内存回收原理尤为重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇到 OOM 异常时，快速的根据错误异常日志定位问题和解决问题。</p>
<ol>
<li> 当应用程序出现内存泄漏，内存溢出等问题时，需要开发人员去定位、解决这些问题；</li>
<li> 当垃圾收集成为系统达到更高并发量的瓶颈时，需要开发人员通过优化 GC 来让系统的性能更上一层楼；</li>
<li> 而这些操作的前提是必须了解内存分配和内存回收的底层实现原理。</li>
</ol>
<hr>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><blockquote>
<ol>
<li>标记阶段<ul>
<li>  引用计数算法</li>
<li>  可达性分析算法（HotSpot 使用）</li>
<li>  对象的复活机制</li>
</ul>
</li>
<li>清除阶段<ul>
<li>  标记-清除算法</li>
<li>  复制算法</li>
<li>  标记-压缩算法</li>
</ul>
</li>
<li> 小结</li>
<li> 分代收集算法</li>
<li> 增量收集算法</li>
<li> 分区算法</li>
</ol>
</blockquote>
<h2 id="1-标记阶段"><a href="#1-标记阶段" class="headerlink" title="1    标记阶段"></a>1    标记阶段</h2><blockquote>
<p>  <strong>垃圾标记阶段：判断对象是否存活</strong></p>
</blockquote>
<p>​    Java 堆中存放着几乎所有的 Java 对象实例，垃圾收集器在进行内存回收之前，第一件事就是要<strong>确定待回收内存空间中的对象哪些是“存活”的，哪些是“死亡”的</strong>，垃圾收集时只会释放已死亡对象占用的内存空间。我们把确定对象存活状态的阶段称为 <strong>垃圾标记阶段。</strong> </p>
<blockquote>
<p>  <strong>那么在 JVM 中如何标记一个死亡对象呢？</strong></p>
</blockquote>
<ul>
<li>  简单来说，当一个对象已经不再被任何存活的对象继续引用时，就可以认为已经死亡。 </li>
<li>  判断对象存活常用的两种方式： <strong>引用计数算法</strong> 和 <strong>可达性分析算法</strong> 。</li>
</ul>
<h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1    引用计数算法"></a>1.1    引用计数算法</h3><blockquote>
<p>  <strong>引用计数算法；Reference_Counting</strong></p>
</blockquote>
<p>​    Reference_Counting 算法比较简单，就是<strong>在对象中添加一个引用计数器，用于记录对象被引用的情况。每当有一个地方引用该对象的时候，计数器值就 +1；当引用失效时，计数器值就 -1。任何时候计数器为零时就说明该对象已死亡，</strong>可被回收。</p>
<p><strong>优点：</strong></p>
<ul>
<li>  实现简单，垃圾对象便于辨识；</li>
<li>  标记效率高，标记延迟性低。（相对于可达性分析算法而言）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  需要单独的字段存储计数器的值，增加了对象<strong>存储空间的开销</strong>。</li>
<li>  每次 被引用/引用失效 时都需要更新计数器，伴随着加法和减法操作，增加了<strong>时间开销</strong> 。</li>
<li>  引用计数器有一个严重的问题，即 <strong>无法处理循环引用</strong> 的情况。这是一条致命的缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li>
</ul>
<h4 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h4><p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623661340601-63c12150-dfe7-454a-8044-9ba4dbea6d55.png" alt="循环引用.png"></p>
<blockquote>
<p>  <strong>什么是循环引用？</strong></p>
</blockquote>
<p>就是多个对象之间的依赖关系形成了一个环，就会导致每个对象的引用计数器的值始终不会减少到0，也就不会被回收。会造成内存泄露。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = Object A;</span><br><span class="line"></span><br><span class="line">a.field = Object B;</span><br><span class="line">b.field = Object C;</span><br><span class="line">c.field = Object A;</span><br></pre></td></tr></table></figure>

<ul>
<li>  如上图，现有某一外部对象通过指针 p 引用了对象A，对象A引用了对象B，对象B引用了对象C，对象C又引用了对象A。所以对象A、B、C 各自维护的引用计数器的值分别为 2，1，1 。 </li>
<li>  当外部对象不再需要使用对象A时，会设置为 <code>p=null</code>，A对象不再被使用，此时按理来说，对象A失效后，其内部变量指向的 B、C 都应该被回收，但是由于这三个对象之间形成了一个闭环引用，所以这三个对象的引用计数器的值最小始终为1，不会减小到0，也就是说，在引用计数算法的标准下，这三个对象始终不会死亡，这就会造成内存的泄漏。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>  JVM 并没有选择引用计数算法作为垃圾标记阶段的算法，是因为引用计数算法很难处理循环引用的问题。</li>
<li>引用计数算法被很多语言作为垃圾回收算法使用，例如 Python ，它支持引用计数算法的垃圾回收机制。<ul>
<li>Python 如何解决循环引用？<ul>
<li>  手动解除。在合适的实际，手动解除引用关系、</li>
<li>  使用弱引用 weakref ，weakref 是 Python 提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ul>
</li>
<li>  具体哪种标记算法最优是要看场景的，业界有大规模实践中仅保留引用计数算法，以提高吞吐量的尝试。</li>
</ul>
<hr>
<h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2    可达性分析算法"></a>1.2    可达性分析算法</h3><blockquote>
<p>  <strong>可达性分析算法；根搜索算法；追踪性垃圾收集；Tracing_Garbage_Collection</strong></p>
<p>  <strong>引用链；Reference_Chain</strong></p>
</blockquote>
<p>相较于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决循环引用问题</strong>，避免内存泄漏的发生。  当前主流的 JVM 虚拟机采用的垃圾标记算法就是可达性分析算法。</p>
<h4 id="可达性分析算法原理"><a href="#可达性分析算法原理" class="headerlink" title="可达性分析算法原理"></a>可达性分析算法原理</h4><p>可达性分析算法的基本原理就是通过一系列称为“<strong>GC_Roots</strong>”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索所走过的路径称为 <strong>Reference_Chain</strong>，如果某个对象到 GC_Roots 之间没有任何 Reference_Chain 相连，则证明此对象可被回收。</p>
<ul>
<li>  可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上到下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</li>
<li>  使用可达性分析算法后，内存中存活的对象都会被根对象集合直接或间接的引用到，搜索所走过的路径称为 Reference_Chain。</li>
<li>  如果 GC_Roots 到某个对象之间没有任何引用链相连，则称该对象是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。</li>
<li>  在可达性分析算法中，只有能够被根对象集合直接或间接引用的对象才是存活对象。</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623664602146-14c005db-f325-47f4-abef-9342102adccc.png" alt="可达性分析算法.png"></p>
<p>可达性分析算法可以有效解决循环依赖问题，即使存在多个对象之间形成“引用闭环”，但只要它到 GC_Roots 之间没有引用链相连，就可以判断这些对象是不可达对象。</p>
<h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>所谓 “GC_Roots” 集合就是<strong>一组活跃的对象的集合</strong>。固定可作为 GC_Roots 的对象包括以下几种：</p>
<ul>
<li>  虚拟机栈（栈帧中的本地变量表）中引用的对象。比如，各个线程被调用的方法中使用到的参数、局部变量、临时变量等。</li>
<li>  本地方法栈内 JNI（通常说的 Native 方法）引用的对象。</li>
<li>  方法区中类静态属性引用的对象。比如，Java类的引用类型静态变量。</li>
<li>  方法区中常量引用的对象。比如，字符串常量池（String_Pool）里的引用。</li>
<li>  所有被同步锁（synchronized 关键字）持有的对象。【就是锁对象】</li>
<li>  Java 虚拟机内部的引用。如基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError）等，还有系统类加载器。</li>
<li>  反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li>
</ul>
<p>除了这些固定的 GC Roots 集合以外，根据回收的内存区域的不同，还<strong>可以有其它对象“临时性”地加入，共同构成完整的 GC Roots 集合</strong>。比如在分代收集和局部回收（Partial GC）中，如果只是只针对堆中的某一块区域进行垃圾回收（如最典型的只针对新生代的垃圾收集），必须考虑到内存区域不是孤立封闭的，所以某个区域里的对象完全有可能被堆中其它区域的对象所引用，这时就需要将这些关联区域的对象也一并加入到 GC Roots 集合中去，才能保证可达性分析的准确性。</p>
<blockquote>
<p>  <strong>小结</strong></p>
</blockquote>
<p><strong>GC_Roots = 固定可作为 GC_Roots 的对象 + 临时性对象</strong></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>  如果要使用可达性分析算法来标记对象是否存活，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性也就无法保证了。【可达性分析的缺点】</li>
<li>  这也是进行 GC 时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要 STW 的。</li>
</ul>
<hr>
<h3 id="1-3-对象的复活机制（对象的-finalization-机制）"><a href="#1-3-对象的复活机制（对象的-finalization-机制）" class="headerlink" title="1.3    对象的复活机制（对象的 finalization 机制）"></a>1.3    对象的复活机制（对象的 finalization 机制）</h3><h4 id="finalize-方法源码分析"><a href="#finalize-方法源码分析" class="headerlink" title="finalize() 方法源码分析"></a>finalize() 方法源码分析</h4><ul>
<li>  <code>finalize()</code> 方法是 <code>Object</code> 类中的方法，也就是说任何对象都可以调用该方法。</li>
<li>  <code>finalize()</code> 方法没有被 <strong>final</strong> 修饰，也就说可以在其子类（也就是任何类）中重写该方法。</li>
<li>  <code>finalize()</code> 方法虽然不是一个抽象方法，但在 <code>Object</code> 类中并没有对该方法做任何逻辑处理，也就是说该方法默认是一个空的方法。</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623686120808-d854840d-99c8-4d74-ba32-8cabed87d347.png" alt="image.png"></p>
<hr>
<h4 id="虚拟机中对象的三种状态"><a href="#虚拟机中对象的三种状态" class="headerlink" title="虚拟机中对象的三种状态"></a>虚拟机中对象的三种状态</h4><p>由于 <code>finalize()</code> 方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong>。 如果从所有的根节点都无法访问到这个对象，说明该对象已经死亡了，需要在下一 次 GC 时被回收。但事实上，也不一定“非死不可”，这时它暂时处于一个“缓刑”阶段。 <strong>一个可复活的对象有可能在某一条件下“复活”自己</strong> ，如果触发了“复活”机制，那么对它进行回收就是不合理的，为此，虚拟机中定义了对象的三种状态：</p>
<ul>
<li>  <strong>可触及的</strong>：存在根节点可以到达这个对象。</li>
<li>  <strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在 <code>finalize()</code> 方法中复活。</li>
<li>  <strong>不可触及的</strong>：对象的 <code>finalize()</code> 方法已被调用过一次（即已复活过一次），并且对象的引用又一次被全部释放，那么就会进入不可触及状态。<strong>不可触及状态的对象不可能被复活，因为 <code>finalize()</code> 方法只会被调用一次。</strong>（假设某个对象是通过 <code>finalize()</code> 方法复活的，那么该对象就失去了再次复活的机会，因为<code>finalize()</code> 方法只能被调用一次）</li>
</ul>
<p>以上3种状态，是根据 <code>finalize()</code> 方法进行的划分。<strong>只有对象处于不可触及状态时才会被真正地回收</strong>。</p>
<ul>
<li>  Java 语言提供了对象终止机制（finalization）来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。  </li>
<li>  当垃圾回收器发现没有任何引用指向某个对象时（即回收器回收此对象之前），总会先调用这个对象的 <code>finalize()</code> 方法。</li>
<li>  <code>finalize()</code> 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li>
</ul>
<hr>
<h4 id="二次标记过程"><a href="#二次标记过程" class="headerlink" title="二次标记过程"></a>二次标记过程</h4><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时它们暂时处于一个“缓刑”阶段。要真正宣告一个对象死亡，至少要经过两次标记过程。</p>
<ol>
<li> 如果对象 obj 在进行可达性分析后发现没有与 GC_Roots 相连的引用链，那它将会被第一次标记。</li>
<li>随后对被标记的对象再进行一次筛选，判断该对象是否有必要执行 <code>finalize()</code> 方法：<ul>
<li>  如果对象 obj 没有重写 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已经被虚拟机调用过一次，则虚拟机视为“没有必要执行”，obj 被判定为不可触及状态。</li>
<li>如果对象 obj 被判定为有必要执行 <code>finalize()</code> 方法，那么 obj 会被插入到一个名为 <strong>F-Queue</strong> 的队列中，并在稍后由 <strong>Finalizer 线程</strong>去执行队列中所有对象的 <code>finalize()</code> 方法。（JVM 进程在运行时会创建多个线程，finalizer 线程就是一个虚拟机自动创建的、优先级较低的线程）<ul>
<li>  这里说的“执行”是指虚拟机会触发 <code>finalize()</code> 方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的 <code>finalize()</code> 方法执行缓慢，甚至更极端地发生了死循环，将很可能导致 F-Queue 队列中的其它对象永久处于等待状态，甚至导致整个内存回收子系统的崩溃。</li>
</ul>
</li>
</ul>
</li>
<li> <code>finalize()</code> 方法是对象复活的最后机会，稍后垃圾回收器会对 F-Queue 中的对象进行二次标记。如果 obj 在 <code>finalize()</code> 方法中复活成功——即与引用链上的任何一个对象建立了联系（譬如把自己（this 关键字）赋值给某个类变量或者存活对象的成员变量），那么在第二次标记时，obj 会被移出 “即将回收”的集合。如果 obj 没有复活成功，这时候就真的要被回收了。</li>
<li> 之后，如果 obj 对象再次出现成为不可达对象的情况，<code>finalize()</code> 方法不会再次被调用，该对象会直接变成不可触及的状态。也就是说，一个对象的 <code>finalize()</code> 方法只会被调用一次。</li>
</ol>
<h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h4><p>建议开发人员不要主动调用某个对象的 <code>finalize()</code> 方法，应该交给垃圾回收机制调用。理由如下：</p>
<ul>
<li>  在执行 <code>finalize()</code> 方法时可能会导致对象复活，这在某些场景下并不是好事。（<code>finalize()</code> 方法的实现细节都是由开发人员后定义的，如果操作不当就有可能导致对象复活）。</li>
<li>  <code>finalize()</code> 方法是否能得到执行是没有保障的。<code>finalize()</code> 方法是由 finalizer 线程执行的，而 finalizer 线程是一个低优先级线程，并不能保证能马上得到执行的机会，并且 finalizer 线程执行时会依次执行 F-Queue 队列中所有对象的 <code>finalize()</code> 方法，如果在执行某个对象的 <code>finalize()</code> 方法时陷入长时间等待，那么在其之后所有对象的 <code>finalize()</code> 方法都有可能无法被执行。</li>
<li>  一个糟糕的 <code>finalize()</code> 方法会严重影响 GC 的性能。（<code>finalize()</code> 方法的实现细节都是由开发人员后定义的，如果定义的细节不合适就有可能影响 GC 性能，比如在 <code>finalize()</code> 方法中写死循环）</li>
</ul>
<hr>
<h2 id="2-清除阶段"><a href="#2-清除阶段" class="headerlink" title="2  清除阶段"></a>2  清除阶段</h2><p>当成功划分出待回收内存中的存活对象和死亡对象后，接下来的任务就是回收这些已死亡的对象，释放已死亡对象占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在 JVM 中比较常见的三种垃圾清除算法是：</p>
<blockquote>
<ol>
<li> <strong>标记-清除算法（Mark_Sweep）</strong>  </li>
<li> <strong>复制算法（Copying）</strong>  </li>
<li> <strong>标记-压缩算法（Mark_Sweep_Compact）</strong></li>
</ol>
</blockquote>
<h3 id="2-1-标记-清除算法-（Mark-Sweep）"><a href="#2-1-标记-清除算法-（Mark-Sweep）" class="headerlink" title="2.1    标记-清除算法 （Mark-Sweep）"></a>2.1    标记-清除算法 （Mark-Sweep）</h3><p><strong>Mark-Sweep</strong> 是最早出现也是最基础的垃圾回收算法，该算法被 J.McCarthy 等人在 1960 年提出并应用于 Lisp 语言。正如其名字一样，Mark-Sweep 算法分为“标记”和“清除”两个阶段。</p>
<h4 id="Mark-Sweep-执行过程"><a href="#Mark-Sweep-执行过程" class="headerlink" title="Mark-Sweep 执行过程"></a>Mark-Sweep 执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（Stop The World），然后进行两项工作：①标记    ②清除。</p>
<ul>
<li><p><strong>标记</strong>：垃圾收集器从 GC_ROOTS 开始遍历，标记所有需要被回收的对象（不可触及对象）。</p>
<blockquote>
<p>  一般是在对象的对象头（Header）中标记当前对象是否可达。</p>
</blockquote>
</li>
<li><p>  <strong>清除</strong>：在标记完成后，统一回收掉所有被标记的对象。</p>
</li>
</ul>
<p>也可以反过来，标记所有存活的对象，统一回收所有未被标记的对象（如无特殊说明，本文中所有的 Mark-Sweep 算法默认都是标记垃圾对象）。标记过程其实就是对象是否属于垃圾的判定过程。之所以说它是最基础的算法，是因为后续的垃圾收集算法大多都是以 Mark-Sweep 为基础改进而来的。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>  <strong>优点：</strong></p>
</blockquote>
<ul>
<li>  原理简单，实现方便</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong></p>
</blockquote>
<ul>
<li>  <strong>执行效率不稳定</strong>。如果 Java 堆中包含大量对象，且其中大部分对象是需要被回收的，这时候就必须进行大量标记和清除的动作。也就是说，标记和清除两个过程的执行效率都会随着对象数量的增长而降低。</li>
<li>  <strong>存在内存碎片化问题</strong>。使用 Mark-Sweep 算法进行垃圾收回收时会产生大量不连续的内存碎片，会导致接下来程序运行过程中需要分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。而每次进行 GC 的时候，在标记阶段需要停止整个应用程序（STW），频繁地触发 GC 会导致用户体验差。</li>
<li>  并且对于产生的内存碎片，需要额外维护一个空闲列表。</li>
</ul>
<hr>
<h4 id="“垃圾清除”-的本质"><a href="#“垃圾清除”-的本质" class="headerlink" title="“垃圾清除” 的本质"></a>“垃圾清除” 的本质</h4><p>JVM 中的垃圾回收的本质并不是真正意义上的“擦除”。</p>
<p>垃圾对象被回收后，实际上并没有擦除垃圾对象在内存中留下的痕迹，只是不再有指针指向垃圾对象对应的内存空间，并且记载这块内存可用，下次有新对象需要分配内存时，就可以直接让新对象的数据直接覆盖这块内存空间。</p>
<ul>
<li>  如果垃圾清除算法含有内存整理，则会记载一个可用内存地址的<strong>起始地址</strong>，该地址之后的内存均为可用内存。</li>
<li>  如果垃圾清除算法不包含内存整理，则会维护一个<strong>空闲列表</strong>，把所有被清除对象的内存起始地址及所占内存大小保存在这个列表中，下次创建新对象时，先根据空闲列表判断表中是否有足够的空闲内存用于容纳新对象。如果有，就可以直接让新对象的数据直接覆盖这块内存空间。</li>
</ul>
<hr>
<h3 id="2-2-标记-复制算法"><a href="#2-2-标记-复制算法" class="headerlink" title="2.2    标记-复制算法"></a>2.2    标记-复制算法</h3><blockquote>
<p>  <strong>复制算法；Copying</strong></p>
</blockquote>
<p>为了解决 <strong>标记-清除算法</strong> 在垃圾回收效率方面的缺陷（内存碎片化问题），M.L.Minsky 于 1963 年发表了著名的论文，提出了 <strong>复制（Copying）算法</strong>。</p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>复制算法的核心思想就是：它将可用的内存空间分为大小相等两块，每次只使用其中的一块。当这一块的内存用完了（触发垃圾回收），就将还存活着的对象复制到另一块上去，然后再把已使用的内存空间一次清理掉。最后交换两个内存块的角色。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623825679196-d22ee959-c0ba-4ae8-89b6-cc0a426f58a7.png" alt="复制算法.png"></p>
<ol>
<li> 首先，将可用的内存空间平均分成两块较小的内存空间 A 和 B，其中必须有一块内存空间为空。</li>
<li> 从 GC Roots 开始向下遍历，查找所有根节点的可达对象（存活对象）。</li>
<li> <strong>找到存活对象</strong>后，不再需要将其标记为可达对象（标记-清除算法需要标记），而是直接将该对象复制一份到 B 空间中。遍历完 GC Roots 后，内存 A 中所有存活的对象就全部被复制到内存 B 空间中了。而且由于空间 B 初始为空，所以可以将从空间 A 中复制过去的对象按顺序依次紧凑的插入空间 B 中，即空间 B 中所有对象的物理空间是规整的。</li>
<li> 完成上述第 3 步后，直接销毁整个 A 空间。</li>
<li> 交换 A 、B 两块内存区域的角色。此时，新建对象的内存分配在 A 区，进行 GC 发生在 B 区，以此类推，每 GC 一次就交换一次角色。</li>
</ol>
<hr>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>  <strong>优点：</strong></p>
</blockquote>
<ul>
<li>  没有标记和清除的过程，实现简单，运行高效。（发现可达对象直接移动，无需标记）</li>
<li>  复制过去的对象在新的空间中连续的，不会出现内存碎片化的问题。复制算法每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只需要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效。</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong></p>
</blockquote>
<ul>
<li><p><strong>执行效率不稳定</strong>。如果内存中多数的对象都是存活的，这种算法将会产生大量的内存间复制的开销；但是如果内存中多数对象都是的垃圾对象的话，算法需要复制的就只是占很少比例的存活对象。</p>
<p>  <em>如果内存中垃圾对象很少，复制算法的效果就不会很理想，复制算法需要在内存中存活对象数量不太大的情况下才会更高效。在某种极端情况下，遍历 GC Roots 后发现，A 区中所有的对象都是存活对象，也就是说需要把 A 区中所有对象都复制一遍到 B 区中，显然这是没有任何意义的。</em></p>
</li>
<li><p>  <strong>空间利用率低</strong>。复制算法的缺点十分明显，就是牺牲空间换取时间。可用内存直接缩小为了原来的一半。</p>
</li>
</ul>
<hr>
<h4 id="HotSpot-中的应用"><a href="#HotSpot-中的应用" class="headerlink" title="HotSpot 中的应用"></a>HotSpot 中的应用</h4><ul>
<li>  在新生代中，绝大多数对象都是“朝生夕灭”的，IBM 曾有研究表明——新生代中的对象有 98% 熬不过第一轮收集。也就是说存活对象的占比很低，此时使用复制算法的性价比就很高。所以目前主流的 Java 虚拟机大多都是采用了用复制算法来回收新生代。</li>
<li>  在具体的虚拟机中不必一定按照 1：1 的比例来划分新生代的内存空间。</li>
<li>  1989 年，Andrew Appel 针对具备“朝生夕灭”特点的对象，提出了一种更优的<strong>半区复制分代策略</strong>，现在称为“Appel 式回收”。HotSpot 的 Serial、ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局。Appel 式回收的具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor（from） 中存活的对象一次性复制到另外一块 Survivor（to） 空间上，然后直接清理掉 Eden 和 Survivor（from）空间。HotSpot 中默认 Eden 和 Survivor 的比例是 8：1，即每次新生代的可用内存空间为整个新生代空间的 90%，只有一个 Survivor（to）空间，即 10% 的新生代空间是会被浪费的。</li>
<li>当然，98% 的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法保证每次存活的对象不超过 10%，因此 Appel 式回收还设有一个充当罕见情况的“<strong>逃生门</strong>”，当 Survivor（to）空间不足以容纳一次 Minor_GC 后存活的对象时，就需要依赖其他内存区域（实际上大多都是老年代）进行分配担保（Handle Promotion），容纳不下的对象将通过分配担保机制直接进入老年代。</li>
</ul>
<hr>
<h3 id="2-3-标记-压缩算法"><a href="#2-3-标记-压缩算法" class="headerlink" title="2.3    标记-压缩算法"></a>2.3    标记-压缩算法</h3><blockquote>
<p>  <strong>Mark-Compact；标记-压缩算法；标记-整理算法；标记-压缩-清除；Mark-Compact-Sweep</strong></p>
</blockquote>
<ul>
<li>  <strong>复制算法</strong>在对象存活率较高时就需要进行更多的复制操作，效率将会降低。更关键的是，如果不想浪费 50% 的空间，就要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况。所以在老年代一般不会选择这种算法。</li>
<li>  <strong>标记-清除算法</strong>的确可以应用在老年代中，但是该算法的执行效率与堆空间的大小成反比，老年代是 Java 堆中内存最大的一块区域，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者在此基础之上进行了改正，也就产生了——<strong>标记-压缩（Mark-Compact）算法</strong>，或称为 标记-压缩-清除（Mark-Compact-Sweep）算法。</li>
<li>  在许多现代的垃圾回收器中，人们都使用了标记-压缩算法或其改进版本。</li>
</ul>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ol>
<li> <strong>第一阶段：标记</strong>。采用可达性分析算法，从根节点开始向下遍历，标记所有存活对象。</li>
<li> <strong>第二阶段：压缩。</strong>将所有存活的对象压缩到内存的一端，按顺序排放。</li>
<li> <strong>第三阶段：清除。</strong>直接清理掉边界以外的所有内存。</li>
</ol>
<p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的对象所占内存将会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个空闲内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623845046673-e64913aa-22a9-4c90-9ba5-ab7f96c9445f.png" alt="标记-压缩算法.png"></p>
<p>标记-压缩算法的<strong>最终效果</strong>等同于 <code>标记-清除算法</code> 执行完成以后，再进行一次内存碎片整理，因此，也可以把它称为 <strong>标记-压缩-清除（Mark-Compact-Sweep）算法</strong> 。二者的本质差别在于 <code>标记-清除算法</code> 是一种非移动式的回收算法，而 <code>标记-压缩算法</code> 是移动式的。是否移动回收后存活的对象是一项优缺点并存的风险决策。</p>
<ul>
<li>  如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活对象并更新所有的引用这些对象的地方是一项负担很重的操作，而且这种对象移动操作必须暂停用户应用程序才能进行（STW）。</li>
<li>  但如果不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决，比如通过“空闲列表”来解决内存分配问题，但这又会导致无法再继续创建大对象，会提前触发 Full_GC，势必会直接影响程序的吞吐率。</li>
</ul>
<p>基于以上 2 点，是否移动对象都会存在弊端。</p>
<ul>
<li>  移动对象则内存回收时会更复杂，不移动对象则内存分配时会更复杂。</li>
<li>  从用户程序的停顿时间（STW）上来看，不移动对象单次停顿时间会更短，甚至可以不需要停顿。</li>
<li>  从整个程序的吞吐量上来看，移动对象会更划算。（移动对象后触发 GC 的频率会显著降低，整体 GC 的停顿时间之和反而会更少，吞吐量也就更高）</li>
</ul>
<p>还有一种折中的解决办法就是：让虚拟机平时多数时间都采用 <code>标记-清除算法</code>，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用 <code>标记-压缩算法</code> 收集一次，以获得规整的内存空间。HotSpot 中使用过的 <strong>CMS</strong> 收集器面临碎片空间过多时采用的就是这种处理办法。</p>
<hr>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>  <strong>优点：</strong></p>
</blockquote>
<ul>
<li>  消除了<code>标记-清除算法</code>中，内存区域分散的缺点，我们给新对象分配内存时，JVM 只需要持有一个空闲内存的起始地址值即可。</li>
<li>  消除了复制算法中，内存减半的高额代价。</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong> </p>
</blockquote>
<ul>
<li>  从效率上来说，标记-压缩算法要低于复制算法。</li>
<li>  移动对象的同时，如果对象被其它对象引用，则还需调整引用的地址。</li>
<li>  移动过程中，需要全程暂停用户应用程序（STW）。</li>
</ul>
<hr>
<h2 id="3-三种算法对比"><a href="#3-三种算法对比" class="headerlink" title="3    三种算法对比"></a>3    三种算法对比</h2><table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要存活对象的2倍大小</td>
</tr>
<tr>
<td>是否移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li>  效率上来说，复制算法是最快的，但是却浪费了大量的内存。</li>
<li>  而为了尽量兼顾以上三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记阶段，比标记-清除算法多了一个整理内存阶段。</li>
</ul>
<hr>
<h2 id="4-分代收集理论"><a href="#4-分代收集理论" class="headerlink" title="4  分代收集理论"></a>4  分代收集理论</h2><p>分代收集算法并不是一种真正意义上的算法。前面所讲的这些算法中，并没有一种算法可以完全替代其它算法，它们都具有自己独特的优势和特点，因此分代收集算法应运而生。</p>
<p>分代收集理论建立在两个分代收集假说之上：</p>
<ol>
<li> <strong>弱分代假说</strong>：绝大多数对象都是朝生夕灭的。</li>
<li> <strong>强分代假说</strong>：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>这两个分代假说共同奠定了常用垃圾回收器一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象根据其年龄分配到不同的区域中存储。显然，</p>
<ul>
<li>  如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集的话，那么把它们集中放在一起，每次回收<strong>只关注如何保留少量存活对象</strong>而不是去标记那些大量将要被回收的对象，就能以较低的代价回收到大量的空间。[新生代]</li>
<li>  如果某个区域中保存的都是难以消亡的对象，把他们集中放在一块，虚拟机<strong>只需用较低的频率来回收这个区域</strong>，就可以减少垃圾收集的时间开销。[老年代]</li>
</ul>
<p>目前几乎所有的 Java 虚拟机都是基于分代收集（Generational Collecting）理论设计垃圾收集算法的，设计者一般至少会把 Java 堆划分为新生代（Young_Generation）和老年代（Old_Generation）两个区域。根据各个区域对象的特点使用不同的回收算法，可以提高垃圾回收的效率。</p>
<blockquote>
<p>  <strong>新生代（Young_Gen）特点：</strong></p>
<ul>
<li>  内存空间相对于老年代较小</li>
<li>  对象生命周期短，存活率低</li>
<li>  回收频繁</li>
</ul>
</blockquote>
<p>新生代中，使用<strong>复制算法</strong>进行垃圾收集速度是最快的。①复制算法的效率只和当前区域存活对象占用的内存大小有关，存活对象越少效率越高，而新生代对象的存活率低。②复制算法的对内存利用率低，通过 HotSpot 中的两个 Survivor 区的设计可以得到缓解。堆中新生代和老年代的内存占比为 <code>1 : 2</code>，而新生代中 Eden 区、Survivor 区的占比为 <code>8 : 1</code>，就整体堆空间而言，大约只有 1/30 的空间没有得到很好地利用，处于一个可以接受的范围。</p>
<blockquote>
<p>  <strong>老年代（Tenured Gen）特点：</strong></p>
<ul>
<li>  区域较大（相较于新生代）</li>
<li>  对象生命周期长，存活率高</li>
<li>  回收次数不及新生代频繁</li>
</ul>
</blockquote>
<p>老年代中，对象生命周期长且存活率高，复制算法明显不合适。所以该区域一般由 <strong>标记-清除算法</strong> 和 <strong>标记-压缩算法</strong> 的混合实现。</p>
<ul>
<li>  Mark 阶段的开销与存活对象的数量成正比；</li>
<li>  Sweep 阶段的开销与所管理区域的大小成正比。（Sweep 阶段会将要 GC 的区域全部遍历一遍，并清除未被标记对象所占的内存空间）</li>
<li>  Compact 阶段的开销与存活对象的数量成正比。</li>
</ul>
<p>​    在 Java 堆划分出不同的区域后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，因此才有了 “Minor GC”、“Major GC”、“Full GC” 这样的回收类型的划分，也才能够针对不同的区域使用不同的垃圾收集算法。</p>
<p>​    在 Java 程序运行的过程中，会产生大量对象，其中有些对象与业务信息相关，比如 Http 请求中的 Session 对象、线程、Socket 连接对象，这类对象跟业务直接挂钩，生命周期较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象的生命周期会比较短，比如：String 对象，由于其不变类的特性，系统会产生大量的这种对象，有些对象甚至只用一次就会被回收。</p>
<p>​    分代收集并非只是简单划分一下内存区域这么简单，它至少存在一个明显的困难：<strong>对象不是孤立的，对象之间存在跨代引用</strong>。假如现在要进行一次只局限于新生代的收集（Minor GC），但是新生代的对象是完全有可能被老年代引用的，为了找出该区域存活的对象，不得不在固定的 GC_Roots 之外，再额外遍历整个老年代中所有的对象来确保可达性分析的正确性，反过来也是一样（老年代中的对象也有可能被新生代引用）。遍历整个老年代的方案虽然理论上可行，但无疑会给内存回收带来很大的性能负担。为了解决这个问题，就需要对分代理论添加第三条经验法则：</p>
<ol start="3">
<li> <strong>跨代引用假说</strong>：跨代引用相较于同代引用来说仅占极少数。</li>
</ol>
<p>​    依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需<strong>在新生代上建立一个全局的数据结构（该结构被称为“记忆集 ”，Remembered Set）</strong>，这个结构把老年代划分成若干小块，并记录老年代的哪一块内存存在跨代引用。此后，当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC_Roots 中进行扫描（包含跨代引用的小块只是极少数）。虽然这种方法需要在对象改变引用关系时维护记录数据的正确性，会增加一些额外的运行时开销，但是比起收集时扫描整个老年代来说仍然是划算的。</p>
<ul>
<li>  <em>使用记忆集前：收集新生代需要额外扫描整个老年代空间。</em></li>
<li>  <em>使用记忆集后：收集新生代只需扫描老年代空间中的极少数内存块，但是会增加额外维护记忆集的开销。</em></li>
</ul>
<h3 id="分代收集衍生出来的-GC-分类"><a href="#分代收集衍生出来的-GC-分类" class="headerlink" title="分代收集衍生出来的 GC 分类"></a>分代收集衍生出来的 GC 分类</h3><ul>
<li>部分收集（Partial_GC）：指目标不是完整回收整个 Java 堆的垃圾收集，其中又分为：<ul>
<li>  新生代收集（Young_GC / Minor_GC）：指目标只是新生代的垃圾收集。</li>
<li>  老年代收集（Old_GC / Major_GC）：指目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独收集老年代的行为。（Tip：Major_GC 在不同的资料上含义有点混淆，读者需按上下文区分到底是指老年代回收还是整堆收集）</li>
<li>  混合收集（Mixed_GC）：指目标是收集<strong>整个新生代</strong>和<strong>部分老年代</strong>的垃圾收集。目前只有 G1 收集器会有这种行为。</li>
</ul>
</li>
<li>  整堆收集（Full  GC）：回收整个 Java 堆和方法区的垃圾收集。</li>
</ul>
<hr>
<h1 id="垃圾收集相关概念"><a href="#垃圾收集相关概念" class="headerlink" title="垃圾收集相关概念"></a>垃圾收集相关概念</h1><h2 id="1-根节点枚举"><a href="#1-根节点枚举" class="headerlink" title="1    根节点枚举"></a>1    根节点枚举</h2><ul>
<li>  在可达性分析算法中，需要从 GC_Roots 集合开始查找引用链。固定可作为 GC_Roots 对象的主要有全局性的引用（例如常量引用或者类变量引用）与执行上下文（例如栈帧中的本地变量表）中的引用。但是现在的 Java 应用越来越大，若要逐个检查以 GC_ROOTS 为起点的引用必然耗时很长。 </li>
<li>  迄今为止，所有的收集器在执行根节点枚举这一步骤时都是<strong>必须暂停用户线程</strong>的（STW）。虽然现在可达性分中析耗时最长的查找引用链的过程已经可以做到和用户线程一起并发执行，但是根节点枚举还是<strong>必须在一个能保障一致性的快照中才能得以进行</strong>，若这点不能满足的话，分析的准确性也就不发保证。这也是垃圾收集过程必须停顿用户线程的一个重要原因。</li>
<li>  目前主流的 Java 虚拟机使用的都是准确式垃圾收集，意思就是当用户线程停下来以后，并不需要遍历检查所有的执行上下文引用和全局引用所在的区域，而是让每个区域维护一张 Map 类型的数据结构，通过这张表虚拟机就可以直接得到在该区域中哪些地方存放着对象引用的。在 HotSpot 中，是使用一组 OopMap 的数据结构来达到这个目的，这样收集器直接扫描 OopMap 就可以得到 GC_Roots 中包含的对象信息了，并不需要从方法区或者局部变量表中去挨个查找。</li>
</ul>
<hr>
<h2 id="2-安全点与安全区域"><a href="#2-安全点与安全区域" class="headerlink" title="2    安全点与安全区域"></a>2    安全点与安全区域</h2><h3 id="2-1-安全点（SafePoint）"><a href="#2-1-安全点（SafePoint）" class="headerlink" title="2.1    安全点（SafePoint）"></a>2.1    安全点（SafePoint）</h3><p>程序在执行时并非在代码指令流的任何位置都能够停下来开始垃圾收集，而是强制要求用户线程必须执行到特定位置后停顿下来，垃圾收集线程才能进行 GC，这些位置称为“安全点（Safepoint）”。</p>
<p>Safe_Point 的选择很重要，<strong>如果太稀疏可能导致垃圾收集线程等待的时间太长，如果太密集可能导致程序的吞吐量降低</strong>。</p>
<ul>
<li>  安全点间隔过远，两个安全点间用户线程执行的时间段就会较长（垃圾收集线程从开始等待到执行的时间段就会相对变长），必然导致会出现更多的垃圾对象，垃圾收集时单次停顿时间（STW）就会变长。</li>
<li>  安全点间隔过近，安全点太多就会导致垃圾收集的频率上升，并且每次垃圾收集都会发生 STW，导致程序频繁停顿，整体吞吐量降低。</li>
</ul>
<p>安全点位置的选取通常是根据<em>“是否具有让程序长时间执行的特征”</em>为标准进行选定的。因为大部分指令的执行时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，选择执行时间较长的指令作为 SafePoint 是比较合适的。比如，方法调用、循环跳转和异常跳转等。【保证了长指令流可以在一次两个安全点之间一次性执行完毕】</p>
<p>对于安全点，另一个需要考虑的问题就是：<strong>在发生垃圾收集时，如何保证所有的用户线程都跑到下一个最近的安全点停顿下来呢？</strong> </p>
<blockquote>
<ol>
<li> <strong>抢先式中断：（目前没有虚拟机采用了）</strong> </li>
</ol>
</blockquote>
<p>在发生垃圾收集前，系统要中断所有用户线程。首先第一次中断用户线程，如果用户线程正好停在了安全点上，则中断用户线程。如果用户线程中断的地方不在安全点上，就恢复这些线程，让它们一会儿再重新中断，反复多次，直到所有的用户线程都停在安全点上。 </p>
<blockquote>
<ol start="2">
<li> <strong>主动式中断</strong>（标志位中断）</li>
</ol>
</blockquote>
<p>当发生垃圾收集前，需要中断用户线程的时候，不直接对用户线程进行操作，仅仅简单设置一个（中断）标志位，各个线程执行过程中不停地主动轮询这个标志，一旦发现中断标志为 true 时就将自己停在下一个最近的安全点上。轮询标志和安全点是重合的。</p>
<hr>
<h3 id="2-2-安全区域（SafeRegion）"><a href="#2-2-安全区域（SafeRegion）" class="headerlink" title="2.2    安全区域（SafeRegion）"></a>2.2    安全区域（SafeRegion）</h3><p>SafePoint 机制保证了<strong>程序执行时</strong>，用户线程在不太长的时间内就可以到达安全点并停顿。但是，<strong>程序“不执行”</strong>的时候呢？例如用户线程处于 Sleep 状态或者 Blocked 状态，这时候用户线程是不会向前执行的，也就无法响应虚拟机的中断请求，无法执行到安全点去挂起自己，虚拟机也显然也不可能等待用户线程被唤醒后再走到最近的安全点将自己挂起（因为用户线程 Sleep 或 Blocked 的时间无法确定）。对于这种情况，就需要引入安全区域（SafeRegion）来解决。</p>
<p><strong>安全区域是指能够确保在某一段代码片段中，对象的引用关系不会发生变化</strong>。因此在这个区域中的任何位置开始 GC 都是安全的。我们可以把 SafeRegion 看作是被拉伸了的 SafePoint 。</p>
<ol>
<li> 当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，如果这段时间内发生 GC，就不必处理这些已经位于安全区域内的线程了（虚拟机会忽略标识为 SafeRegion 状态的线程）（但是没有进入安全区域的线程还是要做额外处理）。</li>
<li> 当用户线程即将离开安全区域时，会先检查虚拟机是否已经完成根节点枚举（或者是垃圾收集过程中其它需要暂停用户线程的阶段），如果完成了，则用户线程继续执行；否则用户线程必须继续等待，直到收到可以离开 SafeRegion 的信号为止。</li>
</ol>
<hr>
<h2 id="3-记忆集与卡表"><a href="#3-记忆集与卡表" class="headerlink" title="3    记忆集与卡表"></a>3    记忆集与卡表</h2><p>讲解分代收集理论的时候，提到了为了解决对象跨代引用所带来的的问题，垃圾收集器在新生代中建立了名为<strong>记忆集（Remembered Set）</strong>的数据结构，用于避免把整个老年代加入 GC_Roots 的扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的垃圾收集器（典型的如 G1、ZGC 和 Shenandoah）都会面临相同的问题。</p>
<p>记忆集用于<strong>记录从非收集区域指向收集区域的对象的地址的集合</strong>，是一种抽象的数据结构。</p>
<p>如果不考虑效率和成本的话，最简单的实现方式可以用非收集区域中所有包含跨代引用的对象数组来实现这个数据结构。但是这种记录全部含跨代引用的对象的实现方案，无论是内存占用还是维护成本都相当高。而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针就可以了。那么设计者在实现记忆集的时候，就可以选择更为粗粒度的记录来节省记忆集的存储和维护成本。常见的有：</p>
<ul>
<li>  <strong>字节精度</strong>：每个记录精确到一个机器字长，该字长的位置上包含跨代指针。</li>
<li>  <strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li>  <strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>采用“卡精度”实现的记忆集列表被称为“<strong>卡表（Card_Table）</strong>”，这是目前最常用的一种记忆集实现形式（HotSpot 也采用了这种形式），一些资料中甚至直接把它和记忆集混为一谈。其实<strong>记忆集是一种“抽象”的数据结构，而卡表则是记忆集的一种落地实现</strong>，它定义了记忆集的记录精度。</p>
<p>卡表最简单的形式可以只是一个字节数组（数组中的每个元素只能是 0 或 1，默认为 0），而 HotSpot 也确实是这样做的。字节数组 CARD_TABLE 的每一个元素都对应着内存区域中一块特定大小的内存块，这个内存块被称为“<strong>卡页（Card_Page）</strong>”。一个卡页的内存中通常包含不只一个对象，只要卡页内有一个（或更多）对象的字段存在跨代指针，那么就将卡表的数组元素的值标识为 1，称这个卡页变脏（Dirty），没有则标识为 0。在发生垃圾收集时，只要筛选出卡表中变脏的卡页，就能轻易得出哪些内存区域包含跨代指针，把它们加入 GC_Roots 中一并扫描。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/%E8%AE%B0%E5%BF%86%E9%9B%86_%E5%8D%A1%E8%A1%A8.png" alt="记忆集_卡表"></p>
<p>一般来说，卡页的大小都是以 2^N^ 字节数，HotSpot 中使用的卡页大小是 2^9^ ，即 512 字节。</p>
<ul>
<li><p>如果卡表标识的内存区域的起始地址是 <code>0x0000</code> 的话，数组 Card_Table 的第0、1、2 号元素，分别对应了地址范围为 <code>0x0000~0x01FF</code>、<code>0x0200~0x03FF</code>、<code>0x0400~0x05FF</code> 的卡页内存块。</p>
<p>  <em>卡表只需知道：1、对应卡页的起始位置地址。   2、每个卡页的大小。  就可以推算出整个卡表中每个元素代表的内存块范围了。</em></p>
</li>
<li><p>  如果卡页中存在一个或多个对象存在跨代引用的话，就将该卡页对应的卡表元素标识为 1。</p>
</li>
<li><p>  在发生垃圾收集时，只需要遍历一遍卡表，就可以得到哪些内存块中含有跨代引用的对象，直接扫描对应的内存块即可，而不用遍历整个老年代空间。</p>
</li>
</ul>
<hr>
<h2 id="4-写屏障"><a href="#4-写屏障" class="headerlink" title="4    写屏障"></a>4    写屏障</h2><p>我们已经解决了如何使用记忆集来缩小 GC_Roots 扫描范围的问题。但还没有解决卡表如何维护的问题。即卡页何时变脏、谁来把它们变脏等。</p>
<p><strong>卡页何时变脏</strong>的答案是很明确的——有非收集区域中的对象引用了待收集区域的对象时，非收集区域对应的卡表元素就应该变脏，变脏的时间点原则上应该发生在引用类型赋值的那一刻。但如何在引用类型赋值的那一刻去更新维护卡表呢？ 假如是解释执行的字节码，还相对好处理，虚拟机负责每条字节码指令的执行，有充分的介入空间；但是在编译执行的场景中，经过即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作中。</p>
<p>在 HotSpot 中是通过<strong>写屏障（Write_Barrier）</strong>技术来维护卡表状态的。写屏障可以看做在虚拟机层面对“引用类型字段赋值”这个动作的 AOP 切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作。也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的写屏障叫做<strong>写前屏障（Pre_Write_Barrier）</strong>，在赋值后的写屏障叫做<strong>写后屏障（Post_Write_Barrier）</strong>。HotSpot 虚拟机的很多收集器都用到了写屏障。</p>
<p>应用了写屏障后，虚拟机就会为所有赋值操作生成响应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与 Minor GC 时扫描整个老年代的代价相比还是低得多的。</p>
<hr>
<h2 id="5-并发条件下的可达性分析"><a href="#5-并发条件下的可达性分析" class="headerlink" title="5    并发条件下的可达性分析"></a>5    并发条件下的可达性分析</h2><blockquote>
<p>  <strong>为什么要有并发条件下的可达性分析？</strong></p>
</blockquote>
<ol>
<li> 目前主流的垃圾收集器都采用了可达性分析算法。</li>
<li> 可达性分析过程要求虚拟机处于一个能保持一致性的快照中，即需要暂停所有的用户线程。</li>
<li> 如果垃圾回收的时间很长，那么 STW 的时间就很长，影响用户体验。</li>
<li> 为了缩短停顿时间，就研究出了垃圾回收线程中的可达性标记过程和用户线程并发执行。</li>
<li> 并发条件下的可达性分析算法包括<strong>增量收集算法</strong>和<strong>原始快照算法</strong>两种方式。</li>
</ol>
<h3 id="5-1-基本思想"><a href="#5-1-基本思想" class="headerlink" title="5.1    基本思想"></a>5.1    基本思想</h3><p>如果一次性将所有的垃圾进行处理，就可能会造成系统长时间的停顿，这种情况下，可以考虑让垃圾回收线程和应用程序线程交替执行。 <strong>垃圾回收线程每次只回收一小片区域的内存空间，接着切换到应用程序线程。以此类推，多次重复直到垃圾收集完成</strong> 。</p>
<h3 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2    缺点"></a>5.2    缺点</h3><p>使用这种方式，由于在垃圾回收过程中，间断性的还执行了应用程序代码，所以能减少系统停顿的时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p>
<h3 id="5-3-流程分析"><a href="#5-3-流程分析" class="headerlink" title="5.3    流程分析"></a>5.3    流程分析</h3><p>当前主流的垃圾收集器大多都是依靠可达性分析算法来判定对象是否存活的。可达性分析算法理论上要求在枚举可达对象的整个过程都要基于一个能保障一致性的快照中才能够进行分析，这就意味着分析过程中必须暂停所有的用户线程。在根节点枚举这一步骤中，由于 GC_Roots 相较于整个 Java 堆中的全部对象毕竟还算极少数，且在各种优化技巧（如 OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从 GC_Roots 再继续向下遍历对象图，这一步骤的停顿时间就必定会与 Java 堆容量成正比了：堆越大，存储的对象越多，对象图结构越复杂，要标记的对象更多，停顿的时间自然也就更长了。</p>
<p>包含“标记”阶段是所有追踪式垃圾回收算法的共同特征，如果这个阶段会随着堆变大而增加停顿时间的话，其影响将会波及几乎所有的垃圾收集器。同理，如果能够削减这部分的停顿时间的话，那收益也将会是系统性的。</p>
<p>想要解决或者降低用户线程的停顿，首先要搞清楚<strong>为什么必须要在一个能保障一致性的快照中才能进行对象图的遍历？</strong>为了能解释清这个问题，我们引入三色标记作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色。</p>
<ul>
<li>  白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li>  黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其它对象引用指向了黑色对象，无需重新扫描一遍。黑色对象不可能直接（不经过黑色对象）指向某个白色对象。</li>
<li>  灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。（扫描了，但没扫描完）</li>
</ul>
<p>关于可达性分析的扫描过程，可以想象成对象图上一股以黑色为波峰的波纹从黑向白推进的过程，如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。但如果用户线程与收集器线程并发工作，就会出现收集器线程在对象图上标记颜色，同时用户线程在修改引用关系。这样可能出现两种后果：一种是把原本要死亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的<strong>浮动垃圾</strong>而已，下次收集清理掉即可。另一种情况是把原本存活的对象错误标记为死亡，这就是非常致命的错误了，程序肯定会因此发生错误，甚至崩溃 。</p>
<blockquote>
<p>  并发出现“对象消失”问题的示意图</p>
</blockquote>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="并发的可达性分析"></p>
<p>经证明，当且仅当以下两个条件<strong>同时</strong>满足时，会产生“对象消失”的问题。即原本应该是黑色的对象被误标为白色。</p>
<ul>
<li><p><strong>（用户线程）赋值器插入了一条或多条从黑色对象到白色对象的新引用</strong>。</p>
<p>  <em>由于用户线程和垃圾收集线程是并发执行的，所以存在这样一种情况，垃圾回收线程扫描过程中，已经被标记为黑色的对象被用户线程使用，并且新增了一条或多条引用指向白色对象，但是在标记阶段结束后，黑色对象不会再被重新扫描一遍，也就是说，这些新增的白色对象，如果只被该黑色对象引用，那么它仍然会是一个白色对象，而实际上这些新增的对象应该是黑色对象。</em></p>
</li>
<li><p><strong>（用户线程）赋值器删除了全部从灰色对象到该白色对象的直接引用或间接引用</strong>。</p>
<p>  <em>由于用户线程和垃圾收集线程是并发执行的，所以存在这样一种情况，垃圾回收器线程访问到某个对象，先将该对象从白色变为灰色，接下来要扫描该灰色对象所关联的其它所有对象，但是此时程序切换到用户线程去执行了，用户线程删除了该灰色对象关联的某个白色对象（并且该白色对象只被该灰色对象引用），那么标记结束后，该白色对象就不会被标记成黑色对象，但是该对象理论上在收集开始时的快照中是应该作为一个黑色对象的。</em></p>
</li>
</ul>
<p>因此，我们要解决并发扫描时的对象消失问题，只需要破坏这两个条件中的任意一个即可。由此分别产生了两种解决方案：<strong>①增量更新（Incremental Update）    ②原始快照（Snapshot At The Beginning，SATB）</strong></p>
<blockquote>
<p>  <strong>增量更新</strong></p>
</blockquote>
<p><strong>增量更新</strong>是要破坏第一个条件，当黑色对象插入指向白色对象的新的引用关系时，就将这个新引用关系记录下来，等并发扫描结束后 ，再以这些记录过引用关系的黑色对象为根，重新扫描。简言之就是，黑色对象一旦新插入了指向白色对象的引用后，它就重新变为灰色对象了。</p>
<blockquote>
<p>  <strong>原始快照</strong></p>
</blockquote>
<p><strong>原始快照</strong>要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再以这些记录过的引用关系的灰色对象为根，按照记录下来的引用关系再重新扫描一次。简言之就是，无论引用关系删除与否，都会按照刚开始扫描那一刻的对象图快照来进行搜索 。    </p>
<p>以上无论是对引用关系的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在 HotSpot 中，增量更新和原始快照这两种解决方案都有实际的应用，譬如，CMS 是基于增量更新来做并发标记的，G1、Shenandoah 则是用原始快照来实现。</p>
<hr>
<h2 id="6-分区算法"><a href="#6-分区算法" class="headerlink" title="6    分区算法"></a>6    分区算法</h2><p>分区算法的目的和并发条件下的可达性分析算法目的相同，都是<strong>为了更好的控制用户线程 STW 的时间</strong>。</p>
<p>一般来说，堆空间越大，堆中对象越多，垃圾对象也就越多，单次回收垃圾所需的时间就越长，用户线程单次停顿的时间也就越长。为了更好的控制内存回收产生的停顿时间，分区算法采用将一块大的内存区域分割成多个小块，根据预设定的目标停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而达到减少用户线程单次停顿时间的目的。</p>
<p><strong>分代算法是按照对象生命周期的长短将堆划分成两个部分，分区算法是将整个堆空间划分成多个不同的小区间（region）</strong>。</p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<hr>
<h2 id="7-System-gc-的理解"><a href="#7-System-gc-的理解" class="headerlink" title="7    System.gc() 的理解"></a>7    System.gc() 的理解</h2><blockquote>
<p>  <strong>源码：<code>System.gc()</code></strong></p>
</blockquote>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623921665668-70b6c909-16f7-4eed-be86-9eeb22c86b3f.png" alt="image.png"></p>
<ul>
<li><p>  默认情况下，调用 <code>System.gc()</code> 或者 <code>Runtime.getRuntime().gc()</code> 方法， <strong>会显式地触发 Full GC</strong> ，对整个堆和方法区进行回收，尝试释放失效对象占用的内存空间。</p>
</li>
<li><p>  然而调用 <code>System.gc()</code> 方法时会附带一个免责声明，即无法保证垃圾回收器能即时被调用。</p>
</li>
<li><p>  <code>System.gc()</code> 方法仅仅是通知虚拟机，希望调用一次 GC ，但是由于具体调用 GC 涉及到垃圾收集线程，只有等到垃圾收集线程执行时，才会真正的去执行 GC 。</p>
</li>
<li><p>  开发人员可以通过调用 <code>System.gc()</code> 方法来决定 JVM 的 GC 行为。而<strong>一般情况下，垃圾回收应该是自动进行的，无需手动触发</strong>。</p>
</li>
</ul>
<blockquote>
<p>  <strong>显式 GC 与 JVM 自动 GC 的区别</strong></p>
</blockquote>
<ul>
<li>  由于垃圾收集线程的优先级要远低于用户线程的优先级，所以在 JVM 自动 GC 的情况下，一般只会在某个区域内存不足（达到设定的阈值）时才会由垃圾收集线程调用垃圾收集器尝试释放已死亡对象占用的内存。 </li>
<li>  也就是说，在应用程序运行的很长一段时间内，即使垃圾收集线程轮询了到 CPU 资源，但是由于堆空间未达到 GC 的标准，垃圾回收线程也不会去执行 GC 过程，而是让出 CPU 资源给优先级更高的线程。</li>
<li>  而手动调用 <code>System.gc()</code> 方法之后，只要下一次垃圾收集线程轮询到了 CPU 资源，那么不管堆空间有没有达到 GC 的标准，就会直接去执行 GC 行为回收堆中已死亡的对象。  </li>
</ul>
<hr>
<h2 id="8-内存溢出与内存泄漏"><a href="#8-内存溢出与内存泄漏" class="headerlink" title="8    内存溢出与内存泄漏"></a>8    内存溢出与内存泄漏</h2><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><ul>
<li>  JavaDoc 中对于 OutOfMemory 的解释是：<strong>①没有空闲的内存空间    ②并且通过垃圾回收后也无法提供更多内存</strong></li>
<li>  内存溢出是相对于内存泄漏来讲的。</li>
<li>  由于 GC 一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收跟不上内存消耗的速度，否则不太容易出现 OOM 的情况。</li>
<li>  大多数情况下，GC 会分别进行各种年龄段的垃圾回收，某些情况下甚至会进行一次独占式的 Full GC 操作，这时会释放大量的内存，供应用程序继续使用。</li>
</ul>
<blockquote>
<ol>
<li> <strong>没有空闲的内存空间</strong></li>
</ol>
</blockquote>
<p>首先说没有空闲内存的情况，说明 Java 虚拟机的堆内存不够。原因有二：</p>
<ol>
<li><p>Java 虚拟机的堆内存设置不够。</p>
<p> 比如：可能存在内存泄漏问题；也有可能就是堆的大小不合理，比如我们要处理比较大的数据量，没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数 <code>-Xms</code> 、 <code>-Xmx</code> 来调整。</p>
</li>
<li><p> 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p>
</li>
</ol>
<p>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemory 也非常常见，尤其是在运行时存在大量动态类型生成的场合；类似于 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息。会标记出来和永久代相关： <strong>java.lamg.OutOfMemoryError: PermGen space</strong> </p>
<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改变，出现 OOM，异常信息则变成了：<strong>java.lamg.OutOfMemoryError: Metaspace 。</strong>直接内存不足，也会导致 OOM。</p>
<blockquote>
<ol start="2">
<li> <strong>并且通过垃圾回收后也无法提供更多内存</strong></li>
</ol>
</blockquote>
<ul>
<li>  意思是说，在抛出 OOM 之前，通常垃圾回收器会被触发。尽其所能去清理出空间。</li>
<li>  例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。</li>
<li>  当然，也不是在任何情况下垃圾回收器都会被触发的。比如，我们去分配一个超大的对象，例如分配一个超大数组超过堆的最大值，JVM 可以判断出垃圾回收并不能解决这个问题，所以直接抛出 OOM。</li>
</ul>
<h3 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h3><ul>
<li>  Memory_Leak 也称作“存储渗漏”。严格来说， <strong>只有对象不会再被程序用到了，但是 GC 又无法回收它们的情况，才叫做内存泄漏</strong> 。但是实际上很多时候由于一些不太好的实现或疏忽会导致<strong>一些对象的生命周期变得很长甚至 OOM，也可以叫做宽泛意义上的“内存泄漏”</strong>。 </li>
<li>  尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory 异常，导致程序崩溃。（内存泄漏最终还是会导致内存溢出），</li>
</ul>
<p>Tip：这里的存储空间并不是指物理内存，而是值虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<h4 id="Java-中内存泄漏举例"><a href="#Java-中内存泄漏举例" class="headerlink" title="Java 中内存泄漏举例"></a>Java 中内存泄漏举例</h4><blockquote>
<ol>
<li> <strong>单例模式</strong> </li>
</ol>
</blockquote>
<p>单例对象的生命周期是非常长的，一旦被创建了之后就不会被自动回收。在含有单例对象的应用程序中，如果一个单例对象持有某个外部对象的引用的话，因为单例对象在程序运行时一定不会被回收，那么与之相连的外部对象自然也不会被回收的，但是这个外部对象可能并不是在整个程序运行过程中都需要使用，这时候我们就称发生了内存泄漏。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623936681185-27ef20bd-43f6-47d0-a355-ee40952eee7f.png" alt="内存泄漏.png"></p>
<blockquote>
<ol start="2">
<li> <strong>一些提供 close() 方法的资源未关闭导致内存泄漏</strong></li>
</ol>
</blockquote>
<p>一些提供了 <code>close()</code> 方法的资源<strong>如果不主动调用 close() 方法的话，JVM 是不会去自动回收这些对象的</strong>，这中情况也会造成内存泄漏。如：数据库连接（ <code>dataSource.getConnection()</code> ）、网络连接（ <code>socket</code>）和 IO 连接等，必须手动调用 <code>cloes()</code> 方法，否则是不会被回收的。</p>
<hr>
<h2 id="9-Stop-The-World"><a href="#9-Stop-The-World" class="headerlink" title="9    Stop The World"></a>9    Stop The World</h2><blockquote>
<p>  <strong>什么是 STW ？</strong></p>
</blockquote>
<p>Stop The World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。 <strong>停顿产生时整个应用程序的用户线程都会被暂停，没有任何响应</strong>，这个停顿被称为 STW。 </p>
<blockquote>
<p>  <strong>STW 发生在什么时候？</strong></p>
</blockquote>
<p><strong>可达性分析算法中枚举根节点（GC Roots）会导致所有用户线程停顿。</strong></p>
<ul>
<li>  分析工作必须在一个能确保一致性的快照中进行。</li>
<li>  一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上。</li>
<li>  如果出现分析过程中对象的引用关系还在不断变化，则分析结果的准确性无法得到保证。</li>
</ul>
<p>被 STW 中断的应用程序会在完成 GC 之后恢复运行，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p>
<blockquote>
<p>  <strong>注意</strong></p>
</blockquote>
<ul>
<li>  STW  事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</li>
<li>  哪怕是 G1 也不能完全避免 STW 情况的发生，只能说垃圾回收器越优秀，回收效率越高，尽可能地缩短了暂停时间。</li>
<li>  <strong>STW 是 JVM 在后台自动发起和自动完成的</strong>。在用户不可见的情况下，把用户的正常线程全部停掉。</li>
<li>  开发中不建议使用 <code>System.gc()</code> 方法，因为这会导致 Stop-the-World 的发生。</li>
</ul>
<hr>
<h2 id="10-垃圾回收的并行与并发"><a href="#10-垃圾回收的并行与并发" class="headerlink" title="10    垃圾回收的并行与并发"></a>10    垃圾回收的并行与并发</h2><h3 id="10-1-操作系统的并行与并发"><a href="#10-1-操作系统的并行与并发" class="headerlink" title="10.1    操作系统的并行与并发"></a>10.1    操作系统的并行与并发</h3><blockquote>
<p>  <strong>并发（Concurrent）</strong></p>
</blockquote>
<ul>
<li>  一个 CPU 同时执行多个 <code>线程/进程</code>。</li>
<li>  并发并不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段，然后在这几个时间片段之间来回切换，由于 CPU 处理速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序在同时进行。</li>
</ul>
<blockquote>
<p>  <strong>并行（Parallel）</strong></p>
</blockquote>
<ul>
<li>  多个 CPU 同时执行多个<code>线程/进程</code>，两个<code>线程/进程</code>之间互不抢占 CPU 资源。</li>
<li>  决定并行的因素并不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</li>
</ul>
<h3 id="10-2-垃圾回收的并行与并发"><a href="#10-2-垃圾回收的并行与并发" class="headerlink" title="10.2    垃圾回收的并行与并发"></a>10.2    垃圾回收的并行与并发</h3><p>并行与并发，在垃圾回收器的上下文语境中，可以理解为：</p>
<blockquote>
<p>  <strong>并行（Parallel）：</strong></p>
</blockquote>
<ul>
<li>  并行描述的是多条垃圾收集线程之间的关系，指同一时间有多条垃圾收集线程在协同工作。通常默认此时用户线程处于等待状态。 </li>
<li>  如 ParNew、Parallel Scavenge、Parallel Old</li>
</ul>
<blockquote>
<p>  <strong>串行（Serial）：</strong></p>
</blockquote>
<ul>
<li>  相较于并行的概念，指同一时间只有一个垃圾收集线程工作，且用户线程处于等待状态。</li>
<li>  如果内存不够，则程序暂停，启动 JVM 垃圾收集器线程进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
<blockquote>
<p>  <strong>并发（Concurrent）：</strong></p>
</blockquote>
<ul>
<li>  并发描述的是<strong>垃圾收集线程与用户线程之间的关系</strong>，指同一时间垃圾收集线程和用户线程都在运行（但不一定是并行的，可能会交替执行）。</li>
<li>  由于用户线程并未被冻结，所以程序此时仍能响应服务请求，但由于垃圾收集线程占用了一部分系统资源，此时应用线程处理的吞吐量将受到一定的影响。 </li>
<li>  如 CMS、G1 </li>
</ul>
<hr>
<h2 id="11-引用分类"><a href="#11-引用分类" class="headerlink" title="11    引用分类"></a>11    引用分类</h2><blockquote>
<ul>
<li>  强引用</li>
<li>  软引用</li>
<li>  弱引用</li>
<li>  虚引用</li>
<li>  终结器引用</li>
</ul>
</blockquote>
<blockquote>
<p>  <strong>面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</strong></p>
</blockquote>
<p>在 JDK1.2 之前，Java 里面的引用是很传统的定义：如果 <code>reference</code> 类型的数据中存储的数值代表的是另一块内存的起始地址，就称该 <code>reference</code> 数据是代表某个内存、某个对象的引用。</p>
<p>但是，我们还希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存在进行<strong>垃圾回收后</strong>还是很紧张，则可以抛弃这些对象。（类似于缓存）</p>
<p>在 JDK1.2 之后，Java 对引用的概念进行了扩充，将引用分为 <code>强引用（Strong Reference）&gt; 软引用（Soft Reference）&gt; 弱引用（Weak Reference）&gt; 虚引用（Phantom Reference）</code> 4 种，这 4 种引用强度依次逐渐减弱。（强软弱虚）</p>
<ul>
<li>  <strong>强引用（StrongReference）</strong>：最传统的引用的定义，在程序代码之中普遍存在的引用赋值，即类似于“<code>Object obj = new Object()</code>”这种引用关系<strong>。无论任何情况下，只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象。</strong></li>
<li>  <strong>软引用（SoftReference）</strong>：软引用用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行二次回收（即使这些对象的软引用关系还存在）。如果这次回收后还没有足够的内存，才会抛出 OOM 异常。</li>
<li>  <strong>弱引用（WeakReference）</strong>：只被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li>  <strong>虚引用（PhantomReference）</strong>：一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过这个虚引用获得到一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾回收器回收时收到一个系统通知。</li>
</ul>
<p>除了强引用外，其它 3 种引用均可在 <code>java.lang.ref</code> 包下找到。如下图，开发人员可以直接在应用程序中使用它们。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1623993190508-8050a81c-0648-4d05-98a0-b95da344d942.png" alt="image.png"></p>
<p>Reference 子类中只有 <code>FinalReference(终结器引用)</code> 是包内可见的（使用默认空修饰符，只能在当前包下使用），其它 3 种引用类型均为 public ，可以在应用程序中直接使用。</p>
<h3 id="1、强引用（Strong-Reference）——不回收"><a href="#1、强引用（Strong-Reference）——不回收" class="headerlink" title="1、强引用（Strong Reference）——不回收"></a>1、强引用（Strong Reference）——不回收</h3><ul>
<li>  在 Java 程序中，最常见的引用就是强引用，也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。当在 Java 语言中使用 new 关键字创建一个新的对象，并将其赋值给一个变量的时候，这个变量就称为指向该对象的一个强引用。</li>
<li>  强引用的对象是可触及的（可达的），垃圾回收器永远不会回收被强引用关联的对象。</li>
<li>  对于一个普通的对象而言，如果没有其它的引用关系，只要超过了强引用的作用域或者显式地将相应的强引用赋值为 null，就可以将该对象当做垃圾回收了，当然具体的回收时机还是要看垃圾回收的策略。</li>
<li>  相对的，软引用、弱引用和虚引用关联的对象分别是软可触及、弱可触及、虚可触及的，在一定条件下，这些引用关联的对象都是可以被回收的（而强引用关联的对象则在强引用未失效之前是绝对不可以回收的）。所以，<strong>强引用是造成 Java 内存泄漏的主要原因之一</strong>。</li>
</ul>
<p><strong>强引用特点</strong></p>
<ul>
<li>  强引用可以直接访问目标对象</li>
<li>  强引用所关联的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向的对象。</li>
<li>  强引用可能会导致内存泄漏。</li>
</ul>
<hr>
<h3 id="2、软引用（Soft-Reference）——内存不足时回收"><a href="#2、软引用（Soft-Reference）——内存不足时回收" class="headerlink" title="2、软引用（Soft Reference）——内存不足时回收"></a>2、软引用（Soft Reference）——内存不足时回收</h3><ul>
<li>  软引用是用来描述一些还有用，但非必需的对象。</li>
<li>  <strong>只被软引用关联的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围进行二次回收，如果这次回收还没有得到足够的内存，才会抛出 OOM 异常</strong>。</li>
<li>  软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用，如果还有空闲内存，就可以暂时保留缓存数据，当内存不足时，就清理掉缓存数据，这样就保证了使用缓存的同时，不会耗尽内存。</li>
<li>  垃圾回收器在某个时刻决定回收软可触及对象的时候，会清理软引用，并可选的把软引用放到一个引用队列（Reference Queue），通过这个队列可以追踪到对象的回收情况。</li>
<li>  软引用类似于弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。（当内存足够时，不会回收软引用对象，当内存不足时，才会回收软引用对象）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建 obj 对象，用强引用关联</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line"><span class="comment">// 2、创建一个软引用，并关联到 obj 对象</span></span><br><span class="line">SoftReference&lt;Object&gt; sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);    </span><br><span class="line"><span class="comment">/* 此时，强引用 和 软引用 同时关联到 obj 对象 */</span></span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 销毁强引用</span></span><br><span class="line"><span class="comment">/* 此时，就只剩软引用指向 obj 对象了 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价方式----------------------------------------</span></span><br><span class="line">SoftReference&lt;Object&gt; sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="3、弱引用（Weak-Reference）——发现即回收"><a href="#3、弱引用（Weak-Reference）——发现即回收" class="headerlink" title="3、弱引用（Weak Reference）——发现即回收"></a>3、弱引用（Weak Reference）——发现即回收</h3><ul>
<li>  弱引用也是用来描述那些非必需的对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集为止</strong>。在系统 GC 时，只要发现弱引用，不管系统堆空间是否充足，都会回收掉只被弱引用关联的对象。</li>
<li>  但是，由于垃圾回收线程的优先级很低，因此，并不一定能很快的发现只持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li>
<li>  弱引用和软引用一样，在构造弱引用时，也可以指定一个弱引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以追踪到对象的回收情况。</li>
<li>  软引用、弱引用都适合用来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以保留较长的时间，从而起到加速系统的作用。</li>
</ul>
<p>在 JDK1.2 之后，Java 提供了 <code>java.lang.ref.WeakReference</code> 类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">WeakReference&lt;Object&gt; sr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);    </span><br><span class="line">obj = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价方式----------------------------------------</span></span><br><span class="line">WeakReference&lt;Object&gt; sr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>  弱引用对象与软引用对象最大的不同就在于：在进行 GC 时，对于软引用对象，GC 需要通过算法检查是否回收软引用对象；而对于弱引用对象，GC 总是进行回收。弱引用对象更容易、更快被 GC 回收。</li>
</ul>
<blockquote>
<p>  <strong>面试题：你开发中使用过 WeakHashMap 吗 ？</strong></p>
</blockquote>
<hr>
<h3 id="4、虚引用（Phantom-Reference）——对象回收跟踪"><a href="#4、虚引用（Phantom-Reference）——对象回收跟踪" class="headerlink" title="4、虚引用（Phantom Reference）——对象回收跟踪"></a>4、虚引用（Phantom Reference）——对象回收跟踪</h3><ul>
<li>  虚引用也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</li>
<li>  一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li>
<li>  <strong>虚引用不能单独使用，也无法通过虚引用来获取关联的对象</strong>。当试图通过虚引用的 <code>get()</code> 方法取的对象时，结果总是为 null。</li>
<li>  为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<blockquote>
<p>  <strong>引用队列</strong></p>
</blockquote>
<ul>
<li>  虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，用于告知程序对象的回收情况。</li>
<li>  <strong>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录</strong>。</li>
<li>  在 JDK1.2 之后，Java 提供了 <code>java.lang.ref.PhantomReference</code> 类来实现虚引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个只有虚引用连接的对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">ReferenceQueue&lt;Object&gt; phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; pr = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用虚引用调用对象，发现结果为 null</span></span><br><span class="line">System.out.println(pr);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5、终结器引用"><a href="#5、终结器引用" class="headerlink" title="5、终结器引用"></a>5、终结器引用</h3><ul>
<li>  它用于实现对象的 <code>finalize()</code> 方法，也可以称为终结器引用。</li>
<li>  无需手动编码，其内部需要配合引用队列使用。（构造方法中必须传入一个引用队列）</li>
<li>  在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用的对象并调用它的 <code>finalize()</code> 方法，第二次 GC 时才能回收被引用对象。</li>
</ul>
<hr>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="1-垃圾收集器分类"><a href="#1-垃圾收集器分类" class="headerlink" title="1    垃圾收集器分类"></a>1    垃圾收集器分类</h2><ul>
<li>  由于《Java虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器可能会有很大的差别。</li>
<li>  由于 JDK 的版本处于高速迭代的过程中，因此 Java 发展至今已经衍生出了众多的 GC 版本。</li>
</ul>
<p>从不同的角度分析垃圾回收器，可将 GC 分为不同的类型。  </p>
<blockquote>
<ol>
<li> 按垃圾收集的线程数分，可以分为<strong>串行垃圾收集器</strong>和<strong>并行垃圾收集器</strong>。</li>
</ol>
</blockquote>
<ul>
<li>串行回收指的是在同一时间段内只允许有一个垃圾收集线程用于执行垃圾回收操作，此时所有用户线程将被暂停，直至垃圾收集工作结束。<ul>
<li>  在只有单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的 Client 模式下的 JVM 中。</li>
<li>  在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
</li>
<li>  和串行收集相反，并行收集可以同时使用多个垃圾收集线程执行垃圾回收，因此提升了应用的吞吐量，不过并行回收与串行回收一样仍然采用了<strong>独占式</strong>的方式，即会产生 STW 。</li>
</ul>
<blockquote>
<ol start="2">
<li> 按工作模式分，可分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong>。</li>
</ol>
</blockquote>
<ul>
<li>  并发式垃圾回收指垃圾收集线程与用户线程交替运行，以尽可能减少应用程序的单次停顿时间。</li>
<li>  独占式垃圾回收器（Stop The World）一旦运行，就停止应用程序中所有的用户线程，直至垃圾回收过程完全结束。</li>
</ul>
<blockquote>
<ol start="3">
<li> 按碎片处理方式分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。</li>
</ol>
</blockquote>
<ul>
<li>压缩式垃圾回收指在回收完成后，对存活对象进行压缩整理，消除回收后的内存碎片。<ul>
<li>  再给新对象分配内存空间时使用策略：指针碰撞</li>
</ul>
</li>
<li>非压缩式垃圾回收器不进行内存整理的操作。<ul>
<li>  再给对象分配内存空间时使用：空闲列表 </li>
</ul>
</li>
</ul>
<blockquote>
<ol start="4">
<li> 按工作的内存区间分，可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</li>
</ol>
</blockquote>
<hr>
<h2 id="2-GC性能指标"><a href="#2-GC性能指标" class="headerlink" title="2    GC性能指标"></a>2    GC性能指标</h2><h3 id="评估垃圾收集器性能的指标"><a href="#评估垃圾收集器性能的指标" class="headerlink" title="评估垃圾收集器性能的指标"></a>评估垃圾收集器性能的指标</h3><ul>
<li>  <strong>吞吐量：用户线程执行的时间占总运行时间的比例</strong>。（总运行时间 = 用户线程执行时间 + 垃圾回收线程执行时间）</li>
<li>  垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li>  <strong>暂停时间：执行垃圾回收时，用户线程单次暂停的时间</strong>。</li>
<li>  <strong>内存占用：Java 堆区所占的内存大小</strong>。</li>
<li>  收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>  快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>上述指标中加粗的三项共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。但是一款优秀的收集器通常最多只能同时满足其中的两项。  </p>
<p>这三项中，暂停时间的重要性日益凸显。因为随着硬件的发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量，而内存的扩大，对延迟反而带来负面效果。</p>
<blockquote>
<p>  <em>内存空间越大，能容纳的对象也就越多，那么 GC 的间隔时间也就越长（默认情况下只有可用内存达到了一定的阈值之后才会进行 GC，当内存空间足够大时，相应的这个阈值也就会增长），并且每次要回收的对象也就越多，那么此时 STW 的时间显然也会增加。</em></p>
</blockquote>
<p>简单来说，主要抓住两点：  </p>
<ul>
<li>  吞吐量</li>
<li>  暂停时间</li>
</ul>
<h4 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）<img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624101790607-b6effada-59c2-41df-8182-7cc9860a09ad.png" alt="吞吐量与暂停时间.png"></h4><ul>
<li><p>  吞吐量就是 CPU 用于运行用户线程的时间与 CPU 总消耗时间的比值，即 <code>吞吐量 = 运行用户线程时间 /（运行用户线程时间 + 垃圾收集时间）</code>。</p>
</li>
<li><p>  某一段时间内，吞吐量越高（越接近100%），垃圾收集的总耗时就越短，垃圾收集的次数比较少，但单次垃圾收集耗时反而会变长。</p>
</li>
<li><p>  吞吐量越低，垃圾收集的总耗时就越长，垃圾回收越频繁（垃圾回收频繁是因为堆内存空间较小），但单次垃圾收集的时间反而会变短。</p>
</li>
<li><p>  低延迟（低停顿时间）情况下，用户线程和垃圾回收线程频繁切换，切换线程也会产生一定的额外时间花销。</p>
</li>
<li><p>  高吞吐量情况下，应用程序能容忍较高的暂停时间。因此说，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
</li>
<li><p>  吞吐量优先，意味着在<strong>单位时间</strong>内，STW 的时间最短。</p>
</li>
</ul>
<hr>
<h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><ul>
<li>  暂停时间优先，意味着尽可能让单次 STW 的时间最短。但是在较长的一段时间内，STW 的总时间反而会更长（因为频繁切换应用程序线程和垃圾回收线程之间会有额外的时间开销），吞吐量自然也随之下降，也就是说，吞吐量优先和暂停时间优先是相互矛盾的。</li>
</ul>
<hr>
<h4 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h4><p>“高吞吐量”和“低暂停时间”是一对相互竞争的目标（矛盾）：</p>
<ul>
<li>  如果选择吞吐量优先，那么必然<strong>需要降低内存回收的执行频率</strong>，但是这样会导致单次 GC 需要更长的暂停时间来执行内存回收。</li>
<li>  相反的，如果选择低延迟优先的原则，那么为了降低每次执行内存回收的暂停时间，也只能<strong>频繁的执行内存回收</strong>，但这又会引起年轻代内存的缩减和程序吞吐量的下降。</li>
</ul>
<blockquote>
<p>  <strong>举例</strong></p>
</blockquote>
<p><em>采用控制变量法，假设在某一段固定的时间内（比如 10s），运行同一应用程序会产生 100M 的垃圾对象。</em></p>
<ul>
<li>  <em>如果采用“高吞吐量”原则，回收频率低（假设共回收了 4 次），那么单次回收 25M 的对象，每次回收花费 100ms</em></li>
<li>  <em>如果采用“低暂停时间”原则，则单次暂停时间较短（假设为 80ms），但相应的回收频率就会增加（假设共回收了 5 次），单次回收 20M 的垃圾，</em></li>
<li>  <em>引起年轻代内存下降是因为单次回收的垃圾量变少了，那么 JVM 就不会在年轻代分配过多的空间，好让年轻代能频繁的触发 GC</em></li>
</ul>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<p><strong>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只能针对两个目标之一（即只专注于“高吞吐量”或“最小暂停时间”），或者尝试找到一个二者的折中。</strong></p>
<hr>
<h2 id="3-不同的垃圾回收器概述"><a href="#3-不同的垃圾回收器概述" class="headerlink" title="3    不同的垃圾回收器概述"></a>3    不同的垃圾回收器概述</h2><p>​    垃圾收集机制是 Java  的招牌能力，极大地提高了开发效率。有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p>
<h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><ul>
<li>  2020 年 3 月，JDK14 发布。删除了 CMS 垃圾回收器，扩展 ZGC 在 macOS 和 Windows 上的应用。</li>
</ul>
<h3 id="7-款经典的垃圾回收器"><a href="#7-款经典的垃圾回收器" class="headerlink" title="7 款经典的垃圾回收器"></a>7 款经典的垃圾回收器</h3><ul>
<li>  串行回收器：Serial、Serial Old</li>
<li>  并行回收器：ParNew、Parallel Scavenge、Parallel Old</li>
<li>  并发回收器：CMS、G1</li>
</ul>
<h4 id="七款垃圾回收器与垃圾分代之间的关系"><a href="#七款垃圾回收器与垃圾分代之间的关系" class="headerlink" title="七款垃圾回收器与垃圾分代之间的关系"></a>七款垃圾回收器与垃圾分代之间的关系</h4><p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624106917861-943a5a11-8e99-4d7d-9ecb-c104bd8ff813.png" alt="7款经典收集器.png"></p>
<ul>
<li>  新生代垃圾回收器：Serial、Parallel Scavenge、ParNew</li>
<li>  老年代垃圾回收器：Serial Old、Parallel Old、CMS</li>
<li>  整堆垃圾回收器：G1</li>
</ul>
<h4 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h4><p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624107922035-37d34be3-ec03-4b2f-86de-f7114309d6a8.png" alt="垃圾回收器的组合关系.png"></p>
<ul>
<li>  两个收集器之间有连线，表示它们可以搭配使用。</li>
<li>  其中 Serial Old 作为 CMS 出现“Concurrent Mode Failure”失败时的候选方案。</li>
<li>  （红色虚线）由于维护和兼容性测试的成本，在 JDK8 时将 <code>Serial + CMS</code> 、 <code>ParNew + Serial Old</code> 这两个组合声明为废弃，并在 JDK9 中完全移除了这两个组合。</li>
<li>  （绿色虚线）JDK14 中：弃用 <code>Parallel Scavenge + Serial Old</code> 组合。</li>
<li>  （绿色虚线）JDK14 中，删除 CMS 垃圾回收器。</li>
</ul>
<blockquote>
<p>  <strong>为什么要有很多收集器，一个不够吗？</strong></p>
</blockquote>
<ul>
<li>  因为 Java 的使用场景很多，移动端、服务器等。所以就需要针对不用的场景，提供不同的垃圾回收器，提高垃圾回收的性能。 </li>
<li>  没有一种在任何场景下都适用的完美的垃圾回收器存在，所以我们选择的只是在具体的应用场景下最合适的垃圾收集器。</li>
</ul>
<h4 id="如何查看默认的垃圾回收器"><a href="#如何查看默认的垃圾回收器" class="headerlink" title="如何查看默认的垃圾回收器"></a>如何查看默认的垃圾回收器</h4><ul>
<li>  命令行参数（包含使用的垃圾回收器）：<code>-XX:+PrintCommandLineFlags</code> </li>
<li>  使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code> </li>
</ul>
<hr>
<h2 id="4-Serial-收集器：串行回收"><a href="#4-Serial-收集器：串行回收" class="headerlink" title="4    Serial 收集器：串行回收"></a>4    Serial 收集器：串行回收</h2><ul>
<li><p>  Serial 收集器是最基本、历史最悠久的垃圾回收器。在 HotSpot 在 JDK3 之前回收新生代唯一的选择。</p>
</li>
<li><p>  Serial 收集器是一个单线程工作的串行收集器。是 HotSpot 中 Client 模式下默认的新生代垃圾回收器。</p>
</li>
<li><p>  <strong>Serial 垃圾回收器采用复制算法、串行回收和“Stop The World”机制的方式执行内存回收。</strong></p>
</li>
<li><p>除了年轻代之外，Serial 收集器还提供了用于执行老年代垃圾回收的 Serial Old 垃圾回收器。<strong>Serial Old 回收器同样采用了串行回收和“Stop The World”机制，但是内存回收算法使用的是标记-压缩算法。</strong></p>
<ul>
<li>  Serial Old 是运行在 Client 模式下默认的老年代垃圾回收器。</li>
<li>  Serial Old 在 Server 模式下主要有两个用途：①与新生代的 Parallel Scavenge 垃圾回收器配合使用    ②作为老年代的 CMS 垃圾回收器的备选垃圾回收器。</li>
</ul>
</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624113654891-30ee59bc-ff69-4073-b21f-70e640fa3240.png" alt="Serial_SerialOld垃圾回收器.png"></p>
<p>Serial 是一个单线程的独占式垃圾回收器。①“单线程”是指在进行垃圾收集时只会使用一个垃圾回收线程去完成垃圾收集的工作。  ②“独占式”是指在进行垃圾收集时，必须暂停其它所有的用户线程，直至垃圾收集工作结束。</p>
<ul>
<li>  优势：简单高效（与其它垃圾回收器在单线程下的运行效率相比）。对于限定单个 CPU 的环境来说，Serial 由于没有多个线程间交互的开销，专心做垃圾回收自然可以获得最高的单线程回收效率。</li>
<li>  在用户的桌面应用场景中，可用内存一般不大（几十MB到一俩百MB），可以在较短的时间内完成垃圾回收，只要不频繁发生，使用串行回收器是可以接受的。</li>
<li>  在 HotSpot 虚拟机中，使用 <code>-XX:+UserSerialGC</code> 参数可以指定年轻代和老年代都使用串行垃圾回收器。（新生代使用 Serial GC，且老年代使用 Serial Old GC）</li>
</ul>
<blockquote>
<p>  <strong>总结</strong></p>
</blockquote>
<ul>
<li>  目前已经很少使用串行垃圾回收器了，而且限定在单核 CPU 才可以使用。现在的处理器大都不是单核了。</li>
<li>  对于<strong>强交互</strong>较的应用而言，这种垃圾回收器是不能接受的。一般在 JavaWeb 应用程序中是不会采用串行垃圾回收器的。</li>
</ul>
<hr>
<h2 id="5-ParNew-收集器：并行回收"><a href="#5-ParNew-收集器：并行回收" class="headerlink" title="5    ParNew 收集器：并行回收"></a>5    ParNew 收集器：并行回收</h2><blockquote>
<p>  <strong>ParNew；Parallel New；Par 是 Parallel 的缩写，New 代表回收的内存区域是新生代。</strong></p>
</blockquote>
<ul>
<li>  如果说 Serial 是针对新生代的单线程垃圾回收器，那么 ParNew 则是 Serial 收集器的多线程版本。ParNew 除了采用并行方式执行内存回收外，两款垃圾回收器几乎没有任何区别。ParNew 在新生代中同样也是采用复制算法、STW机制。</li>
<li>  ParNew 是很多虚拟机 Server 模式下默认的新生代的垃圾收集器。 </li>
<li>  除了 Serial 外，目前只有 ParNew 能与 CMS 配合工作。</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624113581528-c91f6b00-e722-4053-8de0-a3f2fed6c96f.png" alt="ParNew_SerialOld垃圾回收器.png"></p>
<ul>
<li>  对于新生代，回收次数频繁，使用并行方式高效</li>
<li>  对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<blockquote>
<p>  <strong>问题：由于 ParNew 回收器是并行收集的，那么是否可以断定 ParNew 回收器的回收效率在任何情况下都会比 Serial 回收器更高效？</strong></p>
</blockquote>
<ul>
<li><p>  在多 CPU 的环境下，ParNew 收集器可以充分利用多 CPU、多核心等物理硬件的资源优势，可以更快速地完成垃圾回收，提升程序的吞吐量。</p>
</li>
<li><p>但是在单 CPU 的环境下，Serial 比 ParNew 更高效，虽然 Serial 是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效的避免多线程交互过程中产生的一些额外开销。</p>
<p>  ​    <em>在单 CPU 环境下，Serial 只会产生一个线程，该线程对 CPU 的利用率可以达到很高甚至 100%；若采用 ParNew（假设有 4 个 GC 线程），每个 GC 线程只能占 &lt;25% 的CPU性能，因为还要留一部分性能用于完成线程间的切换。</em></p>
</li>
</ul>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li>  在程序中，开发人员可以通过参数 <code>-XX:+UseParNewGC</code>手动指定使用 ParNew 执行内存回收任务。它表示新生代使用并行收集器，不影响老年代（老年代需单独设置）</li>
<li>  由于 ParNew 是一个并行的垃圾回收器，所以还可以额外指定线程数量，参数为：<code>-XX:ParallelGCThreads 线程数量</code> ，默认开启和服务器 CPU 数相同的线程数。</li>
<li>  如一台 8 核的服务器，默认开始 8 个线程效率最高，每个核心分配一个线程，若线程数高于核心数，则还涉及到多个线程抢占 CPU 的消耗，单个 CPU 内多个线程间切换的消耗。</li>
</ul>
<hr>
<h2 id="6-Parallel-Scavenge-收集器：吞吐量优先"><a href="#6-Parallel-Scavenge-收集器：吞吐量优先" class="headerlink" title="6    Parallel Scavenge 收集器：吞吐量优先"></a>6    Parallel Scavenge 收集器：吞吐量优先</h2><p>HotSpot 的新生代中除了可以使用 ParNew 外，还可以使用 Parallel_Scavenge。Parallel_Scavenge 同样也采用了<strong>复制算法</strong>、<strong>并行回收</strong>和“<strong>Stop The World</strong>”机制。</p>
<blockquote>
<p>  <strong>问题：既然 ParNew 和 Parallel_Scavenge 效率相仿，作用区域相同，那么 Parallel_Scavenge 是否还有必要出现呢？</strong></p>
</blockquote>
<ul>
<li>  和 ParNew 不同，Parallel Scavenge 回收器的目标是<strong>达到一个可控制的吞吐量</strong>。它也被称为<strong>吞吐量优先</strong>的垃圾收集器。</li>
<li>  自适应调节策略也是 Parallel Scavenge 和 ParNew 的一个重要区别。</li>
</ul>
<p><strong>应用场景不同</strong></p>
<ul>
<li>  停顿时间越短就越适合需要频繁与用户交互或者需要保证服务器响应速度的程序，良好的响应速度提升用户体验；</li>
<li>  而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</li>
</ul>
<p>​    Parallel Scavenge 在 JDK1.6 时提供了用于执行老年代垃圾回收的 Parallel Old 垃圾回收器，用来代替老年代原先的 Serial Old 回收器。Parallel Scavenge 多用于服务器环境中，而服务器环境大多性能较好（多为多核 CPU），使用 Serial Old 串行回收显然很浪费服务器的性能，所以在 JDK1.6 中新增了 Parallel_Old 回收器用于并行回收老年代内存空间。Parallel_Old 采用了<strong>标记-压缩算法</strong>，<strong>并行回收</strong>和“<strong>Stop-The-World</strong>”机制。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624120059763-c41b9104-37a5-44c0-b314-1fbd8d5d16ba.png" alt="Parallel Scavenge_Parallel Old垃圾回收器.png"></p>
<ul>
<li>  在要求程序吞吐量优先的应用场景中，Parallel Scavenge 和 Parallel Old 的组合，在 Server 模式下内存回收性能很不错。</li>
<li>  在 Java8 中，默认是此垃圾回收器。（Parallel Scavenge + Parallel Old）</li>
</ul>
<h3 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li><p>  <code>-XX:+UseParallelGC</code> ：手动指定新生代使用 Parallel Scavenge 执行内存回收任务。</p>
</li>
<li><p><code>-XX:+UseParallelOldGC</code> ：手动指定老年代使用 Parallel Old 执行内存回收任务。</p>
<blockquote>
<ul>
<li>  以上 2 个参数分别适用于新生代和老年代，JDK8 中默认是开启的。</li>
<li>  以上 2 个参数，如果开启一个，则另一个就会被自动开启（互相激活，互相绑定）。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>-XX:ParallelGCThreads</code> ：设置新生代并行回收器的线程数。最好设置与 CPU 数量相等，以避免过多的线程数影响垃圾回收性能。</p>
<blockquote>
<ul>
<li>  默认情况下，当 CPU 数量小于等于 8 个，ParallelGCThreads 的值等于 CPU 数量。</li>
<li>  当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 <code>3+[5*CPU_Count]/8</code> 。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>-XX:MaxGCPauseMillis</code> ：设置垃圾回收的最大停顿时间，即 STW 的时间。单位：ms</p>
<blockquote>
<ul>
<li>  为了尽可能地把 STW 时间控制在 MaxGCPauseMillis 以内，垃圾回收器在工作时会调整 Java 堆大小或者其它一些参数。</li>
<li>  对于用户来讲，停顿时间越短体验越好。但是在服务器端，整体的吞吐量越高越好，所以服务器端适合使用 Parallel Scavenge 进行垃圾回收。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>-XX:GCTimeRatio</code> ：设置衡量吞吐量的大小。</p>
<blockquote>
<ul>
<li>  吞吐量范围（0，100）。默认值是 99，也就是说垃圾回收的时间不超过 1%。</li>
<li>  与前一个 <code>MaxGCPauseMillis</code> 参数有一定的冲突，暂停时间越长， <code>GCTimeRatio</code> 参数就越容易超过设定的比例。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>-XX:+UseAdaptiveSizePolicy</code> ：设置 Parallel Scavenge 具有自适应调节策略。</p>
<blockquote>
<ul>
<li>  在自适应调节模式下，新生代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大、吞吐量和停顿时间之间的平衡点。</li>
<li>  在手动调优比较困难的情况下，可以直接使用这种自适应的方式。只需要指定虚拟机的最大堆、目标吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），就可以让虚拟机自己完成调优工作。</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h2 id="7-CMS-收集器：低延迟"><a href="#7-CMS-收集器：低延迟" class="headerlink" title="7    CMS 收集器：低延迟"></a>7    CMS 收集器：低延迟</h2><blockquote>
<p>  <strong>CMS（Concurrent-Mark-Sweep）；强交互；低延迟；单次STW间隔短</strong></p>
</blockquote>
<p>在 JDK1.5 中，HotSpot 推出了一款在<strong>强交互应用</strong>中几乎可认为有划时代意义的垃圾收集器：CMS，这款垃圾回收器是 HotSpot 中第一款真正意义上的<strong>并发收集器</strong>，它第一次实现了让垃圾回收线程与用户线程同时工作。</p>
<ul>
<li><p>  CMS 的目标是尽可能缩短垃圾收集时用户线程的单次停顿时间。单次停顿时间（延迟）越低就越适合与用户交互频繁的程序，良好的响应速度能提升用户体验。</p>
</li>
<li><p>  目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以带给用户更好的体验。CMS 就非常符合这类应用的需求。</p>
</li>
<li><p>  CMS 垃圾回收器采用了<strong>标记-清除算法</strong>（上面提到的几种垃圾收集器均采用的是标记-压缩算法），并且也会发生“Stop-The-World”。</p>
</li>
</ul>
<p>不幸的是，<strong>CMS 作为老年代的垃圾回收器</strong>，无法与 JDK1.4 中新增的新生代收集器 Parallel Scavenge 配合工作（底层的实现框架不兼容），所以在 JDK1.5 中使用 CMS 来回收老年代内存的时候，新生代只能选择 ParNew 或者 Serial 中的一个。在 G1 出现之间，CMS 的使用还是非常广泛的。直到今天，仍然有很多系统使用 CMS 垃圾回收器。</p>
<h3 id="CMS-工作过程"><a href="#CMS-工作过程" class="headerlink" title="CMS 工作过程"></a>CMS 工作过程</h3><p>CMS 垃圾回收的整个过程可分为 4 个阶段，包括：</p>
<ol>
<li> <strong>初始标记（Initial-Mark）</strong></li>
<li> <strong>并发标记（Concurrent-Mark）</strong></li>
<li> <strong>重新标记（Remark）</strong></li>
<li> <strong>并发清除（Concurrent-Sweep）</strong></li>
</ol>
<blockquote>
<ol>
<li> <strong>初始标记</strong></li>
</ol>
</blockquote>
<p>这个阶段的<strong>主要任务就是标记出 GC Roots 能直接关联到的对象</strong>。标记过程中垃圾收集线程是独占式的，所有用户线程都将会发生 STW，一旦标记完成之后就会恢复之前被暂停的所有用户线程。由于 GC_Roots 直接关联的对象比较少，所以此阶段暂停的时间非常短。</p>
<blockquote>
<ol start="2">
<li> <strong>并发标记</strong>：</li>
</ol>
</blockquote>
<p><strong>从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要暂停用户线程</strong>，可以与垃圾回收线程一起并发运行。</p>
<blockquote>
<ol start="3">
<li> <strong>重新标记</strong>：</li>
</ol>
</blockquote>
<p><strong>为了修正并发标记期间，因用户线程继续工作而导致标记产生变动的那一部分对象的标记记录</strong>，需要重新进行一次标记（CMS 使用增量更新）。这个阶段的停顿时间通常回比初始阶段稍长一些，但也远比并发标记阶段的时间要短。</p>
<blockquote>
<ol start="4">
<li> <strong>并发清除</strong>：</li>
</ol>
</blockquote>
<p><strong>清理掉标记阶段判定已死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发进行的</strong>（不需 要移动存活对象就意味着不会对现有的正在使用的对象作出任何改变，所以不会对运行着的程序产生任何影响。如果需要移动存活对象，则程序中所有使用到对象引用的地方（如局部变量表或方法区的静态变量）必然也要发生改变，这就会导致运行着的程序出错）。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/CMS%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="CMS 垃圾回收器"></p>
<blockquote>
<p>  <strong>CMS 会产生 STW 吗？</strong></p>
</blockquote>
<p>尽管 CMS 是一款并发式（非独占式）垃圾回收器，但是在其<strong>初始化标记和重新标记这两个阶段仍需要执行 STW 机制</strong>暂停所有用户线程，不过暂停时间并不会太长。可以说目前所有的垃圾回收器都做不到完全不需要“Stop-The-World”，只能是尽可能地缩短暂停时间。 </p>
<blockquote>
<p>  <strong>为什么需要重新标记？</strong></p>
</blockquote>
<ul>
<li>  只要用户线程和垃圾回收线程并发执行，那么就不可避免地会出现：①产生新的垃圾对象    ②将未死亡的对象回收。</li>
<li>  前者还是可以接受的，只不过是产生了一些浮动垃圾而已，而后者则可能会直接导致程序崩溃，所以是一定要避免的。</li>
<li>  这样就还需要重新进行垃圾标记，所以说不可能完全消除“Stop-The-World”。*</li>
</ul>
<blockquote>
<p>  <strong>CMS 的停顿时间长吗？</strong></p>
</blockquote>
<ul>
<li>  由于最耗时的并发标记（遍历 GC_ROOTS 关联的所有对象）与并发清除阶段都不需要暂停用户线程，所以整体的回收过程还是低停顿的。</li>
</ul>
<blockquote>
<p>  <strong>CMS 需要预留一定的老年代空间用于保存并发的用户线程创建的新的对象</strong></p>
</blockquote>
<ul>
<li><p>  另外，由于在垃圾回收阶段用户线程没有中断，所以<strong>在 CMS 回收过程中，还应确保应用程序的用户线程有足够的内存可用</strong>。</p>
</li>
<li><p>  因此，CMS 不能像其它垃圾回收器那样等到老年代几乎完全被填满了再进行回收，而是<strong>当堆内存使用率达到一定阈值时，便开始进行垃圾回收</strong>，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。</p>
</li>
<li><p>要是 CMS 运行期间预留的内存无法满足程序需要，就会出现“<strong>Concurrent Mode Failure</strong>”失败，这时虚拟机将启动后备方案：临时启用 Serial Old 收集器来重新进行老年代的垃圾回收，这时停顿时间就会很长了。</p>
<p>  ​    <em>提前进行垃圾收集是所有的并发垃圾收集器的一个通病。因为并发过程中用户线程会和垃圾收集线程同时执行，那么就存在这样一种情况：用户线程消耗内存的速度远快于垃圾收集线程回收内存的速度。这种情况下，如果垃圾收集器每次都等到可用内存不足时再进行垃圾收集，那么将极有可能出现内存溢出的情况，这时程序就会报“<strong>Concurrent Mode Failure</strong>” 错误。对于 CMS 如果出现该错误，虚拟机将启用 Serial Old 回收器作为后备方案。</em></p>
<p>  ​    <em>而对于并行/串行的回收器，在执行垃圾回收的时候会完全暂停用户线程，只允许垃圾回收线程工作，即用户线程在垃圾回收的过程中不会产生新的垃圾，所以可以在可用内存不足时再启动垃圾回收。</em></p>
</li>
</ul>
<blockquote>
<p>  <strong>CMS在垃圾收集后使用空闲列表为新对象进行内存分配</strong></p>
</blockquote>
<p>CMS 采用的垃圾收集算法是<strong>标记-清除</strong>算法，这意味着每次执行完内存回收后，不可避免的会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞技术（Bump the Point），而只能够使用空闲列表（Free List）进行内存分配。</p>
<blockquote>
<p>  <strong>问题：CMS 为什么使用标记-清除算法而不使用标记-压缩算法？</strong></p>
</blockquote>
<ul>
<li>  <strong>移动对象与并发是矛盾的。</strong></li>
</ul>
<p>CMS 在标记完可回收对象后，清除阶段的是并发执行的，如果采用标记-压缩算法，将会改变内存中存活对象的内存地址，也就是说所有使用到该对象引用的地方都需要被更新，而在一个运行着的程序中显然是不可能完成的，这就会导致程序执行失败。而采用标记-清除算法，只会清除已死亡对象的内存，而不会对存活对象的内存地址产生任何影响，其运行资源不会收到任何影响，不会影响正在执行的程序。Mark-Compact 更适合“Stop_The_World”这种场景下使用，即暂停用户线程，等所有内存重新分配、赋值后再启动用户线程让其继续执行。</p>
<h3 id="CMS-优缺点"><a href="#CMS-优缺点" class="headerlink" title="CMS 优缺点"></a>CMS 优缺点</h3><blockquote>
<p>  <strong>优点：</strong></p>
</blockquote>
<ul>
<li>  并发回收</li>
<li>  低延迟</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong></p>
</blockquote>
<ol>
<li> <strong>会产生内存碎片</strong>。这会导致并发清除后，用户线程的可用连续空间不足，在碰到需要给大对象分配内存时，无法完成任务。在这种情况下，会提前触发下一次的 Full GC。</li>
<li> <strong>CMS 对 CPU 资源非常敏感</strong>。事实上，面向并发设计的收集器对处理器的资源都比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢（垃圾收集线程占用了用户线程的资源），总吞吐量降低。</li>
<li> <strong>CMS 无法处理浮动垃圾</strong>。可能出现“Concurrent Mode Failure”失败而导致下一次 Full GC 的产生。在 CMS 的并发标记和并发清理阶段，由于程序的用户线程和垃圾回收线程是同时运行或交叉运行的，那么<strong>在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记（因为标记的对象是某一时刻内存的一个快照），最终会导致这些新产生的垃圾对象不能被及时回收</strong>，只能等到下一次 GC 时释放这些垃圾对象的内存空间。</li>
</ol>
<h3 id="CMS-参数设置"><a href="#CMS-参数设置" class="headerlink" title="CMS 参数设置"></a>CMS 参数设置</h3><ul>
<li><p><code>-XX:+UseConcMarkSweepGC</code> ：显式地设置使用 CMS 垃圾回收器执行内存回收任务。</p>
<blockquote>
<ul>
<li>  启用该参数后会自动设置新生代的垃圾回收器为 ParNew ，等价于 <code>-XX:+UseParNewGC</code> 。即：ParNew（新生代）+CMS/Serial Old（老年代） 的组合。</li>
</ul>
</blockquote>
</li>
<li><p><code>-XX:CMSInitiatingOccupanyFraction</code> ：设置堆内存使用率的阈值。一旦达到该阈值，便开始进行回收。</p>
<blockquote>
<ul>
<li>  JDK1.6 之前默认值为 68，即当老年代的空间使用率达到 68% 时，就会触发一次 CMS 回收。<strong>从 JDK1.6 开始这个默认值变成了 92</strong>。</li>
<li>  如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 GC 的触发频率，减少老年代回收的次数，改善应用程序的性能。反之，如果应用程序内存使用率增长很快（大于垃圾回收的速度），则应该降低这个阈值，以避免频繁触发老年代的串行收集器。因此<strong>通过该参数可以有效降低 Full GC 的执行次数</strong>。</li>
</ul>
</blockquote>
</li>
<li><p>  <code>-XX:+UseCMSCompactAtFullCollection</code> ：用于指定在执行完 Full GC 后对内存空间进行空间压缩整理，以避免内存碎片的产生。不过由于内存压缩整理无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li><p>  <code>-XX:CMSFullGCsBeforeCompaction</code> ：设置在执行多少次 Full GC 后对内存空间进行压缩整理。</p>
</li>
<li><p><code>-XX:ParallelCMSThreads</code> ：设置 CMS 的线程数量。（垃圾回收线程的数量）</p>
<blockquote>
<ul>
<li>  CMS 默认启动的线程数量是： <code>(ParallelGCThreads + 3) / 4</code> 。ParallelGCThreads 是新生代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。（垃圾回收线程抢占了用户线程的资源）</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>  <strong>Serial GC 、Parallel GC 、Concurrent Mark Sweep GC 这三个 GC 有什么不同呢？</strong></p>
</blockquote>
<ul>
<li>  如果想要最小化地使用内存和并行开销，选择 Serial GC；</li>
<li>  如果想要最大化应用程序的吞吐量，选择 Parallel GC；</li>
<li>  如果想要最小化 GC 的停顿时间，选择 CMS GC</li>
</ul>
<ul>
<li>  JDK9 新特性：CMS 被标记为 Deprecate 了（废弃了）</li>
<li>  JDK14 新特性：删除了 CMS 垃圾回收器</li>
</ul>
<hr>
<h2 id="8-G1-回收器：区域化分代式"><a href="#8-G1-回收器：区域化分代式" class="headerlink" title="8    G1 回收器：区域化分代式"></a>8    G1 回收器：区域化分代式</h2><blockquote>
<p>  <strong>Garbage First；G1</strong></p>
<p>  <strong>回收集；Collection_Set；CSet</strong></p>
</blockquote>
<p>随着应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有垃圾回收机制就不能保证应用程序正常进行，而经常造成 STW 的垃圾收集器又跟不上实际的需求，所以才会不断地尝试对垃圾收集器进行优化。</p>
<p>G1（Garbage First）垃圾回收器是在 Java7 之后引入的一个新的垃圾回收器，是当今收集技术发展的最前沿的成果之一。</p>
<p>G1 收集器开创了面向局部收集的设计思路和基于 Region 的内存布局形式。被 Oracle 官方称为“全功能的垃圾收集器”。</p>
<blockquote>
<p>  <strong>问题：什么是面向局部的设计思路？</strong></p>
</blockquote>
<p>在 G1 收集器出现之前所有的其它收集器，垃圾收集的目标范围要么是整个新生代，要么是整个老年代，要么就是整个 Java 堆。而 G1 跳出了这个樊笼，它可以面向堆的任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是 G1 收集器的 Mixed_GC 模式。</p>
<blockquote>
<p>  <strong>问题：什么是基于 Region 的内存布局形式？</strong></p>
</blockquote>
<p>G1 开创性的使用了基于 Region 的内存布局，虽然它也是遵循分代收集理论设计的，但其堆内存布局与其它收集器有非常明显的差异：</p>
<ul>
<li>  G1 不再坚持固定大小及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 根据需要，可以是 Eden 区空间、Survivor 区空间、或者是老年代空间。收集器能够对不同角色的 Region 采用不同的策略去处理。  </li>
<li>  虽然 G1 仍然保留新生代和老年代的概念，但新生代和老年代的概念不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。</li>
<li>  G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量。</li>
<li>  G1 是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器。能以极高概率满足停顿时间的同时，还兼具高吞吐量的性能特征。</li>
<li>  G1 作为 CMS 收集器的替代者和继承人，设计者希望能做出一款能够建立起“<strong>停顿时间模型</strong>”的收集器。停顿时间模型是指：能够实现<strong>在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间大概率不会超过 N 毫秒</strong>这样的目标。</li>
</ul>
<blockquote>
<p>  <strong>问题：G1 收集器如何实现“停顿时间模型”？</strong></p>
</blockquote>
<ul>
<li>  首先要明确，能够以极高的概率满足指定停顿时间，并不等价于能 100% 满足指定停顿时间。也就是说假如设置停顿时间为 10ms ，那么大部分情况下都会 <code>&lt;=10ms</code>，但是不排除有超过 10ms 的情况。</li>
<li>  G1 之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次收集到的内存空间都是 Region 大小的整数倍。这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。更具体的思路是让 G1 收集器去跟踪各个 Region 里面的 Region 的垃圾堆积的“价值”大小，然后在后台维护一个优先级列表，每次根据用户设定的允许收集停顿时间优先处理回收价值收益最大的那些 Region。这种使用 Region 划分内存空间，以及优先回收价值高的 Region 的回收方式，保证了 G1 收集器在有限的时间内可以获得尽可能高的收集效率。</li>
<li>  那么 G1 如何实现低停顿时间呢？就是通过控制每次回收的 Region 数量来控制停顿时间，Region 数量越多，回收的内存就越大，停顿时间自然也就越长。</li>
</ul>
<blockquote>
<p>  <strong>问题：该垃圾收集器为什么叫做 Garbage First（G1）呢？</strong></p>
</blockquote>
<ul>
<li>  Garbage_First 中的 First 是第一的意思，这就暗示了 G1 收集器是具有优先级的。</li>
<li>  因为 G1 是一个并行垃圾回收器，它把堆内存分割成很多不相关的区域（Region），这些区域在物理上是不连续的。使用不同的 Region 来表示 Eden区、Survivor区、老年代等。</li>
<li>  G1 GC 有计划的避免在整个 Java 堆中进行全区域的垃圾回收。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收可获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的回收时间，优先回收价值最大的 Region</strong>。</li>
<li>  G1 垃圾回收的侧重点在于回收垃圾最大量的区间（Region）。所以我们将其命名为：Garbage First，垃圾优先。</li>
</ul>
<p>G1 在 JDK7 中被加入，在 JDK9 中被设为默认，移除了 Experimental 的标识，是 JDK9 之后的默认垃圾回收器。与此同时，CMS 在 JDK9 中被标记为废弃（deprecated）。在 JDK9 之前若想使用 G1 ，需要使用 <code>-XX:+UserG1GC</code> 来显式地启用。</p>
<h3 id="G1-的特点"><a href="#G1-的特点" class="headerlink" title="G1 的特点"></a>G1 的特点</h3><p>与其它垃圾回收器相比，G1 使用了全新的分区算法，其特点如下：</p>
<ul>
<li><p><strong>兼具并行与并发</strong></p>
<ul>
<li>  并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程停顿（STW）。</li>
<li>  并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行。因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li>
</ul>
</li>
<li><p><strong>分代收集</strong></p>
<ul>
<li>  从分代上看，G1 仍属于分代型垃圾回收器，它会区分新生代和老年代，新生代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、新生代或者老年代是连续的，也不在坚持固定大小和固定数量。</li>
<li>  <strong>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</strong>。</li>
<li>  和之前的几种垃圾回收器不同，G1 同时<strong>兼顾新生代和老年代</strong>。对比其它回收器，或者服务于新生代，或者服务于老年代。</li>
</ul>
</li>
<li><p><strong>空间整合</strong></p>
<ul>
<li><p>  CMS：采用“标记-清除”算法，存在内存碎片，并在若干次 GC 后进行一次碎片整理</p>
</li>
<li><p>G1 将内存划分为一个个的 Region，内存的回收可以是以 Region 作为基本单位的。<strong>Region块之间采用复制算法，整体结构上采用标记-压缩算法（Mark-Compact）</strong>，两种算法都可以避免产生内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续的内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</p>
<blockquote>
<p>  如何理解“Region 之间采用复制算法，整体采用标记-压缩算法”？ </p>
<ul>
<li>  G1 垃圾回收器的基本单位是 Region，在 Region 级别，回收的时候会将内存中存活的对象移动到另一个空闲的 Region 中去。但是从整体内存考虑，每次回收后产生的空闲 Region 都会有序地放在整体内存的一端。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>可预测的停顿时间模型</strong>（即：软实时soft real-time）</p>
<ul>
<li>  这是 G1 相较于 CMS 的另一大的优势。G1 除了追求低停顿时间外，还能建立可预测的时间停顿模型，能让使用者明确指定<strong>在一个长度为 M 毫秒的时间片段内，消耗在垃圾回收上的时间不得超过 N 毫秒</strong>。  </li>
<li>  由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿的时间也能得到较好的控制。</li>
<li>  G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收可获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的回收时间，优先回收价值最大的 Region</strong>。保证了 G1 <strong>在有限的时间内可以获取尽可能高的回收效率</strong>。</li>
<li>  相较于 CMS，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<blockquote>
<ul>
<li>  实时：规定了10ms，就一定要在10ms以内完成垃圾的收集。 </li>
<li>  软实时：规定了10ms，就尽可能地在10ms以内完成垃圾的回收，但允许出现例外。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>相较于 CMS，G1 还不具备全方位、压倒性的优势。比如在用户线程运行过程中，G1 无论是为了垃圾回收产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 高。</p>
<p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则优势更大。平衡点在 6~8GB 之间。</p>
<h3 id="G1-参数设置"><a href="#G1-参数设置" class="headerlink" title="G1 参数设置"></a>G1 参数设置</h3><ul>
<li>  <code>-XX:+UseG1GC</code> ：显式指定使用 G1 垃圾回收器。 </li>
<li>  <code>-XX:G1HeapRegionSize</code> ：设置每个 Region 的大小。值只能是2的次幂（如 1，2，4，8，…），范围是 1MB~32MB 之间，目标是根据最小的 Java 堆大小分出约 2048 个区域，默认是堆内存的 1/2000 。</li>
<li>  <code>-XX:MaxGCPauseMillis</code> ：设置期望达到的最大 GC 停顿时间（JVM 会尽力实现，但不保证实现）。默认值是 200ms 。</li>
<li>  <code>-XX:ParallelGCThreads</code> ：设置 STW 时垃圾回收线程的数量。最多设置为 8。（G1 可以并行，也可以并发）</li>
<li>  <code>-XX:ConcGCThreads</code> ：设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li>
<li>  <code>-XX:InitiatingHeapOccupancyPercent</code> ：设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li>
</ul>
<h3 id="如何使用-G1"><a href="#如何使用-G1" class="headerlink" title="如何使用 G1"></a>如何使用 G1</h3><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需简单的三步即可完成调优。</p>
<ul>
<li>  第一步：启用 G1 垃圾回收器</li>
<li>  第二步：设置堆的最大内存</li>
<li>  第三步：设置最大停顿时间</li>
</ul>
<p>G1 提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p>
<h3 id="G1-的适用场景"><a href="#G1-的适用场景" class="headerlink" title="G1 的适用场景"></a>G1 的适用场景</h3><ul>
<li>  面向服务端的应用，针对具有大内存、多处理器的机器。（在普通大小的堆中表现并不惊喜）</li>
<li>  应用需要低 GC 延迟，并且具有大堆</li>
</ul>
<ul>
<li>  <strong>HotSpot 的垃圾回收器里，除了 G1 以外，其它的垃圾回收器执行内存回收时都需要使用专门的垃圾回收线程进行回收操作，而 G1 在回收内存时还可以采用用户线程来执行 GC 任务</strong>。当 JVM 的 GC 线程处理速度过慢时，系统就会调用用户线程帮助加速垃圾回收的过程。</li>
</ul>
<hr>
<h3 id="分区-Region：化整为零"><a href="#分区-Region：化整为零" class="headerlink" title="分区 Region：化整为零"></a>分区 Region：化整为零</h3><p>使用 G1 垃圾回收器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块的大小根据堆空间的实际大小而定，整体控制在 1MB~32MB 之间，且每块的大小只能为 2 的 N 次幂，即 1MB，2MB，8MB，16MB，32MB。可通过 <code>-XX:G1HeapRegionSize</code> 手动设置块内存的大小。所有的 Region 大小相同，且在 JVM 声明周期内不会被改变。</p>
<p>虽然还保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了（逻辑上隔离，物理上交叉），它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配实现逻辑上的连续。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624208032167-d3376a9c-fca8-4b7a-9df4-81c1b6cd08ec.png" alt="G1回收器.png"></p>
<p>一个 Region 有可能属于 Eden、Survivor 或者 Old 中的任一种。但是一个 Region 只能属于一个角色（一个 Region 中不能既存储新生代对象，又存储老年代对象）。每次内存被回收后空闲出来的 Region 下次充当的角色是随机的。</p>
<p>G1 还增加了一种新的内存区域 Humongous，主要用户存储大对象，如果超过 1.5 个 Region，就放到 Humongous 区。</p>
<ul>
<li>  <strong>设置</strong> <strong>Humongous 区的原因</strong> ：  </li>
</ul>
<p>对于堆中的大对象，默认直接会分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾回收器造成负面影响（因为老年代回收频率低，所以本来一个短期的对象就会在堆中存活很长时间）。为了解决这个问题，G1 专门划分了一个 Humongous 区，它专门用来存放大对象。如果一个 H 区装不下一个大对象，那么 G1 就会寻找连续的 H 区来存储。如果堆中最大的连续 H 区都存不下大对象，就会触发 Full GC 来创造出更大的 H 区。G1 的大多数行为都会把 H 区作为老年代的一部分来看待。</p>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624208903694-2edead3f-d53b-4726-b0f3-a818d1a53400.png" alt="Region的指针碰撞.png"></p>
<ul>
<li>  一个 Region 中可以保存多个对象，每次有新对象加入时，使用“指针碰撞”的方法分配内存。（因为单个 Region 采用复制算法回收，内存规整）</li>
<li>  TLAB：针对某一个 Region，若有多个线程都需要使用，可以在 Region 中在进行细分，给每个线程分配 Region 中的一小块空间，提高分配对象的效率。</li>
</ul>
<h3 id="G1-垃圾回收过程"><a href="#G1-垃圾回收过程" class="headerlink" title="G1 垃圾回收过程"></a>G1 垃圾回收过程</h3><p>G1 的垃圾回收过程主要包括如下几个环节：</p>
<ul>
<li>  年轻代 GC（Young GC）</li>
<li>  老年代并发标记过程（Concurrent Marking）</li>
<li>  混合回收（Mixed GC）</li>
<li>  （如果有需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png" alt="G1垃圾回收过程"></p>
<p>顺时针，Young GC –&gt; Young GC + Concurrent Mark + Mixed GC 顺序，进行垃圾回收。</p>
<ol>
<li> 应用程序分配内存，<strong>当年轻代的 Eden 区用尽时开始新生代的回收过程</strong>：G1 的新生代回收阶段是一个<strong>并行</strong>的<strong>独占式</strong>回收器。在新生代回收期间，暂停所有的用户线程，启动多线程执行新生代的内存回收。然后<strong>从 Eden/from 区移动存活对象到 to 区或者老年代，也有可能两个区间都会涉及</strong>。</li>
<li> 当堆内存使用达到一定阈值（默认是 45%）时，开始老年代并发标记过程。</li>
<li> 标记完成后马上开始混合回收的过程。在混合回收期间，G1 从老年代移动存活对象到空闲 Region，这些空闲 Region 自然也就成为了新的老年代区间。和新生代不同，老年代的 G1 回收器和其它垃圾回收器不同，<strong>G1 的老年代垃圾回收器不需要整个老年代被回收，一次只需要回收一小部分老年代的 Region 就可以了</strong>。同时，这个老年代 Region 是和新生代一起被回收的。</li>
</ol>
<ul>
<li>  G1 垃圾回收的过程中每个阶段都有 Young GC 的参与，这也从一方面验证了新生代回收频繁，老年代回收不频繁这一特点。</li>
</ul>
<hr>
<h3 id="G1-垃圾回收过程：Remembered-Set"><a href="#G1-垃圾回收过程：Remembered-Set" class="headerlink" title="G1 垃圾回收过程：Remembered Set"></a>G1 垃圾回收过程：Remembered Set</h3><p><strong>一个对象被不同区域引用的问题：</strong></p>
<ul>
<li>  一个 Region 不可能是孤立的，一个 Region 中的对象有可能被其它 Region 中的对象引用，判断对象是否存活时，是否需要扫描整个 Java 堆才能保证准确？</li>
<li>在其它的分代垃圾回收器中，也存在这样的问题（而 G1 更加突出）。<ul>
<li>  回收新生代不得不同时扫描老年代？</li>
</ul>
</li>
<li>  <em>如果想要回收某个区域的对象，那么非这个区域的所有引用都可以作为 GC Roots。比如现在想要回收 Eden 区，但是老年代中可能存在对象引用了 Eden 区中的对象，那么就不得不全盘扫描整个堆空间。</em></li>
<li>  这样的话会降低 Minor GC 的效率？</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>  无论是 G1 还是其它分代垃圾回收器，JVM 都是采用<strong>记忆集（Remembered Set）</strong>来避免全局扫描。</li>
<li>  <strong>每个 Region 都有一个对应的 Remembered Set</strong>。</li>
<li>  每次 Reference 类型数据进行写操作时，都会产生一个<strong>写屏障（Write Barrier）</strong>暂时中断操作；</li>
<li>  然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其它垃圾回收器：检查老年代对象是否引用了新生代对象）；</li>
<li>  如果不同，通过 CardTable 把相关引用信息记录到引用指向对象所在 Region 对应的 Remembered Set 中；</li>
<li>  当进行垃圾回收时，在 GC Roots 的枚举范围加入 Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。</li>
</ul>
<p><img src="/2021/06/23/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1624246838963-ac9f133c-0436-418b-9f8b-3ef5715c3838.png" alt="Remembered Set.png"></p>
<p>在 Region2 中给新对象分配内存，并新建一个引用指向该对象。每次新添加引用时，会先暂停，检查这个引用发起的对象来自当前 Region 还是其它 Region。如果是当前 Region，则不做任何处理，因为 G1 是按照 Region 为基本单位进行回收的；如果来自其它 Region，则在 Region2 维护的 Remembered Set 中记录引用发起对象的地址。之后在进行垃圾收集时，就无需再进行全局扫描，只需在 GC Roots 的基础上，加上要回收的 Region 对应的 Remembered Set 中关联的对象，就可以保证不会有遗漏。 </p>
<p>Remembered Set 中记录哪些地址引用了 Region 中的对象。</p>
<hr>
<h3 id="G1-回收过程"><a href="#G1-回收过程" class="headerlink" title="G1 回收过程"></a>G1 回收过程</h3><h4 id="一、新生代-GC"><a href="#一、新生代-GC" class="headerlink" title="一、新生代 GC"></a>一、新生代 GC</h4><p>程序在运行过程中会不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次新生代垃圾回收的过程（Survivor 区满的时候不会触发 YGC）。</p>
<p>新生代的垃圾回收只回收 Eden 区和 Survivor 区。</p>
<p>YGC 时，G1 首先会暂停所有用户线程（STW）（独占式的），G1 创建回收集（Collection Set），回收集就是需要被回收的 Region 的集合，新生代回收过程的回收集包括 Eden 区和 Survivor 区所有的 Region。</p>
<ul>
<li><p>  <strong>第一阶段：扫描GC_Roots（GC_Roots 中包含了 RSet）</strong></p>
</li>
<li><p><strong>第二阶段：更新 RSet</strong></p>
<ul>
<li><p>  处理“脏卡表（dirty card queue）”中的 card，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代 Region 对新生代 Region 中对象的引用。</p>
</li>
<li><p>  对于应用程序的引用赋值语句 <code>object.field = object</code> ，JVM 会在之前和之后执行特殊的操作以在 dirty card queue 中入队一个保存了对象引用信息的 card。在新生代回收的时候，G1 会对 Dirty Card Queue 中所有的 card 进行处理，以更新 RSet，保证 RSet 实时准确地反映引用关系。</p>
</li>
<li><p>  那么为什么不在引用赋值语句处直接更新 RSet 呢？这是处于性能优化的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多</p>
</li>
</ul>
</li>
<li><p><strong>第三阶段：处理 RSet</strong></p>
<ul>
<li>  识别被老年代对象指向的 Eden 中的指针，这些被指向的 Eden 中的对象被认为是存活的对象。</li>
</ul>
</li>
<li><p><strong>第四阶段：复制对象</strong></p>
<ul>
<li>  此阶段，对象树被遍历，Eden 中存活的对象会被复制到 Survivor 中的 to 区；Survivor 中存活的对象如果年龄未达到阈值，年龄+1，达到阈值的对象会被复制到老年代中空的 Region。如果 Survivor 空间不够，Eden 中的部分对象会直接晋升到老年代空间。</li>
</ul>
</li>
<li><p><strong>第五阶段：处理引用</strong></p>
<ul>
<li>  当内存不足时，进行垃圾回收的之后还会处理非强引用的引用关系。如处理 Soft、Weak、Phantom、Final、JNI Weak 等引用。最终 Eden 中的数据为空，GC 停止工作，并且目标内存中的对象都是连续存储的，没有内存碎片。所以复制过程可以达到内存整理的效果，减少内存碎片。</li>
</ul>
</li>
</ul>
<h4 id="二、并发标记过程"><a href="#二、并发标记过程" class="headerlink" title="二、并发标记过程"></a>二、并发标记过程</h4><ul>
<li><p><strong>第一阶段：初始标记阶段</strong></p>
<ul>
<li>  标记根节点的<strong>直接</strong>可达对象。这个阶段是独占式的（会触发 STW），并且会触发一次 YGC。</li>
</ul>
</li>
<li><p><strong>第二阶段：根区域扫描（Root Region Scanning）</strong></p>
<ul>
<li>  扫描 Survivor 区直接可达的老年代区域对象（在第一阶段触发 YGC 后所有的存活对象都会被复制到 Survivor（to）区），并标记被引用的对象。这一过程必须在 YGC 之前完成（因为 YGC 会改变 Survivor 区对象在内存中的位置）。</li>
</ul>
</li>
<li><p><strong>第三阶段：并发标记（Concurrent Marking）</strong></p>
<ul>
<li>  在整个堆中进行并发标记（并发：垃圾收集线程和用户线程并发执行），此过程可能被 YGC 中断。<strong>在并发标记阶段，若发现某个 Region 中的所有对象都是垃圾对象，那么这个 Region 会被立即回收</strong>。同时，在并发标记的过程中，会计算每个区域的对象活性（区域中存活对象的比例）（计算不同 Region 回收的性价比）</li>
</ul>
</li>
<li><p><strong>第四阶段：再次标记</strong></p>
<ul>
<li>  由于在上一阶段“并发标记”过程中。用户线程也一直在同步运行，所以需要通过“再次标记”修正上一阶段的标记结果。这一阶段是独占式的（STW）。G1 采用了比 CMS 更快的初始快照算法：Snapshot-at-the-beginning（SATB）。</li>
</ul>
</li>
<li><p><strong>第五阶段：独占式清理</strong></p>
<ul>
<li>  统计各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域，为下一阶段做准备。是独占式的（STW）。</li>
<li>  这个阶段并不会实际上去做垃圾的回收。</li>
</ul>
</li>
<li><p><strong>第六阶段：并发清理阶段</strong>  </p>
<ul>
<li>  识别并清理完全空闲的区域。</li>
</ul>
</li>
</ul>
<h4 id="三、混合回收"><a href="#三、混合回收" class="headerlink" title="三、混合回收"></a>三、混合回收</h4><p>当越来越多的对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一种混合回收机制，即 Mixed_GC，该算法并不是一个 Old_GC，除了回收整个 Young_Region 之外，还会回收部分 Old_Region。</p>
<ul>
<li>  Tip1：是一部分老年代，而不是全部老年代。可以选择对哪些 Old_Region 进行回收，从而达到对 STW 时间的控制。</li>
<li>  Tip2：是 Mixed_GC，而不是 Full_GC。</li>
</ul>
<ul>
<li>  并发标记结束以后，老年代中全部是垃圾的 Region 被回收了，部分是垃圾的 Region 被标记了出来。默认情况下，老年代中这些被标记的 Region 会分 8 次被回收（根据优先级从高到低）（可以通过 <code>-XX:G1MixedGCCountTarget</code> 参数设置）</li>
<li>  混合回收的回收集（Collection Set）包括 1/8 的老年代 Region，Eden 区所有的 Region、Survivor（from）区的所有 Region。混合回收的算法和新生代的回收算法完全一样，只是回收集多了老年代的部分 Region。具体过程参考上面新生代回收过程。</li>
<li>  由于老年代 Region 默认分 8 次回收，G1 默认先回收垃圾多的 Region。垃圾占 Region 比例越高的，越会先被回收。并且有一个阈值会决定 Region 是否被回收。 <code>-XX:G1MixedGCLiveThresholdPercent</code> ，默认为 65%，意思是垃圾内存占 Region 比例要达到 65% 才会被回收。如果垃圾内存占比太低，意味着存活对象的占比高，在复制的时候会花费更多的时间。</li>
<li>  混合回收并不一定非要进行 8 次。有一个阈值 <code>-XX:G1HeapWastePercent</code> ，默认值为 10%，意思是允许整个堆内存中有 10% 的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例小于 10%，则无需进行混合回收，因为 GC 会花费很多时间但是回收到的内存却很少。</li>
</ul>
<h4 id="四、Full-GC"><a href="#四、Full-GC" class="headerlink" title="四、Full_GC"></a>四、Full_GC</h4><p>G1 的初衷就是要避免 Full_GC 的出现，但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop_The_World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序的暂停时间会很长。</p>
<p>要避免 Full_GC 的发生，一旦发生需要进行调整。什么时候会发生 Full_GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的 Region 可用，则会回退到 Full_GC，这种情况可以通过增大内存解决。</p>
<p>导致 Full_GC 的原因可能有两个：</p>
<ol>
<li> Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li>
<li> 并发处理过程完成之前内存耗尽。</li>
</ol>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>从 Oracle 官方透露出来的信息可知，回收阶段（Evacuation）其实本来也想过设计成与用户线程一起并发执行，但是这件事情做起来比较复杂，考虑到 G1 只是回收一部分的 Region，停顿时间是用户可控制的，所以并不迫切去实现，而是选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h4 id="G1-回收器优化建议"><a href="#G1-回收器优化建议" class="headerlink" title="G1 回收器优化建议"></a>G1 回收器优化建议</h4><ul>
<li><p>  新生代大小</p>
</li>
<li><ul>
<li>  避免使用 <code>-Xmn</code> 或 <code>-XX:NewRatio</code> 等相关选项显式设置新生代的大小。</li>
<li>  固定新生代的大小会覆盖暂停时间目标。</li>
</ul>
</li>
<li><p>  暂停时间目标不要太过严苛</p>
</li>
<li><ul>
<li>  G1 的吞吐量目标是 90% 的应用程序执行时间和 10% 的垃圾回收时间。</li>
<li>  评估 G1 GC 的吞吐量时，暂停时间不太严苛。目标太过严苛表示你愿意承担更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
</li>
</ul>
<h2 id="9-垃圾回收器总结"><a href="#9-垃圾回收器总结" class="headerlink" title="9    垃圾回收器总结"></a>9    垃圾回收器总结</h2><h3 id="7款经典垃圾回收器总结"><a href="#7款经典垃圾回收器总结" class="headerlink" title="7款经典垃圾回收器总结"></a>7款经典垃圾回收器总结</h3><table>
<thead>
<tr>
<th align="left">垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用的算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Serial</td>
<td>串行运行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="left">ParNew</td>
<td>并行运行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多 CPU 下的 Server 模式，<br>与 CMS 配合使用</td>
</tr>
<tr>
<td align="left">Parallel</td>
<td>并行运行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要<br>太多交互的场景</td>
</tr>
<tr>
<td align="left">Serial Old</td>
<td>串行运行</td>
<td>老年代</td>
<td>标记-压缩算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="left">Parallel Old</td>
<td>并行运行</td>
<td>老年代</td>
<td>标记-压缩算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要<br>太多交互的场景</td>
</tr>
<tr>
<td align="left">CMS</td>
<td>并发运行</td>
<td>老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>使用互联网或B/S服务</td>
</tr>
<tr>
<td align="left">G1</td>
<td>并发/并行运行</td>
<td>新生代+老年代</td>
<td>复制算法+标记-压缩算法</td>
<td>响应速度优先</td>
<td>面向服务端应用</td>
</tr>
</tbody></table>
<blockquote>
<p>  速记：</p>
<ul>
<li>  新生代全部使用<code>复制算法</code>。</li>
<li>  老年代只有 CMS 使用了 <code>标记-清除算法</code>，其余均为 <code>标记-压缩算法</code>。</li>
<li>  总结：只有 CMS 使用了<strong>标记-清除算法</strong>。</li>
</ul>
</blockquote>
<h3 id="怎样选择垃圾回收器"><a href="#怎样选择垃圾回收器" class="headerlink" title="怎样选择垃圾回收器"></a>怎样选择垃圾回收器</h3><p>Java 垃圾回收器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾回收器可以让 JVM 的性能有一个很大的提升。</p>
<p>怎样选择垃圾回收器？</p>
<ol>
<li><p> 优先调整堆的大小让 JVM 自适应完成。</p>
</li>
<li><p> 如果内存小于 100MB，使用串行的垃圾回收器。</p>
</li>
<li><p> 如果是单核、单机程序，并且没有停顿时间的要求，选择串行垃圾回收器</p>
</li>
<li><p> 如果是多 CPU、需要高吞吐量、允许停顿时间超过 1s ，选择并行回收器或让 JVM 自行选择。</p>
</li>
<li><p> 如果是多 CPU、追求低停顿时间，需要快速响应（比如延迟不能超过 1s，如互联网应用）。使用并发收集器。</p>
</li>
<li><p> 官方推荐使用 G1 收集器，性能较好。现在的互联网项目，基本都是使用 G1 。</p>
</li>
</ol>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><ul>
<li>  垃圾回收的算法有哪些？</li>
<li>  如何判断一个对象可回收？</li>
<li>  垃圾回收器工作的基本流程？</li>
</ul>
<h2 id="10-GC-日志分析"><a href="#10-GC-日志分析" class="headerlink" title="10    GC 日志分析"></a>10    GC 日志分析</h2><p>通过阅读 GC 日志，我们可以了解 Java 虚拟机内存分配与回收策略。</p>
<p>常见的参数设置：</p>
<ul>
<li>  <code>-XX:+PrintGC</code> ：输出 GC 日志</li>
<li>  <code>-XX:+PrintGCDetails</code> ：输出 GC 日志的详细信息</li>
<li>  <code>-XX:+PrintGCTimeStamps</code> ：输出 GC 的时间戳（以基准时间的形式）</li>
<li>  <code>-XX:+PrintGCDateStamps</code> ：输出 GC 的时间戳（以日期的形式，如 2021-06-20T18:45:32.234+0800）</li>
<li>  <code>-XX:+PrintHeapAtGC</code> ：在进行 GC 的前后打印出堆的信息</li>
<li>  <code>-Xloggc:../logs/gc.log</code> ：将日志文件输出到指定路径</li>
</ul>
<h2 id="10-垃圾回收器新发展"><a href="#10-垃圾回收器新发展" class="headerlink" title="10  垃圾回收器新发展"></a>10  垃圾回收器新发展</h2><p>垃圾回收器仍然处于飞速发展之中，目前的默认选项 G1 在不断的进行改进，很多我们原来认为的缺点。例如串行的 Full GC、Card Table 扫描的低效性等，都已经被大幅改进，例如，JDK10 之后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行实现。</p>
<p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关的数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<strong>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台</strong>。</p>
<p>比较不幸的是 CMS，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但是在 JDK9 中就已经被标记为废弃，并在 JDK14 中被完全移出。</p>
<h3 id="Open-JDK12-中的-Shenandoah-GC"><a href="#Open-JDK12-中的-Shenandoah-GC" class="headerlink" title="Open_JDK12 中的 Shenandoah_GC"></a>Open_JDK12 中的 Shenandoah_GC</h3><blockquote>
<p>  Open_JDK12 中的 Shenandoah_GC：低停顿时间的垃圾回收器（实验性）</p>
</blockquote>
<p>Shenandoah_GC 无疑众多 GC 中最孤独的一个。是第一款不由 Oracle 公司团队领导开发的 HotSpot 垃圾收集器，不可避免的受到官方的排挤。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司拒绝在 OracleJDK12 中支持 Shenandoah。</p>
<p>Shenandoah 垃圾回收器最初是由 RedHat 进行的一项垃圾回收器研究项目 Pauseless_GC 的实现。旨在针对 JVM 上的内存回收实现低停顿的需求。在 2014 年贡献给 OpenJDK。</p>
<p>Red_Hat 研发 Shenandoah 的团队对外<strong>宣称，****Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9% 的目标都可以把垃圾收集的停顿时间限制在 10ms 以内</strong>。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>  Shenandoah_GC 的弱项：高运行负载下的吞吐量下降</li>
<li>  Shenandoah_GC 的强项：低延迟时间</li>
</ul>
<h3 id="令人震惊、革命性的ZGC"><a href="#令人震惊、革命性的ZGC" class="headerlink" title="令人震惊、革命性的ZGC"></a>令人震惊、革命性的ZGC</h3><ul>
<li>  ZGC 与 Shenandoah 目标高度相似，<strong>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在 10ms 以内的低延迟</strong>。</li>
<li>  ZGC 是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记-压缩算法</strong>的，以<strong>低延迟为首要目标</strong>的一款垃圾收集器。</li>
<li>  ZGC 的工作过程可分为 4 个阶段：<strong>1、并发标记  2、并发预备重分配  3、并发重分配  4、并发重映射</strong></li>
<li>  ZGC 几乎在所有的地方都是并发执行的，除了<strong>初始标记是 STW 的</strong>。所以停顿时间几乎就耗费在初始标记上，这部分时间实际是非常少的。</li>
<li>  JDK15 将 ZGC 加入了生产环境。</li>
<li>  使用： <code>-XX:+UseZGC</code> </li>
</ul>
<h1 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h1><blockquote>
<p>  蚂蚁金服</p>
</blockquote>
<ol>
<li> 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms 和 g1</li>
<li> JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法</li>
<li> G1 回收器讲一下回收过程</li>
<li> GC 是什么？为什么要有 GC ？</li>
<li> GC 的两种判定方法？ CMS 收集器与 G1 收集器的特点？</li>
</ol>
<blockquote>
<p>  百度</p>
</blockquote>
<ol>
<li> 说一下GC算法？分代回收说一下？</li>
<li> 垃圾收集策略和算法？</li>
</ol>
<blockquote>
<p>  天猫</p>
</blockquote>
<ol>
<li> JVM GC 原理？JVM 怎么回收内存？</li>
<li> CMS 特点，垃圾收集算法有哪些？各自的优缺点，它们共同的缺点是什么？</li>
</ol>
<blockquote>
<p>  滴滴</p>
</blockquote>
<ol>
<li> Java的垃圾收集器有哪些？说一下 G1 的应用场景，平时你是如何搭配使用垃圾收集器的？</li>
</ol>
<blockquote>
<p>  京东</p>
</blockquote>
<ol>
<li> 你知道哪几种垃圾收集器？各自的优缺点？重点讲下 cms 和 g1 ，包括原理、流程、优缺点。</li>
<li> 垃圾收集器算法的实现原理</li>
</ol>
<blockquote>
<p>  阿里</p>
</blockquote>
<ol>
<li> 讲一下垃圾回收算法</li>
<li> 什么情况下触发垃圾回收</li>
<li> 如何选择合适的垃圾回收算法</li>
<li> JVM有哪几种垃圾回收器</li>
</ol>
<blockquote>
<p>  字节跳动</p>
</blockquote>
<ol>
<li> 常见的垃圾收集器算法有哪些？各有什么优缺点？</li>
<li> system.gc() 和 runtime.gc() 会做什么事情？</li>
<li> Java GC 机制？GC Roots 有哪些？</li>
<li> Java 对象的回收方式，回收算法</li>
<li> GMC 和 G1，CMS解决什么问题，说一下回收的过程。</li>
<li> CMS 回收停顿了几次？为什么要停顿两次？</li>
</ol>
<p>​        对于 G1 这种分拆成为大量 region 的垃圾收集器，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小。</p>
<p>​        在栈空间中保存堆中对象的引用，若使用复制算法，每进行一次 GC 就会导致堆中对象的地址值发生一次变化，这时就必须重新维护栈中对象的地址，这个开销也是很大的。</p>
<hr>
<p>​        以 CMS（Concurrent-Mark-Sweep）回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高（相较于 Mark-Sweep-Compact 算法）。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure）时，将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</p>
<p>分代思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分老年代和新生代。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/14/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/14/%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-14 12:34:55" itemprop="dateCreated datePublished" datetime="2021-06-14T12:34:55+08:00">2021-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-06-16 22:47:16" itemprop="dateModified" datetime="2021-06-16T22:47:16+08:00">2021-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/2021/06/14/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8.png" alt="链表"></p>
<h1 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h1><h2 id="单链表节点定义"><a href="#单链表节点定义" class="headerlink" title="单链表节点定义"></a>单链表节点定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object data;	<span class="comment">//  节点#data域</span></span><br><span class="line">    <span class="keyword">public</span> LNode next;	<span class="comment">//  节点#next域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><h2 id="为什么要有双链表（单链表的缺点）"><a href="#为什么要有双链表（单链表的缺点）" class="headerlink" title="为什么要有双链表（单链表的缺点）"></a>为什么要有双链表（单链表的缺点）</h2><ul>
<li><p>  单链表，查找的方向只能是一个方向（从头到尾），而双向链表可以向前或向后查找</p>
</li>
<li><p>单向链表，不能自我删除，需要靠辅助节点；而双向链表则可以自我删除。</p>
<p>  单链表删除时，总会找到 temp（temp 是待删除节点的前一个节点）节点来帮助删除。</p>
</li>
</ul>
<h2 id="双链表节点的定义"><a href="#双链表节点的定义" class="headerlink" title="双链表节点的定义"></a>双链表节点的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object data;		<span class="comment">//  节点#data域</span></span><br><span class="line">    <span class="keyword">public</span> DLNode prior;	<span class="comment">//  指向前驱节点的指针</span></span><br><span class="line">    <span class="keyword">public</span> DLNode next;		<span class="comment">//  指向后继节点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双链表的基础操作"><a href="#双链表的基础操作" class="headerlink" title="双链表的基础操作"></a>双链表的基础操作</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>​    双向链表的遍历方式和单链表一样，只是在遍历的过程中可以向前查找，也可以向后查找。单向链表只能向后查找，例如我们当前遍历到链表的第5个节点，在单向链表中我们只能够继续向后查找5之后的节点，但是在双向链表中，我们既可以查找5之后的节点，也可以返回去查找5之前的节点。</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><h4 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h4><ol>
<li> 首先，找到当前链表的尾节点 temp；</li>
<li> 让尾节点的 next 指针指向要添加的新节点，即 <code>temp.next = newDLNode</code>；</li>
<li> 让新节点的 prior 指针指向尾节点，即 <code>newDLNode.prior = temp</code></li>
</ol>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>​    修改思路也和单向链表一致</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>​    因为是双向链表，因此，我们可以实现自我删除某个节点。</p>
<ol>
<li> 找到待删除的节点 temp；</li>
<li> 让待删除节点前一个节点的 next 指针指向待删除节点后一个节点，即 <code>temp.prior.next = temp.next</code>；</li>
<li>让待删除节点后一个节点的 prior 指针指向待删除节点的前一个节点，即 <code>temp.next.prior = temp.prior</code> 。<ul>
<li>  如果待删除的节点是链表的尾节点，就不需要执行第 3 步了，否则会出现空指针异常。</li>
</ul>
</li>
</ol>
<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h2 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h2><blockquote>
<p>  <strong>应用场景：约瑟夫（Josephu）问题</strong></p>
</blockquote>
<p>​        Josephu 问题：设编号为 1，2，3，…….，n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，他的下一位又从 1 开始报数，数到 m 的那个人又出列。以此类推，直到所有人都出列为止。据此产生一个出队编号的序列。</p>
<blockquote>
<p>  <strong>思路</strong></p>
</blockquote>
<p>​        用一个不带头结点的循环链表来处理 Josephu 问题，先构成一个有 n 个节点的单循环链表，然后由 k 节点起从 1 开始计数，记到 m 时，对应节点从链表中删除，然后再从被删除节点的下一个节点又从 1 开始计数，直到最后一个节点从链表中删除算法结束。</p>
<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
<p>​        根据用户的输入，要形成一个小朋友出队的顺序。假设 </p>
<ul>
<li>  <code>n=5</code>，即共有 5 人</li>
<li>  <code>k=1</code>，编号为 1 的人从 1 开始报数</li>
<li>  <code>m=2</code>，报数为 2 的人出列，他的下一位又从 1 开始报数</li>
</ul>
<ol>
<li><p> 因为存在出队行为，所以需要执行单链表的删除操作，也就是说需要一个辅助指针 <code>helper</code> 指向待删除节点的前一个节点。 <code>first</code> 指针从头开始遍历，所以 <code>helper</code> 指针需要事先指向 <code>first</code> 指向节点的前一个节点（即单向链表的最后一个节点），并且 <code>helper</code> 指针紧跟 <code>first</code> 指针同步遍历。</p>
</li>
<li><p> 报数前，先让 <code>first</code> 和 <code>helper</code> 移动 <code>k-1</code> 次。</p>
</li>
<li><p> 当小朋友报数时，让 <code>first</code> 和 <code>helper</code> 指针同时移动 <code>m-1</code> 次，因为小朋友报数时，自己需要占一次。</p>
</li>
<li><p>这时就可以将 <code>first</code> 指向的节点出队。两种方式：</p>
<ol>
<li> <code>first = first.next;  helper.next = first</code></li>
<li><code>helper.next = first.next;  first = first.next</code></li>
</ol>
</li>
</ol>
<h2 id="单向环形链表的操作"><a href="#单向环形链表的操作" class="headerlink" title="单向环形链表的操作"></a>单向环形链表的操作</h2><h3 id="构建一个单向环形链表"><a href="#构建一个单向环形链表" class="headerlink" title="构建一个单向环形链表"></a>构建一个单向环形链表</h3><ol>
<li> 先创建链表的第一个节点，让 <code>first</code> 指针指向该节点，让第一个节点的 <code>next</code> 指针指向自己，自我连接形成环状。</li>
<li> 每增加一个新的节点，就把新节点加入到已有的环形链表中即可。</li>
</ol>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li> 创建一个辅助指针 <code>current</code> 与 <code>first</code> 指针指向同一个节点。</li>
<li> 通过 while 循环遍历环形链表，但 <code>current</code> 指针再次与 <code>first</code> 指向同一个节点时循环结束。</li>
</ol>
<h3 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h3><h2 id="双向环形链表"><a href="#双向环形链表" class="headerlink" title="双向环形链表"></a>双向环形链表</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/13/String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/13/String/" class="post-title-link" itemprop="url">String</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-13 11:42:39" itemprop="dateCreated datePublished" datetime="2021-06-13T11:42:39+08:00">2021-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-07-31 17:57:19" itemprop="dateModified" datetime="2021-07-31T17:57:19+08:00">2021-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  本文默认使用 HotSpot 虚拟机 + JDK8 ，如有其它情况会具体指出。</p>
</blockquote>
<h1 id="1-String-的基本特性"><a href="#1-String-的基本特性" class="headerlink" title="1  String 的基本特性"></a>1  String 的基本特性</h1><blockquote>
<p>  <strong>String；字符串；</strong></p>
</blockquote>
<p>顾名思义，就是把一个个的字符串在一起，所以说<strong>字符串的底层实现就是一个字符数组</strong>。</p>
<img src="/2021/06/13/String/1623398509911-a4c2e130-bfc9-4aa7-9a9d-531df6e1cdee.png" alt="image.png">

<ul>
<li>  String 被声明为 <strong>final</strong> 的表示类不可被继承。</li>
<li>  String 实现了 <strong>Serializable</strong> 接口，表示字符串是支持序列化的。</li>
<li>  String 实现了 <strong>Comparable</strong> 接口，表示 String 可以比较大小。</li>
<li>  在 JDK8 中，String 使用字符数组 <strong>final char[] value</strong> 数组来存储字符串数据。</li>
</ul>
<h2 id="1-1-String-存储结构的演变"><a href="#1-1-String-存储结构的演变" class="headerlink" title="1.1    String 存储结构的演变"></a>1.1    String 存储结构的演变</h2><ul>
<li>  在 JDK9 之前，String 底层是通过<strong>字符数组 <code>char[]</code></strong> 来保存字符串的。</li>
<li>  从 <strong>JDK9</strong> 开始，String 底层变成了通过<strong>字节数组 <code>byte[]</code></strong> 来保存字符串数据。【字符型 char 编码后都可以用数字（byte型）表示】</li>
</ul>
<blockquote>
<p>  <strong>为什么要变化？</strong></p>
</blockquote>
<p>String 底层将 <code>char[]</code> 变成 <code>byte[]</code> 来存储字符串数据，可以节约一些空间。</p>
<p>同时，String 的一些衍生对象，如 StringBuffer、StringBuilder 等也作出了同样的改变，将存储结构变更为了 byte[] 。</p>
<hr>
<h2 id="1-2-String-的不可变性"><a href="#1-2-String-的不可变性" class="headerlink" title="1.2    String 的不可变性"></a>1.2    String 的不可变性</h2><blockquote>
<p>  String：<strong>不可变的字符序列</strong></p>
</blockquote>
<ul>
<li>  当对字符串<strong>重新赋值</strong>时，会重新分配内存区域，重新赋值，而不是在原先 <code>value[]</code> 的基础上进行更新。</li>
<li>  当对现有的字符串进行<strong>拼接</strong>操作时，也是重新分配内存区域，重新赋值，而不是在原先 <code>value[]</code> 的基础上进行拼接、赋值。</li>
<li>  当<strong>调用 <code>String replace(char oldChar, char newChar)</code> 方法</strong>使用新字符串替换当前字符串指定的子串时，也是重新分配内存区域并重新赋值，而不能在原先字符串数组 <code>value[]</code> 的基础上进行操作。</li>
</ul>
<blockquote>
<p>  <strong>String 字符串为什么不能直接拼接字符串？【==String为什么设计成不可变的？】</strong></p>
</blockquote>
<p>String 的底层数据结构是 <code>char[]</code> 或 <code>byte[]</code>，由于<strong>数组的定长性</strong>，即一旦被创建出来，它的长度就就确定了，不能再被更改。在进行字符串拼接操作时，原数组的容量显然是不足以容纳拼接后的新数组的，所以只能新开辟一块更大的空间保存新的字符串，而不是去改变原有的字符串。【如果新数组的长度小于原数组，又会导致数组存在多个空白区域，造成内存的浪费，也是不合理的】</p>
<hr>
<h1 id="2-String-的内存分配"><a href="#2-String-的内存分配" class="headerlink" title="2  String 的内存分配"></a>2  String 的内存分配</h1><h2 id="String-对象可以保存在内存中的哪些位置"><a href="#String-对象可以保存在内存中的哪些位置" class="headerlink" title="String 对象可以保存在内存中的哪些位置"></a>String 对象可以保存在内存中的哪些位置</h2><blockquote>
<p>  <strong>String 对象可以保存在内存中的哪些位置?</strong></p>
</blockquote>
<ol>
<li> 字符串常量池中；</li>
<li> 堆中(的非字符串常量池空间)；</li>
<li> 二者都保存</li>
</ol>
<hr>
<h2 id="不同版本-JDK-中-StringPool-在内存中的调整"><a href="#不同版本-JDK-中-StringPool-在内存中的调整" class="headerlink" title="不同版本 JDK 中 StringPool 在内存中的调整"></a>不同版本 JDK 中 StringPool 在内存中的调整</h2><ul>
<li>  在 JDK7 之前，字符串常量池存放在<strong>方法区</strong>中（在 HotSpot 中就是永久代）。</li>
<li>  JDK7，HotSpot 将字符串常量池的位置调整到了<strong>堆</strong>中。</li>
<li>  JDK8：字符串常量池存储在方法区（元空间）</li>
</ul>
<blockquote>
<p>  <strong>问题：String Pool 为什么要从方法区调整到堆空间中？</strong></p>
</blockquote>
<p><strong>保存在方法区的缺点</strong>：</p>
<ol>
<li> 方法区（永久代/元空间）默认占用的内存空间较小，如果在方法区中保存大量的 String 对象，极易导致方法区空间出现 OOM  异常。</li>
<li> 即使将方法区初始的内存空间设置为一个较高的值，但是由于方法区进行 GC 的频率极低，这也就意味着在方法区中，String 对象在使用完后，无法做到及时的 GC，也会导致方法区频繁出现 OOM 异常。</li>
</ol>
<p><strong>保存在堆空间的优点</strong>：</p>
<ol>
<li> 首先堆空间解决了保存在方法区时的两个问题：①内存空间小。  ②GC不及时。</li>
<li> 所有的 String 字面量对象都保存在堆（Heap）中，它就和其它普通对象一样，这样的好处就是在进行 JVM 调优时只需调整堆的大小就可以了。【原来保存在元空间中时还要特意为了 String 常量池去进行元空间的性能调优】</li>
</ol>
<hr>
<h2 id="2-1-字符串常量池的数据结构"><a href="#2-1-字符串常量池的数据结构" class="headerlink" title="2.1    字符串常量池的数据结构"></a>2.1    字符串常量池的数据结构</h2><blockquote>
<p>  <strong>字符串常量池数据结构</strong></p>
</blockquote>
<ul>
<li>  通过字面量的方式<strong>（区别于 new）</strong>给一个字符串赋值，此时字符串的值保存在堆空间的字符串常量池中。</li>
<li>  <strong>字符串常量池的底层数据结构是一个 HashTable，所以说字符串常量池中不会存储相同内容的字符串</strong> 。</li>
<li>  String 的 StringPool 是一个固定大小的 HashTable，数组的默认长度在不同的 JDK 版本中均有所不同。</li>
<li>  如果放进 StringPool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后就会导致调用 <code>String.intern()</code> 时性能大幅下降。</li>
</ul>
<p><strong>参数信息：</strong></p>
<ul>
<li>  使用 <code>-XX:StringTableSize</code> 可以设置 StringPool 的长度。</li>
<li>  JDK6中，StringPool 的默认长度为 1009，可以任意设置大小；</li>
<li>  从 JDK7 开始，StringPool 的默认长度增加到了 60013 ；</li>
<li>  从 JDK8 开始，可设置的最小长度为 1009 。</li>
</ul>
<blockquote>
<p>  <strong>具体代码分析</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol>
<li> 由于字符串常量池在堆空间中，所以一个程序中所有的线程用的是同一个字符串常量池；</li>
<li> 由于字符串常量池底层是 HashTable 结构，所以池中不会出现重复的字符串，所以上述代码中的变量 <code>s1</code> 和 <code>s2</code> 指向的是同一个地址。</li>
<li> 由于字符串的不可变性，第 5 行代码中等号右边的语句会在字符串常量池中新开辟一块内存空间用于保存字符串“hello”，并将其赋值给等号左边的变量 s1。</li>
<li> 所以此时 s1 指向的是 “hello”  的地址，而 s2 指向的 “abc” 的地址，两者不相等。</li>
</ol>
<hr>
<h2 id="2-2-如何将字符串对象保存到字符串常量池中"><a href="#2-2-如何将字符串对象保存到字符串常量池中" class="headerlink" title="2.2    如何将字符串对象保存到字符串常量池中"></a>2.2    如何将字符串对象保存到字符串常量池中</h2><p>​        对于 Java 中的 8 种基本数据类型和引用类型 String，这些类型在程序中的使用是非常频繁的（二八原则），为了使这些类型的数据在内存中速度更快、更节省内存，都提供了一种常量池的概念。    </p>
<p>​        常量池就类似于一个 Java 系统级别提供的缓存。8 种基本类型数据的常量池都是系统协调的，String类型的常量池比较特殊，想要<strong>将字符串对象保存在字符串常量中主要方法有两种</strong> ：</p>
<ol>
<li>直接使用双引号声明出来的 String 对象（字符串字面量对象）会直接存储在常量池中。<ul>
<li>  比如： <code>String info = &quot;HelloWorld&quot;;</code> </li>
</ul>
</li>
<li> 如果不是通过双引号声明的 String 对象，也可以使用 String 提供的 <strong>intern()</strong> 方法将某个字符串对象加入到字符串常量池中。</li>
</ol>
<hr>
<h1 id="4-字符串拼接操作"><a href="#4-字符串拼接操作" class="headerlink" title="4  字符串拼接操作"></a>4  字符串拼接操作</h1><blockquote>
<ul>
<li>  字符串常量 + 字符串常量</li>
<li>  字符串常量 + 字符串变量</li>
<li>  字符串变量 + 字符串变量</li>
</ul>
</blockquote>
<h2 id="常量-常量"><a href="#常量-常量" class="headerlink" title="常量 + 常量"></a>常量 + 常量</h2><ul>
<li>  常量与常量的拼接结果还保存在字符串常量池中，原理是编译期优化。</li>
<li>  编译期优化：</li>
</ul>
<blockquote>
<p>  <strong>问题：如何理解“编译期优化”？</strong></p>
</blockquote>
<p>答：两个字符串常量相加，在被编译成 <code>.class</code> 字节码文件时就已经将这两个常量拼接为一个常量字面量了，所以加载到内存中的只有一个字符串字面量来，所以会将这个字符串字面量保存到字符串常量池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;    <span class="comment">// 在编译后，就等同于 &quot;abc&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  .java 文件需要先被编译成 .class 字节码文件，再被加载到JVM中执行。</span></span><br><span class="line"><span class="comment">     *      在 .class 文件中，s1 已经是一个拼接过的常量了。即</span></span><br><span class="line"><span class="comment">     *          String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     *          String s2 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     *      所以在将字节码文件加载到 JVM 中运行时这两个常量都会保存在堆空间的常量池中，</span></span><br><span class="line"><span class="comment">     *	 并且常量池中不允许出现重复的元素，所以说 s1 和 s2 指向同一个对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2);   <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s2));      <span class="comment">// true</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<hr>
<h2 id="常量-变量-变量"><a href="#常量-变量-变量" class="headerlink" title="常量/变量 +变量"></a>常量/变量 +变量</h2><ul>
<li>  常量池中不会保存相同内容的字面量对象。</li>
</ul>
<blockquote>
<p>  <strong>结论：</strong></p>
</blockquote>
<ul>
<li>  在多个字符串拼接操作中，只要存在变量，结果就<strong>只会</strong>保存在堆中的非常量池区域。</li>
<li>  <strong>Tip：此时拼接后的 String 对象只会保存在堆中的非常量池区域，而不会同步保存到字符串常量池中！！！</strong></li>
</ul>
<blockquote>
<p>  <strong>原理：</strong>字符串拼接操作底层是通过 <code>StringBuilder#append()</code> 方法实现的。</p>
</blockquote>
<p>在多个字符串拼接操作中，只要存在变量，那么 JVM 在进行字符串拼接的时候，</p>
<ol>
<li> 首先会 <code>new StringBuilder()</code> 对象，</li>
<li> 然后调用该对象中的 <code>append()</code> 方法拼接字符串，</li>
<li> 最后再调用  <code>StringBuilder#toString()</code> 方法，将拼接后的字符串对象转换成 String 对象，并将这个 String 对象保存在堆中(的非常量池区域)。</li>
</ol>
<blockquote>
<p>  <strong>代码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + s2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        s1 + s2 的执行细节：</span></span><br><span class="line"><span class="comment">            1、StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="comment">            2、sb.append(s1);</span></span><br><span class="line"><span class="comment">            3、sb.append(s2);</span></span><br><span class="line"><span class="comment">            4、sb.toString();  --&gt;&gt; 类似于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  最终 s4 指向的地址是在第 4 步的 <code>sb.toString()</code> 中确定的，这个方法类似于 <code>new String()</code>，但是并不相同。</li>
<li>  <strong>使用 <code>new String()</code> 创建出来的 String 对象会同时保存在堆和字符串常量池中</strong>，而 <code>StringBuilder#toString()</code> 方法生成的 String 对象只保存在堆中(的非常量池区域)。</li>
</ul>
<blockquote>
<p>  <strong>Tip</strong>：</p>
</blockquote>
<ul>
<li>  在 JDK5 之前，含有变量的字符串拼接操作，底层使用的类是 StringBuffer，<em>因为 JDK5 之前并没有 StringBuilder 这个类</em>；</li>
<li>  从 JDK5 开始，才使用 StringBuilder 代替 StringBuffer 来完成含有变量的字符串拼接操作。</li>
</ul>
<blockquote>
<p>  <strong>字节码文件</strong></p>
</blockquote>
<p><img src="/2021/06/13/String/1623478701279-d327aa0f-fdc0-47a9-a63e-e310317f7271.png" alt="test.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">2</span> &lt;a&gt;   <span class="comment">// 在字符串常量池中创建一个字面量对象&lt;a&gt;，并得到该字面量对象的内存地址</span></span><br><span class="line"> <span class="number">2</span> astore_1     <span class="comment">// 将字面量&lt;a&gt;的内存地址保存到栈中栈帧的局部变量表中下标为 1 的位置上</span></span><br><span class="line"> <span class="number">3</span> ldc #<span class="number">3</span> &lt;b&gt;  </span><br><span class="line"> <span class="number">5</span> astore_2     </span><br><span class="line"> <span class="number">6</span> ldc #<span class="number">4</span> &lt;ab&gt;  </span><br><span class="line"> <span class="number">8</span> astore_3    </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/* 创建 StringBuilder 对象开始 */</span></span><br><span class="line"> <span class="number">9</span> <span class="keyword">new</span> #<span class="number">5</span> &lt;java/lang/StringBuilder&gt; </span><br><span class="line"><span class="number">12</span> dup</span><br><span class="line"><span class="number">13</span> invokespecial #<span class="number">6</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="comment">/*  创建 StringBuilder 对象结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span> aload_1  <span class="comment">// 取出局部变量表中下标为1的位置上的值，即常量池中字面量对象&lt;a&gt;的地址值</span></span><br><span class="line"><span class="number">17</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;    <span class="comment">// 调用 StringBuilder#append() 将该值追加到 StringBuilder 对象中</span></span><br><span class="line"><span class="number">20</span> aload_2  </span><br><span class="line"><span class="number">21</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">     </span><br><span class="line"><span class="number">24</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.toString&gt;  <span class="comment">// 调用 StringBuilder#toString() 将StringBuilder对象转化为String对象</span></span><br><span class="line"><span class="number">27</span> astore <span class="number">4</span> <span class="comment">// 将上一条指令得到的String对象的内存地址值保存到局部变量表下标为4的位置上</span></span><br><span class="line"></span><br><span class="line"><span class="number">29</span> <span class="keyword">new</span> #<span class="number">5</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">32</span> dup</span><br><span class="line"><span class="number">33</span> invokespecial #<span class="number">6</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">36</span> ldc #<span class="number">2</span> &lt;a&gt;   <span class="comment">// 从常量池中得到字符串常量&lt;a&gt;</span></span><br><span class="line"><span class="number">38</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;    </span><br><span class="line"><span class="number">41</span> aload_2      </span><br><span class="line"><span class="number">42</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;    </span><br><span class="line"><span class="number">45</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.toString&gt;  </span><br><span class="line"><span class="number">48</span> astore <span class="number">5</span>     </span><br><span class="line">     </span><br><span class="line"><span class="number">50</span> <span class="keyword">return</span>   <span class="comment">// 返回</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="特殊情况：final-修饰的变量"><a href="#特殊情况：final-修饰的变量" class="headerlink" title="特殊情况：final 修饰的变量"></a>特殊情况：final 修饰的变量</h2><p>使用 <code>final</code> 修饰的变量等价于常量，因为在 <code>.java</code> 源文件在编译成 <code>.class</code> 字节码文件的时候就已经把 <code>final</code> 修饰的变量转换成常量值了（编译期优化）。也就是说加载到内存中的就是字符串字面量常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);  <span class="comment">// true</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用 final 修饰的变量，在编译成字节码文件的时候就已经把这些变量转换成常量了（编译期优化），</span></span><br><span class="line"><span class="comment">        也就是说加载到内存中的是常量字符串，常量与常量的拼接自然保存在常量池中。</span></span><br><span class="line"><span class="comment">        所以可以得到 s3==s4 为 true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>如果拼接的结果调用 <code>intern()</code> 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象在常量池中的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;   <span class="comment">// String Pool；poolAddress[0]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;   <span class="comment">// String Pool；poolAddress[1]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;     <span class="comment">// String Pool；poolAddress[2]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;    <span class="comment">// String Pool；poolAddress[2]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;  <span class="comment">// Not String Pool； heapAddress[0]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;  <span class="comment">// Not String Pool; heapAddress[1]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;    <span class="comment">// Not String Pool; heapAddress[2]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();    <span class="comment">// String Pool；poolAddress[2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     *      s1 保存在字符串常量池中，地址为 poolAddress[0]；</span></span><br><span class="line"><span class="comment">     *      s2 保存在字符串常量池中，地址为 poolAddress[1]；</span></span><br><span class="line"><span class="comment">     *      s3 保存在字符串常量池中，地址为 poolAddress[2]；</span></span><br><span class="line"><span class="comment">     *      s4 是两个常量的拼接，由于编译期优化，结果仍保存在常量池中，并且地址为 poolAddress[2]；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      s5 是 变量+常量 的拼接，结果只会保存在堆中的非常量池区域，所以 s5 的地址为 heapAddress[0]；</span></span><br><span class="line"><span class="comment">     *      s6 也是 变量+常量 的拼接，结果会保存在堆中的非常量池区域，并且在非常量池区域并没有要求相同的值只能保存一份数据，所以 s6 会占用一块新的内存空间，地址为 heapAddress[1]；</span></span><br><span class="line"><span class="comment">     *      s7 也是 变量+变量 的拼接，结果会保存在堆中的非常量池区域，原理同 s6 一样，s7 的地址为 heapAddress[2]；</span></span><br><span class="line"><span class="comment">     *      s8 是 s6 调用 intern() 方法得到的返回值，由于s6对应的字符串字面量在常量池中已经存在了，所以 s8 的地址值为 poolAddress[2];</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);   <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s5);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s6);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s7);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s6);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s7);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s6 == s7);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s8);   <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="5-intern-方法"><a href="#5-intern-方法" class="headerlink" title="5  intern() 方法"></a>5  intern() 方法</h1><h2 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h2><blockquote>
<p>  <strong>源码分析</strong></p>
</blockquote>
<p><img src="/2021/06/13/String/1623488782339-dd95c67e-52d3-4dfd-887b-52ed4e499a47.png" alt="image.png"></p>
<p>​        <strong>intern()</strong> 方法是 String 类中的一个方法，查看源码可知，<code>String#intern()</code> 方法是一个 <code>native</code> 修饰的本地方法。也就是说，其具体实现是由 C/C++ 编写的。</p>
<blockquote>
<p>  <strong>主要作用：</strong></p>
</blockquote>
<p>现有一个字符串对象 <code>String s1</code> ，当调用 <code>s1.intern()</code> 方法时，</p>
<ol>
<li> 首先要去判断字符串常量池中是否已经存在一个 String 对象其字面量与 s1 的字面量相同；</li>
<li> 如果存在，那么就返回字符串常量池中该 String 对象的地址；</li>
<li> 如果不存在，就将 s1 对象的字面量值拷贝一份到字符串常量池中，并返回该 String 对象在字符串常量池中的地址。</li>
</ol>
<blockquote>
<p>  <strong>Tip：</strong></p>
</blockquote>
<p>调用 <code>String#intern()</code> 方法可以确保字符串在内存中只有一份数据，这样可以节约内存空间，加快字符串操作任务的执行速度。</p>
<p><strong>分析：</strong></p>
<ul>
<li>  调用 <code>String#intern()</code> 方法后，如果 String 对象原本就保存在字符串常量池中，那不会有任何改变；</li>
<li>  如果 String 对象原本保存在堆(的非字符串常量池区域)中，那么调用此方法后，就会返回一个字符串常量池中对象的地址。</li>
<li>  这时就可以把原来堆(的非字符串常量池区域)中的 String 对象回收掉，让内存中只保留一份字符串字面量数据。【这一步不是必须的】</li>
</ul>
<hr>
<h2 id="intern-的使用场景"><a href="#intern-的使用场景" class="headerlink" title="intern() 的使用场景"></a>intern() 的使用场景</h2><p>如果不是通过字符串字面量（即双引号）创建的 String 对象，如果想要将其保存到字符串常量池中，可以使用 String 提供的 intern() 方法。</p>
<blockquote>
<p>  <strong>问题：如何保证字符串变量 s 指向的字符串是字符串常量池中的数据而不是堆中非常量池区域的数据呢？</strong></p>
</blockquote>
<p>答：有2种方式</p>
<ol>
<li> 直接通过双引号而不是 new 关键字来创建 String 对象。如：<code>String s = &quot;HelloWorld&quot;;</code></li>
<li> 对堆中的字符串对象，调用 <code>intern()</code> 方法，得到的返回值就是指向字符串常量池中对应字符串字面量的地址。</li>
</ol>
<blockquote>
<p>  <strong>问题：<code>new String(&quot;HelloWorld&quot;)</code> 会创建几个对象？</strong> </p>
</blockquote>
<p>答：如果在此之前，字符串常量池中已有字面量对象 <code>“HelloWorld”</code>，则只会在堆中新建 1 个对象；否则会新建 2 个对象，一个保存在堆中非字符串常量池区域（和普通对象一样），另一个保存在字符串常量池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	创建动作分解：</span></span><br><span class="line"><span class="comment">    	1、new String()  堆中；</span></span><br><span class="line"><span class="comment">    	2、&quot;HelloWorld&quot;  字符串常量池中；</span></span><br><span class="line"><span class="comment">    	3、执行堆中的 String 对象的初始化方法；</span></span><br><span class="line"><span class="comment">    	4、将等式左边的地址赋值给等式右边的变量。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 首先，在堆中非常量池区域中创建一个 String 对象。</li>
<li> 其次，在字符串常量池中创建字面量为 <code>&quot;HelloWorld&quot;</code> 的字面量对象。</li>
<li> 再次，调用 String 类的构造方法，对字符串对象 s 进行显式初始化；</li>
<li> 最后，将结果地址保存到局部变量表下标为 1 的位置上。</li>
<li> <strong>注意：虽然现在字符串常量池和堆中都有“HelloWorld”这个字符串对象，但是此时 s 得到的地址是堆中的！！！</strong></li>
</ol>
<p><img src="/2021/06/13/String/1623491535138-3562077b-906b-41ae-aaee-49806b528949.png" alt="image.png"></p>
<blockquote>
<p>  <strong>扩展：<code>String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> 会创建多少个对象？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/13/String/1623492457552-7821a5f9-93b5-44b1-aabf-11514fb0ba93.png" alt="image.png"></p>
<p>分析：</p>
<ul>
<li>  对象1：<code>new StringBuilder()</code>， 首先，两个字符串变量拼接时，需要一个辅助对象 StringBuilder 。</li>
<li>  对象2：<code>new String(&quot;a&quot;)</code>，</li>
<li>  对象3：常量池中的字面量对象 “a”</li>
<li>  对象4：<code>new String(&quot;b&quot;)</code>，</li>
<li>  对象5：常量池中的字面量对象 “b”</li>
<li>  对象6：在调用 <code>StringBuilder.toString()</code> 方法时，根据 <code>toString()</code> 方法的源码，还要创建一个 String 对象。</li>
</ul>
<blockquote>
<p>  <strong>toString() 方法</strong></p>
</blockquote>
<p><strong>虽然 toString() 方法底层调用了 new String() 方法，但是却不会在字符串常量池中创建对应的字符串对象，只会在堆中创建字符串对象。</strong></p>
<p><img src="/2021/06/13/String/1623492807620-7f60184d-4382-4830-b450-95b9019c6051.png" alt="image.png"></p>
<blockquote>
<p>  <code>StringBuilder#toString()</code> 的字节码文件</p>
</blockquote>
<ul>
<li>  我们可以看到并没有在字符串常量池中创建 String 对象。</li>
</ul>
<p><img src="/2021/06/13/String/image-20210613173632473.png" alt="image-20210613173632473"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);    <span class="comment">// s1 --&gt;&gt; Not String Pool ；heapAddr[0]</span></span><br><span class="line">    s1.intern();    <span class="comment">// s1 --&gt;&gt; Not String Pool ；heapAddr[0]</span></span><br><span class="line">    			   <span class="comment">// s1.intern() 的返回值 --&gt;&gt; String Pool ； poolAddr[0]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;    <span class="comment">// s2 --&gt;&gt; String Pool ； poolAddr[0]</span></span><br><span class="line">    System.out.println(s1 == s2);   <span class="comment">// False</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ol>
<li><p>使用 <code>new</code> 关键字创建对象，</p>
<ul>
<li>  首先会在堆中非常量池区域分配内存保存字符串对象 “1” ；</li>
<li>  并且之后还会在常量池中分配内存保存字面量对象 “1” ;</li>
<li>  但是此时栈中局部变量表中的 s1 保存的是堆中非常量池区域的字符串对象的内存地址；</li>
</ul>
</li>
<li><p>调用 <code>s1.intern()</code> 方法，JVM 尝试在字符串常量池中创建值为 “1” 的字面量对象，发现已存在，得到该字面量对象的地址，作为方法的返回值。<code>intern()</code> 方法是有返回值的，返回值就是字面量对象 “1” 在字符串常量池中的内存地址，但是在本例中并没有接收这个地址，也就是说目前为止，s1 指向的仍然是堆中非常量池区域中那个字符串对象的内存地址。</p>
</li>
<li><p>直接使用双引号创建 String 对象，JVM 会尝试在字符串常量池中创建值为 “1” 的字面量对象，发现已存在，得到该字面量对象的地址，并将此字面量对象的内存地址保存在栈的局部变量表中，即此时 s2 指向字符串常量池中对应字面量对象的地址。</p>
</li>
<li><p>所以，<code>s1==s2</code> 结果为 False</p>
</li>
</ol>
<h3 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// s3 --&gt;&gt; Not String Pool ；heapAddr[1]</span></span><br><span class="line">       s3.intern();    <span class="comment">// // s3 --&gt;&gt; Not String Pool ；heapAddr[1]</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;    <span class="comment">// JDK6：String Pool ； poolAddr[1]  JDK7：Not String Pool ；heapAddr[1]</span></span><br><span class="line">       System.out.println(s3 == s4);   <span class="comment">// JDK6：False  JDK7：True</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>s3</code> 指向的对象是由两个字符串对象拼接而成的，在进行字符串拼接时，底层要借助 <code>StingBuilder</code> 实现。其中有一步需要使用 <code>StringBuilder#toString()</code> 方法将 <code>Stringbuilder</code> 对象转换成 <code>String</code> 对象，在使用 <code>toString()</code> 方法时，<strong>只</strong>会在堆中的非常量池区域创建一个 <code>String</code> 对象，并不会在常量池中创建这个对象对应的字面量对象（类似于 new，但不会同步到常量池中）。所以第 2 行代码在执行完毕后 <code>s3</code> 指向一个堆中的字符串对象。</li>
<li>由于此时字符串常量池中没有字面量对象 <code>“11”</code>，所以调用 <code>intern()</code> 方法会在常量池中创建一个字符串对象<code>“11&quot;</code>并返回其地址值。<ul>
<li>  在 JDK7 之前，由于字符串常量池不在堆空间中，所以会真正意义上的在字符串常量池创建一个字符串对象<code>“11”</code>并返回其地址值。</li>
<li>  从 JDK7 开始，由于字符串常量池也保存在堆空间中，所以这时不会在常量池中创建真正的字符串对象<code>“11”</code>了，而是直接拿来了 s3 对象的地址值。</li>
</ul>
</li>
<li>此处没有使用 <code>intern()</code> 方法的返回值，所以 s3 仍然指向堆中非常量池空间中的那个字符串对象的地址。</li>
<li>直接使用字面量创建String对象。由于此时字符串常量池中已有该字面量对象，所以不再新建对象，只是返回字面量对象的地址，而显然该字面量对象的地址是一个地址值，最后真正指向的对象还是堆中非常量池区域的那个String对象，而返回地址按照对象的就近原则也是堆中非常量池区域的String对象的地址值。</li>
<li>所以说， 在JDK7之前，<code>s3 == s4</code> 为 False；而从JDK7开始，<code>s3 == s4</code> 为 True</li>
</ol>
<img src="/2021/06/13/String/1623508433062-ce767a2e-fba1-4f8d-bd53-374635e01625.png" alt="intern的使用 (1).png" style="zoom: 67%;">





<h2 id="不同版本JDK中不同方式创建字符串对象的先后顺序的影响"><a href="#不同版本JDK中不同方式创建字符串对象的先后顺序的影响" class="headerlink" title="不同版本JDK中不同方式创建字符串对象的先后顺序的影响"></a>不同版本JDK中不同方式创建字符串对象的先后顺序的影响</h2><ol>
<li> 如果只想在堆的非字符串常量池区域创建对象： <code>String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> 此时字符串常量池中没有“ab”对应的字面量对象。</li>
<li>如果这时继续在常量池中也保存一份 “ab” 字符串对应的字面量对象。可以调用 <code>s1.intern();</code> 方法。<ul>
<li>  从 JDK7 开始，为了节省内存，在常量池中创建字符串对象这一步，如果在堆的非常量池区域存在相同字面量值的对象，就不再创建一个“真正”的字面量对象了，而是在常量池的字面量对象的地址中保存堆中非常量池区域那个对象的地址值。</li>
<li>  而在 JDK7 之前，在常量池中创建的对象时真正意义上的字面量对象，保存的是真正的数据值，而不是对象的引用。</li>
</ul>
</li>
<li> 如果使用 <code>String s1 = new String(&quot;1&quot;);</code> 创建对象，这时会创建两个对象，即字符串常量池中的字面量对象和 Java 堆的非字符串常量池区域的对象，这两个对象都是真正意义上的对象。上述1，2的规则就不再使用了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK8 中测试</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// Not String Pool ；heapAddr[1]</span></span><br><span class="line">       s3.intern();    <span class="comment">// String Pool ； poolAddr[1]</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;    <span class="comment">// Not String Pool ；heapAddr[1]</span></span><br><span class="line">       System.out.println(s3 == s4);   <span class="comment">// True</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       调换了2、3行代码的执行顺序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">// Heap&#x27;s Not String Pool ；heapAddr[0]</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;    <span class="comment">// String Pool ; poolAddr[0]</span></span><br><span class="line">       s3.intern();    <span class="comment">// String Pool ； poolAddr[0]</span></span><br><span class="line">       System.out.println(s3 == s4);   <span class="comment">// False</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>总结：String中intern()的使用：</strong></p>
</blockquote>
<ul>
<li><p>  在 JDK7 之前，将字符串对象尝试放入字符串常量池中时：</p>
</li>
<li><ul>
<li>  如果字符串常量池中已经含有，则并不会放入，并返回已有对象的内存地址；</li>
<li>  如果字符串常量池中没有，则会将当前对象的值复制一份，放入字符串常量池，并返回字符串常量池中该对象的内存地址；</li>
</ul>
</li>
<li><p>  从 JDK7 开始，将字符串对象尝试放入字符串常量池中时：</p>
</li>
<li><ul>
<li>  如果字符串常量池中已经含有该字面量对象，则直接返回该字面量对象的内存地址即可；</li>
<li>  如果没有，则会把<strong>对象的引用地址复制一份</strong>，放入字符串常量池，并返回字符串常量池中的引用地址。</li>
</ul>
</li>
</ul>
<h2 id="intern-的练习"><a href="#intern-的练习" class="headerlink" title="intern 的练习"></a>intern 的练习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//      String x = &quot;ab&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// 在上一行代码执行完毕之后，字符串常量池中并没有字面量对象 &quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">        <span class="comment">// JDK6中，在字符串常量池中创建字面量对象 &quot;ab&quot; ，并将地址值赋给 s2</span></span><br><span class="line">        <span class="comment">// JDK8中，在字符串常量池中没有创建字面量对象 &quot;ab&quot;，而是创建了一个引用对象，指向堆中非字符串常量池中的地址并将地址返回</span></span><br><span class="line">        System.out.println(s1 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false（JDK6）；true（JDK8）</span></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);  <span class="comment">// &quot;ab&quot; --&gt;&gt; Heap   执行完以后，在字符串常量池中不会生成 &quot;ab&quot;</span></span><br><span class="line">    s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   <span class="comment">// s2 --&gt;&gt; String Pool --&gt;&gt; Heap</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);   <span class="comment">// &quot;ab&quot; --&gt;&gt; Heap, SringPool    执行完以后，在字符串常量池中会生成 &quot;ab&quot;，但是s1指向的是Heap中的那个</span></span><br><span class="line">    s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   <span class="comment">// s2 --&gt;&gt; String Pool</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="7-G1-中的-String-去重操作"><a href="#7-G1-中的-String-去重操作" class="headerlink" title="7  G1 中的 String 去重操作"></a>7  G1 中的 String 去重操作</h1><p>字符串常量池中本就不允许存储重复元素，所以 String 的去重操作针对的是堆中非字符串常量池的区域。</p>
<p>String s1 = new String(“hello”);</p>
<p>String s1 = new String(“hello”);</p>
<p>什么是去重操作？（图）</p>
<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><blockquote>
<p>  背景</p>
</blockquote>
<p>通过对大量 Java 应用的研究测试表明：</p>
<ul>
<li>  堆中存活的数据集合中 String 对象占据了约 25%；</li>
<li>  其中 String 对象中重复的对象又占了约 13.5%；重复的意思就是： <code>string1.equals(string2) == true</code> </li>
<li>  堆上存在重复的String对象必然是一种内存资源的浪费。</li>
<li>  String 对象的平均长度是 45</li>
</ul>
<p>许多大规模Java应用的瓶颈在于内存，而这些项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样能避免浪费内存。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
