<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/24/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/24/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/24/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/28/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/28/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-07-28 10:05:13" itemprop="dateCreated datePublished" datetime="2020-07-28T10:05:13+08:00">2020-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-29 18:35:01" itemprop="dateModified" datetime="2022-03-29T18:35:01+08:00">2022-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1 Spring概述"></a>1 Spring概述</h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h2><ul>
<li>  <strong>轻量级</strong> Java 开发框架。</li>
<li>  目的是为了解决企业级应用开发中的业务逻辑层和其他各层的耦合问题。</li>
<li>  它是一个分层的 JavaSE/JavaEE <strong>一站式轻量级</strong>开源框架，为开发Java应用程序提供全面的基础架构支持。</li>
<li>  Spring 负责基础架构，因此Java开发者可以<strong>专注于应用程序的开发</strong>。</li>
<li>  Spring 最根本的使命是解决企业级应用开发的复杂性，即简化 Java 开发。</li>
<li>  Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（dependency injection，DI）和面向切面编程（aspectoriented programming，AOP）。</li>
</ul>
<h2 id="1-2-两大核心"><a href="#1-2-两大核心" class="headerlink" title="1.2 两大核心"></a>1.2 两大核心</h2><blockquote>
<ol>
<li><strong>IoC（Inverse of Control）</strong>：控制反转</li>
<li><strong>AOP（Aspect Oriented Programmimg）</strong>：面向切面编程</li>
</ol>
</blockquote>
<p><strong>IOC</strong></p>
<ul>
<li>  IOC 就是不会在代码中直接使用 <code>new</code> 关键字创建对象，只是把对象声明出来；</li>
<li>  在代码中不直接让对象与服务进行连接，但是在配置文件中描述了哪一项组件需要哪一项服务，由容器将它们组装起来。</li>
<li>  在一般的 IOC 场景中，容器创建了所有的对象，并设置了必要的属性将他们联系在一起，等到需要使用的时候才把他们声明出来；</li>
<li>  或者使用注解方式，容器会自动根据注解把对象组合起来。</li>
</ul>
<p><strong>AOP</strong></p>
<ul>
<li>  AOP 是一种编程模式，它允许开发人员通过自定义的横切点进行模块化，将那些影响多个类的行为封装到可重用的模块中。</li>
<li>  比如日志输出，不使用 AOP 的话就需要把日志的输出语句放在所有类、方法中，但是有了 AOP 就可以把日志输出语句封装成一个可重用模块，在以声明的方式将它们放在类中，每次使用类就自动完成了日志输出。 </li>
</ul>
<hr>
<h2 id="1-3-Spring-的设计目标、设计理念、和核心"><a href="#1-3-Spring-的设计目标、设计理念、和核心" class="headerlink" title="1.3 Spring 的设计目标、设计理念、和核心"></a>1.3 Spring 的设计目标、设计理念、和核心</h2><ul>
<li>  <strong>Spring设计目标</strong>：为开发者提供一个一站式轻量级应用开发平台；</li>
<li>  <strong>Spring设计理念</strong>：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OOP（面向对象）设计方法；Spring通过IOC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IOC容器，实现解耦；</li>
<li>  <strong>Spring框架的核心</strong>：IOC 容器和 AOP 模块。通过 IOC 容器管理 POJO 对象以及他们之间的耦合关系；通过 AOP 以动态非侵入的方式增强服务。</li>
<li>  IOC 让相互协作的组件保持松散的耦合，而 AOP 编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</li>
</ul>
<hr>
<h2 id="1-4-优缺点"><a href="#1-4-优缺点" class="headerlink" title="1.4    优缺点"></a>1.4    优缺点</h2><blockquote>
<p>  <strong>优点</strong></p>
</blockquote>
<ol>
<li><strong>降低耦合度，简化开发</strong><ul>
<li>通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬解码所造成的程序过度耦合。</li>
<li>用户也不必再为单例模式、属性文件解析这些很底层的需求写代码，可以更专注于上层的应用。</li>
</ul>
</li>
<li><strong>支持面向切面编程（AOP）</strong><ul>
<li>  Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</li>
</ul>
</li>
<li><strong>声明式事务的支持</strong><ul>
<li>  只需要通过配置就可以完成对事务的管理，而无需手动编写代码。</li>
</ul>
</li>
<li><strong>方便程序的测试</strong><ul>
<li>  Spring 对 Junit4 的支持，可以通过注解方便的测试 Spring 程序。</li>
</ul>
</li>
<li><strong>方便集成各种优秀框架</strong><ul>
<li>  Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</li>
</ul>
</li>
<li><strong>降低 JavaEE API 的使用难度</strong><ul>
<li>  Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低。 </li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>缺点</strong></p>
</blockquote>
<ol>
<li> 配置复杂（相较于 SpringBoot 而言）</li>
<li> Spring 依赖反射，反射影响性能</li>
</ol>
<hr>
<h2 id="1-5-体系结构"><a href="#1-5-体系结构" class="headerlink" title="1.5    体系结构"></a>1.5    体系结构</h2><p>Spring 项目目前总共有20多个模块，点击这里访问 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">GitHub</a> 查看模块源码。</p>
<p><img src="/2020/07/28/Spring/image-20220329182326817.png" alt="image-20220329182326817"></p>
<p>这些模块按照功能大致被划分为</p>
<ul>
<li>  <strong>核心容器（Core Container）</strong></li>
<li>  <strong>AOP（Aspect Oriented Programming）</strong></li>
<li>  <strong>设备支持（Instrmentation）</strong></li>
<li>  <strong>数据访问与集成（Data Access/Integeration）</strong> 、 </li>
<li>  <strong>Web</strong></li>
<li>  <strong>消息（Messaging）</strong> </li>
<li>  <strong>Test</strong></li>
</ul>
<p>6类，下图是 Spring5 的模块分类图：</p>
<p><img src="/2020/07/28/Spring/spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-1598445621955" alt="image-20200706181255193"></p>
<p><strong>Spring Core</strong>：提供了框架的基本组成部分，包括控制反转（IOC）和依赖注入（DI）功能。</p>
<p><strong>Spring Beans</strong>：提供了 BeanFactory，是工厂模式的一个经典实现，Spring 将管理的对象称为 Bean。</p>
<p><strong>Spring Context</strong>：构建于 Core 封装包基础上的 Context 封装包，提供了一种框架式的对象访问方法。</p>
<p><strong>Spring JDBC</strong>：提供了一个 JDBC 的抽象层，消除了烦琐的 JDBC 编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</p>
<p><strong>Spring AOP</strong>：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</p>
<p><strong>Spring Web</strong>：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 IOC 容器初始化和针对 Web 的 ApplicationContext。</p>
<p><strong>Spring Test</strong>：主要为测试提供支持的，支持使用 JUnit 或 TestNG 对 Spring 组件进行单元测试和集成测试。</p>
<h2 id="1-6-Spring-中用到了哪些设计模式"><a href="#1-6-Spring-中用到了哪些设计模式" class="headerlink" title="1.6 Spring 中用到了哪些设计模式"></a>1.6 Spring 中用到了哪些设计模式</h2><ol>
<li> <strong>工厂模式</strong>：BeanFactory 就是工厂模式的提现，用来创建对象的实例。</li>
<li> <strong>单例模式</strong>：Bean 默认为单例模式。</li>
<li> <strong>代理模式</strong>：AOP 功能用到了 JDK 的动态代理和 cglib 字节码生成技术。</li>
<li> <strong>模板方法模式</strong>：用来解决代码重复的问题。比如 RestTemplate，JmsTemplate，JpaTemplate。</li>
<li> <strong>观察者模式</strong>：定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被动更新，如Spring 中 listener 的实现 ApplicationListener。</li>
</ol>
<hr>
<h1 id="2-IoC"><a href="#2-IoC" class="headerlink" title="2    IoC"></a>2    IoC</h1><blockquote>
<p>  超链接：<a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/08/07/Spring%E2%80%94%E2%80%94IoC/">Spring——IoC</a></p>
</blockquote>
<hr>
<h1 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3    AOP"></a>3    AOP</h1><blockquote>
<p>  超链接：<a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/20/Spring%E2%80%94%E2%80%94AOP/">Spring——AOP</a></p>
</blockquote>
<hr>
<h1 id="4-Spring-TX：Spring-中的事务"><a href="#4-Spring-TX：Spring-中的事务" class="headerlink" title="4    Spring TX：Spring 中的事务"></a>4    Spring TX：Spring 中的事务</h1><blockquote>
<p>  <strong>超链接：</strong><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/20/Spring%E2%80%94%E2%80%94TX/">Spring——TX</a></p>
</blockquote>
<ul>
<li>  Spring 中的事务是利用 AOP 面向切面的特性配置的。</li>
<li>  事务管理是一个公共的功能，在很多方法中都需要被使用到，利用 AOP 的特性，可以将事务管理抽取成一个增强类，在代码中需要使用事务管理的方法上动态织入即可。可以在不修改代码的基础上动态的给方法增加事务管理的功能。</li>
<li>  如果是基于 XML 配置的 Spring 事务管理，那么在业务层方法的代码上，你将看不到任何事务管理的相关代码，但是这些方法确确实实是被事务所管理的，管理事务的配置信息写在 XML 配置文件中，运行期间通过动态织入对切入点方法进行增强。</li>
</ul>
<h2 id="1-Before：不使用事务管理存在的问题"><a href="#1-Before：不使用事务管理存在的问题" class="headerlink" title="1    Before：不使用事务管理存在的问题"></a>1    Before：不使用事务管理存在的问题</h2><blockquote>
<p>  <strong>转账（Account）案例中的事务</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户的业务层实现类</span></span><br><span class="line"><span class="keyword">package</span> cn.xsyu.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务逻辑层的具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountDao</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        accountDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountDao.add(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findByName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName    转出账户名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetName    转入账户名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money         转账金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String sourceName, String targetName, Double money)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取转出账户和转入账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">sourceAccount</span> <span class="operator">=</span> accountDao.findByName(sourceName);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">targetAccount</span> <span class="operator">=</span> accountDao.findByName(targetName);</span><br><span class="line">        <span class="comment">// 转出账户减钱，转入账户加钱</span></span><br><span class="line">        sourceAccount.setMoney(sourceAccount.getMoney()-money);</span><br><span class="line">        targetAccount.setMoney(targetAccount.getMoney()+money);</span><br><span class="line">        <span class="comment">// 更新数据</span></span><br><span class="line">        accountDao.update(sourceAccount);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;	<span class="comment">// 模拟转账异常</span></span><br><span class="line">        accountDao.update(targetAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>存在的问题</strong>：</p>
</blockquote>
<ol>
<li><p>事务被自动控制了[默认]。换言之，我们使用了 <code>connection</code> 对象的 <code>setAutoCommit(true)</code>，每执行一条 SQL 语句就会进行一次完整的事务。</p>
</li>
<li><p>此时，如果方法的每个业务功能中都只包含一条 SQL 语句，事务管理是 OK 的，出现异常时可以回滚所有的操作。  </p>
</li>
<li><p>但是如果一个业务方法中包含多条 SQL 语句，当业务出现异常时，就无法实现整个业务的回滚操作了。</p>
<ul>
<li>当我们执行转账业务时，由于执行过程中出现异常，会导致转账失败。但是因为我们每次执行的持久层方法都是独立事务，导致无法实现事务控制（不符合事务的一致性）。</li>
<li>每次自动提交，都会执行一遍开启事务、提交事务、回滚事务、关闭事务的过程。</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<p><img src="/2020/07/28/Spring/%E8%87%AA%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.png"></p>
<ol>
<li><code>accountDao.findByName(sourceName);</code>：完成了按姓名查找的功能，并成功提交事务。</li>
<li><code>accountDao.findByName(targetName);</code>：完成了按姓名查找的功能，并成功提交事务。</li>
<li><code>accountDao.update(sourceAccount);</code>：完成了更新<code>sourceAccount</code>账户的功能，该<code>账户中的余额=原本的余额-money</code>，并成功提交事务。</li>
<li><code>int i = 1/0；</code>：除0异常，程序终止。</li>
<li><code>accountDao.update(targetAccount);</code>：更新<code>targetAccount</code>账户的事务未能执行，但是由于之前的三个事务与该事务独立，所以回滚的时候并不会撤销之前的操作。这就造成了转出账户余额减少，而转入账户余额未增加的问题。</li>
</ol>
<hr>
<h2 id="2-After：解决方案"><a href="#2-After：解决方案" class="headerlink" title="2    After：解决方案"></a>2    After：解决方案</h2><blockquote>
<p>  <strong>解决方法</strong></p>
</blockquote>
<ul>
<li>关闭事务的自动提交，让上述四步操作由一个事务管理。这样其中的任何一步出现异常，事务都会回滚到事务开始的状态。</li>
<li>并且让上述四步操作的<code>Connection对象</code>为同一个。</li>
</ul>
<blockquote>
<p>  <strong>具体步骤</strong></p>
</blockquote>
<ol>
<li>编写ConnectionUtils类。从数据源中获取一个连接Connection，并且实现和线程的绑定。<ul>
<li>  如果不绑定 Connection，每次使用调用 CRUD 操作时都会重新创建一个新的 Connection 对象。</li>
<li>  绑定了 Connection 后，每次操作使用的 Connection 都是同一个 Connection 对象。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库连接的工具类；</span></span><br><span class="line"><span class="comment"> * 用于从DataSource中获取一个连接Connection，并且实现和线程的绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个本地线程变量</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;();</span><br><span class="line">    <span class="comment">// DI</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程上的连接【本程序是单线程程序】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.从ThreadLocal上获取数据库连接Connection</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            <span class="comment">// 2.判断当前线程上是否有连接</span></span><br><span class="line">            <span class="keyword">if</span> (conn!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 3.判断当前线程上没有连接</span></span><br><span class="line">                <span class="comment">// 从数据源中获取一个连接，并且存入ThreadLocal中</span></span><br><span class="line">                <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">                threadLocal.set(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.返回当前线程上的连接</span></span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把连接和线程解绑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="5-Spring中的JDBCTemplate"><a href="#5-Spring中的JDBCTemplate" class="headerlink" title="5    Spring中的JDBCTemplate"></a>5    Spring中的JDBCTemplate</h1><h2 id="5-1-JdbcTemplate概述"><a href="#5-1-JdbcTemplate概述" class="headerlink" title="5.1    JdbcTemplate概述"></a>5.1    JdbcTemplate概述</h2><ul>
<li><p>JdbcTemplate 是 Spring 为我们提供的一个框架，是对原始 Jdbc API 接口的简单封装。</p>
</li>
<li><p>Spring 框架为我们提供了很多的操作框架。</p>
<ol>
<li>操作关系型数据库的：<ul>
<li><code>JdbcTemplate</code></li>
<li><code>HibernateTemplate</code></li>
</ul>
</li>
<li>操作 NoSQL 数据库的：<ul>
<li><code>RedisTemplate</code></li>
</ul>
</li>
<li>操作消息队列的：<ul>
<li><code>JmsTemplate</code></li>
</ul>
</li>
</ol>
<ul>
<li><p>在使用<code>JdbcTemplate</code>时，需要导入：</p>
<ol>
<li><code>spring-jdbc-5.0.2.RELEASE.jar</code></li>
<li><code>spring-tx-5.0.2.RELEASE.jar</code>：和事务相关的jar</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-JdbcTemplate对象的创建"><a href="#5-2-JdbcTemplate对象的创建" class="headerlink" title="5.2    JdbcTemplate对象的创建"></a>5.2    JdbcTemplate对象的创建</h2><blockquote>
<p>  <strong>源码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3种构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JdbcTemplate</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">	setDataSource(dataSource);</span><br><span class="line">	afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JdbcTemplate</span><span class="params">(DataSource dataSource, <span class="type">boolean</span> lazyInit)</span> &#123;</span><br><span class="line">	setDataSource(dataSource);</span><br><span class="line">	setLazyInit(lazyInit);</span><br><span class="line">	afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1、除了无参构造器之外，都需要提供一个数据源。</span></span><br><span class="line"><span class="comment">	2、并且类中含有`set`方法，可以使用配置文件配置`dataSourse`，采用依赖注入赋值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h2 id="5-3-Spring中配置数据源"><a href="#5-3-Spring中配置数据源" class="headerlink" title="5.3    Spring中配置数据源"></a>5.3    Spring中配置数据源</h2><h3 id="5-3-1-环境搭建"><a href="#5-3-1-环境搭建" class="headerlink" title="5.3.1    环境搭建"></a>5.3.1    环境搭建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Spring IoC--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置Spring Jdbc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置Spring 事务管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置数据库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="5-3-2-编写spring的配置文件bean-xml"><a href="#5-3-2-编写spring的配置文件bean-xml" class="headerlink" title="5.3.2    编写spring的配置文件bean.xml"></a>5.3.2    编写spring的配置文件bean.xml</h3><ul>
<li><code>bean.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="5-3-3-配置数据源"><a href="#5-3-3-配置数据源" class="headerlink" title="5.3.3    配置数据源"></a>5.3.3    配置数据源</h3><ul>
<li>我们学过的数据源：</li>
</ul>
<ol>
<li><code>c3p0</code></li>
<li><code>DBCP</code></li>
<li><code>Spring内置数据源</code></li>
</ol>
<h4 id="1、配置c3p0数据源"><a href="#1、配置c3p0数据源" class="headerlink" title="1、配置c3p0数据源"></a>1、配置c3p0数据源</h4><ol>
<li>导入jar：<code>c3p0-0.9.2.1</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置<code>bean</code>：<ul>
<li>查看<code>com.mchange.v2.c3p0.ComboPooledDataSource</code>的源码发现，其中有许多<code>set</code>方法，所以可以采用DI的方式配置连接数据库所需的信息。</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2、配置DBCP数据源"><a href="#2、配置DBCP数据源" class="headerlink" title="2、配置DBCP数据源"></a>2、配置DBCP数据源</h4><ol>
<li><p>导入<code>jar</code>：<code>commons-dbcp.jar</code>和<code>commons-pool.jar</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-pool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>配置<code>bean</code>：</p>
<ul>
<li>显然<code>org.apache.commons.dbcp.BasicDataSource</code>的构造函数中也有大量相关的<code>set</code>方法，可以注入数据库连接信息，只是在<code>set</code>方法的命名上略有差异罢了。</li>
</ul>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3、配置Spring内置数据源"><a href="#3、配置Spring内置数据源" class="headerlink" title="3、配置Spring内置数据源"></a>3、配置Spring内置数据源</h4><ul>
<li>Spring框架也提供了一个内置数据源，我们可以使用Spring的内置数据源。</li>
</ul>
<ol>
<li><p>导入jar：<code>spring-jdbc-5.0.2.RELEASE.jar</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>配置<code>bean</code>：<code>DI</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="4、将数据库连接的信息配置到外部属性文件中"><a href="#4、将数据库连接的信息配置到外部属性文件中" class="headerlink" title="4、将数据库连接的信息配置到外部属性文件中"></a>4、将数据库连接的信息配置到外部属性文件中</h4><h5 id="4-1、定义属性文件"><a href="#4-1、定义属性文件" class="headerlink" title="4.1、定义属性文件"></a>4.1、定义属性文件</h5><ul>
<li><p><code>jdbc.properties</code></p>
  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/db4</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4-2、引入外部的属性文件"><a href="#4-2、引入外部的属性文件" class="headerlink" title="4.2、引入外部的属性文件"></a>4.2、引入外部的属性文件</h5><ol>
<li><p>方式一：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部属性文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>	</span><br></pre></td></tr></table></figure>

</li>
<li><p>方式二：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="5-4-JdbcTemplate的CRUD操作"><a href="#5-4-JdbcTemplate的CRUD操作" class="headerlink" title="5.4    JdbcTemplate的CRUD操作"></a>5.4    JdbcTemplate的CRUD操作</h2><h3 id="5-4-1-前期准备"><a href="#5-4-1-前期准备" class="headerlink" title="5.4.1    前期准备"></a>5.4.1    前期准备</h3><h4 id="1、准备数据库"><a href="#1、准备数据库" class="headerlink" title="1、准备数据库"></a>1、准备数据库</h4><h3 id="5-4-2-在Spring配置文件中配置JdbcTemplate"><a href="#5-4-2-在Spring配置文件中配置JdbcTemplate" class="headerlink" title="5.4.2    在Spring配置文件中配置JdbcTemplate"></a>5.4.2    在Spring配置文件中配置JdbcTemplate</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据库操作模板JdbcTemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置数据源DataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="5-4-3-最基本的CRUD"><a href="#5-4-3-最基本的CRUD" class="headerlink" title="5.4.3    最基本的CRUD"></a>5.4.3    最基本的CRUD</h3><ul>
<li>使用<code>Statement</code>对象执行SQL语句，存在SQL注入的隐患。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 创建spring容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbc</span> <span class="operator">=</span> (JdbcTemplate) ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into account (name, money) values(&#x27;王五&#x27;, 555);&quot;</span>;</span><br><span class="line">    jdbc.execute(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-4-4-基本的CRUD"><a href="#5-4-4-基本的CRUD" class="headerlink" title="5.4.4    基本的CRUD"></a>5.4.4    基本的CRUD</h3><ul>
<li>使用<code>PreparedStatement</code>对象，可以有效防止SQL注入</li>
</ul>
<h4 id="1、保存操作"><a href="#1、保存操作" class="headerlink" title="1、保存操作"></a>1、保存操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 创建spring容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbc</span> <span class="operator">=</span> (JdbcTemplate) ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into account (name, money) values(?, ?);&quot;</span>;</span><br><span class="line">        jdbc.update(sql,<span class="string">&quot;赵四&quot;</span>, <span class="number">666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、更新操作"><a href="#2、更新操作" class="headerlink" title="2、更新操作"></a>2、更新操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 创建spring容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbc</span> <span class="operator">=</span> (JdbcTemplate) ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set name=? where id=?&quot;</span>;</span><br><span class="line">        jdbc.update(sql,<span class="string">&quot;黄猿&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、删除操作"><a href="#3、删除操作" class="headerlink" title="3、删除操作"></a>3、删除操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 创建spring容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbc</span> <span class="operator">=</span> (JdbcTemplate) ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from account where id=?&quot;</span>;</span><br><span class="line">        jdbc.update(sql,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、查询所有操作-★"><a href="#4、查询所有操作-★" class="headerlink" title="4、查询所有操作[★]"></a>4、查询所有操作[★]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 创建spring容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbc</span> <span class="operator">=</span> (JdbcTemplate) ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account where money&gt;?&quot;</span>;</span><br><span class="line">        List&lt;Account&gt; accounts = jdbc.query(sql, <span class="keyword">new</span> <span class="title class_">AccountRowMapper</span>(), <span class="number">600</span>);</span><br><span class="line">        <span class="keyword">for</span> (Account account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;Account&gt;&#123;</span><br><span class="line">        <span class="keyword">public</span> Account <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">            account.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            account.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            account.setMoney(rs.getDouble(<span class="string">&quot;money&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> account;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><h5 id="1、自己手动实现对返回的Bean对象的封装"><a href="#1、自己手动实现对返回的Bean对象的封装" class="headerlink" title="1、自己手动实现对返回的Bean对象的封装"></a>1、自己手动实现对返回的Bean对象的封装</h5><ol>
<li><p><code>RowMapper&lt;T&gt;接口</code>的作用</p>
<ul>
<li><code>JdbcTemplate</code>中所有查询语句的返回结果必须实现的父接口。</li>
<li>作用：执行查询语句从数据库中得到结果集，并把结果集中的数据一一映射到JavaBean实体类中，返回JavaBean实体类。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RowMapper</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行查询语句从数据库中得到结果集，并把结果集中的数据一一映射到JavaBean实体类中，返回JavaBean实体类</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> rs 要映射到Bean对象中的结果集[数据库查询语句得到的结果集]</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> rowNum 当前行的编号</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 当前行映射后的结果对象 (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	T <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>手动实现<code>RowMapper&lt;T&gt;</code>接口，将查询数据库得到的结果集每行的数据映射到一个JavaBean对象上。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现RowMapper&lt;T&gt;接口，并指定封装后的泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;Account&gt;&#123;</span><br><span class="line">    <span class="comment">// 重写mapRow方法</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 创建一个空的Account对象</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="comment">// 从数据库的返回的结果集rs中分别取出`id`、`name`和`money`，映射到实体类JavaBean的对应的字段中</span></span><br><span class="line">        account.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        account.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        account.setMoney(rs.getDouble(<span class="string">&quot;money&quot;</span>));</span><br><span class="line">        <span class="comment">// 返回JavaBean对象account</span></span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>jdbc.query()</code>方法得到的返回值是<code>List&lt;T&gt;</code>集合的形式，</p>
<ul>
<li>就是先让<code>RowMapper&lt;T&gt;</code>接口中的<code>mapRow()</code>方法先把从数据库中得到的每一行数据都封装为一个JavaBean对象；</li>
<li>然后再通过<code>query()</code>方法把这些结果封装为一个List集合，作为返回值返回。</li>
</ul>
</li>
</ol>
<h5 id="2、采用JdbcTemplate提供的默认方法完成对返回的Bean对象的封装"><a href="#2、采用JdbcTemplate提供的默认方法完成对返回的Bean对象的封装" class="headerlink" title="2、采用JdbcTemplate提供的默认方法完成对返回的Bean对象的封装"></a>2、采用JdbcTemplate提供的默认方法完成对返回的Bean对象的封装</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 创建spring容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbc</span> <span class="operator">=</span> (JdbcTemplate) ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account where money&gt;?&quot;</span>;</span><br><span class="line">    List&lt;Account&gt; accounts = jdbc.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), <span class="number">600</span>);</span><br><span class="line">    <span class="keyword">for</span> (Account account : accounts) &#123;</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2020/07/28/Spring/RowMapper.png"></p>
<ol>
<li>显然，<code>BeanPropertyRowMapper类</code>继承自<code>RowMapper接口</code></li>
<li>它是<code>JdbcTemplate</code>为我们提供的自动封装工具。作用：<ul>
<li>从数据库中查询数据，把得到的每行数据封装为一个JavaBean对象。</li>
</ul>
</li>
<li>我们只需要指定JavaBean对象的类型即可。如：<code>new BeanPropertyRowMapper&lt;Account&gt;(Account.class)</code></li>
</ol>
<h4 id="5、查询一个操作"><a href="#5、查询一个操作" class="headerlink" title="5、查询一个操作"></a>5、查询一个操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 创建spring容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbc</span> <span class="operator">=</span> (JdbcTemplate) ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account where id=?&quot;</span>;</span><br><span class="line">    List&lt;Account&gt; accounts = jdbc.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), <span class="number">5</span>);</span><br><span class="line">    System.out.println(accounts.isEmpty()?<span class="string">&quot;没有结果&quot;</span>:accounts.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6、查询返回一行一列操作"><a href="#6、查询返回一行一列操作" class="headerlink" title="6、查询返回一行一列操作"></a>6、查询返回一行一列操作</h4><ul>
<li>返回值结果只能是<strong>一行一列</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 创建spring容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据id获取bean对象</span></span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbc</span> <span class="operator">=</span> (JdbcTemplate) ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT COUNT(*) FROM account WHERE money&gt;?;&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbc.queryForObject(sql, Integer.class, <span class="number">600</span>);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/" class="post-title-link" itemprop="url">容器（数组+集合）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-07-25 11:04:22" itemprop="dateCreated datePublished" datetime="2020-07-25T11:04:22+08:00">2020-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-02 15:37:32" itemprop="dateModified" datetime="2021-08-02T15:37:32+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/05/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94List-Set-Map/">超链接：ArrayList、HashSet、HashMap源码分析</a></li>
</ul>
<p><strong>容器</strong>：是将多个数据存储到一起，每个数据称为该容器的元素。</p>
<p><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/%E5%AE%B9%E5%99%A8.png"></p>
<h1 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h1><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/%E6%95%B0%E7%BB%84Array.png" alt="数组Array" style="zoom: 50%;">



<h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1    是什么"></a>1    是什么</h2><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<ul>
<li>  相同类型数据的集合，并使用一个名字命名，通过编号的方式对这些数据进行统一管理。</li>
<li>  数组是一种<strong>定长</strong>、<strong>定类型</strong>的容器。</li>
</ul>
<blockquote>
<p>  <strong>数组相关的概念：</strong></p>
</blockquote>
<ul>
<li>  数组名</li>
<li>  元素</li>
<li>  角标、下标、索引</li>
<li>  数组的长度：元素的个数</li>
</ul>
<blockquote>
<p>  <strong>数组的特点：</strong></p>
</blockquote>
<ol>
<li> 数组的长度一旦确定，就不能修改。</li>
<li> 数组中元素的数据类型一致。</li>
<li> 在内存中占用一整块连续的空间。</li>
</ol>
<hr>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2    分类"></a>2    分类</h2><blockquote>
<p>  <strong>数组分类</strong></p>
</blockquote>
<ul>
<li>  按维数划分：一维数组、二维数组、…..</li>
<li>  按元素类型划分：基本数据类型元素的数组，引用数据类型元素的数组</li>
</ul>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><blockquote>
<p>  <strong>数组的默认初始值</strong>：</p>
</blockquote>
<ul>
<li>  数组元素是整型：0</li>
<li>  数组元素是浮点型：0.0</li>
<li>  <strong>数组元素是char型：0 或 ‘\u0000’，而非’0’</strong></li>
<li>  数组元素是boolean型：false</li>
<li>  数组元素是引用数据类型：null</li>
</ul>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><blockquote>
<p>  <strong>如何理解二维数组？</strong></p>
</blockquote>
<p>数组属于引用类型数据，数组的元素也可以是引用类型数据，一个一维数组 A 的元素如果还是一个一维数组类型的，则此数组 A 称为二维数组。</p>
<blockquote>
<p>  <strong>二维数组的属性</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(arr.length);		<span class="comment">// 3</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>].length);	<span class="comment">// 3</span></span><br><span class="line">System.out.println(arr[<span class="number">1</span>].length);	<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>二维数组元素的默认初始化值</strong></p>
</blockquote>
<p><strong>规定</strong>：二维数组分为外层数组的元素，内层数组的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">外层元素：arr[<span class="number">0</span>], arr[<span class="number">1</span>]等</span><br><span class="line">内层元素：arr[<span class="number">0</span>][<span class="number">0</span>], arr[<span class="number">1</span>][<span class="number">2</span>]等;</span><br></pre></td></tr></table></figure>



<p><strong>二维数组元素的默认初始化值</strong> </p>
<ol>
<li>针对于初始化方式一：比如：<code>int[][] arr = new int[4][3];</code><ul>
<li>  外层元素的初始值为：地址值</li>
<li>  内层元素的初始值为：与一维数组初始化情况相同</li>
</ul>
</li>
<li>针对于初始化方式二：比如：<code>int[][] arr = new int[4][];</code><ul>
<li>  外层元素的初始化值为：null；【因为外层数组的元素也是一个引用类型，所以初始值为null】</li>
<li>  内层元素的初始化值为：不能调用，否则报错。</li>
</ul>
</li>
</ol>
<p><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/image-20210801174210274.png" alt="image-20210801174210274"></p>
<hr>
<h2 id="3-创建方式（3种）"><a href="#3-创建方式（3种）" class="headerlink" title="3    创建方式（3种）"></a>3    创建方式（3种）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：</span></span><br><span class="line">数组存储的数据类型[] 数组名字 = <span class="keyword">new</span> 数组存储的数据类型[长度]    <span class="comment">// []表示数组</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line">数据类型[] 数组名字 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>，元素<span class="number">2</span>，...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：</span></span><br><span class="line">数据类型[] 数组名字 = &#123;元素<span class="number">1</span>，元素<span class="number">2</span>，...&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-数组的成员"><a href="#4-数组的成员" class="headerlink" title="4    数组的成员"></a>4    数组的成员</h2><h3 id="4-1-索引"><a href="#4-1-索引" class="headerlink" title="4.1    索引"></a>4.1    索引</h3><ul>
<li>数组会自动为其中的每个元素分配一个**索引(index)**，索引从0开始。</li>
</ul>
<blockquote>
<p>   <strong>索引的作用：</strong></p>
</blockquote>
<p>可以通过索引找到到数组中对应的元素。获取到元素后，可以：</p>
<ol>
<li>访问数组中的元素；</li>
<li>为数组中的元素赋值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问数组中的元素</span></span><br><span class="line">数据类型 变量名 = 数组名[索引]</span><br><span class="line"><span class="comment">// 为数组中的元素赋值。</span></span><br><span class="line">数组名[索引]=数值：为组中的元素赋值</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="4-2-数组的长度属性"><a href="#4-2-数组的长度属性" class="headerlink" title="4.2    数组的长度属性"></a>4.2    数组的长度属性</h3><ul>
<li><code>length</code>是数组类中的一个属性。数组的长度是固定的，可以通过数组的长度属性<code>length</code>访问到数组的长度。</li>
<li>数组的最大索引值为：<code>length-1</code></li>
</ul>
<hr>
<h2 id="5-数组的内存布局"><a href="#5-数组的内存布局" class="headerlink" title="5    数组的内存布局"></a>5    数组的内存布局</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr);    <span class="comment">// [I@5fd0d5ae  ；arr数组在堆内存中的地址，存储在方法栈中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
<blockquote>
<p>  程序的执行流程：</p>
</blockquote>
<ol>
<li><p><em><code>main()</code>方法进入栈内存中执行。</em></p>
</li>
<li><p><em>执行<code>new int[3]</code>语句创建数组,JVM会在堆内存中开辟一块空间，存储数组。</em></p>
<ul>
<li><em>数组内容保存在堆内存中，而数组的地址则保存在栈内存中；</em></li>
<li><em>数组中有3个元素，默认初始值是0.</em></li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-数组中常见的操作"><a href="#6-数组中常见的操作" class="headerlink" title="6    数组中常见的操作"></a>6    数组中常见的操作</h2><h3 id="6-1-通过下标存取"><a href="#6-1-通过下标存取" class="headerlink" title="6.1    通过下标存取"></a>6.1    通过下标存取</h3><h3 id="6-2-遍历"><a href="#6-2-遍历" class="headerlink" title="6.2    遍历"></a>6.2    遍历</h3><ol>
<li> for 循环</li>
<li> 增强 for 循环：<code>for-each</code></li>
<li> <strong>注意</strong>：数组不能使用迭代器<code>Iterator</code>遍历，因为 Array 类没有实现<code>Iterable</code>接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 1.遍历数组，给数组赋值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.遍历数组，查看所有元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.遍历数组，获取最大值。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (max&lt;arr[i])&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.数组反转。【数组的最远端元素互换位置】</span></span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start=<span class="number">0</span>, end=arr.length-<span class="number">1</span>; start&lt;end; start++,end--)&#123;</span><br><span class="line">            temp = arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr););</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="7-数组中常见的异常"><a href="#7-数组中常见的异常" class="headerlink" title="7    数组中常见的异常"></a>7    数组中常见的异常</h2><ol>
<li><p>数组下标越界异常</p>
<ul>
<li><strong><code>ArrayIndexOutOfBoundException</code></strong></li>
</ul>
</li>
<li><p>数组空指针异常</p>
<ul>
<li><strong><code>NullPointerException</code></strong></li>
</ul>
</li>
</ol>
<hr>
<h2 id="8-数组工具类：Arrays"><a href="#8-数组工具类：Arrays" class="headerlink" title="8    数组工具类：Arrays"></a>8    数组工具类：Arrays</h2><blockquote>
<p><strong>java.util.Arrays</strong>：此类包含了用来操作数组的各种方法。 该类中所有的方法均为静态方法，可通过类名直接调用。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>String toString（int[] a）</code></td>
<td align="left">返回指定数组内容的字符串表示形式。</td>
</tr>
<tr>
<td align="left"><code>void sort（int[] a）</code></td>
<td align="left">对<code>int[] a</code>数组进行升序排序</td>
</tr>
<tr>
<td align="left"><code>boolean equals(int[] a,int[] b)</code></td>
<td align="left">判断两个数组是否相等</td>
</tr>
<tr>
<td align="left"><code>void fill(int[] a,int val)</code></td>
<td align="left">将指定值填充到数组之中（数组中的全部元素都用该值填充）</td>
</tr>
<tr>
<td align="left"><code>int binarySearch(int[] a,int key)</code></td>
<td align="left">二分查找某个元素</td>
</tr>
<tr>
<td align="left"><code>T[] copyOf(T[] original, int newLength)</code></td>
<td align="left">数组复制</td>
</tr>
<tr>
<td align="left">……</td>
<td align="left">……</td>
</tr>
</tbody></table>
<hr>
<h1 id="数组-vs-集合"><a href="#数组-vs-集合" class="headerlink" title="数组 vs. 集合"></a>数组 vs. 集合</h1><h2 id="1-集合与数组存储数据概述"><a href="#1-集合与数组存储数据概述" class="headerlink" title="1    集合与数组存储数据概述"></a>1    集合与数组存储数据概述</h2><ul>
<li>  集合、数组都是对多个数据进行存储操作的结构，简称 Java 容器。</li>
<li>  <strong>说明：</strong>此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中)</li>
</ul>
<h2 id="2-为什么要有集合？"><a href="#2-为什么要有集合？" class="headerlink" title="2    为什么要有集合？"></a>2    为什么要有集合？</h2><ul>
<li>  为了解决数组存储数据方面的弊端。</li>
</ul>
<hr>
<h2 id="3-数组存储的弊端"><a href="#3-数组存储的弊端" class="headerlink" title="3    数组存储的弊端"></a>3    数组存储的弊端</h2><ol>
<li> 一旦初始化以后，其长度就不可修改；</li>
<li> 数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高；</li>
<li> 获取数组中<strong>实际元素</strong>的个数的需求，数组没有现成的属性或方法可用；</li>
<li> 数组存储的数据是可重复的。对于不可重复的需求，不能满足。</li>
</ol>
<p><strong>总结：长度固定、类型固定、功能少。</strong></p>
<hr>
<h2 id="4-集合和数组的区别："><a href="#4-集合和数组的区别：" class="headerlink" title="4    集合和数组的区别："></a>4    集合和数组的区别：</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="left">数组</th>
<th>集合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">长度是固定的</td>
<td>长度是可变的</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">只能存储同一类型的元素</td>
<td>可以存储不同类型的元素[但不建议]</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">可以存储任意类型的数据</td>
<td>只能存储引用类型数据对象（即存储基础类型数据时会自动装箱）</td>
</tr>
</tbody></table>
<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/image-20210801183135587.png" alt="image-20210801183135587"></p>
<h2 id="迭代器接口：Iterable"><a href="#迭代器接口：Iterable" class="headerlink" title="迭代器接口：Iterable"></a>迭代器接口：Iterable</h2><h3 id="1-遍历Collection的两种方式"><a href="#1-遍历Collection的两种方式" class="headerlink" title="1    遍历Collection的两种方式"></a>1    遍历Collection的两种方式</h3><blockquote>
<ol>
<li> <strong>使用迭代器 Iterator</strong></li>
<li> <strong>for-each循环（或增强for循环）</strong></li>
</ol>
</blockquote>
<ul>
<li>  使用<code>for-each</code>循环遍历不需要实现 <strong>Iterable</strong> 接口，所以数组和集合都可以使用 for-each 遍历；</li>
<li>  <strong>数组可以使用<code>for-each</code>循环遍历，但是数组不能使用<code>iterator</code>迭代器遍历，因为其没有实现 Iterable 接口</strong>。</li>
</ul>
<h3 id="2-Iterable-接口"><a href="#2-Iterable-接口" class="headerlink" title="2    Iterable 接口"></a>2    Iterable 接口</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>  <code>Collection接口</code> 是 <code>Iterable接口</code>的子接口。</li>
<li>  Iterator 对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</li>
<li>  GOF 给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>  遍历集合Collectiton元素</li>
</ul>
<h4 id="如何获取实例"><a href="#如何获取实例" class="headerlink" title="如何获取实例"></a>如何获取实例</h4><ul>
<li>  通过 <strong>Collection#iterator()</strong> 方法返回一个迭代器实例。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="comment">// hasNext()：判断是否还有下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">// next()：①指针下移  ②将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/image-20210802102325927.png" alt="image-20210802102325927"></p>
<h4 id="接口源码"><a href="#接口源码" class="headerlink" title="接口源码"></a>接口源码</h4><blockquote>
<p>  <strong>Iterable 接口的源码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	Iterable接口的源码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>Iterable</code> 接口中有一个成员方法 <strong>iterator()<strong>，该方法的作用是返回一个<code>Iterator实例</code>，这个实例被称为</strong>迭代器</strong>。</li>
<li>  所有实现了<code>Iterable接口</code>的类必须重写<code>iterator()</code>方法，通过该方法可以获得一个<code>迭代器</code>，通过<code>迭代器</code>中的方法可以遍历集合。</li>
</ul>
<blockquote>
<p>  <strong>迭代器（Iterator）接口源码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	Iterator接口的源码（部分）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  迭代器（Iterator）接口中定义了 4 个方法，常用的有 3 个</li>
</ul>
<hr>
<h3 id="3-Iterator-接口"><a href="#3-Iterator-接口" class="headerlink" title="3    Iterator 接口"></a>3    Iterator 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.Iterator&lt;E&gt;;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt;	<span class="comment">// 接口</span></span><br></pre></td></tr></table></figure>



<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>迭代是获取 Collection 集合中元素的通用方式。</p>
<ol>
<li>在取出元素之前要先判断集合中有没有元素，如果有，就把这个元素取出来，</li>
<li>继续判断下一个，如果有就再取出来。一直把集合中的所有元素全部取出来。</li>
</ol>
<h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><ul>
<li><code>增强for</code>循环（也称<code>for...each循环</code>）是 JDK1.5++ 推出的一个高级 for 循环，<strong>专门用来遍历集合和数组</strong>的。</li>
<li>它的<strong>内部原理其实是一个Iterator迭代器</strong>，在遍历的过程中，不能对集合中的元素进行增删操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量名 : Collection集合or数组)&#123;</span><br><span class="line">    <span class="comment">// 操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-操作"><a href="#4-操作" class="headerlink" title="4    操作"></a>4    操作</h3><blockquote>
<ol>
<li> <strong>获取迭代器对象；</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = Collection对象.iterator()</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li> <strong>Iterator 接口中的方法：</strong></li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>hasNext()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">如果仍有元素可以迭代，则返回 <code>true</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>next()</code></td>
<td align="center"><code>E</code></td>
<td align="left">返回迭代的下一个元素</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>remove()</code></td>
<td align="center"><code>void</code></td>
<td align="left">从迭代器指向的 collection 中移除迭代器返回的最后一个元素</td>
</tr>
</tbody></table>
<hr>
<h2 id="单列集合：Collection接口"><a href="#单列集合：Collection接口" class="headerlink" title="单列集合：Collection接口"></a>单列集合：Collection接口</h2><p><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/Collection%E6%8E%A5%E5%8F%A3.png" alt="Collection接口"></p>
<ol>
<li>单列集合的顶级父接口。</li>
<li>两个重要的子接口：<ul>
<li><code>java.util.List</code>    元素有序、可重复</li>
<li><code>java.util.Set</code>    元素无需、不可重复</li>
</ul>
</li>
</ol>
<h3 id="Collection接口中常用的公共方法"><a href="#Collection接口中常用的公共方法" class="headerlink" title="Collection接口中常用的公共方法"></a>Collection接口中常用的公共方法</h3><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增</td>
<td align="left"><code>add(E e)</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">添加对象到集合中</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><code>addAll(Collection coll)</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">添加集合对象到集合中</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">删</td>
<td align="left"><code>remove(E e)</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">删除集合中指定的元素（只是删除元素，即使全都删除完，集合也存在）</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><code>removeAll(Collection coll)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><code>clear()</code></td>
<td align="center"><code>void</code></td>
<td align="left">清空集合中所有的元素，但不删除集合</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">查</td>
<td align="left"><code>size()</code></td>
<td align="center"><code>int</code></td>
<td align="left">返回当前集合中有效元素的个数</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><code>isEmpty()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">判断集合是否为空</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">判断</td>
<td align="left"><code>isEmpty()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><code>contains(E e)</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">判断集合中是否包含元素e</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><code>containsAll(Collection coll)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">其它</td>
<td align="left"><code>toArray()</code></td>
<td align="center"><code>Object[]</code></td>
<td align="left">把集合中的元素存储到数组中</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><code>iterator()</code></td>
<td align="center"><code>Iterator</code></td>
<td align="left">返回在此 collection 集合的迭代器。</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><code>retainsAll(Collection coll)</code></td>
<td align="center"></td>
<td align="left">返回交集</td>
</tr>
</tbody></table>
<h3 id="Collection-接口与数组间的相互转换"><a href="#Collection-接口与数组间的相互转换" class="headerlink" title="Collection 接口与数组间的相互转换"></a>Collection 接口与数组间的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合 --&gt; 数组：toArray()</span></span><br><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组 --&gt; 集合：调用Arrays类的静态方法 asList(T ... t)</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="存储元素的要求"><a href="#存储元素的要求" class="headerlink" title="存储元素的要求"></a>存储元素的要求</h3><blockquote>
<p>  <strong>使用 Collection 集合存储对象，要求对象所属的类满足：</strong></p>
</blockquote>
<p>向 Collection 接口的实现类的对象中添加数据 obj 时，要求 obj 所在类要重写 <code>equals()</code>。</p>
<hr>
<h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>



<h3 id="List-接口的特点"><a href="#List-接口的特点" class="headerlink" title="List 接口的特点"></a>List 接口的特点</h3><ol>
<li> 元素有序（存入和取出顺序一致）</li>
<li> 元素可重复</li>
</ol>
<blockquote>
<p>  <strong>集合或数组中关于有序、无序的概念：</strong></p>
</blockquote>
<p>在集合或数组中的有序性指的是先后顺序，而不是那种按年龄、按大小、按价格之类的排序。有序、无序是指在进行插入操作时，插入位置的顺序性。先插的位置在前，后插的位置在后，则为有序，反之无序</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增</td>
<td align="left"><code>add(int index，E e)</code></td>
<td align="center"><code>void</code></td>
<td align="left">追加</td>
</tr>
<tr>
<td align="center">插</td>
<td align="left"><code>add(int index, Object ele)</code></td>
<td align="center"></td>
<td align="left">插入</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">删</td>
<td align="left"><code>remove(int index）</code></td>
<td align="center"><code>E</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"></td>
<td align="left"><code>remove(Object obj)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">改</td>
<td align="left"><code>set(int index， E e）</code></td>
<td align="center"><code>E</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">查</td>
<td align="left"><code>get(int index）</code></td>
<td align="center"><code>E</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">长度</td>
<td align="left"><code>size()</code></td>
<td align="center"></td>
<td align="left">是元素的个数，不是数组长度</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">遍历</td>
<td align="left"></td>
<td align="center"></td>
<td align="left">① Iterator迭代器方式<br>② 增强for循环<br>③ 普通的循环</td>
</tr>
</tbody></table>
<hr>
<h3 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h3><blockquote>
<ol>
<li>  <strong>ArrayList</strong></li>
<li> <strong>LinkedList</strong></li>
<li> <strong>Vector</strong></li>
</ol>
</blockquote>
<blockquote>
<p>  <strong>ArrayList</strong></p>
</blockquote>
<p>作为 List 接口的主要实现类，具有以下特点：</p>
<ul>
<li>  线程不安全，效率高；</li>
<li>  底层使用 <code>Object[] elementData</code> 数组存储元素，查找快。</li>
</ul>
<blockquote>
<p>  <strong>LinkedList</strong></p>
</blockquote>
<ul>
<li>  底层使用<strong>双向链表</strong>存储元素，对于频繁的插入、删除操作，效率比 ArrayList 高；</li>
</ul>
<blockquote>
<p>  <strong>Vector</strong></p>
</blockquote>
<ul>
<li>  作为 List 接口的古老实现类，是线程安全的(Sychnronized)，效率低；</li>
<li>  底层使用 <code>Object[] elementData</code> 存储。</li>
</ul>
<hr>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><em>ArrayList集合的特点：</em></p>
<ul>
<li><em>数据存储结构是 数组，查找快，增删慢</em></li>
<li><em>线程不安全，效率高</em></li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><blockquote>
<p>  <strong>JDK7 中：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();	<span class="comment">// 底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">123</span>);	<span class="comment">// elementData[0] = new Integer(123);</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">11</span>);	<span class="comment">// 如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  默认情况下，扩容为原来的容量的 1.5 倍，同时需要将原有数组中的数据复制到新的数组中。</li>
<li>  <strong>结论</strong>：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</li>
</ul>
<blockquote>
<p>  <strong>JDK8 中 ArrayList 的变化：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();	<span class="comment">// 底层Object[] elementData初始化为&#123;&#125;.并没创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>);	<span class="comment">// 第一次调用 add() 时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line"><span class="comment">// ...... 后续的添加和扩容操作与 JDK7 无异。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>小结：</strong></p>
</blockquote>
<ul>
<li>  JDK7 中的 ArrayList 的对象的创建类似于单例的饿汉式，</li>
<li>  而 JDK8 中的 ArrayList 的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</li>
</ul>
<hr>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>ArrayList()</code></td>
<td align="left">创建一个初始容量为 0 的对象</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>ArrayList(Collection&lt;? extends E&gt; c)</code></td>
<td align="left">构造一个包含指定 collection 的元素的列表。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>ArrayList(int initialCapacity)</code></td>
<td align="left">构造一个具有指定初始容量的对象</td>
</tr>
</tbody></table>
<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>add(E e)</code></td>
<td align="center">boolean</td>
<td align="center">将指定的元素添加到此列表的尾部。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>add(int index, E e)</code></td>
<td align="center">void</td>
<td align="center">将指定的元素插入此列表中的指定位置。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>addAll(Collection&lt;? extends E&gt; c)</code></td>
<td align="center">boolean</td>
<td align="center">将指定的集合添加到此列表的尾部。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>addAll(int index, Collection&lt;? extends E&gt; c)</code></td>
<td align="center">boolean</td>
<td align="center">将指定的集合插入此列表中的指定位置。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>clear()</code></td>
<td align="center">void</td>
<td align="center">移除此列表中的所有元素。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>clone()</code></td>
<td align="center">Object</td>
<td align="center">返回此 <code>ArrayList</code> 实例浅拷贝</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>contains(Object o)</code></td>
<td align="center">boolean</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><code>get(int index)</code></td>
<td align="center">E</td>
<td align="center">返回此列表中指定位置上的元素。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>indexOf(Object o)</code></td>
<td align="center">int</td>
<td align="center">返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>lastIndexOf(Object o)</code></td>
<td align="center">int</td>
<td align="center">返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><code>set(int index, E e)</code></td>
<td align="center">E</td>
<td align="center">用指定的元素替代此列表中指定位置上的元素。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>isEmpty()</code></td>
<td align="center">boolean</td>
<td align="center">如果此列表中没有元素，则返回 <code>true</code></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><code>remove(int index)</code></td>
<td align="center">E</td>
<td align="center">移除此列表中指定位置上的元素。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>remove(Object o)</code></td>
<td align="center">boolean</td>
<td align="center">移除此列表中首次出现的指定元素（如果存在）。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>removeRange(int fromIndex, int toIndex)</code></td>
<td align="center">void</td>
<td align="center">移除列表中索引在 <code>[fromIndex，toIndex)</code>之间的所有元素。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><code>size()</code></td>
<td align="center">int</td>
<td align="center">返回此列表中的元素数。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><code>toArray()</code></td>
<td align="center">Object[]</td>
<td align="center">返回包含此列表中所有元素的数组</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>toArray(T[] a)</code></td>
<td align="center">T[]</td>
<td align="center">返回包含此列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol>
<li><p>生成6个1~33之间的随机整数，添加到集合，并遍历。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生成6个1~33之间的随机整数，添加到集合，并遍历。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成6个1~33之间的随机整数,并添加到集合</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">randNum</span> <span class="operator">=</span> random.nextInt(<span class="number">33</span>) + <span class="number">1</span>;</span><br><span class="line">            list.add(randNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>定义所有获取偶数元素集合的方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义所有获取偶数元素集合的方法.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成10个0~100之间的随机整数,并添加到集合list中</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">randNum</span> <span class="operator">=</span> random.nextInt(<span class="number">33</span>) + <span class="number">1</span>;</span><br><span class="line">            list.add(randNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取集合中的所有偶数,添加到子集合subList中</span></span><br><span class="line">        ArrayList&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                subList.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.遍历subList子集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;subList.size(); i++)&#123;</span><br><span class="line">            System.out.println(subList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><blockquote>
<ol>
<li>LinkedList 是 List 接口的一个实现类。</li>
<li><em>LinkedList集合的特点：</em><ul>
<li><em>数据结构是 双向链表，</em> </li>
<li><em>查找慢，增删快</em></li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(); <span class="comment">// 内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);	<span class="comment">// 创建一个Node对象，并将123封装到Node中，</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Node 节点的定义：体现了LinkedList的双向链表的说法</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">      E item;</span><br><span class="line">      Node&lt;E&gt; next;</span><br><span class="line">      Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">      <span class="built_in">this</span>.item = element;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">      <span class="built_in">this</span>.prev = prev;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li>LinkedList中特有的成员方法：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">增</td>
<td align="center"><code>addFirst（E e）</code></td>
<td align="center"><code>void</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>addLast（E e）</code></td>
<td align="center"><code>void</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>push（E e）</code></td>
<td align="center"><code>void</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">删</td>
<td align="center"><code>removeFirst（）</code></td>
<td align="center"><code>E</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>removeLast（）</code></td>
<td align="center"><code>E</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>pop（）</code></td>
<td align="center"><code>E</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">查</td>
<td align="center"><code>getFirst（E e）</code></td>
<td align="center"><code>E</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>getLast（E e）</code></td>
<td align="center"><code>E</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>  JDK7 和 JDK8 中通过 <code>Vector()</code> 构造器创建对象时，底层都创建了<strong>长度为10的数组</strong>。</li>
<li>  在扩容方面，默认扩容为原来的数组长度的 <strong>2 倍</strong>。</li>
</ul>
<hr>
<h2 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h2><h3 id="数据特点"><a href="#数据特点" class="headerlink" title="数据特点"></a>数据特点</h3><blockquote>
<p>  <strong>存储的数据特点：</strong></p>
</blockquote>
<ol>
<li> 元素无序</li>
<li> 元素不可重复</li>
</ol>
<hr>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><blockquote>
<p>  <strong>数据特点具体分析：</strong></p>
</blockquote>
<p>以 HashSet 为例说明：</p>
<p>【有序性是数据存储时按照插入的先后顺序排列的】</p>
<ol>
<li>无序性：不等于随机性。<strong>存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</strong></li>
<li>不可重复性：保证相同的元素在添加时，根据 <code>equals()</code> 判断不能返回 true。即相同的元素只能添加一个。</li>
</ol>
<blockquote>
<p>  <strong>底层数据结构：</strong></p>
</blockquote>
<p><strong>HashSet 底层是通过 HashMap 实现的，底层也是一个数组（HashTable）</strong>，初始容量16，当如果使用率超过 0.75（16<em>0.75=12）就会扩大容量为原来的 2 倍。</em>*</p>
<ul>
<li>  在 JDK7中，HashMap 的底层还是通过：数组+链表的结构 实现的。</li>
<li>  从 JDK8 开始，HashMap 的底层结构更改为<strong>链表长度大于等于 8 时，开始由链表转换为红黑树</strong>。</li>
</ul>
<hr>
<h3 id="元素添加过程"><a href="#元素添加过程" class="headerlink" title="元素添加过程"></a>元素添加过程</h3><ol>
<li> 我们向 <code>HashSet</code> 中添加元素 a 时，首先调用元素 a 所在类的 <code>hashCode()</code> 方法，计算元素 a 的哈希值，</li>
<li> 此哈希值接着通过某种算法计算出在 HashSet 底层数组中的存放位置（即：索引位置）</li>
<li>判断数组此位置上是否已经元素：<ul>
<li>  如果此位置上没有其它元素，则元素 a 添加成功。【Case1】</li>
<li>如果此位置上其他元素 b（或以链表形式存在的多个元素，则比较元素 a 与元素 b 的 hash 值）：<ul>
<li>  如果 hash 值不相同，则元素 a 添加成功。【Case2】</li>
<li>如果 hash 值相同，进而需要调用元素 a 所在类的 <code>equals()</code> 方法：<ul>
<li>  <code>equals()</code> 返回 true，元素 a 添加失败。【Case3】</li>
<li>  <code>equals()</code> 返回 false，则元素 a 添加成功。【Case4】</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashCode --&gt; 计算哈希值 --&gt; 索引位置 --&gt; 此位置没有其他元素 --&gt;添加成功</span><br><span class="line">                                    --&gt; 此位置有其他元素 --&gt; hash值不同 --&gt; 添加成功</span><br><span class="line">                                    			      --&gt; hash值相同 --&gt; 调用equals方法 --&gt; 返回true --&gt; 添加失败</span><br><span class="line">                                                                                        --&gt; 返回false --&gt; 添加成功</span><br></pre></td></tr></table></figure>





<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>  Set 接口中没额外定义新的方法，使用的都是 Collection 中声明过的方法。</li>
</ul>
<h3 id="常用实现类-1"><a href="#常用实现类-1" class="headerlink" title="常用实现类"></a>常用实现类</h3><ul>
<li><strong>Collection</strong> 接口：单列集合，用来存储一个一个的对象。<ul>
<li><strong>Set</strong> 接口：存储无序的、不可重复的数据。<ul>
<li><strong>HashSet</strong>：作为 Set 接口的主要实现类；线程不安全的；可以存储 null 值；<ul>
<li>  <strong>LinkedHashSet</strong>：作为 HashSet 的子类；遍历其内部数据时，可以按照添加的顺序遍历。在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。</li>
</ul>
</li>
<li>  <strong>TreeSet</strong>：可以照添加对象的指定属性，进行排序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对存储对象所在类的要求"><a href="#对存储对象所在类的要求" class="headerlink" title="对存储对象所在类的要求"></a>对存储对象所在类的要求</h3><blockquote>
<p>  <strong>HashSet/LinkedHashSet：</strong></p>
</blockquote>
<ol>
<li> 要求：向 HashSet（主要指：HashSet、LinkedHashSet）中添加的数据时，元素对象所在的类一定要重写 <code>hashCode()</code>和 <code>equals()</code> 方法、【因为 HashSet 插入元素时的主要判断标准就是哈希值和 <code>equals()</code> 方法】</li>
<li> 要求：重写的 <code>hashCode()</code>和 <code>equals()</code> 尽可能保持一致性，即相等的对象必须具有相等的散列码。</li>
</ol>
<p>重写两个方法的小技巧：对象中用作 <code>equals()</code> 方法比较的 Field，都应该用来计算 hashCode 值。</p>
<hr>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ol>
<li> 向 TreeSet 中添加的数据，要求是<strong>相同类的对象</strong>。</li>
<li> 两种排序方式：自然排序（实现Comparable接口）和 定制排序（Comparator）</li>
</ol>
<h3 id="常用的排序方式"><a href="#常用的排序方式" class="headerlink" title="常用的排序方式"></a>常用的排序方式</h3><blockquote>
<p>  <strong>方式一：自然排序</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败：不能添加不同类的对象</span></span><br><span class="line"><span class="comment">//        set.add(123);</span></span><br><span class="line"><span class="comment">//        set.add(456);</span></span><br><span class="line"><span class="comment">//        set.add(&quot;AA&quot;);</span></span><br><span class="line"><span class="comment">//        set.add(new User(&quot;Tom&quot;,12));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 举例一：</span></span><br><span class="line"><span class="comment">//        set.add(34);</span></span><br><span class="line"><span class="comment">//        set.add(-34);</span></span><br><span class="line"><span class="comment">//        set.add(43);</span></span><br><span class="line"><span class="comment">//        set.add(11);</span></span><br><span class="line"><span class="comment">//        set.add(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 举例二：</span></span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>方式二：定制排序</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">        <span class="comment">//照年龄从小到大排列</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mary&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="双列集合：Map-接口"><a href="#双列集合：Map-接口" class="headerlink" title="双列集合：Map 接口"></a>双列集合：Map 接口</h2><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/Map%E6%8E%A5%E5%8F%A3.png" alt="Map接口" style="zoom: 50%;">



<h3 id="常用实现类结构"><a href="#常用实现类结构" class="headerlink" title="常用实现类结构"></a>常用实现类结构</h3><ul>
<li><p><strong>Map</strong>：双列数据，存储键值对数据</p>
<ul>
<li><p><strong>HashMap</strong>：作为 Map 的主要实现类；线程不安全的，效率高；存储null的key和value</p>
<ul>
<li><p><strong>LinkedHashMap</strong>：保证在遍历 map 元素时，可以照添加的顺序实现遍历。</p>
<p>  原因：在原的 HashMap 底层结构基础上，添加了一对指针，指向前一个和后一个元素。</p>
<p>  对于频繁的遍历操作，此类执行效率高于HashMap。</p>
</li>
</ul>
</li>
<li><p><strong>TreeMap</strong>：保证照添加的 key-value 对进行排序，实现排序遍历。</p>
<p>  此时考虑key的自然排序或定制排序</p>
<p>  底层使用红黑树</p>
</li>
</ul>
</li>
<li><p><strong>Hashtable</strong>：作为古老的实现类；线程安全的，效率低；不能存储null的key和value</p>
<ul>
<li>  Properties:常用来处理配置文件。key和value都是String类型</li>
</ul>
</li>
</ul>
<h3 id="存储结构的理解"><a href="#存储结构的理解" class="headerlink" title="存储结构的理解"></a>存储结构的理解</h3><ul>
<li><p><strong>Map 中的 key</strong>：无序的、不可重复的。</p>
<p>  使用 Set 存储所有的 key  —&gt; key 所在的类要重写 <code>equals()</code> 和 <code>hashCode()</code> （以HashMap为例)</p>
</li>
<li><p><strong>Map中的value</strong>：无序的、可重复的。</p>
<p>  使用 Collection 存储所有的 value —&gt; value 所在的类要重写 <code>equals()</code></p>
</li>
<li><p>  一个键值对：key-value 构成了一个 Entry 对象。</p>
</li>
<li><p>  Map 中的 entry：无序的、不可重复的，使用 Set 存储所的 entry</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Map map1=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map1.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;BB&quot;</span>,<span class="number">345</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;cc&quot;</span>,<span class="number">345</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;AA&quot;</span>,<span class="number">001</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//key</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">set1</span> <span class="operator">=</span> map1.keySet();	<span class="comment">// HashMap中的key是set无序不可重复,可以用iterator遍历</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> set1.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator1.next());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// values</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map1.values(); <span class="comment">// HashMap中的values是Collection</span></span><br><span class="line">    <span class="keyword">for</span> (Object obj:values) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key-value</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map1.entrySet();	<span class="comment">// HashMap中的entry是set</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="comment">// entrySet集合中的元素都是entry</span></span><br><span class="line">        Map.Entry entry=(Map.Entry)obj;</span><br><span class="line">        System.out.println(entry.getKey()+<span class="string">&quot;----&gt;&quot;</span>+entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/image-20210802115642845.png" alt="image-20210802115642845"></p>
<hr>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 添加：put(Object key,Object value)</span><br><span class="line">* 删除：remove(Object key)</span><br><span class="line">* 修改：put(Object key,Object value)</span><br><span class="line">* 查询：get(Object key)</span><br><span class="line">* 长度：size()</span><br><span class="line">* 遍历：keySet() / values() / entrySet()</span><br></pre></td></tr></table></figure>





<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol>
<li> HashMap的底层实现原理？</li>
<li> HashMap 和 Hashtable的异同？</li>
<li> CurrentHashMap 与 Hashtable的异同？（暂时不讲)</li>
</ol>
<hr>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap-底层结构"><a href="#HashMap-底层结构" class="headerlink" title="HashMap 底层结构"></a>HashMap 底层结构</h3><blockquote>
<p>  <strong>JDK7</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>():</span><br><span class="line"><span class="comment">// ...可能已经执行过多次put...</span></span><br><span class="line">map.put(key1,value1);     </span><br></pre></td></tr></table></figure>

<ol>
<li> 执行 <code>new HashMap()</code> 的指令，底层会创建一个长度为16 的一维数组 <strong>Entry[] table</strong>；</li>
<li>  ….可能已经执行过多次 <code>put</code> …</li>
<li>执行 <code>map.put(key1,value1)</code> 方法：<ul>
<li>首先，调用 <code>key1</code> 所在类的 <code>hashCode()</code> 计算 <code>key1</code> 的哈希值，此哈希值经过某种算法计算以后，得到在 <code>Entry</code> 数组中的存放位置。<ul>
<li>  如果此位置上的数据为空，此时的 <code>key1-value1</code> 添加成功。【Case1】</li>
<li>如果此位置上的数据不为空（意味着此位置上存在一个或多个数据(以链表形式存在)），比较 <code>key1</code> 和已经存在的一个或多个数据的哈希值：<ul>
<li>  如果 <code>key1</code> 的哈希值与已经存在的数据的哈希值都不相同，此时 <code>key1-value1</code> 添加成功。【Case2】</li>
<li>如果 <code>key1</code> 的哈希值和已经存在的某一个数据 <code>(key2-value2)</code> 的哈希值相同，继续比较.调用 <code>key1</code> 所在类的<code>equals(key2)</code>方法，比较：<ul>
<li>  如果 <code>equals()</code>返回 false，此时 <code>key1-value1</code> 添加成功。【Case3】</li>
<li>  如果 <code>equals()</code> 返回 true，使用 <code>value1</code> 替换 <code>value2</code>。【Case4】</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>Tip：</strong></p>
</blockquote>
<ul>
<li>  在不断的添加过程中，会涉及到扩容问题，当<strong>超出临界值 0.75 (且要存放的位置非空)时，扩容</strong>。</li>
<li>  默认的扩容方式：<strong>扩容为原来容量的 2 倍</strong>，并将原的数据复制过来。</li>
</ul>
<blockquote>
<p>  <strong>JDK8</strong>：HashMap 在 JDK8 中相较于 JDK7 在底层实现方面的不同：</p>
</blockquote>
<ol>
<li> <code>new HashMap()</code> 底层没有创建一个长度为16的数组，而是使用一个类加载阶段就创建好的空数组；</li>
<li> JDK8 底层的数组是：**Node[]**，而非Entry[]；</li>
<li> <strong>首次调用<code>put()</code>方法时，底层才会创建长度为16的数组；</strong></li>
<li> JDK7 底层结构：数组+链表。JDK8 中底层结构：数组+链表+红黑树。</li>
<li> 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 <strong>且</strong>当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。<code>[链表长度 &gt;= 8 &amp;&amp; 数组长度 =&lt; 64]</code></li>
</ol>
<blockquote>
<p>  <strong>HashMap 底层结构典型属性的说明（源码中属性的说明）：</strong></p>
</blockquote>
<ul>
<li>  <strong>DEFAULT_INITIAL_CAPACITY</strong> ：HashMap的默认容量，16</li>
<li>  <strong>DEFAULT_LOAD_FACTOR</strong>：HashMap的默认加载因子，0.75；</li>
<li>  <strong>threshold</strong>：扩容的临界值， 等于 <strong>容量*填充因子</strong>：16 * 0.75 =&gt; 12；</li>
<li>  <strong>TREEIFY_THRESHOLD</strong>：Bucket 中链表长度大于该默认值时转化为红黑树，8；</li>
<li>  <strong>MIN_TREEIFY_CAPACITY</strong>：桶中的Node被树化时最小的 hash 表容量，64</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><blockquote>
<p>  <strong>LinkedHashMap的底层实现原理</strong></p>
</blockquote>
<ul>
<li>  LinkedHashMap 底层使用的结构与 HashMap 相同，因为 LinkedHashMap 继承于 HashMap。</li>
<li>  区别就在于：<strong>LinkedHashMap 内部提供了 Entry，替换了 HashMap 中的 Node</strong>。</li>
</ul>
<p><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/image-20210802122626223.png" alt="image-20210802122626223"></p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li>  向 TreeMap 中添加 <code>key-value</code>，<strong>要求 <code>key</code> 必须是由同一个类创建的对象</strong>。</li>
<li>  因为要根据 key 进行排序：自然排序 、定制排序。</li>
</ul>
<hr>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt;</span><br></pre></td></tr></table></figure>

<p>Properties 是 Hashtable 的一个子类，<code>key</code> 和 <code>value</code> 都是 String 类型，常用来处理配置文件。</p>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        pros.load(fis);	<span class="comment">// 加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>  <strong>操作 Collection 和 Map 的工具类</strong></li>
</ul>
<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>  **reverse(List)**：反转 List 中元素的顺序</li>
<li>  **shuffle(List)**：对 List 集合元素进行随机排序</li>
<li>  **sort(List)**：根据元素的自然顺序对指定 List 集合元素升序排序</li>
<li>  **sort(List，Comparator)**：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>  **swap(List，int， int)**：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
<li>  **Object max(Collection)**：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li>  **Object max(Collection，Comparator)**：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li>  <strong>Object min(Collection)</strong></li>
<li>  <strong>Object min(Collection，Comparator)</strong></li>
<li>  **int frequency(Collection，Object)**：返回指定集合中指定元素的出现次数</li>
<li>  **void copy(List dest,List src)**：将src中的内容复制到dest中</li>
<li>  **replaceAll(List list，Object oldVal，Object newVal)**：使用新值替换 List 对象的所有旧值</li>
</ul>
<h3 id="可以创建线程安全的-List-、Set-、Map"><a href="#可以创建线程安全的-List-、Set-、Map" class="headerlink" title="可以创建线程安全的 List 、Set 、Map"></a>可以创建线程安全的 List 、Set 、Map</h3><blockquote>
<p>  <strong>说明：</strong></p>
</blockquote>
<p>ArrayList、HashSet 和 HashMap 都是线程不安全的，如果程序要求线程安全，我们可以使用 Collections 工具类将 ArrayList、HashSet 或 HashMap 转换为线程的。</p>
<p><img src="file://E:/blog/source/_posts/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/image-20210705213534400.png?lastModify=1627872363" alt="image-20210705213534400"></p>
<hr>
<p><img src="/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/%E9%9B%86%E5%90%88.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/26/JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/26/JavaSE/" class="post-title-link" itemprop="url">JavaSE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-05-26 22:12:58" itemprop="dateCreated datePublished" datetime="2020-05-26T22:12:58+08:00">2020-05-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-09-15 23:04:13" itemprop="dateModified" datetime="2022-09-15T23:04:13+08:00">2022-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-计算机基础知识"><a href="#1-计算机基础知识" class="headerlink" title="1.    计算机基础知识"></a>1.    计算机基础知识</h1><h2 id="1-1-进制"><a href="#1-1-进制" class="headerlink" title="1.1    进制"></a>1.1    进制</h2><p><img src="/2020/05/26/JavaSE/image-20210723103449876.png" alt="image-20210723103449876"></p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>二进制系统中，每一个0或1就是一个<strong>位</strong>，都代表一个 <strong>bit（比特）</strong>。</p>
<p><strong>二进制数据的存储方式</strong>：所有的数值，不管正负，底层都以补码的方式存储。</p>
<p><strong>原码、反码、补码的说明：</strong></p>
<ul>
<li><p>  <strong>正数</strong>：三码合一</p>
</li>
<li><p><strong>负数</strong>：</p>
<blockquote>
<p>  <strong>原码：</strong>直接将一个数值转换成二进制数，最高位是符号位。</p>
<p>  <strong>负数的反码：</strong>是对原码按位取反，只是最高位（符号位）确定为1.</p>
<p>  <strong>负数的补码：</strong>对其反码加 1。</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/05/26/JavaSE/image-20210730120058217.png" alt="image-20210730120058217"></p>
<p><img src="/2020/05/26/JavaSE/image-20210730120129684.png" alt="image-20210730120129684"></p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><img src="/2020/05/26/JavaSE/image-20210723103635390.png" alt="image-20210723103635390"></p>
<h2 id="1-2-字节"><a href="#1-2-字节" class="headerlink" title="1.2    字节"></a>1.2    字节</h2><ul>
<li>8个<code>bit</code>（比特）表示1个<strong>字节</strong>，写成 <strong>1B</strong> 或者 <strong>1byte</strong> 。</li>
<li><em>字节是我们常见的计算机中的最小存储单元</em>。</li>
<li>计算机存储任何数据，都是以字节的形式存储。</li>
<li>Java 中单个汉字的所占的 存储空间为 2~4 个字节不等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8bit = 1B</span><br><span class="line">1024B = 1KB</span><br><span class="line">1024KB = 1MB</span><br><span class="line">1024MB = 1GB</span><br><span class="line">1024GB = 1TB</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/26/JavaSE/%E5%AD%97%E8%8A%82.png" alt="字节"></p>
<h2 id="1-3-常见的编码表"><a href="#1-3-常见的编码表" class="headerlink" title="1.3    常见的编码表"></a>1.3    常见的编码表</h2><table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ASCII</strong></td>
<td>美国标准信息交换码。用一个字节的7位可以表示。</td>
</tr>
<tr>
<td><strong>ISO8859-1</strong></td>
<td>拉丁码表。欧洲码表。用一个字节的8位表示。</td>
</tr>
<tr>
<td><strong>GB2312</strong></td>
<td>中国的中文编码表。最多两个字节编码所有字符</td>
</tr>
<tr>
<td><strong>GBK</strong></td>
<td>中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</td>
</tr>
<tr>
<td><strong>Unicode</strong></td>
<td>国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</td>
</tr>
<tr>
<td><strong>UTF-8</strong></td>
<td>变长的编码方式，可用1-4个字节来表示一个字符。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-4-ASCII编码表"><a href="#1-4-ASCII编码表" class="headerlink" title="1.4    ASCII编码表"></a>1.4    ASCII编码表</h2><ul>
<li>计算机只能识别二进制的0或1，那如何用二进制数据表示人类的文字呢？这就用到了编码表！</li>
</ul>
<h3 id="1-编码表"><a href="#1-编码表" class="headerlink" title="1.  编码表"></a>1.  编码表</h3><ol>
<li><strong>概念：</strong><ul>
<li>就是将人类的文字（最初是英文）和一个十进制数字对应起来的一个表格。</li>
<li>十进制数字又可以进一步转换为二进制数字表示。</li>
<li>这样就实现了用二进制数表示人类的文字（英文、中文等）。</li>
</ul>
</li>
<li><strong>ASCII 编码表</strong><ul>
<li><em>将所有的英文字母、数字、符号都和十进制进行了对应，产生了世界上第一张编码表 ASCII</em></li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">48</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">57</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">97</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">122</td>
</tr>
</tbody></table>
<p><img src="/2020/05/26/JavaSE/%E7%BC%96%E7%A0%81%E8%A1%A8.png" alt="编码表"></p>
<hr>
<h1 id="2-Java语言开发环境"><a href="#2-Java语言开发环境" class="headerlink" title="2.    Java语言开发环境"></a>2.    Java语言开发环境</h1><h2 id="2-1-Java虚拟机——JVM"><a href="#2-1-Java虚拟机——JVM" class="headerlink" title="2.1    Java虚拟机——JVM"></a>2.1    Java虚拟机——JVM</h2><ul>
<li><strong>JVM</strong>（Java Virtual Machine）：Java虚拟机，简称JVM。</li>
<li>跨平台。</li>
</ul>
<h3 id="2-1-1-JVM虚拟机的内存划分"><a href="#2-1-1-JVM虚拟机的内存划分" class="headerlink" title="2.1.1    JVM虚拟机的内存划分"></a>2.1.1    JVM虚拟机的内存划分</h3><h4 id="1、内存的概念"><a href="#1、内存的概念" class="headerlink" title="1、内存的概念"></a>1、内存的概念</h4><blockquote>
<p>内存是用来<strong>存储临时数据</strong>的（即断电后数据消失），它主要负责：硬盘等硬件上的数据和CPU之间的数据交换处理，也起到缓存系统中的临时数据的作用。在计算机中，它直接和CPU交换数据。</p>
<p><a href>内存，外存和CPU的关系</a></p>
</blockquote>
<ul>
<li>我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须先加载进内存中，然后由CPU运行程序，运行完毕后会清空内存。</li>
<li>JVM虚拟机要运行程序，必须要对内存进行空间的分配和管理。</li>
</ul>
<h4 id="2、JVM的内存划分"><a href="#2、JVM的内存划分" class="headerlink" title="2、JVM的内存划分"></a>2、JVM的内存划分</h4><blockquote>
<p>为了提高运算效率，JVM对内存空间进行了不同区域的划分。每一片区域都有特定的处理数据方式和内存管理方式。</p>
</blockquote>
<p><strong>JVM的内存划分</strong>：</p>
<table>
<thead>
<tr>
<th align="center">区域名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器</td>
<td align="center">给CPU使用，与开发无关。运行速度最快</td>
</tr>
<tr>
<td align="center">本地方法栈</td>
<td align="center">JVM在操作系统功能时调用，与开发无关。</td>
</tr>
<tr>
<td align="center">方法区</td>
<td align="center">存储<code>1、Class对象</code>，<code>2、类中的成员方法</code>，<code>3、static修饰的一切</code></td>
</tr>
<tr>
<td align="center">堆内存</td>
<td align="center">用于存放所有的Java<code>对象</code>，<strong>new出来的，都存储在堆内存(包括String和数组)。</strong></td>
</tr>
<tr>
<td align="center">方法栈</td>
<td align="center"><code>方法</code>运行时使用的内存，比如main()方法运行，进入方法栈中执行。<code>对象引用</code>保存在栈中。</td>
</tr>
</tbody></table>
<ul>
<li><code>方法区</code>中有一块内存被称为<code>静态区</code>，所有被<code>static</code>修饰的内容（包括静态方法、静态变量、静态代码块）都位于静态区中。</li>
</ul>
<hr>
<h2 id="2-2-JVM-amp-JRE-amp-JDK"><a href="#2-2-JVM-amp-JRE-amp-JDK" class="headerlink" title="2.2    JVM &amp; JRE &amp; JDK"></a>2.2    JVM &amp; JRE &amp; JDK</h2><p><img src="/2020/05/26/JavaSE/image-20210723095928287.png" alt="image-20210723095928287"></p>
<ul>
<li><strong>JVM</strong>：字节码文件运行的平台</li>
<li><strong>JRE</strong>（Java Runtime Environment）：JVM + Java核心类库 + 其它【==&gt; 只能运行编译好的 <code>.class</code> 文件】</li>
<li><strong>JDK</strong>（Java Development Kit）：JRE + Javac编译器 + 其它【==&gt; 编译、运行一条龙服务】</li>
<li>三者关系：<strong>JDK &gt; JRE &gt; JVM</strong></li>
</ul>
<p><img src="/2020/05/26/JavaSE/image-20200618234423180.png" alt="image-20200618234423180"></p>
<hr>
<h2 id="2-3-JavaBean——标准代码"><a href="#2-3-JavaBean——标准代码" class="headerlink" title="2.3    JavaBean——标准代码"></a>2.3    JavaBean——标准代码</h2><ul>
<li><code>JavaBean</code>是Java语言编写类的一种标准规范。</li>
<li>符合<code>JavaBean</code>的类，要求类必须是<strong>具体的和公共的</strong>，并且<strong>具有无参的构造方法</strong>，提供用来操作成员变量的**<code>set</code>和<code>get</code>方法**。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// 无参构造方法【必须】</span></span><br><span class="line">    <span class="comment">// 有参构造方法【建议】</span></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="comment">// getXxx()</span></span><br><span class="line">    <span class="comment">// setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-Java程序的执行原理"><a href="#3-Java程序的执行原理" class="headerlink" title="3.    Java程序的执行原理"></a>3.    Java程序的执行原理</h1><h2 id="3-1-Java程序执行的3个步骤"><a href="#3-1-Java程序执行的3个步骤" class="headerlink" title="3.1.    Java程序执行的3个步骤"></a>3.1.    Java程序执行的3个步骤</h2><p><strong>编写 –&gt; 编译 –&gt; 运行</strong></p>
<p><img src="/2020/05/26/JavaSE/Java%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%843%E4%B8%AA%E6%AD%A5%E9%AA%A4.png"></p>
<blockquote>
<ol>
<li> <strong>编写</strong></li>
</ol>
</blockquote>
<ul>
<li>程序员编写的源程序是<code>.java</code>格式的，JVM 是看不懂这种格式的文件的，因此我们必须把编写好的 <code>.java</code>源文件编译为 JVM 可以识别的二进制字节码文件，即 <code>.class</code> 文件。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>编译</strong></li>
</ol>
</blockquote>
<ul>
<li><p>使用 <code>javac.exe</code> 命令编译我们的 java 源文件。</p>
</li>
<li><p>步骤：在DOS命令窗口中，进入java源文件所在的目录，使用<code>javac</code>命令进行编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac Java源文件名.后缀名</span><br><span class="line"></span><br><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>运行</strong></li>
</ol>
</blockquote>
<ul>
<li><p>使用 <code>java.exe</code> 命令解释运行我们的字节码文件。</p>
</li>
<li><p>步骤：在DOS命令窗口中，进入java源文件所在的目录，使用<code>java</code>命令进行编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java 类名</span><br><span class="line">    </span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-2-编译-amp-解释-amp-运行"><a href="#3-2-编译-amp-解释-amp-运行" class="headerlink" title="3.2    编译 &amp; 解释 &amp; 运行"></a>3.2    编译 &amp; 解释 &amp; 运行</h2><blockquote>
<p>  <strong>编译 &amp; 运行</strong></p>
</blockquote>
<ol>
<li><strong>编译</strong>：将 <code>.java</code> 源文件一次性翻译成 <code>.class</code> 字节码文件。</li>
<li><strong>运行</strong>：将<code>.class</code>文件交给<code>JVM</code>去执行。</li>
</ol>
<blockquote>
<p>  <strong>编译 &amp; 解释</strong></p>
</blockquote>
<ul>
<li><strong>编译</strong>：将源代码一次性转换成<code>二进制文件</code>的过程。</li>
<li><strong>解释</strong>：将源代码逐条转换成<code>二进制文件</code>的过程。</li>
</ul>
<p>Java 是一门半解释半编译型语言。</p>
<hr>
<h2 id="3-2-main-方法"><a href="#3-2-main-方法" class="headerlink" title="3.2    main() 方法"></a>3.2    main() 方法</h2><ol>
<li><p><code>main()</code>方法称为主方法，是一切程序的入口。</p>
</li>
<li><p><code>main()</code> 方法也是一个普通的静态方法。</p>
</li>
<li><p><code>main()</code> 方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</p>
</li>
<li><p>如何将控制台获取的数据传给形参：<code>String[] args</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在控制台上输入：</span></span><br><span class="line">java [类名] <span class="string">&quot;Tom&quot;</span> <span class="string">&quot;Jerry&quot;</span> <span class="string">&quot;123&quot;</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(args[<span class="number">0</span>]);	<span class="comment">// &quot;Tom&quot;</span></span><br><span class="line">        System.out.println(args[<span class="number">3</span>]);	<span class="comment">// &quot;true&quot;</span></span><br><span class="line">        System.out.println(args[<span class="number">4</span>]);	<span class="comment">// 异常，数组下标越界</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-4-其它"><a href="#3-4-其它" class="headerlink" title="3.4    其它"></a>3.4    其它</h2><blockquote>
<p>  <strong>在一个 java 源文件中可以声明几个 class ？</strong></p>
</blockquote>
<p>在一个 java 源文件中可以声明多个 class。但是，只能最多有一个类声明为 public 的。而且要求声明为 public 的类的类名必须与源文件名相同。</p>
<blockquote>
<p>  <strong>编译的过程</strong></p>
</blockquote>
<p>编译以后，一个 <code>.java</code> 源文件会生成<strong>一个或多个字节码文件</strong>（如果含有内部类就会生成多个字节码文件）。字节码文件的文件名与 java 源文件中的类名相同。</p>
<hr>
<h1 id="4-变量的分类"><a href="#4-变量的分类" class="headerlink" title="4.    变量的分类"></a>4.    变量的分类</h1><h2 id="4-1-按照类别划分"><a href="#4-1-按照类别划分" class="headerlink" title="4.1    按照类别划分"></a>4.1    按照类别划分</h2><img src="/2020/05/26/JavaSE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="数据类型" style="zoom:50%;">

<h3 id="4-1-1-、基本数据类型"><a href="#4-1-1-、基本数据类型" class="headerlink" title="4.1.1 、基本数据类型"></a>4.1.1 、基本数据类型</h3><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">内存占用</th>
<th align="center">取值范围</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节型</td>
<td align="center">byte</td>
<td align="center">1个字节</td>
<td align="center">-2^7^ ~ 2^7^-1【2^8^】</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2个字节</td>
<td align="center">-2^15^ ~ 2^15^-1【2^16^】</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">4个字节</td>
<td align="center">-2^31^ ~ 2^31^-1【2^32^】</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">长整形</td>
<td align="center">long</td>
<td align="center">8个字节</td>
<td align="center">-2^63^ ~ 2^63^-1【2^64^】</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">单精度浮点数</td>
<td align="center">float</td>
<td align="center">4个字节</td>
<td align="center"></td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">双精度浮点数</td>
<td align="center">double（默认）</td>
<td align="center">8个字节</td>
<td align="center"></td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">2个字节</td>
<td align="center">0~2^16^</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">布尔类型</td>
<td align="center">boolean</td>
<td align="center">1个字节</td>
<td align="center">true/ false</td>
<td align="center">false</td>
</tr>
</tbody></table>
<blockquote>
<p>  附：</p>
<ul>
<li>  long类型：建议数据后加L表示</li>
<li>  float类型：建议数据后加F表示</li>
</ul>
</blockquote>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><blockquote>
<p>  <strong>为什么4个字节的 float 表示数值的范围比8个字节的 long 还大？</strong></p>
</blockquote>
<p><img src="/2020/05/26/JavaSE/20200625193023765.png" alt="img"></p>
<p>整数在计算机底层采用补码的形式表示，除去首位的符号位，剩余的位数即表示数值的范围，也就是<strong>位数越多，范围越大</strong>。</p>
<p>而对于单精度浮点数 float 和双精度浮点数 double，它们底层的数据结构是由 <strong>符号位 + 指数位 + 尾数位</strong> 组成的，中间的8位是指数位，尾数位表示小数的范围。</p>
<p>指数位有 8 位，即最高取到 128，底数固定为 2，即最大范围约等于  <strong>2^-128^ ~ 2^128^</strong> 之间，显然大于 long 类型的数据。</p>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p><strong>表示方式</strong></p>
<ol>
<li> 显式地声明一个字符</li>
<li> 转义字符</li>
<li> 直接使用 Unicode 值来表示字符型常量</li>
</ol>
<hr>
<h3 id="4-1-2、引用数据类型"><a href="#4-1-2、引用数据类型" class="headerlink" title="4.1.2、引用数据类型"></a>4.1.2、引用数据类型</h3><ul>
<li>除了基本类型剩下的数据都是引用类型。</li>
<li>基本类型数据可以作为成员变量、作为方法的参数，作为方法的返回值，那么当然引用类型也是可以的。*[引用类型数据的使用范围大于等于基本类型数据]*</li>
</ul>
<h4 id="1-class作为成员变量"><a href="#1-class作为成员变量" class="headerlink" title="1.    class作为成员变量"></a>1.    class作为成员变量</h4><ul>
<li><p>定义一个类<code>Role</code>（游戏角色）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> blood;  <span class="comment">//生命值</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时<code>String</code>本身就是引用类型，由于使用的方式类似常量，所以往往忽略了他是引用类型的存在。如果我们继续丰富这个类的定义，给<code>Role</code>增加武器，穿戴装备等属性，将如何编写呢？</p>
</blockquote>
</li>
<li><p>定义武器类<code>Weapon</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> &#123; <span class="comment">// 武器</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 武器名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hurt;   <span class="comment">// 伤害值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义防具类<code>Armor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Armor</span> &#123;    <span class="comment">// 防具</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> protect;    <span class="comment">// 护甲/魔抗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义角色类<code>Role</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> blood;  <span class="comment">//生命值</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Weapon wp;  <span class="comment">// 添加武器属性</span></span><br><span class="line">    <span class="keyword">private</span> Armor ar;   <span class="comment">// 添加防具属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 攻击方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span>+wp.getName()+<span class="string">&quot;造成了&quot;</span>+wp.getHurt()+<span class="string">&quot;点伤害&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防御方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defense</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用&quot;</span>+ar.getName()+<span class="string">&quot;抵挡了&quot;</span>+ar.getProtect()+<span class="string">&quot;点伤害&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">wp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weapon</span>(<span class="string">&quot;终默之焉&quot;</span>, <span class="number">666</span>);</span><br><span class="line">        <span class="type">Armor</span> <span class="variable">ar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Armor</span>(<span class="string">&quot;新手盾牌&quot;</span>,<span class="number">999</span>);</span><br><span class="line">        <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Role</span>(<span class="number">7</span>, <span class="number">100</span>, <span class="string">&quot;执行者&quot;</span>, wp, ar);</span><br><span class="line"></span><br><span class="line">        role.attack();</span><br><span class="line">        role.defense();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出结果：</span></span><br><span class="line"><span class="comment">    ——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">            使用终默之焉造成了666点伤害</span></span><br><span class="line"><span class="comment">            使用新手盾牌抵挡了999点伤害</span></span><br><span class="line"><span class="comment">    ——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>类作为成员变量时，对它进行赋值的操作，实际上是<strong>赋给它该类的一个实例对象</strong>。</p>
</li>
</ul>
<hr>
<h4 id="2-interface作为成员变量"><a href="#2-interface作为成员变量" class="headerlink" title="2.    interface作为成员变量"></a>2.    interface作为成员变量</h4><ul>
<li>接口不能直接 new，但是可以接收一个子类对象。</li>
<li>接口作为成员变量时，对它进行赋值操作，实际上是 <strong>赋给它该接口的一个子类实例对象</strong>。</li>
</ul>
<h4 id="3-interface作为方法参数和返回值类型"><a href="#3-interface作为方法参数和返回值类型" class="headerlink" title="3.    interface作为方法参数和返回值类型"></a>3.    interface作为方法参数和返回值类型</h4><ul>
<li><strong>接口作为方法参数时，传递的是它的子类实例对象。</strong></li>
<li><strong>接口作为返回值类型时，返回的是它的子类实例对象。</strong></li>
</ul>
<hr>
<h2 id="4-2-按声明的位置分类"><a href="#4-2-按声明的位置分类" class="headerlink" title="4.2    按声明的位置分类"></a>4.2    按声明的位置分类</h2><p><img src="/2020/05/26/JavaSE/image-20210723102237987.png" alt="image-20210723102237987"></p>
<hr>
<h2 id="4-2-按照是否可变划分"><a href="#4-2-按照是否可变划分" class="headerlink" title="4.2    按照是否可变划分"></a>4.2    按照是否可变划分</h2><h3 id="4-2-1、常量"><a href="#4-2-1、常量" class="headerlink" title="4.2.1、常量"></a>4.2.1、常量</h3><ul>
<li><strong>常量：</strong>是指在 Java 程序中固定不变的数据。</li>
</ul>
<h4 id="4-2-2-1-分类"><a href="#4-2-2-1-分类" class="headerlink" title="4.2.2.1  分类"></a>4.2.2.1  分类</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数常量</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">小数常量</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">字符常量</td>
<td align="center"><strong>单引号</strong>引起来，只能写一个字符，必须有内容</td>
<td align="center">‘a’, ‘[空格]’, ‘好’</td>
</tr>
<tr>
<td align="center">字符串常量</td>
<td align="center"><strong>双引号</strong>引起来，可以写多个字符，也可以不写</td>
<td align="center">“A”, “Hello”, “你好”, “”</td>
</tr>
<tr>
<td align="center">布尔常量</td>
<td align="center"><code>false/true</code></td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">空常量</td>
<td align="center"><code>null</code></td>
<td align="center">–</td>
</tr>
</tbody></table>
<h3 id="4-2-2、变量"><a href="#4-2-2、变量" class="headerlink" title="4.2.2、变量"></a>4.2.2、变量</h3><ul>
<li><strong>变量：</strong>常量是固定不变的数据，那么在程序中可以变化的量称为变量。</li>
<li>Java 中要求每个变量每一次只能保存一个数据，且必须明确保存的数据类型。</li>
</ul>
<h4 id="4-2-2-1、变量的定义"><a href="#4-2-2-1、变量的定义" class="headerlink" title="4.2.2.1、变量的定义"></a>4.2.2.1、变量的定义</h4><h5 id="1-格式"><a href="#1-格式" class="headerlink" title="1.  格式"></a>1.  格式</h5><ul>
<li><p>变量定义的格式包括3个要素：</p>
<ol>
<li><strong>数据类型</strong></li>
<li><strong>变量名</strong></li>
<li><strong>数据值</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 数据值</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="附1："><a href="#附1：" class="headerlink" title="附1："></a>附1：</h5><ul>
<li>在同一个大括号范围内，变量的名字不可以相同。</li>
<li><strong>变量赋值：类中方法外的成员变量，有缺省值，不赋值可以使用。  类中方法中的值，无缺省值，不赋值不能使用。</strong></li>
</ul>
<hr>
<h2 id="4-3-数据类型转换"><a href="#4-3-数据类型转换" class="headerlink" title="4.3    数据类型转换"></a>4.3    数据类型转换</h2><blockquote>
<p><strong>Java程序中要求参与计算的数据的类型必须保持一致，如果数据类型不一致将发生类型的转换。</strong></p>
</blockquote>
<h3 id="4-3-1-自动类型转换（只涉及7种基本数据类型，不包括Boolean）"><a href="#4-3-1-自动类型转换（只涉及7种基本数据类型，不包括Boolean）" class="headerlink" title="4.3.1    自动类型转换（只涉及7种基本数据类型，不包括Boolean）"></a>4.3.1    自动类型转换（只涉及7种基本数据类型，不包括Boolean）</h3><p><strong>结论：</strong>当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p>
<p><strong>原理：</strong>Java 程序要求参与运算的数据类型必须一致，若不一致将被自动转换。当容量小的数据类型变量与容量大的数据类型变量进行运算时，将取值范围大的数据转换为取值范围小的数据可能会发生数据损失，所以 Java 程序会自动将取值范围小的数据类型转换为取值范围大的数据类型。</p>
<p><strong>转换规则：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> 、<span class="type">char</span> 、<span class="type">short</span> --&gt; <span class="type">int</span> --&gt; <span class="type">long</span> --&gt; <span class="type">float</span> --&gt; <span class="type">double</span> </span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>当 byte、char、short 三种类型的变量做运算时，结果为 int 型。</p>
<h3 id="4-3-2-强制转换-只涉及7种基本数据类型）"><a href="#4-3-2-强制转换-只涉及7种基本数据类型）" class="headerlink" title="4.3.2    强制转换(只涉及7种基本数据类型）"></a>4.3.2    强制转换(只涉及7种基本数据类型）</h3><p><strong>强制类型转换</strong>：将<code>取值范围大的类型</code>转换为<code>取值范围小的类型</code>。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = (数据类型)待转换数据值</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>强制类型转换，可能导致精度损失。</p>
<h3 id="4-3-3-自动转换-vs-强制转换"><a href="#4-3-3-自动转换-vs-强制转换" class="headerlink" title="4.3.3    自动转换 vs. 强制转换"></a>4.3.3    自动转换 vs. 强制转换</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">自动类型转换</th>
<th align="center">强制类型转换</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Java程序自动执行</td>
<td align="center">手动执行</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">不会出现数据的损失</td>
<td align="center">可能会出现数据的损失</td>
</tr>
</tbody></table>
<hr>
<h1 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5.    运算符"></a>5.    运算符</h1><img src="/2020/05/26/JavaSE/%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%886%E7%B1%BB%EF%BC%89.png" alt="运算符（6类）" style="zoom: 50%;">





<h2 id="5-1-算术运算符"><a href="#5-1-算术运算符" class="headerlink" title="5.1    算术运算符"></a>5.1    算术运算符</h2><blockquote>
<p>  <strong>取余运算结果的符号与被模数的符号相同！！！</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;	<span class="comment">// 被模数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">num11</span> <span class="operator">=</span> -<span class="number">12</span>;	<span class="comment">// 被模数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num22</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">       System.out.println(num1 % num2);    <span class="comment">// 12 % (-5) = 2</span></span><br><span class="line">       System.out.println(num11 % num2);   <span class="comment">// (-12) % (-5) = -2</span></span><br><span class="line">       System.out.println(num11 % num22);  <span class="comment">// (-12) % 5 = -2</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>在Java中，2个整数使用算术运算符，无论怎么计算，也不会得到小数</strong>。</p>
</blockquote>
<p>​        如：<code>5/2 = 2</code>。其原理是：Java要求参与运算的数据的数据类型必须保持一致，否则就会进行类型转换。2个<code>int</code>类型的数据进行运算，得到的结果如果正好是<code>int</code>类型，则可以得到准确的结果，如果运算的结果含有小数，那么Java程序就会强制浮点型数据转换为整型数据，即使结果损失了部分数据。</p>
<blockquote>
<p>  <strong><code>前++</code>和<code>后++</code>有什么区别？</strong></p>
</blockquote>
<ul>
<li>在只有一个变量的独立运算中，<code>前++</code>和<code>后++</code>没有区别。如<code>a++</code>就完全等价于<code>++a</code>；</li>
<li>如果运算包含多个变量且有赋值操作，<code>前++</code>和<code>后++</code>的到的结果则不同。如<code>b=a++</code>是先赋值再自增，而<code>b=++a</code>是先自增再赋值。</li>
</ul>
<blockquote>
<p>  <strong>+的含义？</strong></p>
</blockquote>
<ul>
<li>当<code>+</code>两边都为数值型变量时，表示数值运算；</li>
<li>当<code>+</code>两边存在字符串时，表示拼接字符串[只要存在一个字符串就表示拼接]。</li>
</ul>
<blockquote>
<p>  <strong>算术运算符需要注意优先级问题。</strong></p>
</blockquote>
<hr>
<h2 id="5-2-赋值运算符"><a href="#5-2-赋值运算符" class="headerlink" title="5.2    赋值运算符"></a>5.2    赋值运算符</h2><p>​        <code>=</code> 的意思是把<code>=</code>右边的值赋值给左边，右边的值可以是任何常数、变量或者表达式，但左边的值必须是一个明确的、已经定义好的变量。如<code>int a = 4</code>。</p>
<ol>
<li><p>对于对象来说，赋值的不是对象的值，而是对象的引用。</p>
</li>
<li><p><strong>所有的赋值运算符都被看作是一次运算，并带有强制转换的特点</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// s1 = s1 + 2;    // 编译失败</span></span><br><span class="line">    s += <span class="number">1</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	分析： s+=1 逻辑上看作是 s = s+1, 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能自动将取值范围大的类型赋值给取值范围小的类型。</span></span><br><span class="line"><span class="comment">	但是，s=s+1 进行了2步运算， 而 += 是一个运算符，只运算一次，并带有强制转换的特点，也就是说 s+=1 等价于s=(short)s+1，因此程序没有问题编译通过，运行结果是2.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>常量和变量的运算</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">2</span>;    <span class="comment">// OK</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">b4</span> <span class="operator">=</span> b1 + b2;      <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     分析：</span></span><br><span class="line"><span class="comment">         b3 = 1+2, 1和2是常量，为固定不变的数据，在编译(javac)的时候，就可以确定了1+2的结果并没有超过byte类型的取值范围，可以赋值给变量 byte b3， 因此 byte b3 = 1 + 2; 是正确的。</span></span><br><span class="line"><span class="comment">         反之， byte b4 = b1 + b2; b2 和 b3 是变量，变量的值可能是变化的，在编译的时候，编译器不能确定 b2+b3 的结果是否会超过byte的取值范围，因此会将结果以 int 类型处理，因为 int 类型不能赋值给 byte 类型，因此编译失败。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="5-3-比较运算符"><a href="#5-3-比较运算符" class="headerlink" title="5.3    比较运算符"></a>5.3    比较运算符</h2><p>比较运算符：是两个数据之间进行比较的运算。</p>
<ol>
<li> 比较运算符的结果是boolean类型</li>
<li> <code>&gt;  &lt;  &gt;=  &lt;=</code> 只能使用在数值类型的数据之间。</li>
<li> <code>==</code> 和 <code>!=</code> 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</li>
</ol>
<hr>
<h2 id="5-4-逻辑运算符"><a href="#5-4-逻辑运算符" class="headerlink" title="5.4    逻辑运算符"></a>5.4    逻辑运算符</h2><ul>
<li>逻辑运算符：是用来<strong>连接两个布尔类型</strong>结果的运算符，运行结果都是布尔值<code>true/false</code>。</li>
</ul>
<blockquote>
<p>  <strong>区分 <code>&amp;</code> 与  <code>&amp;&amp;</code></strong></p>
</blockquote>
<ul>
<li>  相同点1：<code>&amp;</code> 与 <code>&amp;&amp;</code> 的运算结果相同</li>
<li>  相同点2：当符号左边是 true 时，二者都会执行符号右边的运算</li>
<li>  不同点：当符号左边是 false 时，<code>&amp;</code> 继续执行符号右边的运算，<code>&amp;&amp;</code> 不再执行符号右边的运算。</li>
<li>  开发中，推荐使用&amp;&amp;</li>
</ul>
<blockquote>
<p>  <strong>区分：| 与 ||</strong> </p>
</blockquote>
<ul>
<li>  相同点1：<code>|</code> 与 <code>||</code> 的运算结果相同</li>
<li>  相同点2：当符号左边是 false 时，二者都会执行符号右边的运算</li>
<li>  不同点3：当符号左边是 true 时，<code>|</code> 继续执行符号右边的运算，而 <code>||</code> 不再执行符号右边的运算</li>
<li>  开发中，推荐使用 <code>||</code></li>
</ul>
<hr>
<h2 id="5-5-三元运算符"><a href="#5-5-三元运算符" class="headerlink" title="5.5    三元运算符"></a>5.5    三元运算符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 布尔类型表达式？结果<span class="number">1</span>：结果<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="number">1</span>==<span class="number">2</span> ? <span class="number">100</span> : <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>三元运算符可以嵌套使用</p>
<hr>
<h1 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6.    流程控制"></a>6.    流程控制</h1><img src="/2020/05/26/JavaSE/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="流程控制" style="zoom:50%;">

<h2 id="6-1-顺序结构"><a href="#6-1-顺序结构" class="headerlink" title="6.1    顺序结构"></a>6.1    顺序结构</h2><ul>
<li>默认情况下程序顺序执行。</li>
</ul>
<h2 id="6-2-分支结构"><a href="#6-2-分支结构" class="headerlink" title="6.2    分支结构"></a>6.2    分支结构</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><blockquote>
<p>  <strong>if</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	代码体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>if…else</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	代码体<span class="number">1</span>；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    代码体<span class="number">2</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>if…else  if…else</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">	代码体<span class="number">1</span>；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">    代码体<span class="number">2</span>；</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件n)&#123;</span><br><span class="line">    代码体n;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    代码体n+<span class="number">1</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">swich(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">    	语句体<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	执行流程：</span></span><br><span class="line"><span class="comment">	  1. 首先计算出表达式的值。</span></span><br><span class="line"><span class="comment">	  2. 其次，让表达式值与 case 依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。</span></span><br><span class="line"><span class="comment">	  3. 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后结束程序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li> 根据 <code>switch</code> 表达式中的值，依次匹配各个 <code>case</code> 中的常量。一旦匹配成功，则进入相应 <code>case</code> 中，调用其执行语句。当调用完执行语句以后，继续向下执行其它 <code>case</code> 结构中的执行语句，直到遇到 <code>break</code>关键字或此 <code>switch-case</code> 结构末尾结束为止。</li>
<li> <code>break</code> 可以使用在 <code>switch-case</code> 结构中，表示一旦执行到此关键字，就跳出 <code>switch-case</code> 结构。</li>
<li> <code>break</code> 关键字是可选的。</li>
<li><strong><code>switch</code>结构中的表达式，只能是如下的 6 种数据类型之一：</strong><ul>
<li>  数字类型：byte、short、char、int</li>
<li>  枚举类型(JDK5.0新增)</li>
<li>  String类型(JDK7.0新增)</li>
</ul>
</li>
<li> <strong><code>case</code> 之后只能声明常量，不能声明范围</strong>。</li>
<li> <code>default</code> 相当于 if-else 结构中的else。  </li>
<li> <code>default</code> 结构是可选的，而且位置是灵活的。</li>
</ol>
<p><strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断星期几</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (day)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期1&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期2&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期4&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期5&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期6&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;星期7&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;请重新输入&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-3-循环结构"><a href="#6-3-循环结构" class="headerlink" title="6.3    循环结构"></a>6.3    循环结构</h2><h3 id="1-while"><a href="#1-while" class="headerlink" title="1.    while"></a>1.    while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">初始表达式;</span><br><span class="line"><span class="keyword">while</span>(布尔表达式)&#123;</span><br><span class="line">	循环体;</span><br><span class="line">	步进表达式;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// while循环计算1~100之间的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-do…while"><a href="#2-do…while" class="headerlink" title="2.    do…while"></a>2.    do…while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">初始表达式;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">        循环体；</span><br><span class="line">        步进表达式；</span><br><span class="line">    &#125;<span class="keyword">while</span>(布尔表达式);</span><br><span class="line">        </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	do...while 循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出10次hello</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i&lt;=<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do...while 循环</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无条件执行一次&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-for"><a href="#3-for" class="headerlink" title="3.    for"></a>3.    for</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始表达式; 布尔表达式; 步进表达式)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用循环计算1~100之间的偶数和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> sum_even1();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> sum_even2();</span><br><span class="line">        System.out.println(sum1);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历1~100之间的所有数字，对这些数字再进行筛选，筛选出所有的偶数求和。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum_even2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只遍历啊1~100之间的偶数，设置步长为2，只求所有偶数的和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 1~100之间偶数之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum_even1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-for-each"><a href="#4-for-each" class="headerlink" title="4.    for-each"></a>4.    for-each</h3><blockquote>
<p>在JDK1.5++中引入了一种更加简洁的对数组和集合进行遍历的方法，即<code>for-each</code>语句。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> num: array)&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-知识点"><a href="#5-知识点" class="headerlink" title="5.    知识点"></a>5.    知识点</h3><blockquote>
<p>  <strong><code>if...else</code>语句可与<code>三元运算符</code>的关系？</strong></p>
</blockquote>
<p><code>if...else</code>语句可与<code>三元运算符</code>可互相替换。</p>
<blockquote>
<p>  <strong><code>switch</code>中case的穿透现象？</strong></p>
</blockquote>
<p>​        在switch语句中，如果case后面不写break，将出现穿透现象，也就是不会再判断下一个case的值，直接向后运行，直到到达下一个break，或者整体switch结束。</p>
<blockquote>
<p>  <strong>死循环的两种表现形式</strong></p>
</blockquote>
<p>死循环就是循环中的条件永远为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while死循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 死循环</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>如何结束一个循环结构？</strong></p>
</blockquote>
<ul>
<li>  方式一：当循环条件是false时</li>
<li>  方式二：在循环体中，执行break</li>
</ul>
<blockquote>
<p>  <strong>什么是嵌套循环？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 使用嵌套循环，打印5*8的矩形*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">8</span>; j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 内循环打印8个 *号 后，需要一次换行</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">                ********</span></span><br><span class="line"><span class="comment">__________________________________________________________________*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-5-跳出语句"><a href="#6-5-跳出语句" class="headerlink" title="6.5    跳出语句"></a>6.5    跳出语句</h2><blockquote>
<ol>
<li> <strong>break</strong></li>
</ol>
</blockquote>
<ul>
<li>使用场景：<ol>
<li>终止switch。</li>
<li>终止循环。</li>
</ol>
</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>continue</strong></li>
</ol>
</blockquote>
<ul>
<li>使用场景<ol>
<li>结束本次循环，继续下一次的循环。</li>
</ol>
</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>return</strong></li>
</ol>
</blockquote>
<p><strong>break和continue关键字的使用</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">使用范围</th>
<th align="center">循环中使用的作用(不同点)</th>
<th align="center">相同点</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>break</strong></td>
<td align="center">switch-case</td>
<td align="center">终止switch</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">循环结构中</td>
<td align="center">结束当前循环</td>
<td align="center">关键字后面不能声明执行语句</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>continue</strong></td>
<td align="center"></td>
<td align="center">结束当次循环</td>
<td align="center">关键字后面不能声明执行语句</td>
</tr>
</tbody></table>
<hr>
<h1 id="7-方法"><a href="#7-方法" class="headerlink" title="7.    方法"></a>7.    方法</h1><blockquote>
<p><strong>方法</strong>：方法就是函数，也就是做某些事的方式。</p>
</blockquote>
<img src="/2020/05/26/JavaSE/%E6%96%B9%E6%B3%95.png" style="zoom: 80%;">

<h2 id="7-1-方法的组成"><a href="#7-1-方法的组成" class="headerlink" title="7.1    方法的组成"></a>7.1    方法的组成</h2><ul>
<li>5部分</li>
</ul>
<h3 id="关键字-return"><a href="#关键字-return" class="headerlink" title="关键字 return"></a>关键字 return</h3><blockquote>
<p>  <strong>return关键字：</strong></p>
</blockquote>
<ol>
<li> <strong>使用范围</strong>：使用在方法体中</li>
<li> <strong>作用</strong>：① 结束方法  ② 针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</li>
<li> <strong>注意点</strong>：return关键字后面不可以声明执行语句。</li>
</ol>
<h3 id="可变形参个数的方法"><a href="#可变形参个数的方法" class="headerlink" title="可变形参个数的方法"></a>可变形参个数的方法</h3><p>JDK5 新增的内容。</p>
<blockquote>
<p>  <strong>使用说明：</strong></p>
</blockquote>
<ol>
<li> 可变个数形参的格式：<code>数据类型 ... 变量名</code></li>
<li> 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，…</li>
<li> 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li> <strong>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载</strong>。换句话说，二者不能共存。【因为可变形参的底层就是用数组实现的】</li>
<li> <strong>可变个数形参在方法的形参中，必须声明在末尾</strong></li>
<li> <strong>可变个数形参在方法的形参中,最多只能声明一个可变形参。</strong></li>
</ol>
<blockquote>
<p>  举例说明</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.shuzu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/30 18:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        test.show(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);	<span class="comment">// 调用方式一</span></span><br><span class="line">        test.show(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;);	<span class="comment">// 调用方式二</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">            System.out.print(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//    public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="7-2-方法的定义"><a href="#7-2-方法的定义" class="headerlink" title="7.2    方法的定义"></a>7.2    方法的定义</h2><p><strong>定义方法的范围：类中方法外</strong></p>
<ul>
<li>  一个方法不能在另一个方法中定义，但是可以在另一个方法中调用。</li>
<li>  方法可以定义在一个类中，也可以不定义在一个类中(比如：接口中)。</li>
<li>  不能在 return 后面写代码，return意味着方法结束，后面的所有代码永远不会执行，属于无效代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表）&#123;</span><br><span class="line">	方法体</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="7-2-1-方法的返回值类型、参数类型详解"><a href="#7-2-1-方法的返回值类型、参数类型详解" class="headerlink" title="7.2.1    方法的返回值类型、参数类型详解"></a>7.2.1    方法的返回值类型、参数类型详解</h3><p>方法的参数为基本类型时，传递的是数据值，方法的参数为引用类型时，传递的是地址值。</p>
<p><strong>特殊情况：String 要视情况考虑。[常量池]</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        System.out.println(a);      <span class="comment">// 1</span></span><br><span class="line">        System.out.println(b);      <span class="comment">// 2</span></span><br><span class="line">        change(a, b);</span><br><span class="line">        System.out.println(a);      <span class="comment">// 1</span></span><br><span class="line">        System.out.println(b);      <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        a = a+b;</span><br><span class="line">        b = b+a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法参数为基本类型，传递的是数据值。类似于深拷贝。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);     <span class="comment">// 5</span></span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);     <span class="comment">// 99</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法参数为引用类型，传递的是地址值。类似于浅拷贝。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="7-3-方法分类"><a href="#7-3-方法分类" class="headerlink" title="7.3    方法分类"></a>7.3    方法分类</h2><hr>
<h2 id="7-4-重载"><a href="#7-4-重载" class="headerlink" title="7.4    重载"></a>7.4    重载</h2><p>方法重载指<strong>在同一个类中，允许存在一个以上的同名方法</strong>，只要它们的<strong>参数列表不同</strong>即可，与修饰符和返回值类型无关。</p>
<blockquote>
<p>  <strong>方法重载的条件：</strong></p>
</blockquote>
<p>**”两同一不同”**：</p>
<ol>
<li> 同一个类</li>
<li> 相同方法名</li>
<li>参数列表不同<ul>
<li>  个数不同；</li>
<li>  数据类型不同；</li>
<li>  参数类型排列顺序不同。</li>
</ul>
</li>
<li> 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</li>
</ol>
<blockquote>
<p>  <strong>如何确定一个类中某一个方法的调用？</strong></p>
</blockquote>
<ul>
<li>  方法名 + 参数列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        println(<span class="number">10</span>);</span><br><span class="line">        println(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">        println(<span class="number">0</span>);</span><br><span class="line">        println(<span class="number">12.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String  a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">byte</span> a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> a)</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-5-重写"><a href="#7-5-重写" class="headerlink" title="7.5    重写"></a>7.5    重写</h2><p>方法重写描述的是<code>子类和父类</code>之间的方法关系，而重载指的是同一类中方法的关系。</p>
<blockquote>
<p>  <strong>定义：</strong></p>
</blockquote>
<p>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。</p>
<p>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p>
<blockquote>
<p>  <strong>方法重写的原则：“两同两小一大”</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法的声明：</span></span><br><span class="line">权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>  子类重写方法的 <strong>方法名</strong> 和 <strong>形参列表</strong> 必须和父类被重写的方法的方法名和形参列表相同。【两同】</li>
<li>子类重写的方法的<strong>权限修饰符大于父类</strong>被重写的方法的权限修饰符。【一大】<ul>
<li>  特殊情况：子类不能重写父类中声明为 <code>private</code> 权限的方法【继承都继承不到，自然谈不上重写了】</li>
</ul>
</li>
<li>   返回值类型：    -   父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void；    -   父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)    -   父类被重写的方法的返回值类型是 A 类型，则<strong>子类重写的方法的返回值类型可以是 A 类或 A 类的子类</strong>（一小）</li>
<li>  子类重写的方法<strong>抛出的异常类型小于父类被重写的方法抛出的异常类型</strong>（两小）</li>
</ul>
<h2 id="7-5-重载-vs-重写"><a href="#7-5-重载-vs-重写" class="headerlink" title="7.5 重载 vs.重写"></a>7.5 重载 vs.重写</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">重载</th>
<th align="center">重写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">方法位于同一类中</td>
<td align="center">是父类和子类之间方法的关系</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">参数列表必须不同</td>
<td align="center">参数列表必须相同</td>
</tr>
</tbody></table>
<hr>
<h1 id="8-类"><a href="#8-类" class="headerlink" title="8.    类"></a>8.    类</h1><img src="/2020/05/26/JavaSE/%E7%B1%BB.png" alt="类" style="zoom:45%;">

<blockquote>
<p>  Java中，一切都是对象，类也是一种对象。</p>
</blockquote>
<h2 id="8-1-类结构（4大6小成员）"><a href="#8-1-类结构（4大6小成员）" class="headerlink" title="8.1    类结构（4大6小成员）"></a>8.1    类结构（4大6小成员）</h2><p>类的基本要素是<strong>属性</strong>和<strong>方法</strong>。</p>
<ul>
<li><strong>属性</strong>：属性也被称为字段、成员变量，属性可以是任意类型的对象，也可以是基本类型数据。</li>
<li><strong>方法</strong>：方法也被称为成员方法，其实就是函数，也就是做某些事的方式。包括：构造方法和普通方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">	<span class="comment">// 属性（字段）</span></span><br><span class="line">    <span class="comment">// 成员方法（构造方法+普通方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-1-1-属性（变量）"><a href="#8-1-1-属性（变量）" class="headerlink" title="8.1.1    属性（变量）"></a>8.1.1    属性（变量）</h3><h4 id="成员变量-vs-局部变量"><a href="#成员变量-vs-局部变量" class="headerlink" title="成员变量 vs. 局部变量"></a>成员变量 vs. 局部变量</h4><ul>
<li>  类中的直接属性（字段）也被称为<strong>成员变量</strong>；而类中的间接属性（类中方法中的变量）又被称为<strong>局部变量</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><br>在类中的位置不同</td>
<td align="center"><br>类中 &amp; 方法外</td>
<td align="center">方法中，方法形参<br>构造方法中，构造方法形参<br><strong>代码块内</strong></td>
</tr>
<tr>
<td align="center">作用范围不一样</td>
<td align="center">类中</td>
<td align="center">方法中</td>
</tr>
<tr>
<td align="center">初始化的值不同</td>
<td align="center">有默认值</td>
<td align="center">无默认值，必须赋值</td>
</tr>
<tr>
<td align="center">在内存中的位置不同</td>
<td align="center">堆内存</td>
<td align="center">栈内存</td>
</tr>
<tr>
<td align="center">生命周期不同</td>
<td align="center">随对象的创建而存在，随对象的消失而消失</td>
<td align="center">随方法的调用而存在，随方法的调用完毕而消失</td>
</tr>
<tr>
<td align="center">权限修饰符的不同</td>
<td align="center">private、public、缺省、protected</td>
<td align="center">不可以使用权限修饰符<br>（因为根本出不了当前类，出了作用范围就不可以被使用了）</td>
</tr>
</tbody></table>
<h4 id="类变量-amp-实例变量"><a href="#类变量-amp-实例变量" class="headerlink" title="类变量 &amp; 实例变量"></a>类变量 &amp; 实例变量</h4><ul>
<li>  静态变量：随着类的加载而加载，在内存中只会有一份</li>
<li>  实例变量：属于对象，在内存中创建几次对象就会有几份实例变量</li>
</ul>
<hr>
<h3 id="8-1-2-方法"><a href="#8-1-2-方法" class="headerlink" title="8.1.2    方法"></a>8.1.2    方法</h3><blockquote>
<p>  <strong>方法</strong>：描述类应该具备的功能。</p>
</blockquote>
<h4 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h4><blockquote>
<p>类中有一种特殊的方法被称为 <strong>构造方法</strong>，或者叫 <strong>构造器</strong>、<strong>构造函数</strong>。</p>
</blockquote>
<p><strong>构造器的作用</strong></p>
<ol>
<li> 创建对象</li>
<li> 初始化对象信息</li>
</ol>
<p><strong>构造器的格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  类名(形参列表)&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法比较特殊，</p>
<ol>
<li><em>它没有返回值；</em></li>
<li><em>它的名称要和类名一致；</em></li>
<li><em>构造方法可以有多个，彼此构成重载。</em></li>
</ol>
<p><strong>使用说明</strong></p>
<ol>
<li> 如果类中没有显式地定义构造方法的话，JVM 会自动生成一个默认的无参构造器。</li>
<li> 一旦我们显式地定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li> 构造器只在创建对象的时期调用一次，保证了对象的初始化的进行。</li>
<li> <strong>一个类中至少会有一个构造器，保证对象可以被创建出来</strong>。</li>
</ol>
<p><strong>属性赋值的先后顺序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-   ① 默认初始化</span><br><span class="line">-   ② 显式初始化</span><br><span class="line">-   ③ 构造器中初始化</span><br><span class="line">-   ④ 通过&quot;对象.方法&quot; 或 &quot;对象.属性&quot;的方式，赋值</span><br></pre></td></tr></table></figure>





<h4 id="2、成员方法"><a href="#2、成员方法" class="headerlink" title="2、成员方法"></a>2、成员方法</h4><ul>
<li>成员方法中的变量被称为局部变量。</li>
</ul>
<h3 id="8-1-3-代码块"><a href="#8-1-3-代码块" class="headerlink" title="8.1.3    代码块"></a>8.1.3    代码块</h3><blockquote>
<ol>
<li> <strong>代码块的作用</strong>：用来初始化类、对象的信息</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li> <strong>分类</strong></li>
</ol>
</blockquote>
<p>代码块要是使用修饰符，只能使用 <code>static</code>。</p>
<ul>
<li>  静态代码块</li>
<li>  非静态代码块</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>静态代码块</strong></li>
</ol>
</blockquote>
<ul>
<li>  内部可以输出语句；</li>
<li>  随着类的加载而执行，且只执行一次；</li>
<li>  作用：初始化类的信息；</li>
<li>  如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行；</li>
<li>  静态代码块的执行要优先于非静态代码块的执行；</li>
<li>  静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构。</li>
</ul>
<blockquote>
<ol start="4">
<li> <strong>非静态代码块</strong></li>
</ol>
</blockquote>
<ul>
<li>  内部可以输出语句；</li>
<li>  随着对象的创建而执行；</li>
<li>  每创建一个对象，就执行一次非静态代码块；</li>
<li>  作用：可以在创建对象时，对对象的属性等进行初始化；</li>
<li>  如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行；</li>
<li>  非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
</ul>
<blockquote>
<p>  <strong>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序</strong>：</p>
</blockquote>
<ul>
<li>  由父及子，静态先行。</li>
</ul>
<h3 id="8-1-4-内部类"><a href="#8-1-4-内部类" class="headerlink" title="8.1.4    内部类"></a>8.1.4    内部类</h3><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<p>将一个类 A 定义在另一个类 B 内部，则里面的类A就称为内部类，类B则称为外部类。</p>
<blockquote>
<p>  <strong>分类</strong></p>
</blockquote>
<ul>
<li>  成员内部类（静态、非静态）</li>
<li>  局部内部类(方法内、代码块内、构造器内)</li>
</ul>
<blockquote>
<p>  <strong>内部类特性：</strong></p>
</blockquote>
<ul>
<li>一个内部类对象可以直接访问它的外部类对象的所有内容，包括私有数据。</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性。</li>
<li>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的<code>.class</code>文件，但是前面冠以外部类的类名和<code>$</code>符号。【比如：<code>Person$Heart.class</code>】【这也证明了一个 <code>.java</code> 文件可以生成多个 <code>.class</code>文件】</li>
</ul>
<blockquote>
<p>  <strong>字节码文件格式：</strong></p>
</blockquote>
<p>成员内部类和局部内部类，在编译以后，都会生成字节码文件。</p>
<ul>
<li>  成员内部类：<code>外部类$内部类名.class</code></li>
<li>  局部内部类：<code>外部类$数字 内部类名.class</code></li>
</ul>
<hr>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><blockquote>
<p><strong>定义格式：</strong>定义在<strong>类中方法外</strong>的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 外部类&#123;</span><br><span class="line">    class 内部类&#123;</span><br><span class="line">        <span class="comment">// 代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>成员内部类特点：</strong></p>
</blockquote>
<ol>
<li>一方面，作为外部类的成员，它可以：<ul>
<li>  调用外部类的数据；</li>
<li>  可以被 <code>static</code> 修饰；</li>
<li>  可以被 4 种不同的权限修饰；</li>
</ul>
</li>
<li>另一方面，作为一个类：<ul>
<li>  类内可以定义属性、方法、构造器等；</li>
<li>  可以被 <code>final</code> 修饰，表示此类不能被继承。也就是说不使用 <code>final</code> 的话，内部类就可以被继承；</li>
<li>  可以被 <code>abstract</code> 修饰。</li>
</ul>
</li>
</ol>
<h3 id="8-3-3-局部内部类"><a href="#8-3-3-局部内部类" class="headerlink" title="8.3.3    局部内部类"></a>8.3.3    局部内部类</h3><blockquote>
<p><strong>定义：</strong>定义在类 A 的方法 <code>method()</code> 中的类 B 叫做局部内部类。</p>
</blockquote>
<ul>
<li>  方式一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getComparable() 方法的功能是返回一个实现了Comparable接口的子类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个实现了Comparable接口的类:局部内部类【类方法中的类】</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">MyComparable</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;  </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyComparable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  方式二：匿名局部内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<p>如果在局部内部类的方法中调用外部类的局部变量，那么要求此局部变量必须声明为 <code>final</code> 的。</p>
<ul>
<li>  JDK8 之前：要求此局部变量必须显式地声明为 <code>final</code> 的；</li>
<li>  从 JDK8 开始：可以省略 <code>final</code> 关键字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*final*/</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">12</span>;   <span class="comment">// 外部类的局部变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inner 是一个局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">innerA</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//                num = 21; // 编译异常，因为num被隐式地声明为final了，不能被更改</span></span><br><span class="line">                System.out.println(num);    <span class="comment">// OK，调用是OK的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="8-3-4-匿名内部类"><a href="#8-3-4-匿名内部类" class="headerlink" title="8.3.4    匿名内部类"></a>8.3.4    匿名内部类</h3><blockquote>
<p><strong>匿名内部类</strong>：是内部类的简化写法。</p>
<p>它的本质是一个 <code>带具体实现的</code>、<code>父类或者父接口</code>、<code>匿名的</code><strong>子类对象</strong>。</p>
<p>开发时，最常用到的内部类就是匿名内部类了。</p>
<p>以接口举例，当你使用一个接口时，你得做以下几步操作：</p>
</blockquote>
<ol>
<li>定义子类实现类；</li>
<li>重写接口中的抽象方法；</li>
<li>创建子类对象；</li>
<li>调用重写后的方法；</li>
</ol>
<p>我们的目的，最终只是为了调用方法，那么能不能简化以下，把以上4步合成一步呢？匿名内部类就是这样做的快捷方式。</p>
<h4 id="1-前提"><a href="#1-前提" class="headerlink" title="1    前提"></a>1    前提</h4><ul>
<li>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。也就是说，子类是父类的内部类。</li>
</ul>
<h4 id="2-格式"><a href="#2-格式" class="headerlink" title="2  格式"></a>2  格式</h4><ul>
<li><p><strong>内部类要实现的功能？</strong></p>
<ul>
<li><strong>答：通过外部类调用内部类的方法。</strong></li>
<li><strong>或：通过父类调用调用子类中的方法。</strong></li>
</ul>
</li>
<li><p>格式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或接口名()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-2-初始化"><a href="#8-2-初始化" class="headerlink" title="8.2    初始化"></a>8.2    初始化</h2><h3 id="8-2-1-类的初始化"><a href="#8-2-1-类的初始化" class="headerlink" title="8.2.1    类的初始化"></a>8.2.1    类的初始化</h3><blockquote>
<p><strong>类的初始化就是创建一个新的对象</strong>，我们在使用<code>new</code>关键字创建对象时，其实是调用了这个对象的构造方法进行的初始化。</p>
</blockquote>
<ul>
<li>详见<code>9.  对象</code></li>
</ul>
<h3 id="8-2-2-成员变量初始化"><a href="#8-2-2-成员变量初始化" class="headerlink" title="8.2.2    成员变量初始化"></a>8.2.2    成员变量初始化</h3><blockquote>
<ol>
<li> <strong>成员变量的赋值顺序</strong></li>
</ol>
</blockquote>
<p>JVM 会保证每个成员变量在使用前都会获得初始值，成员变量的赋值顺序可分为：</p>
<ol>
<li> 默认初始化（类加载阶段，默认赋零值）</li>
<li> 显式初始化/在代码块中赋值【先静态后非静态，先父后子】</li>
<li> 构造器中初始化</li>
<li> 有了对象以后，可以通过 <code>对象.属性</code> 或 <code>对象.方法</code> 的方式，进行赋值。</li>
</ol>
<p><strong>成员变量（属性）的默认值</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">数据类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本类型</td>
<td align="center">整型（byte，short，int，long）<br>浮点型（float，double）<br>布尔型（boolean）<br>字符型（char）</td>
<td align="center">0<br>0.0<br>false<br>‘\u0000’</td>
</tr>
<tr>
<td align="center">引用类型</td>
<td align="center">基本类型的包装类、String、数组，类，接口</td>
<td align="center">null</td>
</tr>
</tbody></table>
<ul>
<li></li>
</ul>
<h3 id="8-2-3-构造器初始化"><a href="#8-2-3-构造器初始化" class="headerlink" title="8.2.3    构造器初始化"></a>8.2.3    构造器初始化</h3><blockquote>
<p><strong>可以在<code>构造器</code>中对某些属性进行初始化，确定初始值。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// 未手动初始化，但有默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        i=<span class="number">11</span>;	<span class="comment">// 在构造器中对属性i进行初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<hr>
<h1 id="9-对象"><a href="#9-对象" class="headerlink" title="9.    对象"></a>9.    对象</h1><h2 id="9-1-对象的创建"><a href="#9-1-对象的创建" class="headerlink" title="9.1    对象的创建"></a>9.1    对象的创建</h2><blockquote>
<p>使用<code>new</code>关键字创建对象，但是实际调用的是<code>class</code>类中的构造方法。</p>
</blockquote>
<ul>
<li>创建对象就是类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>



<h2 id="9-2-对象的销毁"><a href="#9-2-对象的销毁" class="headerlink" title="9.2    对象的销毁"></a>9.2    对象的销毁</h2><blockquote>
<p>在Java中，我们不需要手动管理对象的销毁，它是由Java虚拟机（JVM）进行管理和销毁的。</p>
</blockquote>
<h2 id="9-3-对象的使用"><a href="#9-3-对象的使用" class="headerlink" title="9.3    对象的使用"></a>9.3    对象的使用</h2><ol>
<li><p>使用对象中的成员（包括方法和属性）</p>
<blockquote>
<ul>
<li>对象引用.成员变量</li>
<li>对象引用.成员方法</li>
</ul>
</blockquote>
</li>
<li><p>给对象中的属性赋值</p>
<blockquote>
<ul>
<li>对象名.成员变量 = “value”</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="9-4-对象在内存中的情况"><a href="#9-4-对象在内存中的情况" class="headerlink" title="9.4    对象在内存中的情况"></a>9.4    对象在内存中的情况</h2><h3 id="1、一个对象，调用一个方法内存图"><a href="#1、一个对象，调用一个方法内存图" class="headerlink" title="1、一个对象，调用一个方法内存图"></a>1、一个对象，调用一个方法内存图</h3><p><img src="/2020/05/26/JavaSE/%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
<ol>
<li>测试程序中的<code>main()</code>方法是程序执行的入口，<code>main()</code>方法首先进栈；</li>
<li>执行<code>创建p1对象</code>的语句，在堆内存中保存<code>p1对象</code>，<ul>
<li>将<code>p1对象的引用</code>保存在栈中，</li>
<li><code>p1对象的属性</code>保存在堆中；</li>
<li><code>p1对象的成员方法</code>保存在方法区中；</li>
<li><code>p1对象的成员方法的地址</code>保存在堆中；</li>
</ul>
</li>
<li>在测试程序中，通过<code>p1对象的引用</code>调用<code>p1对象中的方法</code>，<code>eat()</code>方法继续进栈执行；</li>
<li>问题：创建多个People对象时，如果每个对象中都保存一份成员方法的信息，那么多个对象就会有多份重复的成员方法信息<code>eat()</code>，这就非常浪费内存了，因为所有对象的方法信息都是一样的，那么如何解决这个问题呢？</li>
</ol>
<h3 id="2-两个对象，调用一个方法内存图"><a href="#2-两个对象，调用一个方法内存图" class="headerlink" title="2.    两个对象，调用一个方法内存图"></a>2.    两个对象，调用一个方法内存图</h3><p><img src="/2020/05/26/JavaSE/%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E5%90%8C%E4%B8%80%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
<ol>
<li>两个对象调用同一成员方法，该成员方法的数据不存储在堆内存中，只在堆内存中保存着一个<strong>方法标记</strong>。</li>
<li>方法真正的内容保存在方法区中。</li>
<li>通过堆内存的方法标记访问方法区的成员方法，来完成成员方法的调用。</li>
<li>可以实现，即便有多个对象，成员方法信息也只保存一份，节省内存空间。</li>
</ol>
<hr>
<h2 id="9-5-匿名对象"><a href="#9-5-匿名对象" class="headerlink" title="9.5    匿名对象"></a>9.5    匿名对象</h2><blockquote>
<p><strong>匿名对象</strong>：没有变量名的对象。</p>
<p>匿名对象是典型的多例的应用。</p>
</blockquote>
<p>定义</p>
<p>我们创建的对象，没显式的赋给一个变量名。即为匿名对象。</p>
<p>特点</p>
<p>匿名对象只能调用一次。（因为没有在栈中保存该对象的引用）</p>
<ul>
<li>创建对象时，只有创建对象的语句，却没有把对象的地址值赋值给某个变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名(参数列表)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>

<h3 id="9-5-1-应用场景"><a href="#9-5-1-应用场景" class="headerlink" title="9.5.1.    应用场景"></a>9.5.1.    应用场景</h3><ol>
<li><p>创建匿名对象并直接直接调用该对象的方法，不使用变量名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>一旦调用两次方法，就是创建了两个对象，造成资源浪费</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br></pre></td></tr></table></figure></li>
<li><p>匿名对象可以<strong>作为方法的参数或返回值</strong></p>
</li>
</ol>
<hr>
<h1 id="10-关键字"><a href="#10-关键字" class="headerlink" title="10    关键字"></a>10    关键字</h1><p><strong>定义</strong>：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p>
<p><strong>特点</strong>：关键字中所字母都为小写</p>
<p><strong>有哪些</strong>：</p>
<p><img src="/2020/05/26/JavaSE/image-20210723101625081.png" alt="image-20210723101625081"></p>
<p><img src="/2020/05/26/JavaSE/image-20210730094044842.png" alt="image-20210730094044842"></p>
<p><img src="/2020/05/26/JavaSE/%E5%85%B3%E9%94%AE%E5%AD%97.png"></p>
<blockquote>
<p>  <strong>保留字</strong></p>
</blockquote>
<p><strong>定义</strong>：现Java版本尚未使用，但以后版本可能会作为关键字使用。</p>
<p><strong>注意</strong>：自己命名标识符时要避免使用这些保留字</p>
<blockquote>
<p>  <strong>标识符</strong></p>
</blockquote>
<p><strong>定义</strong>：凡是自己可以起名字的地方都叫标识符。</p>
<p><strong>涉及到的结构</strong>：包名、类名、接口名、变量名、方法名、常量名</p>
<p><strong>规则</strong>：(必须要遵守。否则，编译不通过)</p>
<p><img src="/2020/05/26/JavaSE/image-20210730094359137.png" alt="image-20210730094359137"></p>
<ul>
<li>  标识符应以字母、_ 、$开头</li>
</ul>
<p><strong>规范</strong>：（可以不遵守，不影响编译和运行。但是要求大家遵守）</p>
<p><img src="/2020/05/26/JavaSE/image-20210730094602848.png" alt="image-20210730094602848"></p>
<p><strong>注意</strong>：在起名字时，为了提高阅读性，要尽量意义，“见名知意”。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><blockquote>
<ol>
<li> <strong>static 可以修饰的结构</strong>：</li>
</ol>
</blockquote>
<ul>
<li><p>  主要用来修饰类的内部结构：<strong>属性、方法、代码块、内部类</strong></p>
</li>
<li><p>  被<code>static</code>修饰的成员是<strong>属于类</strong>的，而不是单单属于某个对象的。</p>
</li>
<li><p>  被 static 修饰的 方法/属性 可以在没有创建对象的情况下被调用。</p>
</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>static 修饰属性：类变量</strong></li>
</ol>
</blockquote>
<ul>
<li>  被 <code>static</code>修饰的成员变量称为<strong>静态成员变量</strong> 或 <strong>类变量</strong>。</li>
<li>  依据同一份类模板创建的每个对象都共享同一份类变量的值，任何对象都可以更改该类变量的值，也可以在不创建实例对象的情况下对类变量进行操作。</li>
<li>  静态变量随着类的加载而加载，可以通过 <code>类.静态变量</code> 的方式进行调用。</li>
<li>  静态变量的加载要早于对象的创建。</li>
<li>  由于类只会加载一次，则静态变量在内存中也只会存在一份。</li>
<li>  <strong>类变量有专门的存储区域</strong>，存在方法区的静态域中，所有的实例对象中保存的是类变量的地址引用。</li>
</ul>
<p><strong>案例：</strong></p>
<p>​        新学期开学，学生报到。现在想按照报到顺序为每一位学生分配学号<code>sid</code>，从第一名学生开始学号为 1，以此类推。学号必须是唯一的，连续的，并且与班级人数相符。以便知道要分配给下一名新同学的学号是多少。【这样我们就需要一个变量，与单独的每一个学生对象无关，而是与创建了多少个学生对象（执行了多少次创建过程）有关】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numberOfStudent</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、Student类只提供了无参构造方法，所以创建学生对象必须使用该类。</span></span><br><span class="line"><span class="comment">        2、每次new一个新的对象时必调用一次构造方法，且numberOfStudent是一个类(静态)变量，所以每个对象都可     以修改该属性的值，做到了每创建一个对象numberOfStudent就会自增1，对应的sid也就实现了自增长。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sid = ++numberOfStudent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.sid = ++numberOfStudent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sid=&quot;</span> + sid +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Student&#123;name=&#x27;null&#x27;, gender=&#x27;null&#x27;, sid=1&#125;</span></span><br><span class="line"><span class="comment">            Student&#123;name=&#x27;李四&#x27;, gender=&#x27;女&#x27;, sid=2&#125;</span></span><br><span class="line"><span class="comment">            Student&#123;name=&#x27;王五&#x27;, gender=&#x27;男&#x27;, sid=3&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<ol start="3">
<li> <strong>static修饰方法：静态静态方法、类方法</strong></li>
</ol>
</blockquote>
<ul>
<li><p>随着类的加载而加载；</p>
</li>
<li><p>建议使用<code>类名.方法名</code>直接调用静态方法，而不是通过实例对象调用静态方法（当然也可以调用成功）。</p>
</li>
<li><p>注意事项：</p>
<ol>
<li><strong>静态方法只能访问静态成员（静态方法+静态变量）</strong>。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>非静态方法既可以调用非静态的方法或属性，也可以调用静态的方法或属性。</li>
<li><strong>静态方法中不能使用 this 和 super 关键字</strong>。【因为 this 和 super 都代表对象实例，而静态方法不依赖任何实例对象】</li>
</ol>
<p><strong>如何理解？</strong></p>
<p>​        <em>因为静态成员先于实例对象成员创建，静态成员在类加载阶段就已经被创建出来了，而实例成员直到执行 <code>&lt;init&gt;()</code> 构造方法时才被创建出来，所以静态成员有可能访问不到实例。</em></p>
<blockquote>
<ol start="4">
<li> <strong>static 修饰代码块：静态代码块</strong></li>
</ol>
</blockquote>
<ul>
<li><p>  静态代码块：使用<code>static</code>修饰的代码块，定义在<strong>类中方法外</strong>。</p>
</li>
<li><p>  随着类的加载而执行，且只执行一次，优先于和构造方法的执行。</p>
</li>
<li><p><strong>格式</strong>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class ClassName&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用</strong>：给类变量进行初始化赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 给类变量赋值</span></span><br><span class="line">        id = <span class="number">2</span>;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到list中</span></span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ol start="5">
<li> <strong>static 内存分布</strong></li>
</ol>
</blockquote>
<p><code>static</code>修饰的内容：</p>
<ol>
<li>是随着类的加载而加载的，且只加载一次。</li>
<li>存储于一块固定的内存区域（静态区），所以可以直接通过类名调用。</li>
<li>它优先于对象存在，所以，可以被所有对象共享。</li>
</ol>
<ul>
<li>非静态成员变量：操作各自的空间（堆内存中）</li>
<li>静态成员变量：操作共享空间（方法区的静态区中）</li>
</ul>
<p><img src="/2020/05/26/JavaSE/%E9%9D%99%E6%80%81%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png"></p>
<hr>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote>
<p>  <strong>可以修饰的结构：</strong></p>
</blockquote>
<ul>
<li>  类、方法、变量</li>
</ul>
<blockquote>
<p>  <strong>final 修饰类</strong>：</p>
</blockquote>
<ul>
<li>  被修饰的类，不能被继承。</li>
<li>  比如：String类、System类、StringBuffer类</li>
</ul>
<blockquote>
<p>  <strong>final 修饰方法</strong></p>
</blockquote>
<ul>
<li>  被修饰的方法，不能被重写。</li>
<li>  比如：Object 类中 <code>getClass()</code></li>
</ul>
<blockquote>
<p>  <strong>final 修饰变量</strong></p>
</blockquote>
<ul>
<li>被修饰的普通类型变量，不能被重新赋值。</li>
<li>被修饰的引用类型变量，引用的地址值不能再发生改变。</li>
<li>被 final 修饰的变量，建议在定义时所有字母都使用大写。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li><p>修饰类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finall class 类名&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修饰方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写被final修饰的方法，编译时会报错。</span></span><br></pre></td></tr></table></figure></li>
<li><p>修饰变量</p>
<blockquote>
<ul>
<li><strong>基本类型变量</strong>：基本类型的局部变量，被<code>final</code>修饰后，只能赋值一次，不能再次被赋值。</li>
<li><strong>引用类型变量</strong>：引用类型的局部变量，被<code>final</code>修饰后，只能指向一个引用，地址不能再更改，但是不影响对象内部成员变量值的修改。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、修饰基本类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    a = <span class="number">99</span>; <span class="comment">// error，编译时直接报错，不可被重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、修饰引用类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    u = <span class="keyword">new</span> <span class="title class_">User</span>();     <span class="comment">// error,地址不能再修改</span></span><br><span class="line">    u.setName(<span class="string">&quot;zs&quot;</span>);    <span class="comment">// Ok，可以修改对象内部成员变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="权限修饰符（3个-4类）"><a href="#权限修饰符（3个-4类）" class="headerlink" title="权限修饰符（3个/4类）"></a>权限修饰符（3个/4类）</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">package-private</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一类中</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">同一包中</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包中有继承关系的类</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包中的无关类</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>package private：包级私有</p>
<blockquote>
<p><strong>建议</strong>：</p>
<ol>
<li>成员变量使用<code>private</code>，隐藏细节。</li>
<li>构造方法使用<code>public</code>，方便创建对象。</li>
<li>成员方法使用<code>public</code>，方便调用方法。</li>
</ol>
</blockquote>
<hr>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>this</code> 可以理解为：当前对象  或 当前正在创建的对象。</p>
<p><strong>可以调用的结构</strong>：属性；方法；构造器</p>
<blockquote>
<p>  <strong><code>this</code> 调用属性、方法</strong>：</p>
</blockquote>
<ol>
<li>在<strong>类的方法</strong>中，我们可以使用 <code>this.属性</code> 或 <code>this.方法</code> 的方式，调用<strong>当前对象</strong>的属性或方法。<ul>
<li>  通常情况下，我们都择省略 <code>this.</code>。</li>
<li>  特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用 <code>this.变量</code> 的方式，表明此变量是属性，而非形参。</li>
</ul>
</li>
<li>在<strong>类的构造器</strong>中，我们可以使用 <code>this.属性</code> 或 <code>this.方法</code> 的方式，调用<strong>当前正在创建的对象</strong>的属性或方法。<ul>
<li>  通常情况下，我们都择省略 <code>this.</code>。</li>
<li>  特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用 <code>this.变量</code> 的方式，表明此变量是属性，而非形参。</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong><code>this</code> 调用构造器：</strong></p>
</blockquote>
<ul>
<li>  我们在类的构造器中，可以显式的使用 <code>this(形参列表)</code> 的方式，调用本类中指定的其他构造器；</li>
<li>  构造器中不能通过 <code>this(形参列表)</code> 的方式调用自己，因为这样会无限递归。【总的原则就是一个构造器调用其它的构造器不能出现无限递归，出现递归则会发生编译时异常】</li>
<li>  如果一个类中有 n 个构造器，则最多可以有 <code>n-1</code> 个构造器中调用用了 <code>this(形参列表)</code>。</li>
<li>  规定：<code>this(形参列表)</code> 必须声明在当前构造器的首行。</li>
<li>  构造器内部，最多只能声明一个 <code>this(形参列表)</code>，用来调用其他的构造器。</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p><code>super</code> 关键字可以理解为：父类对象</p>
<p><strong>可以调用的结构</strong>：属性、方法、构造器</p>
<blockquote>
<p>  <strong>super 调用属性、方法：</strong></p>
</blockquote>
<p>我们可以在子类的方法或构造器中，通过使用 <code>super.属性</code> 或 <code>super.方法</code> 的方式，显式的调用父类中声明的属性或方法。</p>
<ul>
<li>  通常情况下，我们习惯省略 <code>super.</code>；</li>
<li>  特殊情况1：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用 <code>super.属性</code> 的方式，表明调用的是父类中声明的属性。</li>
<li>  特殊情况2：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用 <code>super.方法</code> 的方式，表明调用的是父类中被重写的方法。</li>
</ul>
<blockquote>
<p>  <strong>super调用构造器</strong>：</p>
</blockquote>
<ul>
<li>  我们可以在子类的构造器中显式的使用 <code>super(形参列表)</code> 的方式，调用父类中声明的指定的构造器；</li>
<li>  <code>super(形参列表)</code> 的使用，必须声明在子类构造器的首行！</li>
<li>  我们<strong>在类的构造器中，针对于 <code>this(形参列表)</code> 或 <code>super(形参列表)</code> 只能二一，不能同时出现</strong>。</li>
<li>  在构造器的首行，没显式的声明 <code>this(形参列表)</code> 或 <code>super(形参列表)</code>，则默认调用的是父类中空参的构造器 <code>super()</code>。</li>
<li>  在类的多个构造器中，至少要存在一个类构造器中使用了 <code>super(形参列表)</code>，调用父类中的构造器。</li>
</ul>
<hr>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><h2 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h2><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><blockquote>
<p>见<code>13.2    abstract</code></p>
</blockquote>
<hr>
<h1 id="11-封装"><a href="#11-封装" class="headerlink" title="11    封装"></a>11    封装</h1><blockquote>
<p>  <strong>封装</strong>：将某些属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。</p>
</blockquote>
<h2 id="11-1-为什么要有封装？"><a href="#11-1-为什么要有封装？" class="headerlink" title="11.1    为什么要有封装？"></a>11.1    为什么要有封装？</h2><ol>
<li> <strong>程序设计追求“高内聚，低耦合”。</strong></li>
<li> <strong>隐藏对象内部的复杂性，只对外公开简单的接口，让代码更容易理解</strong>。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</li>
<li> <strong>提高代码的安全性</strong>，防止该类的代码和数据被其它类随意访问。</li>
</ol>
<blockquote>
<ul>
<li>  高内聚：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>  低耦合：仅对外暴露少量的方法用于使用。</li>
</ul>
</blockquote>
<h2 id="11-2-封装思想的代码提现"><a href="#11-2-封装思想的代码提现" class="headerlink" title="11.2    封装思想的代码提现"></a>11.2    封装思想的代码提现</h2><ol>
<li> 将类的属性私有化（private），同时提供公共（public）的<code>get/set</code>方法来获取和设置该属性的值。</li>
<li> 不对外暴露的私有（private）的方法。</li>
<li> 单例模式（将构造器私有化）。</li>
<li> 如果不希望类在包外被调用，可以将类设置为缺省的。</li>
</ol>
<h2 id="11-3-权限修饰符"><a href="#11-3-权限修饰符" class="headerlink" title="11.3    权限修饰符"></a>11.3    权限修饰符</h2><blockquote>
<p>  <strong>权限修饰符可用来修饰的结构说明：</strong></p>
</blockquote>
<ul>
<li>  4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</li>
<li>  修饰非内部类的话，只能使用：缺省、public</li>
</ul>
<p><img src="/2020/05/26/JavaSE/image-20210730173311690.png" alt="image-20210730173311690"></p>
<h2 id="11-3-封装优化"><a href="#11-3-封装优化" class="headerlink" title="11.3    封装优化"></a>11.3    封装优化</h2><h3 id="1-this关键字"><a href="#1-this关键字" class="headerlink" title="1.    this关键字"></a>1.    this关键字</h3><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.    构造方法"></a>2.    构造方法</h3><hr>
<h1 id="12-继承"><a href="#12-继承" class="headerlink" title="12    继承"></a>12    继承</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<p>多个类中存在相同属性或行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。</p>
<blockquote>
<p>  <strong>继承：</strong></p>
</blockquote>
<ul>
<li>子类继承父类的<strong>非私有和非静态的</strong>属性和方法，使得子类对象具有与父类对象相同的属性、方法。</li>
<li>子类可以直接访问父类中的非私有和非静态的属性和行为。</li>
</ul>
<blockquote>
<p>  <strong>好处</strong>：</p>
</blockquote>
<ol>
<li>提高代码的复用性</li>
<li>类与类之间产生了关系，是多态的前提。</li>
</ol>
<blockquote>
<p>  <strong>继承的特点</strong></p>
</blockquote>
<ol>
<li> 一个类可以被多个子类继承。</li>
<li> 单继承：一个类只能有一个父类</li>
<li> 子类直接继承的父类，称为 <strong>直接父类</strong>；间接继承的父类称为 <strong>间接父类</strong>。</li>
<li> 子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法。</li>
</ol>
<h2 id="为什么要有？"><a href="#为什么要有？" class="headerlink" title="为什么要有？"></a>为什么要有？</h2><ol>
<li> 减少了代码的冗余，提高了代码的复用性。【像Java中很多顶级父类，一直从JDK1.1、1.2的版本沿用至今，很多都是利用类的继承性】</li>
<li> 便于功能的扩展</li>
<li> 多态性的前提</li>
</ol>
<h2 id="继承后的特点"><a href="#继承后的特点" class="headerlink" title="继承后的特点"></a>继承后的特点</h2><p><img src="/2020/05/26/JavaSE/%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%90%8E%E6%88%90%E5%91%98%E7%9A%84%E7%89%B9%E7%82%B9.png" alt="子类继承父类后成员的特点"></p>
<h3 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="1.    成员变量"></a>1.    成员变量</h3><ul>
<li><p>子父类中成员变量无重名：无影响</p>
</li>
<li><p><strong>子父类中成员变量有重名</strong>：有影响，通过子类对象访问父类中的<strong>非私有成员变量</strong>时，需要使用<code>super</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.父类成员变量</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-普通方法"><a href="#2-普通方法" class="headerlink" title="2.    普通方法"></a>2.    普通方法</h3><ul>
<li>子父类中成员方法无重名：无影响</li>
<li><strong>字父类中成员方法有重名：重写</strong></li>
</ul>
<h3 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3.    构造方法"></a>3.    构造方法</h3><ul>
<li>  因为构造方法的名字和类名是一致的，所以不会出现子类和父类中构造方法重名的问题。</li>
<li>  构造方法的作用是创建并初始化对象，由于创建子类对象时要用到一部分父类对象的数据，所以在创建子类对象之前，必须先初始化父类对象。</li>
<li>  子类的无参构造器中会隐式地调用 <code>super()</code> 方法来调用父类的构造方法，这个隐式调用在编译后位于构造方法的第一行。</li>
<li>  所以说如果想要重载子类的构造方法，必须先显式地调用父类的构造方法，即<code>super()</code>。因为 JVM 不会对重载的构造方法进行隐式调用 <code>super()</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="comment">// 重载子类的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();    <span class="comment">// 调用父类构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>父类对象优先于子类对象产生</strong></p>
</blockquote>
<p>因为子类对象中包含了父类对象的部分成员变量和方法，所以每次创建子类对象时，先要初始化父类对象，再初始化子类对象。</p>
<ul>
<li><p><strong>super</strong>：代表父类的存储空间地址。</p>
</li>
<li><p><strong>this</strong>：代表当前对象的引用。</p>
</li>
</ul>
<img src="/2020/05/26/JavaSE/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" style="zoom:80%;">



<hr>
<h2 id="super-amp-this"><a href="#super-amp-this" class="headerlink" title="super &amp; this"></a>super &amp; this</h2><ul>
<li>  <code>this</code> 时当前对象的引用，可以调用当前对象的 属性、普通方法 和 <strong>构造方法</strong> 。</li>
<li>  <code>super</code>表示父类对象的引用，可以调用父类对象中的 属性、普通方法 和 <strong>构造方法</strong> 。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">调用方式</td>
<td align="center">调用当前对象的属性、方法、构造函数</td>
<td align="center">调用父类对象中的属性、方法、构造函数</td>
</tr>
<tr>
<td align="center">调用位置</td>
<td align="center">调用构造函数时放在第一行，其它可自行选择</td>
<td align="center">调用构造函数时放在第一行，其它可自行选择</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>  <strong>this(参数)</strong> 表示调用当前对象的构造方法，</li>
<li>  <strong>super(参数)</strong> 表示调用父类对象的构造方法。</li>
</ul>
</blockquote>
<hr>
<h2 id="子类对象实例化全过程"><a href="#子类对象实例化全过程" class="headerlink" title="子类对象实例化全过程"></a>子类对象实例化全过程</h2><blockquote>
<p>  <strong>从结果上看</strong>：继承性</p>
</blockquote>
<ul>
<li>  子类继承父类以后，就获取了父类中声明的属性或方法。</li>
<li>  创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</li>
</ul>
<blockquote>
<p>  <strong>从过程上看</strong>：</p>
</blockquote>
<p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类构造器，进而调用父类的父类构造器，… 直到调用了java.lang.Object 类中空参的构造器为止。正因为加载过所有的父类结构，所以在子类中才可以看到内存中父类中的结构，子类对象才可以进行调用。</p>
<blockquote>
<p>  <strong>图示</strong></p>
</blockquote>
<p><img src="/2020/05/26/JavaSE/image-20210730212054243.png" alt="image-20210730212054243"></p>
<blockquote>
<p>  <strong>注意事项</strong>：</p>
</blockquote>
<p><strong>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为 new 的子类对象</strong>。并没有创建对应的父类实例，只是将父类的 Class 对象加载到内存中读取了被子类继承的方法和属性而已。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Java 虽然不支持多继承，但支持多层继承。所有的类都继承自 java.lang.Object 类，这就意味着所的类具有 Object 类声明的功能。</p>
<blockquote>
<p>  <a href>Object</a></p>
</blockquote>
<hr>
<h1 id="13-抽象类"><a href="#13-抽象类" class="headerlink" title="13    抽象类"></a>13    抽象类</h1><h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1    概述"></a>13.1    概述</h2><blockquote>
<p>父类中的方法，往往被多个子类重写，子类各自的实现方式不尽相同。所以父类中方法的<strong>方法声明</strong>和<strong>方法体</strong>，大多数时候只有方法声明还有意义，而方法主体则没有实际意义了。为了方便，大多数时候我们在父类中只编写<strong>方法声明</strong>，而把具体的<strong>方法体</strong>交给子类去实现。</p>
</blockquote>
<ul>
<li>我们把没有方法体并使用<code>abstract</code>修饰的方法，叫做<strong>抽象方法</strong>。</li>
<li>把使用<code>abstract</code>修饰的类，叫做<strong>抽象类</strong>。[抽象类中可以没有抽象方法]</li>
</ul>
<h2 id="13-2-abstract"><a href="#13-2-abstract" class="headerlink" title="13.2    abstract"></a>13.2    abstract</h2><blockquote>
<p>  <strong>可以修饰的结构：类、方法</strong></p>
</blockquote>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>  <strong>抽象类不能实例化。</strong></li>
<li>  <strong>但是抽象类中一定有构造器，便于子类实例化时调用。</strong></li>
<li>  开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作。</li>
<li>  <strong>抽象类中，不一定包含抽象方法</strong>，但是包含抽象方法的类必定是抽象类。</li>
<li>  抽象类的子类必须重写父类中所有的抽象方法。否则，该子类也必须声明为抽象类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">    <span class="comment">// 抽象方法（必须）</span></span><br><span class="line">    <span class="comment">// 其它.....</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="抽象类结构"><a href="#抽象类结构" class="headerlink" title="抽象类结构"></a>抽象类结构</h4><p><strong>必须有：</strong></p>
<ol>
<li>构造方法</li>
</ol>
<p><strong>可以有</strong>：</p>
<ol start="2">
<li> 抽象方法</li>
<li> 普通属性、方法</li>
<li> 静态属性、静态方法。</li>
</ol>
<p><strong>总结：</strong>抽象类和普通类只有两点不同：</p>
<ul>
<li>  抽象类必须用 <code>abstract</code> 修饰外；</li>
<li>  抽象类中<strong>可以</strong>包含抽象方法。</li>
</ul>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br><span class="line"><span class="comment">// 没有方法体</span></span><br></pre></td></tr></table></figure>





<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li> <code>abstract</code> 不能用来修饰：属性、构造器等结构</li>
<li> <code>abstract</code> 不能用来修饰私有方法、静态方法、<code>final</code> 的方法、<code>final</code> 的类。</li>
</ol>
<p><strong>理解：</strong></p>
<p><code>abstract</code> 的作用就是定义顶级的接口和方法，一般只起一个声明的作用，而不做具体实现，具体实现交由不同的子类去完成。而我们上面的这些方法：构造方法、私有方法、静态方法、final 方法，它们都有一个共同的特点，就是<strong>每个方法都不能被重写</strong>。这些方法都不能被子类去重新实现，也就是说如果你把这些方法声明为抽象的，它们就会永久成为抽象的了，这样就失去了定义方法的意义。</p>
<blockquote>
<p>  <strong>总结：<code>abstract</code> 修饰的方法，必须要能被重写。</strong></p>
</blockquote>
<h3 id="设计模式——模板方法"><a href="#设计模式——模板方法" class="headerlink" title="设计模式——模板方法"></a>设计模式——模板方法</h3><hr>
<h1 id="14-接口"><a href="#14-接口" class="headerlink" title="14    接口"></a>14    接口</h1><ul>
<li>  接口用来定义一种对外的<strong>规范</strong>。</li>
<li>  接口是一种<strong>引用类型</strong>，是方法的集合。</li>
</ul>
<h2 id="14-1-接口中的成员"><a href="#14-1-接口中的成员" class="headerlink" title="14.1    接口中的成员"></a>14.1    接口中的成员</h2><blockquote>
<p>  <strong>JDK8 之前</strong>：接口中只能定义全局常量和抽象方法。</p>
</blockquote>
<ul>
<li>  <strong>全局</strong>常量：<code>public static final</code>的.但是书写时，可以省略不写</li>
<li>  <strong>全局</strong>抽象方法：<code>public abstract</code> 的方法</li>
<li>  注意：一定要是全局 <code>public</code> 的，不是全局的就会产生编译时异常。</li>
</ul>
<img src="/2020/05/26/JavaSE/image-20210731003259648.png" alt="image-20210731003259648" style="zoom:80%;">



<blockquote>
<ol start="2">
<li> <strong>从 JDK8 开始</strong>：接口中除了定义全局常量和抽象方法之外，还可以定义<strong>静态方法、默认方法</strong>。</li>
</ol>
</blockquote>
<ul>
<li>  <strong>注意</strong>：无论是静态方法还是默认方法，前提都必须是<strong>全局方法</strong>。</li>
</ul>
<img src="/2020/05/26/JavaSE/image-20210731003735380.png" alt="image-20210731003735380" style="zoom:80%;">



<blockquote>
<ol start="3">
<li> <strong>从 JDK9 开始</strong>：接口中新增可以定义私有（private）方法了。</li>
</ol>
</blockquote>
<ul>
<li>  接口中的私有方法用于改善接口内部的代码可重用性。比如多个 default 方法中存在重复的代码可以抽取出一个 private 方法供接口内部调用。但是这个方法是不会对外暴露的，所以说接口对外暴露的方法都要求必须是全局(public)的。</li>
<li>  可以说正是因为 JDK8 的改动才导致 JDK9 需要在接口内部新增可以定义私有方法。因为在 JDK8 之前，接口内部是不存在方法实现的，从 JDK8 开始新增了 默认方法 和 静态方法 后，接口内部才可以写一些方法实现了。</li>
</ul>
<blockquote>
<p>  <strong>总结</strong></p>
</blockquote>
<ol>
<li><p> 接口中对外暴露的方法必须是<strong>全局方法</strong>。</p>
</li>
<li><p> 接口中<strong>只能定义方法和常量</strong>，<strong>变量和代码块都不能在接口中定义</strong>。</p>
</li>
<li><p> 接口中没有构造方法，不能被实例化。</p>
</li>
<li><p> 接口中的默认方法（default 修饰的方法）与类中的默认权限修饰符方法是不同的。</p>
</li>
<li><p> 如果实现类实现了接口中的所有抽象方法，则此实现类就可以实例化了；如果实现类没有实现接口中的所有抽象方法，则此实现类仍为一个抽象类，仍然不能被实例化。</p>
</li>
<li><p>Java类可以实现多个接口。【弥补了Java单继承性的局限性】</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">BB</span> <span class="keyword">implements</span> <span class="title class_">CC</span>,DD,EE</span><br></pre></td></tr></table></figure></li>
<li><p> 接口与接口之间可以继承，而且可以多继承。</p>
</li>
</ol>
<h3 id="接口、普通类、抽象类中的成员比较"><a href="#接口、普通类、抽象类中的成员比较" class="headerlink" title="接口、普通类、抽象类中的成员比较"></a>接口、普通类、抽象类中的成员比较</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">普通类</th>
<th align="center">抽象类</th>
<th align="center">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">属性（成员<strong>变量</strong>）</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center"><strong>全局</strong>常量<code>[public static final]</code></td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">构造方法</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center">成员方法</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">抽象方法</td>
<td align="center">✖</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">私有方法</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔<code>[JDK9++]</code></td>
</tr>
<tr>
<td align="center">静态方法</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔<code>[JDK8++]</code></td>
</tr>
<tr>
<td align="center">默认方法</td>
<td align="center">–</td>
<td align="center">1️⃣</td>
<td align="center">✔<code>[JDK8++]</code></td>
</tr>
<tr>
<td align="center">静态代码块</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✖</td>
</tr>
</tbody></table>
<h2 id="14-2-接口-vs-抽象类"><a href="#14-2-接口-vs-抽象类" class="headerlink" title="14.2    接口 vs.抽象类"></a>14.2    接口 vs.抽象类</h2><ul>
<li>  接口和抽象类都不能被实例化。</li>
<li>  但是抽象类中有构造方法，而接口中没有构造方法。</li>
<li>  创建接口的实现类对象，就可以调用接口中的<strong>非静态和非私有</strong>方法了。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">接口</th>
<th align="center">抽象类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否可以实例化？</td>
<td align="center">✖</td>
<td align="center">✖</td>
</tr>
<tr>
<td align="center">是否包含构造方法？</td>
<td align="center">✖</td>
<td align="center">✔</td>
</tr>
</tbody></table>
<h2 id="14-3-接口中的成员详解"><a href="#14-3-接口中的成员详解" class="headerlink" title="14.3    接口中的成员详解"></a>14.3    接口中的成员详解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名称&#123;</span><br><span class="line">    <span class="comment">// 全局抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 全局默认方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-抽象方法"><a href="#1-抽象方法" class="headerlink" title="1    抽象方法"></a>1    抽象方法</h3><ol>
<li>使用<code>public abstract abstract</code> 修饰，没有方法体，该方法供子类实现使用。</li>
<li>接口中有多个抽象方法并且抽象方法有重名时，只需重写一次。</li>
</ol>
<h3 id="2-默认方法（JDK8-）"><a href="#2-默认方法（JDK8-）" class="headerlink" title="2    默认方法（JDK8++）"></a>2    默认方法（JDK8++）</h3><ol>
<li><p>使用<code>public default</code>修饰，供子类调用或重写。</p>
</li>
<li><p>实现类可以继承，可以重写默认方法，但是只能通过实现类的对象来调用（因为接口不能创建实例对象）。[实现类的对象又可以使用接口来表示，这就是多态，父类引用指向子类对象]</p>
</li>
</ol>
<h3 id="3-静态方法（JDK8-）"><a href="#3-静态方法（JDK8-）" class="headerlink" title="3     静态方法（JDK8++）"></a>3     静态方法（JDK8++）</h3><ol>
<li>使用<code>public static</code> 修饰，<strong>只能</strong>通过 <code>接口名.方法名</code> 直接调用。【因为接口不能创建实例对象】</li>
<li>静态方法保存在内存中的方法区，<strong>只能使用接口名调用，不能通过实现类名或实现类对象调用</strong>。</li>
</ol>
<ul>
<li>  普通类中的静态方法，既可以通过类名调用，也可以通过实例对象调用。</li>
<li>  接口中的静态方法，不能够通过 实现类类名 和 实现类对象 调用。</li>
<li>  普通类中，静态属性和静态方法只保留一份在方法区中，实例对象中保存着 Class 对象的地址，所以可以通过实例对象调用 Class 对象中的属性和方法。</li>
<li>  但是在接口中，子类实现接口的时候 私有方法 和 静态方法 不会继承给子类，所以子类成员中就已经失去了私有方法和静态方法，显然实例化时也没有私有方法和静态方法的地址信息，所以不能通过 实现类类名 和 实现类对象 调用。*</li>
</ul>
<ol start="3">
<li>接口中，存在同名的静态方法并不会冲突，因为静态方法不会继承给实现类，只能通过各自的接口名访问。</li>
</ol>
<h3 id="4-私有方法"><a href="#4-私有方法" class="headerlink" title="4    私有方法"></a>4    私有方法</h3><ol>
<li><p>使用<code>private</code>关键字修饰，<strong>在接口中可以省略</strong>，<strong>供接口中的默认方法或静态方法调用</strong>。</p>
<ul>
<li><strong>私有方法</strong>：只有默认方法可以调用。</li>
<li><strong>私有静态方法</strong>：默认方法和静态方法都可以调用。</li>
</ul>
</li>
<li><p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么就可以抽取出来，封装到私有方法中，供默认方法调用【类似于工具类】。</p>
</li>
</ol>
<hr>
<h2 id="14-4-接口的实现"><a href="#14-4-接口的实现" class="headerlink" title="14.4    接口的实现"></a>14.4    接口的实现</h2><blockquote>
<p>类与接口的关系叫做实现关系。即<strong>类实现接口</strong>。</p>
<p>该类可以称为接口的实现类，也可以称为接口的子类。</p>
</blockquote>
<h3 id="1-非抽象子类实现接口"><a href="#1-非抽象子类实现接口" class="headerlink" title="1  非抽象子类实现接口"></a>1  非抽象子类实现接口</h3><ol>
<li>必须重写接口中所有抽象方法。</li>
<li>继承了接口中的默认方法，既可以直接调用，也可以重写。</li>
<li>无法继承接口中的私有方法和静态方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 子类 implements 接口名&#123;</span><br><span class="line">    <span class="comment">// 重写接口中的抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中的默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-接口的多实现"><a href="#2-接口的多实现" class="headerlink" title="2.    接口的多实现"></a>2.    接口的多实现</h3><ul>
<li>一个类只能继承一个父类。</li>
<li>但是，一个类可以实现多个接口。</li>
<li>而且，一个类可以继承一个父类的同时，实现多个接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 子类名 extends 父类名 implements 接口名<span class="number">1</span>，接口名<span class="number">2</span>，...&#123;</span><br><span class="line">    <span class="comment">// 重写接口中的抽象方法【必须】</span></span><br><span class="line">    <span class="comment">// 重写接口中的默认方法【不重名时可选】</span></span><br><span class="line">    <span class="comment">// 重写其它方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h4><ul>
<li><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</p>
<p><strong><code>extends &gt; 接口1 &gt; 接口2 &gt; ...</code></strong></p>
</li>
</ul>
<hr>
<h2 id="14-5-接口的多继承"><a href="#14-5-接口的多继承" class="headerlink" title="14.5    接口的多继承"></a>14.5    接口的多继承</h2><ul>
<li>一个类只能直接继承一个父类，</li>
<li>但是，一个接口能继承另一个或多个接口。</li>
<li>接口的继承使用<code>extends</code>关键字。</li>
<li>子接口继承多个父接口，如果父接口中的方法有重名的，那么子接口需要重写一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B&#123;	<span class="comment">// A,B都是接口</span></span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附1：-1"><a href="#附1：-1" class="headerlink" title="附1："></a>附1：</h4><ol>
<li>子接口重写默认方法时，<code>default</code>关键字可以保留。</li>
<li><strong>子类(实现类)重写默认方法时，<code>default</code>关键字不可以保留。</strong></li>
</ol>
<hr>
<h2 id="14-6-接口中的注意事项"><a href="#14-6-接口中的注意事项" class="headerlink" title="14.6    接口中的注意事项"></a>14.6    接口中的注意事项</h2><ol>
<li><strong>接口中，无法定义成员变量，但是可以定义成员常量</strong>，其值不可以改变，使用<code>public static final</code>修饰。</li>
<li>接口中，没有构造方法，不能创建对象<strong>。</strong></li>
<li>接口中，只能有方法和常量，不能有代码块（包括静态代码块和非静态代码块）。</li>
<li><strong>类优先原则</strong>：如果子类同时继承了父类和实现了接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。</li>
<li><strong>接口冲突原则：</strong>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没重写此方法的情况下会报错。这就需要我们必须在实现类中重写此方法</li>
<li>通过实现类的对象，可以调用接口中的默认方法。如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法。</li>
<li>如果想要在实现类中调用接口中的默认方法，可以通过 <code>super.方法名</code> 来调用。</li>
</ol>
<hr>
<h1 id="15-多态"><a href="#15-多态" class="headerlink" title="15    多态"></a>15    多态</h1><h2 id="15-1-是什么"><a href="#15-1-是什么" class="headerlink" title="15.1    是什么"></a>15.1    是什么</h2><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<ul>
<li>  多态是指同一行为，具有多个不同的表现形式。</li>
<li>  指<strong>程序中定义的引用变量所指向的具体类型和通过该引用变量调用的方法调用在编译期并不确定，而是在运行期才确定</strong>。</li>
</ul>
<blockquote>
<p>  <strong>对象的多态性</strong>：</p>
</blockquote>
<p>父类的引用指向子类的对象。</p>
<blockquote>
<p>  <strong>充要条件</strong>：</p>
</blockquote>
<ol>
<li>继承或实现。【二选一】</li>
<li>重写父类方法。【意义体现】</li>
<li>父类引用指向子类对象。【格式体现】</li>
</ol>
<blockquote>
<p>  <strong>格式</strong>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>注意事项</strong>：</p>
</blockquote>
<ul>
<li>对象的多态性，只适用于方法，不适用于属性。</li>
<li>用多态的方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后的方法。</li>
</ul>
<blockquote>
<p>  <strong>多态的好处</strong>：</p>
</blockquote>
<ul>
<li>  定义时可以只定义顶层接口(类)，具体实现的时候再关注到底层细节。</li>
</ul>
<hr>
<h2 id="15-2-向上转型-amp-向下转型"><a href="#15-2-向上转型-amp-向下转型" class="headerlink" title="15.2    向上转型 &amp; 向下转型"></a>15.2    向上转型 &amp; 向下转型</h2><h3 id="1-向上转型"><a href="#1-向上转型" class="headerlink" title="1.    向上转型"></a>1.    向上转型</h3><ul>
<li>向上转型 == 多态；</li>
<li>多态本身就是子类类型向父类类型转换的过程，这个过程是默认的。</li>
<li>当父类引用指向一个子类对象时，便是向上转型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br></pre></td></tr></table></figure>





<h3 id="2-向下转型"><a href="#2-向下转型" class="headerlink" title="2.    向下转型"></a>2.    向下转型</h3><blockquote>
<p>  <strong>是什么？</strong></p>
</blockquote>
<ul>
<li><p>向下转型：父类类型向子类类型转换的过程，这个过程是<strong>强制</strong>的。</p>
</li>
<li><p>将父类实例转换为子类实例可以使用强制类型转换的格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型)父类对象的变量名;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>  <strong>为什么要向下转型？</strong></p>
</blockquote>
<p>由于对象具有多态性，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？就是使用向下转型。</p>
<blockquote>
<p>  <strong>注意：转型的异常</strong></p>
</blockquote>
<ol>
<li> 使用强转时，可能出现 <strong>ClassCastException</strong> 的异常。</li>
<li> 为了避免在向下转型时出现 <code>ClassCastException </code>的异常，我们在向下转型之前，会先进行 <code>instanceof </code>的判断，只有返回为 true 时才进行向下转型；如果返回 false 则不进行向下转型。</li>
</ol>
<blockquote>
<p>  <strong>instanceof 的使用：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">① a <span class="keyword">instanceof</span> A：判断对象a是否是类A的实例，如果是返回<span class="literal">true</span>；如果不是返回<span class="literal">false</span>。</span><br><span class="line">② 如果 a <span class="keyword">instanceof</span> A 返回<span class="literal">true</span>，则 a <span class="keyword">instanceof</span> B 也返回<span class="literal">true</span>。其中，类B是类A的父类。</span><br><span class="line">③ 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</span><br><span class="line"></span><br><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1. 如果变量名属于该类型，则返回true；</span></span><br><span class="line"><span class="comment">	2. 如果变量名不属于该类型，则返回false。</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>规范的语法格式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"><span class="keyword">if</span> (p1 <span class="keyword">instanceof</span> Woman) &#123;</span><br><span class="line">    <span class="type">Woman</span> <span class="variable">w</span> <span class="operator">=</span> (Woman) p1;	<span class="comment">//强制类型转换，向下转型</span></span><br><span class="line">    w.shopping();	<span class="comment">//调用子类方法</span></span><br><span class="line">    w.beauty = <span class="literal">false</span>;	<span class="comment">//调用子类属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-对比"><a href="#3-对比" class="headerlink" title="3    对比"></a>3    对比</h3><p><img src="/2020/05/26/JavaSE/image-20210730215015521.png" alt="image-20210730215015521"></p>
<hr>
<h2 id="15-3-接口多态的综合案例"><a href="#15-3-接口多态的综合案例" class="headerlink" title="15.3    接口多态的综合案例"></a>15.3    接口多态的综合案例</h2><h3 id="1-笔记本电脑"><a href="#1-笔记本电脑" class="headerlink" title="1.    笔记本电脑"></a>1.    笔记本电脑</h3><pre><code>笔记本电脑（laptop）通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口，但是具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。

定义USB接口，具备最基本的开启功能和关闭功能。

鼠标和键盘想要能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘生产出来也无法使用。
</code></pre>
<h3 id="2-案例分析"><a href="#2-案例分析" class="headerlink" title="2.    案例分析"></a>2.    案例分析</h3><pre><code>定义笔记本类，USB接口，USB鼠标类，USB键盘类。
</code></pre>
<ol>
<li>USB接口，包括开启、关闭功能</li>
<li>笔记本类，包含运行功能、关机功能、使用USB设备功能</li>
<li>鼠标类，要实现USB接口，并具备点击功能。</li>
<li>键盘类，要实现USB接口，并具备敲击功能。</li>
</ol>
<h3 id="3-案例实现"><a href="#3-案例实现" class="headerlink" title="3.    案例实现"></a>3.    案例实现</h3><ol>
<li><p>定义USB接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// USB接口，包括开启、关闭功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Usb</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义Mouse实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标已连接，可正常使用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标已断开连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;点击鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>定义Keyboard实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Keyboard</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘已连接，可正常使用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘已断开连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">knock</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;敲击键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>定义笔记本Laptop类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  笔记本类：包含运行功能、关机功能、使用USB设备功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Laptop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一键关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用USB设备功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useUsb</span><span class="params">(Usb usb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (usb!=<span class="literal">null</span>)&#123;</span><br><span class="line">            usb.open();</span><br><span class="line">            <span class="keyword">if</span> (usb <span class="keyword">instanceof</span> Mouse)&#123;</span><br><span class="line">                ((Mouse) usb).click();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (usb <span class="keyword">instanceof</span> Keyboard)&#123;</span><br><span class="line">                ((Keyboard) usb).knock();</span><br><span class="line">            &#125;</span><br><span class="line">            usb.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Laptop</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义笔记本类，USB接口，USB鼠标类，USB键盘类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1. USB接口，包括开启、关闭功能</span></span><br><span class="line"><span class="comment">        2. 笔记本类，包含运行功能、关机功能、使用USB设备功能</span></span><br><span class="line"><span class="comment">        3. 鼠标类，要实现USB接口，并具备点击功能。</span></span><br><span class="line"><span class="comment">        4. 键盘类，要实现USB接口，并具备敲击功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个笔记本对象</span></span><br><span class="line">        <span class="type">Laptop</span> <span class="variable">laptop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Laptop</span>();</span><br><span class="line">        <span class="comment">// 2. 笔记本开机</span></span><br><span class="line">        laptop.run();</span><br><span class="line">        <span class="comment">// 3. 使用鼠标</span></span><br><span class="line">        laptop.useUsb(<span class="keyword">new</span> <span class="title class_">Mouse</span>());</span><br><span class="line">        <span class="comment">// 4. 使用键盘</span></span><br><span class="line">        laptop.useUsb(<span class="keyword">new</span> <span class="title class_">Keyboard</span>());</span><br><span class="line">        <span class="comment">// 5. 笔记本关机</span></span><br><span class="line">        laptop.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/08/02/%E6%B3%9B%E5%9E%8B/">超链接：泛型</a></p>
<hr>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/31/%E5%BC%82%E5%B8%B8/">超链接：异常</a></p>
<hr>
<h1 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/10/13/IO%E7%B3%BB%E7%BB%9F/">超链接：IO</a></p>
<hr>
<h1 id="容器（数组-集合）"><a href="#容器（数组-集合）" class="headerlink" title="容器（数组 + 集合）"></a>容器（数组 + 集合）</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/07/25/%E5%AE%B9%E5%99%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%EF%BC%89/">超链接：容器</a></p>
<hr>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/01/29/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">超链接：Java8新特性</a></p>
<hr>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/08/20/%E5%8F%8D%E5%B0%84/">超链接：反射</a></p>
<hr>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/08/02/%E6%9E%9A%E4%B8%BE/">超链接：枚举</a></p>
<hr>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/08/02/%E6%B3%A8%E8%A7%A3/">超链接：注解</a></p>
<h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><blockquote>
<ol>
<li> <strong>java.lang.Object类的说明：</strong></li>
</ol>
</blockquote>
<ol>
<li> Object 类是所有类的根类。</li>
<li> 如果在类的声明中未使用 <code>extends</code> 关键字指明其父类，则默认父类为 <code>java.lang.Object</code> 类。 </li>
<li>Object 类中的功能(属性、方法)具有通用性。<ul>
<li>  属性：无</li>
<li>  方法：<code>equals() | toString() | getClass() | hashCode() | clone() | finalize() | wait() | notify() | notifyAll()</code></li>
</ul>
</li>
<li> Object类只声明了一个空参的构造器</li>
</ol>
<blockquote>
<ol start="2">
<li> <strong>equals() 方法</strong></li>
</ol>
</blockquote>
<ol>
<li><p> 只适用于引用数据类型。</p>
</li>
<li><p>Object 类中定义的 <code>equals()</code> 和 <code>==</code> 的作用是相同的，都是比较两个对象的地址值是否相同。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码：Object#equals()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 诸如 String、Date、File、包装类等都重写了 <code>Object#equals()</code> 方法。重写后比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p>
</li>
<li><p>如果我们自定义的类需要使用 <code>equals()</code> 比较两个对象的”实体内容”是否相同的话。那么我们就需要重写继承自 Object类中的<code>equals()</code> 方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写其equals()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age == u.age &amp;&amp; <span class="built_in">this</span>.name.equals(u.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 在实际开发中，可以使用 IDE 工具的提供的自动生成功能。</p>
</li>
<li><p>回顾 <code>==</code> 运算符的使用：</p>
<ul>
<li>  可以用在基本数据类型变量和引用数据类型变量中</li>
<li>  如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</li>
</ul>
<ul>
<li>   如果比较的是引用数据类型变量：比较两个对象的地址值是否相同。</li>
<li>补充：<code>==</code> 符号使用时，必须保证符号左右两边的变量类型一致。</li>
</ul>
</li>
</ol>
<blockquote>
<ol start="3">
<li> <strong>toString()方法</strong></li>
</ol>
</blockquote>
<ol>
<li><p> 当我们输出一个对象的引用时，实际上就是调用当前对象的 <code>toString()</code>。</p>
</li>
<li><p>Object 类中 <code>toString()</code> 的定义：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p> 像 <code>String、Date、File、包装类</code> 等都重写了 Object 类中的 <code>toString()</code> 方法。使得在调用对象的 <code>toString()</code> 时，返回”实体内容”信息。</p>
</li>
<li><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写示例</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Customer [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h2 id="为什么要有包装类"><a href="#为什么要有包装类" class="headerlink" title="为什么要有包装类"></a>为什么要有包装类</h2><ul>
<li>  为了使基本数据类型的变量具有类的特征，引入包装类。</li>
<li>  因为有一些方法只能通过引用类型对象才能调用，基本数据类型变量是无法胜任的。最常见的比如继承自 Object 类的诸多方法。</li>
</ul>
<h2 id="基本数据类型与对应的包装类"><a href="#基本数据类型与对应的包装类" class="headerlink" title="基本数据类型与对应的包装类"></a>基本数据类型与对应的包装类</h2><p><img src="/2020/05/26/JavaSE/image-20210730221022919.png" alt="image-20210730221022919"></p>
<p>​    </p>
<h2 id="需要掌握的类型间的转换：（基本数据类型、包装类、String）"><a href="#需要掌握的类型间的转换：（基本数据类型、包装类、String）" class="headerlink" title="需要掌握的类型间的转换：（基本数据类型、包装类、String）"></a>需要掌握的类型间的转换：（基本数据类型、包装类、String）</h2><p><img src="/2020/05/26/JavaSE/image-20210730221227422.png" alt="image-20210730221227422"></p>
<blockquote>
<p>  <strong>简易版</strong></p>
</blockquote>
<ol>
<li> <code>基本数据类型&lt;---&gt;包装类</code>：自动装箱 与 自动拆箱</li>
<li> <code>基本数据类型/包装类 --&gt; String</code>：调用 String 重载的 <code>valueOf(Xxx xxx)</code></li>
<li><code>String---&gt;基本数据类型/包装类</code>：调用包装类的 <code>parseXxx(String s)</code><ul>
<li>  注意：转换时，可能会报NumberFormatException</li>
</ul>
</li>
</ol>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/06/13/String/">超链接：String 详解</a></li>
</ul>
<h1 id="Java-比较器"><a href="#Java-比较器" class="headerlink" title="Java 比较器"></a>Java 比较器</h1><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/09/14/Java%E4%B8%ADComparable%E6%8E%A5%E5%8F%A3%E5%92%8CComparator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/">超链接：Java中Comparable接口和Comparator接口的区别</a>     </li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/20/Listener/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/20/Listener/" class="post-title-link" itemprop="url">Listener</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-04-20 00:22:22" itemprop="dateCreated datePublished" datetime="2020-04-20T00:22:22+08:00">2020-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-05 11:30:23" itemprop="dateModified" datetime="2022-05-05T11:30:23+08:00">2022-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaWeb/" itemprop="url" rel="index"><span itemprop="name">JavaWeb</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Listener概念"><a href="#Listener概念" class="headerlink" title="Listener概念"></a>Listener概念</h1><blockquote>
<p>  <strong>Listener；监听器；Web三大组件之一</strong></p>
</blockquote>
<p><strong>监听器就是监听某个对象状态变化的组件。</strong> </p>
<p>常用于监听 Web 应用中某些对象的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的处理。</p>
<p>当对象的状态发生变化的时候，服务器自动调用监听器对象中的方法。</p>
<p>事件监听机制</p>
<ul>
<li>事件 ：行为，动作</li>
<li>事件源 ：要监听的对象</li>
<li>监听器 ：监听对象</li>
<li>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</li>
</ul>
<hr>
<h1 id="Listener的实现"><a href="#Listener的实现" class="headerlink" title="Listener的实现"></a>Listener的实现</h1><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol>
<li>自定义一个监听器类，实现<code>ServletContextListener</code>接口。</li>
<li>重写接口中的方法，完成监听的逻辑。</li>
<li>配置监听对象（配置文件<code>web.xml</code>或注解方式）。</li>
</ol>
<h2 id="配置文件配置监听器对象"><a href="#配置文件配置监听器对象" class="headerlink" title="配置文件配置监听器对象"></a>配置文件配置监听器对象</h2><ul>
<li>在配置文件 web.xml 中将自定义的监听器类注册到监听器列表中去。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>cn.itcast.web.listener.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="注解配置监听器对象"><a href="#注解配置监听器对象" class="headerlink" title="注解配置监听器对象"></a>注解配置监听器对象</h2><ul>
<li>在自定义的监听器类上使用 <strong>@WebListener</strong> 注解将该类注册到监听器列表中去。</li>
</ul>
<hr>
<h1 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h1><p><strong>作用：</strong>监听<code>ServletContext</code>对象的创建和销毁</p>
<p><strong>方法：</strong></p>
<ul>
<li><p><code>void contextDestroyed(ServletContextEvent sce)</code></p>
<ul>
<li>  <code>ServletContext</code>对象被销毁之前会自动调用该方法</li>
</ul>
</li>
<li><p><code>void contextInitialized(ServletContextEvent sce)</code></p>
<ul>
<li>  <code>ServletContext</code>对象创建之后会自动调用该方法。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/19/Filter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/19/Filter/" class="post-title-link" itemprop="url">Filter</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-04-19 23:26:53" itemprop="dateCreated datePublished" datetime="2020-04-19T23:26:53+08:00">2020-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-05 13:22:16" itemprop="dateModified" datetime="2022-05-05T13:22:16+08:00">2022-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaWeb/" itemprop="url" rel="index"><span itemprop="name">JavaWeb</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Filter-原理"><a href="#Filter-原理" class="headerlink" title="Filter 原理"></a>Filter 原理</h1><p>Filter 用于拦截客户端的请求，对满足条件的请求放行，不满足条件的请求不放行。</p>
<p>Filter 既可以对用户请求（request）进行<strong>预处理</strong>，也可以对服务器响应（response）进行<strong>后处理</strong>。</p>
<ul>
<li>  预处理：当客户端向服务器发送请求时，过滤器可以将请求拦截下来，进行一些额外的操作。比如：登录验证、统一编码处理、敏感字符处理等操作。</li>
<li>  后处理：服务器发给客户端的响应，也可以被过滤器拦截，完成统一编码处理、响应结果处理等操作。</li>
</ul>
<p><img src="/2020/04/19/Filter/Filter-1651721919372.png" alt="Filter"></p>
<hr>
<h1 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h1><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol>
<li><p>创建自定义的过滤器类，实现 <code>Filter</code> 接口。</p>
</li>
<li><p>重写接口中的 <code>doFilter</code> 方法，编写过滤器逻辑。（即拦截到请求后要对这个请求做什么）</p>
</li>
<li><p>设置<strong>过滤条件</strong>（即对哪些请求进行过滤）</p>
<ul>
<li><code>web.xml</code>配置方式</li>
<li>注解配置方式</li>
</ul>
</li>
</ol>
<h2 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h2><h3 id="1、通过请求URL拦截请求"><a href="#1、通过请求URL拦截请求" class="headerlink" title="1、通过请求URL拦截请求"></a>1、通过请求URL拦截请求</h3><table>
<thead>
<tr>
<th>功能</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>拦截具体URL请求</td>
<td><code>/index.jsp</code></td>
<td>只有访问 <code>index.jsp</code> 的请求才会被</td>
</tr>
<tr>
<td>通过正则表达式拦截</td>
<td><code>/user/*</code></td>
<td>请求 URL 中包含 <code>/user</code> 的请求都会被过滤器拦截</td>
</tr>
<tr>
<td>通过正则表达式拦截</td>
<td><code>*.jsp</code></td>
<td>通过后缀名拦截</td>
</tr>
<tr>
<td>通过正则表达式拦截</td>
<td><code>/*</code></td>
<td>拦截所有资源</td>
</tr>
</tbody></table>
<h3 id="2、通过请求方式拦截请求"><a href="#2、通过请求方式拦截请求" class="headerlink" title="2、通过请求方式拦截请求"></a>2、通过请求方式拦截请求</h3><table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>REQUEST</code></td>
<td>拦截客户端发起的所有<strong>直接</strong>请求（默认值）</td>
</tr>
<tr>
<td><code>FORWARD</code></td>
<td>只拦截来自请求转发的访问</td>
</tr>
<tr>
<td><code>INCLUDE</code></td>
<td>只拦截包含访问资源</td>
</tr>
<tr>
<td><code>ERROR</code></td>
<td>只拦截错误跳转资源</td>
</tr>
<tr>
<td><code>ASYNC</code></td>
<td>只拦截异步访问资源</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>Tip：</strong></p>
<p>  上述多种拦截方式可组合使用。</p>
</blockquote>
<hr>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1、配置文件实现"><a href="#1、配置文件实现" class="headerlink" title="1、配置文件实现"></a>1、配置文件实现</h3><ul>
<li>  配置文件位置：<code>Web/WEB-INF/web.xml</code></li>
<li>  配置<code>&lt;dispatcher&gt;</code>标签可以完成调度。可以设置一个或多个。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.xsyu.web.filter.FilterDemo02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 过滤规则 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>   	<span class="comment">&lt;!--通过请求URL拦截请求--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span>	<span class="comment">&lt;!--通过请求方式拦截请求--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="2、注解实现"><a href="#2、注解实现" class="headerlink" title="2、注解实现"></a>2、注解实现</h3><p>设置 <code>dispatcherTypes</code> 属性</p>
<ul>
<li>  <code>REQUEST</code>：拦截浏览器<strong>直接</strong>发起的Request请求（默认值）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器直接请求index.jsp时，请求被拦截。浏览器通过转发等方式间接访问index.jsp时，请求不会被拦截。</span></span><br><span class="line"><span class="meta">@WebFilter(value = &quot;/index.jsp&quot;, dispatcherTypes = DispatcherType.REQUEST)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>FORWARD</code>：只拦截来自请求转发的访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器通过转发访问index.jsp时，过滤器会执行。浏览器直接访问index.jsp时，过滤器不会被执行。</span></span><br><span class="line"><span class="meta">@WebFilter(value = &quot;/index.jsp&quot;, dispatcherTypes = DispatcherType.FORWARD)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  组合形式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器通过转发访问index.jsp 或者 浏览器直接访问index.jsp时，过滤器都会被执行。</span></span><br><span class="line"><span class="meta">@WebFilter(value = &quot;/index.jsp&quot;, dispatcherTypes = &#123;DispatcherType.FORWARD, DispatcherType.REQUEST&#125;)</span></span><br></pre></td></tr></table></figure>





<h3 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span>    <span class="comment">// 过滤所有Request请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 过滤器中的增强方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;FilterDemo01被执行了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤器考虑是否放行</span></span><br><span class="line">        <span class="comment">// 1.放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        <span class="comment">// 2.不放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="过滤器细节"><a href="#过滤器细节" class="headerlink" title="过滤器细节"></a>过滤器细节</h1><h2 id="过滤器执行流程"><a href="#过滤器执行流程" class="headerlink" title="过滤器执行流程"></a>过滤器执行流程</h2><ul>
<li>  请求消息到达过滤器后首先执行过滤器中放行前的业务逻辑；</li>
<li>  放行后，跳转到 Servlet 转去执行 Servlet 中的业务逻辑；</li>
<li>  Servlet 给出的响应消息返回给客户端时再次经过过滤器，执行过滤器中放行后的业务逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*过滤器执行流程*/</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo03</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.对Request实例的请求消息增强</span></span><br><span class="line">        System.out.println(<span class="string">&quot;FilterDemo03被执行了&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.过滤器过滤</span></span><br><span class="line">        <span class="comment">// 2.1.放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        <span class="comment">// 2.2 不放行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.对Response实例的响应消息增强</span></span><br><span class="line">        System.out.println(<span class="string">&quot;FilterDemo03原路返回了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行结果：</span></span><br><span class="line"><span class="comment">            FilterDemo03被执行了        [1、过滤器对Request请求进行增强]</span></span><br><span class="line"><span class="comment">            index.jsp....              [2、Servlet中的业务逻辑，返回jsp页面]</span></span><br><span class="line"><span class="comment">            FilterDemo03原路返回了      [3、过滤器对Response响应进行增强】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="过滤器生命周期方法"><a href="#过滤器生命周期方法" class="headerlink" title="过滤器生命周期方法"></a>过滤器生命周期方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>init()</code></td>
<td>服务器在启动时，会自动创建Filter实例，并调用<code>init()</code>方法。init 方法只执行一次。用于加载资源。</td>
</tr>
<tr>
<td><code>doFilter()</code></td>
<td>每一次请求被拦截资源时，都会执行。执行多次。</td>
</tr>
<tr>
<td><code>destroy()</code></td>
<td>服务器正常关闭时，会调用<code>destroy()</code>方法，Filter对象被销毁。只执行一次，用于释放资源。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*过滤器生命周期*/</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo04</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/*在服务器启动时，会自动创建Filter实例，该实例调用init方法。只执行一次*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/* 每一次请求被拦截资源时，都会执行。执行多次*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doFilter&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/*服务器正常关闭时，会调用destroy()方法，Filter对象被销毁。只执行一次*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="过滤器链（配置多个过滤器）"><a href="#过滤器链（配置多个过滤器）" class="headerlink" title="过滤器链（配置多个过滤器）"></a>过滤器链（配置多个过滤器）</h2><h3 id="过滤器执行顺序：栈式原则"><a href="#过滤器执行顺序：栈式原则" class="headerlink" title="过滤器执行顺序：栈式原则"></a>过滤器执行顺序：栈式原则</h3><p><img src="/2020/04/19/Filter/Filter%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.svg" alt="Filter的执行顺序"></p>
<p>如果有2个过滤器，过滤器A和过滤器B。其执行顺序为：</p>
<ul>
<li>  过滤器A –&gt; 过滤器B –&gt; 访问业务接口 –&gt; 过滤器B –&gt; 过滤器A</li>
</ul>
<h3 id="过滤器先后顺序配置"><a href="#过滤器先后顺序配置" class="headerlink" title="过滤器先后顺序配置"></a>过滤器先后顺序配置</h3><p>如果代码中配置了2个过滤器，过滤器A和过滤器B，如何判断是过滤器A先执行还是过滤器B先执行？</p>
<h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><ul>
<li>按照类名的字符串比较规则，值小的先执行。</li>
</ul>
<h4 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a><code>web.xml</code>配置</h4><ul>
<li>在配置文件中，谁定义在前面谁先执行。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
