<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/30/Sqoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/30/Sqoop/" class="post-title-link" itemprop="url">Sqoop</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-30 12:22:49" itemprop="dateCreated datePublished" datetime="2021-12-30T12:22:49+08:00">2021-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-22 10:34:19" itemprop="dateModified" datetime="2022-05-22T10:34:19+08:00">2022-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Sqoop/" itemprop="url" rel="index"><span itemprop="name">Sqoop</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第-1-章-Sqoop简介"><a href="#第-1-章-Sqoop简介" class="headerlink" title="第 1 章    Sqoop简介"></a>第 1 章    Sqoop简介</h1><p><code>Sqoop</code> 是一款开源的 ETL 工具，主要用于在 <code>Hadoop(Hive)</code> 与传统的数据库 <code>(mysql、oracle...)</code> 之间进行数据的传递，可以将一个关系型数据库（例如：<code>MySQL，Oracle，Postgres</code> 等）中的数据导进到 <code>Hadoop</code> 的 <code>HDFS</code> 中，也可以将 <code>HDFS</code> 的数据导进到关系型数据库中。</p>
<p><code>Sqoop</code> 项目开始于2009年，最早是作为 <code>Hadoop</code> 的一个第三方模块存在，后来为了让使用者能够快速部署，也为了让开发人员能够更快速的迭代开发，<code>Sqoop</code> 独立成为一个 <code>Apache</code> 项目。</p>
<p><code>Sqoop2</code> 的最新版本是 <code>1.99.7</code>。请注意，2 与 1 不兼容，且特征不完整，它并不打算用于生产部署。</p>
<hr>
<h1 id="第-2-章-Sqoop-原理"><a href="#第-2-章-Sqoop-原理" class="headerlink" title="第 2 章    Sqoop 原理"></a>第 2 章    Sqoop 原理</h1><p>将导入或导出命令翻译成 <code>mapreduce</code> 程序来实现。</p>
<p>在翻译出的 <code>mapreduce</code> 中主要是对 <code>inputformat</code> 和 <code>outputformat</code> 进行定制。</p>
<hr>
<h1 id="第-3-章-Sqoop安装"><a href="#第-3-章-Sqoop安装" class="headerlink" title="第 3 章    Sqoop安装"></a>第 3 章    Sqoop安装</h1><p>安装 <code>Sqoop</code> 的前提是已经具备 <code>Java</code> 和 <code>Hadoop</code> 的环境。</p>
<h2 id="3-1-下载并解压"><a href="#3-1-下载并解压" class="headerlink" title="3.1    下载并解压"></a>3.1    下载并解压</h2><ol>
<li><p> 下载地址：<a target="_blank" rel="noopener" href="http://mirrors.hust.edu.cn/apache/sqoop/1.4.6/">http://mirrors.hust.edu.cn/apache/sqoop/1.4.6/</a></p>
</li>
<li><p> 上传安装包 <code>sqoop-1.4.6.bin__hadoop-2.0.4-alpha.tar.gz</code> 到虚拟机中</p>
</li>
<li><p>解压 <code>sqoop</code> 安装包到指定目录</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 software]$ tar -zxf sqoop-1.4.6.bin__hadoop-2.0.4-alpha.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></li>
<li><p>将 <code>sqoop-1.4.6.bin__hadoop-2.0.4-alpha</code> 重命名为 <code>sqoop</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 module]$ <span class="built_in">mv</span> sqoop-1.4.6.bin__hadoop-2.0.4-alpha/ sqoop</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="3-2-修改配置文件"><a href="#3-2-修改配置文件" class="headerlink" title="3.2 修改配置文件"></a>3.2 修改配置文件</h2><p><code>Sqoop</code> 的配置文件与大多数大数据框架类似，在 <code>sqoop</code> 根目录下的 <code>conf</code> 目录中。</p>
<ol>
<li><p><strong>重命名配置文件</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 conf]$ <span class="built_in">mv</span> sqoop-env-template.sh sqoop-env.sh</span><br></pre></td></tr></table></figure></li>
<li><p><strong>修改配置文件</strong><code>sqoop-env.sh</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HADOOP_HOME</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_COMMON_HOME=/opt/module/hadoop-2.7.2</span><br><span class="line"><span class="built_in">export</span> HADOOP_MAPRED_HOME=/opt/module/hadoop-2.7.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># HIVE_HOME</span></span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/opt/module/hive</span><br><span class="line"></span><br><span class="line"><span class="comment"># ZOOKEEPER_HOME</span></span><br><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/opt/module/zookeeper-3.4.10</span><br><span class="line"></span><br><span class="line"><span class="comment"># ZOOCFGDIR</span></span><br><span class="line"><span class="built_in">export</span> ZOOCFGDIR=/opt/module/zookeeper-3.4.10/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># HBASE_HOME</span></span><br><span class="line"><span class="built_in">export</span> HBASE_HOME=/opt/module/hbase-1.3.1</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="3-3-拷贝-JDBC-驱动"><a href="#3-3-拷贝-JDBC-驱动" class="headerlink" title="3.3    拷贝 JDBC 驱动"></a>3.3    拷贝 JDBC 驱动</h2><ol>
<li><p>拷贝 <code>jdbc</code> 驱动到 <code>sqoop</code> 的 <code>lib</code> 目录下(<code>JDBC</code> 驱动在 <code>MySQL</code> 的安装目录下)</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 mysql-connector-java-5.1.27]$ <span class="built_in">cp</span> mysql-connector-java-5.1.27-bin.jar /opt/module/sqoop/lib/</span><br></pre></td></tr></table></figure></li>
</ol>
<p>因为要通过 Sqoop 将 MySQL 中的数据导入到 HDFS 中，所以 Sqoop 就相当于 MySQL 的一个客户端，自然就需要将 MySQL 的 JDBC 驱动导入到 Sqoop 的 <code>lib</code> 目录下了。</p>
<hr>
<h2 id="3-4-验证-Sqoop"><a href="#3-4-验证-Sqoop" class="headerlink" title="3.4    验证 Sqoop"></a>3.4    验证 Sqoop</h2><ol>
<li><p>我们可以通过某一个命令来验证 <code>sqoop</code> 配置是否正确：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop <span class="built_in">help</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 sqoop]$ bin/sqoop <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现一些Warning警告（警告信息已省略），并伴随着帮助命令的输出：</span></span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line">  codegen            Generate code to interact with database records</span><br><span class="line">  create-hive-table  Import a table definition into Hive</span><br><span class="line">  <span class="built_in">eval</span>               Evaluate a SQL statement and display the results</span><br><span class="line">  <span class="built_in">export</span>             Export an HDFS directory to a database table</span><br><span class="line">  <span class="built_in">help</span>               List available commands</span><br><span class="line">  import             Import a table from a database to HDFS</span><br><span class="line">  import-all-tables  Import tables from a database to HDFS</span><br><span class="line">  import-mainframe   Import datasets from a mainframe server to HDFS</span><br><span class="line">  job                Work with saved <span class="built_in">jobs</span></span><br><span class="line">  list-databases     List available databases on a server</span><br><span class="line">  list-tables        List available tables <span class="keyword">in</span> a database</span><br><span class="line">  merge              Merge results of incremental imports</span><br><span class="line">  metastore          Run a standalone Sqoop metastore</span><br><span class="line">  version            Display version information</span><br><span class="line"></span><br><span class="line">See <span class="string">&#x27;sqoop help COMMAND&#x27;</span> <span class="keyword">for</span> information on a specific <span class="built_in">command</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="3-5-测试-Sqoop-是否能够成功连接数据库"><a href="#3-5-测试-Sqoop-是否能够成功连接数据库" class="headerlink" title="3.5 测试 Sqoop 是否能够成功连接数据库"></a>3.5 测试 Sqoop 是否能够成功连接数据库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示当前连接管理的所有的数据库</span></span><br><span class="line">[lvnengdong@hadoop102 sqoop]$ bin/sqoop \</span><br><span class="line">list-databases \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/ \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现如下输出（数据库列表）：</span></span><br><span class="line">information_schema</span><br><span class="line">metastore</span><br><span class="line">mysql</span><br><span class="line">performance_schema</span><br><span class="line">rdd</span><br><span class="line">sys</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="第4章-Sqoop-的简单使用案例"><a href="#第4章-Sqoop-的简单使用案例" class="headerlink" title="第4章 Sqoop 的简单使用案例"></a>第4章 Sqoop 的简单使用案例</h1><h2 id="4-1-导入数据"><a href="#4-1-导入数据" class="headerlink" title="4.1 导入数据"></a>4.1 导入数据</h2><p>在 Sqoop 中，<strong>导入</strong> 指的是：从非大数据集群(RDBMS)向大数据集群(HDFS，HIVE，HBASE)中传输数据。</p>
<p>导入使用 <code>import</code> 关键字。</p>
<h3 id="4-1-1-RDBMS-gt-HDFS"><a href="#4-1-1-RDBMS-gt-HDFS" class="headerlink" title="4.1.1 RDBMS =&gt; HDFS"></a>4.1.1 RDBMS =&gt; HDFS</h3><ol>
<li><p> 确定 MySQL 服务开启正常</p>
</li>
<li><p>在 MySQL 中新建一张表并插入一些数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 建库</span><br><span class="line">CREATE DATABASE `sqoop_test`;</span><br><span class="line"></span><br><span class="line"># 建表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">  id INT (4) PRIMARY KEY NOT NULL AUTO_INCREMENT,</span><br><span class="line">  NAME VARCHAR (255),</span><br><span class="line">  sex VARCHAR (255)</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">INSERT INTO emp(NAME, sex) VALUES(&#x27;Thomas&#x27;, &#x27;Male&#x27;);</span><br><span class="line">INSERT INTO emp(NAME, sex) VALUES(&#x27;Catalina&#x27;, &#x27;FeMale&#x27;);</span><br><span class="line">INSERT INTO emp(NAME, sex) VALUES(&#x27;zs&#x27;, &#x27;Male&#x27;);</span><br><span class="line">INSERT INTO emp(NAME, sex) VALUES(&#x27;ls&#x27;, &#x27;Male&#x27;);</span><br><span class="line">INSERT INTO emp(NAME, sex) VALUES(&#x27;ww&#x27;, &#x27;FeMale&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>导入数据</p>
<ul>
<li>  全表导入：默认</li>
<li>  导入指定列 <code>--columns</code></li>
<li>  导入指定行 <code>--where</code></li>
<li>  查询导入</li>
</ul>
</li>
</ol>
<h4 id="1、全表导入"><a href="#1、全表导入" class="headerlink" title="1、全表导入"></a>1、全表导入</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># \ 代表在shell窗口中换行</span></span><br><span class="line">[lvnengdong@hadoop102 sqoop]$ bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/sqoop_test \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table emp \</span><br><span class="line">--target-dir /sqoop_test \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span><br><span class="line">--num-mappers 2 \</span><br><span class="line">--split-by <span class="built_in">id</span></span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<ol>
<li><p>从哪儿来</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/sqoop_test \	<span class="comment"># 数据库的URL </span></span><br><span class="line">--username root \	<span class="comment"># 账号</span></span><br><span class="line">--password 123456 \	<span class="comment"># 密码</span></span><br><span class="line">--table emp \	<span class="comment"># 源数据表名</span></span><br></pre></td></tr></table></figure></li>
<li><p>到哪儿去</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--target-dir /sqoop_test \	<span class="comment"># 目的路径（HDFS下的路径）</span></span><br><span class="line">--delete-target-dir \</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、这两行命令一般是成对出现的</span></span><br><span class="line"><span class="comment"># 2、Sqoop `导入/导出`的功能底层是通过 MapReduce 实现的，在 MapReduce 中，要求输出目录必须事先不存在，</span></span><br><span class="line"><span class="comment"># 如果事先存在，在程序执行时就会抛出异常。在 Sqoop 为了避免这个异常，可以通过设置 `--delete-target-dir`，</span></span><br><span class="line"><span class="comment"># 这条命令的作用是如果目标目录事先已经存在了，则删除掉它。</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>怎么去（规则）</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \	<span class="comment"># 导入到 HDFS 上时，MySQL 中的字段使用 `/t` 作为分隔符 </span></span><br><span class="line">--num-mappers 2 \	<span class="comment"># 设置几个 MapTask 来运行程序</span></span><br><span class="line">--split-by <span class="built_in">id</span>	<span class="comment"># 在上一行设置了2个MapTask，自然就需要将数据切分，该行的含义是：基于 id 列，将数据切分为2片，这个参数只有在 `--num-mappers` 参数大于1时才需要指定。如果数据不需要切分该参数是无意义的。	</span></span><br><span class="line"><span class="comment"># 选择的列最好不要有 null 值，否则 null 值所在的行记录是不会被导入的</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>在 HDFS 上查看导入结果：</strong></p>
<p><img src="/2021/12/30/Sqoop/image-20211230191616906.png" alt="image-20211230191616906"></p>
<h4 id="2、导入指定列-columns"><a href="#2、导入指定列-columns" class="headerlink" title="2、导入指定列 --columns"></a>2、导入指定列 <code>--columns</code></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 sqoop]$ bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/sqoop_test \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table emp \</span><br><span class="line">--columns <span class="built_in">id</span>,name \		<span class="comment"># 导入指定列（只导入 id 和 name 列）</span></span><br><span class="line">--target-dir /sqoop_test \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span><br><span class="line">--num-mappers 2 \</span><br><span class="line">--split-by <span class="built_in">id</span></span><br></pre></td></tr></table></figure>





<h4 id="3、导入指定行-where"><a href="#3、导入指定行-where" class="headerlink" title="3、导入指定行 --where"></a>3、导入指定行 <code>--where</code></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 sqoop]$ bin/sqoop import \</span><br><span class="line">&gt; --connect jdbc:mysql://hadoop102:3306/sqoop_test \</span><br><span class="line">&gt; --username root \</span><br><span class="line">&gt; --password 123456 \</span><br><span class="line">&gt; --table emp \</span><br><span class="line">&gt; --<span class="built_in">where</span> <span class="string">&#x27;id &gt;= 1 and id &lt;= 3&#x27;</span> \	<span class="comment"># 导入指定行</span></span><br><span class="line">&gt; --target-dir /sqoop_test \</span><br><span class="line">&gt; --delete-target-dir \</span><br><span class="line">&gt; --fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span><br><span class="line">&gt; --num-mappers 2 \</span><br><span class="line">&gt; --split-by <span class="built_in">id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="6、查询导入"><a href="#6、查询导入" class="headerlink" title="6、查询导入"></a>6、查询导入</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 sqoop]$ bin/sqoop import \</span><br><span class="line">&gt; --connect jdbc:mysql://hadoop102:3306/sqoop_test \</span><br><span class="line">&gt; --username root \</span><br><span class="line">&gt; --password 123456 \</span><br><span class="line">&gt; --query <span class="string">&quot;select * from emp where \$CONDITIONS and id &lt;= 3&quot;</span> \	<span class="comment"># 查询导入</span></span><br><span class="line">&gt; --target-dir /sqoop_test \</span><br><span class="line">&gt; --delete-target-dir \</span><br><span class="line">&gt; --fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span><br><span class="line">&gt; --num-mappers 2 \</span><br><span class="line">&gt; --split-by <span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  如果使用了 <code>--query</code>，就不能再使用 <code>--table、--where、--columns</code> 了</li>
<li>  只要使用 <code>--query</code>，就必须添加 <code>$CONDITIONS</code>。<code>(must contain &#39;$CONDITIONS&#39; in WHERE clause)</code></li>
<li>  如果 <code>--query </code>后使用的是双引号，则 <code>$CONDITIONS</code> 前必须加转义符，防止 <code>shell</code> 识别为自己的变量。</li>
</ul>
<hr>
<h3 id="4-1-2-RDBMS-gt-Hive"><a href="#4-1-2-RDBMS-gt-Hive" class="headerlink" title="4.1.2 RDBMS ==&gt; Hive"></a>4.1.2 <code>RDBMS ==&gt; Hive</code></h3><p>将 MySQL 中的数据导入的 Hive 的过程分为两步：</p>
<ul>
<li>  第一步将数据导入到 <code>HDFS</code>，默认的临时目录是 <code>/user/lvnengdong/表名</code></li>
<li>  第二步将导入到 <code>HDFS</code> 的数据迁移到 <code>Hive</code> 仓库。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/sqoop_test \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table emp \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--hive-import \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span><br><span class="line">--hive-overwrite \</span><br><span class="line">--hive-table emp_hive</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/sqoop_test \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table emp \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--hive-import \	<span class="comment"># 显式指定将MySQL中的数据导入到 Hive</span></span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span><br><span class="line">--hive-overwrite \	<span class="comment"># 是否以 overwrite 的方式导入</span></span><br><span class="line">--hive-table emp_hive	<span class="comment"># 要导入的 Hive 表的名称，若表实现不存在会自动建表</span></span><br></pre></td></tr></table></figure>



<p>连接 Hive，查看数据是否上传成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from emp_hive;</span><br><span class="line">OK</span><br><span class="line">emp_hive.id	emp_hive.name	emp_hive.sex</span><br><span class="line">1	Thomas	Male</span><br><span class="line">2	Catalina	FeMale</span><br><span class="line">3	zs	Male</span><br><span class="line">4	ls	Male</span><br><span class="line">5	ww	FeMale</span><br><span class="line">Time taken: 1.032 seconds, Fetched: 5 row(s)</span><br></pre></td></tr></table></figure>









<hr>
<h3 id="4-1-3-RDBMS-gt-Hbase"><a href="#4-1-3-RDBMS-gt-Hbase" class="headerlink" title="4.1.3    RDBMS ==&gt; Hbase"></a>4.1.3    <code>RDBMS ==&gt; Hbase</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/sqoop_test \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table emp \</span><br><span class="line">--<span class="built_in">where</span> <span class="string">&#x27;id &lt;= 5&#x27;</span> \</span><br><span class="line">--hbase-create-table \</span><br><span class="line">--hbase-table <span class="string">&quot;hive_hbase&quot;</span> \</span><br><span class="line">--hbase-row-key <span class="string">&quot;id&quot;</span> \</span><br><span class="line">--column-family <span class="string">&quot;info&quot;</span> \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--split-by <span class="built_in">id</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong><code>sqoop1.4.6</code> 只支持 <code>HBase1.0.1 </code>之前的版本的自动创建 <code>HBase</code> 表的功能</p>
<p><strong>解决方案：</strong>手动创建 <code>HBase</code> 表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; create &#x27;hive_hbase&#x27;,&#x27;info&#x27;</span><br></pre></td></tr></table></figure>

<p>在 <code>HBase</code> 中 <code>scan</code> 这张表得到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; scan &#x27;hive_hbase&#x27;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="4-2-导出数据"><a href="#4-2-导出数据" class="headerlink" title="4.2    导出数据"></a>4.2    导出数据</h2><p>在 <code>Sqoop</code> 中，<strong>导出</strong>指的是：从大数据集群<code>(HDFS，HIVE)</code>向非大数据集群<code>(RDBMS)</code>中传输数据。</p>
<p>导出使用 <code>export</code> 关键字。</p>
<h3 id="4-2-1-HIVE-HDFS-gt-RDBMS"><a href="#4-2-1-HIVE-HDFS-gt-RDBMS" class="headerlink" title="4.2.1    HIVE/HDFS ==&gt; RDBMS"></a>4.2.1    <code>HIVE/HDFS ==&gt; RDBMS</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop <span class="built_in">export</span> \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/sqoop_test \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table emp_new \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--export-dir /sqoop_test \</span><br><span class="line">--input-fields-terminated-by <span class="string">&quot;\t&quot;</span></span><br></pre></td></tr></table></figure>



<p><strong>解释</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop <span class="built_in">export</span> \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/sqoop_test \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table emp_new \	<span class="comment"># 要导出到 MySQL 的哪张表中</span></span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--export-dir /sqoop_test \	<span class="comment"># HDFS上文件的源路径</span></span><br><span class="line">--input-fields-terminated-by <span class="string">&quot;\t&quot;</span>	<span class="comment"># 待导出数据的分隔符</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong><code>MySQL</code> 中如果表不存在，不会自动创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp_new LIKE emp;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="4-2-2-Sqoop-导出遇到重复主键"><a href="#4-2-2-Sqoop-导出遇到重复主键" class="headerlink" title="4.2.2    Sqoop 导出遇到重复主键"></a>4.2.2    Sqoop 导出遇到重复主键</h3><p>在 <code>MySQL</code> 中，主键是唯一的，如果在插入数据时发现主键重复，则会抛出异常。但是 <code>MySQL</code> 给我们提供了另外一种策略，就是当主键重复时，使用 <code>update</code> 操作来代替 <code>insert</code> 操作，这样即使主键重复也不会报错，而是使用新数据覆盖旧数据。该形式的写法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 当主键重复时，使用新值覆盖旧值</span><br><span class="line">INSERT INTO emp_new </span><br><span class="line">VALUES (3, &quot;张三&quot;, &quot;男&quot;) </span><br><span class="line">ON DUPLICATE KEY UPDATE ;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 当主键重复时，使用新值覆盖旧值，并且仅修改部分列的值</span><br><span class="line">INSERT INTO emp_new VALUES </span><br><span class="line">(3, &quot;张三&quot;, &quot;???&quot;) </span><br><span class="line">ON DUPLICATE KEY UPDATE </span><br><span class="line">sex=VALUES(sex)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<p>默认情况下，<code>Sqoop</code> 在导出数据到 <code>MySQL</code> 中时，会将每一条数据翻译成 MySQL 中的 <code>insert</code> 语句插入到 MySQL 数据库中。如果此时 MySQL 表结构中存在一些主键约束或唯一约束，并且表中已经有了一部分数据，那么新的数据在插入到 MySQL 表中时，就可能会触犯约束条件，导致插入失败。</p>
<p>默认情况下，<code>export</code> 适用于向一张空白表中导出数据的场景。每一条要导出的记录，都会转换为 MySQL 中的 <code>insert</code> 语句执行。</p>
<p>如果要导入的表中已经有数据了，此时可以指定 <code>--update-key</code> 参数，使用该参数后，将不再执行 <code>insert</code> 操作，而是只会执行 <code>update</code> 操作。但是这又会带来另一个问题，即此时只会更新重复的数据，不重复的数据是无法导入的。</p>
<p>如果希望遇到重复的数据就 <code>insert</code>，不重复的数据就 <code>update</code>，可以使用 <code>--update-key</code> 结合 <code>--update-mode=allowinsert </code> 使用。此时当主键不重复时执行 <code>insert</code> 操作，当发生主键重复时，会将<code>新增操作(insert)</code>转变为<code>更新操作(update)</code>执行；。</p>
<p> <code>--update-mode</code> 属性的默认值是 <code>updateonly</code>，即 <code>--update-mode=updateonly</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在导出时，基于哪一列来判断数据是否重复</span></span><br><span class="line">--update-key</span><br><span class="line"></span><br><span class="line"><span class="comment"># .eg</span></span><br><span class="line">--update-key <span class="built_in">id</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="4-3-脚本打包"><a href="#4-3-脚本打包" class="headerlink" title="4.3    脚本打包"></a>4.3    脚本打包</h2><p>使用 <code>opt</code> 格式的文件打包 <code>sqoop</code> 命令，然后执行</p>
<ol>
<li><p>创建一个 <code>.opt</code> 文件</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> opt</span><br><span class="line">$ <span class="built_in">touch</span> opt/job_mysql2hdfs.opt</span><br></pre></td></tr></table></figure>

</li>
<li><p>编写 <code>sqoop</code> 脚本</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ vim opt/job_mysql2hdfs.opt</span><br><span class="line"></span><br><span class="line">import</span><br><span class="line">--connect</span><br><span class="line">jdbc:mysql://hadoop102:3306/company</span><br><span class="line">--username</span><br><span class="line">root</span><br><span class="line">--password</span><br><span class="line">123456</span><br><span class="line">--table</span><br><span class="line">staff</span><br><span class="line">--target-dir</span><br><span class="line">/company3</span><br><span class="line">--delete-target-dir</span><br><span class="line">--num-mappers</span><br><span class="line">1</span><br><span class="line">--fields-terminated-by</span><br><span class="line"><span class="string">&quot;\t&quot;</span></span><br><span class="line">--split-by</span><br><span class="line"><span class="built_in">id</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>执行该脚本</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop --options-file opt/job_mysql2hdfs.opt</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="第5章-Sqoop-常用命令及参数"><a href="#第5章-Sqoop-常用命令及参数" class="headerlink" title="第5章 Sqoop 常用命令及参数"></a>第5章 Sqoop 常用命令及参数</h1><h2 id="5-1-常用命令"><a href="#5-1-常用命令" class="headerlink" title="5.1 常用命令"></a>5.1 常用命令</h2><p>这里给大家列出来了一部分 <code>Sqoop</code> 操作时的常用参数，以供参考，需要深入学习的可以参看对应类的源代码。</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>命令</th>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>import</code></td>
<td><code>ImportTool</code></td>
<td>将数据导入到集群</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>export</code></td>
<td><code>ExportTool</code></td>
<td>将集群数据导出</td>
</tr>
<tr>
<td align="center">3</td>
<td><code>codegen</code></td>
<td><code>CodeGenTool</code></td>
<td>获取数据库中某张表数据生成 Java 并打包 Jar</td>
</tr>
<tr>
<td align="center">4</td>
<td><code>create-hive-table</code></td>
<td><code>CreateHiveTableTool</code></td>
<td>创建 Hive 表</td>
</tr>
<tr>
<td align="center">5</td>
<td><code>eval</code></td>
<td><code>EvalSqlTool</code></td>
<td>查看 SQL 执行结果</td>
</tr>
<tr>
<td align="center">6</td>
<td><code>import-all-tables</code></td>
<td><code>ImportAllTablesTool</code></td>
<td>导入某个数据库下所有表到 HDFS 中</td>
</tr>
<tr>
<td align="center">7</td>
<td><code>job</code></td>
<td><code>JobTool</code></td>
<td>用来生成一个 sqoop 的任务，生成后，该任务<br>并不执行，除非使用命令执行该任务。</td>
</tr>
<tr>
<td align="center">8</td>
<td><code>list-databases</code></td>
<td><code>ListDatabasesTool</code></td>
<td>列出所有数据库名</td>
</tr>
<tr>
<td align="center">9</td>
<td><code>list-tables</code></td>
<td><code>ListTablesTool</code></td>
<td>列出某个数据库下所有表</td>
</tr>
<tr>
<td align="center">10</td>
<td><code>merge</code></td>
<td><code>MergeTool</code></td>
<td>将 HDFS 中不同目录下面的数据合并在一起，并存放在指定的目录中</td>
</tr>
<tr>
<td align="center">11</td>
<td><code>metastore</code></td>
<td><code>MetastoreTool</code></td>
<td>记录 <code>sqoop job</code> 的元数据信息，如果不启动 <code>metastore</code> 实例，<br>则默认的元数据存储目录为 <code>~/.sqoop</code>，如果要更改存储目录，<br>可以在配置文件 <code>sqoop-site.xml</code> 中进行更改</td>
</tr>
<tr>
<td align="center">12</td>
<td><code>help</code></td>
<td><code>HelpTool</code></td>
<td>打印 sqoop 帮助信息</td>
</tr>
<tr>
<td align="center">13</td>
<td><code>version</code></td>
<td><code>VersionTool</code></td>
<td>打印 sqoop 版本信息</td>
</tr>
</tbody></table>
<h2 id="5-2-命令-amp-参数详解"><a href="#5-2-命令-amp-参数详解" class="headerlink" title="5.2    命令&amp;参数详解"></a>5.2    命令&amp;参数详解</h2><p>刚才列举了一些 <code>Sqoop</code> 的常用命令，对于不同的命令，有不同的参数，让我们来一一列举说明。</p>
<p>首先来我们来介绍一下公用的参数，所谓公用参数，就是大多数命令都支持的参数。</p>
<h3 id="5-2-1-公用参数：数据库连接"><a href="#5-2-1-公用参数：数据库连接" class="headerlink" title="5.2.1    公用参数：数据库连接"></a>5.2.1    公用参数：数据库连接</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>--connect</code></td>
<td align="left">连接关系型数据库的URL</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>--connection-manager</code></td>
<td align="left">指定要使用的连接管理类</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>--driver</code></td>
<td align="left">Hadoop 根目录</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>--help</code></td>
<td align="left">打印帮助信息</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>--password</code></td>
<td align="left">连接数据库的密码</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><code>--username</code></td>
<td align="left">连接数据库的用户名</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left"><code>--verbose</code></td>
<td align="left">在控制台打印出详细信息</td>
</tr>
</tbody></table>
<h3 id="5-2-2-公用参数：import"><a href="#5-2-2-公用参数：import" class="headerlink" title="5.2.2    公用参数：import"></a>5.2.2    公用参数：import</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>--enclosed-by &lt;char&gt;</code></td>
<td align="left">给字段值前加上指定的字符</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>--escaped-by &lt;char&gt;</code></td>
<td align="left">对字段中的双引号加转义符</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>--fields-terminated-by &lt;char&gt;</code></td>
<td align="left">设定每个字段是以什么符号作为结束，默认为逗号</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>--lines-terminated-by  &lt;char&gt;</code></td>
<td align="left">设定每行记录之间的分隔符，默认是 <code>\n</code></td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>--mysql-delimiters</code></td>
<td align="left">MySQL 默认的分隔符设置，字段之间以逗号 <code>,</code> 分隔，<br>行之间以 <code>\n</code> 分隔，默认转义符是 <code>\</code>，字段值以单引号 <code>‘ ’</code>包裹</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><code>--optionally-enclosed-by &lt;char&gt;</code></td>
<td align="left">给带有双引号或单引号的字段值前后加上指定字符。</td>
</tr>
</tbody></table>
<h3 id="5-2-3-公用参数：export"><a href="#5-2-3-公用参数：export" class="headerlink" title="5.2.3 公用参数：export"></a>5.2.3 公用参数：export</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>--input-enclosed-by &lt;char&gt;</code></td>
<td>对字段值前后加上指定字符</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>--input-escaped-by &lt;char&gt;</code></td>
<td>对含有转移符的字段做转义处理</td>
</tr>
<tr>
<td align="center">3</td>
<td><code>--input-fields-terminated-by &lt;char&gt;</code></td>
<td>字段之间的分隔符</td>
</tr>
<tr>
<td align="center">4</td>
<td><code>--input-lines-terminated-by &lt;char&gt;</code></td>
<td>行之间的分隔符</td>
</tr>
<tr>
<td align="center">5</td>
<td><code>--input-optionally-enclosed-by &lt;char&gt;</code></td>
<td>给带有双引号或单引号的字段前后加上指定字符</td>
</tr>
<tr>
<td align="center">6</td>
<td><code>--update-key &lt;col-name&gt;</code></td>
<td>更新时参考的列</td>
</tr>
<tr>
<td align="center">7</td>
<td><code>--update-mode &lt;mode&gt;</code></td>
<td>更新模式，可选参数 <code>[updateonly, allowinsert]</code></td>
</tr>
</tbody></table>
<h3 id="5-2-4-公用参数：hive"><a href="#5-2-4-公用参数：hive" class="headerlink" title="5.2.4    公用参数：hive"></a>5.2.4    公用参数：hive</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>--hive-delims-replacement &lt;arg&gt;</code></td>
<td>用自定义的字符串替换掉数据中的 <code>\r\n</code> 和 <code>\013 \010</code> 等字符</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>--hive-drop-import-delims</code></td>
<td>在导入数据到 <code>Hive</code> 时，去掉数据中的 <code>\r\n\013\010</code> 这样的字符</td>
</tr>
<tr>
<td align="center">3</td>
<td><code>--map-column-hive  &lt;arg&gt;</code></td>
<td>生成 <code>Hive</code> 表时，可以更改生成字段的数据类型</td>
</tr>
<tr>
<td align="center">4</td>
<td><code>--hive-partition-key</code></td>
<td>创建分区，后面直接跟分区名，分区字段的默认类型为 <code>string</code></td>
</tr>
<tr>
<td align="center">5</td>
<td><code>--hive-partition-value &lt;v&gt;</code></td>
<td>导入数据时，指定某个分区的值</td>
</tr>
<tr>
<td align="center">6</td>
<td><code>--hive-home &lt;dir&gt;</code></td>
<td><code>Hive</code> 的安装目录，可以通过该参数覆盖之前默认配置的目录</td>
</tr>
<tr>
<td align="center">7</td>
<td><code>--hive-import</code></td>
<td>将数据从关系数据库中导入到 <code>Hive</code> 表中</td>
</tr>
<tr>
<td align="center">8</td>
<td><code>--hive-overwrite</code></td>
<td>覆盖掉在 <code>Hive</code> 表中已经存在的数据</td>
</tr>
<tr>
<td align="center">9</td>
<td><code>--create-hive-table</code></td>
<td>默认是 <code>false</code>，即如果目标表已经存在了，那么创建任务失败</td>
</tr>
<tr>
<td align="center">10</td>
<td><code>--hive-table</code></td>
<td>后面接要创建的 <code>hive</code> 表，默认使用 <code>MySQL</code> 的表名</td>
</tr>
<tr>
<td align="center">11</td>
<td><code>--table</code></td>
<td>指定关系数据库的表名</td>
</tr>
</tbody></table>
<hr>
<p>公用参数介绍完之后，我们来按照命令介绍命令对应的特有参数。</p>
<h3 id="5-2-5-命令-amp-参数：import"><a href="#5-2-5-命令-amp-参数：import" class="headerlink" title="5.2.5    命令&amp;参数：import"></a>5.2.5    命令&amp;参数：import</h3><p>将关系型数据库中的数据导入到 <code>HDFS(包括Hive，HBase)</code> 中，如果导入的是 <code>Hive</code>，那么当 <code>Hive</code> 中没有对应表时，则自动创建。</p>
<p><strong>一、命令：</strong></p>
<p>eg：导入数据到 <code>hive</code> 中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table staff \</span><br><span class="line">--hive-import</span><br></pre></td></tr></table></figure>



<p>eg：增量导入数据到 <code>hive</code> 中，<code>mode=append</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># append导入：</span></span><br><span class="line"></span><br><span class="line">$ bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table staff \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span><br><span class="line">--target-dir /user/hive/warehouse/staff_hive \</span><br><span class="line">--check-column <span class="built_in">id</span> \</span><br><span class="line">--incremental append \	<span class="comment"># 增量导入</span></span><br><span class="line">--last-value 3</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>提示：</strong><code>append</code> 不能与 <code>--hive</code> 等参数同时使用</li>
<li>  Append mode for hive imports is not yet supported. Please remove the parameter –append-mode</li>
</ul>
<p>eg：增量导入数据到 <code>hdfs</code> 中，<code>mode=lastmodified</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先在 mysql 中建表并插入几条数据：</span></span><br><span class="line">mysql&gt; </span><br><span class="line">	create table company.staff_timestamp(</span><br><span class="line">		<span class="built_in">id</span> int(4), </span><br><span class="line">		name varchar(255), </span><br><span class="line">		sex varchar(255), </span><br><span class="line">		last_modified timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into company.staff_timestamp (<span class="built_in">id</span>, name, sex) values(1, <span class="string">&#x27;AAA&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line">mysql&gt; insert into company.staff_timestamp (<span class="built_in">id</span>, name, sex) values(2, <span class="string">&#x27;BBB&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先导入一部分数据：</span></span><br><span class="line">$ bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table staff_timestamp \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--m 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再增量导入一部分数据：</span></span><br><span class="line">mysql&gt; insert into company.staff_timestamp (<span class="built_in">id</span>, name, sex) values(3, <span class="string">&#x27;CCC&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line">$ bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table staff_timestamp \</span><br><span class="line">--check-column last_modified \</span><br><span class="line">--incremental lastmodified \</span><br><span class="line">--last-value <span class="string">&quot;2017-09-28 22:20:38&quot;</span> \</span><br><span class="line">--m 1 \</span><br><span class="line">--append</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>提示：</strong><ol>
<li> 使用 <code>lastmodified</code> 方式导入数据要指定增量数据是要 <code>--append</code>（追加）还是要 <code>--merge-key</code>（合并）</li>
<li> <code>last-value</code> 指定的值是会包含于增量导入的数据中</li>
</ol>
</li>
</ul>
<p><strong>二、参数：</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>--append</code></td>
<td>将数据追加到 HDFS 中已经存在的 DataSet 中。如果使用该参数，<br>sqoop 会把数据先导入到临时文件目录，再合并</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>--as-avrodatafile</code></td>
<td>将数据导入到一个 <code>Avro</code> 数据文件中</td>
</tr>
<tr>
<td align="center">3</td>
<td><code>--as-sequencefile</code></td>
<td>将数据导入到一个 <code>sequence</code> 文件中</td>
</tr>
<tr>
<td align="center">4</td>
<td><code>--as-textfile</code></td>
<td>将数据导入到一个普通文本文件中</td>
</tr>
<tr>
<td align="center">5</td>
<td><code>--boundary-query  &lt;statement&gt;</code></td>
<td>边界查询，导入的数据为该参数的值（一条sql语句）所执行的结果<br>区间内的数据</td>
</tr>
<tr>
<td align="center">6</td>
<td><code>--columns &lt;col1, col2,  col3&gt;</code></td>
<td>指定要导入的字段</td>
</tr>
<tr>
<td align="center">7</td>
<td><code>--direct</code></td>
<td>直接导入模式，使用的是关系数据库自带的导入导出工具，以便加快<br>导入导出过程</td>
</tr>
<tr>
<td align="center">8</td>
<td><code>--direct-split-size</code></td>
<td>在使用上面 direct 直接导入的基础上，对导入的流按字节分块，即达<br>到该阈值就产生一个新的文件</td>
</tr>
<tr>
<td align="center">9</td>
<td><code>--inline-lob-limit</code></td>
<td>设定大对象数据类型的最大值</td>
</tr>
<tr>
<td align="center">10</td>
<td><code>--m</code> 或 <code>–num-mappers</code></td>
<td>启动 N 个 map 来并行导入数据，默认 4 个</td>
</tr>
<tr>
<td align="center">11</td>
<td><code>--query</code>或 <code>--e &lt;statement&gt;</code></td>
<td>将查询结果的数据导入，使用时必须伴随参 <code>--target-dir，--hive-table</code>，<br>如果查询中有 where 条件，则条件后必须加上 <code>$CONDITIONS</code> 关键字</td>
</tr>
<tr>
<td align="center">12</td>
<td><code>--split-by &lt;column-name&gt;</code></td>
<td>按照某一列来切分表的工作单元，不能与–autoreset-to-one-mapper连用<br>（请参考官方文档</td>
</tr>
<tr>
<td align="center">13</td>
<td><code>--table &lt;table-name&gt;</code></td>
<td>关系数据库的表名</td>
</tr>
<tr>
<td align="center">14</td>
<td><code>--target-dir &lt;dir&gt;</code></td>
<td>指定 HDFS 路径</td>
</tr>
<tr>
<td align="center">15</td>
<td><code>--warehouse-dir &lt;dir&gt;</code></td>
<td>与<code>14</code>参数不能同时使用，导入数据到 HDFS 时指定的目录</td>
</tr>
<tr>
<td align="center">16</td>
<td><code>--where</code></td>
<td>从关系数据库导入数据时的查询条件</td>
</tr>
<tr>
<td align="center">17</td>
<td><code>--z</code>或<code>--compress</code></td>
<td>允许压缩</td>
</tr>
<tr>
<td align="center">18</td>
<td><code>--compression-codec</code></td>
<td>指定 hadoop 压缩编码类，默认为<code>gzip(Use Hadoop codec  default gzip)</code></td>
</tr>
<tr>
<td align="center">19</td>
<td><code>--null-string  &lt;null-string&gt;</code></td>
<td><code>string</code> 类型的列如果 <code>null</code>，替换为指定字符串</td>
</tr>
<tr>
<td align="center">20</td>
<td><code>--null-non-string  &lt;null-string&gt;</code></td>
<td>非 <code>string</code> 类型的列如果 <code>null</code>，替换为指定字符串</td>
</tr>
<tr>
<td align="center">21</td>
<td><code>--check-column &lt;col&gt;</code></td>
<td>作为增量导入判断的列名</td>
</tr>
<tr>
<td align="center">22</td>
<td><code>--incremental &lt;mode&gt;</code></td>
<td><code>mode:append</code> 或 <code>lastmodified</code></td>
</tr>
<tr>
<td align="center">23</td>
<td><code>--last-value &lt;value&gt;</code></td>
<td>指定某一个值，用于标记增量导入的位置</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-6-命令-amp-参数：export"><a href="#5-2-6-命令-amp-参数：export" class="headerlink" title="5.2.6    命令&amp;参数：export"></a>5.2.6    命令&amp;参数：export</h3><p>从<code>HDFS（包括Hive和HBase）</code>中奖数据导出到关系型数据库中。</p>
<p><strong>命令：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop <span class="built_in">export</span> \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table staff \</span><br><span class="line">--export-dir /user/company \</span><br><span class="line">--input-fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span><br><span class="line">--num-mappers 1</span><br></pre></td></tr></table></figure>



<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>--direct</code></td>
<td align="left">利用数据库自带的导入导出工具，以便于提高效率</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>--export-dir  &lt;dir&gt;</code></td>
<td align="left">存放数据的 HDFS 的源目录</td>
</tr>
<tr>
<td align="center">3</td>
<td><code>-m</code> 或 <code>--num-mappers &lt;n&gt;</code></td>
<td align="left">启动 N 个 map 来并行导入数据，默认4个</td>
</tr>
<tr>
<td align="center">4</td>
<td><code>--table &lt;table-name&gt;</code></td>
<td align="left">指定导出到哪个 <code>RDBMS</code> 中的表</td>
</tr>
<tr>
<td align="center">5</td>
<td><code>--update-key  &lt;col-name&gt;</code></td>
<td align="left">对某一列的字段进行更新操作</td>
</tr>
<tr>
<td align="center">6</td>
<td><code>--update-mode  &lt;mode&gt;</code></td>
<td align="left"><code>updateonly</code>(默认)  <code>allowinsert</code></td>
</tr>
<tr>
<td align="center">7</td>
<td><code>--input-null-string  &lt;null-string&gt;</code></td>
<td align="left">请参考 import 该类似参数说明</td>
</tr>
<tr>
<td align="center">8</td>
<td><code>--input-null-non-string  &lt;null-string&gt;</code></td>
<td align="left">请参考 import 该类似参数说明</td>
</tr>
<tr>
<td align="center">9</td>
<td><code>--staging-table  &lt;staging-table-name&gt;</code></td>
<td align="left">创建一张临时表，用于存放所有事务的结果，然后<br>将所有事务结果一次性导入到目标表中，防止错误</td>
</tr>
<tr>
<td align="center">10</td>
<td><code>--clear-staging-table</code></td>
<td align="left">如果第 9 个参数非空，则可以在导出操作执行前，清空临时事务结果表</td>
</tr>
</tbody></table>
<h3 id="5-2-7-命令-amp-参数：codegen"><a href="#5-2-7-命令-amp-参数：codegen" class="headerlink" title="5.2.7    命令&amp;参数：codegen"></a>5.2.7    命令&amp;参数：codegen</h3><p>将关系型数据库中的表映射为一个 Java 类，在该类中有各列对应的各个字段。</p>
<p>eg：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop codegen \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table staff \</span><br><span class="line">--bindir /home/admin/Desktop/staff \</span><br><span class="line">--class-name Staff \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>--bindir &lt;dir&gt;</code></td>
<td>指定生成的 Java 文件、编译成的 class 文件及将生成文件打包为<br> <code>jar</code> 的文件输出路径</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>--class-name &lt;name&gt;</code></td>
<td>设定生成的 Java 文件指定的名称</td>
</tr>
<tr>
<td align="center">3</td>
<td><code>--outdir &lt;dir&gt;</code></td>
<td>生成 Java 文件存放的路径</td>
</tr>
<tr>
<td align="center">4</td>
<td><code>--package-name  &lt;name&gt;</code></td>
<td>包名，如 <code>com.z</code>，就会生成<code>com</code>和<code>z</code>两级目录</td>
</tr>
<tr>
<td align="center">5</td>
<td><code>--input-null-non-string &lt;null-str&gt;</code></td>
<td>在生成的 Java 文件中，可以将 <code>null</code> 字符串或者不存在的字符串<br>设置为想要设定的值（例如空字符串）</td>
</tr>
<tr>
<td align="center">6</td>
<td><code>--input-null-string  &lt;null-str&gt;</code></td>
<td>将 <code>null</code> 字符串替换成想要替换的值（一般与 5 同时使用）</td>
</tr>
<tr>
<td align="center">7</td>
<td><code>--map-column-java &lt;arg&gt;</code></td>
<td>数据库字段在生成的 Java 文件中会映射成各种属性，且默认的数据<br>类型与数据库类型保持对应关系。该参数可以改变默认类型，例如：<br><code>--map-column-java  id=long, name=String</code></td>
</tr>
<tr>
<td align="center">8</td>
<td><code>--null-non-string  &lt;null-str&gt;</code></td>
<td>在生成 Java 文件时，可以将不存在或者 <code>null</code> 的字符串设置为其他值</td>
</tr>
<tr>
<td align="center">9</td>
<td><code>--null-string &lt;null-str&gt;</code></td>
<td>在生成 Java 文件时，将 <code>null</code> 字符串设置为其他值（一般与8同时使用）</td>
</tr>
<tr>
<td align="center">10</td>
<td><code>--table &lt;table-name&gt;</code></td>
<td>对应关系数据库中的表名，生成的 Java 文件中的各个属性与该表的各<br>个字段一一对应</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-8-命令-amp-参数：create-hive-table"><a href="#5-2-8-命令-amp-参数：create-hive-table" class="headerlink" title="5.2.8    命令&amp;参数：create-hive-table"></a>5.2.8    命令&amp;参数：create-hive-table</h3><p>生成与关系数据库表结构对应的 <code>Hive</code> 表结构。</p>
<p><strong>命令：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop create-hive-table \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table staff \</span><br><span class="line">--hive-table hive_staff</span><br></pre></td></tr></table></figure>



<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>--hive-home  &lt;dir&gt;</code></td>
<td><code>Hive</code> 的安装目录，可以通过该参数覆盖掉默认的 <code>Hive</code> 目录</td>
</tr>
<tr>
<td>2</td>
<td><code>--hive-overwrite</code></td>
<td>覆盖掉在 <code>Hive</code> 表中已经存在的数据</td>
</tr>
<tr>
<td>3</td>
<td><code>--create-hive-table</code></td>
<td>默认是 <code>false</code>，如果目标表已经存在了，那么创建任务会失败</td>
</tr>
<tr>
<td>4</td>
<td><code>--hive-table</code></td>
<td>后面接要创建的 <code>hive</code> 表</td>
</tr>
<tr>
<td>5</td>
<td><code>--table</code></td>
<td>指定关系数据库的表名</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-9-命令-amp-参数：eval"><a href="#5-2-9-命令-amp-参数：eval" class="headerlink" title="5.2.9    命令&amp;参数：eval"></a>5.2.9    命令&amp;参数：eval</h3><p>可以快速的使用 SQL 语句对关系型数据库进行操作，经常用于在 <code>import</code> 数据之前，了解一下 SQL 语句是否正确，数据是否正常，并可以将结果显示在控制台。</p>
<p><strong>命令：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop <span class="built_in">eval</span> \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--query <span class="string">&quot;SELECT * FROM staff&quot;</span></span><br></pre></td></tr></table></figure>



<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>--query或--e</code></td>
<td>后跟查询的 SQL 语句</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-10-命令-amp-参数：import-all-tables"><a href="#5-2-10-命令-amp-参数：import-all-tables" class="headerlink" title="5.2.10    命令&amp;参数：import-all-tables"></a>5.2.10    命令&amp;参数：import-all-tables</h3><p>可以将 <code>RDBMS</code> 中的所有表导入到 <code>HDFS</code> 中，每一个表都对应一个 <code>HDFS</code> 目录</p>
<p><strong>命令：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop import-all-tables \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--warehouse-dir /all_tables</span><br></pre></td></tr></table></figure>





<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>--as-avrodatafile</code></td>
<td>这些参数的含义均和 <code>import</code>对应的含义一致</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>--as-sequencefile</code></td>
<td></td>
</tr>
<tr>
<td align="center">3</td>
<td><code>--as-textfile</code></td>
<td></td>
</tr>
<tr>
<td align="center">4</td>
<td><code>--direct</code></td>
<td></td>
</tr>
<tr>
<td align="center">5</td>
<td><code>--direct-split-size  &lt;n&gt;</code></td>
<td></td>
</tr>
<tr>
<td align="center">6</td>
<td><code>--inline-lob-limit  &lt;n&gt;</code></td>
<td></td>
</tr>
<tr>
<td align="center">7</td>
<td><code>--m</code> 或 <code>—num-mappers  &lt;n&gt;</code></td>
<td></td>
</tr>
<tr>
<td align="center">8</td>
<td><code>--warehouse-dir  &lt;dir&gt;</code></td>
<td></td>
</tr>
<tr>
<td align="center">9</td>
<td><code>-z</code> 或 <code>--compress</code></td>
<td></td>
</tr>
<tr>
<td align="center">10</td>
<td><code>--compression-codec</code></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-11-命令-amp-参数：job"><a href="#5-2-11-命令-amp-参数：job" class="headerlink" title="5.2.11    命令&amp;参数：job"></a>5.2.11    命令&amp;参数：job</h3><p>用来生成一个 <code>sqoop</code> 任务，生成后不会立即执行，需要手动执行。</p>
<p><strong>命令：</strong></p>
<p>eg：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop job \</span><br><span class="line"> --create myjob -- import-all-tables \</span><br><span class="line"> --connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line"> --username root \</span><br><span class="line"> --password 123456</span><br><span class="line">$ bin/sqoop job \</span><br><span class="line">--list</span><br><span class="line">$ bin/sqoop job \</span><br><span class="line">--<span class="built_in">exec</span> myjob</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>提示：<ol>
<li> 注意 <code>import-all-tables</code> 和它左边的 <code>--</code> 之间有一个空格</li>
<li> 如果需要连接 <code>metastore</code>，则 <code>--meta-connect jdbc:hsqldb:hsql://linux01:16000/sqoop</code></li>
</ol>
</li>
</ul>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>--create  &lt;job-id&gt;</code></td>
<td>创建 <code>job</code> 参数</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>--delete  &lt;job-id&gt;</code></td>
<td>删除一个 <code>job</code></td>
</tr>
<tr>
<td align="center">3</td>
<td><code>--exec  &lt;job-id&gt;</code></td>
<td>执行一个 <code>job</code></td>
</tr>
<tr>
<td align="center">4</td>
<td><code>--help</code></td>
<td>显示 <code>job</code> 帮助</td>
</tr>
<tr>
<td align="center">5</td>
<td><code>--list</code></td>
<td>显示 <code>job</code> 列表</td>
</tr>
<tr>
<td align="center">6</td>
<td><code>--meta-connect  &lt;jdbc-uri&gt;</code></td>
<td>用来连接 <code>metastore</code> 服务</td>
</tr>
<tr>
<td align="center">7</td>
<td><code>--show  &lt;job-id&gt;</code></td>
<td>显示一个 <code>job</code> 的信息</td>
</tr>
<tr>
<td align="center">8</td>
<td><code>--verbose</code></td>
<td>打印命令运行时的详细信息</td>
</tr>
</tbody></table>
<p><strong>提示：</strong>在执行一个 <code>job</code> 时，如果需要手动输入数据库密码，可以做如下优化</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>sqoop.metastore.client.record.password<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>If true, allow saved passwords in the metastore.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-2-12-命令-amp-参数：list-databases"><a href="#5-2-12-命令-amp-参数：list-databases" class="headerlink" title="5.2.12 命令&amp;参数：list-databases"></a>5.2.12 命令&amp;参数：list-databases</h3><p><strong>命令：</strong>  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  bin/sqoop list-databases \  --connect jdbc:mysql://hadoop102:3306/  \  --username root \  --password 123456</span><br></pre></td></tr></table></figure>



<p><strong>参数：</strong>与公用参数一样</p>
<hr>
<h3 id="5-2-13-命令-amp-参数：list-tables"><a href="#5-2-13-命令-amp-参数：list-tables" class="headerlink" title="5.2.13    命令&amp;参数：list-tables"></a>5.2.13    命令&amp;参数：list-tables</h3><p><strong>命令：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  bin/sqoop list-tables \  --connect jdbc:mysql://hadoop102:3306/company  \  --username root \  --password 123456</span><br></pre></td></tr></table></figure>



<p><strong>参数：</strong>与公用参数一样</p>
<hr>
<h3 id="5-2-14-命令-amp-参数：merge"><a href="#5-2-14-命令-amp-参数：merge" class="headerlink" title="5.2.14    命令&amp;参数：merge"></a>5.2.14    命令&amp;参数：merge</h3><p><strong>作用：</strong>将 <code>HDFS</code> 中不同目录下面的数据合并在一起并放入指定目录中。</p>
<p><strong>数据环境：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new_staff</span><br><span class="line">1	AAA	male</span><br><span class="line">2	BBB	male</span><br><span class="line">3	CCC	male</span><br><span class="line">4	DDD	male</span><br><span class="line">old_staff</span><br><span class="line">1	AAA	female</span><br><span class="line">2	CCC	female</span><br><span class="line">3	BBB	female</span><br><span class="line">6	DDD	female</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>提示：</strong>上述数据的列之间的分隔符应该为 <code>\t</code>，行与行之间的分割符为 <code>\n</code>，如果直接复制，请检查。</li>
</ul>
<p><strong>命令：</strong></p>
<p>eg：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建JavaBean：</span></span><br><span class="line">$ bin/sqoop codegen \</span><br><span class="line">--connect jdbc:mysql://hadoop102:3306/company \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table staff \</span><br><span class="line">--bindir /home/admin/Desktop/staff \</span><br><span class="line">--class-name Staff \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始合并：</span></span><br><span class="line">$ bin/sqoop merge \</span><br><span class="line">--new-data /test/new/ \</span><br><span class="line">--onto /test/old/ \</span><br><span class="line">--target-dir /test/merged \</span><br><span class="line">--jar-file /home/admin/Desktop/staff/Staff.jar \</span><br><span class="line">--class-name Staff \</span><br><span class="line">--merge-key <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">1	AAA	MALE</span><br><span class="line">2	BBB	MALE</span><br><span class="line">3	CCC	MALE</span><br><span class="line">4	DDD	MALE</span><br><span class="line">6	DDD	FEMALE</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>--new-data &lt;path&gt;</code></td>
<td>HDFS  中待合并数据的目录，合并后在新的数据集中保留</td>
</tr>
<tr>
<td align="center">2</td>
<td><code>--onto &lt;path&gt;</code></td>
<td>HDFS 合并后，重复的部分在新的数据集中被覆盖</td>
</tr>
<tr>
<td align="center">3</td>
<td><code>--merge-key  &lt;col&gt;</code></td>
<td>合并键，一般是主键ID</td>
</tr>
<tr>
<td align="center">4</td>
<td><code>--jar-file  &lt;file&gt;</code></td>
<td>合并时引入的 <code>jar</code> 包，该 <code>jar</code> 包是通过 <code>Codegen</code> 工具生成的 <code>jar</code> 包</td>
</tr>
<tr>
<td align="center">5</td>
<td><code>--class-name  &lt;class&gt;</code></td>
<td>对应的表名或对象名，该 <code>class</code> 类是包含在 <code>jar</code> 包中的</td>
</tr>
<tr>
<td align="center">6</td>
<td><code>--target-dir  &lt;path&gt;</code></td>
<td>合并后的数据在 HDFS 里存放的目录</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-15-命令-amp-参数：metastore"><a href="#5-2-15-命令-amp-参数：metastore" class="headerlink" title="5.2.15    命令&amp;参数：metastore"></a>5.2.15    命令&amp;参数：metastore</h3><p>记录了 <code>Sqoop job</code> 的元数据信息，如果不启动该服务，那么默认 <code>job</code> 元数据的存储目录为 <code>~/.sqoop</code>，可在 <code>sqoop-site.xml</code> 中修改。</p>
<p><strong>命令：</strong></p>
<p>eg：启动 <code>sqoop</code> 的 <code>metastore</code> 服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/sqoop metastore</span><br></pre></td></tr></table></figure>



<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>--shutdown</code></td>
<td>关闭 <code>metastore</code></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/26/Spark-MLlib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/26/Spark-MLlib/" class="post-title-link" itemprop="url">Spark_MLlib</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-26 11:10:05" itemprop="dateCreated datePublished" datetime="2021-12-26T11:10:05+08:00">2021-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-28 14:34:40" itemprop="dateModified" datetime="2021-12-28T14:34:40+08:00">2021-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spark/" itemprop="url" rel="index"><span itemprop="name">Spark</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="机器学习开发流程"><a href="#机器学习开发流程" class="headerlink" title="机器学习开发流程"></a>机器学习开发流程</h1><ol>
<li> 获取数据</li>
<li> 数据处理</li>
<li> 特征工程</li>
<li> 机器学习算法进行训练 ==&gt; 模型</li>
<li> 模型评估</li>
<li> 应用</li>
</ol>
<h1 id="常见数据集地址"><a href="#常见数据集地址" class="headerlink" title="常见数据集地址"></a>常见数据集地址</h1><p>Kaggle：<a target="_blank" rel="noopener" href="https://www.kaggle.com/datasets">https://www.kaggle.com/datasets</a></p>
<p>UCI：<a target="_blank" rel="noopener" href="https://archive.ics.uci.edu/ml/index.php">https://archive.ics.uci.edu/ml/index.php</a></p>
<p>scikit-learn：<a target="_blank" rel="noopener" href="https://scikit-learn.org/stable/">https://scikit-learn.org/stable/</a></p>
<h2 id="鸢尾花数据集"><a href="#鸢尾花数据集" class="headerlink" title="鸢尾花数据集"></a>鸢尾花数据集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">5.1,3.5,1.4,0.2,Iris-setosa</span><br><span class="line">4.9,3.0,1.4,0.2,Iris-setosa</span><br><span class="line">4.7,3.2,1.3,0.2,Iris-setosa</span><br><span class="line">4.6,3.1,1.5,0.2,Iris-setosa</span><br><span class="line">5.0,3.6,1.4,0.2,Iris-setosa</span><br><span class="line">5.4,3.9,1.7,0.4,Iris-setosa</span><br><span class="line">4.6,3.4,1.4,0.3,Iris-setosa</span><br><span class="line">5.0,3.4,1.5,0.2,Iris-setosa</span><br><span class="line">4.4,2.9,1.4,0.2,Iris-setosa</span><br><span class="line">4.9,3.1,1.5,0.1,Iris-setosa</span><br><span class="line">5.4,3.7,1.5,0.2,Iris-setosa</span><br><span class="line">4.8,3.4,1.6,0.2,Iris-setosa</span><br><span class="line">4.8,3.0,1.4,0.1,Iris-setosa</span><br><span class="line">4.3,3.0,1.1,0.1,Iris-setosa</span><br><span class="line">5.8,4.0,1.2,0.2,Iris-setosa</span><br></pre></td></tr></table></figure>

<ul>
<li>  data：特征值数组</li>
<li>  target：目标值数组</li>
<li>  feature_name：特征值名字</li>
<li>  target_name：目标值名字</li>
</ul>
<p>钻头整体一类：分为多个类别</p>
<p>钻杆整体一类</p>
<p>钻井液整体一类</p>
<h1 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h1><h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">文本类型 ==&gt; 数值</span><br><span class="line"></span><br><span class="line">类别 ==&gt; 数值</span><br><span class="line"></span><br><span class="line">vector	向量	一维数组</span><br><span class="line">matrix	矩阵	二维数组</span><br><span class="line"></span><br><span class="line">父类：转换器类	==&gt; 用转换器类将文本转换成数值</span><br><span class="line"></span><br><span class="line">将类别转换成特征 ==&gt; 一个类别，扩充成多个特征（one-hot编码）</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="字典特征抽取"><a href="#字典特征抽取" class="headerlink" title="字典特征抽取"></a>字典特征抽取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、实例化一个转换器类</span><br><span class="line">2、调用对象中的方法</span><br></pre></td></tr></table></figure>

<ul>
<li>  稀疏矩阵（P8）</li>
</ul>
<p>为了类别公平，转换成 one-hot 编码</p>
<p>应用场景：数据集当中，类别特征比较多的时候</p>
<ol>
<li> <code>将数据集特征 --&gt; 字典类型</code></li>
</ol>
<p>如果将清单上所有的物料都划分到一个类别中的，那么排列组合后得到的所有情况太多了，不太好处理。</p>
<h3 id="文本特征抽取"><a href="#文本特征抽取" class="headerlink" title="文本特征抽取"></a>文本特征抽取</h3><ul>
<li>  <code>TF-IDF</code>：文本特征抽取。用于提取文本文档中的关键词。在 Spark 中同样有（与毕设无关）。</li>
</ul>
<hr>
<h2 id="特征预处理"><a href="#特征预处理" class="headerlink" title="特征预处理"></a>特征预处理</h2><p>无量纲化：使不同规格的数据转化到同一规格</p>
<ul>
<li>  归一化：使用放缩器</li>
<li>  标准化：</li>
</ul>
<h3 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h3><p>通过对原始数据进行变换把数据映射到（默认为[0,1]）之间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、获取数据</span><br><span class="line">2、实例化一个转换器类</span><br><span class="line">3、调用转换方法</span><br><span class="line"></span><br><span class="line">// 进行特征工程时，可以选择要对哪些数据（哪几行哪几列）进行处理</span><br></pre></td></tr></table></figure>





<h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>归一化的缺点：由于归一化的计算公式是根据最大值和最小值计算出来的，所以在进行归一化的时候，如果有异常值（过大或过小值），则会影响最终的归一化结果。</p>
<p>鲁棒性：健壮性</p>
<p>标准化：对原始数据进行变化，把数据变换到均值为 0，标准差为 1 的范围内</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="特征降维"><a href="#特征降维" class="headerlink" title="特征降维"></a>特征降维</h2><p>二维数组</p>
<ul>
<li>  几行就代表有几个样本</li>
<li>  几列就代表有几个特征</li>
</ul>
<p>降维就是降低列数（特征的个数）</p>
<p>希望得到结果：特征与特征之间不相关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：降雨量与湿度就是一对相关的变量</span><br></pre></td></tr></table></figure>



<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><ol>
<li> 删除冗余特征：所有样本都具有的特征就叫做冗余特征</li>
<li></li>
</ol>
<p>特征之间相关性很高的时候，①可以选取其中一个即可。②可以将多个特征按一定的权重组合起来。③主成分分析</p>
<h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><ul>
<li>  定义：<strong>高维数据转化为低维数据的过程</strong>，在此过程中<strong>可能会舍弃原有数据、创造新的变量</strong></li>
<li>  作用：<strong>是数据维数压缩，尽可能降低原数据的维数（复杂度），损失少量信息。</strong></li>
<li>  应用：回归分析或者聚类分析当中</li>
</ul>
<hr>
<h1 id="特征工程-1"><a href="#特征工程-1" class="headerlink" title="特征工程"></a>特征工程</h1><p><img src="/2021/12/26/Spark-MLlib/fb2e1de527829c503514731396edb68a.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、预处理：</span><br><span class="line">	字符型特征值 ==&gt; 数值型特征值</span><br><span class="line">	StringIndexer</span><br><span class="line">	</span><br><span class="line">2、特征选择：降维</span><br><span class="line">	2.1	人工选择</span><br><span class="line">	2.2 统计学方法：Pearson系数、卡方分布</span><br><span class="line">	</span><br><span class="line">3、归一化</span><br><span class="line">	消除特异值误差</span><br><span class="line">4、离散化</span><br><span class="line">	???</span><br><span class="line">5、Embedding</span><br><span class="line">	多用于分类，常见的是 one-hot 编码</span><br><span class="line">6、向量计算</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7、离散化</span><br><span class="line">	降低原始数据的多样性</span><br><span class="line">	场景	适用于 温度、湿度  等等连续数据</span><br><span class="line">	目的	提升特征数据的区分度与内聚性 </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">|-- Id: string (nullable = true)</span><br><span class="line">|-- LotFrontage: string (nullable = true)</span><br><span class="line">|-- LotArea: string (nullable = true)</span><br><span class="line">|-- MasVnrArea: string (nullable = true)</span><br><span class="line">|-- BsmtFinSF1: string (nullable = true)</span><br><span class="line">|-- BsmtFinSF2: string (nullable = true)</span><br><span class="line">|-- BsmtUnfSF: string (nullable = true)</span><br><span class="line">|-- TotalBsmtSF: string (nullable = true)</span><br><span class="line">|-- 1stFlrSF: string (nullable = true)</span><br><span class="line">|-- 2ndFlrSF: string (nullable = true)</span><br><span class="line">|-- LowQualFinSF: string (nullable = true)</span><br><span class="line">|-- GrLivArea: string (nullable = true)</span><br><span class="line">|-- BsmtFullBath: string (nullable = true)</span><br><span class="line">|-- BsmtHalfBath: string (nullable = true)</span><br><span class="line">|-- FullBath: string (nullable = true)</span><br><span class="line">|-- HalfBath: string (nullable = true)</span><br><span class="line">|-- BedroomAbvGr: string (nullable = true)</span><br><span class="line">|-- KitchenAbvGr: string (nullable = true)</span><br><span class="line">|-- TotRmsAbvGrd: string (nullable = true)</span><br><span class="line">|-- Fireplaces: string (nullable = true)</span><br><span class="line">|-- GarageCars: string (nullable = true)</span><br><span class="line">|-- GarageArea: string (nullable = true)</span><br><span class="line">|-- WoodDeckSF: string (nullable = true)</span><br><span class="line">|-- OpenPorchSF: string (nullable = true)</span><br><span class="line">|-- EnclosedPorch: string (nullable = true)</span><br><span class="line">|-- 3SsnPorch: string (nullable = true)</span><br><span class="line">|-- ScreenPorch: string (nullable = true)</span><br><span class="line">|-- PoolArea: string (nullable = true)</span><br><span class="line">|-- SalePrice: string (nullable = true)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|-- MSSubClassIndex: double (nullable = true)</span><br><span class="line">|-- MSZoningIndex: double (nullable = true)</span><br><span class="line">|-- StreetIndex: double (nullable = true)</span><br><span class="line">|-- AlleyIndex: double (nullable = true)</span><br><span class="line">|-- LotShapeIndex: double (nullable = true)</span><br><span class="line">|-- LandContourIndex: double (nullable = true)</span><br><span class="line">|-- UtilitiesIndex: double (nullable = true)</span><br><span class="line">|-- LotConfigIndex: double (nullable = true)</span><br><span class="line">|-- LandSlopeIndex: double (nullable = true)</span><br><span class="line">|-- NeighborhoodIndex: double (nullable = true)</span><br><span class="line">|-- Condition1Index: double (nullable = true)</span><br><span class="line">|-- Condition2Index: double (nullable = true)</span><br><span class="line">|-- BldgTypeIndex: double (nullable = true)</span><br><span class="line">|-- HouseStyleIndex: double (nullable = true)</span><br><span class="line">|-- OverallQualIndex: double (nullable = true)</span><br><span class="line">|-- OverallCondIndex: double (nullable = true)</span><br><span class="line">|-- YearBuiltIndex: double (nullable = true)</span><br><span class="line">|-- YearRemodAddIndex: double (nullable = true)</span><br><span class="line">|-- RoofStyleIndex: double (nullable = true)</span><br><span class="line">|-- RoofMatlIndex: double (nullable = true)</span><br><span class="line">|-- Exterior1stIndex: double (nullable = true)</span><br><span class="line">|-- Exterior2ndIndex: double (nullable = true)</span><br><span class="line">|-- MasVnrTypeIndex: double (nullable = true)</span><br><span class="line">|-- ExterQualIndex: double (nullable = true)</span><br><span class="line">|-- ExterCondIndex: double (nullable = true)</span><br><span class="line">|-- FoundationIndex: double (nullable = true)</span><br><span class="line">|-- BsmtQualIndex: double (nullable = true)</span><br><span class="line">|-- BsmtCondIndex: double (nullable = true)</span><br><span class="line">|-- BsmtExposureIndex: double (nullable = true)</span><br><span class="line">|-- BsmtFinType1Index: double (nullable = true)</span><br><span class="line">|-- BsmtFinType2Index: double (nullable = true)</span><br><span class="line">|-- HeatingIndex: double (nullable = true)</span><br><span class="line">|-- HeatingQCIndex: double (nullable = true)</span><br><span class="line">|-- CentralAirIndex: double (nullable = true)</span><br><span class="line">|-- ElectricalIndex: double (nullable = true)</span><br><span class="line">|-- KitchenQualIndex: double (nullable = true)</span><br><span class="line">|-- FunctionalIndex: double (nullable = true)</span><br><span class="line">|-- FireplaceQuIndex: double (nullable = true)</span><br><span class="line">|-- GarageTypeIndex: double (nullable = true)</span><br><span class="line">|-- GarageYrBltIndex: double (nullable = true)</span><br><span class="line">|-- GarageFinishIndex: double (nullable = true)</span><br><span class="line">|-- GarageQualIndex: double (nullable = true)</span><br><span class="line">|-- GarageCondIndex: double (nullable = true)</span><br><span class="line">|-- PavedDriveIndex: double (nullable = true)</span><br><span class="line">|-- PoolQCIndex: double (nullable = true)</span><br><span class="line">|-- FenceIndex: double (nullable = true)</span><br><span class="line">|-- MiscFeatureIndex: double (nullable = true)</span><br><span class="line">|-- MiscValIndex: double (nullable = true)</span><br><span class="line">|-- MoSoldIndex: double (nullable = true)</span><br><span class="line">|-- YrSoldIndex: double (nullable = true)</span><br><span class="line">|-- SaleTypeIndex: double (nullable = true)</span><br><span class="line">|-- SaleConditionIndex: double (nullable = true)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- Id: string (nullable = true)</span><br><span class="line"> |-- LotFrontage: string (nullable = true)</span><br><span class="line"> |-- MSSubClassIndex: double (nullable = true)</span><br><span class="line"> |-- MSZoningIndex: double (nullable = true)</span><br><span class="line"> |-- StreetIndex: double (nullable = true)</span><br><span class="line"> |-- AlleyIndex: double (nullable = true)</span><br><span class="line"> |-- LotShapeIndex: double (nullable = true)</span><br><span class="line"> |-- LandContourIndex: double (nullable = true)</span><br><span class="line"> |-- UtilitiesIndex: double (nullable = true)</span><br><span class="line"> |-- LotConfigIndex: double (nullable = true)</span><br><span class="line"> |-- LandSlopeIndex: double (nullable = true)</span><br><span class="line"> |-- NeighborhoodIndex: double (nullable = true)</span><br><span class="line"> |-- Condition1Index: double (nullable = true)</span><br><span class="line"> |-- Condition2Index: double (nullable = true)</span><br><span class="line"> |-- BldgTypeIndex: double (nullable = true)</span><br><span class="line"> |-- HouseStyleIndex: double (nullable = true)</span><br><span class="line"> |-- OverallQualIndex: double (nullable = true)</span><br><span class="line"> |-- OverallCondIndex: double (nullable = true)</span><br><span class="line"> |-- YearBuiltIndex: double (nullable = true)</span><br><span class="line"> |-- YearRemodAddIndex: double (nullable = true)</span><br><span class="line"> |-- RoofStyleIndex: double (nullable = true)</span><br><span class="line"> |-- RoofMatlIndex: double (nullable = true)</span><br><span class="line"> |-- Exterior1stIndex: double (nullable = true)</span><br><span class="line"> |-- Exterior2ndIndex: double (nullable = true)</span><br><span class="line"> |-- MasVnrTypeIndex: double (nullable = true)</span><br><span class="line"> |-- ExterQualIndex: double (nullable = true)</span><br><span class="line"> |-- ExterCondIndex: double (nullable = true)</span><br><span class="line"> |-- FoundationIndex: double (nullable = true)</span><br><span class="line"> |-- BsmtQualIndex: double (nullable = true)</span><br><span class="line"> |-- BsmtCondIndex: double (nullable = true)</span><br><span class="line"> |-- BsmtExposureIndex: double (nullable = true)</span><br><span class="line"> |-- BsmtFinType1Index: double (nullable = true)</span><br><span class="line"> |-- BsmtFinType2Index: double (nullable = true)</span><br><span class="line"> |-- HeatingIndex: double (nullable = true)</span><br><span class="line"> |-- HeatingQCIndex: double (nullable = true)</span><br><span class="line"> |-- CentralAirIndex: double (nullable = true)</span><br><span class="line"> |-- ElectricalIndex: double (nullable = true)</span><br><span class="line"> |-- KitchenQualIndex: double (nullable = true)</span><br><span class="line"> |-- FunctionalIndex: double (nullable = true)</span><br><span class="line"> |-- FireplaceQuIndex: double (nullable = true)</span><br><span class="line"> |-- GarageTypeIndex: double (nullable = true)</span><br><span class="line"> |-- GarageYrBltIndex: double (nullable = true)</span><br><span class="line"> |-- GarageFinishIndex: double (nullable = true)</span><br><span class="line"> |-- GarageQualIndex: double (nullable = true)</span><br><span class="line"> |-- GarageCondIndex: double (nullable = true)</span><br><span class="line"> |-- PavedDriveIndex: double (nullable = true)</span><br><span class="line"> |-- PoolQCIndex: double (nullable = true)</span><br><span class="line"> |-- FenceIndex: double (nullable = true)</span><br><span class="line"> |-- MiscFeatureIndex: double (nullable = true)</span><br><span class="line"> |-- MiscValIndex: double (nullable = true)</span><br><span class="line"> |-- MoSoldIndex: double (nullable = true)</span><br><span class="line"> |-- YrSoldIndex: double (nullable = true)</span><br><span class="line"> |-- SaleTypeIndex: double (nullable = true)</span><br><span class="line"> |-- SaleConditionIndex: double (nullable = true)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> |-- LotAreaInt: double (nullable = true)</span><br><span class="line"> |-- MasVnrAreaInt: double (nullable = true)</span><br><span class="line"> |-- BsmtFinSF1Int: double (nullable = true)</span><br><span class="line"> |-- BsmtFinSF2Int: double (nullable = true)</span><br><span class="line"> |-- BsmtUnfSFInt: double (nullable = true)</span><br><span class="line"> |-- TotalBsmtSFInt: double (nullable = true)</span><br><span class="line"> |-- 1stFlrSFInt: double (nullable = true)</span><br><span class="line"> |-- 2ndFlrSFInt: double (nullable = true)</span><br><span class="line"> |-- LowQualFinSFInt: double (nullable = true)</span><br><span class="line"> |-- GrLivAreaInt: double (nullable = true)</span><br><span class="line"> |-- BsmtFullBathInt: double (nullable = true)</span><br><span class="line"> |-- BsmtHalfBathInt: double (nullable = true)</span><br><span class="line"> |-- FullBathInt: double (nullable = true)</span><br><span class="line"> |-- HalfBathInt: double (nullable = true)</span><br><span class="line"> |-- BedroomAbvGrInt: double (nullable = true)</span><br><span class="line"> |-- KitchenAbvGrInt: double (nullable = true)</span><br><span class="line"> |-- TotRmsAbvGrdInt: double (nullable = true)</span><br><span class="line"> |-- FireplacesInt: double (nullable = true)</span><br><span class="line"> |-- GarageCarsInt: double (nullable = true)</span><br><span class="line"> |-- GarageAreaInt: double (nullable = true)</span><br><span class="line"> |-- WoodDeckSFInt: double (nullable = true)</span><br><span class="line"> |-- OpenPorchSFInt: double (nullable = true)</span><br><span class="line"> |-- EnclosedPorchInt: double (nullable = true)</span><br><span class="line"> |-- 3SsnPorchInt: double (nullable = true)</span><br><span class="line"> |-- ScreenPorchInt: double (nullable = true)</span><br><span class="line"> |-- PoolAreaInt: double (nullable = true)</span><br><span class="line"> |-- SalePriceInt: double (nullable = true)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> |-- features: vector (nullable = true)</span><br><span class="line"> </span><br><span class="line"> |-- LotAreaIntVector: vector (nullable = true)</span><br><span class="line"> |-- GrLivAreaIntVector: vector (nullable = true)</span><br><span class="line"> |-- TotalBsmtSFIntVector: vector (nullable = true)</span><br><span class="line"> |-- GarageAreaIntVector: vector (nullable = true)</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28844767/article/details/94465688">https://blog.csdn.net/qq_28844767/article/details/94465688</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/23/Scala%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/23/Scala%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">Scala容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-12-23 14:33:48 / Modified: 15:14:41" itemprop="dateCreated datePublished" datetime="2021-12-23T14:33:48+08:00">2021-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Scala-数组"><a href="#Scala-数组" class="headerlink" title="Scala 数组"></a>Scala 数组</h1><p>数组是用来存储<strong>定长</strong>的<strong>同类型元素</strong>的容器。</p>
<p>以下是 Scala 数组声明的语法格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z:<span class="type">Array</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>以上语法中，<code>z</code> 声明一个字符串类型的数组，数组长度为 3 ，可存储 3 个元素。我们可以为每个元素设置值，并通过索引来访问每个元素，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z(<span class="number">0</span>) = <span class="string">&quot;Runoob&quot;</span>; z(<span class="number">1</span>) = <span class="string">&quot;Baidu&quot;</span>; z(<span class="number">2</span>) = <span class="string">&quot;Google&quot;</span></span><br></pre></td></tr></table></figure>



<p>我们也可以使用以下方式来定义一个数组：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z = <span class="type">Array</span>(<span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Baidu&quot;</span>, <span class="string">&quot;Google&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="不可变数组"><a href="#不可变数组" class="headerlink" title="不可变数组"></a>不可变数组</h2><ol>
<li><p>第一种方式定义数组(定长数组)</p>
 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr1 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）<span class="keyword">new</span>是关键字</span><br><span class="line">（<span class="number">2</span>）[<span class="type">Int</span>]是泛型，如果希望存放任意数据类型，则指定<span class="type">Any</span></span><br><span class="line">（<span class="number">3</span>）(<span class="number">10</span>)，表示数组的大小，确定后就不可以变化</span><br></pre></td></tr></table></figure></li>
<li><p>案例实操</p>
 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArray</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）数组定义</span></span><br><span class="line">        <span class="keyword">val</span> arr01 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">4</span>)</span><br><span class="line">        println(arr01.length) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）数组赋值</span></span><br><span class="line">        <span class="comment">//（2.1）修改某个元素的值</span></span><br><span class="line">        arr01(<span class="number">3</span>) = <span class="number">10</span></span><br><span class="line">        <span class="comment">//（2.2）采用方法的形式给数组赋值</span></span><br><span class="line">        arr01.update(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）遍历数组</span></span><br><span class="line">        <span class="comment">//（3.1）查看数组</span></span><br><span class="line">        println(arr01.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3.2）普通遍历</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3.3）简化遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printx</span></span>(elem:<span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(elem)</span><br><span class="line">        &#125;</span><br><span class="line">        arr01.foreach(printx)</span><br><span class="line">        <span class="comment">// arr01.foreach((x)=&gt;&#123;println(x)&#125;)</span></span><br><span class="line">        <span class="comment">// arr01.foreach(println(_))</span></span><br><span class="line">        arr01.foreach(println)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4）增加元素（由于创建的是不可变数组，增加元素，其实是产生新的数组）</span></span><br><span class="line">        println(arr01)</span><br><span class="line">        <span class="keyword">val</span> ints: <span class="type">Array</span>[<span class="type">Int</span>] = arr01 :+ <span class="number">5</span></span><br><span class="line">        println(ints)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种方式定义数组</p>
 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">（<span class="number">1</span>）在定义数组时，直接赋值</span><br><span class="line">（<span class="number">2</span>）底层使用apply方法创建数组对象</span><br></pre></td></tr></table></figure>

</li>
<li><p>案例实操</p>
 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArray</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> arr02 = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;bobo&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- arr02) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a>可变数组</h2><p>定义变长数组</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr01 = <span class="type">ArrayBuffer</span>[<span class="type">Any</span>](<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）[<span class="type">Any</span>]存放任意数据类型</span><br><span class="line">（<span class="number">2</span>）(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)初始化好的三个元素</span><br><span class="line">（<span class="number">3</span>）<span class="type">ArrayBuffer</span>需要引入scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br></pre></td></tr></table></figure>





<p><strong>Demo</strong></p>
<ol>
<li> <code>ArrayBuffer</code> 是有序的集合</li>
<li> 增加元素使用的是 <code>append()</code> 方法，支持可变参数</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArrayBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）创建并赋值可变数组</span></span><br><span class="line">        <span class="keyword">val</span> arr01 = <span class="type">ArrayBuffer</span>[<span class="type">Any</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">        &#125;</span><br><span class="line">        println(arr01.length) <span class="comment">// 3</span></span><br><span class="line">        println(<span class="string">&quot;arr01.hash=&quot;</span> + arr01.hashCode())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）增加元素</span></span><br><span class="line">        <span class="comment">//（3.1）追加数据</span></span><br><span class="line">        arr01.+=(<span class="number">4</span>)</span><br><span class="line">        <span class="comment">//（3.2）向数组最后追加数据</span></span><br><span class="line">        arr01.append(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">        <span class="comment">//（3.3）向指定的位置插入数据</span></span><br><span class="line">        arr01.insert(<span class="number">0</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">        println(<span class="string">&quot;arr01.hash=&quot;</span> + arr01.hashCode())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4）修改元素</span></span><br><span class="line">        arr01(<span class="number">1</span>) = <span class="number">9</span> <span class="comment">//修改第2个元素的值</span></span><br><span class="line">        println(<span class="string">&quot;--------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">        &#125;</span><br><span class="line">        println(arr01.length) <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="不可变数组与可变数组的转换"><a href="#不可变数组与可变数组的转换" class="headerlink" title="不可变数组与可变数组的转换"></a>不可变数组与可变数组的转换</h2><p><strong>说明</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1.toBuffer <span class="comment">//不可长数组转可变数组</span></span><br><span class="line"></span><br><span class="line">arr2.toArray <span class="comment">//可变数组转不可变数组</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>arr2.toArray</code> 返回结果才是一个不可变数组，arr2 本身没有变化</li>
<li>  <code>arr1.toBuffer</code> 返回结果才是一个可变数组，arr1 本身没有变化</li>
</ul>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArrayBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）创建一个空的可变数组</span></span><br><span class="line">        <span class="keyword">val</span> arr2 = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）追加值</span></span><br><span class="line">        arr2.append(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        println(arr2) <span class="comment">// 1,2,3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）ArrayBuffer ==&gt; Array</span></span><br><span class="line">        <span class="comment">//（3.1）arr2.toArray 返回的结果是一个新的定长数组集合</span></span><br><span class="line">        <span class="comment">//（3.2）arr2它没有变化</span></span><br><span class="line">        <span class="keyword">val</span> newArr = arr2.toArray</span><br><span class="line">        println(newArr)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4）Array ===&gt; ArrayBuffer</span></span><br><span class="line">        <span class="comment">//（4.1）newArr.toBuffer 返回一个变长数组 newArr2</span></span><br><span class="line">        <span class="comment">//（4.2）newArr 没有任何变化，依然是定长数组</span></span><br><span class="line">        <span class="keyword">val</span> newArr2 = newArr.toBuffer</span><br><span class="line">        newArr2.append(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">        println(newArr2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组定义</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>.ofDim[<span class="type">Double</span>](<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>说明：二维数组中有三个一维数组，每个一维数组中有四个元素</p>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）创建了一个二维数组, 有三个元素，每个元素是，含有4个元素一维数组()</span></span><br><span class="line">        <span class="keyword">val</span> arr = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        arr(<span class="number">1</span>)(<span class="number">2</span>) = <span class="number">88</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- arr) &#123; <span class="comment">//i 就是一维数组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j &lt;- i) &#123;</span><br><span class="line">                print(j + <span class="string">&quot; &quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            println()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="Scala-集合-Collection"><a href="#Scala-集合-Collection" class="headerlink" title="Scala 集合(Collection)"></a>Scala 集合(Collection)</h1><h2 id="集合分类一"><a href="#集合分类一" class="headerlink" title="集合分类一"></a>集合分类一</h2><p>Scala 集合分为<strong>可变集合</strong>和<strong>不可变集合</strong>。</p>
<p>可变集合可以被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。</p>
<p>而不可变集合永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，而不是改变原来的集合。</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">集合及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/scala/scala-lists.html">Scala List(列表)</a><br>List 的特征是其元素以线性方式存储，集合中可以存放重复对象。<br>参考 <a target="_blank" rel="noopener" href="http://www.scala-lang.org/api/current/scala/collection/immutable/List.html">API文档</a></td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/scala/scala-sets.html">Scala Set(集合)</a><br>Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。<br>参考 <a target="_blank" rel="noopener" href="http://www.scala-lang.org/api/current/scala/collection/immutable/Set.html">API文档</a></td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/scala/scala-maps.html">Scala Map(映射)</a><br>Map 是一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象。<br>参考 <a target="_blank" rel="noopener" href="http://www.scala-lang.org/api/current/scala/collection/immutable/Map.html">API文档</a></td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/scala/scala-tuples.html">Scala 元组</a><br>元组是不同类型的值的集合</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/scala/scala-options.html">Scala Option</a><br>Option[T] 表示有可能包含值的容器，也可能不包含值。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/scala/scala-iterators.html">Scala Iterator（迭代器）</a><br>迭代器不是一个容器，更确切的说是逐一访问容器内元素的方法。</td>
</tr>
</tbody></table>
<h2 id="集合简介"><a href="#集合简介" class="headerlink" title="集合简介"></a>集合简介</h2><p><strong>说明</strong></p>
<ol>
<li><p> Scala 的集合有三大类：序列 Seq、集 Set、映射 Map，所有的集合都扩展自 Iterable 特质。</p>
</li>
<li><p>对于几乎所有的集合类，Scala 都同时提供了<strong>可变</strong>和<strong>不可变</strong>的版本，分别位于以下两个包</p>
<ul>
<li>  不可变集合：<code>scala.collection.immutable</code></li>
<li>可变集合：<code>scala.collection.mutable</code></li>
</ul>
</li>
</ol>
<p>2）案例实操</p>
<p>​    （1）Scala不可变集合，就是指该集合对象不可修改，每次修改就会返回一个新对象，而不会对原对象进行修改。</p>
<p>（2）可变集合，就是这个集合可以直接对原对象进行修改，而不会返回新的对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不可变List</span></span><br><span class="line">        <span class="keyword">val</span> immutableList: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对不可变List进行修改，在头部添加一个元素0</span></span><br><span class="line">        <span class="keyword">val</span> newImmutableList: <span class="type">List</span>[<span class="type">Int</span>] = <span class="number">0</span> +: immutableList</span><br><span class="line"></span><br><span class="line">        println(immutableList)</span><br><span class="line"></span><br><span class="line">        println(newImmutableList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可变List</span></span><br><span class="line">        <span class="keyword">val</span> mutableList: <span class="type">ListBuffer</span>[<span class="type">Int</span>] = <span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对可变List进行修改，在头部添加一个元素0</span></span><br><span class="line">        <span class="keyword">val</span> newMutableList: <span class="type">ListBuffer</span>[<span class="type">Int</span>] = <span class="number">0</span> +=: mutableList</span><br><span class="line"></span><br><span class="line">        println(mutableList)</span><br><span class="line">        println(newMutableList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// += 可以理解为类似原地修改</span></span><br><span class="line"><span class="comment">// + 可以理解为新增，但不是在原地修改</span></span><br></pre></td></tr></table></figure>







<hr>
<h2 id="Seq集合（List）"><a href="#Seq集合（List）" class="headerlink" title="Seq集合（List）"></a>Seq集合（List）</h2><h3 id="不可变-List"><a href="#不可变-List" class="headerlink" title="不可变 List"></a>不可变 List</h3><p><strong>说明</strong></p>
<ul>
<li>  <code>List</code> 默认为不可变集合</li>
<li>  创建一个 <code>List</code>（数据有顺序，可重复）</li>
<li>  遍历 <code>List</code></li>
<li>  <code>List</code> 增加数据</li>
<li>  集合间合并：将一个整体拆成一个一个的个体，称为<strong>扁平化</strong></li>
<li>  取指定数据</li>
<li>  空集合 <code>Nil</code></li>
</ul>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）List默认为不可变集合</span></span><br><span class="line">        <span class="comment">//（2）创建一个List（数据有顺序，可重复）</span></span><br><span class="line">        <span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（7）空集合Nil</span></span><br><span class="line">        <span class="keyword">val</span> list5 = <span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::<span class="number">4</span>::<span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4）List增加数据</span></span><br><span class="line">        <span class="comment">//（4.1）::的运算规则从右向左</span></span><br><span class="line">        <span class="comment">//val list1 = 5::list</span></span><br><span class="line">        <span class="keyword">val</span> list1 = <span class="number">7</span>::<span class="number">6</span>::<span class="number">5</span>::list</span><br><span class="line">        <span class="comment">//（4.2）添加到第一个元素位置</span></span><br><span class="line">        <span class="keyword">val</span> list2 = list.+:(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（5）集合间合并：将一个整体拆成一个一个的个体，称为扁平化</span></span><br><span class="line">        <span class="keyword">val</span> list3 = <span class="type">List</span>(<span class="number">8</span>,<span class="number">9</span>)</span><br><span class="line">        <span class="comment">//val list4 = list3::list1</span></span><br><span class="line">        <span class="keyword">val</span> list4 = list3:::list1</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（6）取指定数据</span></span><br><span class="line">        println(list(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）遍历List</span></span><br><span class="line">        <span class="comment">//list.foreach(println)</span></span><br><span class="line">        <span class="comment">//list1.foreach(println)</span></span><br><span class="line">        <span class="comment">//list3.foreach(println)</span></span><br><span class="line">        <span class="comment">//list4.foreach(println)</span></span><br><span class="line">        list5.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="可变-ListBuffer"><a href="#可变-ListBuffer" class="headerlink" title="可变 ListBuffer"></a>可变 ListBuffer</h3><p><strong>说明</strong></p>
<ol>
<li> 创建一个可变集合 <code>ListBuffer</code></li>
<li> 向集合中添加数据</li>
<li> 打印集合数据</li>
</ol>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）创建一个可变集合</span></span><br><span class="line">        <span class="keyword">val</span> buffer = <span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）向集合中添加数据</span></span><br><span class="line">        buffer.+=(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）打印集合数据</span></span><br><span class="line">        buffer.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a>Map 集合</h2><p><strong>Scala 中不可变的 Map 是有序的，可变的 Map 是无序的</strong>。</p>
<h3 id="不可变-Map"><a href="#不可变-Map" class="headerlink" title="不可变 Map"></a>不可变 Map</h3><p><strong>说明</strong></p>
<ol>
<li> 创建不可变集合 <code>Map</code></li>
<li> 循环打印</li>
<li> 访问数据</li>
<li> 如果key不存在，返回0</li>
</ol>
<p><strong>二、案例实操</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// Map</span></span><br><span class="line">        <span class="comment">//（1）创建不可变集合Map</span></span><br><span class="line">        <span class="keyword">val</span> map = <span class="type">Map</span>( <span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span> )</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）访问数据</span></span><br><span class="line">        <span class="keyword">for</span> (key &lt;- map.keys) &#123;</span><br><span class="line">            <span class="comment">// 使用get访问map集合的数据，会返回特殊类型Option(选项):有值（Some），无值(None)</span></span><br><span class="line">            <span class="keyword">val</span> option: <span class="type">Option</span>[<span class="type">Int</span>] = map.get(key)</span><br><span class="line">            <span class="keyword">val</span> value: <span class="type">Int</span> = option.get</span><br><span class="line">            println(elem + <span class="string">&quot;=&quot;</span> + value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4）如果key不存在，返回0</span></span><br><span class="line">        println(map.get(<span class="string">&quot;d&quot;</span>).getOrElse(<span class="number">0</span>))</span><br><span class="line">        println(map.getOrElse(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）循环打印</span></span><br><span class="line">        map.foreach((entry)=&gt;&#123;println(entry)&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="可变Map"><a href="#可变Map" class="headerlink" title="可变Map"></a>可变Map</h3><p><strong>说明</strong></p>
<ol>
<li> 创建可变集合</li>
<li> 打印集合</li>
<li> 向集合增加数据</li>
<li> 删除数据</li>
<li> 修改数据</li>
</ol>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMap2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）创建可变集合</span></span><br><span class="line">        <span class="keyword">val</span> map = mutable.<span class="type">Map</span>( <span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span> )</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）向集合增加数据</span></span><br><span class="line">        map.+=(<span class="string">&quot;d&quot;</span>-&gt;<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数值4添加到集合，并把集合中原值1返回</span></span><br><span class="line">        <span class="keyword">val</span> maybeInt: <span class="type">Option</span>[<span class="type">Int</span>] = map.put(<span class="string">&quot;a&quot;</span>, <span class="number">4</span>)</span><br><span class="line">        println(maybeInt.getOrElse(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4）删除数据</span></span><br><span class="line">        map.-=(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（5）修改数据</span></span><br><span class="line">        map.update(<span class="string">&quot;d&quot;</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）打印集合</span></span><br><span class="line">        map.foreach((kv)=&gt;&#123;println(kv)&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p><strong>说明</strong></p>
<p>元组也是可以理解为一个容器，可以存放各种相同或不同类型的数据。说的简单点，就是将多个无关的数据封装为一个整体，称为元组。</p>
<p><strong>注意：</strong>元组中最大只能有22个元素。</p>
<p><strong>Demo：</strong></p>
<ol>
<li> 声明元组的方式：<code>(元素1，元素2，元素3)</code></li>
<li> 访问元组</li>
<li> <code>Map</code> 中的键值对其实就是元组，只不过元组的元素个数为 2，称之为对偶</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTuple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）声明元组的方式：(元素1，元素2，元素3)</span></span><br><span class="line">        <span class="keyword">val</span> tuple: (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Boolean</span>) = (<span class="number">40</span>, <span class="string">&quot;bobo&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）访问元组</span></span><br><span class="line">        <span class="comment">//（2.1）通过元素的顺序进行访问，调用方式：顺序号</span></span><br><span class="line">        println(tuple<span class="number">.1</span>)</span><br><span class="line">        println(tuple<span class="number">.2</span>)</span><br><span class="line">        println(tuple<span class="number">.3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2.2）通过索引访问数据</span></span><br><span class="line">        println(tuple.productElement(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2.3）通过迭代器访问数据</span></span><br><span class="line">        <span class="keyword">for</span> (elem &lt;- tuple.productIterator) &#123;</span><br><span class="line">            println(elem)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）Map中的键值对其实就是元组,只不过元组的元素个数为2，称之为对偶</span></span><br><span class="line">        <span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        map.foreach(tuple=&gt;&#123;println(tuple<span class="number">.1</span> + <span class="string">&quot;=&quot;</span> + tuple<span class="number">.2</span>)&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="集合常用函数"><a href="#集合常用函数" class="headerlink" title="集合常用函数"></a>集合常用函数</h1><h2 id="基本属性和常用操作"><a href="#基本属性和常用操作" class="headerlink" title="基本属性和常用操作"></a>基本属性和常用操作</h2><p><strong>说明</strong></p>
<ol>
<li> 获取集合长度</li>
<li> 获取集合大小</li>
<li> 循环遍历</li>
<li> 迭代器</li>
<li> 生成字符串</li>
<li> 是否包含</li>
</ol>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）获取集合长度</span></span><br><span class="line">        println(list.length)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）获取集合大小</span></span><br><span class="line">        println(list.size)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）循环遍历</span></span><br><span class="line">        list.foreach(println)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4）迭代器</span></span><br><span class="line">        <span class="keyword">for</span> (elem &lt;- list.iterator) &#123;</span><br><span class="line">            println(elem)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（5）生成字符串</span></span><br><span class="line">        println(list.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（6）是否包含</span></span><br><span class="line">        println(list.contains(<span class="number">3</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="衍生集合"><a href="#衍生集合" class="headerlink" title="衍生集合"></a>衍生集合</h2><p><strong>说明</strong></p>
<ol>
<li> 获取集合的头部元素 <code>head</code> </li>
<li> 获取去掉首部元素后的子集合</li>
<li> 集合最后一个数据 <code>last</code></li>
<li> 获取去掉尾部元素后的子集合</li>
<li> 反转</li>
<li> 取前（后）n 个元素 <code>take</code></li>
<li> 去掉前（后）n 个元素 <code>drop</code></li>
<li> 并集</li>
<li> 交集</li>
<li> 差集</li>
<li> <strong>拉链</strong></li>
<li> <strong>滑窗</strong></li>
</ol>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">val</span> list2: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）获取集合的头部元素</span></span><br><span class="line">        println(list1.head)</span><br><span class="line">        <span class="comment">//（3）集合的尾部元素</span></span><br><span class="line">        println(list1.last)</span><br><span class="line">        <span class="comment">//（2）获取去掉首部元素后的子集合</span></span><br><span class="line">        println(list1.tail)</span><br><span class="line">        <span class="comment">//（4）获取去掉尾部元素后的子集合</span></span><br><span class="line">        println(list1.init)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（5）反转</span></span><br><span class="line">        println(list1.reverse)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（6）取前（后）n个元素</span></span><br><span class="line">        println(list1.take(<span class="number">3</span>))</span><br><span class="line">        println(list1.takeRight(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（7）去掉前（后）n个元素</span></span><br><span class="line">        println(list1.drop(<span class="number">3</span>))</span><br><span class="line">        println(list1.dropRight(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（8）并集</span></span><br><span class="line">        println(list1.union(list2))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（9）交集</span></span><br><span class="line">        println(list1.intersect(list2))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（10）差集</span></span><br><span class="line">        println(list1.diff(list2))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（11）拉链 注:如果两个集合的元素个数不相等，那么会将同等数量的数据进行拉链，多余的数据省略不用</span></span><br><span class="line">        println(list1.zip(list2))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（12）滑窗</span></span><br><span class="line">        list1.sliding(<span class="number">2</span>, <span class="number">5</span>).foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="集合计算初级函数"><a href="#集合计算初级函数" class="headerlink" title="集合计算初级函数"></a>集合计算初级函数</h2><p><strong>说明</strong></p>
<ol>
<li> 求和</li>
<li> 求乘积</li>
<li> 最大值</li>
<li> 最小值</li>
<li> 排序</li>
</ol>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-7</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）求和</span></span><br><span class="line">        println(list.sum)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）求乘积</span></span><br><span class="line">        println(list.product)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）最大值</span></span><br><span class="line">        println(list.max)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4）最小值</span></span><br><span class="line">        println(list.min)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（5）排序</span></span><br><span class="line">        <span class="comment">// （5.1）按照元素大小排序</span></span><br><span class="line">        println(list.sortBy(x =&gt; x))  <span class="comment">// 正序</span></span><br><span class="line">        println(list.sortBy(x =&gt; -x)) <span class="comment">// 倒序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// （5.2）按照元素的绝对值大小排序</span></span><br><span class="line">        println(list.sortBy(x =&gt; x.abs))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （5.3）按元素大小升序排序</span></span><br><span class="line">        println(list.sortWith((x, y) =&gt; x &lt; y))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （5.4）按元素大小降序排序</span></span><br><span class="line">        println(list.sortWith((x, y) =&gt; x &gt; y))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="集合计算高级函数"><a href="#集合计算高级函数" class="headerlink" title="集合计算高级函数"></a>集合计算高级函数</h2><p><img src="/2021/12/23/Scala%E5%AE%B9%E5%99%A8/image-20211210144455768.png" alt="image-20211210144455768"></p>
<p><strong>说明</strong></p>
<ol>
<li> 过滤：<code>filter</code></li>
<li> 映射：<code>map</code></li>
<li> 扁平化：<code>flatten</code></li>
<li> 扁平化+映射：<code>flatMap</code> 【注：<code>flatMap</code> 相当于先进行 <code>map</code> 操作，再进行 <code>flatten</code> 操作】   </li>
<li>简化（规约）：<code>reduce</code><ul>
<li>  <code>reduceLeft</code>：等价于 <code>reduce</code>，表示从左向右进行聚合</li>
<li>  <code>reduceRight</code>：从右向左进行聚合</li>
</ul>
</li>
<li> 分组：<code>groupBy</code></li>
<li> 折叠：<code>Fold</code></li>
</ol>
<blockquote>
<p>  map 和 foreach 的区别</p>
</blockquote>
<p><code>map</code> 拥有返回值，而 <code>foreach</code> 没有返回值</p>
<p>实操</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">        <span class="keyword">val</span> nestedList: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="type">List</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line">        <span class="keyword">val</span> wordList: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello atguigu&quot;</span>, <span class="string">&quot;hello scala&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（1）过滤</span></span><br><span class="line">        println(list.filter(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）转化/映射</span></span><br><span class="line">        println(list.map(x =&gt; x + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）扁平化</span></span><br><span class="line">        println(nestedList.flatten)	<span class="comment">// 输出结果为：List(1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（4）扁平化+映射 注：flatMap相当于先进行map操作，在进行flatten操作</span></span><br><span class="line">        println(wordList.flatMap(x =&gt; x.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			&quot;hello world&quot;, &quot;hello atguigu&quot;, &quot;hello scala&quot;</span></span><br><span class="line"><span class="comment">			==&gt; map</span></span><br><span class="line"><span class="comment">            [</span></span><br><span class="line"><span class="comment">            	[hello, world], </span></span><br><span class="line"><span class="comment">            	[hello, atguigu], </span></span><br><span class="line"><span class="comment">            	[hello, scala]</span></span><br><span class="line"><span class="comment">            ]</span></span><br><span class="line"><span class="comment">            ==&gt; flatten</span></span><br><span class="line"><span class="comment">            [hello, world, hello, atguigu, hello, scala]</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="comment">//（5）分组</span></span><br><span class="line">        println(list.groupBy(x =&gt; x % <span class="number">2</span>))	<span class="comment">// 输出结果为：Map(false -&gt; List(1, 3, 5, 7, 9), true -&gt; List(2, 4, 6, 8))</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p><code>Reduce</code> 简化（规约）：通过指定的逻辑将集合中的数据进行聚合，从而减少数据，最终获取结果。</p>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestReduce</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据两两结合，实现运算规则</span></span><br><span class="line">        <span class="keyword">val</span> i: <span class="type">Int</span> = list.reduce( (x,y) =&gt; x-y )</span><br><span class="line">        println(<span class="string">&quot;i = &quot;</span> + i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从源码的角度，reduce底层调用的其实就是reduceLeft</span></span><br><span class="line">        <span class="comment">//val i1 = list.reduceLeft((x,y) =&gt; x-y)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ((4-3)-2-1) = -2</span></span><br><span class="line">        <span class="keyword">val</span> i2 = list.reduceRight((x,y) =&gt; x-y)</span><br><span class="line">        println(i2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Fold"><a href="#Fold" class="headerlink" title="Fold"></a>Fold</h3><p><code>Fold</code> 折叠：化简的一种特殊情况。</p>
<p><strong>Demo01</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFold</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fold方法使用了函数柯里化，存在两个参数列表</span></span><br><span class="line">        <span class="comment">// 第一个参数列表为 ： 零值（初始值）</span></span><br><span class="line">        <span class="comment">// 第二个参数列表为：</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fold 底层其实为 foldLeft</span></span><br><span class="line">        <span class="keyword">val</span> i = list.foldLeft(<span class="number">1</span>)((x,y)=&gt;x-y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> i1 = list.foldRight(<span class="number">10</span>)((x,y)=&gt;x-y)</span><br><span class="line"></span><br><span class="line">        println(i)</span><br><span class="line">        println(i1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Demo02</strong>：两个集合合并</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFold</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个Map的数据合并</span></span><br><span class="line">        <span class="keyword">val</span> map1 = mutable.<span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">val</span> map2 = mutable.<span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">4</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">5</span>, <span class="string">&quot;d&quot;</span>-&gt;<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> map3: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map2.foldLeft(map1) &#123;</span><br><span class="line">            (map, kv) =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> k = kv._1</span><br><span class="line">                <span class="keyword">val</span> v = kv._2</span><br><span class="line"></span><br><span class="line">                map(k) = map.getOrElse(k, <span class="number">0</span>) + v</span><br><span class="line"></span><br><span class="line">                map</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(map3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>在 scala 中，不管是可变集合还是不可变集合，都是返回一个新的排好序的集合。原集合不会发生变化。默认升序</p>
<hr>
<p><strong>不可变</strong></p>
<p><code>:+</code>：一般用于给不可变的集合追加元素（尾插）</p>
<p><code>:+</code>：一般用于给不可变的集合开头插入元素（头插）</p>
<p><strong>可变</strong></p>
<p><code>+=</code>：一般用于可变集合，表示尾插</p>
<p><code>:+=</code>：一般用于可变集合，表示头插</p>
<p><code>++=</code>：把等号后面的元素合并到前面的集合中</p>
<p><code>冒号挨着的对象就是方法的调用主体。</code></p>
<p><code>-=</code>：删除满足条件的第一个元素</p>
<p><code>--=</code>：移出两个结合中的交集元素，（只移出一次）</p>
<p><strong>通用</strong></p>
<p><code>++</code>：合并两个集合 </p>
<p><strong>链表:List</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span></span><br><span class="line"></span><br><span class="line">空链表：</span><br><span class="line">	<span class="type">Nil</span></span><br><span class="line">	<span class="type">List</span>[<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">添加元素（专用）</span><br><span class="line">	:: 	添加元素</span><br><span class="line">	::: 合并两个<span class="type">List</span></span><br></pre></td></tr></table></figure>





<p><strong>Set</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">并集：</span><br><span class="line">	set1 ++ set2</span><br><span class="line">	set1 | set2</span><br><span class="line">	set1 union set2</span><br><span class="line"></span><br><span class="line">交集</span><br><span class="line">	set1 &amp; set2</span><br><span class="line">	set1 intersect set2</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">差集</span><br><span class="line">	set1 &amp;~ set2</span><br><span class="line">	set1 -- set2</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Java-和-Scala-容器的互相转换"><a href="#Java-和-Scala-容器的互相转换" class="headerlink" title="Java 和 Scala 容器的互相转换"></a>Java 和 Scala 容器的互相转换</h2><p>我们知道在 Scala 中可以引入 Java 的 API，但是如果引入 Java 的 API，那么部分的 Scala 特性就不能正常使用了。比如我们创建一个 Java 的 ArrayList ，那么就不能使用 <code>+=</code> 或者 <code>ints.foreach(println)</code> 等来处理这个集合。为了解决这种问题，我们可以通过引入 <code>scala.collection.JavaConversions._</code> 来实现 Java 和 Scala 中对应 API 的自动互相转换，这样就可以无缝使用两种语言的语法了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">J2s</span></span>&#123;</span><br><span class="line">  <span class="keyword">import</span> scala.collection.<span class="type">JavaConversions</span>._		<span class="comment">// 引入J2S转换包，这个包中包含了许多隐式转换，可以完成Java集合和Scala集合的互转</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> ints = <span class="keyword">new</span> util.<span class="type">ArrayList</span>[<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">    ints.add(<span class="number">1</span>) <span class="comment">// Java语法</span></span><br><span class="line">    ints.add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    ints += <span class="number">3</span> <span class="comment">// scala 语法</span></span><br><span class="line">    ints.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/22/Scala%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/22/Scala%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="post-title-link" itemprop="url">Scala模式匹配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-22 16:52:28" itemprop="dateCreated datePublished" datetime="2021-12-22T16:52:28+08:00">2021-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-23 11:13:47" itemprop="dateModified" datetime="2021-12-23T11:13:47+08:00">2021-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>Scala 中的模式匹配<code>(match)</code> 类似于 Java 中的 <code>switch</code> 语法，但是功能更为强大。</p>
<p>所谓的模式匹配，就是一个定义好规则的黑盒，这个黑盒中保存了非常多种 <code>case</code>。对于使用它的用户来讲，只需要传入一个值，就会执行与该值成功匹配的 <code>case</code>。</p>
<p>一个模式匹配包含了一系列备选项，每个都开始于关键字 <code>case</code>。每个备选项都包含了一个模式及一到多个表达式。箭头符号 <code>=&gt;</code> 隔开了模式和表达式。</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> one =&gt; ???</span><br><span class="line">    <span class="keyword">case</span> two =&gt; ???</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式匹配语法中，采用 <code>match</code> 关键字声明进入模式匹配，每个分支采用 <code>case</code> 关键字进行声明，当需要匹配时，会从第一个 <code>case</code> 分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有 <code>case</code> 都不匹配，那么会执行 <code>case _</code> 分支，类似于 Java 中 <code>default</code> 语句。</p>
<p><strong>注意：</strong><code>case _</code>分支必须放在最后，因为 <code>case _</code> 可以匹配所有情况，将会导致 <code>case _</code> 之后的所有 <code>case</code> 都失效。同理，在模式匹配中一定要注意 <code>case</code> 的顺序，如果进入了排在前面的 <code>case</code>，那么排在后面的 <code>case</code> 就一定不会被执行，所以一定要把范围小的条件放在前面，范围大的条件放在后面。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 17:01</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> a:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> b:<span class="type">Int</span> = <span class="number">20</span></span><br><span class="line">    <span class="keyword">val</span> operator:<span class="type">Char</span> = &#x27;x&#x27;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> res = operator <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &#x27;+&#x27; =&gt; a + b</span><br><span class="line">      <span class="keyword">case</span> &#x27;-&#x27; =&gt; a - b</span><br><span class="line">      <span class="keyword">case</span> &#x27;*&#x27; =&gt; a * b</span><br><span class="line">      <span class="keyword">case</span> &#x27;/&#x27; =&gt; a / b</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">&quot;您的输入不合法，请重新输入&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">输出结果为：</span><br><span class="line">您的输入不合法，请重新输入</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li> 如果所有 <code>case</code> 都不匹配，那么会执行 <code>case _</code> 分支，类似于 Java 中的 <code>default</code> 语句，若没有 <code>case _</code> 分支，则会抛出 <code>MatchError</code>。</li>
<li> <code>match</code> 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的 <code>case</code>，剩下的 <code>case</code>不会继续匹配。即在每个 <code>case</code> 中，不用 <code>break</code> 语句，自动中断 <code>case</code>。</li>
<li> <code>match...case...</code> 语句可以匹配任何类型，而不只是字面量。</li>
<li> <code>=&gt;</code> 后面的代码块，<strong>作为一个整体执行</strong>，可以使用 <code>&#123;&#125;</code> 括起来，也可以不括。</li>
</ol>
<hr>
<h1 id="模式守卫"><a href="#模式守卫" class="headerlink" title="模式守卫"></a>模式守卫</h1><p>就是在模式匹配中加守卫。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 17:26</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchGuard</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个函数，函数内部使用了模式匹配。返回匹配的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(num: <span class="type">Int</span>) = &#123;</span><br><span class="line">      num <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> x: <span class="type">Int</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> =&gt; x</span><br><span class="line">        <span class="keyword">case</span> x: <span class="type">Int</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> =&gt; -x</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">&quot;非法参数&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【x : Int if x &gt;= 0】整体作为一个判断条件，既有参数类型匹配，也有参数范围匹配</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(abs(<span class="number">-5</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">输出结果为：</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="模式匹配类型"><a href="#模式匹配类型" class="headerlink" title="模式匹配类型"></a>模式匹配类型</h1><h2 id="匹配常量"><a href="#匹配常量" class="headerlink" title="匹配常量"></a>匹配常量</h2><p><strong>说明</strong>：<code>scala</code> 中，模式匹配可以匹配所有的字面量，包括<strong>字符串，字符，数字，布尔值</strong>等等。</p>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 17:40</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchVal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(describe(<span class="number">6</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(args1 : <span class="type">Any</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    args1 <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span> =&gt; <span class="string">&quot;Int five&quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> =&gt; <span class="string">&quot;Int five&quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="string">&quot;Boolean true&quot;</span></span><br><span class="line">      <span class="keyword">case</span> &#x27;+&#x27; =&gt; <span class="string">&quot;Char +&quot;</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">&quot;Other&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h2><p><strong>说明：</strong>在某些需要进行类型判断场景中，可以使用 Scala 内置的 <code>isInstanceOf[T]</code> 和 <code>asInstanceOf[T]</code> 方法，也可使用模式匹配实现同样的功能</p>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 17:49</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 数组例外，可以保留泛型</span></span><br><span class="line">    println(describe(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))) <span class="comment">// 输出结果为：Other</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其它类型（如List），将会执行泛型擦除</span></span><br><span class="line">    println(describe(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))) <span class="comment">// 输出结果为：List[String]</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(args1 : <span class="type">Any</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    args1 <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> x : <span class="type">Int</span> =&gt; <span class="string">&quot;Int&quot;</span></span><br><span class="line">      <span class="keyword">case</span> y : <span class="type">String</span> =&gt; <span class="string">&quot;String&quot;</span></span><br><span class="line">      <span class="keyword">case</span> z : <span class="type">Array</span>[<span class="type">String</span>] =&gt; <span class="string">&quot;Array[Int]&quot;</span></span><br><span class="line">      <span class="keyword">case</span> w : <span class="type">List</span>[<span class="type">String</span>] =&gt; <span class="string">&quot;List[String]&quot;</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">&quot;Other&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  分析：在上面的代码中，我们使用 <code>List[Int]</code> 类型的集合，却与 <code>List[String]</code> 类型的 case 匹配成功了，这是因为发生了泛型擦除。</li>
</ul>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p><strong>是什么？</strong></p>
<p>所谓泛型擦除，是指 <code>.scala</code> 源代码文件编译成 <code>.class</code> 字节码文件后，会擦除源代码中的泛型类型。也就是说在 <code>.class</code> 字节码文件中是没有泛型的。</p>
<p>在 Scala 中，除了数组，其它所有都是真正使用了泛型。虽然数组看起来也像是使用了泛型，但是实际上并没有使用到泛型。因为数组在编译后的类型就是 <code>new int[]</code>，<code>new String[]</code> 等等这些。</p>
<p><strong>Scala 的模式匹配是无法匹配对象的泛型的。</strong></p>
<p><strong>Demo</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 数组例外，可以保留泛型</span></span><br><span class="line">    println(describe(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))) <span class="comment">// 输出结果为：Other</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其它类型（如List），将会执行泛型擦除</span></span><br><span class="line">    println(describe(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))) <span class="comment">// 输出结果为：List[String]</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(args1 : <span class="type">Any</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    args1 <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> x : <span class="type">Int</span> =&gt; <span class="string">&quot;Int&quot;</span></span><br><span class="line">      <span class="keyword">case</span> y : <span class="type">String</span> =&gt; <span class="string">&quot;String&quot;</span></span><br><span class="line">      <span class="keyword">case</span> z : <span class="type">Array</span>[<span class="type">String</span>] =&gt; <span class="string">&quot;Array[Int]&quot;</span></span><br><span class="line">      <span class="keyword">case</span> w : <span class="type">List</span>[<span class="type">String</span>] =&gt; <span class="string">&quot;List[String]&quot;</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">&quot;Other&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 可以看到，我们使用了 <code>List[Int]</code> 类型的集合去匹配 <code>List[Double]</code> 类型，并且匹配成功了。这就是因为发生了 <strong>泛型擦除</strong>，即在源代码在编译后，只保留了 <code>List</code> 类型，而把泛型全部擦除了。所以真正执行的类型匹配是 <code>List &lt;==&gt; List</code>，所以匹配成功了。</li>
<li> 在 Scala 中的数组看起来像是使用了泛型，诸如 <code>Array[Int]</code> 之类，但是实际上在编译后它的底层实现是 <code>new Int[]</code>，也就是说真正执行的类型匹配是 <code>Int[] &lt;==&gt; String[]</code>，所以匹配失败了。</li>
</ol>
<hr>
<h2 id="匹配数组"><a href="#匹配数组" class="headerlink" title="匹配数组"></a>匹配数组</h2><p><strong>说明</strong>：Scala 的模式匹配可以对集合及集合中的元素进行精确的匹配。</p>
<p><strong>Demo01</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matchTest08</span></span>() = &#123;</span><br><span class="line">  <span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  array <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="comment">// 要求：①长度为4 ②前两个元素是1和2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, _, _) =&gt; println(<span class="string">&quot;(1,2,_,_)&quot;</span>)</span><br><span class="line">    <span class="comment">// 要求：①长度为4  ②前两个元素是1和2  ③后两个元素用变量a和b接收</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, a, b) =&gt; println(<span class="string">s&quot;(1, 2, <span class="subst">$a</span>, <span class="subst">$b</span>)&quot;</span>) <span class="comment">// 变量可以接收任意类型的值</span></span><br><span class="line">    <span class="comment">// 要求：①长度任意  ②前两个元素是2和2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">2</span>, <span class="number">2</span>, _*) =&gt; println(<span class="string">&quot;前两个元素是2，2的任意长度集合&quot;</span>)</span><br><span class="line">    <span class="comment">// 要求：①长度任意  ②前两个元素是2和2  ③用变量x接收通配符_*匹配的集合</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">2</span>, <span class="number">2</span>, x@_*) =&gt; println(x) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>Demo02</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 19:43</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> array: <span class="type">Array</span>[<span class="type">Array</span>[_ &gt;: <span class="type">Int</span>]] = <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="type">Array</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">90</span>))</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- array) &#123;</span><br><span class="line">      <span class="keyword">val</span> res: <span class="type">String</span> = elem <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="comment">// 匹配与 Array(0) 相同的数组</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="comment">// 匹配有两个元素的数组</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(x, y) =&gt; x + <span class="string">&quot;,&quot;</span> + y</span><br><span class="line">        <span class="comment">// 匹配以 0 开头的数组</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; <span class="string">&quot;以0开头的数组&quot;</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">&quot;Others&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      println(<span class="string">&quot;res = &quot;</span> + res)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="集合的模式匹配"><a href="#集合的模式匹配" class="headerlink" title="集合的模式匹配"></a>集合的模式匹配</h2><p>模式匹配还可以根据集合内部的元素进行匹配，但是要求集合必须是有序集合。也就是 HashSet、HashMap 等不能使用模式匹配。</p>
<h2 id="匹配-List"><a href="#匹配-List" class="headerlink" title="匹配 List"></a>匹配 List</h2><ol>
<li> <code>Array</code> 中的模式匹配规则在 <code>List</code> 中同样适用</li>
<li> 并且 <code>List</code> 还对这些匹配规则定义了自己独有的简化语法</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 20:00</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchList</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> myList: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用API</span></span><br><span class="line">    myList <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 1、要求 List 中有四个元素</span></span><br><span class="line"><span class="comment">      * 2、要求 List 中第三个元素为 30</span></span><br><span class="line"><span class="comment">      * 3、用 a 接收 List 中第一个元素，b 接收第二个元素，*/</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>(a, b, <span class="number">30</span>, _) =&gt; println(<span class="string">s&quot;<span class="subst">$a</span>, <span class="subst">$b</span>, 30, _&quot;</span>) <span class="comment">// 10, 20, 30, _</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1、不限制 List 中元素的个数</span></span><br><span class="line"><span class="comment">        * 2、用 a 接收 List 中第一个元素</span></span><br><span class="line"><span class="comment">        * 3、用 `other@_*` 接收 List 中的其它元素，并封装到一个新的 List 中</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>(a, other@_*) =&gt; println(<span class="string">s&quot;<span class="subst">$a</span>, <span class="subst">$other</span>&quot;</span>) <span class="comment">// 10, List(20, 30, 40)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;分隔符=================&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 专用API</span></span><br><span class="line">    myList <span class="keyword">match</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1、要求 List 中有四个元素，Nil 是结束条件</span></span><br><span class="line"><span class="comment">        * 2、用 a 接收 List 中第一个元素</span></span><br><span class="line"><span class="comment">        * 3、用 `other` 接收 List 中的其它元素，并封装到一个新的 List 中。</span></span><br><span class="line"><span class="comment">        * other 不是固定的写法，可以用任意的其它字符串代替，如果没有 Nil 作为结束条件，</span></span><br><span class="line"><span class="comment">        * 默认可以匹配任意多个参数的 List */</span></span><br><span class="line">      <span class="keyword">case</span> (a :: other) =&gt; println(<span class="string">s&quot;<span class="subst">$a</span>, <span class="subst">$other</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> (a :: b :: c :: d :: <span class="type">Nil</span>) =&gt; println(<span class="string">s&quot;<span class="subst">$a</span>, <span class="subst">$b</span>, <span class="subst">$c</span>, <span class="subst">$d</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, _</span><br><span class="line">分隔符=================</span><br><span class="line"><span class="number">10</span>, <span class="type">List</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br></pre></td></tr></table></figure>





<h2 id="匹配元组"><a href="#匹配元组" class="headerlink" title="匹配元组"></a>匹配元组</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 20:23</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 匹配元组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchTuple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> tuple: (<span class="type">String</span>, <span class="type">Int</span>) = (<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组的输出的缺点：无法做到见名知意</span></span><br><span class="line">    println(tuple._1 + <span class="string">&quot;：&quot;</span> + tuple._2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式匹配下输出元组中的元素</span></span><br><span class="line">    tuple <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="comment">// 匹配到一个元组元素，用 name 接收 tuple._1，用 age 接收 tuple._2</span></span><br><span class="line">      <span class="keyword">case</span> (name, age) =&gt; println(name + <span class="string">&quot;：&quot;</span> + age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line">张三：<span class="number">20</span></span><br><span class="line">张三：<span class="number">20</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h2><ul>
<li>  当 <code>case</code> 匹配的条件是一个对象时（以 <code>class User</code> 为例），必须创建 <code>User</code> 类的伴生对象并重写对象中的 <code>unapply()</code> 方法。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 20:26</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 匹配对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchObject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建一个 User 实例</span></span><br><span class="line">    <span class="keyword">val</span> user: <span class="type">User</span> = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">    user <span class="keyword">match</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 当将 User(&quot;张三&quot;, 23) 写在 case 后面时，会默认调用 User 伴生对象中的 unapply() 方法（对象提取器），</span></span><br><span class="line"><span class="comment">        * 所以 User 类必须实现伴生对象并重写 unapply() 方法。该方法接收一个 user 实例作为参数，并且会将 User </span></span><br><span class="line"><span class="comment">        * 对象的 name 和 age 属性提取出来，与 new User(&quot;张三&quot;, 23) 对象中的属性值进行匹配。*/</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>) =&gt; println(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">&quot;Other&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// User 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">val name: <span class="type">String</span>, val age : <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 User 的伴生对象，并重写 unapply 方法</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(user: <span class="type">User</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) <span class="keyword">return</span> <span class="type">None</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="type">Some</span>(user.name, user.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/22/Scala%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/image-20211222203728840.png" alt="image-20211222203728840"></p>
<ul>
<li>  当将 <code>User(&quot;张三&quot;, 23)</code> 写在 <code>case</code> 后面时，会默认调用 <code>User</code> 伴生对象中的 <strong>unapply()</strong> 方法来解析这个对象，所以 <code>User</code> 类必须实现伴生对象并重写 <code>unapply()</code> 方法，该方法接收一个 <code>user</code> 实例作为参数，并且会将 <code>User</code> 对象的 <code>name</code> 和 <code>age</code> 属性提取出来，与 <code>new User(&quot;张三&quot;, 23)</code> 对象中的属性值进行匹配。</li>
<li>  <code>unapply()</code> 方法的返回值类型是 <strong>Option</strong>，<code>Option</code> 有两种子类型。只有当返回值类型为 <code>Some</code> 且所有属性均一致时才算匹配成功，当返回 <code>None</code> 或者返回 <code>Some</code> 但是属性不一致时都表示匹配失败。</li>
</ul>
<h3 id="unapply-方法"><a href="#unapply-方法" class="headerlink" title="unapply 方法"></a>unapply 方法</h3><p><code>unapply</code> 方法又被称为对象提取器</p>
<ol>
<li> 若只提取对象的一个属性，则提取器为 <code>unapply(obj : Obj) : Option[T]</code></li>
<li> 若提取对象的多个属性，则提取器为 <code>unapply(obj : Obj) : Option[ (T1,T2,T3…) ]</code></li>
<li> 若提取对象的可变个属性，则提取器为 <code>unapplySeq(obj: Obj) : Option[ Seq[T] ]</code></li>
</ol>
<hr>
<h3 id="样例类"><a href="#样例类" class="headerlink" title="样例类"></a>样例类</h3><p><strong>创建一个样例类：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ol>
<li> 样例类仍然是类，只是和普通类相比，其自动生成了伴生对象，并且已经在伴生对象中实现了一些常用的方法，如 <code>apply、unapply、toString、equals、hashCode</code> 和 <code>copy</code> 等。</li>
<li> <strong>样例类是为了适应模式匹配而优化的类</strong>，因为其默认提供了 <code>unapply</code> 方法，所以样例类可以直接使用模式匹配，而无需再去实现一遍 <code>unapply</code> 方法。</li>
<li> 在样例类中，构造器中的每一个参数都设置为 <code>val</code>，除非它被显式地声明为 <code>var</code>（不建议这样做）</li>
</ol>
<p><strong>Demo</strong></p>
<p>上一节中匹配对象的案例使用样例类的话会节省大量代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 21:09</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchCaseClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> emp: <span class="type">Emp</span> = <span class="keyword">new</span> <span class="type">Emp</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">    emp <span class="keyword">match</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 样例类的模式匹配</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Emp</span>(<span class="string">&quot;张三&quot;</span>, x) =&gt; println(<span class="string">&quot;张三Yes&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Emp</span>(<span class="string">&quot;李四&quot;</span>, y) =&gt; println(<span class="string">&quot;李四Yes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span>(<span class="params">name: <span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="隐式模式匹配-implicit"><a href="#隐式模式匹配-implicit" class="headerlink" title="隐式模式匹配(implicit)"></a>隐式模式匹配(implicit)</h1><p>隐式模式匹配就是看起来没使用模式匹配，也就是没使用 <code>match...case..</code> 语法，但其实在底层实现用用到了模式匹配的代码。</p>
<h2 id="变量声明中的模式匹配"><a href="#变量声明中的模式匹配" class="headerlink" title="变量声明中的模式匹配"></a>变量声明中的模式匹配</h2><p><strong>是什么？</strong></p>
<p>在声明变量时把等号右边的对象中的属性或方法赋值给等号左边的变量中，类似于 Vue 中的<strong>解构表达式</strong>，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 21:53</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchImplicit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在创建变量 (x, y) 时把元组 (1, 2) 中对应位置上的值分别赋值给变量 x 和 y</span></span><br><span class="line">    <span class="keyword">val</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    println(<span class="string">s&quot;x=<span class="subst">$x</span>, y=<span class="subst">$y</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在创建变量 Array(first, second, _*) 时把数组 Array(1, 2, 3, 4) </span></span><br><span class="line">    <span class="comment">// 中前两个元素的值分别赋值给变量 first 和 second</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">Array</span>(first, second, _*) = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    println(<span class="string">s&quot;first=<span class="subst">$first</span>, second=<span class="subst">$second</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在创建变量 Person(name, age) 时把 Person(&quot;zz&quot;, 13) 实例</span></span><br><span class="line">    <span class="comment">// 中的 `zz` 和 `13` 分别赋值给变量中的 name 和 age</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">Person</span>(name, age) = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;zz&quot;</span>, <span class="number">13</span>)</span><br><span class="line">    println(<span class="string">s&quot;name=<span class="subst">$name</span>, age=<span class="subst">$age</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为底层使用到了模式匹配，所以还必须创建伴生对象并实现 unapply 方法</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行以上代码，输出结果为：</span></span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line"><span class="comment">x=1, y=2</span></span><br><span class="line"><span class="comment">first=1, second=2</span></span><br><span class="line"><span class="comment">name=zz, age=13</span></span><br><span class="line"><span class="comment">----------------------------------- */</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="for-表达式中的模式匹配"><a href="#for-表达式中的模式匹配" class="headerlink" title="for 表达式中的模式匹配"></a>for 表达式中的模式匹配</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author lnd</span></span><br><span class="line"><span class="comment"> * @Date 2021/12/22 22:18</span></span><br><span class="line"><span class="comment"> * @Version 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchFor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;A&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;B&quot;</span> -&gt; <span class="number">0</span>, <span class="string">&quot;C&quot;</span> -&gt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> ((k, v) &lt;- map) &#123; <span class="comment">// 直接将 map 中的 k-v 遍历出来</span></span><br><span class="line">      println(k + <span class="string">&quot; -&gt; &quot;</span> + v) <span class="comment">// 3个</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;************************&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历 value = 0 的 k-v , 如果 v 不是 0 , 过滤</span></span><br><span class="line">    <span class="keyword">for</span> ((k, <span class="number">0</span>) &lt;- map) &#123;</span><br><span class="line">      println(k + <span class="string">&quot; --&gt; &quot;</span> + <span class="number">0</span>) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;************************&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if v == 0 是一个过滤的条件</span></span><br><span class="line">    <span class="keyword">for</span> ((k, v) &lt;- map <span class="keyword">if</span> v &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      println(k + <span class="string">&quot; ---&gt; &quot;</span> + v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 执行以上代码，输出结果为：</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="comment">A -&gt; 1</span></span><br><span class="line"><span class="comment">B -&gt; 0</span></span><br><span class="line"><span class="comment">C -&gt; 3</span></span><br><span class="line"><span class="comment">************************</span></span><br><span class="line"><span class="comment">B --&gt; 0</span></span><br><span class="line"><span class="comment">************************</span></span><br><span class="line"><span class="comment">A ---&gt; 1</span></span><br><span class="line"><span class="comment">C ---&gt; 3</span></span><br><span class="line"><span class="comment">----------------------------------- */</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="偏函数中的模式匹配"><a href="#偏函数中的模式匹配" class="headerlink" title="偏函数中的模式匹配"></a>偏函数中的模式匹配</h2><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/12/22/Scala%E5%87%BD%E6%95%B0">偏函数</a></p>
</blockquote>
<p><strong>偏函数的本质就是定义一个新的函数，对原始函数的功能进行增强。</strong></p>
<p>偏函数也是函数的一种，通过偏函数我们可以方便的对输入参数做更精确的检查。例如该偏函数的输入类型为 <code>List[Int]</code>，而我们需要的是第一个元素是 0 的集合，这就是通过模式匹配实现的。</p>
<p><strong>偏函数定义</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建了一个偏函数叫做 second，该偏函数的功能是返回输入 List 集合的第二个元素</span></span><br><span class="line"><span class="keyword">val</span> second: <span class="type">PartialFunction</span>[<span class="type">List</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]] = &#123;</span><br><span class="line">    <span class="keyword">case</span> x :: y :: _ =&gt; <span class="type">Some</span>(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/22/Scala%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/image-20211222223132241.png" alt="image-20211222223132241"></p>
<p><strong>偏函数原理</strong></p>
<p>上述代码会被 scala 编译器翻译成以下代码，与普通函数相比，只是多了一个用于参数检查的函数 <code>isDefinedAt</code>，其返回值类型为 <code>Boolean</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">val</span> second = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">List</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]] &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查输入参数是否合格</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = list <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> x :: y :: _ =&gt; <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数逻辑</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Option</span>[<span class="type">Int</span>] = list <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> x :: y :: _ =&gt; <span class="type">Some</span>(y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>偏函数使用</strong></p>
<p>偏函数不能像 <code>second(List(1,2,3))</code> 这样直接使用，因为这样会直接调用 <code>apply</code> 方法，而应该调用 <code>applyOrElse</code> 方法，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">second.applyOrElse(  <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),  (_: <span class="type">List</span>[<span class="type">Int</span>]) =&gt; <span class="type">None</span>	 )</span><br></pre></td></tr></table></figure>

<p><code>applyOrElse</code> 方法的逻辑为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ifDefinedAt(list) )</span><br><span class="line">	apply(list) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	<span class="keyword">default</span></span><br></pre></td></tr></table></figure>

<p>如果输入参数满足条件，即 <code>isDefinedAt</code> 返回 <code>true</code>，则执行 <code>apply</code> 方法，否则执行 <code>defalut</code> 方法，<code>default</code> 方法为参数不满足要求的处理逻辑。</p>
<p><strong>案例实操</strong></p>
<ol>
<li><p> 需求：将 <code>List(1,2,3,4,5,6,&quot;test&quot;)</code> 中 <code>Int</code> 类型的元素加一，并去掉字符串。</p>
</li>
<li><p>实操</p>
 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;test&quot;</span>).filter(_.isInstanceOf[<span class="type">Int</span>]).map(_.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;test&quot;</span>).collect &#123; <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">1</span> &#125;.foreach(println)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>说实话，偏函数有点子懵</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/22/Scala%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/22/Scala%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Scala函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-22 11:15:55" itemprop="dateCreated datePublished" datetime="2021-12-22T11:15:55+08:00">2021-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-23 15:23:35" itemprop="dateModified" datetime="2021-12-23T15:23:35+08:00">2021-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Scala-方法与函数"><a href="#Scala-方法与函数" class="headerlink" title="Scala 方法与函数"></a>Scala 方法与函数</h1><h2 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h2><p>Scala 有方法与函数，二者在语义上的区别很小。Scala 方法是类的一部分，而<strong>函数是一个对象</strong>可以赋值给一个变量。换句话来说在类中定义的函数即是方法。</p>
<p>Scala 中的方法跟 Java 的类似，方法是组成类的一部分。</p>
<p>Scala 中的函数则是一个完整的对象，Scala 中的函数其实就是继承了 Trait 的类的对象。</p>
<p>Scala 中使用 <strong>val</strong> 语句可以定义函数，<strong>def</strong> 语句定义方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m</span></span>(x: <span class="type">Int</span>) = x + <span class="number">3</span>	<span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">val</span> f = (x: <span class="type">Int</span>) =&gt; x + <span class="number">3</span>	<span class="comment">// 函数，将函数对象赋值给常量f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数可作为一个参数传入到方法中，而方法不行。</p>
<p>在 Scala 中无法直接操作方法，如果要操作方法，必须先将其转换成函数。在方法名称 m 后面紧跟一个空格和下划线告诉编译器将方法m转换成函数，而不是要调用这个方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f1 = m _</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h2><p>Scala 方法声明格式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionName</span> </span>([参数列表]) : [<span class="keyword">return</span> <span class="class"><span class="keyword">type</span>]</span></span><br></pre></td></tr></table></figure>

<p>如果你不写等于号和方法主体，那么方法会被隐式声明为<strong>抽象(abstract)方法</strong>，包含它的类型于是也应该是一个抽象类。</p>
<hr>
<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>方法定义由一个 <strong>def</strong> 关键字开始，紧接着是可选的参数列表，一个冒号 <strong>:</strong> 和方法的返回类型，一个等于号 <strong>=</strong> ，最后是方法的主体。</p>
<p>Scala 方法定义格式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionName</span> </span>([参数列表]) : [<span class="keyword">return</span> <span class="class"><span class="keyword">type</span>] </span>= &#123;</span><br><span class="line">    function body</span><br><span class="line">    <span class="keyword">return</span> [expr]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中 <strong>return type</strong> 可以是任意合法的 Scala 数据类型。参数列表中的参数可以使用逗号分隔。</p>
<p>如果方法没有返回值，可以返回为 <strong>Unit</strong>，这个类似于 Java 的 <strong>void</strong>, 实例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMe</span></span>( ) : <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello, Scala!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>Scala 提供了多种不同的方法调用方式：</p>
<p>以下是调用方法的标准格式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionName( 参数列表 )</span><br></pre></td></tr></table></figure>

<p>如果方法使用了实例的对象来调用，我们可以使用类似java的格式 (使用 <strong>.</strong> 号)：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[instance.]functionName( 参数列表 )</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="函数至简原则"><a href="#函数至简原则" class="headerlink" title="函数至简原则"></a>函数至简原则</h2><p>函数至简原则：能省则省</p>
<ol>
<li> <code>return</code> 关键字可以省略，Scala 会使用函数体的最后一行代码作为返回值</li>
<li> 返回值类型如果能够推断出来，那么可以省略</li>
<li> 如果函数体只有一行代码，可以省略花括号</li>
<li> 如果函数无参，则可以省略小括号。若定义函数时省略小括号，则调用该函数时，也需省略小括号；若定时函数时未省略，则调用时，可省可不省。</li>
<li> 如果函数显式声明返回值为 <code>Unit</code>，那么即使在函数体中使用 <code>return</code> 关键字也不会起作用</li>
<li> Scala 如果想要自动推断无返回值，可以省略等号</li>
<li> 如果不关心名称，只关系逻辑处理，那么函数名（def）可以省略</li>
<li> 如果函数明确使用return关键字，那么函数返回就不能使用自行推断了，需要声明返回值类型</li>
</ol>
<hr>
<h1 id="函数传名调用-call-by-name"><a href="#函数传名调用-call-by-name" class="headerlink" title="函数传名调用(call-by-name)"></a>函数传名调用(call-by-name)</h1><p>Scala 的解释器在解析函数参数<code>(function arguments)</code>时有两种方式：</p>
<ul>
<li>  <strong>传值调用（call-by-value）</strong>：先计算参数表达式的值，再应用到函数内部；</li>
<li>  <strong>传名调用（call-by-name）</strong>：将未计算的参数表达式直接应用到函数内部</li>
</ul>
<p>在进入函数内部前，传值调用方式就已经将参数表达式的值计算完毕，而传名调用是在函数内部进行参数表达式的值计算的。</p>
<p>这就造成了一种现象，每次使用传名调用时，解释器都会计算一次表达式的值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        delayed(time());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">time</span></span>() = &#123;</span><br><span class="line">        println(<span class="string">&quot;获取时间，单位为纳秒&quot;</span>)</span><br><span class="line">        <span class="type">System</span>.nanoTime</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delayed</span></span>( t: =&gt; <span class="type">Long</span> ) = &#123;</span><br><span class="line">        println(<span class="string">&quot;在 delayed 方法内&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;参数： &quot;</span> + t)</span><br><span class="line">        t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例中我们声明了 <code>delayed</code> 方法， 该方法在参数列表中使用 <code>变量名和变量类型使用 =&gt; 符号</code> 来设置传名调用。执行以上代码，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 delayed 方法内</span><br><span class="line">获取时间，单位为纳秒</span><br><span class="line">参数： 1283416055823200</span><br><span class="line">获取时间，单位为纳秒</span><br></pre></td></tr></table></figure>

<p>实例中 <code>delay</code> 方法打印了一条信息表示进入了该方法，接着 <code>delay</code> 方法打印接收到的值，最后再返回 <code>t</code>。</p>
<hr>
<h1 id="指定函数参数名"><a href="#指定函数参数名" class="headerlink" title="指定函数参数名"></a>指定函数参数名</h1><p>一般情况下函数调用参数，就按照函数定义时的参数顺序一个个传递。但是我们也可以通过指定函数参数名，并且不需要按照顺序向函数传递参数，实例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        printInt(b=<span class="number">5</span>, a=<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printInt</span></span>( a:<span class="type">Int</span>, b:<span class="type">Int</span> ) = &#123;</span><br><span class="line">        println(<span class="string">&quot;Value of a : &quot;</span> + a );</span><br><span class="line">        println(<span class="string">&quot;Value of b : &quot;</span> + b );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Value</span> of a :  <span class="number">7</span></span><br><span class="line"><span class="type">Value</span> of b :  <span class="number">5</span></span><br></pre></td></tr></table></figure>





<h1 id="函数-可变参数"><a href="#函数-可变参数" class="headerlink" title="函数 - 可变参数"></a>函数 - 可变参数</h1><p>Scala 允许你指明函数的最后一个参数可以是重复的，即我们不需要指定函数参数的个数，可以向函数传入可变长度参数列表。</p>
<p>Scala 通过在参数的类型之后放一个星号来设置可变参数(可重复的参数)。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        printStrings(<span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Scala&quot;</span>, <span class="string">&quot;Python&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">printStrings</span></span>( args:<span class="type">String</span>* ) = &#123;</span><br><span class="line">      <span class="keyword">var</span> i : <span class="type">Int</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>( arg &lt;- args )&#123;</span><br><span class="line">         println(<span class="string">&quot;Arg value[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + arg );</span><br><span class="line">         i = i + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arg value[0] = Runoob</span><br><span class="line">Arg value[1] = Scala</span><br><span class="line">Arg value[2] = Python</span><br></pre></td></tr></table></figure>





<h1 id="函数-默认参数值"><a href="#函数-默认参数值" class="headerlink" title="函数 - 默认参数值"></a>函数 - 默认参数值</h1><p>Scala 可以为函数参数指定默认参数值，使用了默认参数，你在调用函数的过程中可以不需要传递参数，这时函数就会调用它的默认参数值，如果传递了参数，则传递值会取代默认值。实例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        println( <span class="string">&quot;返回值 : &quot;</span> + addInt() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">addInt</span></span>( a:<span class="type">Int</span>=<span class="number">5</span>, b:<span class="type">Int</span>=<span class="number">7</span> ) : <span class="type">Int</span> = &#123;</span><br><span class="line">      <span class="keyword">var</span> sum:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">      sum = a + b</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> sum</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scalac Test.scala</span><br><span class="line">$ scala Test</span><br><span class="line">返回值 : 12</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>Scala 中定义匿名函数的语法很简单，箭头左边是参数列表，右边是函数体。</p>
<p>使用匿名函数后，我们的代码变得更简洁了。</p>
<p>下面的表达式就定义了一个接受一个 Int 类型输入参数的匿名函数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inc = (x:<span class="type">Int</span>) =&gt; x+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上述定义的匿名函数，其实是下面这种写法的简写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span> </span>= <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x:<span class="type">Int</span>):<span class="type">Int</span> = x+<span class="number">1</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>以上实例的 inc 现在可作为一个函数，使用方式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = inc(<span class="number">7</span>)<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>同样我们可以在匿名函数中定义多个参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mul = (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x*y</span><br></pre></td></tr></table></figure>

<p>mul 现在可作为一个函数，使用方式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(mul(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>我们也可以不给匿名函数设置参数，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userDir = () =&gt; &#123; <span class="type">System</span>.getProperty(<span class="string">&quot;user.dir&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>userDir 现在可作为一个函数，使用方式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println( userDir() )</span><br></pre></td></tr></table></figure>



<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        println( <span class="string">&quot;multiplier(1) value = &quot;</span> +  multiplier(<span class="number">1</span>) )</span><br><span class="line">        println( <span class="string">&quot;multiplier(2) value = &quot;</span> +  multiplier(<span class="number">2</span>) )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> factor = <span class="number">3</span></span><br><span class="line">    <span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiplier(1) value = 3</span><br><span class="line">multiplier(2) value = 6</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="函数柯里化-Currying"><a href="#函数柯里化-Currying" class="headerlink" title="函数柯里化(Currying)"></a>函数柯里化(Currying)</h1><p>柯里化<code>(Currying)</code>指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>首先我们定义一个函数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>)=x+y</span><br></pre></td></tr></table></figure>

<p>那么我们应用的时候，应该是这样用：add(1,2)</p>
<p>现在我们把这个函数变一下形：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span>)(y:<span class="type">Int</span>) = x + y</span><br></pre></td></tr></table></figure>

<p>那么我们应用的时候，应该是这样用：add(1)(2),最后结果都一样是3，这种方式（过程）就叫柯里化。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>add(1)(2) 实际上是依次调用两个普通函数（非柯里化函数），第一次调用使用一个参数 x，返回一个函数类型的值，第二次使用参数y调用这个函数类型的值。</p>
<p>实质上最先演变成这样一个方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x:<span class="type">Int</span>)=(y:<span class="type">Int</span>)=&gt;x+y</span><br></pre></td></tr></table></figure>

<p>那么这个函数是什么意思呢？ 接收一个x为参数，返回一个匿名函数，该匿名函数的定义是：接收一个Int型参数y，函数体为x+y。现在我们来对这个方法进行调用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = add(<span class="number">1</span>) </span><br></pre></td></tr></table></figure>

<p>返回一个result，那result的值应该是一个匿名函数：(y:Int)=&gt;1+y</p>
<p>所以为了得到结果，我们继续调用result。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = result(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>最后打印出来的结果就是3。</p>
<h3 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h3><p>下面是一个完整实例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      <span class="keyword">val</span> str1:<span class="type">String</span> = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line">      <span class="keyword">val</span> str2:<span class="type">String</span> = <span class="string">&quot;Scala!&quot;</span></span><br><span class="line">      println( <span class="string">&quot;str1 + str2 = &quot;</span> +  strcat(str1)(str2) )</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">strcat</span></span>(s1: <span class="type">String</span>)(s2: <span class="type">String</span>) = &#123;</span><br><span class="line">      s1 + s2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1 + str2 = <span class="type">Hello</span>, <span class="type">Scala</span>!</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>高阶函数（Higher-Order Function）就是操作其他函数的函数。</p>
<p>Scala 中允许使用高阶函数，<strong>高阶函数可以使用其他函数作为参数，或者使用函数作为输出结果</strong>。</p>
<p>以下实例中，apply() 函数使用了另外一个函数 f 和 值 v 作为参数，而函数 f 又调用了参数 v：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        println( apply( layout, <span class="number">10</span>) )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数 f 和 值 v 作为参数，而函数 f 又调用了参数 v</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">String</span>, v: <span class="type">Int</span>) = f(v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">layout</span></span>[<span class="type">A</span>](x: <span class="type">A</span>) = <span class="string">&quot;[&quot;</span> + x.toString() + <span class="string">&quot;]&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10]</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="偏应用函数（偏函数）"><a href="#偏应用函数（偏函数）" class="headerlink" title="偏应用函数（偏函数）"></a>偏应用函数（偏函数）</h1><p><strong>偏函数的本质就是定义一个新的函数，对原始函数的功能进行增强。</strong></p>
<p>偏函数是一种表达式，你不需要提供函数需要的所有参数，只需要提供部分，或不提供所需参数。</p>
<p>如下实例，我们打印日志信息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span></span><br><span class="line">        log(date, <span class="string">&quot;message1&quot;</span> )</span><br><span class="line">        <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">        log(date, <span class="string">&quot;message2&quot;</span> )</span><br><span class="line">        <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">        log(date, <span class="string">&quot;message3&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, message: <span class="type">String</span>)  = &#123;</span><br><span class="line">        println(date + <span class="string">&quot;----&quot;</span> + message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mon Dec 02 12:52:41 CST 2018----message1</span><br><span class="line">Mon Dec 02 12:52:41 CST 2018----message2</span><br><span class="line">Mon Dec 02 12:52:41 CST 2018----message3</span><br></pre></td></tr></table></figure>

<p>实例中，<code>log()</code> 方法接收两个参数：<code>date</code> 和 <code>message</code>。我们在程序执行时调用了三次，参数 <code>date</code> 值都相同，<code>message</code> 不同。</p>
<p>我们可以使用偏应用函数优化以上方法，绑定第一个 <code>date</code> 参数，第二个参数使用下划线 <code>_</code> 替换缺失的参数列表，并把这个新的函数值的索引的赋给变量。以上实例修改如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      <span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span></span><br><span class="line">      <span class="keyword">val</span> logWithDateBound = log(date, _ : <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">      logWithDateBound(<span class="string">&quot;message1&quot;</span> )</span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">      logWithDateBound(<span class="string">&quot;message2&quot;</span> )</span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">      logWithDateBound(<span class="string">&quot;message3&quot;</span> )</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(date: <span class="type">Date</span>, message: <span class="type">String</span>)  = &#123;</span><br><span class="line">     println(date + <span class="string">&quot;----&quot;</span> + message)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tue Dec 18 11:25:54 CST 2018----message1</span><br><span class="line">Tue Dec 18 11:25:54 CST 2018----message2</span><br><span class="line">Tue Dec 18 11:25:54 CST 2018----message3</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/21/SparkSQL%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/21/SparkSQL%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">SparkSQL实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-21 14:49:45" itemprop="dateCreated datePublished" datetime="2021-12-21T14:49:45+08:00">2021-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-25 17:11:25" itemprop="dateModified" datetime="2021-12-25T17:11:25+08:00">2021-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spark/" itemprop="url" rel="index"><span itemprop="name">Spark</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第-1-章-准备数据"><a href="#第-1-章-准备数据" class="headerlink" title="第 1 章    准备数据"></a>第 1 章    准备数据</h1><ul>
<li>  我们这次 <code>SparkSQL</code> 操作中所有的数据均来自 <code>Hive</code>。</li>
<li>  首先在 <code>Hive</code> 中创建表，并导入数据。</li>
<li>  一共有 3 张表：1 张用户行为表，1 张城市表，1 张产品表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 用户行为表</span><br><span class="line">CREATE TABLE `user_visit_action`(</span><br><span class="line">  `date` string,</span><br><span class="line">  `user_id` bigint,</span><br><span class="line">  `session_id` string,</span><br><span class="line">  `page_id` bigint,</span><br><span class="line">  `action_time` string,</span><br><span class="line">  `search_keyword` string,</span><br><span class="line">  `click_category_id` bigint,</span><br><span class="line">  `click_product_id` bigint,</span><br><span class="line">  `order_category_ids` string,</span><br><span class="line">  `order_product_ids` string,</span><br><span class="line">  `pay_category_ids` string,</span><br><span class="line">  `pay_product_ids` string,</span><br><span class="line">  `city_id` bigint)</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;;</span><br><span class="line">load data local inpath &#x27;/opt/module/datas/user_visit_action.txt&#x27; into table sparkpractice.user_visit_action;</span><br><span class="line"></span><br><span class="line"># 产品表</span><br><span class="line">CREATE TABLE `product_info`(</span><br><span class="line">  `product_id` bigint,</span><br><span class="line">  `product_name` string,</span><br><span class="line">  `extend_info` string)</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;;</span><br><span class="line">load data local inpath &#x27;/opt/module/datas/product_info.txt&#x27; into table sparkpractice.product_info;</span><br><span class="line"></span><br><span class="line"># 城市表</span><br><span class="line">CREATE TABLE `city_info`(</span><br><span class="line">  `city_id` bigint,</span><br><span class="line">  `city_name` string,</span><br><span class="line">  `area` string)</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;;</span><br><span class="line">load data local inpath &#x27;/opt/module/datas/city_info.txt&#x27; into table sparkpractice.city_info;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="第-2-章-需求"><a href="#第-2-章-需求" class="headerlink" title="第 2 章    需求"></a>第 2 章    需求</h1><h2 id="2-1-需求简介"><a href="#2-1-需求简介" class="headerlink" title="2.1    需求简介"></a>2.1    需求简介</h2><p>各区域热门商品 Top3</p>
<p>这里的热门商品是从点击量的维度来看的</p>
<p>计算各个区域前三大热门商品，并备注上每个商品在主要城市中的分布比例，超过两个城市用其它显示。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">地区	商品名称		点击次数	城市备注</span><br><span class="line">华北	商品A		100000	北京21.2%，天津13.2%，其它65.6%</span><br><span class="line">华北	商品P		80200	北京63.0%，太原10%，其它27.0%</span><br><span class="line">华北	商品M		40000	北京63.0%，太原10%，其它27.0%</span><br><span class="line">东北	商品J		92000	大连28%，辽宁17.0%，其它 55.0%</span><br></pre></td></tr></table></figure>

<h2 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2    思路分析"></a>2.2    思路分析</h2><p>使用 <code>SQL</code> 来完成。碰到复杂的需求，可以使用 <code>UDF</code> 或 <code>UDAF</code>。</p>
<ol>
<li>   查询出来所有的点击记录，并与 <code>city_info</code> 表连接，得到每个城市所在的地区，与 <code>Product_info</code> 表连接得到产品名称。</li>
<li>   按照地区和商品 <code>id</code> 分组，统计出每个商品在每个地区的总点击次数</li>
<li>   每个地区内按照点击次数降序排列</li>
<li>   只取前三名，并把结果保存在数据库中</li>
<li>   城市备注需要自定义 <code>UDAF</code> 函数</li>
</ol>
<hr>
<h1 id="第-3-章-具体业务实现"><a href="#第-3-章-具体业务实现" class="headerlink" title="第 3 章    具体业务实现"></a>第 3 章    具体业务实现</h1><h2 id="3-1-UDAF-函数定义"><a href="#3-1-UDAF-函数定义" class="headerlink" title="3.1    UDAF 函数定义"></a>3.1    <code>UDAF</code> 函数定义</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.sparkoffline.udf</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.<span class="type">DecimalFormat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.&#123;<span class="type">MutableAggregationBuffer</span>, <span class="type">UserDefinedAggregateFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AreaClickUDAF</span> <span class="keyword">extends</span> <span class="title">UserDefinedAggregateFunction</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据的类型:  北京  String</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">inputSchema</span></span>: <span class="type">StructType</span> = &#123;</span><br><span class="line">        <span class="type">StructType</span>(<span class="type">StructField</span>(<span class="string">&quot;city_name&quot;</span>, <span class="type">StringType</span>) :: <span class="type">Nil</span>)</span><br><span class="line">        <span class="comment">//        StructType(Array(StructField(&quot;city_name&quot;, StringType)))</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存的数据的类型: 北京-&gt;1000, 天津-&gt;5000  Map,  总的点击量  1000/?</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferSchema</span></span>: <span class="type">StructType</span> = &#123;</span><br><span class="line">        <span class="comment">// MapType(StringType, LongType) 还需要标注 map的key的类型和value的类型</span></span><br><span class="line">        <span class="type">StructType</span>(<span class="type">StructField</span>(<span class="string">&quot;city_count&quot;</span>, <span class="type">MapType</span>(<span class="type">StringType</span>, <span class="type">LongType</span>)) :: <span class="type">StructField</span>(<span class="string">&quot;total_count&quot;</span>, <span class="type">LongType</span>) :: <span class="type">Nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出的数据类型  &quot;北京21.2%，天津13.2%，其它65.6%&quot;  String</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dataType</span></span>: <span class="type">DataType</span> = <span class="type">StringType</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相同的输入是否应用有相同的输出.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">deterministic</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给存储数据初始化</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">//初始化map缓存</span></span><br><span class="line">        buffer(<span class="number">0</span>) = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]()</span><br><span class="line">        <span class="comment">// 初始化总的点击量</span></span><br><span class="line">        buffer(<span class="number">1</span>) = <span class="number">0</span>L</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分区内合并 Map[城市名, 点击量]</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>, input: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 首先拿到城市名, 然后把成名作为key去查看map中是否存在, 如果存在就把对应的值 +1, 如果不存在, 则直径0+1</span></span><br><span class="line">        <span class="keyword">val</span> cityName = input.getString(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">//        val map: collection.Map[String, Long] = buffer.getMap[String, Long](0)</span></span><br><span class="line">        <span class="keyword">val</span> map: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = buffer.getAs[<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]](<span class="number">0</span>)</span><br><span class="line">        buffer(<span class="number">0</span>) = map + (cityName -&gt; (map.getOrElse(cityName, <span class="number">0</span>L) + <span class="number">1</span>L))</span><br><span class="line">        <span class="comment">// 碰到一个城市, 则总的点击量要+1</span></span><br><span class="line">        buffer(<span class="number">1</span>) = buffer.getLong(<span class="number">1</span>) + <span class="number">1</span>L</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分区间的合并</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(buffer1: <span class="type">MutableAggregationBuffer</span>, buffer2: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> map1 = buffer1.getAs[<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]](<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> map2 = buffer2.getAs[<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]](<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把map1的键值对与map2中的累积, 最后赋值给buffer1</span></span><br><span class="line">        buffer1(<span class="number">0</span>) = map1.foldLeft(map2) &#123;</span><br><span class="line">            <span class="keyword">case</span> (map, (k, v)) =&gt;</span><br><span class="line">                map + (k -&gt; (map.getOrElse(k, <span class="number">0</span>L) + v))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buffer1(<span class="number">1</span>) = buffer1.getLong(<span class="number">1</span>) + buffer2.getLong(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终的输出. &quot;北京21.2%，天津13.2%，其它65.6%&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(buffer: <span class="type">Row</span>): <span class="type">Any</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> cityCountMap = buffer.getAs[<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]](<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> totalCount = buffer.getLong(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> citysRatio: <span class="type">List</span>[<span class="type">CityRemark</span>] = cityCountMap.toList.sortBy(-_._2).take(<span class="number">2</span>).map &#123;</span><br><span class="line">            <span class="keyword">case</span> (cityName, count) =&gt; &#123;</span><br><span class="line">                <span class="type">CityRemark</span>(cityName, count.toDouble / totalCount)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果城市的个数超过2才显示其它</span></span><br><span class="line">        <span class="keyword">if</span> (cityCountMap.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            citysRatio = citysRatio :+ <span class="type">CityRemark</span>(<span class="string">&quot;其它&quot;</span>, citysRatio.foldLeft(<span class="number">1</span>D)(_ - _.cityRatio))</span><br><span class="line">        &#125;</span><br><span class="line">        citysRatio.mkString(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CityRemark</span>(<span class="params">cityName: <span class="type">String</span>, cityRatio: <span class="type">Double</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> formatter = <span class="keyword">new</span> <span class="type">DecimalFormat</span>(<span class="string">&quot;0.00%&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">s&quot;<span class="subst">$cityName</span>:<span class="subst">$&#123;formatter.format(cityRatio)&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2    具体实现"></a>3.2    具体实现</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.practice.app.udf.<span class="type">AreaClickUDAF</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Author lzc</span></span><br><span class="line"><span class="comment">  * Date 2019/8/9 4:47 PM</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AreaClickApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark: <span class="type">SparkSession</span> = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">&quot;local[2]&quot;</span>)</span><br><span class="line">            .appName(<span class="string">&quot;AreaClickApp&quot;</span>)</span><br><span class="line">            .enableHiveSupport()</span><br><span class="line">            .getOrCreate()</span><br><span class="line">        spark.sql(<span class="string">&quot;use sparkpractice&quot;</span>)</span><br><span class="line">        <span class="comment">// 0 注册自定义聚合函数</span></span><br><span class="line">        spark.udf.register(<span class="string">&quot;city_remark&quot;</span>, <span class="keyword">new</span> <span class="type">AreaClickUDAF</span>)</span><br><span class="line">        <span class="comment">// 1. 查询出所有的点击记录,并和城市表产品表做内连接</span></span><br><span class="line">        spark.sql(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              |select</span></span><br><span class="line"><span class="string">              |    c.*,</span></span><br><span class="line"><span class="string">              |    v.click_product_id,</span></span><br><span class="line"><span class="string">              |    p.product_name</span></span><br><span class="line"><span class="string">              |from user_visit_action v join city_info c join product_info p on v.city_id=c.city_id and v.click_product_id=p.product_id</span></span><br><span class="line"><span class="string">              |where click_product_id&gt;-1</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.stripMargin).createOrReplaceTempView(<span class="string">&quot;t1&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 计算每个区域, 每个产品的点击量</span></span><br><span class="line">        spark.sql(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              |select</span></span><br><span class="line"><span class="string">              |    t1.area,</span></span><br><span class="line"><span class="string">              |    t1.product_name,</span></span><br><span class="line"><span class="string">              |    count(*) click_count,</span></span><br><span class="line"><span class="string">              |    city_remark(t1.city_name)</span></span><br><span class="line"><span class="string">              |from t1</span></span><br><span class="line"><span class="string">              |group by t1.area, t1.product_name</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.stripMargin).createOrReplaceTempView(<span class="string">&quot;t2&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 对每个区域内产品的点击量进行倒序排列</span></span><br><span class="line">        spark.sql(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              |select</span></span><br><span class="line"><span class="string">              |    *,</span></span><br><span class="line"><span class="string">              |    rank() over(partition by t2.area order by t2.click_count desc) rank</span></span><br><span class="line"><span class="string">              |from t2</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.stripMargin).createOrReplaceTempView(<span class="string">&quot;t3&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 每个区域取top3</span></span><br><span class="line">        </span><br><span class="line">        spark.sql(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              |select</span></span><br><span class="line"><span class="string">              |    *</span></span><br><span class="line"><span class="string">              |from t3</span></span><br><span class="line"><span class="string">              |where rank&lt;=3</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.stripMargin).show</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/20/Hive%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/20/Hive%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">Hive（下）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-20 21:10:26" itemprop="dateCreated datePublished" datetime="2021-12-20T21:10:26+08:00">2021-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-22 09:38:28" itemprop="dateModified" datetime="2021-12-22T09:38:28+08:00">2021-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hive/" itemprop="url" rel="index"><span itemprop="name">Hive</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第-7-章-函数"><a href="#第-7-章-函数" class="headerlink" title="第 7 章    函数"></a>第 7 章    函数</h1><h2 id="7-1-函数分类"><a href="#7-1-函数分类" class="headerlink" title="7.1    函数分类"></a>7.1    函数分类</h2><p>在 Hive 中，按照函数的来源可以将函数分为两类：</p>
<ol>
<li> 系统函数</li>
<li> 自定义函数</li>
</ol>
<h3 id="系统函数："><a href="#系统函数：" class="headerlink" title="系统函数："></a>系统函数：</h3><h3 id="用户自定义函数："><a href="#用户自定义函数：" class="headerlink" title="用户自定义函数："></a>用户自定义函数：</h3><ol>
<li><p>遵守 hive 函数接口的要求，自定义一个函数类；</p>
</li>
<li><p>将函数类打成jar包，保存在 Hive 的 lib 目录下，或者保存在 <code>HIVE_HOME/auxlib</code> 目录下</p>
<ul>
<li>auxlib 目录是用来存放 hive 可以加载的第三方 jar 包的目录</li>
<li>Hive 在启动时会加载该目录下的 jar 包，提供额外的第三方功能</li>
</ul>
</li>
<li><p>创建一个函数，让这个函数和 jar 中的函数类关联</p>
</li>
<li><p>使用函数</p>
</li>
</ol>
<p>因为在 Hive 中可以实现自定义的函数，所以函数有库的概念，当然系统提供的函数可以在任意库下使用。</p>
<h2 id="7-1-查看函数"><a href="#7-1-查看函数" class="headerlink" title="7.1    查看函数"></a>7.1    查看函数</h2><ol>
<li><p>查看当前库中的所有函数</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show functions;</span><br></pre></td></tr></table></figure></li>
<li><p>查看函数的用法</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; desc function upper;</span><br></pre></td></tr></table></figure></li>
<li><p>查看函数的用法（详情）</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; desc function extended upper;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="常用日期函数"><a href="#常用日期函数" class="headerlink" title="常用日期函数"></a>常用日期函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	hive默认解析的时间格式必须是： 2019-11-24 08:09:10</span><br><span class="line">unix_timestamp:返回当前或指定时间的时间戳（日期=&gt;时间戳）</span><br><span class="line">from_unixtime：将时间戳转为日期格式（时间戳=&gt;日期）</span><br><span class="line">current_date：当前日期</span><br><span class="line">current_timestamp：当前的日期加时间</span><br><span class="line">* to_date：抽取日期部分</span><br><span class="line">year：获取年</span><br><span class="line">month：获取月</span><br><span class="line">day：获取日</span><br><span class="line">hour：获取时</span><br><span class="line">minute：获取分</span><br><span class="line">second：获取秒</span><br><span class="line">weekofyear：当前时间是一年中的第几周</span><br><span class="line">dayofmonth：当前时间是一个月中的第几天</span><br><span class="line">* months_between： 两个日期间的月份，前-后</span><br><span class="line">* add_months：日期加减月</span><br><span class="line">* datediff：两个日期相差的天数，前-后</span><br><span class="line">* date_add：日期加天数</span><br><span class="line">* date_sub：日期减天数</span><br><span class="line">* last_day：日期的当月的最后一天</span><br><span class="line"></span><br><span class="line">date_format格式化日期   date_format( 2019-11-24 08:09:10,&#x27;yyyy-MM&#x27;) mn</span><br></pre></td></tr></table></figure>



<h3 id="常用取整函数"><a href="#常用取整函数" class="headerlink" title="常用取整函数"></a>常用取整函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round： 四舍五入</span><br><span class="line">ceil：  向上取整</span><br><span class="line">floor： 向下取整</span><br></pre></td></tr></table></figure>



<h3 id="常用字符串操作函数"><a href="#常用字符串操作函数" class="headerlink" title="常用字符串操作函数"></a>常用字符串操作函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upper： 转大写</span><br><span class="line">lower： 转小写</span><br><span class="line">length： 长度</span><br><span class="line">* trim：  前后去空格</span><br><span class="line">lpad： 向左补齐，到指定长度</span><br><span class="line">rpad：  向右补齐，到指定长度</span><br><span class="line">* regexp_replace： SELECT regexp_replace(&#x27;100-200&#x27;, &#x27;(\d+)&#x27;, &#x27;num&#x27;)=&#x27;num-num</span><br><span class="line">	使用正则表达式匹配目标字符串，匹配成功后替换！</span><br></pre></td></tr></table></figure>



<h3 id="常用集合操作"><a href="#常用集合操作" class="headerlink" title="常用集合操作"></a>常用集合操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size： 集合（map和list）中元素的个数</span><br><span class="line">map_keys： 返回map中的key</span><br><span class="line">map_values: 返回map中的value</span><br><span class="line">* array_contains: 判断array中是否包含某个元素</span><br><span class="line">sort_array： 将array中的元素排序</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><h3 id="NVL"><a href="#NVL" class="headerlink" title="NVL"></a>NVL</h3><ol>
<li> 语法： <code>NVL( str1, replace_with)</code></li>
<li> 说明：判断 <code>str1</code> 是否为 <code>NULL</code>，如果不为 <code>NULL</code> 则 返回原值，如果为 <code>NULL</code> 则返回 <code>replace_with</code> 的值。</li>
<li>使用场景：<ul>
<li>  ① 将 <code>NULL</code> 值替换为默认值</li>
<li>  ② 在使用一些统计函数时，如果统计函数会忽略 <code>NULL</code> 值，则使用该函数对 <code>NULL</code> 进行替换。（对于一些统计函数，例如 <code>avg()</code>，如果某一行的值为 <code>NULL</code>，在统计平均值时就会忽略该行，导致总行数减少，统计到的值自然也是不准确的。为了解决这个问题，一般会用 0 值代替 <code>NULL</code>）</li>
</ul>
</li>
</ol>
<p><strong>Demo</strong></p>
<p>数据准备：采用员工表</p>
<p><code>emp.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">7369	SMITH	CLERK	7902	1980-12-17	800.00		20</span><br><span class="line">7499	ALLEN	SALESMAN	7698	1981-2-20	1600.00	300.00	30</span><br><span class="line">7521	WARD	SALESMAN	7698	1981-2-22	1250.00	500.00	30</span><br><span class="line">7566	JONES	MANAGER	7839	1981-4-2	2975.00		20</span><br><span class="line">7654	MARTIN	SALESMAN	7698	1981-9-28	1250.00	1400.00	30</span><br><span class="line">7698	BLAKE	MANAGER	7839	1981-5-1	2850.00		30</span><br><span class="line">7782	CLARK	MANAGER	7839	1981-6-9	2450.00		10</span><br><span class="line">7788	SCOTT	ANALYST	7566	1987-4-19	3000.00		20</span><br><span class="line">7839	KING	PRESIDENT		1981-11-17	5000.00		10</span><br><span class="line">7844	TURNER	SALESMAN	7698	1981-9-8	1500.00	0.00	30</span><br><span class="line">7876	ADAMS	CLERK	7788	1987-5-23	1100.00		20</span><br><span class="line">7900	JAMES	CLERK	7698	1981-12-3	950.00		30</span><br><span class="line">7902	FORD	ANALYST	7566	1981-12-3	3000.00		20</span><br><span class="line">7934	MILLER	CLERK	7782	1982-1-23	1300.00		10</span><br></pre></td></tr></table></figure>





<ol>
<li><p>查询：如果员工的 <code>comm</code> 为 NULL，则用 <code>-1</code> 代替</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select nvl(comm,-1) from emp;</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">20.0</span><br><span class="line">300.0</span><br><span class="line">500.0</span><br><span class="line">-1.0</span><br><span class="line">1400.0</span><br><span class="line">-1.0</span><br><span class="line">-1.0</span><br><span class="line">-1.0</span><br><span class="line">-1.0</span><br><span class="line">0.0</span><br><span class="line">-1.0</span><br><span class="line">-1.0</span><br><span class="line">-1.0</span><br><span class="line">-1.0</span><br></pre></td></tr></table></figure>

</li>
<li><p>查询：如果员工的 <code>comm</code> 为 <code>NULL</code>，则用领导 <code>id</code> 代替</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select nvl(comm,mgr) from emp;</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">20.0</span><br><span class="line">300.0</span><br><span class="line">500.0</span><br><span class="line">7839.0</span><br><span class="line">1400.0</span><br><span class="line">7839.0</span><br><span class="line">7839.0</span><br><span class="line">7566.0</span><br><span class="line">NULL</span><br><span class="line">0.0</span><br><span class="line">7788.0</span><br><span class="line">7698.0</span><br><span class="line">7566.0</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><ol>
<li> 语法： <code>concat(str1, str2, ... strN)</code></li>
<li> 说明：字符串拼接。</li>
<li> 注意事项：一旦参数中存在一个字符串为 NULL，则返回 NULL</li>
</ol>
<hr>
<h3 id="concat-ws"><a href="#concat-ws" class="headerlink" title="concat_ws"></a>concat_ws</h3><ol>
<li><p> 语法：<code>concat_ws(separator, [string | array(string)]+)</code></p>
</li>
<li><p> 说明：拼接字符串或者字符串数组，并以指定的分隔符分隔。</p>
</li>
<li><p>Demo：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT concat_ws(&#x27;.&#x27;, &#x27;www&#x27;, array(&#x27;facebook&#x27;, &#x27;com&#x27;)) FROM src LIMIT 1;</span><br><span class="line"></span><br><span class="line">&#x27;www.facebook.com&#x27;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h3><h4 id="CASE…WHEN"><a href="#CASE…WHEN" class="headerlink" title="CASE…WHEN"></a>CASE…WHEN</h4><ol>
<li><p>语法：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CASE 列名 </span><br><span class="line">	WHEN value1 THEN value2</span><br><span class="line">	WHEN value3 THEN value4</span><br><span class="line">	...</span><br><span class="line">	else valueN</span><br><span class="line">	end</span><br><span class="line">	;</span><br><span class="line"># 说明：</span><br><span class="line">#	1、对于该列的字段来说，如果 字段=value1，就返回 value2；</span><br><span class="line">#	如果 字段=value3，就返回 value4；可以有多个；</span><br><span class="line">#	2、如果找不到对应值，则返回 valueN</span><br><span class="line">#	3、最后以 end 结尾</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="if-函数"><a href="#if-函数" class="headerlink" title="if 函数"></a>if 函数</h4><ol>
<li><p>语法：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(判断表达式, value1, value2        )</span><br><span class="line"></span><br><span class="line"># 说明：</span><br><span class="line">#	表达式返回一个 Boolean 值，如果该值为 true，则返回 value1，否则返回 value2</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p><strong>一、数据准备</strong></p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">dept_id</th>
<th align="center">sex</th>
</tr>
</thead>
<tbody><tr>
<td align="center">悟空</td>
<td align="center">A</td>
<td align="center">男</td>
</tr>
<tr>
<td align="center">大海</td>
<td align="center">A</td>
<td align="center">男</td>
</tr>
<tr>
<td align="center">宋宋</td>
<td align="center">B</td>
<td align="center">男</td>
</tr>
<tr>
<td align="center">凤姐</td>
<td align="center">A</td>
<td align="center">女</td>
</tr>
<tr>
<td align="center">婷姐</td>
<td align="center">B</td>
<td align="center">女</td>
</tr>
<tr>
<td align="center">婷婷</td>
<td align="center">B</td>
<td align="center">女</td>
</tr>
</tbody></table>
<p><strong>二、需求：</strong></p>
<p>求出各个部门的男女各有多少人。结果应该如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 部门	男生人数	女生人数</span><br><span class="line">A	2	1</span><br><span class="line">B	1	2</span><br></pre></td></tr></table></figure>





<p>三、创建本地 <code>emp_sex.txt</code>，导入数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 datas]$ vim emp_sex.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">悟空	A	男</span><br><span class="line">大海	A	男</span><br><span class="line">宋宋	B	男</span><br><span class="line">凤姐	A	女</span><br><span class="line">婷姐	B	女</span><br><span class="line">婷婷	B	女</span><br></pre></td></tr></table></figure>







<p><strong>四、创建 <code>hive</code> 表并导入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1、创建 Hive 表</span><br><span class="line">create table emp_sex</span><br><span class="line">	(</span><br><span class="line">        name string, </span><br><span class="line">        dept_id string, </span><br><span class="line">        sex string</span><br><span class="line">    ) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line"># 2、导入数据</span><br><span class="line">load data local inpath &#x27;/opt/module/datas/emp_sex.txt&#x27; into table emp_sex;</span><br></pre></td></tr></table></figure>





<p><strong>五、按需求查询数据</strong></p>
<ul>
<li>  分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 部门	男生人数	女生人数</span><br><span class="line">A	2	1</span><br><span class="line">B	1	2</span><br><span class="line"></span><br><span class="line">select * from emp_sex</span><br><span class="line">group by dept_id;</span><br><span class="line"></span><br><span class="line">要得到每个部门的男生和女生人数，需要按照部门将所有员工划分成两部分</span><br><span class="line">        悟空	A	男</span><br><span class="line">        大海	A	男</span><br><span class="line">        凤姐	A	女</span><br><span class="line"></span><br><span class="line">        宋宋	B	男</span><br><span class="line">        婷姐	B	女</span><br><span class="line">        婷婷	B	女</span><br><span class="line"></span><br><span class="line">在分组前，要分别得到男生人数和女生人数，可以通过两个子查询来实现</span><br><span class="line"># 得到男生的人数</span><br><span class="line">select count(*) as male_count, dept_id from emp_sex</span><br><span class="line">where sex=&quot;男&quot;</span><br><span class="line">group by dept_id;</span><br><span class="line"></span><br><span class="line"># 得到女生的人数</span><br><span class="line">select count(*) as female_count, dept_id from emp_sex</span><br><span class="line">where sex=&quot;女&quot;</span><br><span class="line">group by dept_id;</span><br><span class="line"></span><br><span class="line"># 将上面两个结果拼接起来</span><br><span class="line">select t1.dept_id, male_count, female_count</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    select count(*) as male_count, dept_id from emp_sex</span><br><span class="line">	where sex=&quot;男&quot;</span><br><span class="line">	group by dept_id</span><br><span class="line">) t1,</span><br><span class="line">(</span><br><span class="line">    select count(*) as female_count, dept_id from emp_sex</span><br><span class="line">    where sex=&quot;女&quot;</span><br><span class="line">    group by dept_id</span><br><span class="line">) t2</span><br><span class="line">where t1.dept_id = t2.dept_id</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<p><strong>优化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">  dept_id,</span><br><span class="line">  sum(case sex when &#x27;男&#x27; then 1 else 0 end) male_count,</span><br><span class="line">  sum(case sex when &#x27;女&#x27; then 1 else 0 end) female_count</span><br><span class="line">from </span><br><span class="line">  emp_sex</span><br><span class="line">group by</span><br><span class="line">  dept_id;</span><br><span class="line">  </span><br><span class="line"># sum 函数是在 group by 之后执行</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="6-7-2-行转列"><a href="#6-7-2-行转列" class="headerlink" title="6.7.2    行转列"></a>6.7.2    行转列</h3><p><strong>行转列：</strong> <code>一列N行 ==&gt; 一列一行</code></p>
<p><strong>一、相关函数说明</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(string A/col, string B/col...)</span><br></pre></td></tr></table></figure>

<ul>
<li>  返回输入字符串拼接后的结果，支持任意个输入字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCAT_WS(separator, str1, str2,...)</span><br></pre></td></tr></table></figure>

<ul>
<li>  它是一个特殊形式的 <code>CONCAT()</code>。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLLECT_SET(col)</span><br><span class="line"># 返回一个去重的 Set 集合</span><br><span class="line"># col 列名</span><br><span class="line"># 作用：将此列的所有记录封装到一个 Set 集合中</span><br></pre></td></tr></table></figure>

<ul>
<li>  函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生 <code>array</code> 类型字段。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLLECT_LIST(col)</span><br><span class="line"># 返回一个 List 集合，允许重复</span><br><span class="line"># col 列名</span><br><span class="line"># 作用：将此列的所有记录封装到一个 List 集合中</span><br></pre></td></tr></table></figure>





<p><strong>数据准备</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>constellation</th>
<th>blood_type</th>
</tr>
</thead>
<tbody><tr>
<td>孙悟空</td>
<td>白羊座</td>
<td>A</td>
</tr>
<tr>
<td>大海</td>
<td>射手座</td>
<td>A</td>
</tr>
<tr>
<td>宋宋</td>
<td>白羊座</td>
<td>B</td>
</tr>
<tr>
<td>猪八戒</td>
<td>白羊座</td>
<td>A</td>
</tr>
<tr>
<td>凤姐</td>
<td>射手座</td>
<td>A</td>
</tr>
</tbody></table>
<p><strong>需求</strong></p>
<p>把星座和血型一样的人归类到一起。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">射手座,A            大海|凤姐</span><br><span class="line">白羊座,A            孙悟空|猪八戒</span><br><span class="line">白羊座,B            宋宋</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 1、按照 星座 和 血型 两个条件对数据进行分组</span><br><span class="line">select concat(constellation, &quot;,&quot;, blood_type)</span><br><span class="line">from person_info</span><br><span class="line">group by constellation, blood_type;</span><br><span class="line"></span><br><span class="line"># 临时结果：得到三个分组</span><br><span class="line">射手座,A</span><br><span class="line">白羊座,A</span><br><span class="line">白羊座,B</span><br><span class="line"></span><br><span class="line"># 2、把分组内的 name 数据（可能有多条）（一列N行）封装成一列一行</span><br><span class="line">select concat(constellation, &quot;,&quot;, blood_type) as cb, CONCAT_WS(&quot;|&quot;, COLLECT_LIST(name)) as nameSet</span><br><span class="line">from person_info</span><br><span class="line">group by constellation, blood_type;</span><br><span class="line"></span><br><span class="line"># select 后面只能使用分组后的字段，及聚集函数。COLLECT_LIST()函数也是一个聚集函数</span><br></pre></td></tr></table></figure>





<ol>
<li><p>创建本地 <code>person_info.txt</code>，导入数据</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 datas]$ vim person_info.txt</span><br><span class="line"></span><br><span class="line">孙悟空	白羊座	A</span><br><span class="line">大海	射手座	A</span><br><span class="line">宋宋	白羊座	B</span><br><span class="line">猪八戒	白羊座	A</span><br><span class="line">凤姐	射手座	A</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建 <code>Hive</code> 表并导入数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建 Hive 表</span><br><span class="line">create table person_info</span><br><span class="line">(</span><br><span class="line">    name string, </span><br><span class="line">    constellation string, </span><br><span class="line">    blood_type string</span><br><span class="line">) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line"># 导入数据</span><br><span class="line">load data local inpath &quot;/opt/module/datas/person_info.txt&quot; into table person_info;</span><br></pre></td></tr></table></figure>

</li>
<li><p>按需求查询数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select concat(constellation, &quot;,&quot;, blood_type) as cb, CONCAT_WS(&quot;|&quot;, COLLECT_LIST(name)) as nameSet</span><br><span class="line">from person_info</span><br><span class="line">group by constellation, blood_type;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h3><p><strong>列转行：</strong><code>一行一列 ==&gt; 一行N列</code></p>
<p><strong>常见函数：</strong></p>
<ol>
<li><p>函数说明</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLODE(col)：</span><br><span class="line"># 作用：将 Array 类型的参数拆分为 1 列 N 行，或将 Map 类型的参数拆分成 2 列 N 行。</span><br><span class="line"># col：列名，要求参数类型只能是 Array 类型或 Map 类型</span><br><span class="line"># EXPLODE 属于 UDTF，UDTF 在使用时，不能和其它表达式一起出现在 select 子句后，即 UDTF 只能单独出现在 select 子句后。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 侧写</span><br><span class="line">LATERAL VIEW	</span><br><span class="line"></span><br><span class="line"># 用法</span><br><span class="line">LATERAL VIEW udtf(expression) tableAlias AS columnAlias</span><br><span class="line"># tableAlias 临时表名</span><br><span class="line"># columnAlias	临时列名</span><br><span class="line"></span><br><span class="line"># 解释</span><br><span class="line">用于和split, explode等UDTF一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>数据准备</p>
<table>
<thead>
<tr>
<th>movie</th>
<th>category</th>
</tr>
</thead>
<tbody><tr>
<td>《疑犯追踪》</td>
<td>悬疑,动作,科幻,剧情</td>
</tr>
<tr>
<td>《Lie  to me》</td>
<td>悬疑,警匪,动作,心理,剧情</td>
</tr>
<tr>
<td>《战狼2》</td>
<td>战争,动作,灾难</td>
</tr>
</tbody></table>
<p>需求：将电影分类中的数组数据展开。结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 期望结果</span></span><br><span class="line"></span><br><span class="line">《疑犯追踪》	悬疑</span><br><span class="line">《疑犯追踪》	动作</span><br><span class="line">《疑犯追踪》	科幻</span><br><span class="line">《疑犯追踪》	剧情</span><br><span class="line">《Lie <span class="keyword">to</span> me》	悬疑</span><br><span class="line">《Lie <span class="keyword">to</span> me》	警匪</span><br><span class="line">《Lie <span class="keyword">to</span> me》	动作</span><br><span class="line">《Lie <span class="keyword">to</span> me》	心理</span><br><span class="line">《Lie <span class="keyword">to</span> me》	剧情</span><br><span class="line">《战狼<span class="number">2</span>》	战争</span><br><span class="line">《战狼<span class="number">2</span>》	动作</span><br><span class="line">《战狼<span class="number">2</span>》	灾难</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在原始数据中，category 是数组类型数据，可以将数组中的元素都拆出来，再与对应的电影名称做笛卡尔积。</span><br><span class="line"></span><br><span class="line"># 1、把集合转为多个元素</span><br><span class="line">select explode(category)</span><br><span class="line">from movie_info;</span><br><span class="line"></span><br><span class="line"># 2、将第一步的查询结果作为一张临时表，再与 movie_info 表进行关联</span><br><span class="line">select </span><br><span class="line">from movie_info</span><br><span class="line">join</span><br><span class="line">select explode(category)</span><br><span class="line">from movie_info</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"># 3、需要将 explode 拆分后的一列N行，在逻辑上依然视为一列一行。和 movie_info 做表关联。这个行为在 Hive 中叫做侧写（lateral view）</span><br></pre></td></tr></table></figure>





<p><strong>实现</strong></p>
<ol>
<li><p>创建本地 <code>movie.txt</code>，导入数据</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 datas]$ vim movie.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件内容</span></span><br><span class="line">《疑犯追踪》	悬疑,动作,科幻,剧情</span><br><span class="line">《Lie to me》	悬疑,警匪,动作,心理,剧情</span><br><span class="line">《战狼2》	战争,动作,灾难</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建 <code>hive</code> 表，并导入数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建 hive 表</span><br><span class="line">create table movie_info</span><br><span class="line">(</span><br><span class="line">    movie string, </span><br><span class="line">    category array&lt;string&gt;</span><br><span class="line">) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;</span><br><span class="line">collection items terminated by &quot;,&quot;;</span><br><span class="line"></span><br><span class="line"># 导入数据</span><br><span class="line">load data local inpath &quot;/opt/module/datas/movie.txt&quot; into table movie_info;</span><br></pre></td></tr></table></figure>

</li>
<li><p>按需求查询数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">    movie,</span><br><span class="line">    category_name</span><br><span class="line">from </span><br><span class="line">    movie_info lateral view explode(category) table_tmp as category_name;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>窗口函数：窗口 + 函数</p>
<ul>
<li>  窗口：函数运行时计算的数据集的范围</li>
<li>  函数：运行的函数</li>
</ul>
<p>注意：不是所有的函数在运行时都可以通过改变窗口的大小，来控制计算的数据集的范围。</p>
<p>格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名 <span class="keyword">over</span>( <span class="keyword">partition</span> <span class="keyword">by</span> 字段, <span class="keyword">order</span> <span class="keyword">by</span> 字段, window_clause) </span><br></pre></td></tr></table></figure>





<ol>
<li><p>相关函数说明</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化</span><br><span class="line"></span><br><span class="line">CURRENT ROW：当前行</span><br><span class="line">n PRECEDING：往前n行数据</span><br><span class="line">n FOLLOWING：往后n行数据</span><br><span class="line">UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING表示到后面的终点</span><br><span class="line"></span><br><span class="line">LAG(col, n)：往前第n行数据</span><br><span class="line"></span><br><span class="line">LEAD(col, n)：往后第n行数据</span><br><span class="line"></span><br><span class="line">NTILE(n)：把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。</span><br></pre></td></tr></table></figure>

</li>
<li><p>数据准备</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># name，orderdate，cost</span><br><span class="line">jack,2017-01-01,10</span><br><span class="line">tony,2017-01-02,15</span><br><span class="line">jack,2017-02-03,23</span><br><span class="line">tony,2017-01-04,29</span><br><span class="line">jack,2017-01-05,46</span><br><span class="line">jack,2017-04-06,42</span><br><span class="line">tony,2017-01-07,50</span><br><span class="line">jack,2017-01-08,55</span><br><span class="line">mart,2017-04-08,62</span><br><span class="line">mart,2017-04-09,68</span><br><span class="line">neil,2017-05-10,12</span><br><span class="line">mart,2017-04-11,75</span><br><span class="line">neil,2017-06-12,80</span><br><span class="line">mart,2017-04-13,94</span><br></pre></td></tr></table></figure>

</li>
<li><p>需求：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）查询在2017年4月份购买过商品的顾客及总人数</span><br><span class="line">（2）查询顾客的购买明细及月购买总额</span><br><span class="line">（3）上述的场景,要将cost按照日期进行累加</span><br><span class="line">（4）查询顾客上次的购买时间</span><br><span class="line">（5）查询前20%时间的订单信息</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>实现：</strong></p>
<ol>
<li><p>创建本地 <code>business.txt</code>，导入数据</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 datas]$ vim business.txt</span><br></pre></td></tr></table></figure></li>
<li><p>创建 <code>hive</code> 表并导入数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建 business 表</span><br><span class="line">create table business</span><br><span class="line">(</span><br><span class="line">    name string, </span><br><span class="line">    orderdate string,</span><br><span class="line">    cost int</span><br><span class="line">) </span><br><span class="line">ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;,&#x27;;</span><br><span class="line"></span><br><span class="line"># 导入数据</span><br><span class="line">load data local inpath &quot;/opt/module/datas/business.txt&quot; into table business;</span><br></pre></td></tr></table></figure></li>
<li><p>按需求查询数据</p>
<ul>
<li>  （1）查询在2017年4月份购买过的顾客及总人数</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select name, count(*) over() </span><br><span class="line">from business </span><br><span class="line">where substring(orderdate,1,7) = &#x27;2017-04&#x27; </span><br><span class="line">group by name;</span><br><span class="line"></span><br><span class="line"># count() 函数用于分组后，统计每个组内所有的数据</span><br><span class="line"># count(*) over() 添加窗口函数，统计分组后临时表的个数</span><br><span class="line"># group by 用于去重，一个用户多次购物不会增加人数</span><br><span class="line"># substring()	作用：截取字符串，从第一位开始，截取7位</span><br></pre></td></tr></table></figure>

<ul>
<li>  （2）查询顾客的购买明细及月购买总额</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name, orderdate, cost, sum(cost) over(partition by month(orderdate)) </span><br><span class="line">from business;</span><br></pre></td></tr></table></figure>

<ul>
<li>  （3）上述的场景,要将 <code>cost</code> 按照日期进行累加</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select name,orderdate,cost, </span><br><span class="line">sum(cost) over() as sample1,--所有行相加 </span><br><span class="line">sum(cost) over(partition by name) as sample2,--按name分组，组内数据相加 </span><br><span class="line">sum(cost) over(partition by name order by orderdate) as sample3,--按name分组，组内数据累加 </span><br><span class="line">sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as sample4 ,--和sample3一样,由起点到当前行的聚合 </span><br><span class="line">sum(cost) over(partition by name order by orderdate rows between 1 PRECEDING and current row) as sample5, --当前行和前面一行做聚合 </span><br><span class="line">sum(cost) over(partition by name order by orderdate rows between 1 PRECEDING AND 1 FOLLOWING ) as sample6,--当前行和前边一行及后面一行 </span><br><span class="line">sum(cost) over(partition by name order by orderdate rows between current row and UNBOUNDED FOLLOWING ) as sample7 --当前行及后面所有行 </span><br><span class="line">from business;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  （4）查询顾客上次的购买时间</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name,orderdate,cost, </span><br><span class="line">lag(orderdate,1,&#x27;1900-01-01&#x27;) over(partition by name order by orderdate ) as time1, lag(orderdate,2) over (partition by name order by orderdate) as time2 </span><br><span class="line">from business;</span><br></pre></td></tr></table></figure>

<ul>
<li>  （5）查询前 <code>20%</code> 时间的订单信息</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from </span><br><span class="line">(</span><br><span class="line">    select name,orderdate,cost, ntile(5) over(order by orderdate) sorted</span><br><span class="line">    from business</span><br><span class="line">) t</span><br><span class="line">where sorted = 1;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="排名函数"><a href="#排名函数" class="headerlink" title="排名函数"></a>排名函数</h3><p><strong>常用的排名函数</strong></p>
<ol>
<li><p><code>RANK()</code>    排序相同时会重复（允许并列），总数不会变</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 3 3 5</span><br></pre></td></tr></table></figure></li>
<li><p><code>DENSE_RANK()</code>    排序相同时会重复，总数会减少</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 2 3</span><br></pre></td></tr></table></figure></li>
<li><p><code>ROW_NUMBER()</code>    会根据顺序计算。就是行号</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>数据准备</strong></p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">subject</th>
<th align="center">score</th>
</tr>
</thead>
<tbody><tr>
<td align="center">孙悟空</td>
<td align="center">语文</td>
<td align="center">87</td>
</tr>
<tr>
<td align="center">孙悟空</td>
<td align="center">数学</td>
<td align="center">95</td>
</tr>
<tr>
<td align="center">孙悟空</td>
<td align="center">英语</td>
<td align="center">68</td>
</tr>
<tr>
<td align="center">大海</td>
<td align="center">语文</td>
<td align="center">94</td>
</tr>
<tr>
<td align="center">大海</td>
<td align="center">数学</td>
<td align="center">56</td>
</tr>
<tr>
<td align="center">大海</td>
<td align="center">英语</td>
<td align="center">84</td>
</tr>
<tr>
<td align="center">宋宋</td>
<td align="center">语文</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">宋宋</td>
<td align="center">数学</td>
<td align="center">86</td>
</tr>
<tr>
<td align="center">宋宋</td>
<td align="center">英语</td>
<td align="center">84</td>
</tr>
<tr>
<td align="center">婷婷</td>
<td align="center">语文</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">婷婷</td>
<td align="center">数学</td>
<td align="center">85</td>
</tr>
<tr>
<td align="center">婷婷</td>
<td align="center">英语</td>
<td align="center">78</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">孙悟空	语文	87</span><br><span class="line">孙悟空	数学	95</span><br><span class="line">孙悟空	英语	68</span><br><span class="line">大海	语文	94</span><br><span class="line">大海	数学	56</span><br><span class="line">大海	英语	84</span><br><span class="line">宋宋	语文	64</span><br><span class="line">宋宋	数学	86</span><br><span class="line">宋宋	英语	84</span><br><span class="line">婷婷	语文	65</span><br><span class="line">婷婷	数学	85</span><br><span class="line">婷婷	英语	78</span><br></pre></td></tr></table></figure>





<p>需求：计算每门学科成绩排名。</p>
<p><strong>实现：</strong></p>
<ol>
<li><p>创建本地 <code>score.txt</code>，导入数据</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 datas]$ vim score.txt</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建 <code>Hive</code> 表并导入数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table score</span><br><span class="line">(</span><br><span class="line">    name string,</span><br><span class="line">    subject string, </span><br><span class="line">    score int</span><br><span class="line">) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line">load data local inpath &#x27;/opt/module/datas/score.txt&#x27; into table score;</span><br></pre></td></tr></table></figure>

</li>
<li><p>按需求查询数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">	name,</span><br><span class="line">	subject,</span><br><span class="line">	score,</span><br><span class="line">rank() over(partition by subject order by score desc) rp,</span><br><span class="line">dense_rank() over(partition by subject order by score desc) drp,</span><br><span class="line">row_number() over(partition by subject order by score desc) rmp</span><br><span class="line">from score;</span><br><span class="line"># 排名前一般需要先排序</span><br><span class="line"></span><br><span class="line"># 查询结果</span><br><span class="line">name    subject score   rp      drp     rmp</span><br><span class="line">孙悟空  数学    95      1       1       1</span><br><span class="line">宋宋    数学    86      2       2       2</span><br><span class="line">婷婷    数学    85      3       3       3</span><br><span class="line">大海    数学    56      4       4       4</span><br><span class="line">宋宋    英语    84      1       1       1</span><br><span class="line">大海    英语    84      1       1       2</span><br><span class="line">婷婷    英语    78      3       2       3</span><br><span class="line">孙悟空  英语    68      4       3       4</span><br><span class="line">大海    语文    94      1       1       1</span><br><span class="line">孙悟空  语文    87      2       2       2</span><br><span class="line">婷婷    语文    65      3       3       3</span><br><span class="line">宋宋    语文    64      4       4       4</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>练习</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 按照科目进行排名</span><br><span class="line"></span><br><span class="line">// 给每个学生的总分进行排名</span><br><span class="line"></span><br><span class="line">// 只查询每个科目的成绩的前2名</span><br><span class="line"></span><br><span class="line">// 查询学生成绩，并显示当前科目最高分</span><br><span class="line"></span><br><span class="line">// 查询学生成绩，并显示当前科目最低分</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="7-2-自定义函数"><a href="#7-2-自定义函数" class="headerlink" title="7.2 自定义函数"></a>7.2 自定义函数</h2><ul>
<li>  <code>Hive</code> 提供了一些内置函数，比如 <code>max/min</code> 等，但是数量有限，所以 <code>Hive</code> 提供了用户自定义函数的功能，用户可以通过 <code>UDF</code> 实现自定义函数。</li>
<li>  UDF：User-defined Function</li>
</ul>
<h3 id="用户自定义函数分类（按照特征分类）："><a href="#用户自定义函数分类（按照特征分类）：" class="headerlink" title="用户自定义函数分类（按照特征分类）："></a>用户自定义函数分类（按照特征分类）：</h3><ol>
<li><p><strong>UDF（User-Defined-Function）</strong></p>
<ul>
<li>  一进一出。输入单个参数，返回单个结果</li>
</ul>
</li>
<li><p><strong>UDAF（User-Defined Aggregation Function）</strong>：用户定义的表聚集函数</p>
<ul>
<li>  聚集函数，多进一出</li>
<li>  类似于：<code>count/max/min</code></li>
</ul>
</li>
<li><p><strong>UDTF（User-Defined Table-Generating Functions）</strong>：用户定义的表生成函数</p>
<ul>
<li>   一进多出</li>
<li>  类似于：<code>lateral view explore()</code></li>
</ul>
<p> ​      </p>
</li>
</ol>
<h3 id="官方文档地址"><a href="#官方文档地址" class="headerlink" title="官方文档地址"></a>官方文档地址</h3><p><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins">https://cwiki.apache.org/confluence/display/Hive/HivePlugins</a></p>
<h3 id="自定义函数编程步骤："><a href="#自定义函数编程步骤：" class="headerlink" title="自定义函数编程步骤："></a>自定义函数编程步骤：</h3><ol>
<li><p> 继承 <code>org.apache.hadoop.hive.ql.UDF</code></p>
</li>
<li><p> 实现 <code>evaluate</code> 函数；<code>evaluate</code> 函数支持重载；</p>
</li>
<li><p>在 <code>Hive</code> 的命令行窗口创建函数</p>
<ul>
<li><p>添加 <code>jar</code></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add jar linux_jar_path</span><br></pre></td></tr></table></figure></li>
<li><p>创建 <code>function</code></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [temporary] function [dbname.]function_name AS class_name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在 <code>hive</code> 的命令行窗口删除函数</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Drop [temporary] function [if exists] [dbname.]function_name;</span><br></pre></td></tr></table></figure>

</li>
<li><p>注意事项</p>
<ul>
<li>  <code>UDF</code> 必须要有返回类型，可以返回 <code>null</code>，但是返回类型不能为 <code>void</code>；</li>
</ul>
</li>
</ol>
<hr>
<h2 id="7-3-自定义-UDF-函数"><a href="#7-3-自定义-UDF-函数" class="headerlink" title="7.3 自定义 UDF 函数"></a>7.3 自定义 UDF 函数</h2><ol>
<li><p>创建一个 <code>Maven</code> 工程，并导入依赖</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hive/hive-exec --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>创建一个类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.hive;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lower</span> <span class="keyword">extends</span> <span class="title class_">UDF</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">evaluate</span> <span class="params">(<span class="keyword">final</span> String s)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> s.toLowerCase();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p> 打成 <code>jar</code> 包上传到服务器 <code>/opt/module/jars/udf.jar</code></p>
</li>
<li><p>将 <code>jar</code> 包添加到 <code>hive</code> 的 <code>classpath</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; add jar /opt/module/datas/udf.jar;</span><br></pre></td></tr></table></figure></li>
<li><p>创建临时函数与开发好的 <code>java class</code> 关联</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; create temporary function mylower as &quot;com.atguigu.hive.Lower&quot;;</span><br></pre></td></tr></table></figure></li>
<li><p>即可在 <code>hql</code> 中使用自定义的函数 <code>strip</code> </p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select ename, mylower(ename) lowername from emp;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="第-8-章-压缩和存储"><a href="#第-8-章-压缩和存储" class="headerlink" title="第 8 章    压缩和存储"></a>第 8 章    压缩和存储</h1><h2 id="8-1-Hadoop源码编译支持Snappy压缩"><a href="#8-1-Hadoop源码编译支持Snappy压缩" class="headerlink" title="8.1 Hadoop源码编译支持Snappy压缩"></a>8.1 Hadoop源码编译支持Snappy压缩</h2><h3 id="8-1-1-资源准备"><a href="#8-1-1-资源准备" class="headerlink" title="8.1.1 资源准备"></a>8.1.1 资源准备</h3><p>1．CentOS联网 </p>
<p>配置CentOS能连接外网。Linux虚拟机ping <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 是畅通的</p>
<p>注意：采用root角色编译，减少文件夹权限出现问题</p>
<p>2．jar包准备(hadoop源码、JDK8 、maven、protobuf)</p>
<p>（1）hadoop-2.7.2-src.tar.gz</p>
<p>（2）jdk-8u144-linux-x64.tar.gz</p>
<p>（3）snappy-1.1.3.tar.gz</p>
<p>（4）apache-maven-3.0.5-bin.tar.gz</p>
<p>（5）protobuf-2.5.0.tar.gz</p>
<h3 id="8-1-2-jar包安装"><a href="#8-1-2-jar包安装" class="headerlink" title="8.1.2 jar包安装"></a>8.1.2 jar包安装</h3><p>注意：所有操作必须在root用户下完成</p>
<p>1．JDK解压、配置环境变量JAVA_HOME和PATH，验证<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javase">java</a>-version(如下都需要验证是否配置成功)</p>
<p>[root@hadoop101 software] # tar -zxf jdk-8u144-linux-x64.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 software]# vi /etc/profile</p>
<p>  #JAVA_HOME  export  JAVA_HOME=/opt/module/jdk1.8.0_144  export  PATH=$PATH:$JAVA_HOME/bin  </p>
<p>[root@hadoop101 software]#source /etc/profile</p>
<p>验证命令：java -version</p>
<p>2．Maven解压、配置  MAVEN_HOME和PATH</p>
<p>[root@hadoop101 software]# tar -zxvf apache-maven-3.0.5-bin.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 apache-maven-3.0.5]# vi /etc/profile</p>
<p>  #MAVEN_HOME  export  MAVEN_HOME=/opt/module/apache-maven-3.0.5  export  PATH=$PATH:$MAVEN_HOME/bin  </p>
<p>[root@hadoop101 software]#source /etc/profile</p>
<p>验证命令：mvn -version</p>
<h3 id="8-1-3-编译源码"><a href="#8-1-3-编译源码" class="headerlink" title="8.1.3 编译源码"></a>8.1.3 编译源码</h3><p>1．准备编译环境</p>
<p>[root@hadoop101 software]# yum install svn</p>
<p>[root@hadoop101 software]# yum install autoconf automake libtool cmake</p>
<p>[root@hadoop101 software]# yum install ncurses-devel</p>
<p>[root@hadoop101 software]# yum install openssl-devel</p>
<p>[root@hadoop101 software]# yum install gcc*</p>
<p>2．编译安装snappy</p>
<p>[root@hadoop101 software]# tar -zxvf snappy-1.1.3.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 module]# cd snappy-1.1.3/</p>
<p>[root@hadoop101 snappy-1.1.3]# ./configure</p>
<p>[root@hadoop101 snappy-1.1.3]# make</p>
<p>[root@hadoop101 snappy-1.1.3]# make install</p>
<p># 查看snappy库文件</p>
<p>[root@hadoop101 snappy-1.1.3]# ls -lh /usr/local/lib |grep snappy</p>
<p>3．编译安装protobuf</p>
<p>[root@hadoop101 software]# tar -zxvf protobuf-2.5.0.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 module]# cd protobuf-2.5.0/</p>
<p>[root@hadoop101 protobuf-2.5.0]# ./configure </p>
<p>[root@hadoop101 protobuf-2.5.0]# make </p>
<p>[root@hadoop101 protobuf-2.5.0]# make install</p>
<p># 查看protobuf版本以测试是否安装成功<br> [root@hadoop101 protobuf-2.5.0]# protoc –version</p>
<p>4．编译hadoop native</p>
<p>[root@hadoop101 software]# tar -zxvf hadoop-2.7.2-src.tar.gz</p>
<p>[root@hadoop101 software]# cd hadoop-2.7.2-src/</p>
<p>[root@hadoop101 software]# mvn clean package -DskipTests -Pdist,native -Dtar -Dsnappy.lib=/usr/local/lib -Dbundle.snappy</p>
<p>执行成功后，/opt/software/hadoop-2.7.2-src/hadoop-dist/target/<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/hadoop">hadoop</a>-2.7.2.tar.gz即为新生成的支持snappy压缩的二进制安装包。</p>
<h2 id="8-2-Hadoop压缩配置"><a href="#8-2-Hadoop压缩配置" class="headerlink" title="8.2 Hadoop压缩配置"></a>8.2 Hadoop压缩配置</h2><h3 id="8-2-1-MR支持的压缩编码"><a href="#8-2-1-MR支持的压缩编码" class="headerlink" title="8.2.1 MR支持的压缩编码"></a>8.2.1 MR支持的压缩编码</h3><p>表6-8</p>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>工具</th>
<th>算法</th>
<th>文件扩展名</th>
<th>是否可切分</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT</td>
<td>无</td>
<td>DEFAULT</td>
<td>.deflate</td>
<td>否</td>
</tr>
<tr>
<td>Gzip</td>
<td>gzip</td>
<td>DEFAULT</td>
<td>.gz</td>
<td>否</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2</td>
<td>bzip2</td>
<td>.bz2</td>
<td>是</td>
</tr>
<tr>
<td>LZO</td>
<td>lzop</td>
<td>LZO</td>
<td>.lzo</td>
<td>是</td>
</tr>
<tr>
<td>Snappy</td>
<td>无</td>
<td>Snappy</td>
<td>.snappy</td>
<td>否</td>
</tr>
</tbody></table>
<p>为了支持多种压缩/解压缩算法，Hadoop引入了编码/解码器，如下表所示：</p>
<p>表6-9</p>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>对应的编码/解码器</th>
</tr>
</thead>
<tbody><tr>
<td>DEFLATE</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
</tr>
<tr>
<td>gzip</td>
<td>org.apache.hadoop.io.compress.GzipCodec</td>
</tr>
<tr>
<td>bzip2</td>
<td>org.apache.hadoop.io.compress.BZip2Codec</td>
</tr>
<tr>
<td>LZO</td>
<td>com.hadoop.compression.lzo.LzopCodec</td>
</tr>
<tr>
<td>Snappy</td>
<td>org.apache.hadoop.io.compress.SnappyCodec</td>
</tr>
</tbody></table>
<p>压缩性能的比较：</p>
<p>表6-10</p>
<table>
<thead>
<tr>
<th>压缩算法</th>
<th>原始文件大小</th>
<th>压缩文件大小</th>
<th>压缩速度</th>
<th>解压速度</th>
</tr>
</thead>
<tbody><tr>
<td>gzip</td>
<td>8.3GB</td>
<td>1.8GB</td>
<td>17.5MB/s</td>
<td>58MB/s</td>
</tr>
<tr>
<td>bzip2</td>
<td>8.3GB</td>
<td>1.1GB</td>
<td>2.4MB/s</td>
<td>9.5MB/s</td>
</tr>
<tr>
<td>LZO</td>
<td>8.3GB</td>
<td>2.9GB</td>
<td>49.3MB/s</td>
<td>74.6MB/s</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="http://google.github.io/snappy/">http://google.github.io/snappy/</a></p>
<p>On a single core of a Core i7 processor in 64-bit mode, Snappy compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more.</p>
<h3 id="8-2-2-压缩参数配置"><a href="#8-2-2-压缩参数配置" class="headerlink" title="8.2.2 压缩参数配置"></a>8.2.2 压缩参数配置</h3><p>要在Hadoop中启用压缩，可以配置如下参数（mapred-site.xml文件中）：</p>
<p>表6-11</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>阶段</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>io.compression.codecs    （在core-site.xml中配置）</td>
<td>org.apache.hadoop.io.compress.DefaultCodec,  org.apache.hadoop.io.compress.GzipCodec,  org.apache.hadoop.io.compress.BZip2Codec,  org.apache.hadoop.io.compress.Lz4Codec</td>
<td>输入压缩</td>
<td>Hadoop使用文件扩展名判断是否支持某种编解码器</td>
</tr>
<tr>
<td>mapreduce.map.output.compress</td>
<td>false</td>
<td>mapper输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.map.output.compress.codec</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
<td>mapper输出</td>
<td>使用LZO、LZ4或snappy编解码器在此阶段压缩数据</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress</td>
<td>false</td>
<td>reducer输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.codec</td>
<td>org.apache.hadoop.io.compress.  DefaultCodec</td>
<td>reducer输出</td>
<td>使用标准工具或者编解码器，如gzip和bzip2</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.type</td>
<td>RECORD</td>
<td>reducer输出</td>
<td>SequenceFile输出使用的压缩类型：NONE和BLOCK</td>
</tr>
</tbody></table>
<h2 id="8-3-开启Map输出阶段压缩"><a href="#8-3-开启Map输出阶段压缩" class="headerlink" title="8.3 开启Map输出阶段压缩"></a>8.3 开启Map输出阶段压缩</h2><p>开启map输出阶段压缩可以减少job中map和Reduce task间数据传输量。具体配置如下：</p>
<p><strong>案例实操：</strong></p>
<p>1．开启hive中间传输数据压缩功能</p>
<p>hive (default)&gt;set hive.exec.compress.intermediate=true;</p>
<p>2．开启mapreduce中map输出压缩功能</p>
<p>hive (default)&gt;set mapreduce.map.output.compress=true;</p>
<p>3．设置mapreduce中map输出数据的压缩方式</p>
<p>hive (default)&gt;set mapreduce.map.output.compress.codec=</p>
<p> org.apache.hadoop.io.compress.SnappyCodec;</p>
<p>4．执行查询语句</p>
<p>  hive (default)&gt; select count(ename) name from emp;</p>
<h2 id="8-4-开启Reduce输出阶段压缩"><a href="#8-4-开启Reduce输出阶段压缩" class="headerlink" title="8.4 开启Reduce输出阶段压缩"></a>8.4 开启Reduce输出阶段压缩</h2><p>当Hive将输出写入到表中时，输出内容同样可以进行压缩。属性hive.exec.compress.output控制着这个功能。用户可能需要保持默认设置文件中的默认值false，这样默认的输出就是非压缩的纯文本文件了。用户可以通过在查询语句或执行脚本中设置这个值为true，来开启输出结果压缩功能。</p>
<p><strong>案例实操：</strong></p>
<p>1．开启hive最终输出数据压缩功能</p>
<p>hive (default)&gt;set hive.exec.compress.output=true;</p>
<p>2．开启mapreduce最终输出数据压缩</p>
<p>hive (default)&gt;set mapreduce.output.fileoutputformat.compress=true;</p>
<p>3．设置mapreduce最终数据输出压缩方式</p>
<p>hive (default)&gt; set mapreduce.output.fileoutputformat.compress.codec =</p>
<p> org.apache.hadoop.io.compress.SnappyCodec;</p>
<p>4．设置mapreduce最终数据输出压缩为块压缩</p>
<p>hive (default)&gt; set mapreduce.output.fileoutputformat.compress.type=BLOCK;</p>
<p>5．测试一下输出结果是否是压缩文件</p>
<p>hive (default)&gt; insert overwrite local directory</p>
<p> ‘/opt/module/datas/distribute-result’ select * from emp distribute by deptno sort by empno desc;</p>
<h2 id="8-5-文件存储格式"><a href="#8-5-文件存储格式" class="headerlink" title="8.5 文件存储格式"></a>8.5 文件存储格式</h2><p>Hive支持的存储数的格式主要有：TEXTFILE 、SEQUENCEFILE、ORC、PARQUET。</p>
<h3 id="8-5-1-列式存储和行式存储"><a href="#8-5-1-列式存储和行式存储" class="headerlink" title="8.5.1 列式存储和行式存储"></a>8.5.1 列式存储和行式存储</h3><p><img src="/2021/12/20/Hive%EF%BC%88%E4%B8%8B%EF%BC%89/clip_image002.jpg" alt="img"></p>
<p>图6-10 列式存储和行式存储</p>
<p>如图6-10所示左边为逻辑表，右边第一个为行式存储，第二个为列式存储。</p>
<p>1．行存储的特点</p>
<p>查询满足条件的一整行数据的时候，列存储则需要去每个聚集的字段找到对应的每个列的值，行存储只需要找到其中一个值，其余的值都在相邻地方，所以此时行存储查询的速度更快。</p>
<p>2．列存储的特点</p>
<p>因为每个字段的数据聚集存储，在查询只需要少数几个字段的时候，能大大减少读取的数据量；每个字段的数据类型一定是相同的，列式存储可以针对性的设计更好的设计压缩算法。</p>
<p>TEXTFILE和SEQUENCEFILE的存储格式都是基于行存储的；</p>
<p>ORC和PARQUET是基于列式存储的。</p>
<h3 id="8-5-2-TextFile格式"><a href="#8-5-2-TextFile格式" class="headerlink" title="8.5.2 TextFile格式"></a>8.5.2 TextFile格式</h3><p>默认格式，数据不做压缩，磁盘开销大，数据解析开销大。可结合Gzip、Bzip2使用，但使用Gzip这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。</p>
<h3 id="8-5-3-Orc格式"><a href="#8-5-3-Orc格式" class="headerlink" title="8.5.3 Orc格式"></a>8.5.3 Orc格式</h3><p>Orc (Optimized Row Columnar)是Hive 0.11版里引入的新的存储格式。</p>
<p>如图6-11所示可以看到每个Orc文件由1个或多个stripe组成，每个stripe250MB大小，这个Stripe实际相当于RowGroup概念，不过大小由4MB-&gt;250MB，这样应该能提升顺序读的吞吐率。每个Stripe里有三部分组成，分别是Index Data，Row Data，Stripe Footer：</p>
<p><img src="/2021/12/20/Hive%EF%BC%88%E4%B8%8B%EF%BC%89/clip_image004.jpg" alt="img"></p>
<p>图6-11 Orc格式</p>
<p>​    1）Index Data：一个轻量级的index，默认是每隔1W行做一个索引。这里做的索引应该只是记录某行的各字段在Row Data中的offset。</p>
<p>   2）Row Data：存的是具体的数据，先取部分行，然后对这些行按列进行存储。对每个列进行了编码，分成多个Stream来存储。</p>
<p>​    3）Stripe Footer：存的是各个Stream的类型，长度等信息。</p>
<p>每个文件有一个File Footer，这里面存的是每个Stripe的行数，每个Column的数据类型信息等；每个文件的尾部是一个PostScript，这里面记录了整个文件的压缩类型以及FileFooter的长度信息等。在读取文件时，会seek到文件尾部读PostScript，从里面解析到File Footer长度，再读FileFooter，从里面解析到各个Stripe信息，再读各个Stripe，即从后往前读。</p>
<h3 id="8-5-4-Parquet格式"><a href="#8-5-4-Parquet格式" class="headerlink" title="8.5.4 Parquet格式"></a>8.5.4 Parquet格式</h3><p>Parquet是面向分析型业务的列式存储格式，由Twitter和Cloudera合作开发，2015年5月从Apache的孵化器里毕业成为Apache顶级项目。</p>
<p>Parquet文件是以二进制方式存储的，所以是不可以直接读取的，文件中包括该文件的数据和元数据，因此Parquet格式文件是自解析的。</p>
<p>通常情况下，在存储Parquet数据的时候会按照Block大小设置行组的大小，由于一般情况下每一个Mapper任务处理数据的最小单位是一个Block，这样可以把每一个行组由一个Mapper任务处理，增大任务执行并行度。Parquet文件的格式如图6-12所示。</p>
<p><img src="/2021/12/20/Hive%EF%BC%88%E4%B8%8B%EF%BC%89/clip_image006.jpg" alt="Parquet文件格式"></p>
<p>图6-12 Parquet格式</p>
<p>上图展示了一个Parquet文件的内容，一个文件中可以存储多个行组，文件的首位都是该文件的Magic Code，用于校验它是否是一个Parquet文件，Footer length记录了文件元数据的大小，通过该值和文件长度可以计算出元数据的偏移量，文件的元数据中包括每一个行组的元数据信息和该文件存储数据的Schema信息。除了文件中每一个行组的元数据，每一页的开始都会存储该页的元数据，在Parquet中，有三种类型的页：数据页、字典页和索引页。数据页用于存储当前行组中该列的值，字典页存储该列值的编码字典，每一个列块中最多包含一个字典页，索引页用来存储当前行组下该列的索引，目前Parquet中还不支持索引页。</p>
<h3 id="8-5-5-主流文件存储格式对比实验"><a href="#8-5-5-主流文件存储格式对比实验" class="headerlink" title="8.5.5 主流文件存储格式对比实验"></a>8.5.5 主流文件存储格式对比实验</h3><p>从存储文件的压缩比和查询速度两个角度对比。</p>
<p><strong>存储文件的压缩比测试：</strong></p>
<p>\1.   测试数据</p>
<p>2．TextFile</p>
<p>（1）创建表，存储数据格式为TEXTFILE</p>
<p>  create  table log_text (  track_time  string,  url  string,  session_id  string,  referer  string,  ip  string,  end_user_id  string,  city_id  string  )  row  format delimited fields terminated by ‘\t’  stored  as textfile ;  </p>
<p>（2）向表中加载数据</p>
<p>  hive  (default)&gt; load data local inpath ‘/opt/module/datas/log.data’ into table  log_text ;  </p>
<p>（3）查看表中数据大小</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_text;  </p>
<p>18.1 M /user/hive/warehouse/log_text/log.data</p>
<p>3．ORC</p>
<p>​    （1）创建表，存储数据格式为ORC</p>
<p>  create  table log_orc(  track_time  string,  url  string,  session_id  string,  referer  string,  ip  string,  end_user_id  string,  city_id  string  )  row  format delimited fields terminated by ‘\t’  stored  as orc ;  </p>
<p>（2）向表中加载数据</p>
<p>  hive  (default)&gt; insert into table log_orc select * from log_text ;  </p>
<p>（3）查看表中数据大小</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_orc/ ;  </p>
<p>2.8 M /user/hive/warehouse/log_orc/000000_0</p>
<p>4．Parquet</p>
<p>（1）创建表，存储数据格式为parquet</p>
<p>  create  table log_parquet(  track_time  string,  url  string,  session_id  string,  referer  string,  ip  string,  end_user_id  string,  city_id  string  )  row  format delimited fields terminated by ‘\t’  stored  as parquet ;    </p>
<p>（2）向表中加载数据</p>
<p>  hive  (default)&gt; insert into table log_parquet select * from log_text ;  </p>
<p>（3）查看表中数据大小</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_parquet/ ;  </p>
<p>13.1 M  /user/hive/warehouse/log_parquet/000000_0</p>
<p>存储文件的压缩比总结：</p>
<p>ORC &gt; Parquet &gt; textFile</p>
<p><strong>存储文件的查询速度测试：</strong></p>
<p>1．TextFile</p>
<p>hive (default)&gt; select count(*) from log_text;</p>
<p>_c0</p>
<p>100000</p>
<p>Time taken: 21.54 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 21.08 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 19.298 seconds, Fetched: 1 row(s)</p>
<p>2．ORC</p>
<p>hive (default)&gt; select count(*) from log_orc;</p>
<p>_c0</p>
<p>100000</p>
<p>Time taken: 20.867 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 22.667 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 18.36 seconds, Fetched: 1 row(s)</p>
<p>3．Parquet</p>
<p>hive (default)&gt; select count(*) from log_parquet;</p>
<p>_c0</p>
<p>100000</p>
<p>Time taken: 22.922 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 21.074 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 18.384 seconds, Fetched: 1 row(s)</p>
<p>存储文件的查询速度总结：查询速度相近。</p>
<h2 id="8-6-存储和压缩结合"><a href="#8-6-存储和压缩结合" class="headerlink" title="8.6 存储和压缩结合"></a>8.6 存储和压缩结合</h2><h3 id="8-6-1-修改Hadoop集群具有Snappy压缩方式"><a href="#8-6-1-修改Hadoop集群具有Snappy压缩方式" class="headerlink" title="8.6.1 修改Hadoop集群具有Snappy压缩方式"></a>8.6.1 修改Hadoop集群具有Snappy压缩方式</h3><p>1．查看hadoop checknative命令使用</p>
<p>[atguigu@hadoop104 hadoop-2.7.2]$ hadoop</p>
<p>​    checknative [-a|-h] check native hadoop and compression libraries availability</p>
<p>2．查看hadoop支持的压缩方式</p>
<p> [atguigu@hadoop104 hadoop-2.7.2]$ hadoop checknative</p>
<p>17/12/24 20:32:52 WARN bzip2.Bzip2Factory: Failed to load/initialize native-bzip2 library system-native, will use pure-Java version</p>
<p>17/12/24 20:32:52 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</p>
<p>Native library checking:</p>
<p>hadoop: true /opt/module/hadoop-2.7.2/lib/native/libhadoop.so</p>
<p>zlib:  true /lib64/libz.so.1</p>
<p>snappy: false </p>
<p>lz4:   true revision:99</p>
<p>bzip2:  false</p>
<p>3．将编译好的支持Snappy压缩的hadoop-2.7.2.tar.gz包导入到hadoop102的/opt/software中</p>
<p>4．解压hadoop-2.7.2.tar.gz到当前路径</p>
<p>[atguigu@hadoop102 software]$ tar -zxvf hadoop-2.7.2.tar.gz</p>
<p>5．进入到/opt/software/hadoop-2.7.2/lib/native路径可以看到支持Snappy压缩的动态链接库</p>
<p>[atguigu@hadoop102 native]$ pwd</p>
<p>/opt/software/hadoop-2.7.2/lib/native</p>
<p>[atguigu@hadoop102 native]$ ll</p>
<p>-rw-r–r–. 1 atguigu atguigu 472950 9月  1 10:19 libsnappy.a</p>
<p>-rwxr-xr-x. 1 atguigu atguigu   955 9月  1 10:19 libsnappy.la</p>
<p>lrwxrwxrwx. 1 atguigu atguigu   18 12月 24 20:39 libsnappy.so -&gt; libsnappy.so.1.3.0</p>
<p>lrwxrwxrwx. 1 atguigu atguigu   18 12月 24 20:39 libsnappy.so.1 -&gt; libsnappy.so.1.3.0</p>
<p>-rwxr-xr-x. 1 atguigu atguigu 228177 9月  1 10:19 libsnappy.so.1.3.0</p>
<p>6．拷贝/opt/software/hadoop-2.7.2/lib/native里面的所有内容到开发集群的/opt/module/hadoop-2.7.2/lib/native路径上</p>
<p>[atguigu@hadoop102 native]$ cp ../native/* /opt/module/hadoop-2.7.2/lib/native/</p>
<p>7．分发集群</p>
<p>[atguigu@hadoop102 lib]$ xsync native/</p>
<p>8．再次查看hadoop支持的压缩类型</p>
<p>[atguigu@hadoop102 hadoop-2.7.2]$ hadoop checknative</p>
<p>17/12/24 20:45:02 WARN bzip2.Bzip2Factory: Failed to load/initialize native-bzip2 library system-native, will use pure-Java version</p>
<p>17/12/24 20:45:02 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</p>
<p>Native library checking:</p>
<p>hadoop: true /opt/module/hadoop-2.7.2/lib/native/libhadoop.so</p>
<p>zlib:  true /lib64/libz.so.1</p>
<p>snappy: true /opt/module/hadoop-2.7.2/lib/native/libsnappy.so.1</p>
<p>lz4:   true revision:99</p>
<p>bzip2:  false</p>
<p>9．重新启动hadoop集群和hive</p>
<h3 id="8-6-2-测试存储和压缩"><a href="#8-6-2-测试存储和压缩" class="headerlink" title="8.6.2 测试存储和压缩"></a>8.6.2 测试存储和压缩</h3><p>官网：<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC</a></p>
<p>ORC存储方式的压缩：</p>
<p>表6-12</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Default</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>orc.compress</td>
<td>ZLIB</td>
<td>high level compression (one of NONE, ZLIB,  SNAPPY)</td>
</tr>
<tr>
<td>orc.compress.size</td>
<td>262,144</td>
<td>number of bytes in each compression chunk</td>
</tr>
<tr>
<td>orc.stripe.size</td>
<td>67,108,864</td>
<td>number of bytes in each stripe</td>
</tr>
<tr>
<td>orc.row.index.stride</td>
<td>10,000</td>
<td>number of rows between index entries (must be  &gt;= 1000)</td>
</tr>
<tr>
<td>orc.create.index</td>
<td>true</td>
<td>whether to create row indexes</td>
</tr>
<tr>
<td>orc.bloom.filter.columns</td>
<td>“”</td>
<td>comma separated list of column names for which  bloom filter should be created</td>
</tr>
<tr>
<td>orc.bloom.filter.fpp</td>
<td>0.05</td>
<td>false positive probability for bloom filter  (must &gt;0.0 and &lt;1.0)</td>
</tr>
</tbody></table>
<p>1．创建一个非压缩的的ORC存储方式</p>
<p>​    （1）建表语句</p>
<p>  create  table log_orc_none(  track_time  string,  url  string,  session_id  string,  referer  string,  ip  string,  end_user_id  string,  city_id  string  )  row  format delimited fields terminated by ‘\t’  stored  as orc tblproperties (“orc.compress”=”NONE”);  </p>
<p>​    （2）插入数据</p>
<p>  hive  (default)&gt; insert into table log_orc_none select * from log_text ;  </p>
<p>​    （3）查看插入后数据</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_orc_none/ ;  </p>
<p>7.7 M /user/hive/warehouse/log_orc_none/000000_0</p>
<p>2．创建一个SNAPPY压缩的ORC存储方式</p>
<p>​    （1）建表语句</p>
<p>  create table log_orc_snappy(  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated by ‘\t’  stored as orc tblproperties  (“orc.compress”=”SNAPPY”);  </p>
<p>​    （2）插入数据</p>
<p>  hive  (default)&gt; insert into table log_orc_snappy select * from log_text ;  </p>
<p>​    （3）查看插入后数据</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_orc_snappy/ ;  </p>
<p>3.8 M  /user/hive/warehouse/log_orc_snappy/000000_0</p>
<p>3．上一节中默认创建的ORC存储方式，导入数据后的大小为</p>
<p>2.8 M /user/hive/warehouse/log_orc/000000_0</p>
<p>比Snappy压缩的还小。原因是orc存储文件默认采用ZLIB压缩。比snappy压缩的小。</p>
<p>4．存储方式和压缩总结</p>
<p>在实际的项目开发当中，hive表的数据存储格式一般选择：orc或parquet。压缩方式一般选择snappy，lzo。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/17/Hive%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/17/Hive%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">Hive安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-17 23:37:03" itemprop="dateCreated datePublished" datetime="2021-12-17T23:37:03+08:00">2021-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-21 16:20:54" itemprop="dateModified" datetime="2022-04-21T16:20:54+08:00">2022-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hive/" itemprop="url" rel="index"><span itemprop="name">Hive</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Hive安装地址"><a href="#1-Hive安装地址" class="headerlink" title="1 Hive安装地址"></a>1 Hive安装地址</h1><ol>
<li><p>Hive官网地址</p>
<p> <a target="_blank" rel="noopener" href="http://hive.apache.org/">http://hive.apache.org/</a></p>
</li>
<li><p>文档查看地址</p>
<p> <a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted">https://cwiki.apache.org/confluence/display/Hive/GettingStarted</a></p>
</li>
<li><p>下载地址</p>
<p> <a target="_blank" rel="noopener" href="http://archive.apache.org/dist/hive/">http://archive.apache.org/dist/hive/</a></p>
</li>
<li><p>github地址</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/apache/hive">https://github.com/apache/hive</a></p>
</li>
</ol>
<hr>
<h1 id="2-Hive-安装部署"><a href="#2-Hive-安装部署" class="headerlink" title="2 Hive 安装部署"></a>2 Hive 安装部署</h1><ol>
<li> 保证系统中已经配置了 <code>JAVA_HOME</code> 和 <code>HADOOP_HOME</code> 环境变量。</li>
<li> 配置 <code>HIVE_HOME</code>。</li>
<li> Hive 在启动时，默认会读取 <code>$HIVE_HOME/conf</code> 目录下的配置文件。</li>
</ol>
<p><strong>配置：</strong></p>
<ul>
<li><p>  如果需要自定义 Hive 的属性，需要在 <code>conf/hive-site.xml</code> 配置文件中配置自定义的属性</p>
</li>
<li><p>Hive 启动时，读取配置文件的顺序：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">① 由于 Hive 在使用时是依赖于 Hadoop 的，所以 Hive 启动时首先会读取 Hadoop 中的 8 个配置文件；</span><br><span class="line">==&gt; ② 读取 Hive 的默认配置文件：hive-default.xml</span><br><span class="line">==&gt; ③ 读取 Hive 的自定义配置文件：hive-site.xml</span><br><span class="line">==&gt; ④ 还可以在启动 Hive 时，通过命令行参数的方式，显式指定配置信息，但是这种方式只在当前次启动生效。[--hiveconf key=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-1-Hive-安装及配置"><a href="#2-1-Hive-安装及配置" class="headerlink" title="2.1    Hive 安装及配置"></a>2.1    Hive 安装及配置</h2><ol>
<li><p> 把 <code>apache-hive-1.2.1-bin.tar.gz</code> 上传到 Linux 的 <code>/opt/software</code> 目录下</p>
</li>
<li><p>解压 <code>apache-hive-1.2.1-bin.tar.gz</code> 到 <code>/opt/module/</code> 目录下面</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 software]$ tar -zxvf apache-hive-1.2.1-bin.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></li>
<li><p>重命名 <code>apache-hive-1.2.1-bin.tar.gz</code> 为 <code>hive</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 module]$ <span class="built_in">mv</span> apache-hive-1.2.1-bin/ hive</span><br></pre></td></tr></table></figure></li>
<li><p>备份 <code>/opt/module/hive/conf</code> 目录下的 <code>hive-env.sh.template</code> 为 <code>hive-env.sh</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 conf]$ <span class="built_in">cp</span> hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure></li>
<li><p>配置 <code>hive-env.sh</code> 文件</p>
<ul>
<li><p>配置 <code>HADOOP_HOME</code> 路径</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/opt/module/hadoop-2.7.2</span><br></pre></td></tr></table></figure></li>
<li><p>配置 <code>HIVE_CONF_DIR</code> 路径</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HIVE_CONF_DIR=/opt/module/hive/conf</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>配置 <code>HIVE_HOME</code></p>
<ul>
<li>  获取 Hive 安装路径</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 hive]$ <span class="built_in">pwd</span></span><br><span class="line">/opt/module/hive</span><br></pre></td></tr></table></figure>

<ul>
<li><p>编辑 <code>/etc/profile.d/my_env.sh</code> 文件</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile.d/my_env.sh</span><br></pre></td></tr></table></figure></li>
<li><p>在文件末尾添加 <code>HIVE_HOME</code></p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HIVE_HOME</span></span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/opt/module/hive</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HIVE_HOME</span>/bin</span><br></pre></td></tr></table></figure></li>
<li><p>测试配置是否生效</p>
<p>  <img src="/2021/12/17/Hive%E5%AE%89%E8%A3%85/image-20211218205539914.png" alt="image-20211218205539914"></p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-2-Hadoop-集群配置"><a href="#2-2-Hadoop-集群配置" class="headerlink" title="2.2    Hadoop 集群配置"></a>2.2    Hadoop 集群配置</h2><ol>
<li><p>必须启动 <code>HDFS</code> 和 <code>Yarn</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 conf]$ sbin/start-dfs.sh</span><br><span class="line">[lvnengdong@hadoop103 conf]$ sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 HDFS 上创建 <code>/tmp</code> 和 <code>/user/hive/warehouse</code> 两个目录并修改他们的同组权限可写</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -<span class="built_in">mkdir</span> /tmp</span><br><span class="line">[lvnengdong@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -<span class="built_in">mkdir</span> -p /user/hive/warehouse</span><br><span class="line">[lvnengdong@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -<span class="built_in">chmod</span> g+w /tmp</span><br><span class="line">[lvnengdong@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -<span class="built_in">chmod</span> g+w /user/hive/warehouse</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="2-3-Hive-基本操作"><a href="#2-3-Hive-基本操作" class="headerlink" title="2.3    Hive 基本操作"></a>2.3    Hive 基本操作</h2><ol>
<li><p>启动 Hive</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 ~]$ hive</span><br></pre></td></tr></table></figure></li>
<li><p>查看数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show databases;</span><br></pre></td></tr></table></figure></li>
<li><p>打开默认数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; use default;</span><br></pre></td></tr></table></figure></li>
<li><p>显示当前数据库下管理的所有表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show tables;</span><br></pre></td></tr></table></figure></li>
<li><p>创建一张表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table student(id int, name string);</span><br></pre></td></tr></table></figure></li>
<li><p>查看表的结构</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; desc student;</span><br></pre></td></tr></table></figure></li>
<li><p>向表中插入数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; insert into student values(10,&quot;zhangsan&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>查询表中数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * from student;</span><br></pre></td></tr></table></figure></li>
<li><p>退出 Hive</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; quit;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="3-将本地文件导入-Hive-中"><a href="#3-将本地文件导入-Hive-中" class="headerlink" title="3 将本地文件导入 Hive 中"></a>3 将本地文件导入 Hive 中</h1><h2 id="3-1-需求："><a href="#3-1-需求：" class="headerlink" title="3.1    需求："></a>3.1    需求：</h2><ul>
<li>  将本地 <code>/opt/module/datas/student.txt</code> 这个目录下的数据导入到 Hive 的 <code>student(id int, name string)</code> 表中。</li>
</ul>
<h2 id="3-2-数据准备"><a href="#3-2-数据准备" class="headerlink" title="3.2    数据准备"></a>3.2    数据准备</h2><p>在 <code>/opt/module/datas</code> 这个目录下准备数据。</p>
<ol>
<li><p>在 <code>/opt/module/</code> 目录下创建 datas 目录</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> datas</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>/opt/module/datas/</code> 目录下创建 <code>student.txt</code> 文件并添加数据</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 datas]$ <span class="built_in">touch</span> student.txt</span><br><span class="line">[lvnengdong@hadoop102 datas]$ vim student.txt</span><br></pre></td></tr></table></figure>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1001	zhangshan</span><br><span class="line">1002	lishi</span><br><span class="line">1003	zhaoliu</span><br></pre></td></tr></table></figure>
<ul>
<li>  注意：每行记录的字段之间以 Tab 键间隔。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-3-Hive-实际操作"><a href="#3-3-Hive-实际操作" class="headerlink" title="3.3    Hive 实际操作"></a>3.3    Hive 实际操作</h2><ol>
<li><p>启动 Hive</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 ~]$ hive</span><br></pre></td></tr></table></figure></li>
<li><p>显示数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show databases;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>default</code> 数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; use default;</span><br></pre></td></tr></table></figure></li>
<li><p>显示 <code>default</code> 数据库中的表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show tables;</span><br></pre></td></tr></table></figure></li>
<li><p>删除已创建的 <code>student</code> 表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; drop table student;</span><br></pre></td></tr></table></figure></li>
<li><p>创建 <code>student</code> 表，并声明文件分隔符 <code>&#39;\t&#39;</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; </span><br><span class="line">	create table student(id int, name string) </span><br><span class="line">	ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;\t&#x27;;	# 显式声明列与列之间的分隔符为 `\t` </span><br></pre></td></tr></table></figure></li>
<li><p>加载 <code>/opt/module/datas/student.txt</code> 文件到 <code>student</code> 数据库表中。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; load data local inpath &#x27;/opt/module/datas/student.txt&#x27; into table student;</span><br></pre></td></tr></table></figure></li>
<li><p>Hive 查询结果</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * from student;</span><br><span class="line">OK</span><br><span class="line">1001  zhangshan</span><br><span class="line">1002  lishi</span><br><span class="line">1003  zhaoliu</span><br><span class="line">Time taken: 0.266 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="3-4-遇到的问题"><a href="#3-4-遇到的问题" class="headerlink" title="3.4    遇到的问题"></a>3.4    遇到的问题</h2><p>再打开一个客户端窗口启动 Hive，会产生 <code>java.sql.SQLException</code> 异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.RuntimeException:</span><br><span class="line"> Unable to instantiate</span><br><span class="line"> org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</span><br><span class="line">        at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:522)</span><br><span class="line">        at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:677)</span><br><span class="line">        at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:621)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:606)</span><br><span class="line">        at org.apache.hadoop.util.RunJar.run(RunJar.java:221)</span><br><span class="line">        at org.apache.hadoop.util.RunJar.main(RunJar.java:136)</span><br><span class="line">Caused by: java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</span><br><span class="line">        at org.apache.hadoop.hive.metastore.MetaStoreUtils.newInstance(MetaStoreUtils.java:1523)</span><br><span class="line">        at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.&lt;init&gt;(RetryingMetaStoreClient.java:86)</span><br><span class="line">        at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.getProxy(RetryingMetaStoreClient.java:132)</span><br><span class="line">        at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.getProxy(RetryingMetaStoreClient.java:104)</span><br><span class="line">        at org.apache.hadoop.hive.ql.metadata.Hive.createMetaStoreClient(Hive.java:3005)</span><br><span class="line">        at org.apache.hadoop.hive.ql.metadata.Hive.getMSC(Hive.java:3024)</span><br><span class="line">        at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:503)</span><br><span class="line">... 8 more</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原因是：<code>Metastore</code> 默认存储在 Hive 自带的 <code>derby</code> 数据库中，推荐使用 <code>MySQL</code> 存储 <code>Metastore</code>。</p>
<hr>
<h1 id="4-MySQL-安装"><a href="#4-MySQL-安装" class="headerlink" title="4    MySQL 安装"></a>4    MySQL 安装</h1><ul>
<li>  <a href>超链接</a></li>
</ul>
<hr>
<h1 id="5-Hive-元数据配置到-MySQL"><a href="#5-Hive-元数据配置到-MySQL" class="headerlink" title="5    Hive 元数据配置到 MySQL"></a>5    Hive 元数据配置到 MySQL</h1><h2 id="5-1-驱动拷贝"><a href="#5-1-驱动拷贝" class="headerlink" title="5.1    驱动拷贝"></a>5.1    驱动拷贝</h2><p><code>Hive</code> 需要访问 MySQL 服务端，自身相当于是一个 MySQL 的客户端，所以需要安装一个 MySQL 客户端依赖。</p>
<ol>
<li><p>在 <code>/opt/software/mysql-libs</code> 目录下解压 <code>mysql-connector-java-5.1.27.tar.gz</code> 驱动包</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mysql-connector-java-5.1.27.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝 <code>/opt/software/mysql-libs/mysql-connector-java-5.1.27</code> 目录下的 <code>mysql-connector-java-5.1.27-bin.jar</code> 到 <code>/opt/module/hive/lib/</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> mysql-connector-java-5.1.27-bin.jar /opt/module/hive/lib/</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="5-2-配置-Metastore-到-MySQL"><a href="#5-2-配置-Metastore-到-MySQL" class="headerlink" title="5.2    配置 Metastore 到 MySQL"></a>5.2    配置 Metastore 到 MySQL</h2><ol>
<li><p>在<code>/opt/module/hive/conf</code>目录下创建一个<code>hive-site.xml</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> hive-site.xml</span><br><span class="line">vim hive-site.xml</span><br></pre></td></tr></table></figure>

</li>
<li><p>根据官方文档配置参数，拷贝数据到<code>hive-site.xml</code>文件中</p>
<ul>
<li>  官方文档：<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+MetastoreAdmin">https://cwiki.apache.org/confluence/display/Hive/AdminManual+MetastoreAdmin</a></li>
</ul>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Hive连接哪个库来查找元数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://hadoop102:3306/metastore?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p> 配置完毕后，如果启动 Hive 异常，可以重新启动虚拟机。（重启后，别忘了启动 Hadoop 集群）</p>
</li>
</ol>
<hr>
<h2 id="5-3-多窗口启动Hive测试"><a href="#5-3-多窗口启动Hive测试" class="headerlink" title="5.3    多窗口启动Hive测试"></a>5.3    多窗口启动Hive测试</h2><ol>
<li><p>先启动 MySQL</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p000000</span><br></pre></td></tr></table></figure></li>
<li><p>查看有几个数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database      |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql       |</span><br><span class="line">| performance_schema |</span><br><span class="line">| test        |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次打开多个窗口，分别启动 <code>hive</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hive</span><br></pre></td></tr></table></figure>

</li>
<li><p>启动 Hive 后，回到 MySQL 窗口查看数据库，显示增加了 <code>metastore</code> 数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line"></span><br><span class="line">+--------------------+</span><br><span class="line">| Database      |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| metastore     |</span><br><span class="line">| mysql       |</span><br><span class="line">| performance_schema |</span><br><span class="line">| test        |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="6-HiveJDBC-访问"><a href="#6-HiveJDBC-访问" class="headerlink" title="6    HiveJDBC 访问"></a>6    HiveJDBC 访问</h1><ol>
<li><p>启动 JDBC 的服务端进程：<code>hiveserver2</code> </p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 ~]$ hiveserver2</span><br></pre></td></tr></table></figure>

<p> <code>hiveserver2 </code>是一个前台进程，启动后控制台界面就不能动了，所以需要再新开一个 shell 窗口启动客户端进程 <code>beeline</code></p>
</li>
<li><p>启动 JDBC 的客户端：</p>
<ul>
<li><p>启动客户端进程 <code>beeline</code>。<code>beeline</code> 是一种 JDBC 客户端的实现方式</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    [lvnengdong@hadoop102 ~]$ beeline</span><br><span class="line">    Beeline version 1.2.1 by Apache Hive</span><br><span class="line">beeline&gt; </span><br></pre></td></tr></table></figure></li>
<li><p>  使用其它的 JDBC 客户端</p>
</li>
</ul>
</li>
<li><p>连接 <code>hiveserver2</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">beeline&gt; !connect jdbc:hive2://hadoop102:10000（回车）</span><br><span class="line">Connecting to jdbc:hive2://hadoop102:10000</span><br><span class="line">Enter username <span class="keyword">for</span> jdbc:hive2://hadoop102:10000: lvnengdong（回车）</span><br><span class="line">Enter password <span class="keyword">for</span> jdbc:hive2://hadoop102:10000: （直接回车）</span><br><span class="line">Connected to: Apache Hive (version 1.2.1)</span><br><span class="line">Driver: Hive JDBC (version 1.2.1)</span><br><span class="line">Transaction isolation: TRANSACTION_REPEATABLE_READ</span><br><span class="line">0: jdbc:hive2://hadoop102:10000&gt; show databases;</span><br><span class="line">+----------------+--+</span><br><span class="line">| database_name  |</span><br><span class="line">+----------------+--+</span><br><span class="line">| default        |</span><br><span class="line">+----------------+--+</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="IDEA-连接-Hive"><a href="#IDEA-连接-Hive" class="headerlink" title="IDEA 连接 Hive"></a>IDEA 连接 Hive</h2><hr>
<h1 id="7-Hive-常用交互命令"><a href="#7-Hive-常用交互命令" class="headerlink" title="7    Hive 常用交互命令"></a>7    Hive 常用交互命令</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 conf]$ hive --<span class="built_in">help</span></span><br><span class="line">Usage ./hive &lt;parameters&gt; --service serviceName &lt;service parameters&gt;</span><br><span class="line">Service List: beeline cli <span class="built_in">help</span> hiveburninclient hiveserver2 hiveserver hwi jar lineage metastore metatool orcfiledump rcfilecat schemaTool version </span><br><span class="line">Parameters parsed:</span><br><span class="line">  --auxpath : Auxillary jars </span><br><span class="line">  --config : Hive configuration directory</span><br><span class="line">  --service : Starts specific service/component. cli is default</span><br><span class="line">Parameters used:</span><br><span class="line">  HADOOP_HOME or HADOOP_PREFIX : Hadoop install directory</span><br><span class="line">  HIVE_OPT : Hive options</span><br><span class="line">For <span class="built_in">help</span> on a particular service:</span><br><span class="line">  ./hive --service serviceName --<span class="built_in">help</span></span><br><span class="line">Debug <span class="built_in">help</span>:  ./hive --debug --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[lvnengdong@hadoop102 hive]$ hive -<span class="built_in">help</span></span><br><span class="line">usage: hive</span><br><span class="line">-d,--define &lt;key=value&gt;          Variable subsitution to apply to hive</span><br><span class="line">commands. e.g. -d A=B or --define A=B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定启动Hive之后要连接的数据库</span></span><br><span class="line">--database &lt;databasename&gt;     Specify the database to use</span><br><span class="line">-e &lt;quoted-query-string&gt;         SQL from <span class="built_in">command</span> line</span><br><span class="line">-f &lt;filename&gt;                    SQL from files</span><br><span class="line">-H,--<span class="built_in">help</span>                        Print <span class="built_in">help</span> information</span><br><span class="line">--hiveconf &lt;property=value&gt;   Use value <span class="keyword">for</span> given property</span><br><span class="line">--hivevar &lt;key=value&gt;         Variable subsitution to apply to hive</span><br><span class="line">commands. e.g. --hivevar A=B</span><br><span class="line">-i &lt;filename&gt;                    Initialization SQL file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静默模式，即在控制台上不打印无关的信息</span></span><br><span class="line">-S,--silent                      Silent mode <span class="keyword">in</span> interactive shell</span><br><span class="line">-v,--verbose                     Verbose mode (<span class="built_in">echo</span> executed SQL to the console)</span><br></pre></td></tr></table></figure>



<ol>
<li><p> <code>-d</code>：定义一个 <code>变量名=变量值</code>，在 <code>hive-cli</code> 中可以通过 <code>$&#123;变量名&#125;</code> 来引用变量值。</p>
</li>
<li><p><code>-e</code>：不进入 Hive 的交互窗口执行 SQL 语句</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hive -e <span class="string">&quot;select id from student;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>-f</code>：执行脚本中 SQL 语句</p>
<ul>
<li>  在 <code>/opt/module/datas</code> 目录下创建 <code>hivef.sql</code> 文件</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 datas]$ <span class="built_in">touch</span> hivef.sql</span><br></pre></td></tr></table></figure>

<ul>
<li>  文件中写入正确的 <code>sql</code> 语句</li>
</ul>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>

<ul>
<li>  执行文件中的 <code>sql</code> 语句</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 hive]$ bin/hive -f /opt/module/datas/hivef.sql</span><br></pre></td></tr></table></figure>

<ul>
<li>  执行文件中的sql语句并将结果写入文件中</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lvnengdong@hadoop102 hive]$ bin/hive -f /opt/module/datas/hivef.sql &gt; /opt/module/datas/hive_result.txt</span><br></pre></td></tr></table></figure></li>
<li><p> <code>--hiveconf key=value</code>：在 <code>hive-cli</code> 启动之前显式指定一组属性。</p>
</li>
</ol>
<hr>
<h1 id="8-Hive-其他命令操作"><a href="#8-Hive-其他命令操作" class="headerlink" title="8    Hive 其他命令操作"></a>8    Hive 其他命令操作</h1><ol>
<li><p> 在 Hive 中使用 HDFS </p>
</li>
<li><p>在 Hive 中使用 shell 命令</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!shell 命令</span><br></pre></td></tr></table></figure>

</li>
<li><p>退出 <code>Hive</code> 窗口</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive(default)&gt;exit;</span><br><span class="line">hive(default)&gt;quit;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	在新版的hive中没区别了，在以前的版本是有的：</span><br><span class="line">		exit：先隐性提交数据，再退出；</span><br><span class="line">		quit：不提交数据，退出；</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

</li>
<li><p>在 <code>hive cli</code> 命令窗口中如何查看 <code>HDFS</code> 文件系统</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive(default)&gt;dfs -<span class="built_in">ls</span> /;</span><br></pre></td></tr></table></figure>

</li>
<li><p>在 <code>hive cli</code> 命令窗口中如何查看本地文件系统(Linux)</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive(default)&gt;!ls /opt/module;</span><br></pre></td></tr></table></figure>

</li>
<li><p>查看在hive中输入的所有历史命令</p>
<ul>
<li>  （1）进入到当前用户的根目录 <code>/root</code> 或 <code>/home/atguigu</code></li>
<li>  （2）查看 <code>.hivehistory</code> 文件</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> .hivehistory</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="9-Hive-常见属性配置"><a href="#9-Hive-常见属性配置" class="headerlink" title="9    Hive 常见属性配置"></a>9    Hive 常见属性配置</h1><h2 id="9-1-Hive-数据仓库位置配置"><a href="#9-1-Hive-数据仓库位置配置" class="headerlink" title="9.1    Hive 数据仓库位置配置"></a>9.1    Hive 数据仓库位置配置</h2><ol>
<li><p> <code>Hive</code> 安装完成后会默认生成一个 <code>default</code> 数据库，我们在创建表时如果没有显式指定数据库的话，创建的表就保存在该数据库下，该数据库默认保存数据的位置是在 <code>HDFS</code> 上的 <code>/user/hive/warehouse</code> 路径下。</p>
</li>
<li><p> 在仓库目录下，没有对默认的数据库 <code>default</code> 创建文件夹，如果某张表属于 <code>default</code> 数据库，直接在数据仓库目录下创建一个文件夹。</p>
</li>
<li><p>修改 <code>default</code> 数据库的默认位置（将 <code>hive-default.xml.template</code> 如下配置信息拷贝到 <code>hive-site.xml</code> 文件中）。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>location of default database for the warehouse<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">==&gt;修改为：</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/hive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>location of default database for the warehouse<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置同组用户有执行权限</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs dfs -<span class="built_in">chmod</span> g+w /user/hive/warehouse</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="9-2-查询后信息显示配置"><a href="#9-2-查询后信息显示配置" class="headerlink" title="9.2    查询后信息显示配置"></a>9.2    查询后信息显示配置</h2><ol>
<li><p>在 <code>hive-site.xml</code> 文件中添加如下配置信息，就可以实现显示当前数据库，以及查询表的头信息配置。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.header<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.current.db<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>重新启动 <code>Hive</code>，对比配置前后差异。</p>
<ul>
<li>  <code>Before</code></li>
</ul>
<p> <img src="/2021/12/17/Hive%E5%AE%89%E8%A3%85/clip_image002.jpg" alt="img"></p>
<ul>
<li>  <code>After</code></li>
</ul>
</li>
</ol>
<p><img src="/2021/12/17/Hive%E5%AE%89%E8%A3%85/clip_image004.jpg" alt="img"></p>
<hr>
<h3 id="9-3-Hive-运行日志信息配置"><a href="#9-3-Hive-运行日志信息配置" class="headerlink" title="9.3    Hive 运行日志信息配置"></a>9.3    Hive 运行日志信息配置</h3><p><code>Hive</code> 的日志文件 <code>log</code> 默认存放在 <code>/tmp/$&#123;用户名&#125;/hive.log</code> 目录下。</p>
<p>修改 <code>Hive</code> 日志存放的目录为 <code>/opt/module/hive/logs</code>。</p>
<ol>
<li><p>备份 <code>/opt/module/hive/conf/hive-log4j.properties.template</code> 文件为 <code>hive-log4j.properties</code></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atguigu@hadoop102 conf]$ <span class="built_in">pwd</span></span><br><span class="line">/opt/module/hive/conf</span><br><span class="line">[atguigu@hadoop102 conf]$ <span class="built_in">cp</span> hive-log4j.properties.template hive-log4j.properties</span><br></pre></td></tr></table></figure>

</li>
<li><p>在 <code>hive-log4j.properties</code> 文件中修改 <code>log</code> 存放位置</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive.log.dir=/opt/module/hive/logs</span><br></pre></td></tr></table></figure></li>
<li><p>重新启动 <code>hive</code> 时就会发现日志文件目录已经发生了改变</p>
<p> <img src="/2021/12/17/Hive%E5%AE%89%E8%A3%85/image-20211219112048028.png" alt="image-20211219112048028"></p>
</li>
</ol>
<hr>
<h2 id="9-4-参数配置方式"><a href="#9-4-参数配置方式" class="headerlink" title="9.4    参数配置方式"></a>9.4    参数配置方式</h2><p>查看当前所有的配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;set;</span><br></pre></td></tr></table></figure>

<p>参数的配置三种方式</p>
<ol>
<li><p>配置文件方式</p>
<ul>
<li>  默认配置文件：<code>hive-default.xml</code></li>
<li>  用户自定义配置文件：<code>hive-site.xml</code></li>
<li>  注意：用户自定义配置会覆盖默认配置。另外，Hive 也会读入 Hadoop 的配置，因为 Hive 是作为 Hadoop 的客户端启动的，Hive 的配置会覆盖 Hadoop 的配置。配置文件的设定对本机启动的所有 Hive 进程都有效。</li>
</ul>
</li>
<li><p>命令行参数方式：</p>
<ul>
<li><p>  启动 Hive 时，可以在命令行添加 <code>-hiveconf param=value</code> 来设定参数。</p>
</li>
<li><p>例如：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop103 hive]$ bin/hive -hiveconf mapred.reduce.tasks=10;</span><br></pre></td></tr></table></figure></li>
<li><p>  注意：仅对本次 Hive 启动有效</p>
</li>
<li><p>查看参数设置：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; set mapred.reduce.tasks;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>参数声明方式：</p>
<ul>
<li><p>  可以在 <code>HQL</code> 中使用 <code>SET</code> 关键字设定参数</p>
</li>
<li><p>例如：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; set mapred.reduce.tasks=100;</span><br></pre></td></tr></table></figure>

</li>
<li><p>  注意：仅对本次 Hive 启动有效。</p>
</li>
<li><p>查看参数设置：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; <span class="built_in">set</span> mapred.reduce.tasks;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>上述三种设定方式的优先级依次递增。即 <code>配置文件&lt;命令行参数&lt;参数声明</code>。注意某些系统级的参数，例如 <code>log4j</code> 相关的设定，必须用前两种方式设定，因为那些参数的读取在会话建立以前已经完成了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/13/Hive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/13/Hive/" class="post-title-link" itemprop="url">Hive</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-13 16:21:50" itemprop="dateCreated datePublished" datetime="2021-12-13T16:21:50+08:00">2021-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-30 12:59:33" itemprop="dateModified" datetime="2022-01-30T12:59:33+08:00">2022-01-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hive/" itemprop="url" rel="index"><span itemprop="name">Hive</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>官网地址：<a target="_blank" rel="noopener" href="https://hive.apache.org/">https://hive.apache.org/</a></p>
<h1 id="第1章-Hive入门"><a href="#第1章-Hive入门" class="headerlink" title="第1章 Hive入门"></a>第1章 Hive入门</h1><h2 id="1-1-什么是Hive"><a href="#1-1-什么是Hive" class="headerlink" title="1.1 什么是Hive"></a>1.1 什么是Hive</h2><p>Hive 是一个由 Facebook 开源的用于解决海量<strong>结构化数据</strong>统计分析的框架。</p>
<p>Hive 只能分析结构化的数据。所以在使用 Hive 之前，需要先对非结构化数据进行 ETL ，转换为结构化的数据。</p>
<p>Hive 是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类 SQL 查询功能。</p>
<p><strong>Hive 的底层实现原理是：将 HQL 转化成 MapReduce 程序执行。</strong></p>
<p><img src="/2021/12/13/Hive/clip_image002.png" alt="img">   </p>
<ol>
<li> Hive 处理的数据存储在 HDFS 上。</li>
<li> Hive 分析数据底层的实现是 MapReduce</li>
<li> 执行程序运行在 Yarn 上</li>
</ol>
<h3 id="Hive的本质"><a href="#Hive的本质" class="headerlink" title="Hive的本质"></a>Hive的本质</h3><p>Hive 不提供存储功能，通过 Hive 创建的库/表中的业务数据都会以文件的形式存放在 HDFS 上。</p>
<p>与此同时，在建库/表后，会在 MySQL 中生成对应的 <code>schema</code> 数据库存储元数据信息。元数据信息以表的形式存储，常见的表有：</p>
<ul>
<li>  <code>tbls</code>：存放表相关的元数据信息</li>
<li>  <code>dbs</code>：存放库相关的元数据信息</li>
<li>  <code>column_v2</code>：存放列相关的元数据信息 </li>
</ul>
<p><img src="/2021/12/13/Hive/image-20220124205740685.png" alt="image-20220124205740685"></p>
<hr>
<h2 id="1-2-Hive的优缺点"><a href="#1-2-Hive的优缺点" class="headerlink" title="1.2 Hive的优缺点"></a>1.2 Hive的优缺点</h2><h3 id="1-2-1-优点"><a href="#1-2-1-优点" class="headerlink" title="1.2.1 优点"></a>1.2.1 优点</h3><ol>
<li> 操作接口采用类SQL语法，提供快速开发的能力（简单、容易上手）。</li>
<li> 避免了去写 MapReduce 程序，减少开发人员的学习成本。</li>
<li> Hive 的执行延迟比较高，因此 Hive 常用于数据分析，对实时性要求不高的场合。</li>
<li> Hive 的优势在于处理大数据，对于处理小数据没有优势，因为 Hive 的执行延迟比较高。</li>
<li> Hive 支持用户自定义函数，用户可以根据需求实现自己的函数。</li>
</ol>
<hr>
<h3 id="1-2-2-缺点"><a href="#1-2-2-缺点" class="headerlink" title="1.2.2 缺点"></a>1.2.2 缺点</h3><ol>
<li>Hive 的 HQL 表达能力有限<ul>
<li>  迭代式算法无法表达</li>
<li>  数据挖掘方面不擅长</li>
</ul>
</li>
<li>Hive 的效率比较低<ul>
<li>  Hive 自动生成的 MapReduce Job，通常情况下不够智能化</li>
<li>  Hive 调优比较困难，粒度较粗</li>
</ul>
</li>
</ol>
<hr>
<h2 id="1-3-Hive架构原理"><a href="#1-3-Hive架构原理" class="headerlink" title="1.3 Hive架构原理"></a>1.3 Hive架构原理</h2><p><img src="/2021/12/13/Hive/clip_image002-1639754524896.png" alt="img"></p>
<ol>
<li><strong>用户接口：Client</strong><ul>
<li>  CLI（Hive shell）、JDBC/ODBC（Java 访问 Hive）、WEBUI（浏览器访问 Hive）</li>
</ul>
</li>
<li><strong>元数据：Metastore</strong><ul>
<li>  元数据包括：表名、表所属的数据库（默认属于default数据库）、表的拥有者、列/分区字段、表的类型（是否为外部表）、表的数据所在目录等；</li>
<li>  元数据默认存储在 Hive 自带的 <code>derby</code> 数据库中。推荐使用 MySQL 的 <code>metastore</code> 数据库存储数据。</li>
</ul>
</li>
<li><strong>Hadoop</strong><ul>
<li>  使用 HDFS 存储业务数据，使用 MapReduce 进行计算。</li>
</ul>
</li>
<li><strong>驱动器：Driver</strong><ul>
<li>  <strong>解析器（SQL Parser）</strong>：将 SQL 字符串转换成抽象语法树 AST，这一步一般都用第三方工具库完成，比如 <code>antlr</code>；对 AST 进行语法分析，比如表是否存在、字段是否存在、SQL 语义是否有误。</li>
<li>  <strong>编译器（Physical Plan）</strong>：将 AST 编译，生成逻辑执行计划。</li>
<li>  <strong>优化器（Query Optimizer）</strong>：对逻辑执行计划进行优化。</li>
<li>  <strong>执行器（Execution）</strong>：把逻辑执行计划转换成可以运行的物理计划。对于 Hive 来说，就是 <code>MapReduce/Spark</code>。</li>
</ul>
</li>
</ol>
<p><img src="/2021/12/13/Hive/clip_image006.png" alt="img"></p>
<p>Hive 通过给用户提供的一系列交互接口，接收到用户的**指令(SQL)<strong>，使用自己的 <strong>Driver</strong>，结合</strong>元数据(MetaStore)**，将这些指令翻译成 MapReduce Job，提交到 Hadoop 中执行，最后，将执行返回的结果输出到用户交互接口。</p>
<hr>
<h2 id="1-4-Hive和数据库比较"><a href="#1-4-Hive和数据库比较" class="headerlink" title="1.4 Hive和数据库比较"></a>1.4 Hive和数据库比较</h2><p>由于 Hive 采用了类 SQL 查询语言 <code>HQL(Hive Query Language)</code>，因此很容易将 Hive 理解为数据库。其实从结构上来看，Hive 和数据库除了拥有类似的查询语言，再无类似之处。本文将从多个方面来阐述 Hive 和数据库的差异。数据库可以用在 Online 的应用中，但是Hive 是为数据仓库而设计的，清楚这一点，有助于从应用角度理解 Hive 的特性。</p>
<hr>
<h3 id="1-4-1-查询语言"><a href="#1-4-1-查询语言" class="headerlink" title="1.4.1 查询语言"></a>1.4.1 查询语言</h3><p>由于 SQL 被广泛的应用在数据仓库中，因此，专门针对 Hive 的特性设计了类 SQL 的查询语言 HQL。熟悉 SQL 开发的开发者可以很方便的使用 Hive 进行开发。</p>
<h3 id="1-4-2-数据存储位置"><a href="#1-4-2-数据存储位置" class="headerlink" title="1.4.2 数据存储位置"></a>1.4.2 数据存储位置</h3><p>Hive 是建立在 Hadoop 之上的，所有 Hive 的数据都是存储在 HDFS 中的。而数据库则可以将数据保存在块设备或者本地文件系统中。</p>
<h3 id="1-4-3-数据更新"><a href="#1-4-3-数据更新" class="headerlink" title="1.4.3 数据更新"></a>1.4.3 数据更新</h3><p>由于 Hive 是针对数据仓库应用设计的，而数据仓库的内容是读多写少的。因此，Hive 中不建议对数据的改写，所有的数据都是在加载的时候确定好的。而数据库中的数据通常是需要经常进行修改的，因此会经常使用 <code>INSERT INTO … VALUES</code> 添加数据，使用 <code>UPDATE … SET</code> 修改数据。</p>
<h3 id="1-4-4-索引"><a href="#1-4-4-索引" class="headerlink" title="1.4.4 索引"></a>1.4.4 索引</h3><p>Hive 在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此也没有对数据中的某些 key 建立索引。Hive 要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高。</p>
<p>由于 MapReduce 的引入， Hive 可以并行访问数据，因此即使没有索引，对于大数据量的访问，Hive 仍然可以体现出优势。数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。由于数据的访问延迟较高，决定了 Hive 不适合在线数据查询。</p>
<h3 id="1-4-5-执行"><a href="#1-4-5-执行" class="headerlink" title="1.4.5 执行"></a>1.4.5 执行</h3><p>Hive 中的查询操作默认是通过 Hadoop 提供的 MapReduce 计算框架来实现的。而数据库通常有自己的执行引擎。</p>
<h3 id="1-4-6-执行延迟"><a href="#1-4-6-执行延迟" class="headerlink" title="1.4.6 执行延迟"></a>1.4.6 执行延迟</h3><p>Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。</p>
<p>另外一个导致 Hive 执行延迟高的因素是 MapReduce 框架。由于 MapReduce 本身具有较高的延迟，因此在利用 MapReduce 执行 Hive 查询时，也会有较高的延迟。</p>
<p>相对的，数据库的执行延迟较低。当然这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive 的并行计算显然能体现出优势。</p>
<h3 id="1-4-7-可扩展性"><a href="#1-4-7-可扩展性" class="headerlink" title="1.4.7 可扩展性"></a>1.4.7 可扩展性</h3><p>由于 Hive 是建立在 Hadoop 之上的，因此 Hive 的可扩展性是和 Hadoop 的可扩展性是一致的（世界上最大的 Hadoop 集群在 Yahoo，2009 年的规模在 4000 台节点左右）。而数据库由于 ACID 语义的严格限制，扩展行非常有限。目前最先进的并行数据库 Oracle 在理论上的扩展能力也只有 100 台左右。</p>
<h3 id="1-4-8-数据规模"><a href="#1-4-8-数据规模" class="headerlink" title="1.4.8 数据规模"></a>1.4.8 数据规模</h3><p>由于 Hive 建立在集群上并可以利用 MapReduce 进行并行计算，因此可以支持很大规模的数据；</p>
<p>对应的，数据库可以支持的数据规模较小。</p>
<hr>
<h1 id="第2章-Hive安装"><a href="#第2章-Hive安装" class="headerlink" title="第2章 Hive安装"></a>第2章 Hive安装</h1><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/12/17/Hive%E5%AE%89%E8%A3%85/">Hive安装</a></li>
</ul>
<hr>
<h1 id="第3章-Hive数据类型"><a href="#第3章-Hive数据类型" class="headerlink" title="第3章 Hive数据类型"></a>第3章 Hive数据类型</h1><p>Hive 是用 Java 语言实现的，所以 Hive 中的所有数据类型底层还是使用的 Java 数据类型。</p>
<h2 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h2><table>
<thead>
<tr>
<th>Hive数据类型</th>
<th>Java数据类型</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td><code>TINYINT</code></td>
<td><code>byte</code></td>
<td><code>1byte</code></td>
</tr>
<tr>
<td><code>SMALLINT</code></td>
<td><code>short</code></td>
<td><code>2byte</code></td>
</tr>
<tr>
<td><code>INT</code></td>
<td><code>int</code></td>
<td><code>4byte</code></td>
</tr>
<tr>
<td><code>BIGINT</code></td>
<td><code>long</code></td>
<td><code>8byte</code></td>
</tr>
<tr>
<td><code>BOOLEAN</code></td>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>FLOAT</code></td>
<td><code>float</code></td>
<td>单精度浮点数</td>
</tr>
<tr>
<td><code>DOUBLE</code></td>
<td><code>double</code></td>
<td>双精度浮点数</td>
</tr>
<tr>
<td><code>STRING</code></td>
<td><code>string</code></td>
<td></td>
</tr>
<tr>
<td><code>TIMESTAMP</code></td>
<td></td>
<td>时间类型</td>
</tr>
<tr>
<td><code>BINARY</code></td>
<td></td>
<td>字节数组</td>
</tr>
</tbody></table>
<p>Hive 的 String 类型相当于数据库的 varchar 类型，该类型是一个可变的字符串，不过它不能声明其中最多能存储多少个字符，理论上它可以存储 2GB 的字符数。</p>
<hr>
<h2 id="3-2-集合数据类型"><a href="#3-2-集合数据类型" class="headerlink" title="3.2 集合数据类型"></a>3.2 集合数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>语法示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>STRUCT</strong></td>
<td>和 C 语言中的 <code>struct</code> 类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是 <code>STRUCT&#123;first STRING, last STRING&#125;</code>，那么第 1 个元素可以通过 <code>字段.first</code> 来引用。</td>
<td><code>struct()</code></td>
</tr>
<tr>
<td><code>MAP</code></td>
<td>MAP 是一组键值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是 MAP，其中键值对是 <code>’first’-&gt;’John’</code> 和 <code>’last’-&gt;’Doe’</code>，那么可以通过 <code>字段名[‘last’]</code> 获取最后一个元素</td>
<td><code>map()</code></td>
</tr>
<tr>
<td><code>ARRAY</code></td>
<td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为 <code>[‘John’,  ‘Doe’]</code>，那么第 2 个元素可以通过 <code>数组名[1]</code> 进行引用。</td>
<td><code>Array()</code></td>
</tr>
</tbody></table>
<p>Hive 有三种复杂数据类型 <code>ARRAY</code>、<code>MAP</code> 和 <code>STRUCT</code>。<code>ARRAY</code> 和 <code>MAP</code> 与 Java 中的 <code>Array</code> 和 <code>Map</code> 类似，而 <code>STRUCT</code> 与 C 语言中的<code>Struct</code> 类似，它封装了一个命名字段集合，复杂数据类型允许任意层次的嵌套。</p>
<h3 id="案例实操"><a href="#案例实操" class="headerlink" title="案例实操"></a>案例实操</h3><ol>
<li><p>假设某表有如下一行，我们用 JSON 格式来表示其数据结构。在 <code>Hive</code> 下访问的格式为：</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;songsong&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;friends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;bingbing&quot;</span> <span class="punctuation">,</span> <span class="string">&quot;lili&quot;</span><span class="punctuation">]</span> <span class="punctuation">,</span>       <span class="comment">//列表Array, </span></span><br><span class="line">    <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                      <span class="comment">//键值Map,</span></span><br><span class="line">        <span class="attr">&quot;xiao song&quot;</span><span class="punctuation">:</span> <span class="number">18</span> <span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;xiaoxiao song&quot;</span><span class="punctuation">:</span> <span class="number">19</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                      <span class="comment">//结构Struct,</span></span><br><span class="line">        <span class="attr">&quot;street&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hui long guan&quot;</span> <span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;beijing&quot;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>基于上述数据结构，我们在 Hive 里创建对应的表，并导入数据。</p>
<ul>
<li>  创建本地测试文件 <code>test.txt</code></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">songsong,bingbing_lili,xiao song:18_xiaoxiao song:19,hui long guan_beijing</span><br><span class="line">yangyang,caicai_susu,xiao yang:18_xiaoxiao yang:19,chao yang_beijing</span><br></pre></td></tr></table></figure>

<ul>
<li>  注意：<code>MAP</code>，<code>STRUCT</code> 和 <code>ARRAY</code> 里的元素间的分隔符都可以用同一个字符表示，这里用 <code>_</code>。</li>
</ul>
</li>
<li><p>  <code>Hive</code> 上创建测试表 <code>test</code></p>
</li>
</ol>
<pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">    name string,</span><br><span class="line">    friends <span class="keyword">array</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span>,</span><br><span class="line">    children map<span class="operator">&lt;</span>string, <span class="type">int</span><span class="operator">&gt;</span>,</span><br><span class="line">    address struct<span class="operator">&lt;</span>street:string, city:string<span class="operator">&gt;</span></span><br><span class="line">)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">collection items terminated <span class="keyword">by</span> <span class="string">&#x27;_&#x27;</span></span><br><span class="line">map keys terminated <span class="keyword">by</span> <span class="string">&#x27;:&#x27;</span></span><br><span class="line">lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">字段解释：</span><br><span class="line"></span><br><span class="line">    <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> <span class="comment">-- 列分隔符</span></span><br><span class="line">    collection items terminated <span class="keyword">by</span> <span class="string">&#x27;_&#x27;</span>     <span class="comment">--MAP STRUCT 和 ARRAY 的分隔符(数据分割符号)</span></span><br><span class="line">    map keys terminated <span class="keyword">by</span> <span class="string">&#x27;:&#x27;</span>               <span class="comment">-- MAP中的key与value的分隔符</span></span><br><span class="line">    lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;                  <span class="comment">-- 行分隔符</span></span><br><span class="line"><span class="comment">--------------</span></span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="4">
<li><p>导入文本数据到测试表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#x27;/home/lvnengdong/mytmp/test.txt&#x27; into table test;</span><br></pre></td></tr></table></figure></li>
<li><p>访问三种集合列里的数据，以下分别是 <code>ARRAY</code>，<code>MAP</code>，<code>STRUCT</code> 的访问方式</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	select friends[1],children[&#x27;xiao song&#x27;],address.city </span><br><span class="line">	from test</span><br><span class="line">	where name=&quot;songsong&quot;;</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line">_c0     _c1     city</span><br><span class="line">lili    18      beijing</span><br><span class="line">Time taken: 0.076 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="3-3-类型转化"><a href="#3-3-类型转化" class="headerlink" title="3.3 类型转化"></a>3.3 类型转化</h2><p><code>Hive</code> 的原子数据类型是可以进行隐式转换的，类似于 Java 的类型转换，例如某表达式使用 <code>INT</code> 类型，<code>TINYINT</code> 会自动转换为 <code>INT</code> 类型，但是 <code>Hive</code> 不会进行反向转化，例如，某表达式使用 <code>TINYINT</code> 类型，<code>INT</code> 不会自动转换为 <code>TINYINT</code> 类型，它会返回错误，除非使用 <code>CAST</code> 操作。</p>
<p><strong>一、隐式类型转换规则如下：</strong></p>
<ol>
<li> 任何整数类型都可以隐式地转换为一个范围更广的类型，如 <code>TINYINT</code> 可以转换成 <code>INT</code>，<code>INT</code> 可以转换成 <code>BIGINT</code>。</li>
<li> <code>所有整数类型</code>、<code>FLOAT</code> 和 <code>STRING</code> 类型都可以隐式地转换成 <code>DOUBLE</code>。</li>
<li> <code>TINYINT</code>、<code>SMALLINT</code>、<code>INT</code> 都可以转换为 <code>FLOAT</code>。</li>
<li> <code>BOOLEAN</code> 类型<strong>不可以</strong>转换为任何其它的类型。</li>
</ol>
<p><strong>二、可以使用 <code>CAST</code> 操作显式进行数据类型转换</strong></p>
<p>例如 <code>CAST(&#39;1&#39; AS INT)</code> 将把 <code>字符串&#39;1&#39;</code> 转换成 <code>整数1</code>；如果强制类型转换失败，如执行 <code>CAST(&#39;X&#39; AS INT)</code>，表达式返回空值 <code>NULL</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select cast(&quot;1&quot; AS int);</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="第4章-DDL"><a href="#第4章-DDL" class="headerlink" title="第4章 DDL"></a>第4章 DDL</h1><blockquote>
<p>  <strong>DDL；Data Definition Language；数据定义语言</strong></p>
</blockquote>
<h2 id="4-1-库操作"><a href="#4-1-库操作" class="headerlink" title="4.1 库操作"></a>4.1 库操作</h2><h3 id="4-1-1-增：创建数据库"><a href="#4-1-1-增：创建数据库" class="headerlink" title="4.1.1 增：创建数据库"></a>4.1.1 增：创建数据库</h3><p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE [REMOTE] (DATABASE|SCHEMA) [IF NOT EXISTS] database_name		# DATABASE 和 SCHEMA 都表示创建数据库，DATABASE 在新版本中使用，SCHEMA 在老版本中使用</span><br><span class="line">  [COMMENT database_comment]	# 关于数据库的注释</span><br><span class="line">  [LOCATION hdfs_path]	# 数据库在 HDFS 上的路径</span><br><span class="line">  [MANAGEDLOCATION hdfs_path]</span><br><span class="line">  [WITH DBPROPERTIES (property_name=property_value, ...)];	# 库的 dbproperties 属性</span><br></pre></td></tr></table></figure>



<p><strong>Demo：</strong></p>
<ol>
<li><p>使用默认配置创建数据库。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; create database if not exists db_hive;</span><br></pre></td></tr></table></figure>

<ul>
<li>  数据库在 HDFS 上的默认存储路径是 <code>/user/hive/warehouse/*.db</code></li>
</ul>
</li>
<li><p>创建数据库时手动指定数据库在 HDFS 上的存储路径。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">create database db_hive2 \</span><br><span class="line">location &#x27;/custom_hive.db&#x27;;</span><br></pre></td></tr></table></figure>

<p> <img src="/2021/12/13/Hive/image-20211219121900037.png" alt="image-20211219121900037"></p>
</li>
</ol>
<hr>
<h3 id="4-1-2-删：删除数据库"><a href="#4-1-2-删：删除数据库" class="headerlink" title="4.1.2 删：删除数据库"></a>4.1.2 删：删除数据库</h3><p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 情况1： </span><br><span class="line">drop database 库名;   # drop 只能删除空数据库</span><br><span class="line"></span><br><span class="line"># 情况2：</span><br><span class="line">drop database db_hive cascade;  # 强制删除，可以删除非空的库</span><br></pre></td></tr></table></figure>



<p><strong>Demo：</strong></p>
<ol>
<li><p>删除空数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; drop database if exists db_hive;</span><br></pre></td></tr></table></figure></li>
<li><p>删除非空数据库。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; drop database db_hive;</span><br><span class="line">FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. InvalidOperationException(message:Database db_hive is not empty. One or more tables exist.)</span><br><span class="line"></span><br><span class="line"># 如果数据库不为空，可以采用 cascade 命令，强制删除数据库</span><br><span class="line">hive&gt; drop database db_hive cascade;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="4-1-3-改：修改数据库"><a href="#4-1-3-改：修改数据库" class="headerlink" title="4.1.3 改：修改数据库"></a>4.1.3 改：修改数据库</h3><p>Hive 允许修改的数据库的部分元数据信息。可以修改的数据在不同的 Hive 版本中是不一样的。以下是一些常见的允许修改的数据库信息：</p>
<ol>
<li> <code>DBPROPERTIES</code>：数据库描述信息</li>
<li> <code>OWNER</code>：数据库属主</li>
<li> <code>LOCATION</code>：数据库保存的位置</li>
<li> <code>MANAGEDLOCATION</code>：数据库管理位置</li>
</ol>
<p>数据库的其它元数据信息都是不可更改的，包括数据库名等等。</p>
<p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER (DATABASE|SCHEMA) database_name SET DBPROPERTIES (property_name=property_value, ...);   -- (Note: SCHEMA added in Hive 0.14.0)</span><br><span class="line"> </span><br><span class="line">ALTER (DATABASE|SCHEMA) database_name SET OWNER [USER|ROLE] user_or_role;   -- (Note: Hive 0.13.0 and later; SCHEMA added in Hive 0.14.0)</span><br><span class="line">  </span><br><span class="line">ALTER (DATABASE|SCHEMA) database_name SET LOCATION hdfs_path; -- (Note: Hive 2.2.1, 2.4.0 and later)</span><br><span class="line"> </span><br><span class="line">ALTER (DATABASE|SCHEMA) database_name SET MANAGEDLOCATION hdfs_path; -- (Note: Hive 4.0.0 and later)</span><br></pre></td></tr></table></figure>





<p><strong>Demo</strong></p>
<ol>
<li><p>使用 <code>ALTER DATABASE</code> 命令来修改数据库的 <code>DBPROPERTIES</code>信息。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	alter database db_hive set dbproperties(&#x27;createtime&#x27;=&#x27;20170830&#x27;);</span><br><span class="line">	# 新增 &#x27;createtime&#x27;=&#x27;20170830&#x27; 信息。</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>Hive</code> 中查看修改结果：<code>createtime=20170830</code> 是新增的属性。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; desc database extended db_hive;</span><br><span class="line">db_name comment location        owner_name      owner_type      parameters</span><br><span class="line">db_hive		hdfs://hadoop102:9000/hive/warehouse/db_hive.db	lvnengdong	USER    &#123;createtime=20170830&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>注意：</strong>在修改 <code>DBPROPERTIES</code> 中的数据时，同名的属性值会覆盖，非同名的属性会新增。</p>
</li>
</ol>
<hr>
<h3 id="4-1-4-查：查询数据库"><a href="#4-1-4-查：查询数据库" class="headerlink" title="4.1.4 查：查询数据库"></a>4.1.4 查：查询数据库</h3><h4 id="1、显示数据库"><a href="#1、显示数据库" class="headerlink" title="1、显示数据库"></a>1、显示数据库</h4><ol>
<li><p>显示当前连接管理的所有数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show databases;</span><br></pre></td></tr></table></figure></li>
<li><p>过滤显示查询的数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show databases like &#x27;db_hive*&#x27;;</span><br><span class="line">OK</span><br><span class="line">db_hive</span><br><span class="line">db_hive_1</span><br></pre></td></tr></table></figure></li>
<li><p>查看某个数据库中有哪些表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 语法：show tables in database</span><br><span class="line"></span><br><span class="line">hive (default)&gt; show tables in default;</span><br><span class="line">OK</span><br><span class="line">tab_name</span><br><span class="line">person</span><br><span class="line">student</span><br><span class="line">test</span><br><span class="line">Time taken: 0.038 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h4 id="2、查看数据库的描述信息"><a href="#2、查看数据库的描述信息" class="headerlink" title="2、查看数据库的描述信息"></a>2、查看数据库的描述信息</h4><ol>
<li><p>查看数据库的描述信息</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt;  desc database db_hive;</span><br><span class="line">OK</span><br><span class="line">db_name	comment	location	owner_name	owner_type	parameters</span><br><span class="line">db_hive		hdfs://hadoop102:9000/hive/warehouse/db_hive.db	lvnengdong	USER	</span><br><span class="line">Time taken: 0.026 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>

</li>
<li><p>显示数据库详细信息，<code>extended</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    hive (default)&gt; desc database extended db_hive;</span><br><span class="line">    OK</span><br><span class="line">    db_name	comment	location	owner_name	owner_type	parameters</span><br><span class="line">    db_hive		hdfs://hadoop102:9000/hive/warehouse/db_hive.db	lvnengdong	USER	</span><br><span class="line">Time taken: 0.019 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h4 id="3、切换数据库上下文"><a href="#3、切换数据库上下文" class="headerlink" title="3、切换数据库上下文"></a>3、切换数据库上下文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; use db_hive;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="4-2-表操作"><a href="#4-2-表操作" class="headerlink" title="4.2 表操作"></a>4.2 表操作</h2><h3 id="4-2-1-增：创建表"><a href="#4-2-1-增：创建表" class="headerlink" title="4.2.1 增：创建表"></a>4.2.1 增：创建表</h3><p><strong>理论知识：</strong></p>
<p>Hive 中元数据和业务数据是分开存储的，元数据存储在 MySQL 中，业务数据存储在 HDFS 上。</p>
<p>所以在执行<strong>建表</strong>语句时，</p>
<ol>
<li> Hive 会在 HDFS 上生成存储业务数据的目录，业务数据会以文件的形式存储在该目录下。</li>
<li> 同时 Hive 还会向 MySQL 的 metastore 数据库中插入表的元数据信息。</li>
</ol>
<p>在执行<strong>删除表</strong>的语句时：</p>
<ul>
<li>对于<strong>内部表</strong>，将会删除两个地方的数据。<ol>
<li> MySQL 的 metastore 数据库中的元数据信息；</li>
<li> HDFS 中对应目录下的业务数据文件。</li>
</ol>
</li>
<li>  对于<strong>外部表</strong>，只删除 MySQL 的 metastore 数据库中的元数据信息，而不会删除 HDFS 中的业务数据。</li>
</ul>
<p><strong>建表语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name </span><br><span class="line">[(col_name data_type [COMMENT col_comment], ...)] 	# 表中的字段信息（包括字段的注释）</span><br><span class="line">[COMMENT table_comment] # 表的注释信息</span><br><span class="line">[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] </span><br><span class="line">[CLUSTERED BY (col_name, col_name, ...) 	# 分桶表</span><br><span class="line">[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] # 分桶之后对桶中的数据排序</span><br><span class="line">[ROW FORMAT row_format] # 表中每行数据的格式</span><br><span class="line">[STORED AS file_format]	# 表中的数据要以哪种格式来存储（如：textfile/sequencefile 等，默认为textfile）</span><br><span class="line">[LOCATION hdfs_path]	# 表在 HDFS 上的位置</span><br></pre></td></tr></table></figure>



<p><strong>字段解释说明（部分）：</strong></p>
<ol>
<li><p><strong>EXTERNAL</strong>：声明要创建一个外部表。需要配合 <strong>LOCATION</strong> 共同使用，LOCATION 关键字的作用是指定保存业务数据的文件的存储路径。</p>
<blockquote>
<p>  <strong>外部表 vs. 内部表</strong></p>
<ol>
<li>建表时，如果不使用关键字 EXTERNAL，默认创建的表就是一个 MANAGED_TABLE（内部表/管理表）；如果建表时显式地使用了 EXTERNAL 关键字，那么创建的表就是一个外部表。</li>
<li>外部表和内部表的区别是：<ul>
<li>  内部表在执行删除操作时，会将表的元数据（schema）信息和表中的记录数据一起删除。</li>
<li>  外部表在执行删除操作时，只删除表的元数据（schema）信息。</li>
</ul>
</li>
<li>Hive 在创建内部表时，会将数据<strong>拷贝</strong>到 Location 关键字指向的路径。若创建外部表，则仅记录业务数据文件所在的路径，而不对数据文件做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</li>
</ol>
</blockquote>
</li>
<li><p> <strong>COMMENT</strong>：注释。</p>
</li>
<li><p> <strong>PARTITIONED BY</strong>：创建分区表</p>
</li>
<li><p> <strong>CLUSTERED BY</strong>：创建分桶表</p>
</li>
<li><p> <strong>SORTED BY</strong>：排序。</p>
</li>
<li><p><strong>ROW FORMAT</strong>：表中每行数据的格式</p>
<ul>
<li>  SerDe 是 Serialize/Deserilize 的简称，目的是用于序列化和反序列化。</li>
<li>  用户在建表的时候可以自定义 SerDe 或者使用默认的 SerDe。如果没有指定 ROW FORMAT 或者 ROW FORMAT DELIMITED，将会使用默认的 SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的 SerDe，Hive 通过 SerDe 确定表的具体的列的数据。</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELIMITED </span><br><span class="line">[FIELDS TERMINATED BY char] </span><br><span class="line">[COLLECTION ITEMS TERMINATED BY char]</span><br><span class="line">[MAP KEYS TERMINATED BY char] </span><br><span class="line">[LINES TERMINATED BY char] </span><br><span class="line"> | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, ...)]</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>STORED AS</strong>：指定表中的数据以什么样的文件类型类型存储。常用的文件类型有：</p>
<ul>
<li>  SEQUENCEFILE（二进制序列文件）</li>
<li>  TEXTFILE（文本）</li>
<li>  RCFILE（列式存储格式文件）</li>
</ul>
<p> 如果文件数据是纯文本，可以使用 <code>STORED AS TEXTFILE</code>。如果数据需要压缩，使用 <code>STORED AS SEQUENCEFILE</code>。</p>
</li>
<li><p> <strong>LOCATION</strong>：用于指定当前表的业务数据文件在 HDFS 上的存储位置。</p>
</li>
<li><p> <strong>LIKE</strong>：允许用户复制现有的表结构，但不复制表数据。</p>
</li>
</ol>
<hr>
<h4 id="1-内部表（管理表）"><a href="#1-内部表（管理表）" class="headerlink" title="1 内部表（管理表）"></a>1 内部表（管理表）</h4><p><strong>理论</strong></p>
<p>Hive 默认创建的表都是<strong>管理表（内部表）</strong>，创建外部表需要显示使用 <strong>EXTERNAL</strong> 关键字。</p>
<p>对于内部表，Hive 控制着业务数据的生命周期。Hive 默认情况下会将表的业务数据文件存储在由配置属性 <code>hive.metastore.warehouse.dir</code> 所定义的目录的下，例如 <code>/user/hive/warehouse</code>。当我们删除一个内部表时，Hive 不仅会删除 MySQL 中 metastore 数据库中表的元数据信息，同时也会删除这个目录下的业务数据文件。</p>
<p>内部表不适合和其他工具共享数据。</p>
<p><strong>Demo</strong></p>
<ol>
<li><p>普通创建表（默认创建的就是一个内部表）</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists student2</span><br><span class="line">	(  </span><br><span class="line">        id int, </span><br><span class="line">        name string  </span><br><span class="line">    )</span><br><span class="line">    row format delimited fields terminated by &#x27;\t&#x27;  </span><br><span class="line">    stored as textfile  </span><br><span class="line">    location &#x27;/user/hive/warehouse/student2&#x27;;    </span><br></pre></td></tr></table></figure>

</li>
<li><p>根据查询结果创建表，同时查询的结果集会添加到新创建的表中</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists student3 </span><br><span class="line">as </span><br><span class="line">select id, name from student;  </span><br></pre></td></tr></table></figure>

</li>
<li><p>根据已经存在的表结构创建表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists student4 </span><br><span class="line">like student;</span><br></pre></td></tr></table></figure>

</li>
<li><p>查询表的描述信息</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; desc formatted student2;</span><br><span class="line">Table Type:       MANAGED_TABLE </span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="2-外部表"><a href="#2-外部表" class="headerlink" title="2 外部表"></a>2 外部表</h4><p><strong>理论</strong></p>
<p>对于外部表，Hive 并非完全拥有表的业务数据，所以在删除外部表时并不会删除业务数据，而只是删除描述表的元数据信息。</p>
<p>一般情况下，MySQL 数据库中的业务数据会以文件的格式上传到 HDFS 中的某个目录下。对于内部表而言，会将业务数据拷贝一份到 Hive 指定的目录下，所以可以说 Hive 拥有这份业务数据文件的所有权限，对该文件执行写/删除操作不会影响 HDFS 中最初的源文件。而对于外部表而言，Hive 直接引用 HDFS 上源文件的地址作为 Hive 读取业务数据的来源，所以 Hive 不能轻易去修改/删除这个源文件，因为该源文件很有可能还被其它程序使用。</p>
<p><strong>内部表和外部表的使用场景：</strong></p>
<p>每天将收集到的网站日志定期流入 HDFS 文本文件。在外部表（原始日志表）的基础上做大量的统计分析，用到的<strong>中间表、结果表</strong>使用内部表存储，数据通过 <code>SELECT+INSERT</code> 进入内部表。</p>
<p><strong>Demo：</strong></p>
<p>分别创建部门和员工外部表，并向表中导入数据。</p>
<ol>
<li><p>原始数据：</p>
<p> <code>/opt/module/datas/dept.txt</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10	ACCOUNTING	1700</span><br><span class="line">20	RESEARCH	1800</span><br><span class="line">30	SALES	1900</span><br><span class="line">40	OPERATIONS	1700</span><br></pre></td></tr></table></figure>

<p> <code>/opt/module/datas/emp.txt</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">7369	SMITH	CLERK	7902	1980-12-17	800.00		20</span><br><span class="line">7499	ALLEN	SALESMAN	7698	1981-2-20	1600.00	300.00	30</span><br><span class="line">7521	WARD	SALESMAN	7698	1981-2-22	1250.00	500.00	30</span><br><span class="line">7566	JONES	MANAGER	7839	1981-4-2	2975.00		20</span><br><span class="line">7654	MARTIN	SALESMAN	7698	1981-9-28	1250.00	1400.00	30</span><br><span class="line">7698	BLAKE	MANAGER	7839	1981-5-1	2850.00		30</span><br><span class="line">7782	CLARK	MANAGER	7839	1981-6-9	2450.00		10</span><br><span class="line">7788	SCOTT	ANALYST	7566	1987-4-19	3000.00		20</span><br><span class="line">7839	KING	PRESIDENT		1981-11-17	5000.00		10</span><br><span class="line">7844	TURNER	SALESMAN	7698	1981-9-8	1500.00	0.00	30</span><br><span class="line">7876	ADAMS	CLERK	7788	1987-5-23	1100.00		20</span><br><span class="line">7900	JAMES	CLERK	7698	1981-12-3	950.00		30</span><br><span class="line">7902	FORD	ANALYST	7566	1981-12-3	3000.00		20</span><br><span class="line">7934	MILLER	CLERK	7782	1982-1-23	1300.00		10</span><br></pre></td></tr></table></figure>

</li>
<li><p>建表语句</p>
<ul>
<li><p>创建部门表</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create external table if not exists default.dept</span><br><span class="line">	(  </span><br><span class="line">        deptno  int,  </span><br><span class="line">        dname  string,  </span><br><span class="line">        loc  int  </span><br><span class="line">    )  </span><br><span class="line">    row  format delimited fields terminated by &#x27;\t&#x27;;  </span><br></pre></td></tr></table></figure>

</li>
<li><p>创建员工表</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create external table if not exists default.emp</span><br><span class="line">	(  </span><br><span class="line">        empno  int,  </span><br><span class="line">        ename  string,  </span><br><span class="line">        job  string,  </span><br><span class="line">        mgr  int,  </span><br><span class="line">        hiredate  string,   </span><br><span class="line">        sal  double,   </span><br><span class="line">        comm  double,  </span><br><span class="line">        deptno  int</span><br><span class="line">    )  </span><br><span class="line">    row  format delimited fields terminated by &#x27;\t&#x27;;  </span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
<li><p>查看创建的表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; show tables;</span><br><span class="line">OK</span><br><span class="line">tab_name</span><br><span class="line">dept</span><br><span class="line">emp</span><br></pre></td></tr></table></figure>

</li>
<li><p>向外部表中导入数据</p>
<ul>
<li>  导入数据</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#x27;/opt/module/datas/dept.txt&#x27; into table default.dept;</span><br><span class="line">hive (default)&gt; load data local inpath &#x27;/opt/module/datas/emp.txt&#x27; into table default.emp;</span><br></pre></td></tr></table></figure>

<ul>
<li>  查询结果</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from emp;</span><br><span class="line">hive (default)&gt; select * from dept;</span><br></pre></td></tr></table></figure>

</li>
<li><p>查看表格式化数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; desc formatted dept;</span><br><span class="line">Table Type:       EXTERNAL_TABLE</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="3-内部表-lt-gt-外部表"><a href="#3-内部表-lt-gt-外部表" class="headerlink" title="3 内部表 &lt;=&gt; 外部表"></a>3 内部表 &lt;=&gt; 外部表</h4><p>想要实现内部表与外部表之间的相互转换，只需要切换表的 <code>Table Type: MANAGED_TABLE | EXTERNAL_TABLE</code> 属性就可以了。具体的实现方式如下：</p>
<ol>
<li><p>查询表的类型</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; desc formatted student2;</span><br><span class="line">Table Type:             MANAGED_TABLE	# 管理表，也就是内部表</span><br></pre></td></tr></table></figure></li>
<li><p>修改内部表 <code>student2</code> 为外部表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student2 set tblproperties(&#x27;EXTERNAL&#x27;=&#x27;TRUE&#x27;);	# 打开外部表的开关</span><br></pre></td></tr></table></figure></li>
<li><p>查询表的类型</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; desc formatted student2;</span><br><span class="line">Table Type:             EXTERNAL_TABLE	# 表的类型变成了外部表</span><br></pre></td></tr></table></figure></li>
<li><p>修改外部表 <code>student2</code> 为内部表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student2 set tblproperties(&#x27;EXTERNAL&#x27;=&#x27;FALSE&#x27;);	# 关闭外部表的开关，就会自动变为内部表了</span><br></pre></td></tr></table></figure></li>
<li><p>查询表的类型</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; desc formatted student2;</span><br><span class="line">Table Type:             MANAGED_TABLE</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong>在 Hive 中查询语句不区分大小写，但是在参数中严格区分大小写。所以 <code>(&#39;EXTERNAL&#39;=&#39;TRUE&#39;)</code> 和 <code>(&#39;EXTERNAL&#39;=&#39;FALSE&#39;)</code> 为固定写法，不能小写。</p>
<hr>
<h3 id="4-2-2-删：删除表"><a href="#4-2-2-删：删除表" class="headerlink" title="4.2.2 删：删除表"></a>4.2.2 删：删除表</h3><h4 id="彻底删除表"><a href="#彻底删除表" class="headerlink" title="彻底删除表"></a>彻底删除表</h4><p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure>

<p><strong>Demo：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; drop table dept_partition;</span><br></pre></td></tr></table></figure>





<h4 id="清空表中数据，但保留表结构"><a href="#清空表中数据，但保留表结构" class="headerlink" title="清空表中数据，但保留表结构"></a>清空表中数据，但保留表结构</h4><p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure>

<p><strong>Demo：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; truncate table dept_partition;</span><br></pre></td></tr></table></figure>

<p><strong>Tip：</strong>只能清空内部表的业务的数据，无法清空外部表的业务数据，因为外部表的业务数据不属于 Hive 管理。</p>
<hr>
<h3 id="4-2-3-改"><a href="#4-2-3-改" class="headerlink" title="4.2.3 改"></a>4.2.3 改</h3><h4 id="4-2-3-1-重命名表"><a href="#4-2-3-1-重命名表" class="headerlink" title="4.2.3.1 重命名表"></a>4.2.3.1 重命名表</h4><p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name RENAME TO new_table_name</span><br></pre></td></tr></table></figure>

<p><strong>Demo：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; alter table dept_partition2 rename to dept_partition3;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="4-2-3-2-增加、修改和删除表分区"><a href="#4-2-3-2-增加、修改和删除表分区" class="headerlink" title="4.2.3.2 增加、修改和删除表分区"></a>4.2.3.2 增加、修改和删除表分区</h4><p>详见 4.6.1 分区表基本操作。</p>
<hr>
<h4 id="4-2-3-3-增加-修改-替换列信息"><a href="#4-2-3-3-增加-修改-替换列信息" class="headerlink" title="4.2.3.3 增加/修改/替换列信息"></a>4.2.3.3 增加/修改/替换列信息</h4><p><strong>语法</strong></p>
<ol>
<li><p>更新列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name </span><br><span class="line">CHANGE [COLUMN] col_old_name col_new_name column_type </span><br><span class="line">[COMMENT col_comment] </span><br><span class="line">[FIRST|AFTER column_name]	# 调整列的顺序（FIRST表示调整到第一列）</span><br></pre></td></tr></table></figure></li>
<li><p>增加和重设列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">&#123;ADD | REPLACE&#125; COLUMNS (col_name data_type [COMMENT col_comment], ...) </span><br><span class="line"></span><br><span class="line"># 注：ADD 代表新增一字段，字段位置在所有列后面(partition列前)，</span><br><span class="line"># REPLACE 则是表示重设表中所有字段。</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>Demo：</strong></p>
<ol>
<li><p>查询表结构</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; desc dept_partition;</span><br></pre></td></tr></table></figure></li>
<li><p>添加列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; alter table dept_partition add columns(deptdesc string);</span><br></pre></td></tr></table></figure></li>
<li><p>更新列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; alter table dept_partition change column deptdesc desc int;</span><br></pre></td></tr></table></figure></li>
<li><p>替换列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	alter table dept_partition </span><br><span class="line">	replace columns(</span><br><span class="line">        deptno string, </span><br><span class="line">        dname string, </span><br><span class="line">        loc string</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="4-2-4-查"><a href="#4-2-4-查" class="headerlink" title="4.2.4 查"></a>4.2.4 查</h3><p><strong>一、查看表的描述（概要信息）</strong></p>
<ul>
<li><p><strong>语法：</strong> </p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Demo</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看 student 表的描述信息</span><br><span class="line">hive (default)&gt; desc student;</span><br><span class="line">OK</span><br><span class="line">col_name	data_type	comment</span><br><span class="line">id                  	int                 	                    </span><br><span class="line">name                	string              	                    </span><br><span class="line">Time taken: 0.133 seconds, Fetched: 2 row(s)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>二、查看表的描述（详细信息）</strong></p>
<ul>
<li><p>语法：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc extended 表名;</span><br></pre></td></tr></table></figure></li>
<li><p>Demo：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; desc extended student;</span><br><span class="line">OK</span><br><span class="line">col_name	data_type	comment</span><br><span class="line">id                  	int                 	                    </span><br><span class="line">name                	string              	                    </span><br><span class="line">	 	 </span><br><span class="line">Detailed Table Information	Table(tableName:student, dbName:default, owner:lvnengdong, createTime:1639841380, lastAccessTime:0, retention:0, sd:StorageDescriptor(cols:[FieldSchema(name:id, type:int, comment:null), FieldSchema(name:name, type:string, comment:null)], location:hdfs://hadoop102:9000/user/hive/warehouse/student, inputFormat:org.apache.hadoop.mapred.TextInputFormat, outputFormat:org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat, compressed:false, numBuckets:-1, serdeInfo:SerDeInfo(name:null, serializationLib:org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, parameters:&#123;serialization.format=1&#125;), bucketCols:[], sortCols:[], parameters:&#123;&#125;, skewedInfo:SkewedInfo(skewedColNames:[], skewedColValues:[], skewedColValueLocationMaps:&#123;&#125;), storedAsSubDirectories:false), partitionKeys:[], parameters:&#123;totalSize=12, numRows=-1, rawDataSize=-1, COLUMN_STATS_ACCURATE=false, numFiles=1, transient_lastDdlTime=1639841380&#125;, viewOriginalText:null, viewExpandedText:null, tableType:MANAGED_TABLE)	</span><br><span class="line">Time taken: 0.096 seconds, Fetched: 4 row(s)</span><br></pre></td></tr></table></figure></li>
<li><p>  可以看到详情信息非常的乱，这时候就可以使用另一条命令以格式化的形式输出表的详情信息</p>
</li>
</ul>
<p><strong>三、查看表详情（以格式化后的形式展示在控制台上）</strong></p>
<ul>
<li><p>语法：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc formatted 表名;</span><br></pre></td></tr></table></figure></li>
<li><p>Demo：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; desc formatted student;</span><br><span class="line">OK</span><br><span class="line">col_name	data_type	comment</span><br><span class="line"># col_name            	data_type           	comment             </span><br><span class="line">	 	 </span><br><span class="line">id                  	int                 	                    </span><br><span class="line">name                	string              	                    </span><br><span class="line">	 	 </span><br><span class="line"># Detailed Table Information	 	 </span><br><span class="line">Database:           	default             	 </span><br><span class="line">Owner:              	lvnengdong          	 </span><br><span class="line">CreateTime:         	Sat Dec 18 23:29:40 CST 2021	 </span><br><span class="line">LastAccessTime:     	UNKNOWN             	 </span><br><span class="line">Protect Mode:       	None                	 </span><br><span class="line">Retention:          	0                   	 </span><br><span class="line">Location:           	hdfs://hadoop102:9000/user/hive/warehouse/student	 </span><br><span class="line">Table Type:         	MANAGED_TABLE       	</span><br><span class="line">Table Parameters:	 	 </span><br><span class="line">	COLUMN_STATS_ACCURATE	false               </span><br><span class="line">	numFiles            	1                   </span><br><span class="line">	numRows             	-1                  </span><br><span class="line">	rawDataSize         	-1                  </span><br><span class="line">	totalSize           	12                  </span><br><span class="line">	transient_lastDdlTime	1639841380          </span><br><span class="line">	 	 </span><br><span class="line"># Storage Information	 	 </span><br><span class="line">SerDe Library:      	org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe	 </span><br><span class="line">InputFormat:        	org.apache.hadoop.mapred.TextInputFormat	 </span><br><span class="line">OutputFormat:       	org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat	 </span><br><span class="line">Compressed:         	No                  	 </span><br><span class="line">Num Buckets:        	-1                  	 </span><br><span class="line">Bucket Columns:     	[]                  	 </span><br><span class="line">Sort Columns:       	[]                  	 </span><br><span class="line">Storage Desc Params:	 	 </span><br><span class="line">	serialization.format	1                   </span><br><span class="line">Time taken: 0.907 seconds, Fetched: 32 row(s)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="4-3-分区表"><a href="#4-3-分区表" class="headerlink" title="4.3 分区表"></a>4.3 分区表</h2><h3 id="4-3-1-是什么？"><a href="#4-3-1-是什么？" class="headerlink" title="4.3.1 是什么？"></a>4.3.1 是什么？</h3><p>Hive 表中的业务数据文件保存在 HDFS 中。<strong>默认情况</strong>下（也就是没有显式指定分区的情况下），每张表映射到 HDFS 中有一个存储目录，业务数据就保存在该目录下。</p>
<p>因为 Hive 表是没有索引的，所以检索表中数据的方式只能是遍历。在某些情况下，我们执行的查询操作并不想要检索整张表，而只想要检索表的一部分数据，为了细化数据的粒度，Hive 引入了<code>分区</code>的概念。<strong>分区就是把整张表的数据根据业务需要分割成多个小的数据集，对应到 HDFS 上就是在表目录下再创建多个子目录（分区目录），将对应的子数据集存储在分区目录中。</strong>在执行查询语句时通过 WHERE 子句中的条件查询指定的分区，提高查询效率。</p>
<p><strong>Tip</strong></p>
<ul>
<li>  只有分区表才有分区目录（子目录）</li>
<li>  分区目录的名称由两部分决定：<code>分区列列名=分区列列值</code></li>
</ul>
<h3 id="4-3-2-分区表语法"><a href="#4-3-2-分区表语法" class="headerlink" title="4.3.2 分区表语法"></a>4.3.2 分区表语法</h3><p><strong>分区表语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] </span><br></pre></td></tr></table></figure>



<p>引入分区表（需要根据日期对日志进行管理）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/user/hive/warehouse/log_partition/20170702/20170702.log</span><br><span class="line">/user/hive/warehouse/log_partition/20170703/20170703.log</span><br><span class="line">/user/hive/warehouse/log_partition/20170704/20170704.log</span><br></pre></td></tr></table></figure>





<h3 id="4-3-3-分区表基本操作"><a href="#4-3-3-分区表基本操作" class="headerlink" title="4.3.3 分区表基本操作"></a>4.3.3 分区表基本操作</h3><h4 id="1、准备数据"><a href="#1、准备数据" class="headerlink" title="1、准备数据"></a>1、准备数据</h4><p>准备数据：<code>/opt/module/datas/dept.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10	ACCOUNTING	1700</span><br><span class="line">20	RESEARCH	1800</span><br><span class="line">30	SALES	1900</span><br><span class="line">40	OPERATIONS	1700</span><br></pre></td></tr></table></figure>

<h4 id="2、创建分区表"><a href="#2、创建分区表" class="headerlink" title="2、创建分区表"></a>2、创建分区表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	create table dept_partition(</span><br><span class="line">        deptno int, </span><br><span class="line">        dname string, </span><br><span class="line">        loc string</span><br><span class="line">    )</span><br><span class="line">    partitioned by (month string)	# 创建分区表时要额外指定分区信息</span><br><span class="line">    row format delimited fields terminated by &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure>



<h4 id="3、导入数据（失败）"><a href="#3、导入数据（失败）" class="headerlink" title="3、导入数据（失败）"></a>3、导入数据（失败）</h4><p>加载数据到分区表 <code>dept_partition</code> 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#x27;/opt/module/datas/dept.txt&#x27; into table dept_partition;</span><br><span class="line">FAILED: SemanticException [Error 10062]: Need to specify partition columns because the destination table is partitioned</span><br><span class="line"># 导入数据失败，因为目标表是一个分区表，所以在导入数据时必须数据要导入到哪一个分区目录中</span><br></pre></td></tr></table></figure>

<p>如果当前表是一个分区表，在导入数据时，必须指定向哪个分区导入数据。因为对于分区表来说，在 HDFS 的表目录下还有多个分区目录，对应的数据应该导入到这些分区目录中。</p>
<h4 id="4、增加分区"><a href="#4、增加分区" class="headerlink" title="4、增加分区"></a>4、增加分区</h4><p><strong>增加分区</strong>：目前我们还没有创建分区，所以我们首先要在当前表下创建分区。</p>
<ul>
<li><p>创建单个分区</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># alter table 表名 add partition(分区字段名=分区字段值);</span><br><span class="line">hive (default)&gt; </span><br><span class="line">	hive (default)&gt; alter table dept_partition add partition(month=&#x27;202112&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>同时创建多个分区</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	alter table dept_partition </span><br><span class="line">	add partition(month=&#x27;202111&#x27;) partition(month=&#x27;202110&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="新增分区（方式一）："><a href="#新增分区（方式一）：" class="headerlink" title="新增分区（方式一）："></a>新增分区（方式一）：</h5><p>在给分区表新增分区时：</p>
<ol>
<li><p>在 HDFS 上会生成分区路径。查看 HDFS 的分区目录结构：</p>
<p> <img src="/2021/12/13/Hive/image-20211219223705371.png" alt="image-20211219223705371"></p>
</li>
<li><p>在 MySQL 中的 <code>metastore.partitions</code> 表中会生成分区相关的元数据信息</p>
<p> <img src="/2021/12/13/Hive/image-20211220102736063.png" alt="image-20211220102736063"></p>
<ul>
<li>  <strong>PART_NAME</strong>：保存了分区列的信息；</li>
<li>  <strong>TBL_ID</strong>：指定了分区所在的表的 ID，对应 <code>TBLS</code>表的主键</li>
</ul>
<p> <img src="/2021/12/13/Hive/image-20211220102924703.png" alt="image-20211220102924703"></p>
</li>
</ol>
<h5 id="增加分区（方式二）"><a href="#增加分区（方式二）" class="headerlink" title="增加分区（方式二）"></a>增加分区（方式二）</h5><p>我们还可以直接使用 <code>load</code> 命令向分区加载数据，如果分区不存在，load 时会自动帮我们生成分区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	load data local inpath &#x27;/opt/module/datas/dept.txt&#x27; into table dept_partition partition(month=202109);</span><br></pre></td></tr></table></figure>





<h4 id="5、导入数据（成功）"><a href="#5、导入数据（成功）" class="headerlink" title="5、导入数据（成功）"></a>5、导入数据（成功）</h4><p>加载数据到分区表的指定分区中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	load data local inpath &#x27;/opt/module/datas/dept.txt&#x27; into table dept_partition partition(month=&#x27;202110&#x27;);</span><br><span class="line">Loading data to table default.dept_partition partition (month=202110)</span><br><span class="line">Partition default.dept_partition&#123;month=202110&#125; stats: [numFiles=1, totalSize=65]</span><br><span class="line">OK</span><br><span class="line">Time taken: 0.975 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li>  在 HDFS 上查看上传的数据文件</li>
</ul>
<p><img src="/2021/12/13/Hive/image-20211220103704244.png" alt="image-20211220103704244"></p>
<h4 id="6、查询分区表"><a href="#6、查询分区表" class="headerlink" title="6、查询分区表"></a>6、查询分区表</h4><ol>
<li><p>将数据导入到指定的分区之后，数据会额外附加上分区列的信息。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition;</span><br><span class="line">OK</span><br><span class="line">dept_partition.deptno	dept_partition.dname	dept_partition.loc	dept_partition.month</span><br><span class="line">NULL	1700	NULL	202110</span><br><span class="line">20	RESEARCH	1800	202110</span><br><span class="line">30	SALES	1900	202110</span><br><span class="line">40	OPERATIONS	1700	202110</span><br><span class="line">Time taken: 0.47 seconds, Fetched: 4 row(s)</span><br><span class="line"></span><br><span class="line"># 分区列 dept_partition.month 的信息在源数据文件中是没有的，是在将数据分区表之后由 Hive 自动生成的</span><br></pre></td></tr></table></figure>

</li>
<li><p>可以通过分区列来对数据进行过滤，指定查找的目录</p>
<ul>
<li><p>单分区查询</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition where month = &quot;202110&quot;;</span><br><span class="line">OK</span><br><span class="line">dept_partition.deptno	dept_partition.dname	dept_partition.loc	dept_partition.month</span><br><span class="line">NULL	1700	NULL	202110</span><br><span class="line">20	RESEARCH	1800	202110</span><br><span class="line">30	SALES	1900	202110</span><br><span class="line">40	OPERATIONS	1700	202110</span><br><span class="line">Time taken: 0.388 seconds, Fetched: 4 row(s)</span><br></pre></td></tr></table></figure></li>
<li><p>多分区联合查询：通过关键字 union 联合查询多个分区</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	select * from dept_partition where month=&#x27;202110&#x27;</span><br><span class="line">	union</span><br><span class="line">	select * from dept_partition where month=&#x27;202111&#x27;</span><br><span class="line">	union</span><br><span class="line">	select * from dept_partition where month=&#x27;202112&#x27;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="7、删除分区"><a href="#7、删除分区" class="headerlink" title="7、删除分区"></a>7、删除分区</h4><ul>
<li><p>删除单个分区</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	alter table dept_partition drop partition (month=&#x27;202110&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>同时删除多个分区</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	alter table dept_partition </span><br><span class="line">	drop partition (month=&#x27;202110&#x27;), partition (month=&#x27;202111&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在执行删除表操作时，首先会删除 MySQL 数据库中对应的元数据信息；并且如果当前表是内部表，还会删除 HDFS 上对应的数据信息。</p>
<h4 id="8、查看分区表有哪些分区"><a href="#8、查看分区表有哪些分区" class="headerlink" title="8、查看分区表有哪些分区"></a>8、查看分区表有哪些分区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; show partitions dept_partition;</span><br></pre></td></tr></table></figure>



<h4 id="9、查看分区表结构"><a href="#9、查看分区表结构" class="headerlink" title="9、查看分区表结构"></a>9、查看分区表结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; desc formatted dept_partition;</span><br></pre></td></tr></table></figure>







<hr>
<h3 id="4-3-4-多级分区表"><a href="#4-3-4-多级分区表" class="headerlink" title="4.3.4 多级分区表"></a>4.3.4 多级分区表</h3><p><strong>一、创建多级分区表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	create table dept_partition2</span><br><span class="line">		(           </span><br><span class="line">            deptno int, </span><br><span class="line">            dname string,</span><br><span class="line">            loc string</span><br><span class="line">        )           </span><br><span class="line">        partitioned by (month string, day string)	# 二级分区，先按 month 分区，month 相等时再按 day 分区           </span><br><span class="line">        row format delimited fields terminated by &#x27;\t&#x27;;  </span><br></pre></td></tr></table></figure>



<p><strong>二、正常的加载数据</strong></p>
<ol>
<li><p>加载数据到二级分区表中</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	load data local inpath &#x27;/opt/module/datas/dept.txt&#x27; into table default.dept_partition2</span><br><span class="line">	partition(month=&#x27;202112&#x27;, day=&#x27;20&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>  对应的目录结构就是三级目录：<strong>表目录/一级分区目录/二级分区目录</strong>，在 HDFS 上的结构如下：</li>
</ul>
<p> <img src="/2021/12/13/Hive/image-20211220114355694.png" alt="image-20211220114355694"></p>
<ul>
<li>Tip：如果是多级分区表，数据必须位于最内层目录下。</li>
</ul>
</li>
<li><p>查询分区数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">              &gt; select * from dept_partition2</span><br><span class="line">              &gt; where month=&#x27;202112&#x27; and day=&#x27;20&#x27;;</span><br><span class="line">OK</span><br><span class="line">dept_partition2.deptno	dept_partition2.dname	dept_partition2.loc	dept_partition2.month	dept_partition2.day</span><br><span class="line">NULL	1700	NULL	202112	20</span><br><span class="line">20	RESEARCH	1800	202112	20</span><br><span class="line">30	SALES	1900	202112	20</span><br><span class="line">40	OPERATIONS	1700	202112	20</span><br><span class="line">Time taken: 0.106 seconds, Fetched: 4 row(s)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="4-3-5-自动修复分区"><a href="#4-3-5-自动修复分区" class="headerlink" title="4.3.5 自动修复分区"></a>4.3.5 自动修复分区</h3><p>通常情况下，HDFS 上保存的数据是预先采集好的，再由 Hive 对 HDFS 上保存的数据进行分析。所以一般是先有数据后有表，所以 Hive 在建表时首先要读取 HDFS 上的数据，再根据数据建立对应的表。</p>
<p><strong>把数据直接上传到分区目录上，让分区表和数据产生关联的三种方式：</strong></p>
<p><strong>方式一：上传数据后自动修复</strong></p>
<ul>
<li>  上传数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br><span class="line">hive (default)&gt; </span><br><span class="line">	dfs -put /opt/module/datas/dept.txt  /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br></pre></td></tr></table></figure>

<ul>
<li>  查询数据（查询不到刚上传的数据）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	select * from dept_partition2 where month=&#x27;201709&#x27; and day=&#x27;12&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>执行修复命令</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; </span><br><span class="line">	msck repair table dept_partition2;</span><br></pre></td></tr></table></figure>

<ul>
<li>  再次查询数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	select * from dept_partition2 where month=&#x27;201709&#x27; and day=&#x27;12&#x27;;</span><br></pre></td></tr></table></figure>



<p><strong>方式二：上传数据后添加分区</strong></p>
<ul>
<li>  上传数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=11;</span><br><span class="line">hive (default)&gt; </span><br><span class="line">	dfs -put /opt/module/datas/dept.txt  /user/hive/warehouse/dept_partition2/month=201709/day=11;</span><br></pre></td></tr></table></figure>

<ul>
<li>  手动添加分区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	alter table dept_partition2 add partition(month=&#x27;201709&#x27;,day=&#x27;11&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  查询数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition2 where month=&#x27;201709&#x27; and day=&#x27;11&#x27;;</span><br></pre></td></tr></table></figure>



<p><strong>方式三：创建分区目录后load数据到指定分区</strong></p>
<ul>
<li>  创建目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=10;</span><br></pre></td></tr></table></figure>

<ul>
<li>  上传数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	load data local inpath &#x27;/opt/module/datas/dept.txt&#x27; into table dept_partition2 partition(month=&#x27;201709&#x27;,day=&#x27;10&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>  查询数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition2 where month=&#x27;201709&#x27; and day=&#x27;10&#x27;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-4-分桶表"><a href="#4-4-分桶表" class="headerlink" title="4.4 分桶表"></a>4.4 分桶表</h2><h3 id="4-4-1-理论知识"><a href="#4-4-1-理论知识" class="headerlink" title="4.4.1 理论知识"></a>4.4.1 理论知识</h3><p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    CLUSTERED BY (col_name, col_name, ...) 	# 分桶表	</span><br><span class="line">    [SORTED BY (col_name [ASC|DESC], ...)]  # 分桶之后对桶中的数据排序</span><br><span class="line">    INTO num_buckets BUCKETS</span><br><span class="line">] 	</span><br></pre></td></tr></table></figure>

<ul>
<li>  在创建分区表的时候，需要手动指定<strong>分区列名称</strong>和<strong>分区列类型</strong>；而在创建分桶表的时候，只需要手动指定<strong>分桶列名称</strong>就可以了。</li>
<li>  在创建分区表时，<strong>分区列名称</strong>和<strong>分区列类型</strong>会作为新的属性组追加到表中，而创建分桶表时，则是复用表中已有的字段作为分桶的依据。</li>
</ul>
<p><strong>是什么？</strong></p>
<ul>
<li>  如果在建表时，显式指定了 <code>CLUSTERED BY</code> 属性，那么这张表就称为分桶表。</li>
<li>  分桶就是把表数据分散到多个文件中。比如一张表中有 100W 条数据，存储在一个文件中。假如分成 4 个桶，这 100W 条数据就会分散到 4 个桶中存储，降低了单个文件的负担。</li>
<li>  分桶的意义是为了分散数据。在分桶后，可以结合 Hive 提供的抽样查询，只查询指定桶的数据。</li>
<li>  <strong>分区</strong>是把一张表中的数据分散存储到各个目录下，<strong>分桶</strong>是把一张表中的数据分散存储到各个文件中。</li>
</ul>
<p><strong>单个桶中数据的排序：</strong></p>
<ul>
<li>  在分桶后，可以将每个桶中的数据根据一定的规则进行排序。</li>
<li>  如果需要排序，可以通过 <code>SORTED BY</code> 关键字来显式指定排序的字段和规则。</li>
</ul>
<hr>
<h3 id="4-4-2-案例实操"><a href="#4-4-2-案例实操" class="headerlink" title="4.4.2 案例实操"></a>4.4.2 案例实操</h3><h4 id="1、创建分桶表"><a href="#1、创建分桶表" class="headerlink" title="1、创建分桶表"></a>1、创建分桶表</h4><ol>
<li><p>数据准备：<code>/opt/module/datas/student.txt</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 学号	姓名</span><br><span class="line">1001	ss1</span><br><span class="line">1002	ss2</span><br><span class="line">1003	ss3</span><br><span class="line">1004	ss4</span><br><span class="line">1005	ss5</span><br><span class="line">1006	ss6</span><br><span class="line">1007	ss7</span><br><span class="line">1008	ss8</span><br><span class="line">1009	ss9</span><br><span class="line">1010	ss10</span><br><span class="line">1011	ss11</span><br><span class="line">1012	ss12</span><br><span class="line">1013	ss13</span><br><span class="line">1014	ss14</span><br><span class="line">1015	ss15</span><br><span class="line">1016	ss16</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建分桶表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">              &gt; create table stu_buck(id int, name string)</span><br><span class="line">              &gt; clustered by(id) into 4 buckets</span><br><span class="line">              &gt; row format delimited fields terminated by &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表结构</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; desc formatted stu_buck;</span><br><span class="line">OK</span><br><span class="line">col_name	data_type	comment</span><br><span class="line"># col_name            	data_type           	comment             </span><br><span class="line">	 	 </span><br><span class="line">id                  	int                 	                    </span><br><span class="line">name                	string              	                    </span><br><span class="line">	 	 </span><br><span class="line"># Detailed Table Information	 	 </span><br><span class="line">Database:           	default             	 </span><br><span class="line">Owner:              	lvnengdong          	 </span><br><span class="line">CreateTime:         	Mon Dec 20 12:17:47 CST 2021	 </span><br><span class="line">LastAccessTime:     	UNKNOWN             	 </span><br><span class="line">Protect Mode:       	None                	 </span><br><span class="line">Retention:          	0                   	 </span><br><span class="line">Location:           	hdfs://hadoop102:9000/hive/warehouse/stu_buck	 </span><br><span class="line">Table Type:         	MANAGED_TABLE       	 </span><br><span class="line">Table Parameters:	 	 </span><br><span class="line">	transient_lastDdlTime	1639973867          </span><br><span class="line">	 	 </span><br><span class="line"># Storage Information	 	 </span><br><span class="line">SerDe Library:      	org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe	 </span><br><span class="line">InputFormat:        	org.apache.hadoop.mapred.TextInputFormat	 </span><br><span class="line">OutputFormat:       	org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat	 </span><br><span class="line">Compressed:         	No                  	 </span><br><span class="line">Num Buckets:        	4    # 桶数量              	 </span><br><span class="line">Bucket Columns:     	[id]     # 分桶的列名           	 </span><br><span class="line">Sort Columns:       	[]       # 排序字段      	 </span><br><span class="line">Storage Desc Params:	 	 </span><br><span class="line">	field.delim         	\t                  </span><br><span class="line">	serialization.format	\t                  </span><br><span class="line">Time taken: 0.089 seconds, Fetched: 28 row(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>导入数据到分桶表中</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#x27;/opt/module/datas/student.txt&#x27; into table  stu_buck;</span><br></pre></td></tr></table></figure></li>
<li><p>查看创建的分桶表中是否分成4个桶。</p>
<p> <img src="/2021/12/13/Hive/image-20211220122413669.png" alt="image-20211220122413669"></p>
<blockquote>
<p>  发现并没有分成 4 个桶。是什么原因呢？</p>
<ul>
<li>  向分桶表中导入数据时，必须运行 MapReduce 程序，才能实现分桶操作。</li>
<li>  load 方式只是简单的上传数据，类似于 put 操作，无法满足分桶表的导入数据。必须采用 insert into 方式导入数据才能实现分桶</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="2、创建分桶表时，数据通过子查询的方式导入"><a href="#2、创建分桶表时，数据通过子查询的方式导入" class="headerlink" title="2、创建分桶表时，数据通过子查询的方式导入"></a>2、创建分桶表时，数据通过子查询的方式导入</h4><ol>
<li><p>先建一个普通的 <code>stu</code> 表</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table stu(id int, name string)  row  format delimited fields terminated by &#x27;\t&#x27;;  </span><br></pre></td></tr></table></figure></li>
<li><p>向普通的 <code>stu</code> 表中导入数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data local inpath &#x27;/opt/module/datas/student.txt&#x27; into table stu;  </span><br></pre></td></tr></table></figure></li>
<li><p>清空 <code>stu_buck</code> 表中数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate  table stu_buck;  select  * from stu_buck;  </span><br></pre></td></tr></table></figure></li>
<li><p>通过子查询的方式导入数据到分桶表。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into table stu_buck select id, name from stu;  </span><br></pre></td></tr></table></figure></li>
<li><p>发现还是只有一个分桶</p>
<p> <img src="/2021/12/13/Hive/image-20211220125128806.png" alt="image-20211220125128806"></p>
</li>
<li><p>需要设置一个属性</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1、打开强制分桶开关：</span><br><span class="line">hive  (default)&gt; set hive.enforce.bucketing=true;</span><br><span class="line"># 2、mapreduce.job.reduces=-1 表示默认值，表示 Hive 会读取分桶表的设置的 numBuckets 来设置分桶值，</span><br><span class="line"># 但是该参数生效的前提是必须打开分桶开关</span><br><span class="line">hive  (default)&gt; set mapreduce.job.reduces=-1;  </span><br><span class="line">hive  (default)&gt; insert into table stu_buck  select  id, name from stu;  </span><br></pre></td></tr></table></figure></li>
<li><p>查询分桶的数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from stu_buck;</span><br><span class="line">OK</span><br><span class="line">stu_buck.id	stu_buck.name</span><br><span class="line">1016	ss16</span><br><span class="line">1012	ss12</span><br><span class="line">1008	ss8</span><br><span class="line">1004	ss4</span><br><span class="line">1009	ss9</span><br><span class="line">1005	ss5</span><br><span class="line">1001	ss1</span><br><span class="line">1013	ss13</span><br><span class="line">1010	ss10</span><br><span class="line">1002	ss2</span><br><span class="line">1006	ss6</span><br><span class="line">1014	ss14</span><br><span class="line">1003	ss3</span><br><span class="line">1011	ss11</span><br><span class="line">1007	ss7</span><br><span class="line">1015	ss15</span><br><span class="line">Time taken: 0.043 seconds, Fetched: 16 row(s)</span><br></pre></td></tr></table></figure></li>
<li><p>查看 HDFS 上的分桶结果</p>
<p> 表中的所有数据现在都根据 <code>id</code> 的 Hash 值分散在四个桶中了。Hash 是采用 MapReduce 默认的 Hash 分区器。</p>
<p> <img src="/2021/12/13/Hive/image-20211220125548362.png" alt="image-20211220125548362"></p>
</li>
</ol>
<hr>
<h3 id="4-4-2-分桶抽样查询"><a href="#4-4-2-分桶抽样查询" class="headerlink" title="4.4.2 分桶抽样查询"></a>4.4.2 分桶抽样查询</h3><p>对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是全部结果。<code>Hive</code> 可以通过对表进行抽样来满足这个需求。</p>
<p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 分桶表名 tablesample(bucket x out of y on 分桶字段);  </span><br></pre></td></tr></table></figure>

<p><strong>要求：</strong></p>
<ul>
<li><p>  抽样查询的表必须是分桶表</p>
</li>
<li><p>  假设当前表一共分了 <code>z</code> 个桶，<code>x</code> 表示从第 <code>x</code> 桶开始抽样，每间隔 <code>y</code> 桶抽一次，直到抽满 <code>z/y</code> 桶。</p>
</li>
<li><p>  <code>y</code> 必须是 <code>z</code> 的倍数或者因子。<code>Hive</code> 根据 <code>y</code> 的大小，决定抽样的比例。例如，<code>table</code> 总共分了 4 份，当 <code>y=2</code> 时，抽取 <code>(4/2)=2</code> 个 <code>bucket</code> 的数据，当 <code>y=8</code> 时，抽取 <code>(4/8)=1/2</code> 个 <code>bucket</code> 的数据。</p>
</li>
<li><p>  <code>x</code> 表示从第几个 <code>bucket</code> 开始抽取，如果需要取多个分区，以后的分区号为当前分区号加上 <code>y</code>。例如，<code>table</code> 总 <code>bucket</code> 数为 4， <code>tablesample(bucket 1 out of 2)</code>，表示总共抽取 <code>（4/2）= 2</code> 个 <code>bucket</code> 的数据，抽取第 1 个和第 3 个 <code>bucket</code> 的数据。</p>
</li>
<li><p>注意： <code>x</code> 的值必须小于等于 <code>y</code> 的值，否则会抛出异常。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FAILED: SemanticException [Error 10061]: Numerator should not be bigger than denominator in sample clause for table stu_buck</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ol>
<li><p>查询表 <code>stu_buck</code> 中的数据。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 当前表分了四桶（0~3号桶），当前次查询只查询第0号桶和2号桶中的数据</span><br><span class="line">hive (default)&gt; select * from stu_buck tablesample(bucket 1 out of 2 on id);</span><br><span class="line">OK</span><br><span class="line">stu_buck.id	stu_buck.name</span><br><span class="line">1016	ss16</span><br><span class="line">1012	ss12</span><br><span class="line">1008	ss8</span><br><span class="line">1004	ss4</span><br><span class="line">1010	ss10</span><br><span class="line">1002	ss2</span><br><span class="line">1006	ss6</span><br><span class="line">1014	ss14</span><br><span class="line">Time taken: 0.164 seconds, Fetched: 8 row(s)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="第5章-DML数据操作"><a href="#第5章-DML数据操作" class="headerlink" title="第5章 DML数据操作"></a>第5章 DML数据操作</h1><h2 id="5-1-数据导入"><a href="#5-1-数据导入" class="headerlink" title="5.1 数据导入"></a>5.1 数据导入</h2><h3 id="5-1-1-向表中装载数据（Load）"><a href="#5-1-1-向表中装载数据（Load）" class="headerlink" title="5.1.1 向表中装载数据（Load）"></a>5.1.1 向表中装载数据（Load）</h3><p><strong>作用：</strong>将数据加载到 Hive 表中</p>
<p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> load data [<span class="keyword">local</span>] inpath <span class="string">&#x27;/opt/module/datas/student.txt&#x27;</span> [overwrite] <span class="keyword">into</span> <span class="keyword">table</span> student [<span class="keyword">partition</span> (partcol1<span class="operator">=</span>val1,…)];</span><br><span class="line"></span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line">（<span class="number">1</span>）load data：表示加载数据</span><br><span class="line">（<span class="number">2</span>）<span class="keyword">local</span>：如果导入的文件位于本地文件系统，则使用 <span class="keyword">local</span> 关键字，表示使用 put 的方式将本地文件上传到 Hive 上的表目录中；如果不加 <span class="keyword">local</span> 默认导入的文件位于 HDFS 上，通过 mv 的方式将源文件移动到 Hive 的表目录中。</span><br><span class="line">（<span class="number">3</span>）inpath：表示加载数据的路径</span><br><span class="line">（<span class="number">4</span>）overwrite：表示覆盖表中已有数据，否则表示追加</span><br><span class="line">（<span class="number">5</span>）<span class="keyword">into</span> <span class="keyword">table</span>：表示加载到哪张表</span><br><span class="line">（<span class="number">6</span>）student：表示具体的表名</span><br><span class="line">（<span class="number">7</span>）<span class="keyword">partition</span>：表示上传到指定分区</span><br><span class="line"><span class="comment">---------------------------</span></span><br></pre></td></tr></table></figure>





<p><strong>实操案例</strong></p>
<ol>
<li><p>创建一张表</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> student(id string, name string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure>

</li>
<li><p>加载本地文件到 Hive</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> load data <span class="keyword">local</span> inpath <span class="string">&#x27;/opt/module/datas/student.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> default.student;</span><br></pre></td></tr></table></figure>

</li>
<li><p>加载 HDFS 中的文件到 Hive 中</p>
<ul>
<li><p>上传文件到 HDFS</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> dfs <span class="operator">-</span>put <span class="operator">/</span>opt<span class="operator">/</span><span class="keyword">module</span><span class="operator">/</span>datas<span class="operator">/</span>student.txt <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>atguigu<span class="operator">/</span>hive;</span><br></pre></td></tr></table></figure></li>
<li><p>加载 HDFS 中的文件到 Hive 中</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> load data inpath <span class="string">&#x27;/user/atguigu/hive/student.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> default.student;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>加载数据覆盖表中已有的数据</p>
<ul>
<li><p>上传文件到 HDFS</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> dfs <span class="operator">-</span>put <span class="operator">/</span>opt<span class="operator">/</span><span class="keyword">module</span><span class="operator">/</span>datas<span class="operator">/</span>student.txt <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>atguigu<span class="operator">/</span>hive;</span><br></pre></td></tr></table></figure></li>
<li><p>加载 HDFS 上的数据覆盖表中已有的数据</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> load data inpath <span class="string">&#x27;/user/atguigu/hive/student.txt&#x27;</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> default.student;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-1-2-通过查询语句向表中插入数据（Insert）"><a href="#5-1-2-通过查询语句向表中插入数据（Insert）" class="headerlink" title="5.1.2    通过查询语句向表中插入数据（Insert）"></a>5.1.2    通过查询语句向表中插入数据（Insert）</h3><p><code>insert</code> 方式运行 MapReduce 程序，通过程序将数据输出到表目录。</p>
<p>在某些场景，必须使用 <code>insert</code> 方式来导入数据。</p>
<ol>
<li> 向桶中插入数据</li>
<li> 如果想要使表中的数据以非文本的格式存储，需要使用 <code>insert</code> 的方式导入数据</li>
</ol>
<p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert &#123;into | overwrite&#125; table 表名 &#123;select xxx | values(...)&#125;</span><br><span class="line"></span><br><span class="line"># insert into：追加写</span><br><span class="line"># insert overwrite：覆盖写</span><br><span class="line"></span><br><span class="line"># select xxx：将从MySQL中查到的数据写入到Hive中</span><br><span class="line"># values(...)：直接显式指定要插入的值，如 values(1,&#x27;张三&#x27;)</span><br></pre></td></tr></table></figure>





<p><strong>Demo</strong></p>
<ol>
<li><p>创建一张分区表</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> student(id <span class="type">int</span>, name string) partitioned <span class="keyword">by</span> (<span class="keyword">month</span> string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>基本插入数据</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> student <span class="keyword">partition</span>(<span class="keyword">month</span><span class="operator">=</span><span class="string">&#x27;201709&#x27;</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;wangwu&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>基本模式插入（根据单张表查询结果）</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">insert</span> overwrite <span class="keyword">table</span> student <span class="keyword">partition</span>(<span class="keyword">month</span><span class="operator">=</span><span class="string">&#x27;201708&#x27;</span>)</span><br><span class="line">             <span class="keyword">select</span> id, name <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">month</span><span class="operator">=</span><span class="string">&#x27;201709&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>多插入模式（根据多张表查询结果）</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; from student</span><br><span class="line">              insert overwrite table student partition(month=&#x27;201707&#x27;)</span><br><span class="line">              select id, name where month=&#x27;201709&#x27;</span><br><span class="line">              insert overwrite table student partition(month=&#x27;201706&#x27;)</span><br><span class="line">              select id, name where month=&#x27;201710&#x27;;</span><br><span class="line">              </span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>多插入模式（从一张源表查询，向多张目标表插入）</strong>。在上面的语句中就是：</p>
<ol>
<li> 查询 month=’201709’ 的数据插入到 student 表的 month=’201707’ 分区中；</li>
<li> 查询 month=’201710’ 的数据插入到 student 表的 month=’201706’ 分区中；</li>
</ol>
<p>  <strong>语法：</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from 源表</span><br><span class="line">insert into 目标表 select xxx</span><br><span class="line">insert overwrite 目标表 select xxx</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ol>
<p>​    </p>
<hr>
<h3 id="5-1-3-查询语句中创建表并加载数据（As-Select）"><a href="#5-1-3-查询语句中创建表并加载数据（As-Select）" class="headerlink" title="5.1.3 查询语句中创建表并加载数据（As Select）"></a>5.1.3 查询语句中创建表并加载数据（As Select）</h3><p>详见 4.5.1 章创建表。</p>
<p>根据查询结果创建表（查询的结果会添加到新创建的表中）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> student3</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-1-4-创建表时通过-Location-指定加载数据路径"><a href="#5-1-4-创建表时通过-Location-指定加载数据路径" class="headerlink" title="5.1.4 创建表时通过 Location 指定加载数据路径"></a>5.1.4 创建表时通过 Location 指定加载数据路径</h3><ol>
<li><p>创建表，并指定表数据在 Hive 上的位置</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> student5(</span><br><span class="line">    id <span class="type">int</span>, name string</span><br><span class="line">)</span><br><span class="line">	<span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">	location <span class="string">&#x27;/user/hive/warehouse/student5&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>上传数据到 HDFS 上</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> dfs <span class="operator">-</span>put <span class="operator">/</span>opt<span class="operator">/</span><span class="keyword">module</span><span class="operator">/</span>datas<span class="operator">/</span>student.txt</span><br><span class="line"><span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>hive<span class="operator">/</span>warehouse<span class="operator">/</span>student5;</span><br></pre></td></tr></table></figure>

</li>
<li><p>查询数据</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student5;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="5-1-5-Import数据到指定Hive表中"><a href="#5-1-5-Import数据到指定Hive表中" class="headerlink" title="5.1.5 Import数据到指定Hive表中"></a>5.1.5 Import数据到指定Hive表中</h3><ul>
<li>  <strong>import</strong> 不仅可以导入业务数据，同时还可以导入元数据。 </li>
<li>  注意：<strong>import</strong> 只能导入 <strong>export</strong> 导出的数据。</li>
</ul>
<p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMPORT [[EXTERNAL] TABLE new_or_original_tablename [PARTITION (part_column=&quot;value&quot;[, ...])]]</span><br><span class="line">  FROM &#x27;source_path&#x27;</span><br><span class="line">  [LOCATION &#x27;import_target_path&#x27;]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  向一张表中导入数据时，如果表不存在，Hive 会根据导入数据中的元数据信息自动创建表。</p>
</li>
<li><p>  如果表已经存在，在导入之前会先检查目标表的元数据与导入数据中的元数据信息是否一致。检查通过后才会执行导入。</p>
</li>
<li><p>不管表是否为空，目标表中的分区必须是不存在的。</p>
</li>
</ul>
<p><strong>Demo</strong></p>
<ol>
<li><p>通过 import 将数据导入指定的 Hive 表中</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; import table import_table1 from &#x27;/export&#x27;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>查看导入后的表信息</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; show tables;</span><br><span class="line">OK</span><br><span class="line">import_table1</span><br><span class="line">student</span><br><span class="line">test</span><br><span class="line">Time taken: 0.018 seconds, Fetched: 8 row(s)</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; desc import_table1;</span><br><span class="line">OK</span><br><span class="line">col_name	data_type	comment</span><br><span class="line">deptno              	int                 	                    </span><br><span class="line">dname               	string              	                    </span><br><span class="line">loc                 	string              	                    </span><br><span class="line">month               	string              	                    </span><br><span class="line">	 	 </span><br><span class="line"># Partition Information	 	 分区信息</span><br><span class="line"># col_name            	data_type           	comment             </span><br><span class="line">	 	 </span><br><span class="line">month               	string              	                    </span><br><span class="line">Time taken: 0.076 seconds, Fetched: 9 row(s)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="5-2-数据导出"><a href="#5-2-数据导出" class="headerlink" title="5.2 数据导出"></a>5.2 数据导出</h2><h3 id="5-2-1-Insert-导出"><a href="#5-2-1-Insert-导出" class="headerlink" title="5.2.1 Insert 导出"></a>5.2.1 Insert 导出</h3><ol>
<li><p>将查询的结果导出到本地</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; insert overwrite local directory &#x27;/opt/module/datas/export/student&#x27;</span><br><span class="line">            select * from student;</span><br></pre></td></tr></table></figure></li>
<li><p>将查询的结果<strong>格式化</strong>后导出到本地</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive(default)&gt;insert overwrite local directory &#x27;/opt/module/datas/export/student1&#x27;</span><br><span class="line">           ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;\t&#x27;             </span><br><span class="line">           select * from student;</span><br></pre></td></tr></table></figure>

</li>
<li><p>将查询的结果导出到 HDFS 上（省略 local 关键字）</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; insert overwrite directory &#x27;/user/atguigu/student2&#x27;</span><br><span class="line">             ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;\t&#x27; </span><br><span class="line">             select * from student;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="5-2-2-Hadoop命令导出到本地"><a href="#5-2-2-Hadoop命令导出到本地" class="headerlink" title="5.2.2 Hadoop命令导出到本地"></a>5.2.2 Hadoop命令导出到本地</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; dfs -get /user/hive/warehouse/student/month=201709/000000_0</span><br><span class="line">/opt/module/datas/export/student3.txt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="5-2-3-Hive-Shell-命令导出"><a href="#5-2-3-Hive-Shell-命令导出" class="headerlink" title="5.2.3    Hive Shell 命令导出"></a>5.2.3    Hive Shell 命令导出</h3><p>基本语法：<code>hive -f/-e 执行语句或者脚本 &gt; file</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 hive]$ bin/hive -e <span class="string">&#x27;select * from default.student;&#x27;</span> &gt; </span><br><span class="line">/opt/module/datas/export/student4.txt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-2-4-Export-导出到-HDFS-上"><a href="#5-2-4-Export-导出到-HDFS-上" class="headerlink" title="5.2.4    Export 导出到 HDFS 上"></a>5.2.4    Export 导出到 HDFS 上</h3><p><strong>Export：</strong></p>
<ul>
<li>  既能导出数据，还可以导入元数据</li>
<li>  <code>export</code> 只能导出到 HDFS 中，会在 HDFS 的导出目录中，生成数据和元数据文件。</li>
<li>  如果当前表是一个分区表，可以选择只导出表的部分分区数据及其元数据信息。</li>
</ul>
<p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT TABLE tablename [PARTITION (part_column=&quot;value&quot;[, ...])]</span><br><span class="line">  TO &#x27;export_target_path&#x27; [ FOR replication(&#x27;eventid&#x27;) ]</span><br></pre></td></tr></table></figure>





<p><strong>Demo：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> EXPORT <span class="keyword">TABLE</span> dept_partition <span class="keyword">TO</span> <span class="string">&#x27;/export&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看 HDFS 上的文件结构</p>
<p>  <img src="/2021/12/13/Hive/image-20211220175855162.png" alt="image-20211220175855162"></p>
</li>
</ul>
<hr>
<h3 id="5-2-5-Sqoop-导出"><a href="#5-2-5-Sqoop-导出" class="headerlink" title="5.2.5    Sqoop 导出"></a>5.2.5    Sqoop 导出</h3><p>后续课程专门讲。</p>
<hr>
<h2 id="5-3-清除表中数据（Truncate）"><a href="#5-3-清除表中数据（Truncate）" class="headerlink" title="5.3 清除表中数据（Truncate）"></a>5.3 清除表中数据（Truncate）</h2><p>注意：<code>Truncate</code> 只能删除管理表，不能删除外部表中数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">truncate</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="第-6-章-查询"><a href="#第-6-章-查询" class="headerlink" title="第 6 章    查询"></a>第 6 章    查询</h1><p>官网：<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select</a></p>
<p><strong>查询语句语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">WITH</span> CommonTableExpression (, CommonTableExpression)<span class="operator">*</span>]    (Note: <span class="keyword">Only</span> available starting <span class="keyword">with</span> Hive <span class="number">0.13</span><span class="number">.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] select_expr, select_expr, ...</span><br><span class="line"><span class="keyword">FROM</span> table_reference</span><br><span class="line">[<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> col_list]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> col_list]</span><br><span class="line">[CLUSTER <span class="keyword">BY</span> col_list <span class="operator">|</span> [DISTRIBUTE <span class="keyword">BY</span> col_list] [SORT <span class="keyword">BY</span> col_list]]</span><br><span class="line">[LIMIT number]</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="6-1-基础查询（Select…From）"><a href="#6-1-基础查询（Select…From）" class="headerlink" title="6.1 基础查询（Select…From）"></a>6.1 基础查询（Select…From）</h2><h3 id="6-1-1-全表和特定列查询"><a href="#6-1-1-全表和特定列查询" class="headerlink" title="6.1.1 全表和特定列查询"></a>6.1.1 全表和特定列查询</h3><ol>
<li><p>全表查询</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li>
<li><p>特定列查询</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> empno, ename <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li> SQL 语言大小写不敏感。</li>
<li>  SQL 可以写在一行或者多行。</li>
</ol>
<h3 id="6-1-2-列别名"><a href="#6-1-2-列别名" class="headerlink" title="6.1.2 列别名"></a>6.1.2 列别名</h3><p>列别名的规则与 MySQL 相同，可以紧跟列名，也可以在列名和别名之间加入关键字 AS。 </p>
<p>案例实操：查询名称和部门</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> ename <span class="keyword">AS</span> name, deptno dn <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="6-1-3-算术运算符"><a href="#6-1-3-算术运算符" class="headerlink" title="6.1.3 算术运算符"></a>6.1.3 算术运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>A + B</code></td>
<td>A 加 B</td>
</tr>
<tr>
<td align="center"><code>A - B</code></td>
<td>A 减 B</td>
</tr>
<tr>
<td align="center"><code>A * B</code></td>
<td>A 乘 B</td>
</tr>
<tr>
<td align="center"><code>A / B</code></td>
<td>A 除 B</td>
</tr>
<tr>
<td align="center"><code>A % B</code></td>
<td>A 对 B 取余</td>
</tr>
<tr>
<td align="center"><code>A &amp; B</code></td>
<td>A 和 B 按位与</td>
</tr>
<tr>
<td align="center">`A</td>
<td>B`</td>
</tr>
<tr>
<td align="center"><code>A ^ B</code></td>
<td>A 和 B 按位异或</td>
</tr>
<tr>
<td align="center"><code>~A</code></td>
<td>A 按位取反</td>
</tr>
</tbody></table>
<p>案例实操：查询出所有员工的薪水后 <code>+1</code> 显示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> sal <span class="operator">+</span><span class="number">1</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="6-1-4-常用函数"><a href="#6-1-4-常用函数" class="headerlink" title="6.1.4 常用函数"></a>6.1.4 常用函数</h3><ol>
<li><p>求总行数（count）</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) cnt <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li>
<li><p>求工资的最大值（max）</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">max</span>(sal) max_sal <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li>
<li><p>求工资的最小值（min）</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">min</span>(sal) min_sal <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li>
<li><p>求工资的总和（sum）</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">sum</span>(sal) sum_sal <span class="keyword">from</span> emp; </span><br></pre></td></tr></table></figure></li>
<li><p>求工资的平均值（avg）</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">avg</span>(sal) avg_sal <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="6-1-5-Limit-语句"><a href="#6-1-5-Limit-语句" class="headerlink" title="6.1.5 Limit 语句"></a>6.1.5 Limit 语句</h3><p>典型的查询会返回多行数据。LIMIT 子句用于限制返回的行数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="6-2-Where语句"><a href="#6-2-Where语句" class="headerlink" title="6.2 Where语句"></a>6.2 Where语句</h2><p>案例实操：查询出薪水大于 1000 的所有员工</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="6-2-1-比较运算符（Between-In-Is-Null）"><a href="#6-2-1-比较运算符（Between-In-Is-Null）" class="headerlink" title="6.2.1 比较运算符（Between / In / Is Null）"></a>6.2.1 比较运算符（Between / In / Is Null）</h3><p>下面表中描述了谓词操作符，这些操作符同样可以用于 <code>JOIN…ON</code> 和 <code>HAVING</code> 语句中。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>支持的数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>A=B</code></td>
<td>基本数据类型</td>
<td>如果 A 等于 B 则返回 TRUE，反之返回 FALSE</td>
</tr>
<tr>
<td><code>A&lt;=&gt;B</code></td>
<td>基本数据类型</td>
<td>如果 A 和 B 都为 NULL，则返回TRUE；<br>如果任一为 NULL 则结果为 NULL；<br>其它的和等号（=）操作符的结果一致。</td>
</tr>
<tr>
<td><code>A&lt;&gt;B</code>，<code>A!=B</code></td>
<td>基本数据类型</td>
<td>A 或 B 为 NULL 则返回NULL；<br>如果 A 不等于 B，则返回 TRUE，反之返回 FALSE</td>
</tr>
<tr>
<td><code>A&lt;B</code></td>
<td>基本数据类型</td>
<td>A 或 B 为 NULL，则返回 NULL；<br>如果 A 小于 B，则返回 TRUE，反之返回 FALSE</td>
</tr>
<tr>
<td><code>A&lt;=B</code></td>
<td>基本数据类型</td>
<td>A 或 B 为 NULL，则返回 NULL；<br>如果 A 小于等于 B，则返回 TRUE，反之返回 FALSE</td>
</tr>
<tr>
<td><code>A&gt;B</code></td>
<td>基本数据类型</td>
<td>A 或 B 为 NULL，则返回 NULL；<br>如果 A 大于 B，则返回 TRUE，反之返回 FALSE</td>
</tr>
<tr>
<td><code>A&gt;=B</code></td>
<td>基本数据类型</td>
<td>A 或 B 为 NULL，则返回 NULL；<br>如果 A 大于等于 B，则返回 TRUE，反之返回 FALSE</td>
</tr>
<tr>
<td><code>A [NOT] BETWEEN B AND C</code></td>
<td>基本数据类型</td>
<td>如果 A、B 或 C 任一为 NULL，则结果为NULL。<br>如果 A 的值大于等于 B 而且小于或等于 C，则结果为 TRUE，<br>反之为 FALSE。如果使用 NOT 关键字则可达到相反的效果</td>
</tr>
<tr>
<td><code>A IS NULL</code></td>
<td>所有数据类型</td>
<td>如果 A 等于 NULL，则返回 TRUE，反之返回 FALSE</td>
</tr>
<tr>
<td><code>A IS NOT NULL</code></td>
<td>所有数据类型</td>
<td>如果 A 不等于 NULL，则返回 TRUE，反之返回 FALSE</td>
</tr>
<tr>
<td><code>IN(数值1, 数值2) </code></td>
<td>所有数据类型</td>
<td>使用 IN 运算显示列表中的值</td>
</tr>
<tr>
<td><code>A [NOT] LIKE B</code></td>
<td>STRING 类型</td>
<td>B 是一个 SQL 下的简单正则表达式，如果 A 与其匹配的话，则返回TRUE；<br>反之返回 FALSE。B 的表达式说明如下：<code>x%</code> 表示 A 必须以字母 <code>x</code> 开头，<br><code>%x</code> 表示 A 必须以字母 <code>x</code> 结尾，而 <code>%x%</code> 表示 A 包含有字母 <code>x</code>，可以位于开头，<br>结尾或者字符串中间。如果使用 NOT 关键字则可达到相反的效果。</td>
</tr>
<tr>
<td><code>A RLIKE B, A REGEXP B</code></td>
<td>STRING 类型</td>
<td>B 是一个正则表达式，如果 A 与其匹配，则返回 TRUE；反之返回 FALSE。<br>匹配使用的是 JDK 中的正则表达式接口实现的，因为正则也依据其中的规则。<br>例如，正则表达式必须和整个字符串 A 相匹配，而不是只需与其字符串匹配</td>
</tr>
</tbody></table>
<p><strong>案例实操</strong></p>
<ol>
<li><p>查询出薪水等于 5000 的所有员工</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">=</span><span class="number">5000</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查询工资在 500 到 1000 的员工信息</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">between</span> <span class="number">500</span> <span class="keyword">and</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查询 <code>comm</code> 为空的所有员工信息</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> comm <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查询工资是 1500 或 5000 的员工信息</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">IN</span> (<span class="number">1500</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="6-2-2-Like-和-RLike"><a href="#6-2-2-Like-和-RLike" class="headerlink" title="6.2.2 Like 和 RLike"></a>6.2.2 Like 和 RLike</h3><ol>
<li> 使用 LIKE 运算选择类似的值</li>
<li>选择条件可以包含字符或数字：<ul>
<li>  <code>%</code> 代表零个或多个字符(任意个字符)。</li>
<li>  <code>_</code> 代表一个字符。</li>
</ul>
</li>
<li> <code>RLIKE</code> 子句是 Hive 中这个功能的一个扩展，其可以通过 Java 的正则表达式这个更强大的语言来指定匹配条件。</li>
</ol>
<p><strong>案例实操</strong></p>
<ol>
<li><p>查找以 2 开头薪水的员工信息</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">LIKE</span> <span class="string">&#x27;2%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查找第二个数值为 2 的薪水的员工信息</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">LIKE</span> <span class="string">&#x27;_2%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查找薪水中含有 2 的员工信息</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal RLIKE <span class="string">&#x27;[2]&#x27;</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="6-2-3-逻辑运算符（And-Or-Not）"><a href="#6-2-3-逻辑运算符（And-Or-Not）" class="headerlink" title="6.2.3    逻辑运算符（And/Or/Not）"></a>6.2.3    逻辑运算符（And/Or/Not）</h3><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AND</td>
<td align="center">与</td>
</tr>
<tr>
<td align="center">OR</td>
<td align="center">或</td>
</tr>
<tr>
<td align="center">NOT</td>
<td align="center">非</td>
</tr>
</tbody></table>
<p><strong>案例实操</strong></p>
<ol>
<li><p>查询薪水大于 1000，部门是 30</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal<span class="operator">&gt;</span><span class="number">1000</span> <span class="keyword">and</span> deptno<span class="operator">=</span><span class="number">30</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查询薪水大于 1000，或者部门是30</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal<span class="operator">&gt;</span><span class="number">1000</span> <span class="keyword">or</span> deptno<span class="operator">=</span><span class="number">30</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查询除了 20 部门和 30 部门以外的员工信息</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="keyword">not</span> <span class="keyword">IN</span>(<span class="number">30</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="6-3-分组"><a href="#6-3-分组" class="headerlink" title="6.3    分组"></a>6.3    分组</h2><h3 id="6-3-1-Group-By语句"><a href="#6-3-1-Group-By语句" class="headerlink" title="6.3.1    Group By语句"></a>6.3.1    Group By语句</h3><p><code>GROUP BY</code> 语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，然后对每个组执行聚合操作。</p>
<p><strong>案例实操：</strong></p>
<ol>
<li><p>计算 <code>emp</code> 表每个部门的平均工资</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> t.deptno, <span class="built_in">avg</span>(t.sal) avg_sal <span class="keyword">from</span> emp t <span class="keyword">group</span> <span class="keyword">by</span> t.deptno;</span><br></pre></td></tr></table></figure></li>
<li><p>计算 <code>emp</code> 每个部门中每个岗位的最高薪水</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> t.deptno, t.job, <span class="built_in">max</span>(t.sal) max_sal <span class="keyword">from</span> emp t <span class="keyword">group</span> <span class="keyword">by</span> t.deptno, t.job;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="6-3-2-Having-语句"><a href="#6-3-2-Having-语句" class="headerlink" title="6.3.2    Having 语句"></a>6.3.2    Having 语句</h3><p><strong><code>having</code> 与 <code>where</code> 不同点：</strong></p>
<ol>
<li> <code>where</code> 针对表中的列发挥作用，查询数据；<code>having</code> 针对查询结果中的列发挥作用，筛选数据。</li>
<li> <code>where</code> 后面不能写分组函数，而 <code>having</code> 后面可以使用分组函数。</li>
<li> <code>having</code> 只用于 <code>group by</code> 分组统计语句。</li>
</ol>
<p><strong>案例实操</strong>：求所有部门中平均薪水大于 2000 的部门</p>
<ol>
<li><p>求每个部门的平均工资</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> deptno, <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure></li>
<li><p>求所有部门中平均薪水大于 2000 的部门</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> deptno, <span class="built_in">avg</span>(sal) avg_sal <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> avg_sal <span class="operator">&gt;</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="6-4-Join语句"><a href="#6-4-Join语句" class="headerlink" title="6.4 Join语句"></a>6.4 Join语句</h2><h3 id="6-4-1-等值Join"><a href="#6-4-1-等值Join" class="headerlink" title="6.4.1 等值Join"></a>6.4.1 等值Join</h3><p>Hive 支持常用的 <code>SQL JOIN</code> 语句，但是只支持等值连接，不支持非等值连接。</p>
<p><strong>案例实操</strong></p>
<ol>
<li><p>根据员工表和部门表中的部门编号相等，查询员工编号、员工名称和部门名称；</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> </span><br><span class="line">	<span class="keyword">select</span> e.empno, e.ename, d.deptno, d.dname </span><br><span class="line">	<span class="keyword">from</span> emp e <span class="keyword">join</span> dept d</span><br><span class="line">	<span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="6-4-2-表的别名"><a href="#6-4-2-表的别名" class="headerlink" title="6.4.2    表的别名"></a>6.4.2    表的别名</h3><p><strong>好处：</strong></p>
<ol>
<li> 使用别名可以简化查询。</li>
<li> 使用表名前缀可以提高执行效率。</li>
</ol>
<p><strong>案例实操</strong></p>
<ol>
<li><p>合并员工表和部门表</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> </span><br><span class="line">	<span class="keyword">select</span> e.empno, e.ename, d.deptno </span><br><span class="line">	<span class="keyword">from</span> emp e <span class="keyword">join</span> dept d </span><br><span class="line">	<span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="6-4-3-内连接"><a href="#6-4-3-内连接" class="headerlink" title="6.4.3    内连接"></a>6.4.3    内连接</h3><p><strong>内连接：</strong>只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> </span><br><span class="line">	<span class="keyword">select</span> e.empno, e.ename, d.deptno </span><br><span class="line">	<span class="keyword">from</span> emp e <span class="keyword">join</span> dept d </span><br><span class="line">	<span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="6-4-4-左外连接"><a href="#6-4-4-左外连接" class="headerlink" title="6.4.4    左外连接"></a>6.4.4    左外连接</h3><p><strong>左外连接：</strong>JOIN 操作符左边表中符合 WHERE 子句的所有记录将会被返回。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> </span><br><span class="line">	<span class="keyword">select</span> e.empno, e.ename, d.deptno </span><br><span class="line">	<span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">join</span> dept d </span><br><span class="line">	<span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="6-4-5-右外连接"><a href="#6-4-5-右外连接" class="headerlink" title="6.4.5    右外连接"></a>6.4.5    右外连接</h3><p><strong>右外连接：</strong>JOIN 操作符右边表中符合 WHERE 子句的所有记录将会被返回。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> </span><br><span class="line">	<span class="keyword">select</span> e.empno, e.ename, d.deptno </span><br><span class="line">	<span class="keyword">from</span> emp e <span class="keyword">right</span> <span class="keyword">join</span> dept d </span><br><span class="line">	<span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="6-4-6-全外连接"><a href="#6-4-6-全外连接" class="headerlink" title="6.4.6    全外连接"></a>6.4.6    全外连接</h3><p><strong>全外连接：</strong>将会返回所有表中符合 WHERE 语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用 NULL 值替代。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> </span><br><span class="line">	<span class="keyword">select</span> e.empno, e.ename, d.deptno </span><br><span class="line">	<span class="keyword">from</span> emp e <span class="keyword">full</span> <span class="keyword">join</span> dept d </span><br><span class="line">	<span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="6-4-7-多表连接"><a href="#6-4-7-多表连接" class="headerlink" title="6.4.7    多表连接"></a>6.4.7    多表连接</h3><p><strong>注意：</strong>连接 <code>n</code> 个表，至少需要 <code>n-1</code> 个连接条件。例如：连接三个表，至少需要两个连接条件。</p>
<p><strong>数据准备</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1700	Beijing</span><br><span class="line">1800	London</span><br><span class="line">1900	Tokyo</span><br></pre></td></tr></table></figure>



<ol>
<li><p>创建位置表</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> default.location(</span><br><span class="line">    loc <span class="type">int</span>,</span><br><span class="line">    loc_name string</span><br><span class="line">)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>导入数据</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> load data <span class="keyword">local</span> inpath <span class="string">&#x27;/opt/module/datas/location.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> default.location;</span><br></pre></td></tr></table></figure></li>
<li><p>多表连接查询</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">SELECT</span> e.ename, d.deptno, l. loc_name</span><br><span class="line">    <span class="keyword">FROM</span>   emp e </span><br><span class="line">    <span class="keyword">JOIN</span>   dept d</span><br><span class="line">    <span class="keyword">ON</span>     d.deptno <span class="operator">=</span> e.deptno </span><br><span class="line">    <span class="keyword">JOIN</span>   location l</span><br><span class="line">    <span class="keyword">ON</span>     d.loc <span class="operator">=</span> l.loc;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>大多数情况下，Hive 会对每对 <code>JOIN</code> 连接对象启动一个 <code>MapReduce</code> 任务。本例中会首先启动一个 <code>MapReduce job</code> 对表 <code>e</code> 和表 <code>d</code> 进行连接操作，然后会再启动一个 <code>MapReduce job</code> 将第一个 <code>MapReduce job</code> 的输出和表 <code>l</code> 进行连接操作。</p>
<p>注意：为什么不是表 <code>d</code> 和表 <code>l</code> 先进行连接操作呢？这是因为 Hive 总是按照从左到右的顺序执行的。</p>
<hr>
<h3 id="6-4-8-笛卡尔积"><a href="#6-4-8-笛卡尔积" class="headerlink" title="6.4.8    笛卡尔积"></a>6.4.8    笛卡尔积</h3><p>笛卡尔集会在下面条件下产生：</p>
<ol>
<li> 省略连接条件</li>
<li> 连接条件无效</li>
<li> 所有表中的所有行互相连接</li>
</ol>
<p><strong>案例实操</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> empno, dname <span class="keyword">from</span> emp, dept;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="6-4-9-连接谓词中不支持or"><a href="#6-4-9-连接谓词中不支持or" class="headerlink" title="6.4.9    连接谓词中不支持or"></a>6.4.9    连接谓词中不支持or</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	select e.empno, e.ename, d.deptno </span><br><span class="line">	from emp e join dept d </span><br><span class="line">	on e.deptno = d.deptno or e.ename=d.ename;   # 错误的</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="6-5-排序"><a href="#6-5-排序" class="headerlink" title="6.5 排序"></a>6.5 排序</h2><p>Hive 的本质是 MapReduce，所以 Hive 的排序和 MapReduce 中的排序相关。在 MapReduce 中，排序可分为：</p>
<ul>
<li>  全排序：结果只有一个（只有一个分区），所有的数据整体有序</li>
<li>  部分排序：结果有多个（有多个分区），每个分区内部有序</li>
</ul>
<p>排序是在 Shuffle 阶段完成的，在 Reduce 阶段开始前就已经完成了。</p>
<h3 id="6-5-1-全局排序（Order-By）"><a href="#6-5-1-全局排序（Order-By）" class="headerlink" title="6.5.1    全局排序（Order By）"></a>6.5.1    全局排序（Order By）</h3><ol>
<li> <code>Order By</code>：全排序，只有一个分区，使用一个 <code>ReducTask</code> 进程</li>
<li>使用 <code>ORDER BY</code> 子句排序<ul>
<li>  <code>ASC（ascend）</code>: 升序（默认）</li>
<li>  <code>DESC（descend）</code>: 降序</li>
</ul>
</li>
<li> <code>ORDER BY</code> 子句在 <code>SELECT</code> 语句的结尾</li>
</ol>
<p><strong>案例实操</strong></p>
<ol>
<li><p>查询员工信息按工资升序排列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from emp order by sal;</span><br></pre></td></tr></table></figure></li>
<li><p>查询员工信息按工资降序排列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from emp order by sal desc;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="6-5-2-按照别名排序"><a href="#6-5-2-按照别名排序" class="headerlink" title="6.5.2    按照别名排序"></a>6.5.2    按照别名排序</h3><ol>
<li><p>按照员工薪水的 2 倍排序</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select ename, sal*2 twosal from emp order by twosal;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="6-5-3-复合排序"><a href="#6-5-3-复合排序" class="headerlink" title="6.5.3    复合排序"></a>6.5.3    复合排序</h3><p>按照多个列的值进行排序</p>
<ol>
<li><p>按照部门号和工资升序排序</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select ename, deptno, sal from emp order by deptno, sal ;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="6-5-4-部分排序（Sort-By）"><a href="#6-5-4-部分排序（Sort-By）" class="headerlink" title="6.5.4    部分排序（Sort By）"></a>6.5.4    部分排序（Sort By）</h3><p><code>Sort By</code>：每个分区内部排序，对全局结果集来说不是排序。对于多个分区需要设置 <code>reduceTaskNum &gt; 1</code>。</p>
<ol>
<li><p>设置 <code>reduceTaskNum</code> 的数量，决定了分区的个数</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; set mapreduce.job.reduces=3;</span><br></pre></td></tr></table></figure>

</li>
<li><p>查看 <code>reduceTaskNum</code> 的值</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; set mapreduce.job.reduces;</span><br></pre></td></tr></table></figure>

</li>
<li><p>根据部门编号降序查看员工信息</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from emp sort by empno desc;</span><br></pre></td></tr></table></figure>

</li>
<li><p>将查询结果导入到文件中（按照部门编号降序排序）</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; </span><br><span class="line">	insert overwrite local directory &#x27;/opt/module/datas/sortby-result&#x27;</span><br><span class="line">	select * from emp sort by deptno desc;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>Hive</code> 底层调用了 <code>MapReduce</code>，对于 <code>MapReduce</code> 来说，默认的分区器是 <code>Hash</code> 分区器，并且采用键值对数据中 key 的 <code>hash</code> 值来进行分区。对于使用 <code>sort by</code> 进行分区内排序的记录，我们无法确定哪一个字段将会作为 <code>hash</code> 分区器的 key，所以说 <code>sort by</code> 是随机分区，能够作为 <code>key</code> 的字段是随机的。如果希望能够显式指定一个表中的字段作为 <code>key</code>，则需要使用 <code>Distribute By</code> 关键字来进行分区间的排序。</p>
<hr>
<h3 id="6-5-5-分区排序（Distribute-By）"><a href="#6-5-5-分区排序（Distribute-By）" class="headerlink" title="6.5.5    分区排序（Distribute By）"></a>6.5.5    分区排序（Distribute By）</h3><p><code>Distribute By</code>：指定按照哪个字段分区。类似 <code>MR</code> 中 <code>partition</code>，进行分区，结合 <code>sort by</code> 使用。</p>
<p><strong>注意</strong>：<code>Hive</code> 要求 <code>DISTRIBUTE BY</code> 语句要写在 <code>SORT BY</code> 语句之前。</p>
<p>对于 <code>distribute by</code> 进行测试，一定要分配多 <code>reduce</code> 进行处理，否则无法看到 <code>distribute by</code> 的效果。</p>
<p><strong>案例实操：</strong></p>
<ol>
<li><p>先按照部门编号分区，再按照员工编号降序排序。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   hive (default)&gt; set mapreduce.job.reduces=3;</span><br><span class="line">   hive (default)&gt; </span><br><span class="line">   	insert overwrite local directory &#x27;/opt/module/datas/distribute-result&#x27; </span><br><span class="line">   	select * from emp </span><br><span class="line">   	distribute by deptno 	# 指定作为分区器key的字段</span><br><span class="line">sort by empno desc;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="6-5-6-Cluster-By"><a href="#6-5-6-Cluster-By" class="headerlink" title="6.5.6    Cluster By"></a>6.5.6    Cluster By</h3><p>如果用于分区的字段和用于排序的字段相同时，可以简写为 <code>cluster by</code> 。</p>
<p>当 <code>distribute by</code> 和 <code>sorts by</code> 排序的字段相同时，可以使用 <code>cluster by</code> 的方式。</p>
<p><code>cluster by</code> 除了具有 <code>distribute by</code> 的功能外还兼具 <code>sort by</code> 的功能。但是排序只能是升序排序，不能指定排序规则为 <code>ASC</code> 或者 <code>DESC</code>。</p>
<ul>
<li><p>以下两种写法等价</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from emp cluster by deptno;</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select * from emp distribute by deptno sort by deptno;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意：按照部门编号分区，不一定就是固定死的数值，可以是20号和30号部门分到一个分区里面去。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/11/Spark-Streaming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/11/Spark-Streaming/" class="post-title-link" itemprop="url">Spark_Streaming</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-11 20:50:37" itemprop="dateCreated datePublished" datetime="2021-12-11T20:50:37+08:00">2021-12-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
