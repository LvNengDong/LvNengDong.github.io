<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/10/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/10/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" class="post-title-link" itemprop="url">数据结构——栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-25 10:07:36 / Modified: 10:39:56" itemprop="dateCreated datePublished" datetime="2021-08-25T10:07:36+08:00">2021-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="中缀-前缀-后缀-表达式之间的互相转换"><a href="#中缀-前缀-后缀-表达式之间的互相转换" class="headerlink" title="中缀 / 前缀 / 后缀 表达式之间的互相转换"></a>中缀 / 前缀 / 后缀 表达式之间的互相转换</h2><ul>
<li>  中缀表达式就是我们常见的算术表达式</li>
<li>  中缀表达式是由括号，而前缀和后缀表达式都是没有括号的。</li>
<li>  编译系统对算术表达式的处理是先把它转换为后缀表达式。所以<strong>计算机底层执行的是没有括号的后缀表达式</strong>。</li>
</ul>
<blockquote>
<p>  <strong>基本转换规则</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：a+b</span><br><span class="line">前缀表达式：+ab</span><br><span class="line">后缀表达式：ab+</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>中缀 –&gt; 前缀</strong></p>
</blockquote>
<ul>
<li>  基本转换规则中的每一部分都可以视为一个整体，中缀转前缀的手工转换写法就是把一个复杂的表达式划分成两部分，将符号部分提到数据后面即可。</li>
<li>步骤：<ol>
<li> 每一个表达式用括号括起来</li>
<li> 两个表达式中间的运算符提到括号前面</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：(a+b)*c+d-(e+g)*h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、将该中缀表达式分成两部分</span><br><span class="line">[(a+b)*c+d] - [(e+g)*h]</span><br><span class="line"><span class="number">2</span>、将运算符移动到最前端</span><br><span class="line">-[(a+b)*c+d]  [(e+g)*h]</span><br><span class="line"><span class="number">3</span>、再依次递归地拆分两个子表达式，同理也是将每个子表达式拆成两部分，将运算符提到最前面</span><br><span class="line">	(a+b)*c+d </span><br><span class="line">==&gt; ((a+b)*c)+d</span><br><span class="line">==&gt; +((a+b)*c) d</span><br><span class="line">==&gt; + * (a+b) <span class="type">c</span> <span class="variable">d</span></span><br><span class="line"><span class="operator">=</span>=&gt; + * + a b c <span class="title function_">d</span></span><br><span class="line">	</span><br><span class="line">	<span class="params">(e+g)</span>*h</span><br><span class="line">==&gt; * (e+g)h</span><br><span class="line">==&gt; * + egh</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、将三部分拼接起来</span><br><span class="line">-  +*+abcd  *+egh  ==&gt; -+*+abcd*+egh</span><br></pre></td></tr></table></figure>



<ul>
<li>  中缀转前缀表达式不是唯一的，因为交换律的存在。比如上面的例子中缀表达式可以拆分为 <code>[(a+b)*c] + [d-(e+g)*h]</code>，也可以拆分为 <code>[(a+b)*c+d] - [(e+g)*h]</code>，这样得到的前缀表达式就是不一样的，但是这两种都是正确的。</li>
</ul>
<blockquote>
<p>  <strong>中缀 –&gt; 后缀</strong></p>
</blockquote>
<ul>
<li>  中缀转后缀表达式的手工写法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：(a+b)*c+d-(e+g)*h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、给所有的子表达式都加上括号</span><br><span class="line">	(((a+b)*c)+d)-((e+g)*h)</span><br><span class="line"><span class="number">2</span>、遇到左括号跳过，遇到右括号就将子表达式的符号提到括号后面，并去掉括号</span><br><span class="line">	(((a+b)*c)+d)-((e+g)*h)</span><br><span class="line">==&gt; (((ab+)*c)+d)-((e+g)*h)</span><br><span class="line">==&gt; ((ab+c*)+d)-((e+g)*h)</span><br><span class="line">==&gt; (ab+c*d+)-((e+g)*h)</span><br><span class="line">==&gt; (ab+c*d+)((e+g)*h)-</span><br><span class="line">==&gt; (ab+c*d+)-((eg+)*h)</span><br><span class="line">==&gt; (ab+c*d+)-(eg+h*)</span><br><span class="line">==&gt; (ab+c*d+)(eg+h*)-</span><br><span class="line">==&gt; ab+c*d+eg+h*-</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">位运算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-17 10:58:27" itemprop="dateCreated datePublished" datetime="2021-08-17T10:58:27+08:00">2021-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-25 10:47:10" itemprop="dateModified" datetime="2021-10-25T10:47:10+08:00">2021-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><blockquote>
<p>  <strong>原码、反码、补码的关系</strong></p>
</blockquote>
<p><strong>正数：</strong></p>
<ul>
<li>  三码合一</li>
</ul>
<p><strong>负数：</strong></p>
<ul>
<li>  负数的反码是在其原码的基础上，符号位不变，其余各位取反。</li>
<li>  负数的补码是在反码的基础上+1</li>
</ul>
<hr>
<h1 id="1-位运算基本操作"><a href="#1-位运算基本操作" class="headerlink" title="1    位运算基本操作"></a>1    位运算基本操作</h1><blockquote>
<ul>
<li>  与：<code>&amp;</code></li>
<li>  或：<code>|</code></li>
<li>  异或：<code>^</code></li>
<li>  取反：<code>~</code></li>
<li>  左移：<code>&lt;&lt;</code></li>
<li>  右移：<code>&gt;&gt;</code></li>
<li>  无符号右移：<code>&gt;&gt;&gt;</code></li>
</ul>
</blockquote>
<h2 id="1-1-与、或、异或、取反"><a href="#1-1-与、或、异或、取反" class="headerlink" title="1.1    与、或、异或、取反"></a>1.1    与、或、异或、取反</h2><blockquote>
<p>  <strong>逻辑运算符 与 位运算符 中的 <code>&amp;</code> 和 <code>|</code></strong></p>
</blockquote>
<ul>
<li>  位运算符是对操作数的二进制位进行运算，操作数和计算结果都是<strong>整型</strong>；</li>
<li>  逻辑运算符的操作数和计算结果都是<strong>布尔类型</strong>。</li>
</ul>
<blockquote>
<p>  <strong>常用的位运算符</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">实例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移</td>
<td align="center"><code>4&lt;&lt;2</code></td>
<td align="center">16</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">右移</td>
<td align="center"><code>4&gt;&gt;1</code></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;&gt;</code></td>
<td align="center">无符号右移</td>
<td align="center"><code>4&gt;&gt;&gt;1</code></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="center">与</td>
<td align="center"><code>4 &amp; 2</code></td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">`</td>
<td align="center"><code>或</code></td>
<td align="center">` 4</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">异或</td>
<td align="center"><code>4 ^ 2</code></td>
<td align="center">6</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center">取反</td>
<td align="center"><code>-4</code></td>
<td align="center">-5</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>位运算符规则1</strong></p>
</blockquote>
<ul>
<li>  &amp; ：两个二进制位只有全为 1 时结果为 1 ，否则结果为 0 。</li>
<li>  | ：两个二进制位只要有一个为 1 那么结果就为 1 ，否则结果为 0 。</li>
<li>  ^ ：任何相同二进制位进行 ^ 运算，结果是 0；不相同二进制位 ^ 运算结果是 1 。【同0异1】</li>
<li>  ~ ：取反。0 变 1，1 变 0 。</li>
</ul>
<p><strong>助记</strong>：记忆 <code>&amp;</code> 和 <code>|</code> 时，可以类比的把 1 看做 TRUE，0 看做 FALSE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 和 1 之间的 &amp; 和 | 分别都有三种情况：</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 1 视为 true， 0 视为 false，则可得到如下转化关系</span></span><br><span class="line"><span class="literal">false</span> &amp; <span class="literal">false</span> = <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span> &amp; <span class="literal">true</span> = <span class="literal">false</span></span><br><span class="line"><span class="literal">true</span> &amp; <span class="literal">true</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，| 的三种情况为：</span></span><br><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">================</span><br><span class="line"><span class="literal">false</span> | <span class="literal">false</span> = <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span> | <span class="literal">true</span> = <span class="literal">true</span></span><br><span class="line"><span class="literal">true</span> | <span class="literal">true</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//与</span></span><br><span class="line">        System.out.println(<span class="number">3</span> &amp; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        System.out.println(<span class="number">3</span> | <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//异或</span></span><br><span class="line">        System.out.println(<span class="number">3</span> ^ <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//取反</span></span><br><span class="line">        System.out.println(~<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">-<span class="number">4</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>分析</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>） <span class="number">3</span> &amp; <span class="number">4</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 4的二进制</span></span><br><span class="line">	</span><br><span class="line">	&amp;运算：有<span class="number">0</span>则<span class="number">0</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		</span><br><span class="line">	&amp;</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br><span class="line">	------------------------------------------------</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">	结果是：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>） <span class="number">3</span> | <span class="number">4</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 4的二进制</span></span><br><span class="line">	</span><br><span class="line">	|运算：有<span class="number">1</span>则<span class="number">1</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		</span><br><span class="line">	&amp;</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br><span class="line">	------------------------------------------------</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000111</span></span><br><span class="line">	结果是：<span class="number">7</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span>） <span class="number">3</span> ^ <span class="number">4</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 4的二进制</span></span><br><span class="line">	</span><br><span class="line">	^运算：相同为<span class="number">0</span>，不同为<span class="number">1</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		</span><br><span class="line">	&amp;</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br><span class="line">	------------------------------------------------</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000111</span></span><br><span class="line">	结果是：<span class="number">7</span></span><br></pre></td></tr></table></figure>





<h2 id="1-2-左移和右移"><a href="#1-2-左移和右移" class="headerlink" title="1.2    左移和右移"></a>1.2    左移和右移</h2><h3 id="1-2-1-左移"><a href="#1-2-1-左移" class="headerlink" title="1.2.1    左移"></a>1.2.1    左移</h3><blockquote>
<p>  <strong>语法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 &lt;&lt; 位数</span><br></pre></td></tr></table></figure>

<p>将符号左边的操作数左移指定的位数。</p>
<ul>
<li>  首先将左边的操作数转为二进制。</li>
<li>  然后按照要求左移指定位数，左边最高位丢弃，右边补齐0。</li>
</ul>
<blockquote>
<p>  <strong>例子：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> &lt;&lt; <span class="number">2</span></span><br><span class="line"><span class="comment">// 3的二进制：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span></span><br><span class="line"><span class="comment">// 左移2位，左边最高位丢弃，右边补齐0：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001100</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-右移"><a href="#1-2-2-右移" class="headerlink" title="1.2.2    右移"></a>1.2.2    右移</h3><blockquote>
<p>  <strong>语法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 &gt;&gt; 位数</span><br></pre></td></tr></table></figure>

<p>将符号左边的操作数右移指定的位数。</p>
<ul>
<li>  首先将左边的操作数转为二进制。</li>
<li>  然后按照要求右移指定位数，<strong>最高位为 0，左边补齐 0；最高为为 1，左边补齐 1</strong>。</li>
</ul>
<blockquote>
<p>  <strong>例子：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 24的二进制：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span></span><br><span class="line"><span class="comment">// 右移2位，最高位是0，左边补齐0；最高位是1，左边补齐1：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000110</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-3-无符号数右移"><a href="#1-2-3-无符号数右移" class="headerlink" title="1.2.3    无符号数右移"></a>1.2.3    无符号数右移</h3><blockquote>
<p>  <strong>语法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 &gt;&gt;&gt; 拉数</span><br></pre></td></tr></table></figure>

<p>将符号左边的操作数右移指定的位数。</p>
<ul>
<li>  首先将左边的操作数转为二进制。</li>
<li>  然后按照要求右移指定位数，<strong>无论最高位是 0 还是 1 左边补齐 0</strong>。</li>
</ul>
<h3 id="1-2-4-程序测试"><a href="#1-2-4-程序测试" class="headerlink" title="1.2.4    程序测试"></a>1.2.4    程序测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	位运算测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// &lt;&lt; 左移1位即左边数乘以2的1次方，左移2位即左边数乘以2的2次方，以此类推</span></span><br><span class="line">		System.out.println(<span class="number">3</span> &lt;&lt; <span class="number">2</span>); </span><br><span class="line">		<span class="comment">// &gt;&gt; 右移1位即左边数除以2的1次方，右移2位即左边数除以2的2次方，以此类推</span></span><br><span class="line">		System.out.println(<span class="number">24</span> &gt;&gt; <span class="number">2</span>); </span><br><span class="line">		<span class="comment">// 负数转成二进制要用补码，最终将补码右移，再转成原码</span></span><br><span class="line">		System.out.println(-<span class="number">24</span> &gt;&gt; <span class="number">2</span>); </span><br><span class="line">		<span class="comment">// 无符号数右移无论最高位是0还是1左边都补齐0</span></span><br><span class="line">		System.out.println(<span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">		System.out.println(-<span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">-<span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1073741818</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>） <span class="number">3</span>&lt;&lt;<span class="number">2</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	左移两位</span><br><span class="line">    <span class="number">00000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0000001100</span></span><br><span class="line">	结果是：<span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>） <span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">    计算出<span class="number">24</span>的二进制码如下（计算机中所有数据都以补码的形式保存）：</span><br><span class="line">    正数的补码与原码相同！</span><br><span class="line"> </span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 原码 </span></span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 补码</span></span><br><span class="line"></span><br><span class="line">	补码右移<span class="number">2</span>位，左边补<span class="number">0</span></span><br><span class="line">	<span class="number">0000000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000110</span>	</span><br><span class="line">	结果是：<span class="number">6</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span>） -<span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">    负数的补码等于反码 +<span class="number">1</span></span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 原码 </span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100111</span>		<span class="comment">// 反码</span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11101000</span>		<span class="comment">// 补码</span></span><br><span class="line">	补码右移两位，左边补<span class="number">1</span></span><br><span class="line">    <span class="number">1111111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111010</span></span><br><span class="line">	</span><br><span class="line">    得到右移的结果后，存储到计算机中的仍然是补码，开发人员在判断时还需要将补码转为原码</span><br><span class="line">    原码 = （补码 - <span class="number">1</span>） + 取反</span><br><span class="line">    </span><br><span class="line">    <span class="number">1111111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111001</span>		<span class="comment">// 减一操作</span></span><br><span class="line">    <span class="number">1000000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000110</span>		<span class="comment">// 取反(符号位不变)</span></span><br><span class="line">    结果是：-<span class="number">6</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>） <span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">    无符号右移，由于 <span class="number">24</span> 为正数，其方法等价于 <span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">    结果是：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="number">5</span>） -<span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">    计算出 -<span class="number">24</span> 的补码如下</span><br><span class="line">    <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 原码 </span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100111</span>		<span class="comment">// 反码</span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11101000</span>		<span class="comment">// 补码</span></span><br><span class="line">    右移两位，无论最高位是<span class="number">0</span>还是<span class="number">1</span>，左边补<span class="number">0</span></span><br><span class="line">    <span class="number">0011111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111010</span></span><br><span class="line">    对于正数来说，补码与原码相同</span><br><span class="line">    结果：</span><br><span class="line">    将二进制 <span class="number">0011111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111010</span> 转换为十进制的结果是：<span class="number">1073741818</span></span><br></pre></td></tr></table></figure>





<h3 id="1-2-5-总结（重要）"><a href="#1-2-5-总结（重要）" class="headerlink" title="1.2.5    总结（重要）"></a>1.2.5    总结（重要）</h3><p>在位运算中</p>
<ul>
<li>  <code>&lt;&lt;</code> 左移 1 位即左边数乘以 2^1^ ，左移2位即左边数乘以2^2^ ，以此类推。</li>
<li>  <code>&gt;&gt;</code> 右移 1 位即左边数除以 2^1^ ，右移2位即左边数除以2^2^ ，以此类推。</li>
</ul>
<hr>
<h1 id="2-位运算应用"><a href="#2-位运算应用" class="headerlink" title="2    位运算应用"></a>2    位运算应用</h1><h2 id="2-1-奇偶判断"><a href="#2-1-奇偶判断" class="headerlink" title="2.1    奇偶判断"></a>2.1    奇偶判断</h2><ul>
<li>  位运算是直接操作二进制位，效率较高，一些算法会采用位运算。</li>
<li>  奇偶判断是判断一个是奇数还是偶数，如何使用位运算实现呢？</li>
</ul>
<blockquote>
<p>  <strong>原理：</strong></p>
</blockquote>
<ol>
<li> 位运算。&amp; 运算的特点是：两个二进制位只要有一个为 0 那么结果就为 0，否则结果为 1。</li>
<li> <strong>二进制的最低位为 1 一定是奇数，为 0 则一定是偶数</strong>，我们让某个数和 1 进行与运算，结果为 1 则是奇数，为 0 则是偶数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int i = 6;</span><br><span class="line">int j = 7;</span><br><span class="line">// 对应的二进制</span><br><span class="line">6	0110</span><br><span class="line">7	0111</span><br><span class="line"></span><br><span class="line">原理解释：二进制的最低位为 1 一定是奇数，为 0 则一定是偶数</span><br><span class="line">7 = 0111 = 1*2^0 + 1*2^1 + 1*2^2 + 0*2^3 + ...</span><br><span class="line">6 = 0110 = 0*2^0 + 1*2^1 + 1*2^2 + 0*2^3 + ...</span><br><span class="line">除了最低位外，其余每位上的数都是2的倍数。也就是说，除了最低位外，</span><br><span class="line">其余数都是偶数，两个偶数之和还是偶数，所以每个二进制数是奇数还是</span><br><span class="line">偶数是由最低位决定的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 奇偶判断的方法：让这个数和 1 相与（&amp;）</span><br><span class="line">1） 6 &amp; 1 = 0</span><br><span class="line">	0110</span><br><span class="line">	0001</span><br><span class="line">	-------</span><br><span class="line">	0000	==&gt; 结果是 0</span><br><span class="line"></span><br><span class="line">2） 7 &amp; 1 = 1</span><br><span class="line">	0111</span><br><span class="line">	0001</span><br><span class="line">	-------</span><br><span class="line">	0001	==&gt; 结果是 1</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="comment">//和1与运算，结果为1则为奇数</span></span><br><span class="line">        System.out.println(x &amp; a);</span><br><span class="line">        <span class="comment">//和1与运算，结果为0则为偶数</span></span><br><span class="line">        System.out.println(y &amp; a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-2-两数交换"><a href="#2-2-两数交换" class="headerlink" title="2.2    两数交换"></a>2.2    两数交换</h2><blockquote>
<p>  <strong>不用二进制实现两数交换</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//======交换两个数方法1：使用中间变量======</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = tmp;</span><br><span class="line">        </span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>使用二进制的异或运算实现两数交换</strong></p>
</blockquote>
<ul>
<li>  <strong>原理</strong>：一个数对自己异或一次，再异或另一个数，结果为另一个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">5</span>, n = <span class="number">10</span>;</span><br><span class="line"><span class="number">0000</span> <span class="number">0101</span>	<span class="comment">// m</span></span><br><span class="line"><span class="number">0000</span> <span class="number">1010</span>	<span class="comment">// n</span></span><br><span class="line"></span><br><span class="line">m^m</span><br><span class="line">    <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">    <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">    ------------</span><br><span class="line">    <span class="number">0000</span> <span class="number">0000</span>  ==&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">m^m^n</span><br><span class="line">	<span class="number">0000</span> <span class="number">0000</span> </span><br><span class="line">	<span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">	---------------</span><br><span class="line">	<span class="number">0000</span> <span class="number">1010</span>	==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//======交换两个数方法2：使用异或运算======</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="comment">// 先测试异或运算的特点 </span></span><br><span class="line">		<span class="comment">// 一个数对自己异或一次，再异或另一个数，结果为另一个数</span></span><br><span class="line">		System.out.println(m ^ m ^ n); 	<span class="comment">// m变成了n，输出10</span></span><br><span class="line">		System.out.println(n ^ n ^ m ); <span class="comment">// n变成了m，输出5</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 下边通过异或交换变量的值</span></span><br><span class="line">		<span class="comment">// 下边是m和n没有交换之前的异或，存入m</span></span><br><span class="line">		m = m ^ n ;</span><br><span class="line">		<span class="comment">//下边的赋值语句相当于n=m ^ n ^ n，将m的值赋值给了n</span></span><br><span class="line">		n = m ^ n ;</span><br><span class="line">		<span class="comment">//此时n的值为m，所以m ^ n即m ^ m ^  n ，将n的值赋值给了m</span></span><br><span class="line">		m = m ^ n ;</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		System.out.println(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用二进制的好处：<ol>
<li> 不用额外创建空间保存临时变量；</li>
<li> 使用二进制数据进行运算，执行速度较快。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="3-位运算常见的规律（LeetCode刷题常用）"><a href="#3-位运算常见的规律（LeetCode刷题常用）" class="headerlink" title="3    位运算常见的规律（LeetCode刷题常用）"></a>3    位运算常见的规律（LeetCode刷题常用）</h1><h2 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h2><p>在位运算中</p>
<ul>
<li>  <code>&lt;&lt;</code> 左移 1 位即左边数乘以 2^1^ ，左移2位即左边数乘以2^2^ ，以此类推。</li>
<li>  <code>&gt;&gt;</code> 右移 1 位即左边数除以 2^1^ ，右移2位即左边数除以2^2^ ，以此类推。</li>
</ul>
<h2 id="与（-amp-）运算"><a href="#与（-amp-）运算" class="headerlink" title="与（&amp;）运算"></a>与（&amp;）运算</h2><blockquote>
<p>  <strong>任意数 和 1 相与（&amp;）</strong></p>
</blockquote>
<ul>
<li>任意数 和 1 相与（&amp;），结果为 1 是奇数，结果为 0 是偶数。</li>
</ul>
<blockquote>
<p>  <strong>n &amp; (n-1)</strong></p>
</blockquote>
<ul>
<li>  n 和 (n−1) 解析：（n-1）就是将二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。</li>
<li>  <code>n &amp; (n - 1)</code> 解析：<code>n &amp; (n - 1)</code> 就是将二进制数字 n 最右边的 1 变成 0 ，其余不变。</li>
</ul>
<p><img src="/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/9bc8ab7ba242888d5291770d35ef749ae76ee2f1a51d31d729324755fc4b1b1c-Picture10.png" alt="Picture10.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/10/LockSupport/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/10/LockSupport/" class="post-title-link" itemprop="url">LockSupport</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-10 18:16:57" itemprop="dateCreated datePublished" datetime="2021-08-10T18:16:57+08:00">2021-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-21 21:27:31" itemprop="dateModified" datetime="2021-08-21T21:27:31+08:00">2021-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1    是什么？"></a>1    是什么？</h1><img src="/2021/08/10/LockSupport/image-20210716173307046.png" alt="image-20210716173307046" style="zoom:80%;">

<ul>
<li>  <strong>LockSupport</strong> 是 JUC 包下的一个类，也用于多线程间的通信，<strong>是 <code>wait / notify</code> 机制的改良加强版</strong>。</li>
<li>  LockSupport 是一个线程阻塞唤醒的工具类，<strong>类中所有的方法都是静态方法</strong>，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。</li>
<li>  LockSupport 提供了 <code>park()</code> 和 <code>unpark()</code> 方法实现阻塞线程和解除线程阻塞的过程。</li>
<li>  归根结底，<strong>LockSupport 调用的是 Unsafe 类中的 native 方法</strong>。</li>
<li>  LockSupport 是用来创建锁和其它同步类的基本线程阻塞原语。</li>
</ul>
<p><img src="/2021/08/10/LockSupport/image-20210716173522862.png" alt="image-20210716173522862"></p>
<hr>
<h1 id="2-为什么学-LockSupport"><a href="#2-为什么学-LockSupport" class="headerlink" title="2    为什么学 LockSupport"></a>2    为什么学 LockSupport</h1><ol>
<li> LockSupport 是学习 AQS 的前置知识。</li>
<li> 传统的 等待/唤醒 机制在某些情况下不适用。</li>
</ol>
<hr>
<h1 id="3-三组让线程等待-唤醒的方法（传统等待-唤醒方法存在的缺陷）"><a href="#3-三组让线程等待-唤醒的方法（传统等待-唤醒方法存在的缺陷）" class="headerlink" title="3    三组让线程等待/唤醒的方法（传统等待/唤醒方法存在的缺陷）"></a>3    三组让线程等待/唤醒的方法（传统等待/唤醒方法存在的缺陷）</h1><blockquote>
<ol>
<li> <strong>Object</strong>：<code>wait()</code> 和 <code>notify()</code></li>
<li> <strong>Condition</strong>：<code>await()</code> 和 <code>signal()</code></li>
<li> <strong>LockSupport</strong>：<code>park()</code> 和 <code>unpark()</code></li>
</ol>
</blockquote>
<h2 id="3-1-wait-notify"><a href="#3-1-wait-notify" class="headerlink" title="3.1    wait / notify"></a>3.1    wait / notify</h2><blockquote>
<p>  <strong>Object 类中的 wait 和 notify 方法实现线程的等待和唤醒（wait/notify 限制）</strong></p>
</blockquote>
<h3 id="正常"><a href="#正常" class="headerlink" title="正常"></a>正常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.one;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/16 18:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行结果：</span></span><br><span class="line"><span class="comment"> *      T1 come in</span></span><br><span class="line"><span class="comment"> *      T1 进入Waiting状态</span></span><br><span class="line"><span class="comment"> *      T2 come in</span></span><br><span class="line"><span class="comment"> *      T2 唤醒Waiting中的线程</span></span><br><span class="line"><span class="comment"> *      T1 被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="异常1"><a href="#异常1" class="headerlink" title="异常1"></a>异常1</h3><ul>
<li>  将 <code>wait</code> 和 <code>notify</code> 方法，两个都去掉同步代码块。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            synchronized (obj)&#123;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            synchronized (obj)&#123;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>执行结果：</strong></p>
</blockquote>
<p><img src="/2021/08/10/LockSupport/image-20210716181135743.png" alt="image-20210716181135743"></p>
<blockquote>
<p>  <strong>结论</strong></p>
</blockquote>
<ul>
<li>  <strong>Object 类中的 wait、notify、notifyAll 方法必须放在 synchronized 同步代码（同步代码块或同步方法）中才能正常使用。</strong></li>
<li>  <strong>编译时不会报错，但是运行时会抛出 <code>IllegalMonitorStateException</code> 异常。</strong>【非法监听状态异常】</li>
</ul>
<hr>
<h3 id="异常2"><a href="#异常2" class="headerlink" title="异常2"></a>异常2</h3><ul>
<li>  让 <code>notify()</code> 先于 <code>wait()</code> 执行，会导致某个线程进入 Waiting 状态后无法被唤醒，程序无法结束。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                    obj.wait();		<span class="comment">// 13行</span></span><br><span class="line"><span class="comment">//                    obj.wait(1000);      // 超时唤醒可以单独出现              </span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>执行结果</strong></p>
</blockquote>
<p><img src="/2021/08/10/LockSupport/image-20210716181509277.png" alt="image-20210716181509277"></p>
<blockquote>
<p>  <strong>代码分析</strong></p>
</blockquote>
<ol>
<li> 在线程 T1 争夺锁对象之前让其先暂停 1s，让 T2 线程能先于 T1 执行；</li>
<li> T2 线程先得到锁对象，在控制台上输出指定的内容，并随机唤醒当前锁对象维护的等待队列中的一个线程，将其移动到锁对象的同步队列中，最后执行完毕释放锁对象。（由于当前锁对象的等待队列为空，所以这里并没有发生真正的唤醒线程的过程）</li>
<li> T1 线程休眠 1s 后醒来获得锁对象，执行代码块中的方法，将指定内容打印输出到控制台上。执行到 13 行 <code>obj.wait();</code> 代码后 T1 线程被挂起。</li>
<li> 但是由于锁对象的唤醒动作已经先于阻塞动作执行了，并且在此之后锁对象也没有其它的唤醒动作了，所以 T1 会一直陷入 Waiting 状态，该行代码之后的打印输出动作也就不会被执行到。</li>
<li> 整个进程无法结束。</li>
</ol>
<blockquote>
<p>  <strong>附加</strong></p>
</blockquote>
<ul>
<li>  如果将唤醒操作设置成超时唤醒，则 <strong>wait(long timeout)</strong> 可以不用与 <code>notify()</code> 方法成对出现，也可以不用关心与 <code>notify()</code> 方法出现的顺序。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>  <code>wait()</code> 和 <code>notify()</code> 方法必须<strong>要在 synchronized 同步代码里面</strong>且<strong>成对使用</strong>，且使用时必须先 <code>wait</code> 后 <code>notify</code>。【注意这里的 <code>wait()</code> 方法一定是空参的 wait 方法】</li>
</ul>
<hr>
<h2 id="3-2-await-signal"><a href="#3-2-await-signal" class="headerlink" title="3.2    await  / signal"></a>3.2    await  / signal</h2><blockquote>
<p>  <strong>Condition 接口中的 await 和 signal 方法实现线程的等待和唤醒</strong></p>
</blockquote>
<p>与<code>Object#wait</code>、<code>Object#notify</code> 方法遇到的问题基本一样。</p>
<h3 id="正常-1"><a href="#正常-1" class="headerlink" title="正常"></a>正常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/16 18:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                condition.await();  <span class="comment">// 当前线程被阻塞</span></span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行结果：</span></span><br><span class="line"><span class="comment"> *      T1 come in</span></span><br><span class="line"><span class="comment"> *      T1 进入Waiting状态</span></span><br><span class="line"><span class="comment"> *      T2 come in</span></span><br><span class="line"><span class="comment"> *      T2 唤醒Waiting中的线程</span></span><br><span class="line"><span class="comment"> *      T1 被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="异常1-1"><a href="#异常1-1" class="headerlink" title="异常1"></a>异常1</h3><p>如果注释掉 lock 和 unlock 方法，程序将会抛出 <strong>IllegalMonitorStateException</strong> 异常。</p>
<p><img src="/2021/08/10/LockSupport/image-20210716184240464.png" alt="image-20210716184240464"></p>
<h3 id="异常2-1"><a href="#异常2-1" class="headerlink" title="异常2"></a>异常2</h3><p>如果调换 <code>await()</code> 和 <code>signal()</code> 的执行顺序，将有一个线程永远处于 Waiting 状态，导致线程无法结束。</p>
<hr>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3    总结"></a>3.3    总结</h2><blockquote>
<p>  <strong>传统的 synchronized 和 Lock 实现等待唤醒的约束</strong></p>
</blockquote>
<ol>
<li> 等待和唤醒的方法必须写在锁代码块（synchronized 或 lock）中；</li>
<li> 等待 / 唤醒方法必须成对出现，成对使用。</li>
<li> 必须先等待后唤醒。如果先唤醒后等待，线程将陷入死等。</li>
</ol>
<hr>
<h2 id="3-4-park-unpark"><a href="#3-4-park-unpark" class="headerlink" title="3.4    park / unpark"></a>3.4    park / unpark</h2><blockquote>
<p>  <strong>LockSupport 类中 park 等待和 unpark 唤醒</strong></p>
</blockquote>
<ul>
<li>  见下文</li>
</ul>
<hr>
<h1 id="4-LockSupport"><a href="#4-LockSupport" class="headerlink" title="4    LockSupport"></a>4    LockSupport</h1><h2 id="4-1-常用方法"><a href="#4-1-常用方法" class="headerlink" title="4.1    常用方法"></a>4.1    常用方法</h2><p>在 LockSupport 中，通过 <code>park()</code> 和 <code>unpark(Thread thread)</code> 方法来实现阻塞和唤醒线程的操作。</p>
<p><img src="/2021/08/10/LockSupport/image-20210716203238382.png" alt="image-20210716203238382"></p>
<h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2    原理"></a>4.2    原理</h2><ul>
<li>  LockSupport 中使用了一种名为 Permit（许可证）的概念来实现阻塞和唤醒线程的功能，Permit 与线程绑定。</li>
<li>  Permit 只有两个值 1 和 0，默认是 0。</li>
<li>  0 表示线程没有许可证，1 表示线程拥有许可证。每个线程允许携带的许可证的最大上限是 1。</li>
</ul>
<h2 id="4-3-阻塞"><a href="#4-3-阻塞" class="headerlink" title="4.3    阻塞"></a>4.3    阻塞</h2><blockquote>
<p>  <strong>阻塞方法</strong></p>
</blockquote>
<ul>
<li>  <code>park()</code>：消耗一个许可证，若许可证个数为 0 则会阻塞当前线程，若许可证个数为 1 则会消耗掉一个许可证，并放行线程。</li>
<li>  <code>park(Object blocker)</code>：阻塞指定线程（会消耗掉一个许可证）</li>
</ul>
<blockquote>
<p>  <strong>阻塞原理</strong></p>
</blockquote>
<p>调用 <code>LockSupport#park()</code> 方法时，底层调用的是 <code>UNSAFE.park()</code> 方法</p>
<p><img src="/2021/08/10/LockSupport/image-20210716203521212.png" alt="image-20210716203521212"></p>
<p>默认情况 <code>permit == 0</code>，对于一个新的线程直接调用 <code>park()</code> 方法，该线程没有许可证可以被消耗，所以当前线程会直接阻塞，直到其它线程给该线程颁发一个许可证，即设置该线程的 <code>permit == 1</code> 时，该线程才会从阻塞状态中恢复运行，并消耗掉一个许可证，设置 <code>permit == 0</code> ，继续执行 <code>park()</code> 方法之后的代码。</p>
<h2 id="4-4-唤醒"><a href="#4-4-唤醒" class="headerlink" title="4.4    唤醒"></a>4.4    唤醒</h2><blockquote>
<p>  <strong>唤醒方法</strong></p>
</blockquote>
<ul>
<li>   <code>unpark(Thread thread)</code>：唤醒某个线程。</li>
</ul>
<blockquote>
<p>  <strong>唤醒原理</strong></p>
</blockquote>
<p><strong>严格意义上将并不是唤醒线程，而是给线程颁发了一个许可证，这个许可证并不会立即被消耗，而是保存在线程实例中，在遇到 park() 方法造成的阻塞时，消耗该许可证可以保证线程不被阻塞。</strong></p>
<p><img src="/2021/08/10/LockSupport/image-20210716203852897.png" alt="image-20210716203852897"></p>
<p>调用 <code>unpark(thread)</code> 方法后，设置 thread 线程的许可证 <code>permit == 1</code>（注意多次调用 <code>unpark()</code>，permit 的值不会累加，最高只能是 1），自动唤醒 thread 线程，即之前阻塞中的 <code>LockSupport.park()</code> 方法会立即返回。</p>
<h2 id="4-5-形象的理解"><a href="#4-5-形象的理解" class="headerlink" title="4.5    形象的理解"></a>4.5    形象的理解</h2><p><em>permit 许可证与线程绑定。</em></p>
<p><em>permit  是一张万能的通行证，可以提前发给线程，线程每遇到一个关卡（阻塞）就需要消耗一张通行证。如果有则通过关卡，没有则不让通过，即阻塞。且每个线程最大只能持有一张许可证。</em></p>
<p>线程阻塞时需要消耗凭证（permit），这个凭证每个线程最多只有 1 个。</p>
<ol>
<li>当调用 <code>park()</code> 方法时，<ul>
<li>  如果有凭证，则会直接消耗掉这个凭证，然后程序继续执行。</li>
<li>  如果无凭证，则必须阻塞等待凭证可用</li>
</ul>
</li>
<li> 而 <code>unpark()</code> 正好相反，它会增加一个凭证，但凭证最多只能有一个，累加无效。</li>
</ol>
<hr>
<h1 id="5-代码"><a href="#5-代码" class="headerlink" title="5    代码"></a>5    代码</h1><blockquote>
<p>  <strong>LockSupport 的优势</strong></p>
</blockquote>
<ul>
<li>  优势1：不需要锁块，唤醒和阻塞的代码可以写在任意位置。（之前的两组方法都只能写在锁代码块中）</li>
<li>  优势2：支持 <code>unpark()</code> 可以在 <code>park()</code> 之前执行（先唤醒后等待）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in \t&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 被唤醒 \t&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;唤醒&quot;</span> + t1.getName() + <span class="string">&quot;线程&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1); </span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>代码分析</strong></p>
</blockquote>
<ol>
<li> T1 线程即使抢到 CPU 资源后也会立即睡眠 3s，所以 T2 线程中的内容必定先于 T1 执行。</li>
<li> T2 调用 <code>unpark()</code> 方法给 t1 线程发放了一个通行证；</li>
<li> 3s 后 T1 线程睡醒，接着上次的位置继续执行，打印 <code>... come in ...</code> 在控制台上，接着执行 <code>park()</code> 方法阻塞线程，但是由于此时 T1 线程是有一个通行证 permit 的，所以这个阻塞校验可以通过，紧接着继续执行下面的操作。</li>
</ol>
<p><strong>最终的运行结果为</strong>：</p>
<p><img src="/2021/08/10/LockSupport/image-20210716213814924.png" alt="image-20210716213814924"></p>
<p>可以看到：<code>LockSupport.park()</code>前后执行时间是一样的，也就说明阻塞没有生效。</p>
<hr>
<h1 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6    面试题"></a>6    面试题</h1><blockquote>
<ol>
<li> <strong>为什么可以先唤醒线程后阻塞线程？</strong></li>
</ol>
</blockquote>
<p><code>unpark()</code> 方法并不是直接唤醒阻塞的线程，而是相当于给线程发放了一个万能的通行证，只要有这个通行证在，线程在遇到阻塞时，直接消费这个通行证就可以通过而不会被阻塞。</p>
<blockquote>
<ol start="2">
<li> <strong>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</strong></li>
</ol>
</blockquote>
<p>因为一个线程持有通行证的最大数量只能为 1，所以调用两次 <code>unpark()</code> 和调用一次 <code>unpark()</code> 效果一样，最多只能获得一个通行证。而调用两次 <code>park()</code> 则会消费两个通行证，证不够就不能放行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/BlockingQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/09/BlockingQueue/" class="post-title-link" itemprop="url">BlockingQueue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-09 15:45:50" itemprop="dateCreated datePublished" datetime="2021-08-09T15:45:50+08:00">2021-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-19 20:20:18" itemprop="dateModified" datetime="2021-10-19T20:20:18+08:00">2021-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>阻塞队列；BlockingQueue</strong></p>
</blockquote>
<h1 id="阻塞队列的由来"><a href="#阻塞队列的由来" class="headerlink" title="阻塞队列的由来"></a>阻塞队列的由来</h1><blockquote>
<p>  <strong>生产者-消费者模式</strong></p>
</blockquote>
<ul>
<li>  我们假设一种场景，生产者一直生产资源，消费者一直消费资源，资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的 <strong>生产者-消费者模式</strong>。</li>
<li>  该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</li>
<li>  我们自己编码实现这个模式的时候，因为需要让多个线程操作共享变量（即资源），所以很容易引发线程安全问题，造成重复消费和死锁，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个等待-唤醒逻辑都需要自己实现。</li>
</ul>
<blockquote>
<p>  <strong>为什么需要 BlockingQueue？有什么好处？</strong></p>
</blockquote>
<ul>
<li>  在多线程领域，所谓阻塞，就是指在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会被唤醒。[但是这些都是需要人工去判断挂起和唤醒的] [<strong>手动挂起和唤醒</strong>]</li>
<li>  在 juc 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，这会给开发带来不小的难度。</li>
<li>  由程序员手动去判断阻塞和唤醒条件是非常容易出错的，所以 JDK 中新增了 **阻塞队列(BlockingQueue)**，你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</li>
<li>  好处是我们不需要关心什么时候阻塞线程，什么时候唤醒线程，因为这一切都由 BlockingQueue 自动实现了。[<strong>自动挂起和唤醒</strong>]</li>
<li>  BlockingQueue⼀般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。BlockingQueue就是存放元素的容器。</li>
</ul>
<hr>
<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><ol>
<li> 阻塞队列首先是一个队列，满足队列 FIFO 的特性；</li>
<li>阻塞队列<ul>
<li>  当阻塞队列为空时，从队列中<strong>获取</strong>元素的操作将会被阻塞。</li>
<li>  当阻塞队列为满时，往队列里<strong>添加</strong>元素的操作将会被阻塞。</li>
</ul>
</li>
<li> 阻塞队列空了消费者阻塞，满了生产者阻塞。</li>
</ol>
<p><img src="/2021/08/09/BlockingQueue/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="阻塞队列"></p>
<hr>
<h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>
<table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center"><code>add(e)</code></td>
<td align="center"><code>offer(e)</code></td>
<td align="center"><code>put(e)</code></td>
<td align="center"><code>offer(e, time, unit)</code></td>
</tr>
<tr>
<td align="center">移出</td>
<td align="center"><code>remove()</code></td>
<td align="center"><code>poll()</code></td>
<td align="center"><code>take()</code></td>
<td align="center"><code>poll(time, unit)</code></td>
</tr>
<tr>
<td align="center">检查</td>
<td align="center"><code>element()</code></td>
<td align="center"><code>peek()</code></td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ul>
<li>  检查：检查队列是否为空，不为空则查到队头元素的值</li>
</ul>
<blockquote>
<p>  <strong>抛出异常：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，则抛出异常。</p>
<ul>
<li>  当阻塞队列满时，再往队列里插入元素会抛出 <strong>IllegalStateException: Queue full</strong> 异常；</li>
<li>  当阻塞队列空时，再从队列里删除元素会抛出 <strong>NoSuchElementException</strong> 异常。</li>
</ul>
<blockquote>
<p>  <strong>返回特殊值：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，会返回一个特殊值。</p>
<ul>
<li>  对于插入方法，成功返回 <strong>true</strong> 失败返回 <strong>false</strong>；</li>
<li>  对于移除方法，成功返回出队的元素，队列为空就返回 <strong>null</strong>。</li>
</ul>
<blockquote>
<p>  <strong>一直阻塞：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，则一直阻塞或者响应中断。</p>
<ul>
<li>  当阻塞队列满时，生产者线程继续往队列里 put 元素，队列会一直阻塞生产线程；</li>
<li>  当阻塞队列空时，消费者线程继续试图从队列中 take 元素，队列会一直阻塞消费者线程直到队列可用。</li>
</ul>
<blockquote>
<p>  <strong>超时退出：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 <code>true / false</code>。</p>
<ul>
<li>  当阻塞队列满时，继续向队列中添加元素，会阻塞生产者线程一段时间，若该段时间内队列中可以添加元素了，则添加成功，超过时间后生产者线程会退出，返回一个特定值告知该操作是否成功。</li>
<li>  当阻塞队列空时，继续从队列中移出元素，会阻塞消费者线程一段时间，若该段时间内可以从队列中移除元素了，则移除成功，超过时间后消费者线程会退出，返回一个特定值告知该操作是否成功。</li>
</ul>
<blockquote>
<p>  <strong>注意</strong></p>
</blockquote>
<ul>
<li>  不能往阻塞队列中插⼊null，会抛出空指针异常。</li>
<li>  可以访问阻塞队列中的任意元素，调用 <code>remove(o)</code> 可以将队列之中的特定对象移除，但并不⾼效，尽量避免使用。</li>
</ul>
<hr>
<h1 id="BlockingQueue-架构"><a href="#BlockingQueue-架构" class="headerlink" title="BlockingQueue 架构"></a>BlockingQueue 架构</h1><img src="/2021/08/09/BlockingQueue/BlockingQueue.png" alt="BlockingQueue">



<ul>
<li>  <strong>ArrayBlockingQueue：由数组结构组成的有界阻塞队列。类似于ArrayList</strong></li>
<li>  <strong>LinkedBlockedQueue：由链表结构组成的有界阻塞队列（但大小默认值为 Integer.MAX_VALUE）。类似于 LinkedArrayList</strong></li>
<li>  PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li>
<li>  DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</li>
<li>  <strong>SynchronousQueue：不存储元素的阻塞队列。</strong></li>
<li>  LinkedTransferQueue：由链表结构组成的无界阻塞队列。</li>
<li>  LinkedBlockingDeque：由链表结构组成的双向阻塞队列。</li>
</ul>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><blockquote>
<p>  <strong>构造方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span>&#123;</span><br><span class="line">    <span class="comment">//...省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  ArrayBlockingQueue 是由数组结构组成的<strong>有界</strong>阻塞队列。</li>
<li>  内部结构是<strong>数组</strong>，故具有数组的特性。</li>
<li>  可以初始化队列大小， 且一旦初始化不能改变。构造方法中的 <strong>fair</strong> 表示控制对象的内部锁是否采用公平锁，默认是非公平锁。</li>
</ul>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><ul>
<li>  由链表结构组成的<strong>有界</strong>阻塞队列。默认队列的大小是 <strong>Integer.MAX_VALUE</strong>，也可以指定大小。</li>
<li>  内部结构是链表，具有链表的特性。</li>
<li>  此队列按照先进先出的原则对元素进行排序。</li>
</ul>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><ul>
<li>  这个队列比较特殊，没有任何内部容量，甚至连一个队列的容量都没有。并且每个 <code>put</code> 必须等待一个 <code>take</code>，反之亦然。</li>
</ul>
<blockquote>
<p>  <strong>SynchronousQueue 与容量为 1 的 ArrayBlockingQueue、LinkedBlockingQueue 有什么区别？</strong></p>
</blockquote>
<p>在 SynchronousQueue 中：</p>
<ul>
<li>  <code>iterator()</code> 永远返回空，因为里面没有东西；</li>
<li>  <code>isEmpty()</code> 永远返回 true；</li>
<li>  <code>peek()</code> 永远返回 <strong>null</strong>；</li>
<li>  <code>put()</code> 往 queue 放进去一个 element 以后就一直 wait，直到有其他 thread 进来把这个 element 取走。</li>
<li>  <code>offer()</code> 往 queue 里放一个 element 后立即返回，如果碰巧这个 element 被另一个thread取走了，<code>offer()</code> 返回 true，认为 <code>offer()</code> 成功；否则返回 false。</li>
<li>  <code>take()</code> 取出并且 remove 掉 queue 里 的 element，取不到东西他会一直等。</li>
<li>  <code>poll()</code> 取出并且 remove 掉 queue 里的 element，只有到碰巧另外一个线程正在往 queue 里 offer 数据或者 put 数据的时候，该方法才会取到东西。否则立即返回 null。</li>
<li>  <code>remove()</code> &amp; <code>removeAll()</code> 永远返回 false。</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>  PriorityBlockingQueue 不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。</li>
<li>  因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</li>
<li>  对于使用默认大小的LinkedBlockingQueue也是一样的。</li>
</ul>
<hr>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h2 id="ArrayBlockingQueue-1"><a href="#ArrayBlockingQueue-1" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><h3 id="Case1：add-remove"><a href="#Case1：add-remove" class="headerlink" title="Case1：add / remove"></a>Case1：add / remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blockingQueue.add(<span class="string">&quot;A&quot;</span>);    <span class="comment">// 正常添加返回值为Boolean类型的true</span></span><br><span class="line">        blockingQueue.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        blockingQueue.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="comment">//        blockingQueue.add(&quot;X&quot;);   // 队列满时再向队列时添加元素会抛出异常：IllegalStateException: Queue full</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*检索*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> blockingQueue.element();   <span class="comment">// 正常检索返回队首元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.remove();     <span class="comment">// 正常出队返回值为队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.remove();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.remove();</span><br><span class="line"><span class="comment">//        String q4 = blockingQueue.remove();   // 队列空时继续出队会抛出异常：NoSuchElementException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  队列满时继续入队</li>
</ul>
<p><img src="/2021/08/09/BlockingQueue/image-20210713172132018.png" alt="image-20210713172132018"></p>
<ul>
<li>  队列为空时继续出队</li>
</ul>
<p><img src="/2021/08/09/BlockingQueue/image-20210713172625099.png" alt="image-20210713172625099"></p>
<h3 id="Case2：offer-poll"><a href="#Case2：offer-poll" class="headerlink" title="Case2：offer / poll"></a>Case2：offer / poll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blockingQueue.offer(<span class="string">&quot;A&quot;</span>);    <span class="comment">// 正常添加返回值为Boolean类型的true</span></span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;X&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*检索*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> blockingQueue.peek();   <span class="comment">// 正常检索返回队首元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.poll();     <span class="comment">// 正常出队返回值为队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.poll();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.poll();</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果：</span></span><br><span class="line"><span class="comment"> *      false</span></span><br><span class="line"><span class="comment"> *      null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Case3：put-take"><a href="#Case3：put-take" class="headerlink" title="Case3：put / take"></a>Case3：put / take</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;A&quot;</span>);    <span class="comment">// 正常添加无返回值</span></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;X&quot;);     // 当队列满时，继续入队元素，就会阻塞当前线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.take();     <span class="comment">// 正常出队返回队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">q4</span> <span class="operator">=</span> blockingQueue.take();       <span class="comment">// 当队列空时，继续出队，也会阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Case4：offer-poll"><a href="#Case4：offer-poll" class="headerlink" title="Case4：offer / poll"></a>Case4：offer / poll</h3><p><img src="/2021/08/09/BlockingQueue/image-20210713173931729.png" alt="image-20210713173931729"></p>
<p><img src="/2021/08/09/BlockingQueue/image-20210713174208204.png" alt="image-20210713174208204"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blockingQueue.offer(<span class="string">&quot;A&quot;</span>,<span class="number">2</span>, TimeUnit.SECONDS);    <span class="comment">// 正常添加返回值为Boolean类型的true</span></span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;X&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);  <span class="comment">// 队列满时继续添加，会阻塞当前线程 2s，之后继续运行线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);    <span class="comment">// 正常出队返回值为队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="type">String</span> <span class="variable">q4</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);    <span class="comment">// 队列空时继续出队，会阻塞当前线程线程2s，</span></span><br><span class="line">        <span class="comment">// 如果2s后队列还为空，则返回null，若2s后队列被其它线程入队了值，则返回队首的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="SynchronousQueue-1"><a href="#SynchronousQueue-1" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p><strong>原理</strong></p>
<ul>
<li>  SynchronousQueue 没有容量。与其它 BlockingQueue 不同，SynchronousQueue 是一个不存储元素的 BlockingQueue，每一个 put 元素操作必须等待一个 take 操作，否则不能继续添加元素，反之亦然。</li>
<li>  也可以理解为 SynchronousQueue 容量为 1，即每生产一个必须等消费之后才能继续生产下一个。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产者线程*/</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put A&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.put(<span class="string">&quot;A&quot;</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put B&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.put(<span class="string">&quot;B&quot;</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put C&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.put(<span class="string">&quot;C&quot;</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费者线程*/</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.take(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.take(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.take(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;customer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码分析</strong></p>
<ol>
<li> main 线程启动，创建 SynchronousQueue 类的实例对象，创建两个线程，生产者线程和消费者线程并发执行。</li>
<li> 生产者线程连续生产 3 个元素，但是由于 blockingQueue 是一个同步队列，最大容量是 1，所以只能添加进去一个，然后被挂起；</li>
<li> 消费者线程在 3s 后消费一个线程，消费完成后，生产者线程才能被唤醒继续生产。</li>
</ol>
<p>所有程序的输出结果是：</p>
<ol>
<li> 生产者线程添加 “A” 到同步阻塞队列，然后被挂起，等待队列中元素被消费；</li>
<li> 3s 后消费者线程被唤醒消费队列中队首元素，然后继续挂起 2s；</li>
<li> 生产者线程检测到阻塞队列为空，生产 “B” 到同步队列中，等待队列中的元素被消费；</li>
<li> 2s 后消费者线程被唤醒消费队列中队首元素，然后继续挂起 1s；</li>
<li> 生产者线程检测到阻塞队列为空，生产 “C” 到同步队列中，等待队列中的元素被消费，生产线程结束；</li>
<li> 1s 后消费者线程被唤醒消费队列中队首元素，消费者线程结束；</li>
<li> main 线程结束，程序执行完成。</li>
</ol>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">producer put A</span><br><span class="line">producer put B</span><br><span class="line">producer put C</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="用在哪里"><a href="#用在哪里" class="headerlink" title="用在哪里"></a>用在哪里</h1><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/14 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 知识点： volatile/CAS/atomicInteger/BlockQueue/线程交互/原子引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData3</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">// 默认开启，进行 生产+消费 。需要被多个线程知道，使用 volatile 修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="literal">null</span>;     <span class="comment">// 定义为接口类型，可以接受该接口的所有实现类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造器注入*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyData3</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName()); <span class="comment">// 通过反射的方式获取调用对象的全限定类名，方便出错时检查</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flag == true</span></span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet()+<span class="string">&quot;&quot;</span>; <span class="comment">// i++</span></span><br><span class="line">            result = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);    <span class="comment">// 加入阻塞队列，并返回执行结果</span></span><br><span class="line">            <span class="keyword">if</span> (result)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;加入队列成功***&quot;</span> + data);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;加入队列失败***&quot;</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flag == false</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;生产线程执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == result)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;超过2s没有取到阻塞队列中的数据，消费线程退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费&quot;</span> + result +<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProdConsumerDemo03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyData3</span> <span class="variable">myData3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData3</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;String&gt;(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产线程启动&quot;</span>);</span><br><span class="line">                myData3.product();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Product&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费线程启动&quot;</span>);</span><br><span class="line">                myData3.consumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5s钟后，生产和消费都结束</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        myData3.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong></p>
<img src="/2021/08/09/BlockingQueue/image-20210714203155396.png" alt="image-20210714203155396" style="zoom:80%;">



<p><strong>代码分析</strong></p>
<ol>
<li> main 线程启动，创建一个资源类，传入一个阻塞队列。</li>
<li> 启动一个生产线程（Product）和一个消费线程（Consumer），两个线程并发执行。</li>
<li> main 线程可以直接叫停这两个线程</li>
</ol>
<p><em>生产线程：</em></p>
<ol>
<li> 生产线程执行具有原子性的 i++ 操作，并将 i 加入阻塞队列（阻塞队列的最大容量为 3），每加入一次暂停 1s</li>
</ol>
<p><em>消费线程</em>：</p>
<ol>
<li>消费线程消费阻塞队列中的值，<ul>
<li>  如果阻塞队列中有值，则消费成功；</li>
<li>  如果超过 2s 消费队列中都没有值，则消费失败，消费线程退出。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">超链接：线程池</a></li>
</ul>
<blockquote>
<p>  <strong>线程池 ThreadPoolExecutor 的构造方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/09/NIO/" class="post-title-link" itemprop="url">NIO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-09 12:28:02" itemprop="dateCreated datePublished" datetime="2021-08-09T12:28:02+08:00">2021-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-25 18:26:13" itemprop="dateModified" datetime="2022-06-25T18:26:13+08:00">2022-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><p><img src="https://processon.com/chart_image/62a72a32e0b34d29447092bf.png"></p>
<h1 id="第一章-Java-I-O-模型"><a href="#第一章-Java-I-O-模型" class="headerlink" title="第一章 Java I/O 模型"></a>第一章 Java I/O 模型</h1><p>在真实开发中，<strong>非阻塞I/O</strong> 配合 <strong>I/O多路复用</strong>，是高性能网络编程中最常见的技术。</p>
<h2 id="1-阻塞-amp-非阻塞；同步-amp-异步"><a href="#1-阻塞-amp-非阻塞；同步-amp-异步" class="headerlink" title="1. 阻塞&amp;非阻塞；同步&amp;异步"></a>1. 阻塞&amp;非阻塞；同步&amp;异步</h2><h3 id="1-1-同步-synchronous-amp-异步-asynchronous"><a href="#1-1-同步-synchronous-amp-异步-asynchronous" class="headerlink" title="1.1 同步(synchronous) &amp; 异步(asynchronous)"></a>1.1 同步(synchronous) &amp; 异步(asynchronous)</h3><p><strong>同步/异步主要针对C(client)端：</strong></p>
<ul>
<li><strong>同步：</strong>简单来说，“同步”就是在C端发出一个功能调用时，在没有得到处理结果之前，该调用就不返回，而C端后续的任务必须等待当前调用返回后，才能进行下一步。这是一种串行化的思想，事情必须一件一件做，等前一件事情做完了才能做下一件事情。<ul>
<li>例如普通的同步B/S模式：提交请求-&gt;等待服务器处理-&gt;处理完毕返回。在此期间客户端浏览器不能干其它事情。</li>
</ul>
</li>
<li><strong>异步：</strong>异步的概念和同步相对，当C端发出一个异步调用后，调用者不会立刻得到结果。实际处理这个调用的部件在任务完成后，通过状态、通知和回调来通知调用者。<ul>
<li>例如Ajax请求(异步)：请求通过事件触发 -&gt; 服务器处理(这时浏览器仍然可以做其它事情) -&gt; 处理完毕。</li>
</ul>
</li>
</ul>
<p>简单来说，同步是一种可靠有序的运行机制。当我们进行同步操作时，后续的任务必须等待当前调用返回，才会进行下一步；而异步则相反，其它任务不需要等待当前调用返回，通常依靠回调、事件等机制来实现任务间次序关系。</p>
<h3 id="1-2-阻塞-Block-amp-非阻塞-Unblock"><a href="#1-2-阻塞-Block-amp-非阻塞-Unblock" class="headerlink" title="1.2 阻塞(Block) &amp; 非阻塞(Unblock)"></a>1.2 阻塞(Block) &amp; 非阻塞(Unblock)</h3><p><strong>阻塞/非阻塞主要针对S(Server)端：</strong></p>
<h4 id="1-2-1-什么是阻塞？"><a href="#1-2-1-什么是阻塞？" class="headerlink" title="1.2.1 什么是阻塞？"></a>1.2.1 什么是阻塞？</h4><p>当服务器上的应用程序(实际上是一个进程，对于单线程程序来说，一个应用程序只有一个线程)调用阻塞I/O完成某个操作时，应用程序会被挂起，等待操作系统内核完成操作后，再重新得到 CPU 继续执行应用程序，感觉上应用程序就像被“阻塞”了一样。实际上，在内核处理 I/O 操作的这段时间内，CPU 会被内核切换给其它有需要的进程，因此这个应用程序不能得到 CPU 资源来做其它的事情。</p>
<blockquote>
<p><strong>以“应用程序执行写数据的I/O操作”进行分析：</strong></p>
<p>当一个网络应用程序(用户态的进程)执行写操作时，首先等待写出的数据会保存在当前进程的内存空间中。当用户态进程发起“写操作”的系统调用后，CPU 需要将这份数据从用户进程的内存空间拷贝到当前操作系统的内核态空间中，当然这需要一定的时间。在没有得到这个系统调用的返回结果之前，这个用户态的进程将一直处于阻塞状态。直到得到了系统调用的返回结果后，用户进程重新轮询得到 CPU 资源后，进程才离开阻塞状态继续运行。</p>
</blockquote>
<p><strong>问：阻塞的是谁？</strong></p>
<p>答：阻塞的是应用程序（也就是应用程序对应的用户态进程）</p>
<h4 id="1-2-2-什么是非阻塞？"><a href="#1-2-2-什么是非阻塞？" class="headerlink" title="1.2.2 什么是非阻塞？"></a>1.2.2 什么是非阻塞？</h4><p>与阻塞 I/O 不同，当应用程序调用非阻塞 I/O 完成某个操作时，应用程序首先会通过系统调用来访问操作系统内核，但不会等待内核完成处理，而是立刻返回。这种情况下，内核就不会把 CPU 时间切换给其它进程，因此应用程序可以继续使用 CPU 资源来完成其它事情。</p>
<blockquote>
<p><strong>举例</strong></p>
<p>拿“去书店买书”举例子。</p>
<ul>
<li>阻塞 I/O 就是：你去了书店，告诉老板(内核)你想要某本书，然后你就一直在那儿等着，直到老板翻箱倒柜找到了你想要的书(本地阻塞)，有可能还要帮你联系全城的其它分店(网络阻塞)。注意：这个过程你一直滞留在书店等待老板的回复，就好像在书店老板这里“阻塞”住了。</li>
<li>而非阻塞 I/O 则是：你去了书店，问老板有没有你心仪的那本书，老板查了下电脑，告诉你没有，你就悻悻地离开了。一周以后，你又来这个书店，再问这个老板，老板一查，有了，于是你买了这本书。注意：这个过程中，你没有被阻塞，而是在不断地轮询。</li>
</ul>
<p><strong>I/O 多路复用</strong></p>
<ul>
<li>但是轮询的效率太低了，于是你跟老板商量：“老板，到货给我打电话吧，我再来付钱取书。”这就是所谓的 I/O 多路复用。</li>
</ul>
<p><strong>AIO(异步I/O)</strong></p>
<ul>
<li>再进一步，你连去书店取书也想省了，得了，让老板代劳吧。你留下地址，付了书费，让老板到货时寄给你，你直接在家里拿到书就可以看了。这就是传说中的异步 I/O。</li>
</ul>
</blockquote>
<h2 id="2-I-O模型"><a href="#2-I-O模型" class="headerlink" title="2. I/O模型"></a>2. I/O模型</h2><p>目前为止，Java 共支持 3 种 IO 模型：BIO、NIO、AIO</p>
<ul>
<li><strong>BIO（同步阻塞 I/O）</strong></li>
<li><strong>NIO（同步非阻塞I/O）</strong></li>
<li><strong>AIO（异步非阻塞I/O）</strong></li>
</ul>
<p>这里我们暂时不考虑同步和异步的问题，只从阻塞和非阻塞两个角度来学习常见的 I/O 模型。</p>
<h3 id="2-1-阻塞I-O"><a href="#2-1-阻塞I-O" class="headerlink" title="2.1 阻塞I/O"></a>2.1 阻塞I/O</h3><p><strong>所谓的阻塞I/O，就是在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其它任务，只有当条件就绪才能继续。如果读取数据，代码会阻塞直至用户线程的内存空间中有可供读取的数据。同样，如果写入数据，在内核写入完成前，用户线程会一直处于阻塞状态。</strong></p>
<p>传统的 Server/Client 模式基于 TPR(Thread per Request)原则，服务器会为每个客户端连接创建一个新的线程，由该线程单独负责处理当前次的客户请求。这种模式的缺点就是：服务器需要创建多个线程来维护多个连接，大量的线程会增大服务器的开销，甚至导致服务器宕机。</p>
<p><img src="http://processon.com/chart_image/62b5b7def346fb6dc5800047.png"></p>
<p>大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量。但这又带来了新的问题，如果线程池中有100个线程，而目前这100个线程都在进行文件传输，就会导致第101个用户的请求无法被及时处理，即便第101个用户只想请求一个几KB大小的页面。</p>
<h3 id="2-2-非阻塞I-O"><a href="#2-2-非阻塞I-O" class="headerlink" title="2.2 非阻塞I/O"></a>2.2 非阻塞I/O</h3><p>在 Java NIO 中，非阻塞 I/O 采用了基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，相反是注册感兴趣的特定 I/O 事件(如可读数据到达，新的套接字连接等)。在特定事件发生时，系统再通知我们。</p>
<blockquote>
<p>我要读数据 –&gt; 发起“系统调用” –&gt; 我不被阻塞，继续执行其它操作 –&gt; 我去注册一个感兴趣的读事件 –&gt; 数据达到用户进程内存空间时通知我 –&gt; 我去读数据</p>
<ul>
<li>注：“我” == 用户进程</li>
</ul>
</blockquote>
<p>NIO 中实现非阻塞 I/O 的核心对象就是 Selector。Selector 就是注册各种 I/O 事件的地方。当我们感兴趣的事件发生时，这个对象就会告诉我们所发生的事件。</p>
<p><img src="/2021/08/09/NIO/image-20210909171418839.png" alt="image-20210909171418839"></p>
<p>从图中可以看出，当用户进程空间有读或写等任何注册的事件发生时，可以从 Selector 中获得相应的 SelectionKey，同时从 SelectionKey 中可以找到发生的事件和该事件所发生的具体的 SelectableChannel，以获得客户端发送过来的数据。</p>
<p><strong>非阻塞指的是 I/O 事件本身不阻塞，但是获取 I/O 事件的 <code>select()</code> 方法是需要阻塞等待的。区别是阻塞 I/O 会阻塞在 I/O 操作上，NIO 阻塞在事件获取上，没有事件就没有 I/O，从更高的层次看 I/O 就不阻塞了。</strong></p>
<p><strong>也就是说只有 I/O 已经发生那么我们才评估 I/O 是否阻塞，但是 <code>select()</code> 阻塞的时候 I/O 还没有发生，何谈 I/O 的阻塞呢？NIO 的本质是延迟 I/O 操作到真正发生 I/O 的时候，而不是以前的只要 I/O 流打开了就一直等待 IO 操作。</strong></p>
<table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流（Stream Oriented）</td>
<td>面向缓冲区（Buffer Oriented）</td>
</tr>
<tr>
<td>阻塞IO（Blocking IO）</td>
<td>非阻塞IO（Non Blocking IO）</td>
</tr>
<tr>
<td>无</td>
<td>选择器（Selectors）</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-NIO-概述"><a href="#3-NIO-概述" class="headerlink" title="3. NIO 概述"></a>3. NIO 概述</h2><blockquote>
<p>  <strong>Java NIO；New IO 或 Non Blocking IO</strong></p>
</blockquote>
<p>Java NIO 是 JDK1.4 引入的一组全新的IO API，用于代替之前版本的 IO API。NIO 使用了<strong>面向缓冲区</strong>的、<strong>基于通道</strong>的IO操作，可以更加高效地执行文件的读写操作。</p>
<p>Java NIO 的三个核心组件：</p>
<ul>
<li><strong>Channels</strong></li>
<li><strong>Buffers</strong></li>
<li><strong>Selectors</strong></li>
</ul>
<p>虽然除此之外，Java NIO 中还有很多其它的类和组件，如 Pipe 和 FileLock。但其它 API 只不过是与三个核心组件配合使用的工具类。</p>
<h3 id="3-3-1-Channel"><a href="#3-3-1-Channel" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h3><blockquote>
<p>  <strong>Channel；通道</strong></p>
</blockquote>
<p>Channel 和传统 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream，OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。</p>
<p>NIO 中的 Channel 的主要实现类有：</p>
<ul>
<li>  FileChannel</li>
<li>  DatagramChannel</li>
<li>  SocketChannel</li>
<li>  ServerSocketChannel，</li>
</ul>
<p>这里看名字就可以猜出个所以然来：分别可以对应：</p>
<ul>
<li>  文件 I/O</li>
<li>  UDP 数据传输</li>
<li>  TCP 数据传输（Server 和 Client）</li>
</ul>
<h3 id="3-3-2-Buffer"><a href="#3-3-2-Buffer" class="headerlink" title="3.3.2 Buffer"></a>3.3.2 Buffer</h3><p>NIO 中的关于 Buffer 实现有：</p>
<ul>
<li>  <strong>ByteBuffer</strong></li>
<li>  <strong>CharBuffer</strong></li>
<li>  DoubleBuffer</li>
<li>  FloatBuffer</li>
<li>  IntBuffer</li>
<li>  LongBuffer</li>
<li>  ShortBuffer</li>
</ul>
<p>分别对应基本数据类型是：</p>
<ul>
<li>  byte</li>
<li>  char</li>
<li>  double</li>
<li>  float</li>
<li>  int</li>
<li>  long</li>
<li>  short</li>
</ul>
<h3 id="3-3-Selector"><a href="#3-3-Selector" class="headerlink" title="3.3 Selector"></a>3.3 Selector</h3><p><strong>Selector 运行单线程处理多个 Channel</strong>。</p>
<p>如果你的应用程序需要维护了多个通道，并且每个连接的流量都很低，使用 Selector 就会很方便。例如在一个聊天服务器中，使用 Selector，可以向 Selector 注册多个 Channel，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件。</p>
<hr>
<h1 id="第二章-缓冲区-Buffer"><a href="#第二章-缓冲区-Buffer" class="headerlink" title="第二章 缓冲区[Buffer]"></a>第二章 缓冲区[Buffer]</h1><h2 id="1-Buffer的属性"><a href="#1-Buffer的属性" class="headerlink" title="1. Buffer的属性"></a>1. Buffer的属性</h2><p>Buffer 实际上就是一个数组，这个数组的内容与元信息会被包装成一个 <code>java.nio.Buffer</code> 对象，并提供了一组访问这些信息的 API。</p>
<h3 id="Buffer-对象的重要属性"><a href="#Buffer-对象的重要属性" class="headerlink" title="Buffer 对象的重要属性"></a>Buffer 对象的重要属性</h3><ul>
<li><strong>capacity</strong>：容量。指缓冲区可以存储多少个字节的数据。<ul>
<li>容量在创建 Buffer 实例时指定，创建后不能再次修改。如果缓冲区满了，需要清空后才能继续写数据。</li>
</ul>
</li>
<li><strong>position</strong>：当前位置（读写指针）。指缓冲区当前写入/读取的位置。<ul>
<li>新的 Buffer 对象 position 初始值为 0，每读/写一个数据，position 自动向后移动一个单位，它的最大值是 <code>capacity-1</code>。当 Buffer 发生读写模式的切换时，position 会被重置为 0。</li>
</ul>
</li>
<li><strong>limit</strong>：上限。指第一个不能被读/写的位置。<ul>
<li>limit 上限后面的单元既不能读也不能写。在 Buffer 缓冲区的写模式下，limit 表示能够写入多少个数据；在读模式下，limit 表示最多可以读取多少个数据。</li>
</ul>
</li>
<li>mark：标记。设置一个标记位置。<ul>
<li>调用 mark() 方法会把标记设置在 position 位置，当调用 reset() 方法时，会把 position 设置为 mark 标记的位置。</li>
</ul>
</li>
</ul>
<p><img src="http://processon.com/chart_image/62a885837d9c082d0b2cb18d.png" alt="img"></p>
<p><code>CharBuffer.allocate(12)</code> 方法会创建一个大小为 12 个字符的 Buffer 数组。</p>
<ul>
<li>对于该 buffer 对象来说，新建的 buffer 对象默认处于写模式(因为新建的buffer里面没有内容，所以必然处于写模式)，position 初始为 0，capacity 和 limit 为 12。</li>
<li>向缓冲区中写入 5 个字符后，position 会移动到下标为 5 的地方，capacity 和 limit 未发生改变。</li>
<li>调用 flip() 方法切换到读模式后，capacity 仍不会发生变化，但 position 变为 0，limit 会变为 position 原来的位置(最多能读多少个字符)，即下标为 5 的位置。<ul>
<li>在写模式下，position 始终在真实数据的后一个位置，表示下一个要写的位置。而在读模式下，position 每次都指示当前次要读的数据的位置。</li>
</ul>
</li>
</ul>
<h2 id="2-Buffer的常用API"><a href="#2-Buffer的常用API" class="headerlink" title="2. Buffer的常用API"></a>2. Buffer的常用API</h2><p>在 NIO 中，Buffer 常见的子类有：</p>
<ul>
<li>ByteBuffer、CharBuff、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer</li>
</ul>
<p>这些 Buffer 覆盖了能够通过 I/O 发送的所有基本数据类型：</p>
<ul>
<li>byte、char、double、float、int、long、short 等。</li>
</ul>
<p>实际上使用比较多的是 <strong>ByteBuffer 和 CharBuffer</strong>。</p>
<ul>
<li>每个 Buffer 类都有一个静态方法 <code>allocate(capacity)</code> 可用于创建一个指定容量的缓冲区；</li>
<li>都有一个 <code>put()</code> 方法用于向缓冲区中写数据；一个 <code>get()</code> 方法用于从缓冲区中读数据；</li>
<li>当缓冲区中还有未读完的数据，而要求马上向缓冲区中写数据时，可以调用 <code>compact()</code> 方法进行压缩，将所有未读数据复制到 buffer 的起始位置，把 position 设置到最后一个未读元素的后面，limit 属性设置为 capacity。【可以理解为切换到了写模式，其实所谓的读写模式就是通过设置 position 和 limit 的位置来实现的】</li>
<li><code>capacity()</code> 方法返回缓冲区的大小。</li>
<li><code>hasRemaining()</code>：判断当前 position 后面是否还有待处理的数据。即判断 position 与 limit 之间是否还有有效数据。</li>
<li><code>limit()</code>：返回 limit 上限的位置</li>
<li><code>mark()</code>：设置缓冲区的标志位置，这个值只能在 0~position 之间。之后可以通过 <code>reset()</code> 方法返回到这个位置。</li>
<li><code>position()</code> 可以返回 position 当前位置。</li>
<li><code>remaining()</code> 返回当前 position 位置与 limit 之间的数据量</li>
<li><code>reset()</code> 方法可以将 position 设置为 mark 标志位</li>
<li><code>rewind()</code> 方法会将 position 设置为 0，并取消 mark 标志位。</li>
<li><code>clear()</code> 清空缓冲区。仅仅是修改 position 标志为 0，设置 limit 标志为 capacity，缓冲区中的数据还是存在的。</li>
<li><code>flip()</code> 方法可以把缓冲区由写模式切换到读模式。即先设置 limit 为 position 位置，再把 position 设置为 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 Buffer 的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBuffer01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建 CharBuffer 缓冲区对象</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、打印 capacity、limit、position</span></span><br><span class="line">    System.out.println(<span class="string">&quot;02************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、向缓冲区中写数据</span></span><br><span class="line">    buf.put(<span class="string">&quot;你&quot;</span>);</span><br><span class="line">    buf.put(<span class="string">&quot;好&quot;</span>);</span><br><span class="line">    buf.put(<span class="string">&quot;世&quot;</span>);</span><br><span class="line">    buf.put(<span class="string">&quot;界&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;03************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、调用 flip()，把缓冲区切换为读模式</span></span><br><span class="line">    buf.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;04************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、调用 get() 方法读取缓冲区中的数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;05************************************&quot;</span>);</span><br><span class="line">    System.out.println(buf.get()); <span class="comment">//你</span></span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、再次写数据，把数据保存在 position 位置(由于没有切换写模式，所以会直接覆盖position位置的数据)</span></span><br><span class="line">    buf.put(<span class="string">&quot;X&quot;</span>); <span class="comment">// 你X世界</span></span><br><span class="line">    System.out.println(<span class="string">&quot;06************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、设置标志</span></span><br><span class="line">    buf.mark(); <span class="comment">//标志设在了下标为2的位置上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8、再读一个字符</span></span><br><span class="line">    System.out.println(<span class="string">&quot;08************************************&quot;</span>);</span><br><span class="line">    System.out.println(buf.get()); <span class="comment">//世</span></span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9、调用 reset()，把position重置为mark标志位置</span></span><br><span class="line">    buf.reset();</span><br><span class="line">    System.out.println(<span class="string">&quot;09************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10、调用compact压缩，把buffer中未读的数据复制到 position 为 0 的位置【compact会完成读到写模式的转换】</span></span><br><span class="line">    buf.compact();</span><br><span class="line">    System.out.println(<span class="string">&quot;10************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11、调用 clear() 清空。仅仅是修改 position/limit 的值</span></span><br><span class="line">    buf.clear();</span><br><span class="line">    System.out.println(<span class="string">&quot;11************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12、clear() 清空以后，缓冲区的数据依然存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;12************************************&quot;</span>);</span><br><span class="line">    System.out.println(buf); <span class="comment">// 世界世界</span></span><br><span class="line">    <span class="comment">//通过循环把position与limit之间的内容逐个打印</span></span><br><span class="line">    <span class="keyword">while</span> (buf.hasRemaining())&#123;</span><br><span class="line">        System.out.println(buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用缓冲区就是为了提高数据传输效率，一次读写一个字符或者一个字节效率不高，可以进行批量处理操作。</span></span><br><span class="line"><span class="comment"> * 可以借助数组，把缓冲区中的一块数据读到数组中，也可以把数组中的部分内容保存到缓冲区。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBuffer02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 可以把字符串保存到 buffer 缓冲区中</span></span><br><span class="line">    buffer.put(<span class="string">&quot;你好世界，你好NIO&quot;</span>);</span><br><span class="line">    buffer.flip(); <span class="comment">// 切换为读模式(主要是为了改变limit的值)</span></span><br><span class="line">    System.out.println(buffer); <span class="comment">//你好世界，你好NIO</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] dst = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//调用 get() 方法把缓冲区中的数据读到字符数组中</span></span><br><span class="line">    <span class="comment">//注意：批量传输时大小总是固定的，如果没有指定传输的大小，意味着把数组填满。如果数组不能被填满，则会抛出异常</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">remainingCharBuffer</span> <span class="operator">=</span> buffer.get(dst);</span><br><span class="line">    System.out.println(<span class="string">&quot;数组中数据：&quot;</span> + Arrays.toString(dst)); <span class="comment">//数组中数据：[你, 好, 世, 界, ，, 你, 好, N]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;缓冲区中剩余数据：&quot;</span> + remainingCharBuffer); <span class="comment">// 缓冲区中剩余数据：IO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续把buffer中的内容读取到字符数组中，当缓冲区的数据量不足以填满整个数组时，会抛出异常</span></span><br><span class="line">    <span class="comment">// buffer.get(dst); //BufferUnderflowException</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在批量读取数据缓冲区的数据时，一定记得查询缓冲区中的剩余量。</span></span><br><span class="line">    <span class="comment">// 把小缓冲区中的数据填充到大数组中时，一定要指定缓冲区剩余量的长度。</span></span><br><span class="line">    buffer.get(dst, <span class="number">0</span>, buffer.remaining()); <span class="comment">// 把buffer缓冲区中剩余的数据(总大小为remaining)传输到dst数组0开始的位置</span></span><br><span class="line">    System.out.println(Arrays.toString(dst)); <span class="comment">// [I, O, 世, 界, ，, 你, 好, N]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取缓冲区中的数据</span></span><br><span class="line">    buffer.clear();</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(dst.length, buffer.remaining());</span><br><span class="line">        buffer.get(dst, <span class="number">0</span>, len);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(dst, <span class="number">0</span>, len)); <span class="comment">//你好世界，你好NIO</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量写入</span></span><br><span class="line">    <span class="type">char</span>[] contents = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">// 把字符数组中的数据写入到缓冲区中(如果缓冲区没有足够的空间，会抛出异常)</span></span><br><span class="line">    <span class="comment">//buffer.put(contents); //BufferOverflowException</span></span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer.capacity()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer.limit()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer.position()); <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">    buffer.clear();</span><br><span class="line">    buffer.put(contents);</span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(buffer); <span class="comment">//abcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Buffer 对象的创建方式：</span></span><br><span class="line"><span class="comment"> *      1、分配操作创建缓冲区。allocate() 方法分配一个私有的，指定容量大小的数据来存储元素。</span></span><br><span class="line"><span class="comment"> *      2、包装操作创建缓冲区。它使用现成的数组作为存储空间来充当一个缓冲区。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方式一：分配操作创建缓冲区</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buf1</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方式二：使用包装操作创建缓冲区</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">// 把现成的数组包装成一个Buffer对象</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buf2</span> <span class="operator">=</span> CharBuffer.wrap(charArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过调用 put() 方法向缓冲区中保存数据，也会直接影响到数组</span></span><br><span class="line">    buf2.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    buf2.flip();</span><br><span class="line">    System.out.println(buf2); <span class="comment">//hello</span></span><br><span class="line">    System.out.println(Arrays.toString(charArray)); <span class="comment">//[h, e, l, l, o,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组做的任何修改，也会影响到缓冲区对象</span></span><br><span class="line">    charArray[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    System.out.println(buf2); <span class="comment">//Xello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不管是 allocate() 还是通过 warp() 方法创建的缓冲区都是间接的。</span></span><br><span class="line"><span class="comment">     * 间接缓冲区会使用备份数组 hasArray() 方法判断是否有一个可存取的备份数组。</span></span><br><span class="line"><span class="comment">     * 如果 hasArray() 返回 true，可以通过 array() 返回缓冲区对象使用的备份数组的引用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (buf2.hasArray())&#123;</span><br><span class="line">        <span class="type">char</span>[] backupArray = buf2.array();</span><br><span class="line">        System.out.println(Arrays.toString(backupArray)); <span class="comment">//[X, e, l, l, o,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓冲区的复制与分隔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建缓冲区</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 2、存储数据</span></span><br><span class="line">    buffer.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;buffer.position=&quot;</span> + buffer.position()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、缓冲区的复制</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> buffer.duplicate();</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer2.capacity()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer2.limit()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer2.position()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    buffer2.flip();</span><br><span class="line">    System.out.println(buffer2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer 与 buffer2 实际引用同一个数组</span></span><br><span class="line">    buffer2.clear();</span><br><span class="line">    buffer2.put(<span class="string">&quot;NIO_world&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出 buffer 中的内容</span></span><br><span class="line">    buffer.flip(); <span class="comment">// 反转，把limit设置的值为上一个position的值5</span></span><br><span class="line">    System.out.println(buffer); <span class="comment">//NIO_w</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔缓冲区，slice() 方法根据 [position, limit) 区间创建一个新的缓冲区</span></span><br><span class="line">    buffer2.position(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer2.capacity()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer2.limit()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer2.position()); <span class="comment">//3</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> buffer2.slice();</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer3.capacity()); <span class="comment">//13</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer3.limit()); <span class="comment">//13</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer3.position()); <span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-直接字节缓冲区-ByteBuffer"><a href="#3-直接字节缓冲区-ByteBuffer" class="headerlink" title="3. 直接字节缓冲区[ByteBuffer]"></a>3. 直接字节缓冲区[ByteBuffer]</h2><p>在硬盘和操作系统中处理的数据都是二进制的 01 数据，Buffer 的子类中只有 ByteBuffer 字节缓冲区有资格参与 IO 操作。</p>
<p>Channel 通道只能使用 ByteBuffer 作为它的参数。</p>
<p>直接字节缓冲区通常是 IO 操作最好的选择，如果使用非直接字节缓冲区可能会导致性能损耗。如果向通道传递一个非直接字节缓冲区，通道可能会先创建一个临时的直接字节缓冲区，将非直接缓冲区中的内容复制到这个临时的直接字节缓冲区中，使用临时直接字节缓冲区执行底层的 IO 操作。</p>
<p>直接缓冲区是 IO 的最佳选择，可能创建直接缓冲区比创建非直接缓冲区的成本要高。直接缓冲区使用的内存是通过调用本地操作系统分配的，绕过了 JVM 的堆栈。</p>
<p>现在 JVM 可能会执行缓冲区缓存的优化，作为入门初级开发人员，不要考虑优化的问题，先保证程序的正确性。</p>
<p><code>ByteBuffer.allocateDirect(16)</code> 方法创建直接字节缓冲区。</p>
<hr>
<h1 id="第三章-通道-Channel"><a href="#第三章-通道-Channel" class="headerlink" title="第三章 通道[Channel]"></a>第三章 通道[Channel]</h1><h2 id="1-Channel概述"><a href="#1-Channel概述" class="headerlink" title="1 Channel概述"></a>1 Channel概述</h2><p><strong>通道(Channel)负责将缓冲区的数据块移入到各种I/O源，如文件、socket、数据报等；或者是将各种 I/O 源的数据移入到缓冲区。</strong></p>
<ul>
<li>  通道与流(Stream)的不同之处在于通道是双向的，而流只在一个方向上移动(一个流必须是 InputStream 或 OutputStream)。</li>
<li>  而且通道可以用于读、写或同时用于读写。因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5/310007?fr=aladdin">全双工</a></li>
<li>  NIO 中通过 Channel 封装了对数据源的操作，通过 Channel 我们可以操作数据源，但又不必关心数据源的具体物理结构。这个数据源可以是多种的。比如，可以是文件，也可以是网络 socket。</li>
<li>  在大多数应用中，Channel 与文件描述符或者 socket 是一一对应的。</li>
<li>  <strong>Channel 用于在 Buffer 缓冲区和位于通道另一侧的实体(通常是一个文件或套接字)之间有效地传输数据。</strong></li>
</ul>
<blockquote>
<p>  <strong>Channel接口源码</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio.channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tells whether or not this channel is open.</span></span><br><span class="line"><span class="comment">     * 判断通道是否打开</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if, and only if, this channel is open</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this channel.</span></span><br><span class="line"><span class="comment">     * 关闭通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>  与缓冲区不同，Channel API 主要由接口指定。<strong>通道API仅仅进行了一些功能性的描述，具体的实现方式根据不同的操作系统会有根本性的差异。</strong>因此很自然地，Channel 的实现通常使用操作系统的本地代码。</li>
<li>  Channel 是一个对象，可以通过它读取和写入数据。拿 NIO 与传统 I/O 做个比较，通道就像是流，所有数据都通过 Buffer 对象来处理。你永远不会将字节直接写入通道中，相反，你是将数据写入包含一个或者多个字节的缓冲区。同样，你不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</li>
</ul>
<p>Java NIO 的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道中。但流的读写通常是单向的。</li>
<li>通道可以异步的读写。</li>
<li>通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：</li>
</ul>
<p><img src="http://processon.com/chart_image/62b5bc5d1efad40851a8a913.png"></p>
<hr>
<h2 id="2-Channel实现"><a href="#2-Channel实现" class="headerlink" title="2 Channel实现"></a>2 Channel实现</h2><p>下面是 Java NIO 中最重要的 Channel 的实现：</p>
<ul>
<li><strong>FileChannel</strong>：从文件中读写数据。</li>
<li><strong>DatagramChannel</strong>：能通过 UDP 协议读写网络中的数据。</li>
<li><strong>SocketChannel</strong>：能通过 TCP 协议读写网络中的数据。</li>
<li><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，像 Web 服务器那样。对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<p>这些通道涵盖了 UDP 和 TCP 网络 I/O，以及文件 I/O。</p>
<h2 id="3-FileChannel"><a href="#3-FileChannel" class="headerlink" title="3 FileChannel"></a>3 FileChannel</h2><h4 id="从-channel-中读数据"><a href="#从-channel-中读数据" class="headerlink" title="从 channel 中读数据"></a>从 channel 中读数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 FileChannel 读取文件中的数据到 Buffer 中</span></span><br><span class="line"><span class="comment">     *  1、创建 FileChannel 对象</span></span><br><span class="line"><span class="comment">     *  2、创建 Buffer 对象</span></span><br><span class="line"><span class="comment">     *  3、通过 FileChannel 读取文件中的数据到 Buffer 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建FileChannel对象（FileChannel不能直接创建，创建该对象要依赖于一个File对象）</span></span><br><span class="line">        <span class="comment">// args1：文件路径。 args2：文件模式（读/写/执行）</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">afile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\nio\\src\\resource\\demo.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> afile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建Buffer对象，并分配buffer的大小（4字节）</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将数据从文件读取到Buffer中</span></span><br><span class="line">        <span class="comment">// 返回值用于记录当前次读取的字节数，等于-1时表示读取到了最后一行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> fileChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取了：&quot;</span> + bytesRead + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 目的：验证数据是否已经读到了buffer中。</span></span><br><span class="line"><span class="comment">            * 方式：取出buffer对象中的数据，打印在控制台上</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="comment">// 进行读写模式的转换【在这里转换的目的是为了输出读到的内容】</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// hasRemaining方法用于判断Buffer中是否还有剩余的数据内容</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 获取buffer中的内容</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) buffer.get();</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 循环从文件中读取数据到buffer中（当buffer中无数据后，bytesRead变量应该为-1）</span></span><br><span class="line">            bytesRead = fileChannel.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、释放资源</span></span><br><span class="line">        afile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;操作结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">读取了：4字节</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">读取了：4字节</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">读取了：1字节</span><br><span class="line">9</span><br><span class="line">操作结束</span><br></pre></td></tr></table></figure>



<h4 id="向-channel-中写数据"><a href="#向-channel-中写数据" class="headerlink" title="向 channel 中写数据"></a>向 channel 中写数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 向 Channel 中写数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、进行数据传输时需要使用到 Channel（通道），也就是说需要先创建一个连通两端（发送方/接收方）的通道</span></span><br><span class="line"><span class="comment">        2、创建 Channel 需要两端，其中一端为连接的发起方，在这里就是我们的代码端，所以我们必须还要手动指定</span></span><br><span class="line"><span class="comment">        另一端，一般我们会指定为一个文件。</span></span><br><span class="line"><span class="comment">      整个流程也就是说，把我们在代码中的数据发送给本机上的某个文件，在这两端之间建立一个 channel 用于数据传输，</span></span><br><span class="line"><span class="comment">      当然也会用到 buffer，因为 channel 的读或写操作都直接依赖于 buffer ，用 buffer 作为一个中转站，再去</span></span><br><span class="line"><span class="comment">      访问到具体的文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建 channel 对象，需要提前指定好 channel 的另一端，一般是一个文件对象</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo02.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、建立 磁盘文件 到 Java程序虚拟内存 间的连接通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、分配一块缓冲区，用于向channel中写数据</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、在内存中新建一段数据，并将其写入 buffer 中</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;This is my world!&quot;</span>).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        buffer.clear(); <span class="comment">// 使用前先清空buffer中的数据，这是一个好习惯</span></span><br><span class="line">        buffer.put(bytes);</span><br><span class="line"></span><br><span class="line">        buffer.flip();  <span class="comment">// 切换为读模式(向channel中写就意味着从buffer中读)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、将 buffer 中的数据写入 channel 中</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())</span><br><span class="line">        &#123;</span><br><span class="line">            channel.write(buffer);	<span class="comment">// 注意 write() 方法需要在while循环中进行调用，因为无法保证 write() 方法一次能向 channel 中写入多少字节，因此需要重复调用 write() 方法，直到 buffer 为空</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="通道间的数据传输"><a href="#通道间的数据传输" class="headerlink" title="通道间的数据传输"></a>通道间的数据传输</h4><p>两个通道间的数据可以进行直接的数据传输</p>
<h5 id="FileChannel-transferTo-transferFrom"><a href="#FileChannel-transferTo-transferFrom" class="headerlink" title="FileChannel#transferTo/transferFrom"></a>FileChannel#transferTo/transferFrom</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通道间的数据传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、建立两个通道</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo02.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel1</span> <span class="operator">=</span> file1.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel2</span> <span class="operator">=</span> file2.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、通道间进行数据传输（将channel1中的数据传输到channel2中）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> channel1.size();</span><br><span class="line"><span class="comment">//        channel1.transferTo(position, count, channel2);   // 方法1</span></span><br><span class="line">        channel2.transferFrom(channel1, position, count);   <span class="comment">// 方法2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、关闭资源</span></span><br><span class="line">        channel1.close();</span><br><span class="line">        channel2.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<h4 id="FileChannel-size-方法"><a href="#FileChannel-size-方法" class="headerlink" title="FileChannel#size()方法"></a>FileChannel#size()方法</h4><ul>
<li>  FileChannel 对象是根据其所关联的具体文件来创建的，</li>
<li>  所以 FileChannel 实例的 size() 方法将返回该实例所关联的文件的大小。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> fileChannel.size();	</span><br></pre></td></tr></table></figure>



<h4 id="FileChannel-truncate-方法"><a href="#FileChannel-truncate-方法" class="headerlink" title="FileChannel#truncate() 方法"></a>FileChannel#truncate() 方法</h4><ul>
<li>  FileChannel 实例一定会关联到某一个具体的文件</li>
<li>  可以使用 <strong>FileChannel#truncate()</strong> 方法来截取这个文件，截取文件时，会将指定长度后面的部分删除掉。截取后得到一个新的 fileChannel 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">newFileChannel</span> <span class="operator">=</span> fileChannel.truncate(<span class="number">1024</span>);	<span class="comment">// 截取文件的前 1024 个字节</span></span><br></pre></td></tr></table></figure>



<h4 id="FileChannel-force-方法"><a href="#FileChannel-force-方法" class="headerlink" title="FileChannel#force() 方法"></a>FileChannel#force() 方法</h4><ul>
<li>  在使用 Channel 时，出于性能考虑，操作系统会先将 channel 中的数据写出到缓存中，缓存区满了之后再将缓存中的数据写到磁盘上，所以一般情况下 fileChannel 无法保证数据一定会即时写到磁盘上。</li>
<li>  若想保证这一点，可以使用 FileChannel 的 force() 方法会将通道中尚未写入磁盘中的数据和缓存中的数据强制写到磁盘上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.force(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// force() 方法有一个 boolean 类型的参数，指明是否将数据写到磁盘上</span></span><br></pre></td></tr></table></figure>





<hr>
<h4 id="FileChannel-position-方法"><a href="#FileChannel-position-方法" class="headerlink" title="FileChannel#position() 方法"></a>FileChannel#position() 方法</h4><ul>
<li>  <strong>FileChannel#position()</strong> 方法可以获取 filechannel 当前读/写到的位置，</li>
<li>  也可以调用 position(long pos) 方法设置 fileChannel 的读/写的位置。</li>
<li>  该功能用于对 fileChannel 的某个特定位置进行读/写操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();	<span class="comment">// 获取 fileChannel 的当前位置</span></span><br><span class="line">channel.position(pos + <span class="number">123</span>);	<span class="comment">// 设置 fileChannel 的新的当前位置</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>  如果将当前位置设置在文件结束符之后，再试图从文件通道中读取数据，读方法将返回 -1。</li>
<li>  如果将当前位置设置在文件结束符之后，然后向通道中写数据，文件将被撑大到当前位置并写入数据。但是这有可能导致<strong>“文件空洞”</strong>，即磁盘上物理文件中写入的数据间有空隙。</li>
</ul>
<hr>
<h2 id="4-TCP协议相关的Channel"><a href="#4-TCP协议相关的Channel" class="headerlink" title="4. TCP协议相关的Channel"></a>4. TCP协议相关的Channel</h2><p>Channel接口有很多实现类，但是对于网络编程来说，实际上只有3个重要的通道类：SocketChannel、ServerSocketChannel和DatagramChannel。对于TCP连接，只需要前两个通道类；对于UDP连接只需要第三个通道类。</p>
<h3 id="4-1-SocketChannel"><a href="#4-1-SocketChannel" class="headerlink" title="4.1 SocketChannel"></a>4.1 SocketChannel</h3><p>SocketChannel对象可以读写<code>TCP Socket</code>。每个SocketChannel都与一个Socket对象关联。这个Socket对象可用于高级配置，但有些应用采用默认选项就可以正常运行，对于这些应用程序，可以忽略这个需求。</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>SocketChannel类没有公共的构造函数。但提供了两个静态 open() 方法来创建新的SocketChannel对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">(SocketAddress remote)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>第一个方法会尝试建立连接(通过系统调用告知操作系统内核尝试与远端建立连接)。这个方法是一个阻塞方法。也就是说，在连接建立或抛出异常之前，当前线程将一直处于阻塞状态。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open(address);</span><br></pre></td></tr></table></figure>

<p>无参版本的方法不会立即建立连接。它会创建一个初始未连接socket，以后必须用 connect() 方法进行连接。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">channel.connect(address);</span><br></pre></td></tr></table></figure>

<p>如果你希望以非阻塞的方式打开通道时，还需要配置通道的各项属性。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">channel.connect(address);</span><br></pre></td></tr></table></figure>

<p>或者你还想在连接前配置 socket 的各种选项，你可以选择一种更迂回的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> channel.socket();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">socket.connect(address);</span><br></pre></td></tr></table></figure>

<p>使用非阻塞通道时，connect() 方法会立即返回。在等待操作系统与远端服务器建立连接时，程序可以做其它事情。不过，程序在实际使用这个连接之前，一定要调用 finshConnect() 方法验证连接是否完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回true表示连接现在可以使用；</span></span><br><span class="line"><span class="comment"> * 返回false表示连接还未建立成功；</span></span><br><span class="line"><span class="comment"> * 如果连接无法建立，比如网络出现故障，将会抛出一个异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">finishConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>当然，这只对非阻塞模式是必须的。对于阻塞通道，当线程可以继续正常向后执行时连接一定已经建立成功了。</p>
<p>如果程序想检查连接是否完成，可以使用以下两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isConnectionPending</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>如果连接处于打开状态，isConnected() 方法会返回true。如果连接仍在建立过程中，isConnectionPending() 返回 true。</p>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>为了读取 SocketChannel 通道中的数据，首先要创建一个 ByteBuffer 对象，可以读取通道中的数据写到 Buffer 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>通道会用尽可能多的数据填充缓冲区，然后返回写入缓冲区的字节数。如果遇到流末尾，通道会将所有的剩余字节数写出到缓冲区，并且在下一次调用 read() 时返回<code>-1</code>。</p>
<p>如果通道是阻塞的，这个方法至少读取一个字节(读取成功)，或者返回<code>-1</code>(读取完成)，或者抛出异常(读取失败)。但如果通道是非阻塞的，这个方法可能返回<code>0</code>。</p>
<blockquote>
<ul>
<li>在阻塞模式下，若 SocketChannel 中没有数据可读，或者缓冲区满了，就会阻塞，直到满足读的条件(源有数据可读，目的地可以写数据)。所以一般阻塞模式的 read() 是比较简单的。</li>
<li>在非阻塞模式下，read() 方法返回 0 有两种情况：<ul>
<li>（1）首先是：某一时刻的 socketChannel 中没有数据可读会返回0。</li>
<li>（2）其次是：byteBuffer 中的 position 等于 limit 了，即 byteBuffer 缓冲区满了也会返回0；</li>
</ul>
</li>
</ul>
</blockquote>
<p>例如，下面的循环会一直读取从 socketChannel 读取数据向缓冲区写入，直到缓冲区填满或检测到流末尾为止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (buffer.hasRemaining() &amp;&amp; channel.read(buffer) != -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>





<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>Socket通道提供了读写方法，一般情况下它们是全双工的。要想写入，只需先填充一个 ByteBuffer，再将 ByteBuffer 中的数据写入通道中即可。</p>
<p>基本的 write() 方法接收一个缓冲区对象作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>与读取一样，如果通道是非阻塞的，这个方法不能保证会一次性将缓冲区中的全部内容写入到通道中。不过基于缓冲区游标的特性，你可以很容易的反复调用这个方法，直到缓冲区完全排空，且数据已经完全写入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (buffer.hasRemaining() &amp;&amp; channel.write(buffer) != -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>就像正常的 Socket 一样，在用完通道后应该将其关闭，释放它使用的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>如果通道已经关闭，再进行重复关闭将没有任何效果。如果试图读/写已关闭的通道，将抛出一个异常。如果不确定通道是否已经关闭，可以使用 isOpen() 方法检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通道已经关闭时，该方法返回 false；</span></span><br><span class="line"><span class="comment"> * 如果通道是打开的，则返回 true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>close() 和 isOpen() 方法是 Channel 接口中声明的仅有的两个方法，所有的通道类都共享这两个方法。</p>
<hr>
<h3 id="4-2-ServerSocketChannel"><a href="#4-2-ServerSocketChannel" class="headerlink" title="4.2 ServerSocketChannel"></a>4.2 ServerSocketChannel</h3><p>与 SocketChannel、DatagramChannel 不同，ServerSocketChannel 类并没有定义读和写的功能。ServerSocketChannel 类只有两个目的：监听并接受一个新的客户端连接和创建新的 SocketChannel 对象，它本身从不传递数据。</p>
<p>ServerSocketChannel 类本身只声明了4个方法，其中 accept() 最重要。该类还从其超类继承了几个方法，主要与向 Selector 注册来得到客户端连接通知有关。最后，与所有的通道一样，它有一个 close() 方法，用于关闭服务器 Socket。</p>
<h4 id="创建服务器Socket通道"><a href="#创建服务器Socket通道" class="headerlink" title="创建服务器Socket通道"></a>创建服务器Socket通道</h4><p>静态工厂方法 ServerSocketChannel.open() 用于创建一个新的 ServerSocketChannel 对象。不过，在 JDK7 之前，这个方法实际并不打开一个新的服务器 Socket，而只是创建一个 Channel 对象。在使用之前，需要调用 socket() 方法来获得相应的 ServerSocket 对象。之后，你就可以使用 serverSocket 的各种设置方法配置任何服务器选项。比如接收缓冲区的大小或 Socket 的超时值。最后，对于你希望绑定的端口，将这个 serverSocket 连接到对应端口的 SocketAddress。例如，下面的代码希望在端口 80 上打开一个 ServerSocketChannel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> server.socket();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">80</span>);</span><br><span class="line">socket.bind(address);</span><br></pre></td></tr></table></figure>

<p>在 Java7 之后，这个过程会更简单一些，因为现在 ServerSocketChannel 有了一个自己的 bind() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">80</span>);</span><br><span class="line">server.bind(address);</span><br></pre></td></tr></table></figure>

<p>JVM 在创建 ServerSocketChannel 对象时使用了工厂方法而不是构造函数，但是不同的虚拟机可以提供这个类的不同实现，从而更适用于本地硬件和操作系统。</p>
<h4 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h4><p>一旦打开并绑定了 ServerSocketChannel 对象，accept() 方法就可以监听新入站的 TCP 连接了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title function_">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>accept() 可以在阻塞或非阻塞模式下操作。</p>
<p>在阻塞模式下，accept() 方法等待入站连接。然后它接受一个连接，并返回连接到到远程客户端的一个 SocketChannel 对象。在建立连接之前，线程无法进行任何操作。这种策略适用于立即响应每一个请求的简单服务器。阻塞模式是默认模式。</p>
<p>在非阻塞模式下，如果没有入站连接，accept() 方法会返回 null。非阻塞模式更适合于需要为每个连接完成大量工作的服务器，这样就可以并发地处理多个请求。非阻塞模式一般与 Selector 配合使用。为了使 ServerSocketChannel 处于非阻塞模式，要向其 configureBlocking() 方法传入 false。</p>
<p>accept() 方法声明：出现错误时将抛出一个 IOException。IOException 的几个常见的子类及运行时异常如下：</p>
<ul>
<li>ClosedChannelException    关闭后无法重新打开一个 ServerSocketChannel。</li>
<li>AsynchronousCloseException    执行 accept() 方法时，另一个线程管理了这个 ServerSocketChannel</li>
<li>ClosedByInterruptException    一个阻塞 ServerSocketChannel 在等待时，另一个线程中断了这个线程。</li>
<li>NotYetBoundException    调用了 open()，但在调用之前没有将 ServerSocketChannel 对应的 ServerSocket 对象与地址绑定。这是一个运行时异常，不是 IOException 异常。</li>
<li>SecurityException    安全管理器拒绝这个应用程序绑定所请求的端口。</li>
</ul>
<h3 id="4-3-实战"><a href="#4-3-实战" class="headerlink" title="4.3 实战"></a>4.3 实战</h3><p>ServerSocketChannel 可以监听新进来的 TCP 连接。</p>
<p>SocketChannel 是一个连接到 TCP 网络套接字的。</p>
<p><strong>ServerSocketChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Date</span> 2022/6/19 21:11</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerSocketChannelTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="comment">// 1、建立一个新的(未绑定ServerSocket服务器的)的Channel通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、得到与 channel 相连的 serverSocket，并为 serverSocket 绑定端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));   <span class="comment">// 由于当前在服务器端，IP就是本机IP，所以直接绑定端口号即可</span></span><br><span class="line">        <span class="comment">// 从JDK7开始，上述两步可合为一步，代码如下：</span></span><br><span class="line">        <span class="comment">//serverSocketChannel.bind(new InetSocketAddress(port));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、设置通道(Channel)为非阻塞模式。当没有传入连接时，accept()方法返回null</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、服务器始终保持监听状态，监测是否有客户端请求连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是ServerSocket服务器，已经准备就绪。&quot;</span>);</span><br><span class="line">            <span class="comment">// 服务器通过 accept() 方法接收客户端发生的 socketChannel。(socketChannel中携带了客户端发送过来的数据)</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">            <span class="comment">// 如果没有入站请求，accept() 方法默认的返回值为null</span></span><br><span class="line">            <span class="keyword">if</span> (socketChannel == <span class="literal">null</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">//这里设置了：当没有客户端接入时，服务器等待3000ms后再重新监测</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当有连接到达服务器时：</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 先给客户端发送一个问候(服务器端-&gt;Buffer-&gt;SocketChannel)</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charsets.UTF_8.encode(<span class="string">&quot;Hello，I&#x27;m from socketServer&quot;</span>);</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Channel支持全双工数据传输，既有读的通道，也有也的通道，同时读写并不冲突</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                <span class="comment">// 再读取客户端中发送来的内容</span></span><br><span class="line">                <span class="type">SocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> socketChannel.socket().getRemoteSocketAddress();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端地址：&quot;</span> + address.toString());</span><br><span class="line">                <span class="comment">// 读取客户端发来的数据保存到buffer中</span></span><br><span class="line">                buffer.clear(); <span class="comment">// 复用buffer</span></span><br><span class="line">                socketChannel.read(buffer);</span><br><span class="line">                <span class="comment">// 打印buffer中的内容</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端发来的信息：&quot;</span> + Charsets.UTF_8.decode(buffer));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>SocketChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ReadableByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/19 21:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketChannelTest</span> &#123;</span><br><span class="line">    <span class="comment">// 服务器IP和进程端口号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT); <span class="comment">// Server Socket的地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个未连接 ServerSocket 的 SocketChannel(客户端Channel，客户端发出/接收的数据都要经过该channel)</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="comment">// 连接 socketChannel 与 socket</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> socketChannel.socket();</span><br><span class="line">        <span class="comment">// 建立客户端 socket 与服务器 serverSocket 的连接</span></span><br><span class="line">        socket.connect(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TCP连接需要一定时间，两个连接的建立需要进行“三次握手”</span></span><br><span class="line">        <span class="comment">// 可以调用 finishConnect() 方法查看连接是否完成，如果没有连接成功返回false</span></span><br><span class="line">        <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在连接中，请稍后...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功! ^_^&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向服务器发送消息[客户端代码 -&gt; Buffer -&gt; 客户端Channel -&gt; 服务器Channel]</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charsets.UTF_8.encode(<span class="string">&quot;Hello, I&#x27;m form client socket&quot;</span>);</span><br><span class="line">        System.out.println(buffer.position());</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得服务器发送给客户端的消息(服务器返回 -&gt; 客户端Channel -&gt; buffer -&gt; 打印输出)</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socketChannel.socket().getInputStream();</span><br><span class="line">        <span class="type">ReadableByteChannel</span> <span class="variable">newChannel</span> <span class="operator">=</span> Channels.newChannel(inputStream);</span><br><span class="line">        <span class="comment">// 读 newChannel 中的数据到 buffer 中</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        newChannel.read(buffer);</span><br><span class="line">        <span class="comment">// 展示buffer中的数据</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(Charsets.UTF_8.decode(buffer));</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="第四章-选择器-Selector"><a href="#第四章-选择器-Selector" class="headerlink" title="第四章 选择器[Selector]"></a>第四章 选择器[Selector]</h1><h2 id="1-选择器基础"><a href="#1-选择器基础" class="headerlink" title="1. 选择器基础"></a>1. 选择器基础</h2><p>选择器提供了一种<strong>选择执行已经就绪任务的能力</strong>。</p>
<blockquote>
<p><strong>已就绪任务</strong>：该任务已经从操作系统内核返回用户态的进程空间了，对程序而言，这就是“就绪”了。</p>
</blockquote>
<p>Selector 选择器允许单线程处理多个通道。</p>
<p>如果服务器同时维护着多个连接通道，并且每个连接通道的流量都比较低，这时候就可以使用 Selector 来管理多个通道。</p>
<p>一个线程维护一个 Selector 实例，一个 Selector 实例维护多个 Channel 通道，这样就实现了一个线程同时管理多个 Channel 通道。 </p>
<p><img src="http://processon.com/chart_image/62b453cdf346fb075472e93a.png" alt="img"></p>
<ul>
<li>要使用 Selector 选择器，就需要向 Selector 实例注册 Channel 实例，注册成功后会返回一个维护 Channel 与 Selector 间关系的对象(SelectionKey)，并在 SelectionKey 实例中记录当前 Selector 关心的通道和通道中发生的操作。选择键 selectionKey 会追踪通道是否就绪。</li>
<li>selector 实例可以调用它的 <code>select()</code> 方法，来获取其关联的 selectionKey 的最新状态(调用 <code>select()</code> 方法后，与 selector 实例关联的所有的 channel 的信息都会被更新)。以此来检查所有被注册到 selector 的 channel 的最新消息，可以选择出两次调用 <code>selec()</code> 方法的间隔内新就绪的 channel。</li>
<li>Selector 选择器提供了一种询问 Channel 通道是否已经准备好执行 I/O 操作的能力。比如：了解 ServerSocketChannel 是否有新的连接，SocketChannel 是否还有更多的字节需要读取。</li>
</ul>
<h3 id="1-1-三个相关的类"><a href="#1-1-三个相关的类" class="headerlink" title="1.1 三个相关的类"></a>1.1 三个相关的类</h3><p><strong>Selector 选择器</strong></p>
<ul>
<li>Selector 选择器对象通过 SelectionKey 对象管理着所有注册成功的通道(Channel)，包括通道的基本信息和就绪状态。</li>
</ul>
<p><strong>SelectableChannel 可被选择的通道</strong></p>
<ul>
<li><p>SelectableChannel 是一个抽象类，是所有支持就绪检查的通道类的基类。</p>
</li>
<li><p>注意：FileChannel 不是 SelectableChannel 的子类，即 FileChannel 是不能注册到 Selector 选择器上的。</p>
</li>
<li><p>一个 selectableChannel 实例可以注册到多个 selector 实例上，但是不能多次注册到同一个一个选择器上。</p>
<p>  <img src="http://processon.com/chart_image/62b471935653bb104192d9ed.png" alt="img"></p>
</li>
</ul>
<p><strong>SelectionKey 选择键</strong></p>
<ul>
<li>SelectionKey 封装了 selectableChannel 与 selector 之间的一种关联关系。</li>
<li>selectionKey 包含了两个 byte 集合，一个指示注册关系所关心的通道操作，另一个表示通道已经准备好的操作。</li>
</ul>
<h3 id="1-2-如何创建Selector选择器"><a href="#1-2-如何创建Selector选择器" class="headerlink" title="1.2 如何创建Selector选择器"></a>1.2 如何创建Selector选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建Selector实例[工厂模式]</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、channel通道必须设置为非阻塞模式才能注册到Selector选择器上</span></span><br><span class="line"><span class="type">SelectableChannel</span> <span class="variable">selectableChannel1</span> <span class="operator">=</span> ...;</span><br><span class="line">selectableChannel1.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 创建两个channel实例</span></span><br><span class="line"><span class="type">SelectableChannel</span> <span class="variable">selectableChannel2</span> <span class="operator">=</span> ...;</span><br><span class="line">selectableChannel2.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、把channel通道的OP_READ事件注册到selector上，会返回一个选择键(SelectionKey实例)</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> selectableChannel1.register(selector, SelectionKey.OP_READ); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     arg1：把channel通道注册到哪个selector上；</span></span><br><span class="line"><span class="comment">     arg2：selector选择器关注channel通道中的哪些操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用位运算符把selector关注的多种操作连接起来</span></span><br><span class="line">selectableChannel2.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     SelectionKey 包含的操作有：</span></span><br><span class="line"><span class="comment">         1) OP_CONNECT  通道中是否发生了“客户端请求连接服务器”的事件   </span></span><br><span class="line"><span class="comment">         2) OP_ACCEPT  只有 ServerSocketChannel 有这个事件，通道中是否发生了“查看新的连接”的事件</span></span><br><span class="line"><span class="comment">         3) OP_READ  通道中是否发生了“读操作准备就绪”事件</span></span><br><span class="line"><span class="comment">         4) OP_WRITE  通道中是否发生了“写操作准备就绪”事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、注册完成后，可调用 select() 方法轮询是否有就绪的通道</span></span><br><span class="line"><span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> selector.select(); <span class="comment">// select()方法返回就绪通道的数量</span></span><br></pre></td></tr></table></figure>





<h2 id="2-SelectionKey相关的方法"><a href="#2-SelectionKey相关的方法" class="headerlink" title="2. SelectionKey相关的方法"></a>2. SelectionKey相关的方法</h2><p>向 Selector 注册一个 Channel 通道时，就会返回一个 SelectionKey 选择键对象，这个 selectionKey 对象表示一个通道与一个选择器之间的关联关系。</p>
<p><img src="http://processon.com/chart_image/62b453cdf346fb075472e93a.png" alt="img"></p>
<p><strong>selectionKey 对象中的方法：</strong></p>
<ul>
<li><p>channel()    返回该键对应的通道</p>
</li>
<li><p>selector()    返回该键对应的选择器</p>
</li>
<li><p>cancel()    删除选择器与通道间的关联关系</p>
</li>
<li><p>isValid()    判断选择器与通道的关联关系是否有效</p>
</li>
<li><p>interestOps()    返回 selector 对象关注的该通道中的操作/事件。</p>
<ul>
<li><p>返回结果是一个整数，该整数是一个比特掩码，可以使用位运算符检查所关心的操作。如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 selector 对象关注的该通道中的事件的编码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该编码是否对应 SelectionKey.OP_READ </span></span><br><span class="line"><span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> interestOps &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">if</span> (key == SelectionKey.OP_READ)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是一个 SelectionKey.OP_READ 事件&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>readyOps()    返回通道中已经就绪的操作。</p>
<ul>
<li>返回值也是一个整数，也可以使用类似上面的位运算操作检测通道中有哪个事件/操作已经准备就绪。</li>
</ul>
</li>
<li><p>除了按位与操作外，还可以使用 selectionKey 对象的 isReadable()、isWritable()、isConnectable()、isAccetable() 等方法来检测通道中哪些事件已就绪。</p>
</li>
</ul>
<h2 id="3-使用选择器"><a href="#3-使用选择器" class="headerlink" title="3. 使用选择器"></a>3. 使用选择器</h2><p>Selector 选择器通过 SelectionKey 对象维护着所有注册成功的集合通道。</p>
<p>每个 Selector 对象都有以下三个集合：</p>
<ul>
<li>已注册的 selectionKey 对象集合(<code>Set&lt;SelectionKey&gt;</code> )：通过 <code>selector.keys()</code> 方法返回这个集合。</li>
<li>已就绪的 selectionKey 对象集合：通过 <code>selector.selectedkeys()</code> 方法返回。该集合中的每个成员都是相关通道及关注的事件被选择器判断已经准备好了的。</li>
<li>已取消的 selectionKey 对象集合：这个集合包含了调用过 cancel() 方法的 selectionKey 对象集合。</li>
</ul>
<p>对于新创建的 Selector 对象，这三个集合都为空。</p>
<br>

<p>Selector 类的核心就是 select() 选择，该方法调用时，执行以下步骤：</p>
<ol>
<li>检查 <code>已取消的 selectionKey 对象集合</code>，如果该集合非空，就把该集合中的 selectionKey 对象从另外两个集合中移除，并注销相关的通道。该步骤结束后，<code>已取消的 selectionKey 对象集合</code> 应该是空的。</li>
<li>检查 <code>Set&lt;SelectionKey&gt;</code> 集合中所有 selectionKey 对象的 interset 集合，判断每个通道所关注的操作/事件是否已经就绪。</li>
<li>返回两次调用 <code>select()</code> 方法的时间间隔内进入就绪状态的通道的数量。</li>
</ol>
<p><strong>基本操作流程：</strong></p>
<p>通常使用以下方法来管理这些键：</p>
<ol>
<li>调用选择器对象的 select() 方法，如果就绪通道的数量大于 0，则执行下一步。</li>
<li>遍历 <code>selector.selectedkeys()</code> 方法的返回结果，得到所有已就绪的通道及通道中事件的数据：<ol>
<li>检查集合中的每个元素，查看相关通道的就绪信息，并进行处理；</li>
<li>处理完毕后，将 selectionKey 从  <code>Set&lt;SelectionKey&gt;</code> 集合中移除；</li>
<li>继续检查下一个元素。</li>
</ol>
</li>
</ol>
<p><strong>通用代码模板：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/25 16:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 服务端选择器模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerSelectorTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        serverSocketChannel.bind(address);</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 将serverSocketChannel的OP_ACCEPT事件注册到selector上</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 持续监听</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 接受连接</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// 读数据</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable())&#123;</span><br><span class="line">                    <span class="comment">// 写数据</span></span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 移除处理完的selectionKey</span></span><br><span class="line">                selectionKeys.remove(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="动力节点"><a href="#动力节点" class="headerlink" title="动力节点"></a>动力节点</h1><h2 id="JVM读取数据模型"><a href="#JVM读取数据模型" class="headerlink" title="JVM读取数据模型"></a>JVM读取数据模型</h2><p><img src="http://processon.com/chart_image/62a86862e0b34d294473999b.png"></p>
<p>假设现在的场景是一个Java程序从磁盘上读取数据。</p>
<p>任何程序都是运行在操作系统之上的，所以还会涉及到一个操作系统的内核空间，由操作系统内核来真正读取磁盘上的数据。在读取数据时，内核会启动一个磁盘控制器组件来读取磁盘上的数据到操作系统内核的缓冲区中。这个读取过程叫做DMA（Direct Memory Access）。</p>
<p>而我们的 Java 程序是从操作系统内核的缓冲区中读取的数据。把操作系统的缓冲区的数据读取到JVM的内存中。</p>
<p>这就是一个最简单的Java程序读取磁盘数据的模型。</p>
<p>对于目前的计算机，程序在读取数据的时候，CPU的处理速度往往不是程序运行效率的短板，CPU的处理速度非常快。更多的时候，程序运行的快慢是由I/O的效率决定的。</p>
<p>对于现代计算机的操作系统，它的IO性能已经发展的非常好了，操作系统可以快速的传输数据。</p>
<p>但对于JVM而言，它为了提供统一的操作环境，它对一些操作系统的强大的功能给屏蔽了，也就是说，由于JVM自身在IO方面的效率不足，导致了程序运行的效率变慢。在操作系统中，它可以从硬件上很快的读取数据到缓冲区，但是JVM的IO只能慢速地从缓冲区读取数据。</p>
<p>从JDK4开始，引入了NIO，在很大程序上提升了Java程序的IO效率。</p>
<p>主要有以下这些包：</p>
<ul>
<li>  <code>java.nio.*</code>：定义了各种与Buffer相关的API</li>
<li>  <code>java.nio.channel.*</code>：定义了与Channel和Selector相关的API</li>
<li>  <code>java.nio.charset.*</code>：定义了与字符集相关的API</li>
</ul>
<h2 id="NIO与传统IO的区别"><a href="#NIO与传统IO的区别" class="headerlink" title="NIO与传统IO的区别"></a>NIO与传统IO的区别</h2><p>传统的IO是面向流的，每次可以从流中读取一个或多个字节，只能向后读取，不能向前移动。</p>
<p>NIO是面向缓冲区的，把数据读到一个缓冲区中，可以在缓冲区中向前/向后移动，增加了程序的灵活性。</p>
<p>在NIO中，所有的数据都需要通过Channel传输，通道可以直接将一块数据映射到内存中。</p>
<p>Channel是双向的，不仅可以读取数据，还能保存数据。程序不能直接读写Channel通道，Channel只与Buffer缓冲区交互。</p>
<p>Java程序在读数据的时候，会先把数据源（比如操作系统中的缓冲区）上的数据读到Channel，通过Channel将数据传递到Buffer，Java程序是从Buffer中读取数据。</p>
<p><img src="http://processon.com/chart_image/62a87a9f1efad4656677a49d.png"></p>
<p>传统IO（IO流）是线程阻塞的。在调用 read()/write() 读写数据时，线程会阻塞，直到数据读/写完毕。在读写过程中，线程不能执行其它任务。</p>
<p>NIO是线程不阻塞的。当线程从Channel中读取数据时，如果通道中没有可用的数据，线程不会阻塞，可以继续做其它的任务。</p>
<hr>
<hr>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="1-Channel概述-1"><a href="#1-Channel概述-1" class="headerlink" title="1. Channel概述"></a>1. Channel概述</h2><p>Channel 是一种新的 I/O 的访问方式，用于在字节缓冲区与通道另一侧的实体(可以是文件也可以是 Socket)之间进行数据的传输。</p>
<p>Channel 可以双向读写数据，也可以实现异步读写。</p>
<p>程序不能直接访问 Channel，Channel 只能与 Buffer 缓冲区进行交互。即：在执行读操作时，需要先把通道中的数据读到 Buffer 缓冲区中，程序再从 Buffer 中读取数据；在执行写操作时，程序会先把数据写入 Buffer 缓冲区中，再把 Buffer 中的数据写到 Channel 中。</p>
<p>常用的 Channel 有：</p>
<ul>
<li>  FileChannel  读写文件的通道。</li>
<li>  DatagramChannel  通过UDP读写网络数据的通道。</li>
<li>  SocketChannel/ServerSocketChannel  读写Socket套接字中数据的通道。</li>
</ul>
<h2 id="2-Scatter-Gather"><a href="#2-Scatter-Gather" class="headerlink" title="2. Scatter/Gather"></a>2. Scatter/Gather</h2><p>有时候如果能从一个源填充到多个缓冲区，这会很有用。这称为**散布(Scatter)**。下面两个方法接收一个 ByteBuffer 数组作为参数，按顺序填充数组中的多个 ByteBuffer。</p>
<blockquote>
<p>所在类：interface ScatteringByteChannel</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">read</span><span class="params">(ByteBuffer[] dsts, <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>第一个方法填充所有缓冲区。第二个方法则从位于 offset 的缓冲区开始，填充 length 个缓冲区。</p>
<p>在填充缓冲数组时，常用的代码范式如下，只要列表中最后一个缓冲区还有剩余空间，就可以继续填充。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer[] buffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[<span class="number">2</span>];</span><br><span class="line">buffers[<span class="number">0</span>] =ByteBuffer.allocate(<span class="number">1000</span>);</span><br><span class="line">buffers[<span class="number">1</span>] =ByteBuffer.allocate(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">while</span> (buffers[<span class="number">1</span>].hasRemaining() &amp;&amp; channel.read(buffers) != -<span class="number">1</span>)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将多个缓冲区的数据写入到一个 Socket 通常很有用。这称为**聚集(Gather)**。例如，你可能希望在一个缓冲区存储 HTTP 首部，在另一个缓冲区存储 HTTP 主体。具体实现甚至可使用两个线程同时填充这两个缓冲区。下面两个方法接受一个 ByteBuffer 对象作为参数，并按顺序依次排空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">write</span><span class="params">(ByteBuffer[] srcs, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>第一个方法依次排空所有缓冲区。第二个方法则从位于 offset 的缓冲区开始，排空 length 个缓冲区。</p>
<p><strong>分散读，集中写</strong></p>
<p>Scatter(分散) 和 Gather(集中)是通道提供的一个重要功能。Scatter、Gather 是指在多个缓冲区中实现一个简单的 IO 操作(有时也被称为矢量 IO)。</p>
<p>Scatter 是指从 Channel 通道中读取数据，把这些数据按顺序分散写入到多个 Buffer 缓冲区中。</p>
<ul>
<li>  从 Channel 中读取数据，先把数组存储到 buffer1 缓冲区中；</li>
<li>  buffer1 缓冲区满了之后，再把通道中的数据写入到 buffer2，当 buffer2 也写满之后，最后把数据写到 buffer3 中。</li>
</ul>
<p><img src="http://processon.com/chart_image/62aef1cd1efad41af0432596.png"></p>
<p>Gather 是指在写操作时，将多个 Buffer 缓冲区中的数据写到同一个 Channel 中。</p>
<ul>
<li>  Gather 先把 buffer1 中的数据写到 Channel 中；</li>
<li>  再把 buffer2 中的数据写到 Channel 中；</li>
<li>  最后把 buffer3 中的数据写到 Channel 中。</li>
</ul>
<p><img src="http://processon.com/chart_image/62aef4d1e401fd5a4d73630a.png"></p>
<p>Scatter、Gather 经常用于需要将传输的数据分开的场景。</p>
<p>如 Scatter 从一个 Channel 中读取数据存储到多个 Buffer 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">ByteBuffer[] bufferArray = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1, buffer2, buffer3&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">channel.read(bufferArray); <span class="comment">// 从bufferArray中读取数据</span></span><br></pre></td></tr></table></figure>

<p>使用 read() 方法从 channel 中读取数据，将 channel 中的顺序按照 bufferArray 数组中 buffer 的顺序依次存储到缓冲区中。</p>
<p>注意：必须在 buffer1 缓冲区写满后才能写入 buffer2 缓冲区。</p>
<p>使用 Scatter/Gather 处理的数据大小都是固定的。</p>
<h2 id="3-FileChannel-1"><a href="#3-FileChannel-1" class="headerlink" title="3. FileChannel"></a>3. FileChannel</h2><p>FileChannel 可以通过 RandomAccessFile、FileInputStream 或 FileOutputStream 对象调用 <code>getChannel()</code> 方法获取。</p>
<p>FileChannel 虽然是双向的，既有 read() 方法又有 write() 方法。但是根据 FileInputStream 获得的通道是只读的，如果调用 write() 方法会产生异常。并且如果访问的文件是只读属性的，也不能执行 write() 写操作。</p>
<p>FileChannel 对象是线程安全的，不过并非所有的线程操作都是多线程的，影响通道位置或者影响文件大小的操作都是单线程的。即如果有一个线程在执行会影响通道位置的操作，那么其它尝试此类操作的线程需要等待。</p>
<h3 id="3-1-内存映射文件"><a href="#3-1-内存映射文件" class="headerlink" title="3.1 内存映射文件"></a>3.1 内存映射文件</h3><p>FileChannel 常用的三类方法：<code>map()</code>、<code>read()</code> 和 <code>write()</code>。</p>
<p>map() 方法会创建一个由磁盘文件支持的虚拟内存映射，并在这块虚拟内存空间上封装一个 MappedByteBuffer 对象。需要注意的是：为一个文件建立虚拟内存映射后，文件数据通常不会从硬盘读到内存。当然这并非是绝对的，这取决于操作系统。</p>
<p><code>read()/write()</code> 方法的作用是从 Buffer 中读写数据。</p>
<p>通过内存映射机制访问文件会比常规方法更高效，因为不需要做明确的系统调用，操作系统的虚拟内存可以自动缓存内存页，这些是使用系统内存缓存的，不会消耗 JVM 的堆内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存映射文件：</span></span><br><span class="line"><span class="comment"> *  即把磁盘上某个文件的数据映射到虚拟内存中，以这种方式访问文件数据的效率比较高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 把当前类文件(ChannelTest.java)以内存映射的方式读到 out.txt 文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件的 File 对象</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src/test/java/com/donglijiedian/buffer/ChannelTest.java&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 Channel 读取文件内容</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="comment">// 创建输出Channel，用于把文件把存到 out.txt 文件中</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>).getChannel();</span><br><span class="line">    <span class="comment">// 将 inChannel 中的数据映射到虚拟内存中</span></span><br><span class="line">    <span class="type">MappedByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, file.length());</span><br><span class="line">    <span class="comment">// 把缓冲区中的数据输出到 outChannel 中</span></span><br><span class="line">    outChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以把 buffer 中的内容打印出来</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> Charsets.UTF_8.decode(buffer);</span><br><span class="line">    System.out.println(charBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-2-FileChannel双向传输"><a href="#3-2-FileChannel双向传输" class="headerlink" title="3.2 FileChannel双向传输"></a>3.2 FileChannel双向传输</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-3-缓冲区设置固定大小"><a href="#3-3-缓冲区设置固定大小" class="headerlink" title="3.3 缓冲区设置固定大小"></a>3.3 缓冲区设置固定大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读写文件时，设置缓冲区为固定大小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 把 data.txt 文件的内容复制到 data_backup.txt 文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、磁盘(data.txt) -&gt; Channel -&gt; Buffer</span></span><br><span class="line">    <span class="comment">// 2、Buffer -&gt; Channel -&gt; 磁盘(data_backup.txt)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data_backup.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">srcChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">dstChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 srcChannel 中读数据写到 buffer 中</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> srcChannel.read(byteBuffer);</span><br><span class="line">    <span class="keyword">while</span> (readBytes != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 把 buffer 中的内容写到 dstChannel 中</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        dstChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">// 继续读 srcChannel 中的内容到 buffer 中</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        readBytes = srcChannel.read(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 dstChannel 到 data_backup.txt 的过程自动完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-Channel到Channel的传输"><a href="#3-4-Channel到Channel的传输" class="headerlink" title="3.4 Channel到Channel的传输"></a>3.4 Channel到Channel的传输</h3><p>如果经常需要将文件从一个位置传输到另一个位置，可以直接使用通道与通道之间的传输，而不需要中间缓冲区(Buffer)来传递数据。</p>
<p>Channel 到 Channel 间的传输是及其快速的，特别是在底层操作系统提供本地支持的时候，有的操作系统可以不经过用户空间而是直接使用内核空间传输数据。</p>
<blockquote>
<p>  <strong>注意：</strong></p>
<p>  只有 FileChannel 类有这两个方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通道与通道之间数据的传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  把 data.txt 复制到 data_backup.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data_backup.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 inChannel 从 0 开始的所有字节传输到 outChannel 中</span></span><br><span class="line">    <span class="comment">//inChannel.transferTo(0, file.length(), outChannel); // 等价表达</span></span><br><span class="line">    outChannel.transferFrom(inChannel, <span class="number">0</span>, file.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-Gather"><a href="#3-5-Gather" class="headerlink" title="3.5 Gather"></a>3.5 Gather</h3><h2 id="4-SocketChannel和ServerSocketChannel"><a href="#4-SocketChannel和ServerSocketChannel" class="headerlink" title="4. SocketChannel和ServerSocketChannel"></a>4. SocketChannel和ServerSocketChannel</h2><hr>
<h2 id="5-DatagramChannel"><a href="#5-DatagramChannel" class="headerlink" title="5. DatagramChannel"></a>5. DatagramChannel</h2><p>DatagramChannel 是对 UDP 无连接用户数据报协议的通道。</p>
<p><strong>DatagramChannelServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/22 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * UDP 没有所谓的客户端和服务器端，服务器和客户端在实现上没有什么区别，</span></span><br><span class="line"><span class="comment"> * 所以需要人为地给设置哪个机器是客户端，哪个机器是服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 模拟服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatagramChannelServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个初始通道(未绑定Socket)的通道</span></span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">datagramChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、初始化通道(绑定本地机器的IP和端口号)</span></span><br><span class="line">        datagramChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9090</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、设置为非阻塞模式</span></span><br><span class="line">        datagramChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器启动后，持续监听，等待客户端发送数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 接收客户端发送的数据，写到buffer中</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> (InetSocketAddress)datagramChannel.receive(buffer);</span><br><span class="line">            <span class="comment">// 如果没有客户端向服务器发送数据，address默认为null</span></span><br><span class="line">            <span class="comment">// 没有客户端发送数据</span></span><br><span class="line">            <span class="keyword">if</span> (address == <span class="literal">null</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有客户端发送数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端IP：&quot;</span> + address);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端端口号：&quot;</span> + address.getPort());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端发送的数据：&quot;</span> + Charsets.UTF_8.decode(buffer));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回数据给客户端</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">// arg1:发送给客户端的内容。  arg2：客户端地址</span></span><br><span class="line">            datagramChannel.send(Charsets.UTF_8.encode(content), address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/22 21:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *  DatagramChannel 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatagramChannelClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器IP和进程端口号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 datagramChannel，但无需初始化，由随机分配的端口号发送数据</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">serverAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT);</span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">datagramChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">        datagramChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(Charsets.UTF_8.encode(line));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 buffer 中的数据发送到服务器</span></span><br><span class="line">            buffer.flip();  <span class="comment">// 切换到读模式</span></span><br><span class="line">            datagramChannel.send(buffer, serverAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收服务器返回的数据</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">SocketAddress</span> <span class="variable">receive</span> <span class="operator">=</span> datagramChannel.receive(buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 receive=null 时，表示未接收到数据</span></span><br><span class="line">            <span class="keyword">while</span> (receive == <span class="literal">null</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;正在等待服务器端的响应结果......&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(Charsets.UTF_8.decode(buffer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-Pipe"><a href="#6-Pipe" class="headerlink" title="6. Pipe"></a>6. Pipe</h2><p>Pipe(管道)：用于在两个线程之间进行单向的数据传输。</p>
<p>数据传输过程如下图所示：</p>
<p>Pipe 由 Source 通道和一个 Sink 通道两部分组成。线程A负责把数据写到 Sink 通道中，线程B负责从 Source 通道中获取数据。在管道中完成数据从 Sink 通道到 Source 通道的传递。</p>
<p><img src="http://processon.com/chart_image/62b322b7e0b34d0712cdaa9a.png"></p>
<p><strong>Tip：</strong>Pipe 是一个管道，但是它有两个通道(Channel)。</p>
<blockquote>
<p><strong>Pipe 使用说明：</strong></p>
</blockquote>
<ol>
<li><p>创建 Pipe 实例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pipe</span> <span class="variable">pipe</span> <span class="operator">=</span> Pipe.open();</span><br></pre></td></tr></table></figure></li>
<li><p>向管道中写数据(向 sink 通道中写数据)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写数据首先要拿到 Sink 通道对象</span></span><br><span class="line">Pipe.<span class="type">SinkChannel</span> <span class="variable">sinkChannel</span> <span class="operator">=</span> pipe.sink();</span><br><span class="line"><span class="comment">// 将数据保存到 buffer 对象中</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charsets.UTF_8.encode(<span class="string">&quot;Hello Pipe&quot;</span>);</span><br><span class="line"><span class="comment">// 向 sink 通道中写数据</span></span><br><span class="line">sinkChannel.write(buffer);</span><br></pre></td></tr></table></figure></li>
<li><p>从管道中读数据(从 source 通道中读数据)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读数据首先要拿到 source 通道对象</span></span><br><span class="line">Pipe.<span class="type">SourceChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> pipe.source();</span><br><span class="line">buffer.flip(); <span class="comment">// 切换为读模式</span></span><br><span class="line"><span class="comment">// 从 source 通道中读数据</span></span><br><span class="line">sourceChannel.read(buffer);</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Pipe;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/22 22:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 演示在两个线程之间通过 Pipe 管道实现数据的传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.io.PipedOutputStream&#125; 和 &#123;<span class="doctag">@link</span> java.io.PipedInputStream&#125;</span></span><br><span class="line"><span class="comment"> * 分别是管道输出流类和管道输入流类。</span></span><br><span class="line"><span class="comment"> * 在管道通信时，线程A向 &#123;<span class="doctag">@link</span> java.io.PipedOutputStream&#125; 中写入数据，这些数据会</span></span><br><span class="line"><span class="comment"> * 自动发送到对应的 &#123;<span class="doctag">@link</span> java.io.PipedInputStream&#125; 中，线程B就可以从 &#123;<span class="doctag">@link</span> java.io.PipedInputStream&#125;</span></span><br><span class="line"><span class="comment"> * 中读取数据，从而实现线程A到线程B的数据传输。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 输入流对象和输出流对象</span></span><br><span class="line">        <span class="type">PipedInputStream</span> <span class="variable">pipedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedInputStream</span>();</span><br><span class="line">        <span class="type">PipedOutputStream</span> <span class="variable">pipedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedOutputStream</span>();</span><br><span class="line">        <span class="comment">// 在输入流对象和输出流对象之间建立连接[重要]</span></span><br><span class="line">        pipedInputStream.connect(pipedOutputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程</span></span><br><span class="line">        <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>(pipedOutputStream);</span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>(pipedInputStream);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sender).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(receiver).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送数据的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedOutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sender</span><span class="params">(PipedOutputStream outputStream)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.outputStream = outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟发送数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello, sender：&quot;</span> + i + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">                <span class="comment">// 将字符串数据写到outputStream流中</span></span><br><span class="line">                outputStream.write(text.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收数据的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PipedInputStream inputStream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Receiver</span><span class="params">(PipedInputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inputStream = inputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">                len = inputStream.read(bytes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<hr>
<h1 id="咕泡教育"><a href="#咕泡教育" class="headerlink" title="咕泡教育"></a>咕泡教育</h1><h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2. ByteBuffer"></a>2. ByteBuffer</h2><h3 id="2-3-Buffer常见方法"><a href="#2-3-Buffer常见方法" class="headerlink" title="2.3 Buffer常见方法"></a>2.3 Buffer常见方法</h3><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>可以使用 allocate() 方法为 ByteBuffer 分配空间，其它 XxxBuffer 类也有类似的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  在 NIO 中，buffer 空间的大小，一经分配，就不能再发生改变。而在 Netty 中对这一点做了增强，Netty 支持对 buffer 的大小进行后修改。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testByteBufferAllocate</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(ByteBuffer.allocate(<span class="number">16</span>).getClass()); <span class="comment">//class java.nio.HeapByteBuffer</span></span><br><span class="line">    System.out.println(ByteBuffer.allocateDirect(<span class="number">16</span>).getClass()); <span class="comment">//class java.nio.DirectByteBuffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        class java.nio.HeapByteBuffer</span></span><br><span class="line"><span class="comment">            - Buffer空间使用的是JVM的堆内存。</span></span><br><span class="line"><span class="comment">            - 与操作系统的直接内存相比，堆内存的读写效率较低。</span></span><br><span class="line"><span class="comment">            - 堆内存空间会受到GC的影响。（可能会在GC时发生数据的移动，降低效率）</span></span><br><span class="line"><span class="comment">       **********************************************************</span></span><br><span class="line"><span class="comment">        class java.nio.DirectByteBuffer</span></span><br><span class="line"><span class="comment">            - Buffer空间使用的是直接内存。</span></span><br><span class="line"><span class="comment">            - 直接内存的读写效率较高。因为它相比于JVM堆内存少一次数据的拷贝。</span></span><br><span class="line"><span class="comment">            - 使用的是系统内存，不会受到GC的影响。</span></span><br><span class="line"><span class="comment">            - 缺点：</span></span><br><span class="line"><span class="comment">                - 需要调用操作系统来分配内存，分配时的效率较低。</span></span><br><span class="line"><span class="comment">                - 如果使用不当，可能会造成内存泄露。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="向Buffer中写入数据"><a href="#向Buffer中写入数据" class="headerlink" title="向Buffer中写入数据"></a>向Buffer中写入数据</h4><p>有两种方法。</p>
<ol>
<li><p>调用 channel 的 read() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取channel中的数据，写到buffer中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>

</li>
<li><p>调用 buffer 自己的 put() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.put((<span class="type">byte</span>) <span class="number">127</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h4><p>同样有两种办法。</p>
<ol>
<li><p>调用 channel 的 write() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将buffer中的数据写到channel中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buffer);</span><br></pre></td></tr></table></figure></li>
<li><p>调用 buffer 自己的 get() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buffer.get();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get() 方法会让 position 指针向后走，如果想重复读取数据</p>
<ul>
<li>  可以调用 rewind() 方法将 position 重新置为 0。</li>
<li>  或者调用 get(int index) 获取索引 index 的内容，它不会移动指针。</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_rewind_and_getX</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    buffer.flip(); <span class="comment">// buffer的初始模式为写模式，如需读取数据需要切换为读模式</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//1</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//2</span></span><br><span class="line">    buffer.rewind();</span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//1</span></span><br><span class="line">    System.out.println(buffer.get(<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="mark-amp-reset"><a href="#mark-amp-reset" class="headerlink" title="mark &amp; reset"></a>mark &amp; reset</h4><ul>
<li>  mark：做一个标记，记录 position 的位置</li>
<li>  reset：将 position 重置到 mark 的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_mark_and_reset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//1</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//2</span></span><br><span class="line">    buffer.mark(); <span class="comment">//加标记</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//3</span></span><br><span class="line">    buffer.reset(); <span class="comment">//回到标记</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//3</span></span><br><span class="line">    buffer.reset();</span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h4><p><strong>字符串–&gt;ByteBuffer</strong></p>
<ol>
<li><p>手动分配buffer，手动将字符串转为字节数据，并添加到buffer中</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、字符串 --&gt; ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">buffer1.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li>
<li><p>Charset</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、Charset</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>wrap()</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、wrap()</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>  <strong>Tip</strong></p>
<p>  方式二和方式三在完成字符串到ByteBuffer的转换后，会自动将当前模式切换到读模式，在读模式下可以直接读取Buffer中的数据。而在方式一中，必须手动切换为读模式才能正常读到Buffer中的数据。</p>
</blockquote>
<p><strong>ByteBuffer –&gt; 字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StandardCharsets</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(buffer2).toString();</span><br><span class="line">System.out.println(string); <span class="comment">//hello</span></span><br></pre></td></tr></table></figure>





<h3 id="2-4-Scattering-Reads"><a href="#2-4-Scattering-Reads" class="headerlink" title="2.4 Scattering Reads"></a>2.4 Scattering Reads</h3><blockquote>
<p>  <strong>分散读，集中写</strong></p>
</blockquote>
<p>分散读取。</p>
<p><strong>需求：</strong>已知一个文本文件 3parts.txt。文件的三部分分别是3、3、5个字节。需要将这个文件读取到Buffer中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onetwothree</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>  思路一：将这三部分的内容（3+3+5=11字节）全部读到一个 ByteBuffer 中，之后再利用其它手段将ByteBuffer拆分为三部分。</li>
<li>  思路二：在读取的时候按照 3/3/5 字节将这个文件中的内容读取到三个 ByteBuffer 中。这种方式就叫做 Scattering Reads（分散读）</li>
</ul>
<p><strong>演示：</strong></p>
<p>使用如下方式读取，可以将数据填充到三个Buffer中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分散读（测试用例）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScatteringReads</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src/main/resources/3parts.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 从channel中读数据写到多个buffer中</span></span><br><span class="line">    channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">    <span class="comment">// 尝试打印查看buffer中是否已经写入了数据</span></span><br><span class="line">    buffer1.flip();</span><br><span class="line">    buffer2.flip();</span><br><span class="line">    buffer3.flip();</span><br><span class="line">    System.out.println((<span class="type">char</span>) buffer1.get(<span class="number">0</span>)); <span class="comment">//o</span></span><br><span class="line">    System.out.println((<span class="type">char</span>) buffer2.get(<span class="number">0</span>)); <span class="comment">//t</span></span><br><span class="line">    System.out.println((<span class="type">char</span>) buffer3.get(<span class="number">1</span>)); <span class="comment">//h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-5-Gathering-Writes"><a href="#2-5-Gathering-Writes" class="headerlink" title="2.5 Gathering Writes"></a>2.5 Gathering Writes</h3><p>集中写</p>
<p><strong>需求：</strong>已有 3 个 ByteBuffer，先需将这 3 个 ByteBuffer 写入到一个文件中。</p>
<p><strong>思路：</strong></p>
<ul>
<li>  思路一：先将这 3 个 ByteBuffer 组合成一个更大的 ByteBuffer，再将大的 ByteBuffer 写入到文件中。</li>
<li>  思路二：按照一定的顺序分别将这 3 个 ByteBuffer 写到同一个文件中（追加写）。</li>
</ul>
<p><strong>演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集中写（测试用例）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGatheringWrites</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;am&quot;</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;are&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;3parts2.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    channel.write(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结束后，查看文件可以看到数据已经写入。</p>
<hr>
<h2 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3. 文件编程"></a>3. 文件编程</h2><h3 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h3><blockquote>
<p>  <strong>注意</strong></p>
<p>  FileChannel 只能工作在阻塞模式下，不能配合 Selector 使用。只有网络编程中的 Channel，如 SocketChannel 等才能配合 Selector 工作在非阻塞模式下。</p>
</blockquote>
<p><strong>获取：</strong></p>
<p>FileChannel 不能直接创建，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 <strong>getChannel()</strong> 方法。</p>
<ul>
<li>  通过 FileInputStream 获取的 Channel 只能读；</li>
<li>  通过 FileOutputStream 获取的 Channel 只能写；</li>
<li>  通过 RandomAccessFile 获取的 Channel 的读写权限根据构造 RandomAccessFile 时的读写模式决定。</li>
</ul>
<p><strong>读取：</strong></p>
<p>读取 channel 中的数据写入到 buffer 中。返回值表示读取到了多少字节，<code>-1</code> 表示读取到了文件的末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>



<p><strong>写入：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ...;</span><br><span class="line">buffer.put(...); <span class="comment">//存入数据</span></span><br><span class="line">buffer.flip(); <span class="comment">//切换到读模式</span></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 while 中调用 channel.write() 方法时因为 write() 方法不能保证一次将 buffer 中的内容全部写入 channel 中。</p>
<p><strong>关闭：</strong></p>
<p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close() 方法会间接地调用 channel 的 close() 方法。</p>
<p><strong>位置：</strong></p>
<ul>
<li><p>获取当前位置</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();</span><br></pre></td></tr></table></figure></li>
<li><p>设置当前位置</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">newPos</span> <span class="operator">=</span> ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></table></figure>

<ul>
<li>设置当前位置时，如果设置为文件的末尾：<ul>
<li>  这时读会返回 <code>-1</code>；</li>
<li>  这时写入，会追加内容。但要注意，如果 position 超过了文件末尾，在执行写入时新内容和原末尾之间会用 0 填充。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>大小：</strong></p>
<p>使用 size 方法获取文件的大小。</p>
<p><strong>强制写入</strong></p>
<p>操作系统出于性能的考虑，会先将数据写入操作系统的缓存中，而不是立刻写入磁盘。但是可以调用 force(true) 方法将文件内容和元数据(文件的权限等信息)立刻写入磁盘。</p>
<hr>
<h3 id="3-2-两个Channel间传输数据"><a href="#3-2-两个Channel间传输数据" class="headerlink" title="3.2 两个Channel间传输数据"></a>3.2 两个Channel间传输数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个channel之间数据的传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_fileChannelTransferTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;b.txt&quot;</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">    <span class="comment">// 效率高，底层会利用操作系统的“零拷贝”进行优化</span></span><br><span class="line">    <span class="comment">// transferTo 方法每次传输的数据不能大于2G，超过2G的内容将被丢弃</span></span><br><span class="line">    from.transferTo(<span class="number">0</span>, from.size(), to);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    log.info(<span class="string">&quot;transferTo 用时&#123;&#125;秒&quot;</span>, (end-start)/<span class="number">1000_000.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-3-Path"><a href="#3-3-Path" class="headerlink" title="3.3 Path"></a>3.3 Path</h3><p>JDK7 引入了 Path 和 Paths 类。</p>
<ul>
<li>  Path 用来表示文件/目录。</li>
<li>  Paths 是工具类，用来获取 Path 实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\1.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">source3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:/1.txt&quot;</span>); <span class="comment">//另一种等价写法</span></span><br><span class="line"><span class="comment">// 目录+文件名</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source4</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>);</span><br><span class="line"><span class="comment">// 获取网络资源</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source5</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;http://processon.com/chart_image/62a885837d9c082d0b2cb18d.png&quot;</span>);</span><br></pre></td></tr></table></figure>





<h3 id="3-4-Files"><a href="#3-4-Files" class="headerlink" title="3.4 Files"></a>3.4 Files</h3><p>检查文件/目录是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> Files.exists(path);</span><br></pre></td></tr></table></figure>



<p>创建一级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> ...;</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果目录已存在，会抛出 FileAlreadyExistsException 异常</li>
<li>  不能一次创建多级目录，否则会抛出 NoSuchFileException 异常。</li>
</ul>
<p>创建多级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> ...;</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>



<p>拷贝文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  如果目标文件已存在，会抛出 FileAlreadyExistsException 异常</p>
</li>
<li><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>移动文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>

<ul>
<li>  StandardCopyOption.ATOMIC_MOVE 用来保证文件移动时的原子性。</li>
</ul>
<p><strong>删除文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果文件不存在，会抛出 NoSuchFileException 异常。</li>
</ul>
<p><strong>删除目录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/a/b&quot;</span>);</span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果目录中还有内容，会抛出 DirectoryNotEmptyException 异常。</li>
</ul>
<p><strong>遍历目录中的文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历目录中的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilesWalkFileTree</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Software\\Dev\\Java\\jdk1.8.0_162&quot;</span>);</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Files.walkFileTree(source, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====&quot;</span> + dir);</span><br><span class="line">            dirCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;dir count&quot;</span> + dirCount);</span><br><span class="line">    System.out.println(<span class="string">&quot;file count&quot;</span> + fileCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>查看目录下的所有 jar 包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看目录下的所有jar包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilesWalkFileTreeExt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Software\\Dev\\Java\\jdk1.8.0_162&quot;</span>);</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">jarFileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Files.walkFileTree(source, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.toString().endsWith(<span class="string">&quot;.jar&quot;</span>))&#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                jarFileCount.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;file count：&quot;</span> + jarFileCount);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>使用 walkFileTree 实现删除多级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 walkFileTree 实现删除多级目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestWalkFileTreeDel</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\study\\http_study - 副本&quot;</span>);</span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====&gt; 进入&#123; &quot;</span> + dir + <span class="string">&quot; &#125;目录&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="comment">// 删除文件</span></span><br><span class="line">            Files.delete(file);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;==== 退出&#123; &quot;</span> + dir + <span class="string">&quot; &#125;目录&quot;</span>);</span><br><span class="line">            <span class="comment">// 删除目录</span></span><br><span class="line">            Files.delete(dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 walkFileTree 实现递归文件夹的拷贝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 walkFileTree 实现递归文件夹的拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWalkFileTreeCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\study\\http_study&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\study\\http_study - 副本&quot;</span>);</span><br><span class="line">    Files.walkFileTree(source, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====&gt; 进入&#123; &quot;</span> + dir + <span class="string">&quot; &#125;目录&quot;</span>);</span><br><span class="line">            <span class="comment">// 拷贝外层文件夹（文件夹需要创建，文件才需要拷贝）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> dir.toString().replace(source.toString(), target.toString());</span><br><span class="line">            Files.createDirectory(Paths.get(targetName));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="comment">// 拷贝内层文件</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> file.toString().replace(source.toString(), target.toString());</span><br><span class="line">            Files.copy(file, Paths.get(targetName));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4-网络编程（重点）"><a href="#4-网络编程（重点）" class="headerlink" title="4. 网络编程（重点）"></a>4. 网络编程（重点）</h2><h3 id="4-1-非阻塞-vs-阻塞"><a href="#4-1-非阻塞-vs-阻塞" class="headerlink" title="4.1 非阻塞 vs. 阻塞"></a>4.1 非阻塞 vs. 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>  在没有数据可读，或数据复制过程中，线程必须阻塞等待。不会占用CPU，但线程相当于闲置。</li>
<li>  32位JVM一个线程320K，64位JVM一个线程1024K。为了减少线程数，需要采用线程池技术。</li>
<li>  但即使使用了线程池，如果有很多连接建立，长时间的 inactive，会阻塞线程池中的所有线程。</li>
</ul>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>  在某个 Channel 没有可读事件时，线程不必阻塞，它可以去处理其它有可读事件的 Channel。</li>
<li>  但是在数据复制过程中，线程实际还是阻塞的（AIO改进的地方）</li>
<li>  写数据时，线程只是等待数据写入 Channel 中即可，无需等待 Channel 通过网络把数据发送出去。</li>
</ul>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>线程必须配合 Selector 才能完成对多个 Channel 可读事件的监控，这称之为多路复用。</p>
<ul>
<li>  多路复用仅针对网路IO，普通文件IO无法利用多路复用。</li>
<li>  如果不用 Selector 多路复用，那么 Channel 读取到的字节很多时候都是 0，而 Selector 保证了有可读事件才去读取。</li>
<li>  Channel 输入的数据一旦准备好，就会触发 Selector 的可读事件。</li>
</ul>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p><strong>BIO 执行流程</strong></p>
<ol>
<li> 服务器启动；</li>
<li> 客户端通过 Socket 向服务器发起通信，默认情况下服务器端会为每一个请求建立一个线程与之通讯；</li>
<li> 客户端发出请求后，会先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝；</li>
<li> 如果有响应，客户端线程会等待请求结束后，再执行其它操作。在请求未结束前，不允许执行其它操作，即会陷入阻塞。</li>
</ol>
<p>进程是不能直接发送网络包的，需要调用系统调用将数据复制到内核，内核使用网卡驱动程序进行发送。</p>
<p>服务器的实现模式为一个线程处理多个请求（连接），客户端发送的请求都会被注册到多路复用器（Selector）上，多路复用器轮询到连接有 IO 请求时就处理，没有则继续轮询。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/07/volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/07/volatile/" class="post-title-link" itemprop="url">volatile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-07 16:28:28" itemprop="dateCreated datePublished" datetime="2021-08-07T16:28:28+08:00">2021-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-08 11:08:26" itemprop="dateModified" datetime="2021-08-08T11:08:26+08:00">2021-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1    前置知识"></a>1    前置知识</h1><p>在 Java 内存模型中，我们知道了 JMM 有一个主内存，每个线程有自己的私有工作内存，工作内存中保存了一些变量在主内存的拷贝。</p>
<blockquote>
<p>  <strong>内存可见性：</strong></p>
</blockquote>
<p>指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。</p>
<blockquote>
<p>  <strong>重排序</strong></p>
</blockquote>
<p>为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。</p>
<hr>
<h1 id="2-Volatile-概述"><a href="#2-Volatile-概述" class="headerlink" title="2    Volatile 概述"></a>2    Volatile 概述</h1><ol>
<li> volatile 是 Java 提供的轻量级的同步机制（乞丐版的 syschorcize）</li>
<li>volatile <strong>三大特性</strong><ul>
<li>  保证变量的<strong>内存可见性</strong></li>
<li>  <strong>禁止 volatile 变量与普通变量重排序</strong></li>
<li>  不保证原子性</li>
</ul>
</li>
</ol>
<h1 id="3-内存可见性"><a href="#3-内存可见性" class="headerlink" title="3    内存可见性"></a>3    内存可见性</h1><ul>
<li>  可见性是指当一个线程运行时能感知到另一个线程对共享变量做出的改变。</li>
</ul>
<h2 id="3-1-验证普通变量之间的内存不可见性"><a href="#3-1-验证普通变量之间的内存不可见性" class="headerlink" title="3.1    验证普通变量之间的内存不可见性"></a>3.1    验证普通变量之间的内存不可见性</h2><ul>
<li>  如果两个线程不是同时执行的，而是先后执行，因为每次本地内存中对共享变量的改变都会写回到主内存中，另一个线程接着再取出来的是更改过的共享变量。这就相当于是一个单线程了。</li>
<li>  简单点就是说，A、B两个线程并发执行，B 线程正在用着 num，并且可能还要继续用一段时间，这时候线程 A 修改了 num 的值，B线程马上就知道了，这叫做线程间变量的可见性。（用着用着 num 突然变了）  </li>
<li>  而 A、B 两个线程先后被创建，然后开始并发执行，如果B线程在创建之前A线程就已经修改完 num 的值并将其写回主内存了，那么B线程得到的 num 变量的副本自然也是被 A 线程修改后的 num。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VisibleDemo</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag == <span class="literal">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">VisibleDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VisibleDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            	<span class="comment">// Thread.sleep(100);</span></span><br><span class="line">                demo.method1();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            demo.method2();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  我们来分析一下这段代码，线程 A 调用了 <code>method1()</code>，线程 B 调用了 <code>method2()</code>，线程A 和线程B 并发执行。</li>
<li>  我们想象中的是由于 flag 没有使用 volatile 修饰，那么在线程 A 中对 flag 的改变线程B 不能感知到，那么线程B 自然就会进入到死循环中了，导致 JVM 进程不能结束。</li>
<li>  但程序的真实结果是线程B执行了，即知道了 flag 的改变，死循环不会执行，而是会执行输出语句。这是为什么呢？难道不加 volatile 也能保证可见性吗？其实不是的。</li>
<li>  由于我们上面这段代码非常简单，在 main 方法中有创建 A、B 两个线程的操作，先创建A，再创建B。但是由于A线程执行的时间太短了，所以在线程B执行之前A线程已经执行完了 <code>method1()</code> 方法，并且把修改后的 flag 重写回了主内存。这时B线程才去执行 <code>run()</code>，所以B线程创建时从主内存中复制过去的变量 flag 已经是修改过的值了，即<code>flag==true</code>，所以自然不会进入死循环了。</li>
<li>  如果想要验证不加 volatile 就不具备可见性，可以让线程 A 先睡眠 100ms，让线程B先执行 method2 方法进入死循环，再让线程A去修改 flag 的值，发现程序不能结束，这也就验证了此时线程间确实是不具备可见性的。</li>
</ul>
<hr>
<h2 id="3-2-验证-volatile-能保证可见性"><a href="#3-2-验证-volatile-能保证可见性" class="headerlink" title="3.2    验证 volatile 能保证可见性"></a>3.2    验证 volatile 能保证可见性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/*volatile*/</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// child线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========End of Child Thread&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Child&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;turn flag off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面这段代码在运行时，存在两个线程 child 和 main，一个保存在主内存中的变量 flag。</p>
<ol>
<li>由于 main 线程在创建子线程后会睡眠100ms，所以 child 线程开始执行，检测到 <code>flag == true</code>，child 线程进入死循环中。</li>
<li>mian 线程在睡醒后继续执行，修改 <code>flag=false</code>并在控制台上输出指定内容，然后主线程结束。</li>
<li>但这是我们会发现程序并没有结束，因为 child 线程仍处于死循环状态。也就是说<strong>main 线程修改全局变量 flag=false ，并不能被 child 线程感知到</strong>。</li>
</ol>
<p><img src="/2021/08/07/volatile/image-20210506143613131.png" alt="image-20210506143613131"></p>
<p>但是如果我们将 <strong>volatile</strong> 关键字的注释打开，代码的执行流程就变成了：</p>
<ol>
<li>child 线程开始执行，检测到 <code>flag == true</code>，进入死循环中。</li>
<li>mian 线程在睡醒后继续执行，修改 <code>flag = false</code>并在控制台上输出指定内容，然后主线程结束。</li>
<li>但是此时 child 线程监听了到主线程对于 flag 变量的修改，即在 child 线程的感知中 <code>flag == false</code> 了，所以 child 线程退出死循环，在控制台上打印指定内容，child 线程结束。</li>
<li>整个 JVM 进程结束。</li>
</ol>
<p><img src="/2021/08/07/volatile/image-20210506143757319.png" alt="image-20210506143757319"></p>
<p><strong>总结：</strong></p>
<p>上面的代码可以证明：<strong>volatile 关键字可以保证多个线程之间共享变量的可见性</strong>。即共享变量在某个线程中的本地内存中发生了变化，其它的线程也可以监听到这种变化！当然这种<strong>监听的底层原理还是通过主内存作为传输纽带进行交互的</strong>，即单个线程在本地内存中对共享变量的操作最终还是要写回到主内存中，再由主内存将这种变化通知到其它所有使用这个共享变量的线程。</p>
<hr>
<h1 id="4-不保证原子性"><a href="#4-不保证原子性" class="headerlink" title="4    不保证原子性"></a>4    不保证原子性</h1><blockquote>
<p>  <strong>代码验证</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  验证 volatile 不保证原子性</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *      新建20个线程，每个线程都调用1000次 autoIncrement() 方法对共享变量num进行自增的操作，</span></span><br><span class="line"><span class="comment"> *      让 main 线程休眠一段时间直到这20个新建的线程执行完毕后再查看堆内存中num的值，在无错的情况下，</span></span><br><span class="line"><span class="comment"> *      num 的值应该是 0+20*1000=20000</span></span><br><span class="line"><span class="comment"> *      但是实际情况确实，大多数情况下这个值都小于20000，且值不确定。这说明了volatile并不能保证原子性，</span></span><br><span class="line"><span class="comment"> *      即 volatile 并不能保证线程安全。在某个线程执行的时候，可能会被其它线程加塞。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.autoIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(myData.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">     <span class="comment">/*  此时 num 前面是加了 volatile 关键字修饰的，但是 volatile 并不能保证变量的原子性   */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoIncrement</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>为什么说 volatile 不能保证原子性？</strong></p>
</blockquote>
<p>因为在 <code>MyData#autoIncrement()</code> 方法中，可能存在多个线程同时执行了 num++ 操作。</p>
<p><strong>num++</strong> 这一行代码的实际操作可分为三个步骤：<code>读 --&gt; 改 --&gt; 写</code></p>
<ol>
<li> 读：首先从主内存中拿到 num 的值，复制一份到自己的工作内存中；[<code>getfield #2 &lt;com/juc/day01/Test.n&gt;</code>]</li>
<li> 改：在自己的工作内存中对 num 进行自增操作；[<code>iadd</code>]</li>
<li> 写：将更改后的 num 写回到主内存中去。[<code>putfield #2 &lt;com/juc/day01/Test.n&gt;</code>]</li>
</ol>
<p><img src="/2021/08/07/volatile/image-20210709105405172.png" alt="image-20210709105405172"></p>
<p>原子性就是对 num 的操作，即 “读 –&gt; 改 –&gt; 写” 这三个步骤是不可分割的，而 volatile 不能保证原子性。</p>
<p>​        在保证原子性的情况下 num++ 的执行流程应该是：假设线程 A、B、C 并发执行，线程 A 拿到了 num=0，复制副本后在自己的工作空间中将其更新为 num=1，然后再将其写回到主内存中。这时候其它线程再去对 num 进行操作，这是一个完整的具备原子性的操作流程。</p>
<p>​        而在不能保证原子性的情况下则会出现，线程 A、B、C 同时拿到了主内存中的值 num=0，并在各自的内存空间将 num 更新为 1。接下来三个线程需要将更新后的值写回主内存中，假设 A 先写回主内存，主内存中的共享变量改变后需要通知其它线程，但是在这个通知还未发送到 B、C 线程的时候，B、C 线程就已经把写回主内存的操作都做完了，那么此时主内存中的值仍然会是 1，最后一个写入到主内存的 1 会覆盖前面两个写入到主内存的 1。而我们知道实际的运算结果本应该是 3。所以说在不能保证原子性的前提下，上述代码执行的结果大概率会小于 20000。</p>
<blockquote>
<p>  <strong>如何解决 volatile 不能保证原子性的问题？</strong></p>
</blockquote>
<ol>
<li> 使用 synchronized 关键字加锁（可以解决，但的锁太重）</li>
<li> 使用 JUC 包下的 AtomicInteger</li>
</ol>
<p>查看 JavaDoc 可知，在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html">java.util.concurrent.atomic</a> 包下包含了一系列的能保证原子性的数据类型。我们可以<strong>在使用 volatile 的基础上再使用 AtomicXXX 类型的对象就能保证多线程操作数据的可见性和原子性并存，并且不用添加重锁</strong>。</p>
<img src="/2021/08/07/volatile/image-20210709112717007.png" alt="image-20210709112717007" style="zoom:80%;">



<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html">AtomicInteger</a> 的构造方法<ul>
<li>  AtomicInteger 其实就是对 Integer 的又一层包装，二者最大的区别就是 Integer 不能保证原子性，但 AtomicInteger 可以。</li>
<li>  默认的无参构造函数会初始化一个满足原子性的值为 0 的 int 类型数据</li>
<li>  带参的构造函数可以自己指定初始化值。</li>
</ul>
</li>
</ul>
<p><img src="/2021/08/07/volatile/image-20210709113136165.png" alt="image-20210709113136165"></p>
<ul>
<li>  <strong>代码修改</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.autoIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(myData.num);		<span class="comment">// 此时输出结果必定为 20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoIncrement</span><span class="params">()</span>&#123;</span><br><span class="line">        num.getAndIncrement();   <span class="comment">// 等价于 num++;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>AtomicInteger#getAndIncrement() 方法源码</strong></p>
</blockquote>
<img src="/2021/08/07/volatile/image-20210709113659357.png" alt="image-20210709113659357" style="zoom:80%;">





<hr>
<h1 id="5-有序性（指令重排）"><a href="#5-有序性（指令重排）" class="headerlink" title="5    有序性（指令重排）"></a>5    有序性（指令重排）</h1><h2 id="为什么要禁止指令重排？"><a href="#为什么要禁止指令重排？" class="headerlink" title="为什么要禁止指令重排？"></a>为什么要禁止指令重排？</h2><p>在多线程程序中，如果发生了指令重排，可能会导致程序的执行结果每次都是不确定的。即线程不安全。</p>
<hr>
<h2 id="指令重排是什么？"><a href="#指令重排是什么？" class="headerlink" title="指令重排是什么？"></a>指令重排是什么？</h2><p>计算机在执行程序时，为了提高性能，编译器和处理器往往会<strong>对指令进行重排</strong>。</p>
<p>指令重排造成的结果是：程序员写的代码的执行的顺序与代码真正在底层执行的顺序是有偏差的。</p>
<p><img src="/2021/08/07/volatile/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png" alt="指令重排"></p>
<ul>
<li>  多线程环境中线程交替执行，由于指令优化重排的存在，多个线程中使用的变量能否保证一致性是无法确定的，程序执行的结果也就无法预测了。</li>
<li>  处理器在进行指令重排时必须要考虑指令之间的<strong>数据依赖性</strong>。（也就是说指令重排必须是在满足数据依赖性的基础上进行的）</li>
</ul>
<hr>
<h2 id="指令重排演示"><a href="#指令重排演示" class="headerlink" title="指令重排演示"></a>指令重排演示</h2><h3 id="指令重排案例1：数据依赖性"><a href="#指令重排案例1：数据依赖性" class="headerlink" title="指令重排案例1：数据依赖性"></a>指令重排案例1：数据依赖性</h3><p>​        程序进行指令重排的前提是一定要满足数据依赖性，那么什么是数据依赖性呢？很简单的一个例子就是，想要吃苹果就必须得先有苹果，在程序中就是想要使用变量 num 就必须先声明这个变量 num。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;	<span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">4</span>;	<span class="comment">// 2</span></span><br><span class="line">x = x + <span class="number">7</span>;	<span class="comment">// 3</span></span><br><span class="line">y = y + <span class="number">8</span>;	<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>​        在上面的程序中，源代码设计的执行顺序是 <code>1234</code>，但是如果发生了指令重排，它就有可能变成 <code>2143</code>、<code>1324</code>，这都是 OK 的，但是能不能变成 <code>4321</code> 呢？答案是不可以的，因为第3、4条语句对应的指令是需要依赖于 1、2条语句指令创建的变量的，这就是最简单的数据依赖性。</p>
<h3 id="指令重排案例2：数据间无依赖性"><a href="#指令重排案例2：数据间无依赖性" class="headerlink" title="指令重排案例2：数据间无依赖性"></a>指令重排案例2：数据间无依赖性</h3><ol>
<li> 在两个线程的程序中，源代码中设计的程序执行顺序为：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,x,y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 在声明完4个变量a，b，x，y 后，这4个变量之间无依赖性，执行顺序可以任意组合</span></span><br><span class="line">x = a;</span><br><span class="line">y = b;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">这段代码在执行结束后，x 和 y 的结果应该为：x=<span class="number">0</span>, y=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 但是如果编译器对这段程序代码执行指令重排优化后，可能会出现执行顺序变为：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line">x = a;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line">y = b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这段代码在执行结束后，x 和 y 的结果应该为：x=<span class="number">2</span>, y=<span class="number">1</span></span><br></pre></td></tr></table></figure>





<h3 id="指令重排案例3"><a href="#指令重排案例3" class="headerlink" title="指令重排案例3"></a>指令重排案例3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReSortDemo</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        num = <span class="number">1</span>;	<span class="comment">// 语句1</span></span><br><span class="line">        flag = <span class="literal">true</span>;	<span class="comment">// 语句2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            num = num + <span class="number">5</span>;	<span class="comment">// 语句3</span></span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设现在有两个线程 A、B 并发执行 method1 和 method2 方法。</p>
<blockquote>
<p>  <strong>未发生指令重排：</strong></p>
</blockquote>
<p>假设线程 A 先执行 <code>method1()</code>，更新 num 和 flag 的值，线程 B 再执行，执行 <code>num = num + 5;</code>，最终 num 的值为 6，<strong>输出的结果为 6</strong>。</p>
<blockquote>
<p>  <strong>发生指令重排：</strong></p>
</blockquote>
<p>发生指令重排后，假设语句1和语句2在重排后执行顺序发生了交换，线程A先执行 <code>flag=true</code>，紧接着又切换到线程B 执行 <code>num=num+5</code>，但此时 num == 0，因此线程 B <strong>输出的结果变成了 5</strong>，并且最后还是会执行语句1让<code>num = 1;</code>。可以看到发生指令重排后程序的运行结果每次可能不一样。</p>
<hr>
<h2 id="指令重排总结"><a href="#指令重排总结" class="headerlink" title="指令重排总结"></a>指令重排总结</h2><ul>
<li>  <code>volatile</code> 关键字能禁止指令重排，从而避免多线程环境下程序执行结果不确定的情况。</li>
<li>  单线程程序中发生指令重排是不会影响到最终的执行结果的，因为指令重排首先要满足对象的依赖性，所以不会出现某个对象还没有初始化就对其操作的情况。</li>
<li>  指令重排有时候有好处（执行速度比较快），有时候有坏处（执行结果得不到保证），需要根据具体场景判断是否需要使用指令重排。如果需要就不用加 <code>volatile</code> 修饰，如果不需要指令重排就加 <code>volatile</code> 修饰。</li>
</ul>
<hr>
<h1 id="6-线程安全性获得保证"><a href="#6-线程安全性获得保证" class="headerlink" title="6    线程安全性获得保证"></a>6    线程安全性获得保证</h1><blockquote>
<p>  <strong>多线程存在哪些隐患？</strong></p>
</blockquote>
<ol>
<li> 工作内存与主内存同步延迟现象导致的可见性问题。</li>
<li> 指令重排导致的有序性问题。</li>
</ol>
<blockquote>
<p>  <strong>如何解决？</strong></p>
</blockquote>
<ol>
<li> 对于多个工作内存间的可见性问题，可以使用 synchronized 或 volatile 关键字解决，它们都可以使一个线程<strong>修改后的变量立即对其它线程可见</strong>。</li>
<li> 对于指令重排导致的有序性问题，可以使用 volatile 关键字解决，因为 volatile 的另一个作用就是禁止指令重排。</li>
</ol>
<blockquote>
<p>  <strong>遗留问题：</strong></p>
</blockquote>
<ul>
<li>  <strong>synchronized 关键字不能禁止指令重排，却能保证有序性，这是为什么？</strong></li>
</ul>
<hr>
<h1 id="7-DCL-单例"><a href="#7-DCL-单例" class="headerlink" title="7    DCL 单例"></a>7    DCL 单例</h1><p>DCL（Double Check Lock）：双重检查锁</p>
<blockquote>
<ol>
<li><strong>饿汉式单例</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个单例对象（饿汉式）：</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      1、将构造方法私有化（不提供从外部创建对象的接口）</span></span><br><span class="line"><span class="comment"> *      2、提供一个公共的方法用于获取这个单例对象</span></span><br><span class="line"><span class="comment"> *	    3、在类加载时就创建一个实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleExample</span> <span class="variable">singleExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这种单例模式的弊端：无论这个单例对象在程序中是否会使用，在类加载阶段都会创建这个单例对象。会浪费服务器的性能。</li>
</ul>
<blockquote>
<ol start="2">
<li><strong>单例优化（懒加载）</strong>：类加载阶段不创建实例对象，在使用时才创建实例对象。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">            <span class="comment">// 线程不安全。假设在这个位置同时进入了多个线程</span></span><br><span class="line">            singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这种单例模式的弊端：线程不安全！！！</li>
<li>如果同时有多个线程进入了第 10 行的位置，显然这些线程都会执行 <code>new SingleExample()</code> 方法，就会创建多个对象实例。</li>
</ul>
<blockquote>
<ol start="3">
<li>继续优化：想要实现线程安全，就需要<strong>加锁</strong>。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;	<span class="comment">// 使用 synchronized 关键字加锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">            singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面这种单例模式的弊端：锁的粒度太大。</p>
<p>  除了第一次调用 <code>getInstance()</code> 方法时会执行创建 SingleExample 对象的动作外，以后的每一次调用都是直接返回 singleExample 对象的引用，返回对象引用这个操作的耗时是很小的，绝大部分的耗时都用在 synchronized 修饰符的同步准备上，也就是说对象创建好了之后再有多个线程访问该方法是安全的，直接在最外层的方法上加锁，每次仍然需要进行锁对象的争夺，就会影响程序执行的性能了。</p>
</li>
</ul>
<blockquote>
<ol start="4">
<li>继续优化：<strong>降低锁的粒度</strong>。将同步锁加在具体某一行或几行代码上。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample) &#123;</span><br><span class="line">            <span class="comment">// 可能存在多个线程同时进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample.class) &#123;</span><br><span class="line">                singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>弊端：违背了单例的原则。</li>
<li>分析：第 9 行可能存在多个线程同时进入，即使在第10行进行了加锁，但是第 9 行的多个线程已经通过了 if 判断，不会再次进行判断了，所以这多个线程最终还是会创建出来多个 SingleExample 对象，违背了单例的原则。</li>
</ul>
<blockquote>
<ol start="5">
<li>继续优化：<strong>DCL（Double Check Lock）</strong>，双重检查锁。在锁的前面和后面都进行一次判断</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 支持多线程操作且线程安全的代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample) &#123;    <span class="comment">/*第一次检查，如果已有实例对象就不会触发多线程操作，作用是节省性能*/</span></span><br><span class="line">            <span class="comment">// 可能存在多个线程同时进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample.class) &#123;    <span class="comment">/*第二次检查，作用是保证创建出来的实例对象只能有一个*/</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">                    singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>双重检查锁可以解决锁的粒度大且线程不安全的问题。</p>
</li>
<li><p>分析：</p>
<ol>
<li> 第一次检查的目的：如果 singleExample 对象已经被创建了出来，那么就不会进入到多个线程争夺锁对象的阶段，节省性能。</li>
<li> 第二次检查的目的：保证创建出来的实例对象只能有一个。</li>
</ol>
</li>
<li><p>隐患：</p>
<p>  DCL 单例看起来已经可以完美地创建出来一个单例对象了，但是由于存在指令重排的可能，因此 DCL 单例还能有进一步优化的可能。</p>
</li>
</ul>
<h2 id="DCL-单例存在的隐患及优化方法"><a href="#DCL-单例存在的隐患及优化方法" class="headerlink" title="DCL 单例存在的隐患及优化方法"></a>DCL 单例存在的隐患及优化方法</h2><p>​        DCL 单例并不一定线程安全，原因是可能会出现指令重排，所以还需要使用 volatile 关键字来防止高并发情况下，指令重排造成的线程安全问题。</p>
<h3 id="Java创建对象过程中CPU进行的操作"><a href="#Java创建对象过程中CPU进行的操作" class="headerlink" title="Java创建对象过程中CPU进行的操作"></a>Java创建对象过程中CPU进行的操作</h3><p><img src="/2021/08/07/volatile/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%843%E4%B8%AA%E9%98%B6%E6%AE%B5.png"></p>
<p>Java 创建对象的过程可分为三个部分：</p>
<ol>
<li>在堆中给将要创建的对象分配一块内存空间，并赋初始零值。</li>
<li>根据对象的构造函数进行初始化（显式初始化）。</li>
<li>在栈中建立指针与对象的对应关系。</li>
</ol>
<p>​        Java 创建对象的每一步都需要 CPU 提供相应的指令，且对象数据保存在堆内存中，CPU 需要从内存中去读取这部分数据并拿回来运算，这就有可能会发生指令重排。</p>
<p>​        步骤2 和 步骤3 不存在数据依赖关系，所以可能会存在指令重排，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排是允许的。</p>
<blockquote>
<p>  <strong>重排前</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();	<span class="comment">// 1、给对象分配内存空间</span></span><br><span class="line">instance(memory);		<span class="comment">// 2、初始化对象</span></span><br><span class="line">instance = memory;		<span class="comment">// 3、设置栈中变量 instance 指向刚分配的内存地址，此时 instance != null</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>重排后</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();	<span class="comment">// 1、给对象分配内存空间</span></span><br><span class="line">instance = memory;		<span class="comment">// 3、设置栈中变量 instance 指向刚分配的内存地址，此时 instance != null，但是对象还没有初始化完成</span></span><br><span class="line">instance(memory);		<span class="comment">// 2、初始化对象</span></span><br></pre></td></tr></table></figure>



<ul>
<li>如果发生指令重排，则原本执行顺序可能变为<code>1-&gt; 3-&gt; 2</code>，指令重排在单线程下是不会对程序产生大的影响的，因为单线程操作的过程中不会有其它线程来访问程序执行的某个中间阶段，最终的结果不会改变。</li>
<li>但是如果在多线程的情况下（假设指令重排后顺序变为<code>1-&gt; 3-&gt; 2</code>），线程A 创建单例对象，执行了1，3步骤后，切换到线程B 执行读取单例对象并返回的操作，因为线程A 执行完1、3步骤后 <code>instance != null</code>，所以线程B 不会再去执行创建对象的代码，而是直接返回单例对象的引用，但是此时这个引用指向的单例对象的值是类加载阶段赋的初始零值 null，而不是构造器中显式指定的初始值，显然这是不对的。如果线程B 拿着这个错误的单例对象去使用了，线程B 对应的程序就不能够正常运行了。</li>
<li>即便之后线程A 再执行第2步骤，完成了构造器显式赋值，并且之后也不会再出现读取到默认零值的情况，但是起码存在这样一种出错的可能性。</li>
<li>而 <strong>volatile</strong> 关键字的作用就是保证指令不被重排。当创建单例对象时，保证指令的执行顺序一定是是 <code>1-&gt; 2 -&gt;3</code>。</li>
</ul>
<blockquote>
<p>  <strong>null != single 有两种情况：</strong></p>
</blockquote>
<ol>
<li> 已经完整地创建过 SingleExample 对象了，没有发生指令重排，或者在指令重排的时候没有多个线程访问。</li>
<li> 正在创建 SingleExample 对象，但是发生了指令重排，并且有多个线程访问，并且有 A线程得到了锁对象，但是只执行了分配内存空间和设置 instance 指向内存地址后，CPU 资源就切换到 B线程去执行了，这时候 instance 确实是有值的（地址值），但是地址中没有数据，如果 B线程拿到了 instance 并使用，就会出现程序执行错误了。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/07/Spring%E2%80%94%E2%80%94IoC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/" class="post-title-link" itemprop="url">Spring——IoC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-07 12:22:09" itemprop="dateCreated datePublished" datetime="2021-08-07T12:22:09+08:00">2021-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-30 16:42:05" itemprop="dateModified" datetime="2022-03-30T16:42:05+08:00">2022-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IoC-是什么？"><a href="#IoC-是什么？" class="headerlink" title="IoC 是什么？"></a>IoC 是什么？</h1><p><strong>IOC 的概念：</strong></p>
<p>IOC（Inversion of Control） 最初被叫做“Hollywood Principe”，即好莱坞原则。为什么要起这个名字呢？好莱坞原则的意思就是：在拍摄某部电影时，演员不是主动去申请拍摄这部电影的，而是由导演来挑选演员的。类比到 Spring 中就是：实例对象不是主动去创建的，而是由 Spring 容器在适当的时候去创建出来提供给程序使用的。官方一点的解释就是：</p>
<blockquote>
<ul>
<li>  IOC 就是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。 </li>
<li>  Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</li>
</ul>
</blockquote>
<p><strong>IoC 作用：</strong></p>
<ol>
<li> 创建对象并维护对象之间的依赖关系。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的。</li>
<li> 解耦，由容器去维护具体的对象</li>
</ol>
<p><strong>实现 IoC 设计原则的2种方式：</strong></p>
<ol>
<li><strong>依赖注入（DI）</strong></li>
<li>依赖查找（Dependency Lookup）</li>
</ol>
<p><strong>Spring 中 IOC 的实现原理：</strong></p>
<p>Spring 中 IOC 的实现原理就是 <u><strong>工厂模式+反射机制</strong></u>。我们通过一个例子来解释一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getInstance</span><span class="params">(String ClassName)</span> &#123;</span><br><span class="line">        Fruit f=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;cn.lnd.springtest.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="程序的耦合和解耦"><a href="#程序的耦合和解耦" class="headerlink" title="程序的耦合和解耦"></a>程序的耦合和解耦</h2><blockquote>
<ul>
<li><p>耦合性（Coupling），是对模块间关联程度的度量。</p>
</li>
<li><p>划分模块的一个准则就是<strong>高内聚低耦合</strong>。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>程序的耦合</strong>，就是程序间的依赖关系。包括：<ul>
<li>类之间的依赖</li>
<li>方法之间的依赖</li>
</ul>
</li>
<li><strong>解耦</strong>，就是降低程序间的依赖关系。在实际开发中，应该做到：<ul>
<li>编译期不依赖，运行时才依赖。</li>
</ul>
</li>
<li><strong>解耦的思路</strong>：<ul>
<li>step1：通过反射来创建对象，而避免使用new关键字。</li>
<li>step2：通过读取配置文件来获取想要创建的对象的全限定类名。</li>
</ul>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在开发中，有些依赖关系必须是显式的，有些依赖关系可以通过优化代码来避免。</p>
<p><strong>问：</strong>在使用 JDBC 注册驱动时，为什么不使用<code>DriverManger</code>中的静态方法 <code>registerDriver()</code>，而是采用<code>Class.forName()</code>的方式？</p>
<p><strong>答：</strong></p>
<ol>
<li><code>DriverManager.registerDriver(Driver driver)</code> 是 <code>java.sql</code> 包下的一个静态方法，接收的参数是一个数据库驱动实现类实例，作用是注册数据库驱动程序。如果我们直接调用该方法来注册驱动当然是可以的，需要我们创建一个数据库驱动实现类的实例并将对象传递给<code>registerDriver()</code>方法即可。但是此时：<ul>
<li>如果更换了数据库驱动，假设从 MySQL 数据库驱动换为 Oracle 数据库驱动，那么必须修改代码，重新创建一个 Oracle 数据库驱动对象并传递给 <code>registerDriver()</code> 方法。</li>
<li>如果需要的数据库驱动类不存在，那么在编译期就会直接报错。</li>
</ul>
</li>
<li>使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>反射机制将 MySQL 数据库驱动类对象加载进内存。<ul>
<li>使用反射机制的好处是，消除了编译期依赖，<code>Class.forName()</code>方法中接收的形参是String类型，在编译期传递任意错误的值都不会报错，当然运行时必定会出现错误。 </li>
<li>但是更换数据库驱动时仍然要修改源代码。</li>
</ul>
</li>
<li> 但是第2种方法仍然不是耦合度最低方法。耦合度最低的方式是将数据库配置信息保存在外部配置文件(如<code>.properties</code>)中，在源码中通过读取配置文件的方式将数据库驱动加载进内存中。当我们更换了数据库品牌的时候，只需要修改外部的配置文件即可，而不用对源码做任何修改。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.jdbc;<span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo01</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;        </span><br><span class="line">        <span class="comment">// 注册数据库驱动        </span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);     <span class="comment">// 方式2：通过反射的方式注册数据库驱动</span></span><br><span class="line">        <span class="comment">// DriverManager.registerDriver(new com.mysql.jdbc.Driver());    // 方式1：通过DriverManager中的静态方法registerDriver(Driver driver)来注册驱动</span></span><br><span class="line">        <span class="comment">// 获取连接对象Connection        </span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);    </span><br><span class="line">        <span class="comment">// 获取数据预处理对象PreparedStatement        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user;&quot;</span>;        </span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);        </span><br><span class="line">        <span class="comment">// 执行（查询）语句，并接收返回值        </span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();        </span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 提交事务（MySQL自动提交）        </span></span><br><span class="line">        <span class="comment">// 释放资源        </span></span><br><span class="line">        resultSet.close();        </span><br><span class="line">        preparedStatement.close();        </span><br><span class="line">        connection.close();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="容器-amp-工厂"><a href="#容器-amp-工厂" class="headerlink" title="容器 &amp; 工厂"></a>容器 &amp; 工厂</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1 容器"></a>1 容器</h2><p>Spring 的作者 Rod Johnson 设计了两个顶级接口来表示容器，分别是：</p>
<ul>
<li>  <strong>BeanFactory</strong></li>
<li>  <strong>ApplicationContext</strong></li>
</ul>
<p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，key 是 BeanName，value 是 Bean 的 Class 对象。通常只提供注册（put），获取（get）这两个功能，我们一般称其为 “<strong>低级容器</strong>”。</p>
<p>那么相对的，ApplicationContext 一般被称为 “<strong>高级容器</strong>”。它继承了包括 BeanFactory 在内的多个接口，在 BeanFactory 的基础上提供了更多的功能。</p>
<p>例如资源的获取，支持多种消息（例如 JSP tag 的支持），相较于 BeanFactory 多了工具级别的支持。所以它的名字已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。</p>
<p>ApplicationContext 接口的源码中定义了一个 <code>refresh()</code> 方法（高级容器特有的方法），此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p>
<h3 id="低级容器的-IOC-过程"><a href="#低级容器的-IOC-过程" class="headerlink" title="低级容器的 IOC 过程"></a>低级容器的 IOC 过程</h3><p>IOC 在 Spring 里，只需要低级容器就可以实现：</p>
<ol>
<li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li>
<li>调用 <code>getBean</code> 的时候，从 BeanDefinition 所属 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 <code>getBean</code> 方法完成多个类的依赖注入。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>  Spring 应用程序在启动时，就会读取并加载配置文件到内存中，根据配置文件中的全限定类名创建对应的 Class 类对象并保存到容器中。</li>
<li>  <strong>懒加载</strong>是指需要实例对象的时候，将 Class 对象拿出来创建对象的实例对象。而 Class 对象则是在程序启动时一次性加载到内存中的的，并且会将 Class 实例保存到容器中作为 Value。</li>
</ul>
<hr>
<h2 id="2-工厂"><a href="#2-工厂" class="headerlink" title="2 工厂"></a>2 工厂</h2><p>Spring 的 IoC 是通过 <strong>简单工厂模式 + 反射机制</strong> 来实现的。</p>
<p>工厂主要有如下几个作用：</p>
<ol>
<li><p> 在程序启动时，读取配置文件，根据配置文件中 bean 的全限定类名创建其对应的 Class 类对象并保存到一个 Map 结构的容器中。【反射】</p>
</li>
<li><p> 对外提供 getInstance 方法，在需要使用实例对象的时候提供对应的实例对象，而不用自己去创建<code>(new)</code></p>
</li>
<li><p>工厂模式内部是通过反射机制，从容器中拿到对应的 Class 对象，根据 Class 对象动态的创建对应的对象实例。</p>
</li>
</ol>
<h3 id="2-1-工厂的体系结构（BeanFactory-vs-ApplicationContext）"><a href="#2-1-工厂的体系结构（BeanFactory-vs-ApplicationContext）" class="headerlink" title="2.1 工厂的体系结构（BeanFactory vs. ApplicationContext）"></a>2.1 工厂的体系结构（BeanFactory vs. ApplicationContext）</h3><blockquote>
<p><strong>Spring容器体系结构图（部分）</strong></p>
</blockquote>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/Spring%E5%AE%B9%E5%99%A8%E7%B1%BB.png" alt="Spring容器类"></p>
<h5>BeanFactory 和 ApplicationContext 的继承关系：</h5>


<p>BeanFactory 和 ApplicationContext 是 Spring 容器的两大顶级接口，都可以当做 Spring 容器。其中 BeanFactory 是 Spring 容器最顶级的接口，ApplicationContext 是 BeanFactory 的子接口。</p>
<p>BeanFactory 接口内部定义了一系列顶级抽象方法（包含各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系等）。</p>
<p>ApplicationContext 接口作为 BeanFactory 的子接口，除了拥有 BeanFactory 声明的所有功能外，还继承了很多其它的接口，因此可以提供更多的功能。如：</p>
<ul>
<li>  支持国际化。</li>
<li>  支持统一的资源文件访问方式。</li>
<li>  提供在监听器中注册bean的事件。</li>
<li>  支持同时加载多个配置文件。</li>
<li>  载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层。</li>
</ul>
<h5>BeanFactory 和 ApplicationContext 对应的不同加载方式：</h5>


<p>​    <code>BeanFactroy</code> 采用的是<strong>懒加载</strong>的形式来注入 Bean 的，即只有在使用到某个Bean时（调用 <code>getBean()</code>）才对该 Bean 进行加载实例化。这样，我们就不能第一时间发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入，BeanFacotry 加载后，直至第一次使用调用 <code>getBean()</code> 方法才会抛出异常。</p>
<p>​    <code>ApplicationContext</code> 是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，如果存在的配置错误就会直接报错，这样有利于检查所依赖属性是否注入。这种方式的优点是：<code>ApplicationContext</code> 启动后预载入所有的单例 Bean，当你需要使用的时候，无需等待，因为它们已经创建好了，可以直接使用。缺点是：相对于基本的 <code>BeanFactory</code>，<code>ApplicationContext</code> 唯一的不足是占用内存空间。当应用程序配置 Bean 较多时，程序启动较慢。</p>
<h5>ApplicationContext接口常用的实现类：</h5>


<ul>
<li>  <strong>ClassPathXmlApplicationContext</strong>：它是从类的根路径下加载配置文件【推荐使用】</li>
<li>  <strong>FileSystemXmlApplicationContext</strong>：它是从磁盘路径上加载配置文件。</li>
<li>  <strong>AnnotationConfigApplicationContext</strong>：当我们使用Spring的纯注解开发时，需要使用此类来加载<strong>配置类</strong>。</li>
</ul>
<hr>
<h1 id="Spring中基于XML的IoC环境搭建"><a href="#Spring中基于XML的IoC环境搭建" class="headerlink" title="Spring中基于XML的IoC环境搭建"></a>Spring中基于XML的IoC环境搭建</h1><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1 代码实现"></a>1 代码实现</h2><ol>
<li><p>创建Maven工程并导入 <code>spring-contex</code> 依赖。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个配置文件 <code>bean.xml</code>，保存要创建的对象的全限定类名以及对应的<code>id</code>，用于通过反射创建对象。</p>
<ul>
<li><code>bean.xml</code>配置文件的约束：</li>
</ul>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>       </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--待创建的bean对象--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;自定义id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;全限定类名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用注解配置 IoC 时配置文件的约束：</li>
</ul>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>       </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--告知spring创建时，容器要扫描的包--&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xsyu&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>创建测试类。在测试类中读取配置文件，创建Spring容器（底层是Map结构），并使用 <code>getBean()</code> 方法中从 Spring容器中获取对应的实例对象。</p>
<ul>
<li>  Spring 容器中的的 key 是 <code>bean.xml</code> 配置文件中<code>&lt;bean&gt;</code>标签的 id 属性；</li>
<li>  Spring 容器中的的 value 是根据 <code>bean.xml</code> 配置文件中<code>&lt;bean&gt;</code>标签中的 class 属性对应的全限定类名通过反射创建出来的 <strong>Class类对象</strong>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建工厂实例</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 工厂实例从IoC容器中获取实例对象</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="2-IoC中bean标签和管理对象细节"><a href="#2-IoC中bean标签和管理对象细节" class="headerlink" title="2 IoC中bean标签和管理对象细节"></a>2 IoC中bean标签和管理对象细节</h2><p><code>bean.xml</code> 是一个配置文件，该文件内所有的数据都被用来根据反射创建对象。</p>
<h3 id="2-1-bean标签"><a href="#2-1-bean标签" class="headerlink" title="2.1 bean标签"></a>2.1 bean标签</h3><p><strong>作用：</strong></p>
<ul>
<li>用于配置要添加到容器中的对象的信息（id和全限定类名）。</li>
<li><u>默认情况下，工厂创建实例对象时使用的是类的无参构造函数，如果没有无参构造函数则不能创建成功。</u></li>
</ul>
<p><strong>属性：</strong></p>
<ul>
<li><code>id</code>：是对象在 Spring 容器中的 key，用于获取对象。</li>
<li><code>class</code>：指定类的全限定类名。[全类名被用于通过反射创建对象，默认情况下调用无参构造函数初始化。]</li>
<li><code>scope</code>：指定对象的作用范围。<ol>
<li><code>singleton</code>：单例的。默认值</li>
<li><code>prototype</code>：多例的</li>
<li><code>request</code>：一次请求范围内</li>
<li><code>session</code>：一次会话范围内</li>
<li><code>global session</code>：全局session，一个集群范围内。如果没有集群，等价于<code>session</code></li>
</ol>
</li>
<li><code>init-method</code>：指定类中初始法方法的名称。</li>
<li><code>destroy-method</code>：指定类中销毁方法的名称</li>
</ul>
<h3 id="2-2-Bean-的作用范围和生命周期"><a href="#2-2-Bean-的作用范围和生命周期" class="headerlink" title="2.2 Bean 的作用范围和生命周期"></a>2.2 Bean 的作用范围和生命周期</h3><table>
<thead>
<tr>
<th align="center">单例对象</th>
<th align="center">多例对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">scope=”singleton”</td>
<td align="center">scope=”prototype”</td>
</tr>
<tr>
<td align="center">容器中只有一个该类的实例对象。它的作用范围就是整个应用[即无论哪里用到该对象，都是同一个对象]。</td>
<td align="center">一个容器中<strong>可以有无数个</strong>该类的实例对象。每次需要使用该对象时，就会重新创建实例对象。</td>
</tr>
</tbody></table>
<p>单例对象的生命周期：</p>
<ul>
<li>  对象出生：当应用程序加载时，读取了配置文件，创建了Spring容器时，单例对象就被创建了。</li>
<li>  对象活着：只要容器还存在，单例对象就一直活着。</li>
<li>对象死亡：当应用程序关闭，容器被销毁时，对象就被销毁了。</li>
</ul>
<p>多例对象的生命周期：</p>
<ul>
<li>  对象创建：Spring 容器被创建时，对象并没有被创建。当程序中的某一步骤需要使用该对象时，才会创建对象的实例。[懒加载]</li>
<li>  对象活着：只要程序运行中某一步骤还需要使用该对象，多例对象就一直活着。</li>
<li>  对象死亡：当对象长时间不用时，由Java的垃圾回收器回收。</li>
</ul>
<h3 id="2-3-实例化Bean的三种方式"><a href="#2-3-实例化Bean的三种方式" class="headerlink" title="2.3 实例化Bean的三种方式"></a>2.3 实例化Bean的三种方式</h3><blockquote>
<ul>
<li>使用默认无参构造函数</li>
<li>使用静态工厂</li>
<li>使用实例化工厂</li>
</ul>
</blockquote>
<h4>1、使用默认无参构造函数</h4>


<p><strong>默认情况</strong>下，Spring容器会根据全限定类名找到对应的类，并根据类中无参构造器来创建实例对象。如果类中没有无参构造器，将会创建失败。</p>
<ul>
<li>  默认情况下，JVM 会给每个类提供一个无参构造函数，所以如果没有重写构造函数，是可以直接创建实例对象的。</li>
<li>  如果重写了无参构造函数，那么 Spring 容器会使用你重写的这个无参构造函数来创建实例对象，也是可以创建成功的。</li>
<li>  但是如果重写了构造函数，但是只重写了带参构造函数，而没有重写无参构造函数，则默认的无参构造函数则会失效，这时候使用Spring默认的实例化Bean的方式创建实例对象就会失败。</li>
</ul>
<p>所以说，<strong>对于Spring容器默认的实例化 Bean 的方式，只要存在无参构造函数，就可以成功创建对象。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认情况--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h4>2、Spring管理静态工厂，使用静态工厂中的方法创建对象</h4>


<ol>
<li>创建一个静态工厂，这个工厂中的方法用于实例化Bean对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 模拟一个静态工厂，创建dao层实现类*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置<code>bean.xml</code>文件中的<code>&lt;bean&gt;标签</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--	</span></span><br><span class="line"><span class="comment">使用StaticFactory类中的静态方法`createUserDao()`创建对象，并存入Spring容器。		</span></span><br><span class="line"><span class="comment">	id：指定bean的唯一标识，用于从容器中获取实例对象。		</span></span><br><span class="line"><span class="comment">	class：指定静态工厂的全限定类名。</span></span><br><span class="line"><span class="comment">  	factory-method：指定生产对象的静态方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span>       </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.factory.StaticFactory&quot;</span>      </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  分析：</p>
</blockquote>
<ol>
<li><code>&lt;bean&gt;</code>标签中存在<strong>静态工厂类的全限定类名</strong>，可以通过反射创建类对应的 Class 实例，通过 Class 实例直接调用类中的方法，不必实例化。**[即Spring容器中并没有<code>cn.xsyu.factory.StaticFactory</code>的实例对象]**</li>
<li><code>class=&quot;cn.xsyu.factory.StaticFactory&quot;</code>只是起到了一个代理的作用，通过类中的<code>createUserDao()</code>方法<strong>创建了<code>UserDaoImpl</code>实例对象，并将其加入spring容器</strong>，指定唯一标识<code>id=&quot;usertDao&quot;</code></li>
</ol>
<hr>
<h4>3、Spring管理实例工厂，使用实例工厂中的方法创建对象</h4>


<ol>
<li><p>创建一个实例工厂，这个工厂中的方法用于实例化Bean对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 模拟一个实例工厂，创建dao层实现类。</span></span><br><span class="line"><span class="comment">* 此工厂创建对象，必须要有工厂实例对象，才能调用方法。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置<code>bean.xml</code>文件中的<code>&lt;bean&gt;标签</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--	</span></span><br><span class="line"><span class="comment">	先把工厂的创建（实例化）交给spring来管理，然后再使用工厂的实例化对象`factory-bean`来调用对象中的方法，					factory-bean：用于指定实例工厂bean的唯一标识；		</span></span><br><span class="line"><span class="comment">		factory-method：用于指定实例工厂中的方法。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.factory.InstanceFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span>      </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-bean</span>=<span class="string">&quot;instanceFactory&quot;</span>      </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>  分析：</p>
</blockquote>
<ol>
<li><code>bean</code>标签中存在非静态工厂的全限定类名<code>cn.xsyu.factory.InstanceFactory</code>，要想使用实例工厂对象中的方法，则必须通过反射得到<code>InstanceFactory</code>对象的实例。</li>
<li>通过 Class 对象得到对应的实例对象，并将其交给 Spring 管理。**[内存中存在<code>cn.xsyu.factory.InstanceFactory</code>的实例对象]**</li>
<li>得到 <strong>InstanceFactory</strong> 实例对象后，再通过<code>factory-method</code>调用对象中的方法<code>createUserDao</code>，最后得到方法的返回值交给 Spring容器管理，并指定唯一标识<code>id=&quot;accountDao&quot;</code>。</li>
</ol>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E6%96%B9%E5%BC%8F-1598445621956.png"></p>
<hr>
<h1 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h1><blockquote>
<ul>
<li>依赖注入是什么</li>
<li>构造函数注入</li>
<li>set方法注入</li>
<li>注入集合属性（set方法）</li>
</ul>
</blockquote>
<h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1 是什么？"></a>1 是什么？</h2><ul>
<li>  IoC 的实现方式有 <strong>依赖查找</strong> 和 <strong>依赖注入</strong>。由于依赖查找使用的很少，因此 IoC 也叫做依赖注入（DI）。</li>
<li>  <strong>DI</strong> 的设计原则允许我们<strong>移除硬编码依赖来降低程序间的耦合度</strong>。</li>
<li>  我们的程序在编写时，通过控制反转，把对象的创建交给了spring，但是代码中不可能出现没有依赖的情况。IoC解耦只是降低它们的依赖关系，而不会消除。</li>
<li>  例如：我们的业务层仍然会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring自己来维护了。简单的说，w我们只进行声明，具体的过程就是坐等框架把持久层对象传入业务层，而不用我们自己在业务层去获取。</li>
</ul>
<hr>
<h2 id="2-依赖注入的3种方式"><a href="#2-依赖注入的3种方式" class="headerlink" title="2    依赖注入的3种方式"></a>2    依赖注入的3种方式</h2><blockquote>
<p>  依赖注入的数据类型（3类）：</p>
</blockquote>
<ul>
<li>基本类型和String</li>
<li>其它bean类型（在配置文件中配置或者注解配置过的bean）</li>
<li>复杂类型/集合类型</li>
</ul>
<blockquote>
<p>  依赖注入的方式（2种）：</p>
</blockquote>
<ul>
<li>使用构造函数注入</li>
<li>使用set方法注入</li>
</ul>
<h3 id="2-1-构造函数注入"><a href="#2-1-构造函数注入" class="headerlink" title="2.1    构造函数注入"></a>2.1    构造函数注入</h3><ul>
<li>  顾名思义，就是在使用指定的构造器初始化对象时，通过给构造器中的属性赋值，创建出有初始值的对象。</li>
<li>  实际上使用默认无参构造函数初始化类时，也就是<code>&lt;construct-arg&gt;</code>标签中没有任何内容，所以自然可以省略该标签，初始化时bean对象自然也就没有任何初始值了。</li>
<li>  注意：赋值的操作不是我们自己做的，而是通过设置配置文件让 Spring 框架来为我们注入，我们只需要提供 <strong>要使用的初始值</strong> 和 <strong>对应的构造函数</strong> 即可。</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<ol>
<li>定义一个类对象<code>AccountServiceImpl</code>，重写其中的构造方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;    </span><br><span class="line">    <span class="keyword">private</span> Date birthday;    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountServiceImpl</span><span class="params">(String name, <span class="type">int</span> age, Date birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;        </span><br><span class="line">        <span class="built_in">this</span>.age = age;        </span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;:&quot;</span>+age+<span class="string">&quot;:&quot;</span>+birthday);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在<code>bean.xml</code>配置文件中，使用<code>构造函数注入</code>的方式，给<code>AccountServiceImpl</code>类中的成员变量赋值。</p>
<ul>
<li><p>类中构造函数的参数列表需与配置文件中给出的初始化属性一一映射。</p>
</li>
<li><p>涉及的标签：**<code>&lt;constructor-arg&gt;</code>**</p>
</li>
<li><p>标签出现的位置：<code>&lt;bean&gt;</code>标签的内部</p>
</li>
<li><p>标签中的属性：标签中的属性可分为2类，一类用来与类中构造函数中的参数产生映射关系，另一类是对参数进行赋值。</p>
<ul>
<li><p>以下三个属性均可用于绑定构造函数中的某个参数：</p>
<blockquote>
<ol>
<li><code>type</code>：用于指定参数的数据类型；【如果该类型的参数在构造函数列表中只有唯一一个与之匹配，则能注入成功，否则注入失败】</li>
<li><code>index</code>：指定参数在构造函数参数列表中的索引位置，指定索引的位置从0开始。            </li>
<li><strong>name</strong>：用于给指定的构造函数中的指定名称的参数赋值。【常用】</li>
</ol>
</blockquote>
</li>
<li><p>下面两个参数则用于对绑定的参数进行赋值：</p>
<blockquote>
<ol>
<li><code>value</code>：用于提供基本类型和String类型的数据</li>
<li><code>ref</code>：用于指定其他bean类型的数据。它只能指定在spring的IoC核心容器中出现过的bean对象。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.AccountServiceImpl&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;飞龙在天&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;45&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;time&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置一个日期对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>







<hr>
<h3 id="2-2-set方法注入"><a href="#2-2-set方法注入" class="headerlink" title="2.2    set方法注入"></a>2.2    set方法注入</h3><blockquote>
<p>顾名思义，就是在类初始化时使用中 set 方法给类中的属性赋值，这样创建出来的对象就是有初始值的。</p>
</blockquote>
<ol>
<li>创建JavaBean类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="comment">// 要注入成员    </span></span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;    </span><br><span class="line">    <span class="keyword">private</span> Date birthday;	</span><br><span class="line">    <span class="comment">// set方法    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(Date birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(name+<span class="string">&quot;:&quot;</span>+age+<span class="string">&quot;:&quot;</span>+birthday);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建配置文件，通过配置文件给JavaBean中的属性传值。使用<code>set</code> 方法的方式。</p>
<ul>
<li><p>使用的标签：**<code>&lt;property&gt;</code> **</p>
</li>
<li><p>出现的位置：<code>&lt;bean&gt;</code>标签内部</p>
</li>
<li><p>标签的属性：</p>
<blockquote>
<ol>
<li><code>name</code>：name属性的值与类中字段的值无关，只与<code>set方法</code>有关【去掉set后首字母小写】</li>
<li><code>value</code>：给JavaBean中的属性赋的值是基本数据类型和String类型的。</li>
<li><code>ref</code>:给JavaBean中的属性赋的值是其它bean类型的</li>
</ol>
</blockquote>
</li>
<li><p>实际开发中，此种方法用的较多。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.AccountServiceImpl2&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;施瓦奇迹&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;time&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置一个日期对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="2-3-使用-set-方法注入集合属性"><a href="#2-3-使用-set-方法注入集合属性" class="headerlink" title="2.3    使用 set 方法注入集合属性"></a>2.3    使用 set 方法注入集合属性</h3><ul>
<li>顾名思义，就是给类中的集合成员传值。它用的是set方法注入的方式，只不过变量的数据类型都是集合。</li>
</ul>
<ol>
<li><p>创建一个JavaBean类。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl3</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] arrs;    </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;    </span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets;    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;    </span><br><span class="line">    <span class="keyword">private</span> Properties props;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArrs</span><span class="params">(String[] arrs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arrs = arrs;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLists</span><span class="params">(List&lt;String&gt; lists)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lists = lists;    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.sets = sets;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.maps = maps;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProps</span><span class="params">(Properties props)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.props = props;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;    </span><br><span class="line">        System.out.println(Arrays.toString(arrs));        </span><br><span class="line">        System.out.println(lists);        </span><br><span class="line">        System.out.println(sets);       </span><br><span class="line">        System.out.println(maps);      </span><br><span class="line">        System.out.println(props);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建一个配置文件<code>bean.xml</code>。</p>
<p> 注入集合数据：</p>
<ol>
<li><p>List结构的：</p>
<ul>
<li><p><code>&lt;array&gt;&lt;value&gt;</code></p>
</li>
<li><p><code>&lt;list&gt;&lt;value&gt;</code></p>
</li>
<li><p><code>&lt;set&gt;&lt;value&gt;</code></p>
</li>
</ul>
</li>
<li><p>Map结构的：</p>
<ul>
<li><p><code>&lt;map&gt;&lt;entry&gt;</code></p>
</li>
<li><p><code>&lt;props&gt;&lt;prop&gt;</code></p>
</li>
</ul>
</li>
<li><p>在注入集合数据时，只要结构相同，标签可以互换。</p>
</li>
</ol>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.AccountServiceImpl3&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arrs&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>C<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lists&quot;</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>A<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BB<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span>       </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>C<span class="tag">&lt;/<span class="name">value</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;testA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aaa&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;testB&quot;</span>&gt;</span>               </span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;props&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;propC&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;propD&quot;</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="3-案例：使用纯XML实现单表的CRUD操作"><a href="#3-案例：使用纯XML实现单表的CRUD操作" class="headerlink" title="3    案例：使用纯XML实现单表的CRUD操作"></a>3    案例：使用纯XML实现单表的CRUD操作</h2><blockquote>
<p>  <strong>需求</strong></p>
</blockquote>
<ul>
<li>实现用户的 CRUD 操作</li>
</ul>
<blockquote>
<p>  <strong>技术要求</strong></p>
</blockquote>
<ul>
<li>使用Spring的 IoC 实现对象的管理</li>
<li>使用<code>dbutils</code>作为持久层解决方案</li>
<li>使用<code>c3p0</code>数据源</li>
</ul>
<blockquote>
<p>  <strong>环境搭建</strong></p>
</blockquote>
<ul>
<li>导入依赖</li>
</ul>
<h3 id="1、创建数据库"><a href="#1、创建数据库" class="headerlink" title="1、创建数据库"></a>1、创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE TABLE IF NOT EXISTS USER(	</span><br><span class="line">    id INT(2) AUTO_INCREMENT PRIMARY KEY,	</span><br><span class="line">    username VARCHAR(9) NOT NULL,	</span><br><span class="line">    gender VARCHAR(3) NOT NULL,</span><br><span class="line">    hobby VARCHAR(32)</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO USER(username, gender, hobby)VALUES(&quot;里番&quot;, &quot;男&quot;, &quot;口琴&quot;);</span><br><span class="line">INSERT INTO USER(username, gender, hobby)VALUES(&quot;刘玉豪&quot;, &quot;男&quot;, &quot;篮球&quot;);</span><br><span class="line">INSERT INTO USER(username, gender, hobby)VALUES(&quot;谭思雨&quot;, &quot;男&quot;, &quot;足球&quot;);</span><br></pre></td></tr></table></figure>



<h3 id="2、-编写实体类"><a href="#2、-编写实体类" class="headerlink" title="2、 编写实体类"></a>2、 编写实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 用户的实体类 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;   </span><br><span class="line">    <span class="keyword">private</span> Integer id;   </span><br><span class="line">    <span class="keyword">private</span> String username;  </span><br><span class="line">    <span class="keyword">private</span> String gender;  </span><br><span class="line">    <span class="keyword">private</span> String hobby;   </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +       </span><br><span class="line">            <span class="string">&quot;id=&quot;</span> + id +           </span><br><span class="line">            <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +    </span><br><span class="line">            <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +          </span><br><span class="line">            <span class="string">&quot;, hobby=&#x27;&quot;</span> + hobby + <span class="string">&#x27;\&#x27;&#x27;</span> +        </span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> id;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.id = id; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> username;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.username = username; </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> gender;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHobby</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobby</span><span class="params">(String hobby)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、编写持久层代码"><a href="#3、编写持久层代码" class="headerlink" title="3、编写持久层代码"></a>3、编写持久层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 操作数据库接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;   </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 增   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span>; </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 删   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 改   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;  </span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 查询所有    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 根据id查询  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;&#125;</span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">/*	持久层接口的实现类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;  </span><br><span class="line">    <span class="comment">// dbutils中操作数据库的核心对象，需要注入数据 </span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunner</span><span class="params">(QueryRunner runner)</span> &#123;    </span><br><span class="line">        <span class="built_in">this</span>.runner = runner;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 增 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user (username, gender, hobby) values(?,?,?)&quot;</span>;  </span><br><span class="line">            result = runner.update(sql, user.getUsername(), user.getGender(), user.getHobby());   </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;       </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 删  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">try</span>&#123;         </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user where id=?&quot;</span>;  </span><br><span class="line">            result = runner.update(sql, id);   </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;         </span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;     </span><br><span class="line">            <span class="keyword">return</span> result;      </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 改   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">try</span> &#123;      </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set username=?,gender=?,hobby=? where id=?&quot;</span>;     </span><br><span class="line">            result = runner.update(sql, user.getUsername(), user.getGender(), user.getHobby(),user.getId());   </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;     </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 查询所有   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;      </span><br><span class="line">        List&lt;User&gt; users = <span class="literal">null</span>;     </span><br><span class="line">        <span class="keyword">try</span> &#123;          </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;    </span><br><span class="line">            users = runner.query(sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;User&gt;(User.class));    </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;      </span><br><span class="line">            <span class="keyword">return</span> users;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 查询一个 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;   </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;    </span><br><span class="line">        <span class="keyword">try</span> &#123;         </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id=?&quot;</span>;     </span><br><span class="line">            user = runner.query(sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;User&gt;(User.class), id);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();      </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;        </span><br><span class="line">            <span class="keyword">return</span> user;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、编写业务层代码"><a href="#4、编写业务层代码" class="headerlink" title="4、编写业务层代码"></a>4、编写业务层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 增  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 删  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 改  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 查    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 查  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	业务层接口的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> cn.xsyu.service.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="comment">// 依赖注入  </span></span><br><span class="line">    <span class="keyword">private</span> UserDao dao;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDao</span><span class="params">(UserDao dao)</span> &#123;   </span><br><span class="line">        <span class="built_in">this</span>.dao = dao;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> dao.create(user);  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> dao.delete(id);  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> dao.update(user);  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> dao.findAll();    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> dao.findById(id); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、创建并编写配置文件"><a href="#5、创建并编写配置文件" class="headerlink" title="5、创建并编写配置文件"></a>5、创建并编写配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans      </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--配置service--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.UserServiceImpl&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置dao--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.dao.impl.UserDaoImpl&quot;</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;queryRunner&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置QueryRunner--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;queryRunner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!--配置数据源--&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!--数据库连接必备的信息--&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>/&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="6、编写测试类代码"><a href="#6、编写测试类代码" class="headerlink" title="6、编写测试类代码"></a>6、编写测试类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.test;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 调用Junit单元测试，测试我们的配置 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 测试保存新成员方法 </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="meta">@Test</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate</span><span class="params">()</span>&#123;     </span><br><span class="line">        <span class="comment">// 创建spring工厂      </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);    </span><br><span class="line">        <span class="comment">// 获取可执行对象    </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);   </span><br><span class="line">        <span class="comment">// 执行对象中方法     </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); </span><br><span class="line">        user.setUsername(<span class="string">&quot;spring&quot;</span>);       </span><br><span class="line">        user.setGender(<span class="string">&quot;女&quot;</span>);      </span><br><span class="line">        user.setHobby(<span class="string">&quot;java&quot;</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> service.create(user);    </span><br><span class="line">        System.out.println(result); </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 测试删除方法     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="comment">// 创建spring容器  </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);   </span><br><span class="line">        <span class="comment">// 获取service层对象    </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);       </span><br><span class="line">        <span class="comment">// 调用service层的方法   </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> service.delete(<span class="number">7</span>);     </span><br><span class="line">        <span class="comment">// 获取返回结果      </span></span><br><span class="line">        System.out.println(result); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 测试查询所有 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;    </span><br><span class="line">        <span class="comment">// 获取spring容器    </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取service层对象 </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);   </span><br><span class="line">        <span class="comment">// 调用service层的方法       </span></span><br><span class="line">        List&lt;User&gt; users = service.findAll();    </span><br><span class="line">        <span class="comment">// 获取返回结果   </span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123; </span><br><span class="line">            System.out.println(user);     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 测试查询一个方法   </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindOne</span><span class="params">()</span>&#123;    </span><br><span class="line">        <span class="comment">// 获取sprig容器 </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取service层对象   </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);  </span><br><span class="line">        <span class="comment">// 调用service层的方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> service.findById(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取返回结果     </span></span><br><span class="line">        System.out.println(user); </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 测试update方法 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;   </span><br><span class="line">        <span class="comment">// 获取spring容器     </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);       </span><br><span class="line">        <span class="comment">// 获取service层对象    </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);      </span><br><span class="line">        <span class="comment">// 调用service层的方法     </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> service.findById(<span class="number">1</span>);      </span><br><span class="line">        user.setUsername(<span class="string">&quot;李帆&quot;</span>);        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> service.update(user);      </span><br><span class="line">        <span class="comment">// 获取返回结果  </span></span><br><span class="line">        System.out.println(result);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7、分析"><a href="#7、分析" class="headerlink" title="7、分析"></a>7、分析</h3><ul>
<li>通过上面的测试，我们可以看出，每个测试方法都重新获取了一次spring的核心容器，造成了不必要的重复代码，增加了开发的工作量。这种情况，在开发中应该避免发生。</li>
<li>解决方法：Junit单元测试</li>
</ul>
<hr>
<h1 id="IoC注解开发"><a href="#IoC注解开发" class="headerlink" title="IoC注解开发"></a>IoC注解开发</h1><ul>
<li>  基于XML配置文件开发：指定配置文件的位置，创建容器时加载配置文件，容器是一个 HashMap 结构，key 为 bean 对象的id，值为 id 对应的全限定类名加载到内存中的 Class 对象。</li>
<li>  注解开发：指定要扫描的包，将该包下指定注解的类加载并保存到容器中。</li>
</ul>
<h2 id="1-使用注解开发时要导入的约束"><a href="#1-使用注解开发时要导入的约束" class="headerlink" title="1    使用注解开发时要导入的约束"></a>1    使用注解开发时要导入的约束</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--告知spring创建时，容器要扫描的包[含有注解的包]--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xsyu&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-注解分类"><a href="#2-注解分类" class="headerlink" title="2    注解分类"></a>2    注解分类</h2><h3 id="2-1-用于创建对象的注解"><a href="#2-1-用于创建对象的注解" class="headerlink" title="2.1    用于创建对象的注解"></a>2.1    用于创建对象的注解</h3><p><strong>作用</strong>：它们的作用就和在XML配置文件中编写一个<code>&lt;bean&gt;</code>标签实现的功能是一样的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Component-value-””"><a href="#Component-value-””" class="headerlink" title="@Component(value=””)"></a>@Component(value=””)</h4><ol>
<li><p><strong>作用范围</strong>：作用在类上。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;	<span class="comment">// 类中的代码</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用</strong>：把资源交给容器来管理，把当前类的 Class 对象存入容器中。相当于在 xml 中配置一个<code>&lt;bean&gt;</code></p>
</li>
<li><p><strong>属性</strong>：<code>value</code>：指定<code>&lt;bean&gt;</code>的 id，如果不显式指定value属性，默认<code>&lt;bean&gt;</code>的id是当前类的类名，首字母小写。</p>
</li>
<li><p><strong>Tip</strong>：如果注解中有且仅有一个属性要赋值，且名称是 <code>value</code>时，<code>value</code>可以省略不写。 </p>
</li>
</ol>
<h4 id="Controller、-Service、-Repository"><a href="#Controller、-Service、-Repository" class="headerlink" title="@Controller、@Service、@Repository"></a>@Controller、@Service、@Repository</h4><p>这三个注解是 <strong>@Component</strong> 衍生的注解，它们的作用和属性都是一样的，只不过是提供了更加明确的语义化定义。</p>
<ol>
<li><code>@Controler</code>：    一般用于表现层的注解</li>
<li><code>@Service</code>：    一般用于业务层的注解</li>
<li><code>@Repository</code>：    一般用于持久层的注解</li>
</ol>
<hr>
<h3 id="2-2-依赖注入（注解）"><a href="#2-2-依赖注入（注解）" class="headerlink" title="2.2    依赖注入（注解）"></a>2.2    依赖注入（注解）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--等价于xml中的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1、-Autowired"><a href="#1、-Autowired" class="headerlink" title="1、@Autowired"></a>1、@Autowired</h4><ol>
<li><p>作用范围：①成员变量 ②成员方法</p>
</li>
<li><p>作用：<strong>自动按照类型注入</strong>。    <strong><code>比较顺序：[待注入数据的数据类型--&gt;&gt;待注入数据的变量名]</code></strong></p>
<ul>
<li>如果类代码中待注入对象的数据类型无法和 Spring 容器中的任何一个实例对象相匹配，则报错。</li>
<li>如果 Spring 容器中只有唯一一个实例对象的数据类型与类代码中的数据类型匹配，直接注入成功。    <ul>
<li>如果在 Spring 容器中同时存在多个实例对象可以与类代码中某个对象的数据类型相匹配时，则继续使用类代码中对象的<code>变量名</code>与容器中的<code>id</code>进行匹配，找到了也可以注入成功，找不到就报错。</li>
</ul>
</li>
<li>当使用注解注入属性时，<code>set</code>方法可以省略。</li>
<li><code>@Autowired</code>只能注入其它<code>bean</code>类型【除了基本类型和String以外的类型】。</li>
</ul>
</li>
</ol>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/%E8%87%AA%E5%8A%A8%E6%8C%89%E7%85%A7%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5-1598445621956.png"></p>
<hr>
<h4 id="2、-Qualifier"><a href="#2、-Qualifier" class="headerlink" title="2、@Qualifier"></a>2、@Qualifier</h4><ol>
<li><p>作用范围：①成员变量 ②成员方法中的形式参数</p>
</li>
<li><p>作用：按照名称注入。</p>
<ul>
<li><strong>它在给成员变量注入时不能单独使用，必须在使用<code>@Autowired</code>注解的基础之上再按照名称注入。</strong></li>
<li><strong>但是在给方法中的局部变量（形式参数）注入时可以单独使用。</strong></li>
</ul>
</li>
<li><p>属性：<code>value</code>：指定要注入的数据在IoC容器中<code>bean</code>对应的id。</p>
</li>
<li><p>示例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向账户中存入了2000元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="meta">@Repository()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向账户中存入了1000元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired()</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;accountDaoImpl2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao dao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	执行过程分析：</span></span><br><span class="line"><span class="comment">	  1. 使用 @Repository()注解将 AccountDaoImpl2 加入IoC容器。</span></span><br><span class="line"><span class="comment">	  	 使用 @Repository()注解将 AccountDaoImpl 加入IoC容器。</span></span><br><span class="line"><span class="comment">	  	   [</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl2&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl2&quot;&#125;</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl&quot;&#125;</span></span><br><span class="line"><span class="comment">      		......													    ]</span></span><br><span class="line"><span class="comment">       使用 @Autowired() 注解查找IoC容器中类型为 `AccountDao` 类型的数据，共找到2个</span></span><br><span class="line"><span class="comment">      	[</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl2&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl2&quot;&#125;</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl&quot;&#125;</span></span><br><span class="line"><span class="comment">      																    ]</span></span><br><span class="line"><span class="comment">       3. 使用 `@Qualifier(value=&quot;accountDaoImpl2&quot;)` 注解在容器中筛选出来的字集合中查找id为			     `accountDaoImpl2`的数据，最终找到了:</span></span><br><span class="line"><span class="comment">       		&#123;id=&quot;accountDaoImpl2&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl2&quot;&#125;,</span></span><br><span class="line"><span class="comment">        并将对应的类对象的数据注入。（在这里是创建实例对象，并将引用传给`dao`）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="3、-Resource"><a href="#3、-Resource" class="headerlink" title="3、@Resource"></a>3、@Resource</h4><ol>
<li>作用范围：①成员变量  ②成员方法</li>
<li>作用：直接按照<code>bean</code>的 id 注入，它可以独立使用。它也只能注入其它<code>bean</code>类型</li>
<li>属性：<code>name</code>：指定要注入的数据在 IoC 容器中<code>bean</code>对应的 id。</li>
</ol>
<h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip:"></a>Tip:</h4><ul>
<li>以上3个注入都只能注入其它bean类型的数据，而基本类型和String类型无法使用上述注解实现。</li>
</ul>
<hr>
<h4 id="4、-Value"><a href="#4、-Value" class="headerlink" title="4、@Value"></a>4、@Value</h4><ol>
<li><strong>作用范围</strong>：成员变量</li>
<li><strong>作用</strong>：可以注入基本类型数据和String类型数据</li>
<li><strong>属性</strong>：<code>value</code>：用于指定值。它可以使用 <strong>SpEL</strong> 表达式(Spring的EL表达式)。<ul>
<li>SpEL格式：<code>$&#123;表达式&#125;</code></li>
</ul>
</li>
<li>示例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(value = &quot;666&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向账户中存入了&quot;</span>+money+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="2-3-用于改变作用范围的注解"><a href="#2-3-用于改变作用范围的注解" class="headerlink" title="2.3    用于改变作用范围的注解"></a>2.3    用于改变作用范围的注解</h3><ul>
<li>它们的作用就和<code>&lt;bean&gt;</code>标签中使用<code>scope</code>属性实现的功能时一样的。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><ol>
<li><strong>作用</strong>：用于指定<code>bean</code>的作用范围</li>
<li><strong>属性</strong>：<code>value</code>：指定范围的取值。常用取值：<ol>
<li><code>singleton[单例]</code></li>
<li><code>prototype[多例]</code></li>
<li><code>request</code></li>
<li><code>session</code></li>
<li><code>globalsession</code></li>
</ol>
</li>
</ol>
<h3 id="2-4-和生命周期相关的注解"><a href="#2-4-和生命周期相关的注解" class="headerlink" title="2.4    和生命周期相关的注解"></a>2.4    和生命周期相关的注解</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--相当于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h4><ol>
<li><strong>作用</strong>：用于指定类的初始化方法，即类初始化时先执行的方法。</li>
</ol>
<h4 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h4><ol>
<li><strong>作用</strong>：用于指定类的销毁方法，即类销毁前先执行的方法。</li>
</ol>
<hr>
<h3 id="2-5-关于Spring注解和XML的选择问题"><a href="#2-5-关于Spring注解和XML的选择问题" class="headerlink" title="2.5    关于Spring注解和XML的选择问题"></a>2.5    关于Spring注解和XML的选择问题</h3><blockquote>
<p>  注解的优势</p>
</blockquote>
<ul>
<li>配置简单，维护方便（我们找到了类，就相当于找到了对应的配置）</li>
</ul>
<blockquote>
<p>  XML的优势</p>
</blockquote>
<ul>
<li>修改时，不用修改源码。不涉及重新编译和部署</li>
</ul>
<blockquote>
<p>  Spring管理Bean方式的比较</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">基于XML配置</th>
<th align="left">基于注解配置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Bean定义</td>
<td align="left"><code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code></td>
<td align="left"><code>@Component</code>；衍生类：<code>@Controller、@Service、@Repository</code></td>
</tr>
<tr>
<td align="left">Bean名称</td>
<td align="left">通过<code>id</code>或<code>name</code>指定</td>
<td align="left"><code>@Compoonent(value=&quot;person&quot;)</code></td>
</tr>
<tr>
<td align="left">Bean注入</td>
<td align="left"><code>&lt;property&gt;</code>或<code>&lt;constructor-arg&gt;</code></td>
<td align="left"><code>@Autowired</code>()：按类型注入；  <code>@Qualifier()</code>：按名称注入</td>
</tr>
<tr>
<td align="left">Bean生命周期</td>
<td align="left"><code>init-method</code>；<code>destroy-method</code></td>
<td align="left"><code>@PostConstruct</code>；<code>@PreDestroy</code></td>
</tr>
<tr>
<td align="left">Bean作用范围</td>
<td align="left"><code>scope属性</code></td>
<td align="left"><code>@Scope()</code></td>
</tr>
<tr>
<td align="left">适合场景</td>
<td align="left">Bean来自第三方，使用其它</td>
<td align="left">Bean的实现类由用户自己开发</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-6-新注解说明-区别于XML中功能的注解"><a href="#2-6-新注解说明-区别于XML中功能的注解" class="headerlink" title="2.6    新注解说明(区别于XML中功能的注解)"></a>2.6    新注解说明(区别于XML中功能的注解)</h3><h4 id="1、-Configuration"><a href="#1、-Configuration" class="headerlink" title="1、@Configuration"></a>1、@Configuration</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>用于指定当前类是一个spring的配置类，Spring工厂会读取该类中的配置信息创建容器，相当于读取<code>bean.xml</code>配置文件。</li>
<li>获取容器时需要使用<code>AnnotationApplicationContext(有@Configration注解的类.class)</code>【纯注解开发】</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>value</code>：用于指定配置类的字节码</p>
</li>
<li><p>示例代码</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring配置类，相当于bean.xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ul>
<li>我们已经把配置文件用配置类来代替了，但是如何配置创建容器时要扫描的包呢？</li>
<li>答：<code>@ComponentScan</code>注解</li>
</ul>
</li>
</ol>
<h4 id="2、-ComponentScan"><a href="#2、-ComponentScan" class="headerlink" title="2、@ComponentScan"></a>2、@ComponentScan</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li><p>开启注解扫描，用于指定 Spring 在初始化容器时要扫描的包。</p>
</li>
<li><p>作用和XML配置文件中的 <code>component-scan</code> 是一样的。：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xsyu&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>属性</strong>：</p>
<ul>
<li><code>basePackages</code>：用于指定要扫描的包。</li>
<li><code>value</code>：和<code>basePackages</code>属性的作用是一样的。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring配置类，相当于bean.xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;cn.xsyu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>存在的问题</strong>：</p>
<ul>
<li>我们已经配置好了要扫描的包，但是数据源和<code>JDBCTemplete</code>对象如何从配置文件中转移到注解中呢？</li>
<li>答：<code>@Bean</code>注解</li>
</ul>
</li>
</ol>
<h4 id="3、-Bean"><a href="#3、-Bean" class="headerlink" title="3、@Bean"></a>3、@Bean</h4><ol>
<li><p><strong>作用范围</strong>：方法上【@Component 注解用于将类对象装载到容器中，而 @Bean 注解则用于将方法返回值对象装载到容器中】</p>
</li>
<li><p><strong>作用</strong>：该注解只能作用于方法上，表示将此方法的返回值对象存入 Spring 容器中，并指定唯一标识。</p>
</li>
<li><p><strong>属性</strong>：<code>name</code>：给当前<code>@Bean注解</code>方法创建的对象指定一个唯一标识名称。</p>
</li>
<li><p><strong>示例代码</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接数据库的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个DataSource，并存入spring容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">            ds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            ds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>);</span><br><span class="line">            ds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个QueryRunner对象，并存入spring容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queryRunner&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> QueryRunner <span class="title function_">createQueryRunner</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(dataSource);</span><br><span class="line">        <span class="keyword">return</span> queryRunner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>存在的问题</strong>：</p>
<ul>
<li>我们已经把数据源<code>dataSource对象</code>和<code>queryRunner对象</code>从配置文件中转移到<code>JdbcConfig.java</code>类中了，此时就可以删除<code>bean.xml</code>了。</li>
<li>但是由于没有了配置文件，创建数据源<code>DataSource</code>的配置信息又写死在类中了。如何把它们分离出来呢？</li>
<li>答：<code>@PropertySource</code></li>
</ul>
</li>
</ol>
<hr>
<h4 id="4、-PropertySource"><a href="#4、-PropertySource" class="headerlink" title="4、@PropertySource"></a>4、@PropertySource</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>用于加载<code>xxx.properties</code>文件中的配置信息到内存中。</li>
<li>例如我们配置数据源时，就可以把连接数据库的信息写到<code>properties</code>配置文件中，就可以使用此注解指定<code>properties</code>配置文件的位置。</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>vlaue[]</code>：用于指定<code>properties</code>文件位置。如果配置文件在类路径下，需要写上：<strong>classpath：</strong>。</p>
</li>
<li><p><strong>示例代码</strong>：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.config;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接数据库的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span>	<span class="comment">// 指定配置文件的位置，并加载到容器中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>	<span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个DataSource，并存入spring容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">            ds.setDriverClass(driver);</span><br><span class="line">            ds.setJdbcUrl(url);</span><br><span class="line">            ds.setUser(username);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个QueryRunner对象，并存入spring容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queryRunner&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> QueryRunner <span class="title function_">createQueryRunner</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(dataSource);</span><br><span class="line">        <span class="keyword">return</span> queryRunner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*——————————————————————————————————————————————————————————————————————————————————————————*/</span></span><br><span class="line"></span><br><span class="line">jdbc.properties文件：</span><br><span class="line">    jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">    jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/db5</span></span><br><span class="line">    jdbc.username=root</span><br><span class="line">    jdbc.password=root</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  注意：此时，我们已经有了2个配置类：<code>SpringConfiguration.java</code>和<code>JdbcConfig.java</code>，但是它们之间还没有关系。如何建立它们之间的关系呢？</p>
</blockquote>
<ul>
<li>答：<code>@Import</code></li>
</ul>
<hr>
<h4 id="5、-Import"><a href="#5、-Import" class="headerlink" title="5、@Import"></a>5、@Import</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>用于导入其它配置类。【一个项目中可以有多个配置类】</li>
<li>如果不使用<code>@Import</code>注解，则所有配置类都必须通过添加 <code>@Configuration</code> 来表明自己是一个配置类。</li>
<li>如果使用<code>@Import</code>注解在主配置类中引入其它配置类时，子配置类中的<code>@Configuration</code>注解可以省略。当然，写上也没任何问题。</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>value[]</code>：用于指定子配置类的 Class 类对象。</p>
</li>
<li><p>示例代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring配置类，相当于bean.xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;cn.xsyu&quot;)</span></span><br><span class="line"><span class="meta">@Import(value = &#123;JdbcConfig.class&#125;)</span>		<span class="comment">// 导入`JdbcConfig`子配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>存在的问题</strong>：</p>
<ul>
<li>我们已经把要配置的都配置好了，但是有新的问题产生了，由于没有配置文件了，如何获取Spring容器呢？</li>
</ul>
</li>
</ol>
<h4 id="6、获取容器（注解）"><a href="#6、获取容器（注解）" class="headerlink" title="6、获取容器（注解）"></a>6、获取容器（注解）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);	<span class="comment">// 读取配置类就相当于读取配置文件</span></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h1><blockquote>
<p>  <strong>存在的问题</strong></p>
</blockquote>
<ul>
<li><p>在测试类中，每个测试方法都有以下2行代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取spring容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);</span><br><span class="line"><span class="comment">// 获取service层对象</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>这2行代码的作用是获取spring核心容器，如果不写的话，直接会出现空指针异常，所以又不能轻易删掉。</p>
</li>
</ul>
<blockquote>
<p>  <strong>解决思路</strong></p>
</blockquote>
<ul>
<li>针对上述问题，我们需要的是<strong>程序能自动帮助我们读取配置文件/配置类，并创建Spring容器</strong>。一旦程序能自动为我们创建 Spring 容器，我们就无需手动创建了，问题也自然就解决了。</li>
</ul>
<h2 id="1-junit单元测试的原理"><a href="#1-junit单元测试的原理" class="headerlink" title="1    junit单元测试的原理"></a>1    junit单元测试的原理</h2><ol>
<li>所有程序的入口：<ul>
<li><code>main</code>方法</li>
</ul>
</li>
<li>junit单元测试中，没有<code>main方法</code>也能执行的原理：<ul>
<li>junit单元测试集成了一个<code>main方法</code></li>
<li>该集成方法会判断当前测试类中哪些方法有<code>@Test</code>注解</li>
<li>junit就会让有<code>@Test</code>注解的方法执行。</li>
</ul>
</li>
<li>junit不会关注我们是否使用了<code>spring</code>框架。<ul>
<li>也就是说，在执行测试方法时，junit根本不知道我们是否使用了spring框架。</li>
<li>所以也就不会为我们读取配置文件/配置类，创建spring容器。</li>
</ul>
</li>
<li>由以上3点可知：<ul>
<li>当测试方法执行时，就算添加<code>@Autowired</code>注解，由于没有spring核心容器，也无法实现注入。</li>
</ul>
</li>
<li>解决方案：<ul>
<li>但是junit给我们提供了一个注解，让我们可以替换掉它的运行器。</li>
<li>只要把junit的运行器替换成可以自动读取配置文件，创建spring容器的运行器，就可以解决上述问题了。</li>
<li>Spring框架正好提供了一个运行器，可以<strong>自动</strong>读取配置文件/配置类来创建spring容器。我们只需要告诉它配置文件在哪里就行了。</li>
</ul>
</li>
</ol>
<h2 id="2-配置步骤"><a href="#2-配置步骤" class="headerlink" title="2    配置步骤"></a>2    配置步骤</h2><blockquote>
<p>  Spring整合Junit的配置：</p>
</blockquote>
<ol>
<li><p>导入spring整合Junit的jar(坐标)；</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>使用Junit提供的一个注解把替换原有运行器。</p>
<ul>
<li><code>@Runwith</code></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br></pre></td></tr></table></figure>

</li>
<li><p>告知Spring的运行器，spring的核心容器是基于XML还是注解的，并且说明位置。</p>
<ul>
<li><p><code>@ContextConfiguration</code></p>
<p>  属性：</p>
<ul>
<li><code>locations</code>：指定xml文件的位置。加上<code>classpath关键字</code>，表示在类路径下。</li>
<li><code>classes</code>：指定注解类所在的位置。</li>
</ul>
</li>
<li><p>示例代码</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="comment">// 或 @ContextConfiguration(locations = &#123;&quot;classpath:bean.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
<li><p>使用<code>@Autowired</code>和<code>@Qualifier</code>注解给测试类中的变量注入数据。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;    </span><br><span class="line">    <span class="comment">// 数据注入    </span></span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> UserService service;        </span><br><span class="line">    <span class="meta">@Test</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;        </span><br><span class="line">        <span class="comment">// 调用service层的方法        </span></span><br><span class="line">        List&lt;User&gt; users = service.findAll();        </span><br><span class="line">        <span class="comment">// 获取返回结果        </span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>当我们使用<code>spring 5.X</code>版本时，要求<code>junit</code>的jar必须是<code>12++</code></p>
</li>
</ol>
<hr>
<h1 id="Refresh-源码分析"><a href="#Refresh-源码分析" class="headerlink" title="Refresh 源码分析"></a>Refresh 源码分析</h1><p>refresh 的 12 个步骤</p>
<p><strong>一、准备工作</strong></p>
<ol>
<li> prepareRefresh——做好准备工作</li>
</ol>
<p><strong>二、创建和准备 BeanFactory（基础容器）</strong></p>
<ol start="2">
<li> obtainFreshBeanFactory——创建或获取空的 BeanFactory</li>
<li> prepareBeanFactory——准备 BeanFactory</li>
<li> postProcessBeanFactory——子类扩展 BeanFactory</li>
<li> invokeBeanFactoryPostProcessors——后处理器扩展 BeanFactory</li>
<li> registerBeanPostProcessors——准备 Bean 的后处理器</li>
</ol>
<p><strong>三、创建和准备 ApplicationContext（增强容器）</strong></p>
<ol start="7">
<li> initMessageSource——为 ApplicationContext提供国际化功能</li>
<li> initApplicationEventMulticaster——为ApplicationContext 提供事件发布器</li>
<li> onRefresh——留给子类扩展</li>
<li> registerListeners——为 ApplicationContext 准备监听器</li>
<li> <strong>finishBeanFactoryInitialization</strong>——初始化单例 Bean，执行 Bean 后处理器扩展</li>
<li> finishRefresh——准备生命周期管理器，发布 ContextRefreshed 事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1、prepareRefresh"><a href="#1、prepareRefresh" class="headerlink" title="1、prepareRefresh"></a>1、prepareRefresh</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002093938014.png" alt="image-20211002093938014"></p>
<blockquote>
<p>  <strong>prepareRefresh 方法的作用</strong></p>
</blockquote>
<ol>
<li> 创建（初始化）一个容器，这个容器刚被创建出来的时候是一个空的容器；</li>
<li> 创建（初始化）一个 Environment 对象加入到容器中。</li>
</ol>
<blockquote>
<p>  <strong>Environment 对象的作用</strong></p>
</blockquote>
<p>Environment 实例对象主要负责管理各种键值信息。主要包括：</p>
<ol>
<li> 系统属性的键值对形式（systemProperties）</li>
<li> 系统环境变量的键值对形式（systemEnvironment）</li>
<li>自定义的键值对属性（PropertySource）<ul>
<li>  一般是配置文件中的键值对属性。最常见的就是 SpringBoot 中 <code>application.properties</code> 配置文件，该配置文件中的所有配置信息都是由这个 environment 对象加载并保存的，然后再将这个 environment 实例对象加入到 ApplicationContext 中，容器就间接的知道了配置信息。</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>Environment 使用场景</strong></p>
</blockquote>
<ul>
<li>  Environment 的作用之一就是在 @Value 注解中，根据对应的键注入值，这个值就是从 Environment 中获取的。</li>
</ul>
<hr>
<h2 id="2、obtainFreshBeanFactory"><a href="#2、obtainFreshBeanFactory" class="headerlink" title="2、obtainFreshBeanFactory"></a>2、obtainFreshBeanFactory</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211001211518869.png" alt="image-20211001211518869"></p>
<blockquote>
<p>  <strong>obtainFreshBeanFactory 方法的作用：</strong></p>
</blockquote>
<ul>
<li>  创建（或获取）最新的 BeanFactory 对象。</li>
<li>  虽然 ApplicationContext 在结构上属于 BeanFactory 的子类，但实际上 ApplicationContext 类中包含了一个 BeanFactory ，因为在 ApplicationContext 中，有一些基础功能它并没有自己去实现，而是通过去复用 BeanFactory 内部现成的功能实现的。</li>
</ul>
<blockquote>
<p>  <strong>BeanDefinition</strong></p>
</blockquote>
<ul>
<li>  BeanDefinition 保存了具体对象的键值信息，单例还是多例、等等</li>
<li>  <strong>BeanDefinition 的来源：</strong>BeanDefinition 的来源有多种多样，可以通过 xml 获得、通过配置类获得、通过组件扫描获得、也可以通过编程添加。</li>
</ul>
<blockquote>
<p>  <strong>总结：</strong></p>
</blockquote>
<ul>
<li>  BeanFactory 的作用是负责 Bean 的创建、依赖注入和初始化；</li>
<li>  而 BeanDefinition 作为 Bean 的设计蓝图，则规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等；</li>
</ul>
<blockquote>
<p>  <strong>测试：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; 一开始&quot;</span>);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();  <span class="comment">// BeanFactory 的一个实现类</span></span><br><span class="line">        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames));</span><br><span class="line">        <span class="comment">// 刚创建好的 beanFactory 对象，内部是没有任何 BeanDefinition 信息的</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; （1）从 xml 中获取&quot;</span>);</span><br><span class="line">        <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">        reader.loadBeanDefinitions(<span class="string">&quot;myBean.xml&quot;</span>);   <span class="comment">// 从 xml 文件中获取 BeanDefinition 信息</span></span><br><span class="line">        String[] beanDefinitionNames1 = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames1));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; （2）从配置类中获取&quot;</span>);</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;myConfig&quot;</span>, BeanDefinitionBuilder.genericBeanDefinition(MyConfig.class).getBeanDefinition());  <span class="comment">// 将配置类加入到容器中</span></span><br><span class="line">        <span class="comment">// 通过后处理器，将配置类中还存在的其它对象也加入到容器中</span></span><br><span class="line">        <span class="type">ConfigurationClassPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassPostProcessor</span>();</span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(beanFactory);</span><br><span class="line">        String[] beanDefinitionNames2 = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; （3）扫描获取（包扫描）&quot;</span>);</span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(beanFactory);</span><br><span class="line">        scanner.scan(<span class="string">&quot;cn.xsyu&quot;</span>);    <span class="comment">// 指定要扫描的包</span></span><br><span class="line">        String[] beanDefinitionNames3 = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3、prepareBeanFactory"><a href="#3、prepareBeanFactory" class="headerlink" title="3、prepareBeanFactory"></a>3、prepareBeanFactory</h2><blockquote>
<p>  <strong>prepareBeanFactory 方法的作用</strong></p>
</blockquote>
<ol>
<li> 完善 BeanFactory ==&gt; 继续初始化 BeanFactory 中的成员变量</li>
<li> 解析 SpEL</li>
<li> 执行类型转换</li>
<li> 特殊 bean 的注入</li>
<li> 两个内置的 BeanPostProcessor 的作用</li>
</ol>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211001214801077.png" alt="image-20211001214801077"></p>
<ul>
<li>  上图中 BeanFactory 内部的变量，由白色变为绿色部分就是在 prepareBeanFactory 方法中进行变量初始化的。</li>
<li>  beanExpressResolver：解析 SpEL 表达式的</li>
<li>  propertyEditorRegistars：注册类型转换器（在值注入的时候可能会发生类型转换，比如 String 类型转为 Integer 类型等等）</li>
<li>  resolvableDependencies：管理特殊 bean 的一个 Map 结构，在 Spring 中，大部分的 bean 对象都被单例池（singletonObjects）所管理，但是还有一部分特殊对象，比如 BeanFactory 自身、或者 ApplicationContext 等等，这些对象并没有保存在单例池中，但是我们从使用者的角度来看，依然能够调用到它们，这是因为这些特殊对象被保存在 resolvableDependencies 对象池中</li>
<li>  beanPostProcessors：主要用于对 bean 创建时能够使用一些扩展功能。</li>
</ul>
<h2 id="4、postProcessBeanFactory"><a href="#4、postProcessBeanFactory" class="headerlink" title="4、postProcessBeanFactory"></a>4、postProcessBeanFactory</h2><blockquote>
<p>  <strong>postProcessBeanFactory 方法的作用</strong></p>
</blockquote>
<ul>
<li>  这一步是空实现，留给子类扩展</li>
<li>  掌握对应的设计模式：模板方法设计模式——主要的脉络都由父类规定死了，但是有一些可以扩展的方法留空了，留给子类去扩展。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  总结：</p>
</blockquote>
<p>一般 Web 环境下的 ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory。</p>
<hr>
<h2 id="5、invokeBeanFactoryPostProcessors"><a href="#5、invokeBeanFactoryPostProcessors" class="headerlink" title="5、invokeBeanFactoryPostProcessors"></a>5、invokeBeanFactoryPostProcessors</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211001221038451.png" alt="image-20211001221038451"></p>
<blockquote>
<p>  <strong>invokeBeanFactoryPostProcessors 方法的作用</strong></p>
</blockquote>
<p>beanFactory 有两个扩展点，</p>
<ul>
<li>  第一个扩展点就是在第 4 步提到的 postProcessBeanFactory ，在父类中没有具体的方法实现，交由子类进行扩展；</li>
<li>  第二个扩展点就是在第 5 步由 Bean 工厂的后处理器来进行扩展，主要用来补充或修改 BeanDefinition</li>
</ul>
<blockquote>
<p>  <strong>常见的 beanFactory 后处理器</strong></p>
</blockquote>
<ul>
<li>  ConfigurationClassPostProcessor：解析 @Configuration、@Bean、@Import、@PropertySource 等修饰的对象，并加载其 BeanDefinition 到 ApplicationContext 中</li>
</ul>
<blockquote>
<p>  <strong>总结：</strong></p>
</blockquote>
<ul>
<li>  beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition</li>
</ul>
<h2 id="6、registerBeanPostProcessors"><a href="#6、registerBeanPostProcessors" class="headerlink" title="6、registerBeanPostProcessors"></a>6、registerBeanPostProcessors</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002153102533.png" alt="image-20211002153102533"></p>
<ol>
<li> bean 的后处理器（第5步的是BeanFactory的后处理器）</li>
<li> 常见的 bean 后处理器</li>
</ol>
<p>在 BeanDefinitionMap 中查看是否有自定义的类实现了 BeanPostProcessors 接口，如果实现了就把这个自定义的类作为一个 bean 的后处理器注册到容器中，具体就是 beanPostProcessors 集合中去。</p>
<blockquote>
<p>  总结：</p>
</blockquote>
<ul>
<li>  bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段</li>
<li>常见的 bean 的后处理器<ul>
<li>  AutowiredAnnotationBeanPostProcessor，功能：解析 @Autowired，@Value 注解</li>
<li>  CommonAnnotationBeanPostProcessor，功能：解析 @Resource，@PostConstruct，@PreDestory 注解</li>
<li>  AnnotationAwareAspectJAutoProxyCreator，功能：为符合切点的目标 bean 自动创建代理</li>
</ul>
</li>
</ul>
<h2 id="7、initMessageSource"><a href="#7、initMessageSource" class="headerlink" title="7、initMessageSource"></a>7、initMessageSource</h2><p>从第 7 开始，回到 ApplicationContext 。</p>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002153624068.png" alt="image-20211002153624068"></p>
<ol>
<li> 新加入一个 MessageSource 对象，用于提供国际化功能。</li>
</ol>
<p>MessageSource 从哪里来？</p>
<ul>
<li>  在容器中 BeanDefinitionMap 中查找是否存在一个 messageSource 的 bean（实现了 MessageSource 接口的对象），如果没有，则提供空的 MessageSource 的实现（空实现就是不支持国际化）。</li>
</ul>
<h2 id="8、initApplicationEventMulticaster"><a href="#8、initApplicationEventMulticaster" class="headerlink" title="8、initApplicationEventMulticaster"></a>8、initApplicationEventMulticaster</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002153714170.png" alt="image-20211002153714170"></p>
<blockquote>
<p>  作用</p>
</blockquote>
<ul>
<li>  初始化一个事件广播器</li>
<li>  广播器的作用就是发送事件给监听器，将发生的事件发送给各个监听器对象</li>
<li>  监听器的作用是监听广播器发送的事件</li>
</ul>
<blockquote>
<p>  广播器从哪里来</p>
</blockquote>
<ul>
<li>  先去 BeanDefinitionMap 中找，如果能找到，则使用自定义的事件广播器</li>
<li>  如果没有提供，则使用默认的事件广播器</li>
<li>  广播器内部有一个集合，这个集合中维护了所有的监听器</li>
<li>  可以从容器中找名为 applicationEventMulticaster 的 bea 作为事件广播器，若没有，则会新建默认的事件广播器</li>
<li>  可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件</li>
</ul>
<blockquote>
<p>  如何发布事件</p>
</blockquote>
<h2 id="9、onRefresh"><a href="#9、onRefresh" class="headerlink" title="9、onRefresh"></a>9、onRefresh</h2><ul>
<li>  这一步是空实现，留给子类扩展</li>
<li>  掌握对应的设计模式——模板方法设计模式</li>
</ul>
<ul>
<li>  SpringBoot 中的子类可以在这里准备 WebServer，即内嵌 web 容器</li>
</ul>
<h2 id="10、registerListeners"><a href="#10、registerListeners" class="headerlink" title="10、registerListeners"></a>10、registerListeners</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002154659370.png" alt="image-20211002154659370"></p>
<ul>
<li>  注册监听器对象</li>
<li>  用来接收事件</li>
</ul>
<blockquote>
<p>  监听器从何而来</p>
</blockquote>
<ol>
<li> 通过编程事先添加</li>
<li> BeanDefinitionMap 中存在实现了 ApplicationListener 的接口，</li>
<li> 还有一部分来自于 @EventListenr 注解的解析</li>
</ol>
<p>会把容器中的监听器都找到，添加到对应的广播器的集合中去，当发生事件后，广播器就会发送消息给监听器</p>
<ul>
<li>  如何接收事件</li>
</ul>
<p>实现 ApplicationListener 接口，必须重写其中的 onApplicationEvent(E e) 方法，方法参数 E 就是监听的对象，当对象发生改变时，就会触发该方法，可以在该方法中编写具体的业务处理逻辑。</p>
<h2 id="11、finishBeanFactoryInitialization"><a href="#11、finishBeanFactoryInitialization" class="headerlink" title="11、finishBeanFactoryInitialization"></a>11、finishBeanFactoryInitialization</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002155343583.png" alt="image-20211002155343583"></p>
<ol>
<li> conversionService：用来做类型转换，作为对 propertyEditorRegister 的补充，都是类型转换，但是这个功能更加强大</li>
<li> embeddedValueResolvers：解析 <code>$&#123;&#125;</code>，对 Environment 进行再一次的封装，底层调用的还是 Environment 中的方法来完成对 <code>$&#123;&#125;</code> 的解析，只不过它是属于 BeanFactory 的成员方法。</li>
<li> singletonObjects：找到所有的非延迟创建的单例对象，创建对象并保存到单例池中</li>
</ol>
<blockquote>
<p>  总结</p>
</blockquote>
<ul>
<li>  conversionService 也是一套类型转换机制，作为对 PropertyEditor 的补充</li>
<li>  内嵌值解析器用来解析 @Value 中的 ${} ，借用的是 Environment 中的功能</li>
<li>  单例池用来缓存所有的单例对象，对象的创建都分为三个阶段，每一阶段都有不同的 bean 后处理器参与进来，进行功能上的扩展。</li>
</ul>
<h2 id="12、finishRefresh"><a href="#12、finishRefresh" class="headerlink" title="12、finishRefresh"></a>12、finishRefresh</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002160408973.png" alt="image-20211002160408973"></p>
<ol>
<li> 创建 lifecycleProcessor，生命周期处理器。</li>
<li> 发布 ContextRefreshed 事件，表示整个容器创建已经完成</li>
</ol>
<blockquote>
<p>  从哪来？</p>
</blockquote>
<ol>
<li> 先去 BeanDefinitionMap 中找，没有则创建一个默认的</li>
</ol>
<blockquote>
<p>  总结</p>
</blockquote>
<ol>
<li> 用来控制容器内，需要生命周期管理的 bean</li>
<li> 如果容器中有名为 lifecycleProcessor 的 bean 就用它，如果没有就创建默认的生命周期管理器。</li>
<li> 调用 applicationContext 的 start 方法，就可以触发所有实现了 LifeCycle 接口的 bean 的 start。（总控）</li>
<li> 调用 applicationContext 的 stop 方法，就可以触发所有实现了 LifeCycle 接口的 bean 的 stop。（总控）</li>
</ol>
<hr>
<h1 id="Spring-bean-的生命周期"><a href="#Spring-bean-的生命周期" class="headerlink" title="Spring bean 的生命周期"></a>Spring bean 的生命周期</h1><ul>
<li>  阶段1：别名解析，查询缓存</li>
<li>  阶段2：检查父工厂</li>
<li>  阶段3：检查 DependsOn</li>
<li>阶段4：按 Scope 创建 bean<ul>
<li>  创建 singleton</li>
<li>  创建 prototype</li>
<li>  创建其它 scope</li>
</ul>
</li>
<li>阶段5：创建 bean<ul>
<li>  创建 bean 实例</li>
<li>  依赖注入</li>
<li>  初始化</li>
<li>  登记可销毁 bean</li>
</ul>
</li>
<li>  阶段6：类型转换</li>
<li>  阶段7：销毁 bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doGetBean 是 bean 对象生命周期的起点</span></span><br><span class="line"><span class="comment">// AbstractBeanFactory#doGetBean</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br></pre></td></tr></table></figure>

<p>为什么 doGetBean 是 bean 对象生命周期的起点？</p>
<ul>
<li>  因为 Spring 容器中的 bean 都是一些懒加载的对象，只要在第一次获取这个对象的时候，才会触发该 bean 的创建过程，所以起点方法名叫做 doGetBean</li>
</ul>
<h2 id="阶段1：别名解析，查询缓存"><a href="#阶段1：别名解析，查询缓存" class="headerlink" title="阶段1：别名解析，查询缓存"></a>阶段1：别名解析，查询缓存</h2><ol>
<li><p><strong>别名解析</strong></p>
<ul>
<li>  在 Spring 中，一个 bean 可以有多个别名，而在创建对象的时候希望通过不同的别名能够找到同一个 bean 对象。所以首先就需要把别名解析为真实名称（全限定类名），然后再进行后续处理。</li>
</ul>
</li>
<li><p><strong>查询缓存</strong></p>
<ul>
<li>  根据全限定类名从缓存中查看是否已经有创建好的实例对象</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singletonObjects 是一级缓存，存放单例成品对象</span><br><span class="line">earlySingletonObjects 是二级缓存，存放单例工程的产品，可称为提前单例对象</span><br><span class="line">singleFactories 是三级缓存，存放单例工厂。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  二级和三级缓存主要为了解决循环依赖</p>
</blockquote>
<hr>
<h2 id="阶段2：处理父子容器"><a href="#阶段2：处理父子容器" class="headerlink" title="阶段2：处理父子容器"></a>阶段2：处理父子容器</h2><ul>
<li>  在阶段 1 中我们了解到，在获取对象时，首先从缓存中查找，如果缓存中存在，就直接从缓存中获取。那如果缓存中不存在就会直接创建 bean 对象吗？也不是！</li>
<li>  如果容器还有父容器，那么会先去父容器中查找，在父容器中如果能直接匹配到 bean 对象，创建对象的流程也会直接结束。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>  父、子容器中的 bean 名称可以重复</li>
<li>  优先查找子容器的 bean，找到了直接返回，找不到再继续到父容器中去查找。</li>
</ul>
<hr>
<h2 id="阶段3：dependsOn"><a href="#阶段3：dependsOn" class="headerlink" title="阶段3：dependsOn"></a>阶段3：dependsOn</h2><ul>
<li>  大部分 bean 之间是有依赖关系的，比如 A 依赖了 B，B 依赖了 C，那么在创建 A 对象的时候，必须保证先将 B 和 C 创建出来。</li>
<li>  但是有一些 bean 之间是没有依赖关系的，但是我们又想要控制这些 bean 的创建顺序，那么就需要用到 dependsOn。比如 A、B 两个对象间没有依赖关系，但是又希望 B 先于 A 创建，那么我们就需要设置 A dependsOn B，这样就能保证 B 一定先于 A 创建。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>  dependsOn 用于控制那些没有显式依赖的 bean 对象间的创建顺序</li>
</ul>
<h2 id="阶段4：按-Scope-创建-bean"><a href="#阶段4：按-Scope-创建-bean" class="headerlink" title="阶段4：按 Scope 创建 bean"></a>阶段4：按 Scope 创建 bean</h2><ul>
<li>  创建 singleton</li>
<li>  创建 prototype</li>
<li>  创建其它 scope</li>
</ul>
<h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSingletonScope</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    applicationContext.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">    applicationContext.registerBean(CommonAnnotationBeanPostProcessor.class);   <span class="comment">// 注册一个后处理器</span></span><br><span class="line">    applicationContext.refresh();   <span class="comment">// refresh方法在第11步底层就是调用了 getBean 方法 ==&gt; getBean 会调用 init 方法</span></span><br><span class="line">    applicationContext.close();     <span class="comment">// 当容器销毁的时候，就会调用 destroy 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrototypeScope</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    applicationContext.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class, bd -&gt; bd.setScope(<span class="string">&quot;prototype&quot;</span>));  <span class="comment">// 指定创建的对象为多例</span></span><br><span class="line">    applicationContext.registerBean(CommonAnnotationBeanPostProcessor.class);   <span class="comment">// 注册一个后处理器</span></span><br><span class="line">    applicationContext.refresh();   <span class="comment">// refresh方法在第11步底层就是调用了 getBean 方法 ==&gt; getBean 会调用 init 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 多例 bean 从首次 getBean 时才被创建，到调用 BeanFactory 的 destroyBean 方法销毁。（即如果只是单纯的refresh不会创建多例对象）*/</span></span><br><span class="line">    <span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> applicationContext.getBean(Bean2.class);</span><br><span class="line">    <span class="comment">/* 销毁方法也需要我们手动调用 */</span></span><br><span class="line">    applicationContext.getDefaultListableBeanFactory().destroyBean(bean2);</span><br><span class="line"></span><br><span class="line">    applicationContext.close();     <span class="comment">// 当容器销毁的时候，就会调用 destroy 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<ul>
<li>  scope 理解为从 xxx 范围内找这个 bean 更加贴切</li>
<li>  singleton 表示从单例池范围内获取 bean，如果没有，则创建并放入单例池。</li>
<li>  prototype 表示从不缓存 bean，每次都创建新的</li>
<li>  request 表示从 request 对象范围内获取 bean，如果没有，则创建并放入 request 中。</li>
</ul>
<h2 id="阶段5：创建-bean"><a href="#阶段5：创建-bean" class="headerlink" title="阶段5：创建 bean"></a>阶段5：创建 bean</h2><ul>
<li>  创建 bean 实例</li>
<li>  依赖注入</li>
<li>  初始化</li>
<li>  登记可销毁 bean</li>
</ul>
<p>146</p>
<h2 id="阶段6：类型转换"><a href="#阶段6：类型转换" class="headerlink" title="阶段6：类型转换"></a>阶段6：类型转换</h2><h2 id="阶段7：销毁-bean"><a href="#阶段7：销毁-bean" class="headerlink" title="阶段7：销毁 bean"></a>阶段7：销毁 bean</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/05/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/05/%E5%9B%BE/" class="post-title-link" itemprop="url">图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-05 11:19:45" itemprop="dateCreated datePublished" datetime="2021-08-05T11:19:45+08:00">2021-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-06 17:32:24" itemprop="dateModified" datetime="2021-08-06T17:32:24+08:00">2021-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="图是什么"><a href="#图是什么" class="headerlink" title="图是什么"></a>图是什么</h1><blockquote>
<p>  <strong>图 = 节点集合 + 边的集合</strong></p>
</blockquote>
<p>​        图是一种用来表示相连数据的数据结构，类似我们的社交网络，图中有很多的节点，每个节点代表一个数据，每个节点可以和其他节点相连。其中每个节点叫做<strong>顶点（vertex）</strong>，连接顶点之间的线叫做<strong>边（edge）</strong>。</p>
<p>​        下图就是一个用来表示社交网络的图数据结构：在此图中，我们含有 5 个顶点和 6 条相连线，每个顶点包含了人名，而连接线代表相连人名之间是朋友关系。</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph1.jpg" alt="img"></p>
<p>​        如果我们要更正式地表示图，那么图就可以用一对<strong>（V，E）集合</strong>来表示，其中 V 是一堆<strong>顶点的集合</strong>，而 E 是一堆<strong>边的集合</strong>，如下图所示：在此图中：<code>V = &#123;a, b, c, d, e&#125;，E = &#123;ab, ac, bd, cd, de&#125;</code></p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph2.jpg" alt="img"></p>
<p>上面提到的图是无向图，而常见的图有以下三种：</p>
<ol>
<li> <strong>无向图（Undirected Graph）</strong>：在无向图中，每个顶点和其他顶点通过边连接。</li>
<li> <strong>有向图（Directed Graph）</strong>：有向图中的边是有方向的。</li>
<li> <strong>权重图（Weighted Graph）</strong>：在权重图中，每条边有各自的权重。</li>
</ol>
<p>下图是有向图：此图可以用来表示用户之间相互关注的情况，如果Mark指向Alice，则代表Mark关注了Alice。</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph3.jpg" alt="img"></p>
<p>下图是权重图：此图可以用来表示两个好友之间的亲密程度，数值越高代表越亲密。</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph4.jpg" alt="img"></p>
<hr>
<h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>图有多种存储方式，常见的两种：一种是用<strong>矩阵（Matrix）</strong>的形式来实现，另一种是用<strong>链表（List）</strong>的形式来实现。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><img src="/2021/08/05/%E5%9B%BE/Graph5.png" alt="img"></p>
<p>每行代表相应的顶点，如果 <code>M[i][j] = 1</code>，那么就代表顶点 i 连向 j，如果是 0，则表达顶点间没有联系。用矩阵的方式来实现图的优势很明显，我们可以很快地判断两个顶点之间是否相连，可是用矩阵实现的空间复杂度很高，我们需要 <strong>O(V^2^)</strong> 来记录所有的数据，不管顶点之间是否有相连线。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>为了解决空间复杂度的问题，我们可以使用链表的方式来实现图：</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph6.png" alt="img"></p>
<p>在链表实现中，我们实际上使用了储存链表的数组来表示图，图的左侧用数组来实现，代表我们的所有顶点，而每个顶点含有一个链表，链表上储存了该顶点指向的顶点。</p>
<h1 id="图存储结构的代码实现（Java）"><a href="#图存储结构的代码实现（Java）" class="headerlink" title="图存储结构的代码实现（Java）"></a>图存储结构的代码实现（Java）</h1><h2 id="无向图的矩阵实现"><a href="#无向图的矩阵实现" class="headerlink" title="无向图的矩阵实现"></a>无向图的矩阵实现</h2><blockquote>
<p>  <strong>Graph.java</strong>：无向图的数据结构</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图</span></span><br><span class="line"><span class="comment"> *  1、图 = 节点集合 + 边的集合</span></span><br><span class="line"><span class="comment"> *  2、图的表示方法：①邻接矩阵（二维数组）  ②邻接表（链表形式）</span></span><br><span class="line"><span class="comment"> *     本例中我们采用邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="comment">// 节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;  <span class="comment">// 边的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; <span class="comment">// 表示边的数目【非必需】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化顶点集合和边的集合（矩阵）</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边（建立两个顶点之间的联系）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    起始顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    结束顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    边的权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向图而言，所有的边都是双向的，构造成的矩阵是一个对称矩阵，</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据下标得到对应的顶点数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到顶点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rows : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>测试类</strong></p>
</blockquote>
<img src="/2021/08/05/%E5%9B%BE/image-20210806153141817.png" alt="image-20210806153141817" style="zoom: 67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 12:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 顶点的个数</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        </span><br><span class="line">        String[] vertexes = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : vertexes) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 总共的边为：A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>执行结果</strong></p>
</blockquote>
<p><img src="/2021/08/05/%E5%9B%BE/image-20210805122136982.png" alt="image-20210805122136982"></p>
<hr>
<h1 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h1><blockquote>
<p>  <strong>思想</strong></p>
</blockquote>
<ol>
<li> 首先访问出发点 <strong>v</strong> ，并将其标记为已访问过；</li>
<li> 然后选取与 v 邻接的、未被访问的任意一个顶点 <strong>w</strong> ，并访问它；</li>
<li> 再选取与 w 邻接的未被访问的任一顶点并访问，以此重复进行；</li>
<li> 当一个顶点的所有邻接顶点都被访问过时，则依次退回到最近被访问过的顶点，若该顶点还有其它邻接顶点未被访问，则从这些未被访问的顶点中取一个并重复上述访问过程，直至图中所有顶点都被访问过为止。</li>
</ol>
<blockquote>
<p>  <strong>图示</strong></p>
</blockquote>
<p>下面以“有向图”为例，来对深度优先搜索进行演示：</p>
<img src="/2021/08/05/%E5%9B%BE/Graph7.png" alt="img" style="zoom:150%;">

<p>对于上面的图，我们从顶点A开始搜索：</p>
<img src="/2021/08/05/%E5%9B%BE/Graph8.png" alt="img" style="zoom: 150%;">



<p>以下是具体的遍历步骤：</p>
<blockquote>
<ol>
<li> 访问A</li>
<li> 访问B（在访问A之后，接下来应该访问的是A出发的另一个顶点，既顶点B）</li>
<li> 访问C（在访问B之后，接下来访问的是从B出发的另一个顶点，既C，E，F。在此图中，我们按照字母排序顺序访问，因此先访问C。）</li>
<li> 访问E（接下来访问与C连接的另一个顶点E。）</li>
<li> 访问D（接下来访问从E出发的顶点B和D，因为B已被访问过，所以访问顶点D。）</li>
<li> 访问F（接下来回溯“访问B的另一个连接顶点F”）</li>
<li> 访问G</li>
</ol>
</blockquote>
<p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G。</p>
<p>在图的深度优先搜索中，我们尽可能先遍历一个顶点可以达到的最深处，其中可能会出现的问题就是会有循环出现，所以我们需要一个数组来记录哪些节点已经被访问过。</p>
<blockquote>
<p>  <strong>代码实现</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图</span></span><br><span class="line"><span class="comment"> *  1、图 = 节点集合 + 边的集合</span></span><br><span class="line"><span class="comment"> *  2、图的表示方法：①邻接矩阵（二维数组）  ②邻接表（链表形式）</span></span><br><span class="line"><span class="comment"> *     本例中我们采用邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="comment">// 节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;  <span class="comment">// 边的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; <span class="comment">// 表示边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[] isVisited; <span class="comment">// 定义布尔型数组，记录某个节点是否被访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化节点集合和边的集合（矩阵）</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    边的起始顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    边的结束顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向图而言，构造成的矩阵是一个对称矩阵，所有的边都是双向的</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回顶点i对应的数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rows : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个顶点的深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 随机选择一个顶点作为深度优先遍历的起始顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">// 首先访问顶点 v 并输出</span></span><br><span class="line">        System.out.print(getValueByIndex(v) + <span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 将该节点设置为已访问过</span></span><br><span class="line">        isVisited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找与顶点 v 邻接的、未被访问的任意任一个顶点 w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getEffectiveNeighbor(v);</span><br><span class="line">        <span class="keyword">if</span> (w != -<span class="number">1</span>)&#123;   <span class="comment">// 说明存在邻接顶点未被访问</span></span><br><span class="line">            <span class="comment">// 递归地访问顶点 w</span></span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不存在满足条件的顶点 w，则说明顶点 v 已经遍历完毕了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找与与顶点 v 邻接的、未被访问的任一顶点 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEffectiveNeighbor</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][j] == <span class="number">1</span> &amp;&amp; isVisited[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 dfs 进行一个重载，完成整体图中所有的顶点的遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 isVisited 数组</span></span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的节点，进行 dfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h1><blockquote>
<p>  <strong>思想</strong></p>
</blockquote>
<ol>
<li> 首先访问起始顶点 v ，</li>
<li> 然后选取与 v 邻接的、未被访问过的全部顶点 w<del>1</del>，w<del>2</del>，…，w<del>n</del> 进行访问；</li>
<li> 再依次访问 w<del>1</del>，w<del>2</del>，…，w<del>n</del> 邻接的全部顶点（已访问过的除外）</li>
<li> 以此类推，直到所有顶点都被访问过了为止。</li>
</ol>
<blockquote>
<p>  <strong>主要步骤：</strong></p>
</blockquote>
<ol>
<li> 任取图中的一个顶点访问，入队，并将这个顶点标记为已访问；</li>
<li> 当队列不为空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队；</li>
<li> 当队列为空时跳出循环，广度优先搜索即完成。</li>
</ol>
<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jmx.remote.internal.ArrayQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图</span></span><br><span class="line"><span class="comment"> *  1、图 = 节点集合 + 边的集合</span></span><br><span class="line"><span class="comment"> *  2、图的表示方法：①邻接矩阵（二维数组）  ②邻接表（链表形式）</span></span><br><span class="line"><span class="comment"> *     本例中我们采用邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="comment">// 节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;  <span class="comment">// 边的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; <span class="comment">// 表示边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[] isVisited; <span class="comment">// 定义布尔型数组，记录某个节点是否被访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化节点集合和边的集合（矩阵）</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    边的起始顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    边的结束顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向图而言，构造成的矩阵是一个对称矩阵，所有的边都是双向的</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回顶点i对应的数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rows : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个顶点的深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 随机选择一个顶点作为深度优先遍历的起始顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">// 首先访问顶点 v 并输出</span></span><br><span class="line">        System.out.print(getValueByIndex(v) + <span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 将该节点设置为已访问过</span></span><br><span class="line">        isVisited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找与顶点 v 邻接的、未被访问的任意任一个顶点 w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getEffectiveNeighbor(v);</span><br><span class="line">        <span class="keyword">if</span> (w != -<span class="number">1</span>)&#123;   <span class="comment">// 说明存在邻接顶点未被访问</span></span><br><span class="line">            <span class="comment">// 递归地访问顶点 w</span></span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不存在满足条件的顶点 w，则说明顶点 v 已经遍历完毕了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找与与顶点 v 邻接的、未被访问的任一顶点 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEffectiveNeighbor</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][j] == <span class="number">1</span> &amp;&amp; isVisited[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 dfs 进行一个重载，完成整体图中所有的顶点的遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 isVisited 数组</span></span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的节点，进行 dfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对顶点 v 进行广度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        LinkedList&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、访问顶点 v 并输出</span></span><br><span class="line">        System.out.print(getValueByIndex(v) + <span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、将节点标记为已访问</span></span><br><span class="line">        isVisited[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 3、将顶点加入队列</span></span><br><span class="line">        queue.addLast(v);</span><br><span class="line">        <span class="comment">// 4、当队列不为空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队；</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出队头节点的下标 u，访问 u 的所有未被访问过的邻接节点</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">u</span> <span class="operator">=</span> (Integer) queue.removeFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="built_in">this</span>.getEffectiveNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>)&#123;    <span class="comment">// 证明顶点 u 存在未被访问过的邻接节点 w</span></span><br><span class="line">                System.out.print(getValueByIndex(w) + <span class="string">&quot;--&gt;&quot;</span>);   <span class="comment">//输出</span></span><br><span class="line">                isVisited[w] = <span class="literal">true</span>;    <span class="comment">// 标记为已访问</span></span><br><span class="line">                queue.addLast(w);   <span class="comment">// 入队</span></span><br><span class="line">                w = <span class="built_in">this</span>.getEffectiveNeighbor(u);   <span class="comment">// 更新 w 的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以下一个队头顶点 u 为起始顶点，查找其未被访问的所有邻接顶点（提现广度优先）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 bfs 进行一个重载，完成整体图中所有的顶点的遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                bfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>测试</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 12:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 节点的个数</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line"></span><br><span class="line">        String[] vertexes = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : vertexes) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 总共的边为：A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：dfs深度优先遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;深度优先遍历=================&quot;</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：bfs广度优先遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;广度优先遍历=================&quot;</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">JVM体系结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-02 22:47:30" itemprop="dateCreated datePublished" datetime="2021-08-02T22:47:30+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 09:53:06" itemprop="dateModified" datetime="2021-08-03T09:53:06+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><p>​        JVM 只是一个概念，而 <code>Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</code> 则是 JVM 的一个落地产品，HotSpot 是 Orecle 平台默认的 Java 虚拟机。常见的 JVM 的落地产品还有：JRockit、J9 等。</p>
<h2 id="1-HotSpot"><a href="#1-HotSpot" class="headerlink" title="1    HotSpot"></a>1    HotSpot</h2><p>​        在装有JDK的电脑上，输入 <code>java -version</code> 命令，会展示如下信息：</p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210416102603356.png"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_141&quot;</span>	</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>  <code>Java HotSpot(TM)</code>，是指<code>Java HotSpot</code>虚拟机，它是JVM的一个落地产品，TM 是 TradeMark，就是商标，就像苹果一样，是个牌子。</li>
<li>  <code>64-Bit</code> 指的是当前安装的虚拟机版本是64位，版本号为 <code>build 25.141-b15</code>，</li>
<li>  运行在<code>mixed mode</code>下，因为 Java 是一种办解释半编译型语言，<code>mixed mode</code> 代表混合模式。</li>
</ul>
</blockquote>
<hr>
<h2 id="2-Java——跨平台的语言"><a href="#2-Java——跨平台的语言" class="headerlink" title="2    Java——跨平台的语言"></a>2    Java——跨平台的语言</h2><p>Java 语言具有跨平台性！可以实现 <strong>write once，run anywhere</strong> ，一次编译，到处运行。</p>
<ol>
<li> Java 程序即开发人员编写的源代码文件；</li>
<li> 源代码文件首先会被编译成字节码文件；</li>
<li> 这些所有的字节码文件可以在任何安装了 JVM 虚拟机的平台上运行。</li>
</ol>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg"></p>
<hr>
<h2 id="3-JVM——跨语言的平台"><a href="#3-JVM——跨语言的平台" class="headerlink" title="3    JVM——跨语言的平台"></a>3    JVM——跨语言的平台</h2><p>​        JVM 并不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心<strong>字节码</strong>文件。 也就是说 <strong>JVM 拥有语言无关性</strong>，并不与 Java 语言绑定，只要其它编程语言的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其它的辅助信息，它就是一个有效的字节码文件，就能被 JVM 识别、装载和运行！</p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"></p>
<blockquote>
<ul>
<li><strong>字节码文件</strong> 可以是由不同的编程语言编译后形成的。</li>
<li>只要不同的编程语言通过各自的编译器编译形成的字节码文件遵循Java虚拟机的规范，就可以在Java虚拟机上解释运行！</li>
<li>也就是说，JVM 虚拟机并不强制要求开发的源代码是否是用Java语言实现的。</li>
</ul>
</blockquote>
<hr>
<h2 id="4-字节码"><a href="#4-字节码" class="headerlink" title="4    字节码"></a>4    字节码</h2><ul>
<li><p>我们一般讲的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说：任何能在 JVM 平台上执行的字节码格式都是一样的，所以应该统称为：<strong>JVM 字节码</strong></p>
</li>
<li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</p>
<p>  [比如要实现在控制台输出 “HelloWorld！” 的功能，我们可以通过 Java 语言实现也可以通过 Js 语言实现，这两种编程语言各自的源代码文件是不同的，分别是 <code>.java</code> 和 <code>.js</code>，但是通过各自的编译器编译成的 JVM 字节码文件就是一样的，也就是通过不同的编译器编译出相同的字节码文件。    当然，这个字节码文件也可以在不同的 JVM 虚拟机上运行]</p>
</li>
<li><p>Java 虚拟机 与 Java 语言并没有必然的联系，它只与特定的二进制文件格式——Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或称为字节码、Bytecodes）和符号表，还有一些其它辅助信息。</p>
</li>
</ul>
<h2 id="5-多语言混合编程"><a href="#5-多语言混合编程" class="headerlink" title="5    多语言混合编程"></a>5    多语言混合编程</h2><ul>
<li><p><em>Java 平台上的多语言混合编程正在成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</em></p>
</li>
<li><p>什么是多语言混合编程？</p>
<blockquote>
<p>在一个项目之中，并行处理用 Clojure 语言开发，展示层使用 JRuby/Rails 语言开发，中间层则用 Java 开发，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<strong>各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便透明，因为它们都运行在一个虚拟机上</strong>。</p>
</blockquote>
</li>
<li><p>能够实现这样一个组合的原因，是因为大家都能在 JVM 平台上运行。</p>
</li>
</ul>
<h2 id="6-虚拟机"><a href="#6-虚拟机" class="headerlink" title="6    虚拟机"></a>6    虚拟机</h2><ul>
<li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。</p>
</li>
<li><p>虚拟机的作用就是为程序提供一个运行环境，例如我们的JVM虚拟机就是给字节码文件提供一个运行环境，如果没有JVM虚拟机，就无法直接在Windows环境下运行字节码文件。</p>
</li>
<li><p>大体上，虚拟机可分为 <strong>系统虚拟机</strong> 和 <strong>程序虚拟机</strong>。</p>
<blockquote>
<p>常见的 Visual Box、VMware 就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</p>
<p>程序虚拟机的典型代表就是 Java 虚拟机，它专门为执行单个计算机程序而设计，在 Java 虚拟机中执行的指令被称为 Java 字节码指令。 </p>
</blockquote>
<p>  程序虚拟机只作用于某个特定的程序上，而系统虚拟机就相当于另一台电脑，在系统虚拟机中可以继续安装程序虚拟机。</p>
</li>
<li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
</li>
</ul>
<h2 id="7-Java-虚拟机"><a href="#7-Java-虚拟机" class="headerlink" title="7    Java 虚拟机"></a>7    Java 虚拟机</h2><ul>
<li><p>Java 虚拟机就是一台执行 JVM 字节码的虚拟计算机，它拥有独立的运行机制，其运行的字节码未必由 Java 语言编译而成。</p>
</li>
<li><p>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。</p>
</li>
<li><p>Java 技术的核心就是 Java 虚拟机（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机上。</p>
</li>
<li><p><strong>Java 虚拟机就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释/编译为对应操作系统上的机器指令执行。  每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数、怎么处理操作数、处理结果放在哪里。</p>
</li>
<li><p>特点</p>
<blockquote>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h2 id="8-JVM-的位置"><a href="#8-JVM-的位置" class="headerlink" title="8    JVM 的位置"></a>8    JVM 的位置</h2><ul>
<li>  JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</li>
</ul>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg"></p>
<ul>
<li></li>
</ul>
<h2 id="9-JVM-的整体结构"><a href="#9-JVM-的整体结构" class="headerlink" title="9    JVM 的整体结构"></a>9    JVM 的整体结构</h2><ul>
<li>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构。</li>
</ul>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg"></p>
<h3 id="Class-Loader-Subsystem"><a href="#Class-Loader-Subsystem" class="headerlink" title="Class Loader Subsystem"></a>Class Loader Subsystem</h3><blockquote>
<p><strong>类加载器子系统</strong></p>
</blockquote>
<ul>
<li>主要作用就是将 <code>.class</code> 字节码文件加载到<strong>内存</strong>中形成一个 Class 对象。</li>
</ul>
<h3 id="Runtime-Data-Area"><a href="#Runtime-Data-Area" class="headerlink" title="Runtime Data Area"></a>Runtime Data Area</h3><blockquote>
<p><strong>运行时数据区</strong></p>
</blockquote>
<ul>
<li>方法区 和 堆 是多线程共享的，</li>
<li>程序计数器、本地方法栈和虚拟机栈是每个线程独有一份的。</li>
</ul>
<h3 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h3><blockquote>
<p>执行引擎</p>
</blockquote>
<ul>
<li>主要作用就是将内存中 <code>.class</code> 字节码文件形成的 Class 对象编译成底层机器能够识别的机器指令。</li>
</ul>
<h2 id="10-Java-代码的执行流程"><a href="#10-Java-代码的执行流程" class="headerlink" title="10    Java 代码的执行流程"></a>10    Java 代码的执行流程</h2><p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210416190414894.png"></p>
<h2 id="11-JVM-的架构模型"><a href="#11-JVM-的架构模型" class="headerlink" title="11    JVM 的架构模型"></a>11    JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另一种指令集架构则是基于寄存器的指令集架构。</p>
<blockquote>
<p>  <strong>总结：</strong></p>
</blockquote>
<p><strong>由于跨平台的设计，Java 的指令都是根据栈来设计的。</strong>  不同平台 CPU 架构不同，所以不能设计为基于寄存器的。  优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>​           </p>
<h2 id="12-JVM-的生命周期"><a href="#12-JVM-的生命周期" class="headerlink" title="12    JVM 的生命周期"></a>12    JVM 的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java 虚拟机的启动是通过引导类加载器（BootStrap Class Loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机内部实现的。</p>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul>
<li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</li>
<li>程序开始执行它才运行，程序结束时它就停止。</li>
<li>执行一个所谓的 Java 程序的时候，真正执行的是一个叫做 Java 虚拟机的进程。</li>
</ul>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下几种情况：</p>
<ol>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到了异常或错误而异常终止。</li>
<li>由于操作系统出现错误而导致 Java 虚拟机进程终止。</li>
<li>某线程调用 Runtime 类或 System 类的 <code>exist</code> 方法，或 Runtime 类的 <code>halt</code> 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或写在 Java 虚拟机时，Java 虚拟机的退出情况。</li>
</ol>
<hr>
<h1 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h1><p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E8%8B%B1.jpg"></p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE-1621267020283.jpg" alt="第02章_JVM架构-简图"></p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E8%8B%B1-1621267020283.jpg" alt="第02章_JVM架构-英"></p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E4%B8%AD-1621267020284.jpg" alt="第02章_JVM架构-中"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-02 22:19:15" itemprop="dateCreated datePublished" datetime="2021-08-02T22:19:15+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 09:22:58" itemprop="dateModified" datetime="2021-08-03T09:22:58+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>排序算法稳定性小结：</strong></p>
</blockquote>
<p><strong>快些选一堆</strong>是不稳定的排序算法，其它都是稳定的！</p>
<ul>
<li>  快排</li>
<li>  希尔</li>
<li>  选择</li>
<li>  堆排</li>
</ul>
<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li> 选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</li>
<li> 从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。</li>
<li>找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的<br> 值才交换。</li>
<li> 直到 <strong>从前往后的比较索引&gt;从后往前比较的索引</strong>，结束第一次循环。</li>
<li> 此时，对于基准值来说，左边都比基准值小，右边都比基准值大，这个基准值就到达排序的最终位置了。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
