<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/10/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/10/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/06/AQS/" class="post-title-link" itemprop="url">AQS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-06 17:27:18" itemprop="dateCreated datePublished" datetime="2021-09-06T17:27:18+08:00">2021-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-13 10:17:35" itemprop="dateModified" datetime="2022-08-13T10:17:35+08:00">2022-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<ul>
<li>  AQS简介</li>
<li>  AQS数据结构</li>
<li>  资源共享模式</li>
<li>  AQS 源码分析</li>
<li>  释放资源</li>
</ul>
</blockquote>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><blockquote>
<ol>
<li> 公平锁和非公平锁</li>
<li> 可重入锁</li>
<li> LockSupport</li>
<li> 自旋锁</li>
<li> 数据结构链表</li>
<li> 设计模式——模板设计模式</li>
</ol>
</blockquote>
<hr>
<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="1-为什么学"><a href="#1-为什么学" class="headerlink" title="1    为什么学"></a>1    为什么学</h2><h3 id="1-1-重要性"><a href="#1-1-重要性" class="headerlink" title="1.1    重要性"></a>1.1    重要性</h3><ul>
<li>  JUC 底层原理就是 AQS，就相当于 JVM 之于 Java。</li>
<li>  AQS 是 JUC 内容中最重要的基石</li>
</ul>
<blockquote>
<p>  <strong>为什么需要 AQS ？</strong></p>
</blockquote>
<p>在不同的多线程场景中，往往需要使用不同的同步器（锁），如果为每一个同步器都实现一遍所有功能的话，虽然可以但并不方便，因为有一部分功能是所有子类同步器都需要实现的公共功能。而 AQS 就是这样一个抽象类，它里面包含了部分抽象方法，这些抽象方法的具体实现交给了子类（模板方法设计模式），还有一部分非抽象方法，这些方法是所有子类同步器都需要使用到的方法，并且无序子类重写。AQS 大大地减少了重复代码量，降低了代码耦合程度。</p>
<blockquote>
<p>  <strong>AQS 为什么是 JUC 内容中最重要的基石？</strong></p>
</blockquote>
<p>JUC 中和 AQS 有关的类：</p>
<ul>
<li>  Semaphore 信号量</li>
<li>  CyclicBarrier</li>
<li>  ReentrantLock</li>
<li>  CountDownLatch</li>
<li>  ReentrantReadWriteLock</li>
</ul>
<p>以上列举的几种类，虽然是不同的 API，但其内部都有一些共同的操作，例如加锁、释放锁。如果为每个 API 都重写一份功能实现的话，虽然可以，但并不划算。而 AQS 就是这样一个 API ，它把同步器（包括锁）中需要实现的功能抽取出来，在  AQS 中进行声明和简单逻辑的实现。这样子类同步器只需要实现 AQS 类，并实现 AQS 类中部分未实现的方法，就可以轻易的实现自定义的同步器。</p>
<ol>
<li> <strong>ReentrantLock</strong></li>
</ol>
<p><img src="/2021/09/06/AQS/image-20210716222211925.png" alt="image-20210716222211925"></p>
<ol start="2">
<li> <strong>CountDownLatch</strong></li>
</ol>
<p><img src="/2021/09/06/AQS/image-20210716222347766.png" alt="image-20210716222347766"></p>
<ol start="3">
<li> <strong>ReentrantReadWriteLock</strong></li>
</ol>
<p><img src="/2021/09/06/AQS/image-20210716222507442.png" alt="image-20210716222507442"></p>
<ol start="4">
<li> <strong>Semaphore</strong></li>
</ol>
<p><img src="/2021/09/06/AQS/image-20210716222601965.png" alt="image-20210716222601965"></p>
<h3 id="1-2-必要性"><a href="#1-2-必要性" class="headerlink" title="1.2    必要性"></a>1.2    必要性</h3><ul>
<li>  多线程环境下，为保证线程安访问共享资源时就会加锁，加锁就会导致抢不到锁的其它线程阻塞，如果有多个线程被阻塞后就需要对这些线程进行排队，实现排队必然需要队列（抢不到锁的线程被阻塞后就得去排队）。</li>
<li>  抢到锁的线程直接访问临界资源执行业务逻辑，抢不到锁的线程必然涉及一种排队等候机制。抢占锁失败的线程继续等待，但等候的线程仍保留获取锁的可能性。【在锁被前一个持有锁的线程释放后等待队列中的线程就有可能获取到锁】</li>
<li>  如果锁被占用，就需要一定的阻塞等待和唤醒机制来保证锁分配。这个机制主要是通过 CLH（CLH 是三个科学家的首字母缩写）队列的变体实现的，将暂时获取不到锁（被阻塞）的线程加入到等待队列中，这个队列就是 AQS 的抽象表现。它被阻塞的线程封装成一个个节点（Node）加入等待队列中，通过 CAS、自旋以及 <code>LockSupport#part()</code> 等方式，维护 state 变量的状态，使并发达到同步的控制效果。</li>
<li>  <strong>AQS 管理的是没有抢到锁的、将要被加入到阻塞队列的线程。</strong></li>
</ul>
<hr>
<h2 id="2-是什么"><a href="#2-是什么" class="headerlink" title="2    是什么"></a>2    是什么</h2><blockquote>
<p>  <strong>AQS；AbstractQueuedSynchronizer；抽象队列同步器</strong></p>
</blockquote>
<ul>
<li>  <strong>抽象</strong>：抽象类，只进行方法的声明和部分通用方法的实现，其余细节都交给子类去实现；</li>
<li>  <strong>队列</strong>：使用先进先出（FIFO）队列存储数据；</li>
<li>  <strong>同步</strong>：实现了同步的功能。</li>
</ul>
<h2 id="3-有什么用"><a href="#3-有什么用" class="headerlink" title="3    有什么用"></a>3    有什么用</h2><ul>
<li>  <strong>AQS 是用来构建锁或者其它同步器的基础框架</strong>。</li>
<li>  使用 AQS 能简单且高效地构造出应用广泛的同步器，比如我们学过的 ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 实现的。</li>
<li>  当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器，只要在子类中实现它的几个 <code>protected</code> 方法就可以了。</li>
</ul>
<blockquote>
<p>  <strong>锁和同步器的关系：</strong></p>
</blockquote>
<ul>
<li><p>  锁：面向锁的<strong>使用者</strong>。定义了程序员和锁交互的 API，隐藏了实现细节。</p>
</li>
<li><p>  同步器：面向锁的<strong>实现者</strong>，即怎样实现一个锁。提出了统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。</p>
</li>
</ul>
<hr>
<h2 id="4-AQS-数据结构"><a href="#4-AQS-数据结构" class="headerlink" title="4    AQS 数据结构"></a>4    AQS 数据结构</h2><ul>
<li><p>  AQS 内部通过一个 FIFO <strong>双端队列</strong>来完成资源获取线程的排队工作，</p>
</li>
<li><p>使用 <strong>volatile int state</strong> 变量作为资源的标识。同时定义了几个获取和改变 <code>state</code> 的 <code>protectd</code> 方法，子方法可以通过重写这些方法来实现自己的逻辑。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState()</span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure></li>
<li><p>  这 3 个方法均是原子操作，其中 <code>compareAndSetState</code> 的实现依赖于 Unsafe 的 <code>compareAndSwapInt()</code> 方法。</p>
</li>
<li><p>  AQS 类本身实现的是⼀些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针 <code>head</code> 和 <code>tail</code> 用于标识队列的头部和尾部。其数据结构如图：</p>
</li>
</ul>
<p><img src="/2021/09/06/AQS/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="AQS数据结构"></p>
<ul>
<li>  但它并不是直接储存线程，而是存储与线程绑定的 Node 节点。</li>
</ul>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<ul>
<li>  AQS 就是一个双向队列 + 一个 int 类型的变量 state</li>
<li>  <strong>AQS = 双向队列 + state</strong> </li>
</ul>
<hr>
<h3 id="4-1-AQS内部体系架构"><a href="#4-1-AQS内部体系架构" class="headerlink" title="4.1    AQS内部体系架构"></a>4.1    AQS内部体系架构</h3><p><img src="/2021/09/06/AQS/AbstractQueuedSynchronizer.png" alt="AbstractQueuedSynchronizer"></p>
<ul>
<li>  AQS 有两个内部类：<strong>ConditionObject</strong> 和 <strong>Node</strong></li>
<li>  Sync 实现了 AQS，NofairSync 和 FairSync 实现了 Sync，所以说它们两个也实现了 AQS</li>
<li>  Sync、NofairSync 和 FairSync 都是 ReentrantLock 的内部类，也即 Lock 的内部类</li>
</ul>
<hr>
<h2 id="5-AQS-成员变量"><a href="#5-AQS-成员变量" class="headerlink" title="5    AQS 成员变量"></a>5    AQS 成员变量</h2><h3 id="5-1-AQS-成员变量"><a href="#5-1-AQS-成员变量" class="headerlink" title="5.1    AQS 成员变量"></a>5.1    AQS 成员变量</h3><p><img src="/2021/09/06/AQS/image-20210717091946871.png" alt="image-20210717091946871"></p>
<ol>
<li><p>静态内部类 <strong>Node</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span>;	<span class="comment">// Node 节点是对线程的抽象，与线程绑定</span></span><br></pre></td></tr></table></figure></li>
<li><p>同步状态码 <strong>state</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;	<span class="comment">// 同步状态码，有3种状态。0 表示无人占用，1 表示有线程正在占用，大于 1 表示可重入锁。</span></span><br></pre></td></tr></table></figure></li>
<li><p>等待队列的头结点 <strong>head</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;	<span class="comment">// 等待队列中的头结点</span></span><br></pre></td></tr></table></figure></li>
<li><p>等待队列的尾节点 <strong>tail</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;	<span class="comment">// 等待队列中的尾节点</span></span><br></pre></td></tr></table></figure></li>
<li><p>AQS 的父类 AbstractOwnableSynchronizer 中的成员变量 <strong>exclusiveOwnerThread</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;	<span class="comment">// 独占线程的线程ID</span></span><br></pre></td></tr></table></figure></li>
<li><p> 静态内部类 ConditionObject</p>
</li>
<li><p> 其它</p>
</li>
</ol>
<hr>
<h3 id="5-2-静态内部类Node"><a href="#5-2-静态内部类Node" class="headerlink" title="5.2 静态内部类Node"></a>5.2 静态内部类Node</h3><h4 id="1、资源共享模式"><a href="#1、资源共享模式" class="headerlink" title="1、资源共享模式"></a>1、资源共享模式</h4><p>资源共享的两种模式：</p>
<ul>
<li>  独占模式（Exclusive）：单个线程独占资源，一次只能被一个线程获取。如 <code>ReentrantLock</code>。</li>
<li>  共享模式（Share）：资源可同时可以被多个线程获取，具体的资源个数可以通过参数指定。如 <code>Semaphore/CountDownLatch</code>。</li>
</ul>
<p>两种不同的共享模式分别用于实现不同的同步器（锁），即独占锁或者共享锁。</p>
<p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如 ReadWriteLock 。</p>
<p>AQS 中关于这两种资源共享模式的定义源码（均在内部类Node中）。</p>
<h4 id="2、AQS-Node-类源码"><a href="#2、AQS-Node-类源码" class="headerlink" title="2、AQS$Node 类源码"></a>2、AQS$Node 类源码</h4><h5 id="Node-类成员变量"><a href="#Node-类成员变量" class="headerlink" title="Node 类成员变量"></a>Node 类成员变量</h5><ol>
<li> 前驱节点 <strong>prev</strong></li>
<li> 后继节点 <strong>next</strong></li>
<li> 当前节点的等待状态 <strong>waitStatus</strong></li>
<li> 结点对应的线程 thread</li>
<li> 等待队列里下一个等待条件的结点 nextWaiter</li>
<li> 其它</li>
</ol>
<h5 id="Node-类小结"><a href="#Node-类小结" class="headerlink" title="Node 类小结"></a>Node 类小结</h5><ul>
<li>  <strong>Node = waitStatus + 前后指针</strong></li>
</ul>
<h5 id="AQS-Node-类源码："><a href="#AQS-Node-类源码：" class="headerlink" title="AQS$Node 类源码："></a>AQS$Node 类源码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">       <span class="comment">// 标记一个（线程）节点在共享模式下等待（节点与线程绑定）</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">       <span class="comment">// 标记一个（线程）节点在独占模式下等待（节点与线程绑定）</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">/* 小总结：</span></span><br><span class="line"><span class="comment">		1、只有进入等待队列的线程，才会给其分配一个节点与线程绑定。</span></span><br><span class="line"><span class="comment">		2、换言之就是，如果一个线程抢占到了资源，就无需再给这个线程绑定节点对象了</span></span><br><span class="line"><span class="comment">        */</span>		</span><br><span class="line"></span><br><span class="line">       <span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消，即从等待队列中移除</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">      	<span class="comment">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// waitStatus的值，表示该结点（对应的线程）在等待某⼀条件，当 Condition 条件满足时会被唤醒</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">   	<span class="comment">// waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点(共享模式下，同步获取状态将会无条件的传播下去)</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">       <span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1。初始值是0，</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">		</span><br><span class="line">       <span class="keyword">volatile</span> Node prev;	<span class="comment">// 前置节点</span></span><br><span class="line">       <span class="keyword">volatile</span> Node next;	<span class="comment">// 后继节点</span></span><br><span class="line">       <span class="keyword">volatile</span> Thread thread;	<span class="comment">// 结点对应的线程</span></span><br><span class="line">       Node nextWaiter; <span class="comment">// 等待队列⾥下一个等待条件的结点</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断共享模式的方法</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">return</span> <span class="variable">nextWaiter</span> <span class="operator">=</span>= SHARED;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 返回 node 节点的前驱节点，或抛出 NullPointerException</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev; <span class="comment">// 让节点p指向当前线程绑定的节点的前驱结点</span></span><br><span class="line">           <span class="comment">// 如果这个前驱节点为空，抛出异常；如果前驱节点不为空，返回这个前驱节点即可</span></span><br><span class="line">           <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">           <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">           <span class="built_in">this</span>.thread = thread;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">           <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">           <span class="built_in">this</span>.thread = thread;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：通过 Node 我们可以实现两个队列：</p>
<ul>
<li>  一是通过 <code>prev</code> 和 <code>next</code> 实现 CLH 队列（阻塞线程的等待队列，双向队列）；</li>
<li>  二是 <code>nextWaiter</code> 实现 Condition 条件上的等待线程队列（单向队列），这个 Condition 主要用在 ReentrantLock 类中。</li>
</ul>
<blockquote>
<p>  <strong>AQS 中的 addWaiter() 私有方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用了Node类的 Node(Thread thread, Node mode) 构造函数</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="6-AQS主要方法的源码解析"><a href="#6-AQS主要方法的源码解析" class="headerlink" title="6 AQS主要方法的源码解析"></a>6 AQS主要方法的源码解析</h2><p>AQS是基于<strong>模板方法模式</strong>设计的，它有一些方法是要求子类去实现的，主要包括：</p>
<ul>
<li><p>  <code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到 condition 时才需要去实现它。</p>
</li>
<li><p>  <code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false 。</p>
</li>
<li><p>  <code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false 。</p>
</li>
<li><p>  <code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
</li>
<li><p><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
<p>  这些方法虽然都是 protected 级别的方法，但并没有在 AQS 类中提供具体实现，而是直接抛出异常（模板设计模式：强制要求子类必须实现这个方法，否则抛出异常）。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 AQS 实现了⼀系列主要的逻辑。下⾯我们从源码来分析⼀下<strong>获取和释放资源的主要逻辑</strong>：</p>
<h3 id="6-1-获取资源"><a href="#6-1-获取资源" class="headerlink" title="6.1    获取资源"></a>6.1    获取资源</h3><p>获取资源的入口是 <strong>acquire(int arg)</strong> 方法。arg 是要获取的资源的个数，在独占模式下始终为 1。这个方法的逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li> 首先调用 <strong>tryAcquire(arg)</strong> 尝试去获取资源。【这个方法要由子类提供具体的实现】</li>
</ol>
</blockquote>
<ul>
<li>  如果尝试获取资源成功，<code>tryAcquire(arg)</code> 方法返回值 true，取反后是 false，直接退出当前方法，转去执行获取锁成功后的代码逻辑，也就不会再将当前线程封装成 Node 节点并加入等待队列了。</li>
<li>  如果获取资源失败，<code>tryAcquire(arg)</code> 方法返回值 false，取反后是 true，继续执行 <code>&amp;&amp;</code> 符号后面的方法。即通过 <strong>addWaiter(Node.EXCLUSIVE)</strong> 方法把这个线程封装成 Node 节点并插入到等待队列中。其中传入的参数代表要插入的 Node 是独占式的。这个方法的具体实现如下：</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>addWaiter(Node.EXCLUSIVE)</strong> 方法源码</li>
</ol>
</blockquote>
<ul>
<li>  方法介绍：将未获取到资源的线程封装到一个 Node 节点中，并追加到等待队列尾部。</li>
<li>  方法参数：接收一个指定模式（mode）的节点。（独占式 &amp; 共享式）</li>
<li>  返回值：返回值是追加到尾部的那个节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为当前线程新建一个Node节点并与线程绑定（独占式/共享式）</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	也就是说，如果线程获取资源成功，就不会被加入等待队列，自然也不会生成线程对应的Node节点。</span></span><br><span class="line"><span class="comment">    	换言之，只有线程获取资源不成功时，才会为当前线程新建一个对应模式的Node节点（这个节点绑</span></span><br><span class="line"><span class="comment">    	定一个线程），并将节点加入等待队列</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	将Node节点插入等待队列中，成为新的尾节点</span></span><br><span class="line"><span class="comment">    		1.让node节点的前驱节点指向旧的尾节点</span></span><br><span class="line"><span class="comment">    		2.更新旧的尾节点，让其指向当前节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail; <span class="comment">// 让当前node节点的前驱节点指向队尾节点。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	1、如果当前等待队列为空，则尾节点一定为 null，则 pred 指向 null，不进入if判断的代码块内</span></span><br><span class="line"><span class="comment">    	2、如果当前等待队列不为空，则尾节点一定不为null，则 pred 也不为 null，进入if判断的代码块内执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred; <span class="comment">// 让当前node节点的前驱节点指向当前队列的尾节点</span></span><br><span class="line">        <span class="comment">// 修改结果回写的时候要进行CAS比较，防止队列的尾节点被其它线程提前修改。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">            <span class="comment">// 如果CAS比较成功，让尾节点的next指针指向当前节点，尾插结束，返回被新插入的节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待队列为空或者上述CAS失败，继续使用CAS循环插入【因为上述的CAS只比较了一次，enq则是一个循环的CAS插入过程】</span></span><br><span class="line">    enq(node);	</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li> <strong>enq(node)</strong> 方法源码</li>
</ol>
</blockquote>
<ul>
<li>  方法介绍：使用循环 CAS 的方式将等待线程的节点对象插入等待队列</li>
<li>  循环 CAS 就叫做 <strong>自旋</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;	<span class="comment">// 拿到当前等待队列的尾节点</span></span><br><span class="line">        <span class="comment">// 如果尾节点为空（即队列为空），就新建一个空的头结点，并把当先线程绑定的node节点通过CAS的方式追加到新的头结点之后</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果尾节点不为空，就通过CAS的方式把当前线程节点node插入等待队列尾部</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) </span><br><span class="line">            &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li> <strong>小总结</strong></li>
</ol>
</blockquote>
<p>上面的两个函数⽐较好理解，就是在队列的尾部插入新的 Node 节点，但是需要注意的是由于 AQS 中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这⾥是通过 CAS 自旋的方式保证了操作的线程安全性。</p>
<p>OK，现在回到最开始的 <code>aquire(int arg)</code> 方法。现在通过 <code>addWaiter </code>方法，已经把⼀个 Node 放到等待队列尾部了。而处于等待队列中的结点是从头结点⼀个⼀个按顺序去获取资源的。具体的实现我们来看看 <strong>acquireQueued</strong> 方法</p>
<blockquote>
<ol start="5">
<li> **acquireQueued(final Node node, int arg) **方法源码</li>
</ol>
</blockquote>
<ul>
<li>  方法介绍：</li>
<li>方法参数：<ul>
<li>  node 节点是最新插入等待队列的节点，即等待队列中的最后一个节点。</li>
<li>  arg 是要获取的资源的个数，在独占模式下始终为 1。</li>
</ul>
</li>
<li>  返回值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); <span class="comment">// 获取node节点的前驱节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果node的前驱结点p是head，表示node是第⼆个结点，就可以尝试去获取资源了【因为第一个节点是无数据的节点，只标志队列的开始】</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) </span><br><span class="line">            &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="6-2-释放资源"><a href="#6-2-释放资源" class="headerlink" title="6.2    释放资源"></a>6.2    释放资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="AQS-原理概述（以-ReentrantLock-为例）"><a href="#AQS-原理概述（以-ReentrantLock-为例）" class="headerlink" title="AQS 原理概述（以 ReentrantLock 为例）"></a>AQS 原理概述（以 ReentrantLock 为例）</h1><h2 id="ReentrantLock-和-AQS-的关系"><a href="#ReentrantLock-和-AQS-的关系" class="headerlink" title="ReentrantLock 和 AQS 的关系"></a>ReentrantLock 和 AQS 的关系</h2><p><img src="/2021/09/06/AQS/ReentrantLock_AQS_01.png" alt="ReentrantLock_AQS_01"></p>
<p>ReentrantLock 类有一个内部类 Sync 继承了 AbstractQueuedSynchronizer 抽象类，说白了就是 ReentrantLock 中包含了一个 AQS 对象，AQS 对象是 ReentrantLock 实现加锁和释放锁的关键性核心组件。</p>
<h2 id="ReentrantLock-加锁和释放锁的底层原理"><a href="#ReentrantLock-加锁和释放锁的底层原理" class="headerlink" title="ReentrantLock 加锁和释放锁的底层原理"></a>ReentrantLock 加锁和释放锁的底层原理</h2><blockquote>
<ol>
<li> <strong>线程 T1 加锁</strong></li>
</ol>
</blockquote>
<p>如果现在有一个线程尝试调用 <code>ReentrantLock</code> 的 <code>lock()</code> 方法进行加锁，会发生什么事情呢？</p>
<p>很简单。这个 AQS 对象内部有一个核心变量 <code>private volatile int state</code>，代表了加锁的状态。初始状态下，<code>state == 0</code>，另外，这个 AQS 内部还有一个关键变量，用来记录当前加锁的是哪个线程，初始化状态下，这个变量是 null。</p>
<p><img src="/2021/09/06/AQS/ReentrantLock_AQS_01_1.png" alt="ReentrantLock_AQS_01_1"></p>
<p>接着线程 T1 调用 ReentrantLock#lock() 方法尝试进行加锁，这个加锁的过程，就是用 CAS 操作将 state 值从 0 变成 1。</p>
<p>如果 T1 之前没有其它线程加锁锁，那么 <code>state==0</code> 恒成立。此时线程 T1 就可以加锁成功。</p>
<p>一旦线程 T1 加锁成功后，就可以设置当前加锁线程是自己。如下图所示，就是线程 T1 加锁的过程。</p>
<p><img src="/2021/09/06/AQS/ReentrantLock_AQS_02.png" alt="ReentrantLock_AQS_02"></p>
<p>说白了，AQS 其实就是 JUC 包中的一个核心组件，里面有 <strong>state 变量</strong>、<strong>加锁线程变量</strong>等核心的东西，维护了加锁的状态。</p>
<p>而<strong>ReentrantLock 只是一个外层的 API，内核中的锁机制实现都是依赖于 AQS 组件的。</strong></p>
<p>ReentrantLock 顾名思义是一个可重入锁，即可以使用一个 ReentrantLock 对象执行多次 <code>lock()</code> 和 <code>unlock()</code> 方法。</p>
<p>那么 AQS 是如何实现可重入加锁的呢？线程 T1 每调用一次 <code>lock()</code> 方法，如果 CAS 比较发现 state != 0，接着会再判断当前加锁线程是不是自己，如果是就把 state 的值累加 1，其余不变。同理，调用 <code>unlock()</code> 释放锁的时候就是把 state 值累减 1。</p>
<blockquote>
<ol start="2">
<li> <strong>线程 T2 加锁</strong></li>
</ol>
</blockquote>
<p>如果线程 T1 加锁之后，线程 T2 想要争夺锁会怎么样？（<strong>互斥锁</strong>）</p>
<ol>
<li> 线程 T2 尝试获取锁，调用 <code>lock()</code> 方法，首先会去检查 <code>ReentrantLock.AQS.state</code> 变量是否为 0，发现不为 0，说明有线程正在使用锁，CAS 校验失败；</li>
<li> 接着线程 T2 会继续查看当前加锁的线程是不是自己，“<strong>加锁线程</strong>”这个变量明确记录了是线程 T1 占用了这个锁，所以此时线程 T2 会加锁失败。</li>
</ol>
<p><img src="/2021/09/06/AQS/ReentrantLock_AQS_03.png" alt="ReentrantLock_AQS_03"></p>
<blockquote>
<ol start="3">
<li> <strong>加锁失败</strong></li>
</ol>
</blockquote>
<p>接着，线程 T2 会将自己放入 AQS 的同步等待队列中，因为自己尝试加锁失败了，此时就要将自己放入等待队列中，直到线程 T1 释放锁之后，自己就可以重新尝试加锁了。</p>
<p>所以 AQS 内部还有一个同步等待队列，专门存放那些加锁失败的线程。</p>
<p><img src="/2021/09/06/AQS/ReentrantLock_AQS_03_02.png" alt="ReentrantLock_AQS_03_02"></p>
<blockquote>
<ol start="4">
<li> <strong>释放锁</strong></li>
</ol>
</blockquote>
<p>接着，线程 T1 在执行完自己的业务逻辑代码之后，就会释放锁。释放锁的过程非常简单，就是将 AQS 内的 state 变量的值递减 1，如果 state 为 0，则彻底释放锁，会将“加锁线程”变量的值也设置为 null。</p>
<blockquote>
<ol start="5">
<li> <strong>释放锁之后</strong></li>
</ol>
</blockquote>
<p>接下来，会从等待队列的队头唤醒线程 T2 重新尝试加锁。</p>
<p>线程 T2 重新尝试加锁，还是使用 CAS 操作将 state 从 0 变成 1，此时就会加锁成功，并将 state 设置为 1，同时把 “<strong>加锁线程”</strong> 设置为线程 T2 自己，同时线程 T2 从同步等待队列中出队。 </p>
<hr>
<h1 id="从-ReentrantLock-开始解读-AQS"><a href="#从-ReentrantLock-开始解读-AQS" class="headerlink" title="从 ReentrantLock 开始解读 AQS"></a>从 ReentrantLock 开始解读 AQS</h1><p>Lock 接口的实现类（如 ReentrantLock ），基本都是通过【聚合】了一个【队列同步器】的子类（sync ）完成线程访问控制的。</p>
<p><img src="/2021/09/06/AQS/ReentrantLock.png" alt="ReentrantLock"></p>
<p>ReentrantLock 类：</p>
<ol>
<li> 实现了 Lock 接口</li>
<li>包含一个内部抽象类 Sync<ul>
<li>  Sync 实现了 AbstractQueuedSynchronizer 接口</li>
<li>  Sync 包含两个实现类 FairSync 和 NonfairSync </li>
</ul>
</li>
</ol>
<p>对比公平锁和非公平锁的 tryAcquire() 方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少一个判断 hasQueuedPredecessors()。该方法中判断了是否需要排队，导致公平锁和非公平锁的差异如下：</p>
<p>公平锁：公平锁讲究先来后到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入到等待队列之中。</p>
<p>非公平锁：不管是否有等待队列，如果可以获取锁，就马上占有锁对象。也就是说等待队列中的第一个线程在 unpark() 之后还是需要 竞争锁（存在线程竞争锁的情况）</p>
<p><strong>整个 ReentrantLock 加锁（非公平）的过程可以分为三个阶段：</strong></p>
<ol>
<li> <strong>尝试加锁</strong>，加锁成功则正常调用资源</li>
<li> <strong>加锁失败，线程进入AQS队列</strong></li>
<li> <strong>线程进入队列后，进入阻塞状态</strong></li>
</ol>
<blockquote>
<p>  lock()</p>
<p>  acquire()</p>
<p>  tryAcquire(arg)</p>
<p>  addWaiter(Node.EXCLUSIVE)：将线程节点加入等待队列</p>
<p>  acquireQueued(addWaiter(Node.EXCLUSIVE)， arg)</p>
</blockquote>
<p>acquire(1) 表示占用 1 个</p>
<blockquote>
<ol>
<li> <strong>ReentrantLock 底层源码01</strong></li>
</ol>
</blockquote>
<p><img src="/2021/09/06/AQS/ReentrantLock%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%8101.png" alt="ReentrantLock底层源码01"></p>
<blockquote>
<ol start="2">
<li> <strong>公平锁和非公平锁的 tryAcquire() 方法</strong></li>
</ol>
</blockquote>
<p><img src="/2021/09/06/AQS/fair_nonfair$tryAcquire.png" alt="fair_nonfair$tryAcquire"></p>
<ul>
<li>  hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 reentrantLock.lock() 方法</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层调用的是 sync.lock(); 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sync 是 AQS 的一个静态抽象子类，包含两个实现类 FairSync 和 NonfairSync。</span></span><br><span class="line"><span class="comment">// 在 sync 中，lock 方法被声明为一个抽象方法，具体的方法实现包含在子类 FairSync 和 NonfairSync 中，我们以 ReentrantLock 默认的非公平锁 NonfairSync 为例。NonfairSync#lock 方法为：</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))	</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分支1：CAS 比较  state 的值是否为 0，如果为 0 则更新为 1，并设置锁的占用线程为当前线程。【锁对象空闲时】</span></span><br><span class="line"><span class="comment">// 分支2：在非公平锁中，即使发现锁对象被占用，也会调用 acquire(1) 方法尝试抢占锁。【锁对象已被占用】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来我们来看一下 acquire() 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;	</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;	</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tryAcquire(1) 方法：返回 true 表示加锁成功，返回 false 表示加锁失败。如果加锁成功，取反后为 false ，则不执行 &amp;&amp; 后面的方法。如果加锁失败，取反后为 true，则还需判断 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 方法的执行结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// addWaiter(Node.EXCLUSIVE) 方法</span></span><br><span class="line"><span class="comment">// acquireQueued(__, 1)) 方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>s</p>
<p><strong>tryAcquire()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryAcquire() 方法是一个顶级方法，具体的实现在其实现类中，我们选择了 NonfairSync#tryAcquire 方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;	 	<span class="comment">// tryAcquire(1)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonfairSync#tryAcquire</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;	<span class="comment">// tryAcquire(1)</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);		<span class="comment">// nonfairTryAcquire(1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回 true 表示加锁成功，false 表示加锁失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync#nonfairTryAcquire()</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分支1：如果 state==0（代表当前锁无线程占用），就更新 state 为 1，并设置锁对象的占用线程为为当前线程，返回 true；</span></span><br><span class="line"><span class="comment">// 分支2：state!=0，但是当前线程与锁对象绑定的线程相同（可重入锁），就将 state 累加 1，返回 true；</span></span><br><span class="line"><span class="comment">// 分支3：state!=0 &amp;&amp; 加锁线程！=当前线程，则说明加锁失败，返回 false</span></span><br></pre></td></tr></table></figure>



<p><strong>addWaiter(Node.EXCLUSIVE)</strong>  加强</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、将线程封装成 node 节点</span></span><br><span class="line"><span class="comment">// 2、Node 的</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;	<span class="comment">// 失败的标志位</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">//是否被打断的标志位。被打断与失败刚好是相反的。如果被打断一定失败</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果失败的标志位为 true，该线程就取消排队</span></span><br><span class="line">        <span class="keyword">if</span> (failed)	</span><br><span class="line">        &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>  调用 unpark 后线程才真正进入阻塞状态，之前虽然被连接到了等待队列中，但是仍然会总是尝试去 CAS 比较锁是否空闲，仍然想要去抢夺锁</li>
<li>  而调用 unpark 后，就不会再主动去监测锁是否空闲了，只有当持有锁的线程调用 unpark 方法唤醒后线程才会继续执行。</li>
<li>  【阻塞】</li>
</ul>
<h1 id="2021-10-08附加"><a href="#2021-10-08附加" class="headerlink" title="2021.10.08附加"></a>2021.10.08附加</h1><ol>
<li> AQS类内部</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">并查集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-30 09:55:15 / Modified: 16:19:23" itemprop="dateCreated datePublished" datetime="2021-08-30T09:55:15+08:00">2021-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  参考地址：力扣大佬</p>
<p>  链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/">https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/</a></p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>  并查集是一种数据结构</li>
<li>  并查集这三个字，一个字代表一个意思。</li>
<li>  <strong>并（Union）</strong>，代表合并</li>
<li>  <strong>查（Find）</strong>，代表查找</li>
<li>  <strong>集（Set）</strong>，代表这是一个以字典为基础的数据结构，它的基本功能是合并集合中的元素，查找集合中的元素</li>
<li>  并查集的典型应用是有关<strong>连通分量</strong>的问题</li>
</ul>
<hr>
<h2 id="并查集实现"><a href="#并查集实现" class="headerlink" title="并查集实现"></a>并查集实现</h2><blockquote>
<ol>
<li> <strong>数据结构</strong></li>
</ol>
</blockquote>
<ul>
<li>  并查集跟树有些类似，只不过它跟树是相反的。在树这个数据结构里面，每个节点会记录它的子节点。在并查集里，每个节点会记录它的父节点。</li>
<li>  通常用 Map 来实现这个结构，Map 的 K 表示当前节点，V 表示当前节点的父节点</li>
</ul>
<p><img src="/2021/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/1609980000-ofFjdW-%E5%B9%BB%E7%81%AF%E7%89%871.JPG" alt="幻灯片1.JPG"></p>
<p>可以看到，如果节点是相互连通的（从一个节点可以到达另一个节点），那么他们在同一棵树里，或者说在同一个集合里，或者说他们的<strong>祖先是相同的</strong>。</p>
<blockquote>
<ol start="2">
<li> <strong>初始化节点</strong></li>
</ol>
</blockquote>
<p>初始化时每个节点的父节点都为空，也就是说每个节点最初都是一个独立的子集</p>
<blockquote>
<ol start="3">
<li> <strong>合并两个节点</strong></li>
</ol>
</blockquote>
<ul>
<li>  如果发现两个节点是连通的（一般通过题目中给定的条件来判断两个节点是否连通），就把它们合并。</li>
<li>  合并就是设置两个节点的祖宗相同，可以把 A 节点的祖宗设置为 A、B 共同的祖宗或者把 B 节点的祖宗设置为 A、B 共同的祖宗。</li>
</ul>
<blockquote>
<ol start="4">
<li> <strong>判断两节点是否连通</strong></li>
</ol>
</blockquote>
<ul>
<li>  就是判断两个节点的祖先是否相同，相同处于同一连通分量中</li>
</ul>
<blockquote>
<ol start="5">
<li> <strong>查找祖宗（通用方法）</strong></li>
</ol>
</blockquote>
<ul>
<li>  如果该节点的父节点不为空，就一直迭代向上查找，直到找到某个节点的父节点为空</li>
</ul>
<h2 id="并查集基本模板代码-Java"><a href="#并查集基本模板代码-Java" class="headerlink" title="并查集基本模板代码(Java)"></a>并查集基本模板代码(Java)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.unionFind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/30 9:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并查集模板类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// K 表示当前节点，V表示当前节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、【初始化节点】当新加入一个节点时节点的父节点为空，即每个节点初始都是一个独立的子集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> newNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(newNode))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(newNode, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、【合并两个节点】如果两个节点是连通的，就把它们合并到一个子集中。</span></span><br><span class="line">    <span class="comment">// ==&gt; 就是设置祖先相同，可以把 A 子树的祖先作为两个节点共同的祖先，也可以把B子树作为两个节点共同的祖先</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB)	<span class="comment">// 只有当不在同一个连通分量中时才需要设置到一块去，如果已经在了就无需重复设置</span></span><br><span class="line">        &#123;</span><br><span class="line">            map.put(rootB, rootA);  <span class="comment">// 将 rootA 作为合并后的新的祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、【判断两个节点是否连通】就是判断两个节点是否有同一个祖先，如果有，则证明连通；否则不连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line">        <span class="keyword">return</span> rootA==rootB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、【查找祖先】通用功能，如果父节点不为空，就一直迭代向上查找，直到找到父节点为空的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (map.get(root) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 map.get(node) == null 时，返回 node 即可</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h2><h3 id="LeetCode547：省份数量"><a href="#LeetCode547：省份数量" class="headerlink" title="LeetCode547：省份数量"></a>LeetCode547：省份数量</h3><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="comment">// 共有 n 个城市，依次初始化，每次初始化新的城市就判断是否与已添加的城市相连，如果相连就将它们连接起来，最后统计一共有多少个连通分量</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;isConnected.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将 i 添加到 uf 中</span></span><br><span class="line">            uf.add(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果两个城市相连，就将它们并入一个连通分量</span></span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uf.merge(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 UnionFind 中增加一个方法用于统计连通分量</span></span><br><span class="line">        <span class="keyword">return</span> uf.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// K 表示当前节点，V表示当前节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连通分量个数。每新增一个节点连通分量个数就加一，每合并一次节点连通分量个数就减一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="built_in">this</span>.num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、【初始化节点】当新加入一个节点时节点的父节点为空，即每个节点初始都是一个独立的子集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> newNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(newNode))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(newNode, <span class="literal">null</span>);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、【合并两个节点】如果两个节点是连通的，就把它们合并到一个子集中。</span></span><br><span class="line">    <span class="comment">// ==&gt; 就是设置祖先相同，可以把 A 子树的祖先作为两个节点共同的祖先，也可以把B子树作为两个节点共同的祖先</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 当两个节点连通，且这两个节点不在同一个连通分量中时，才进行合并</span></span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(rootB, rootA);  <span class="comment">// 将 rootA 作为合并后的新的祖先</span></span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、【判断两个节点是否连通】就是判断两个节点是否有同一个祖先，如果有，则证明连通；否则不连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line">        <span class="keyword">return</span> rootA==rootB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、【查找祖先】通用功能，如果父节点不为空，就一直迭代向上查找，直到找到父节点为空的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (map.get(root) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 map.get(node) == null 时，返回 node 即可</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="LeetCode200：岛屿数量"><a href="#LeetCode200：岛屿数量" class="headerlink" title="LeetCode200：岛屿数量"></a>LeetCode200：岛屿数量</h3><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/30 12:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求岛屿的数量，可以转换为求连通分量的数量。可以考虑用并查集来求解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution200_02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] grid = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution200_02</span> <span class="variable">solution200</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution200_02</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> solution200.numIslands(grid);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*【特殊情况】*/</span></span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*【一般情况】</span></span><br><span class="line"><span class="comment">        *   1、从头到尾遍历：遇到“0”跳过，遇到 &quot;1&quot; 就并入集合。</span></span><br><span class="line"><span class="comment">        *   2、最终看有几个连通分量</span></span><br><span class="line"><span class="comment">        *   */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【首先把矩阵中所有陆地的数量统计出来，加入到集合中】</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uf.add(i*cols+j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="comment">//                    uf.add(i*cols+j);</span></span><br><span class="line">                    <span class="comment">// 查看上下左右是否可以并入并查集</span></span><br><span class="line">                    <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage((i-<span class="number">1</span>)*cols+j, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i+<span class="number">1</span> &lt; rows &amp;&amp; grid[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage((i+<span class="number">1</span>)*cols+j, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage(i*cols+j-<span class="number">1</span>, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j+<span class="number">1</span> &lt; cols &amp;&amp; grid[i][j+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage(i*cols+j+<span class="number">1</span>, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> num;   <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新加入的节点设置其父节点为 null</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(node))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(node, <span class="literal">null</span>);</span><br><span class="line">            num++;  <span class="comment">// 连通分量+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点合并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merage</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果两个节点之间是连通的，就将其合并，合并后连通分量的数目-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当两个节点连通，且这两个节点不在同一个连通分量中时，才进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(rootA != rootB)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(rootA, rootB);</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点的祖宗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span>(map.get(root) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/28/%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/28/%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="post-title-link" itemprop="url">回溯法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-28 16:13:17" itemprop="dateCreated datePublished" datetime="2021-08-28T16:13:17+08:00">2021-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-01 22:02:24" itemprop="dateModified" datetime="2021-10-01T22:02:24+08:00">2021-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  力扣大佬解释链接：</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></p>
<blockquote>
<p>  <strong>核心要义：</strong></p>
</blockquote>
<p><strong>集合的大小构成了树的宽度，递归的深度构成了树的深度。</strong></p>
<blockquote>
<p>  <strong>回溯法模板</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、方法名 || 返回值 || 参数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、终止条件</span></span><br><span class="line"><span class="keyword">if</span>(终止条件)</span><br><span class="line">&#123;</span><br><span class="line">    结果收集;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、回溯搜索 + 遍历【集合的大小构成了树的宽度，递归的深度构成了树的深度】</span></span><br><span class="line"><span class="keyword">for</span>(本层集合中的元素)</span><br><span class="line">&#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径, 选择列表);	<span class="comment">// 递归</span></span><br><span class="line">    回溯;	<span class="comment">// 撤销处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="回溯法常见题型"><a href="#回溯法常见题型" class="headerlink" title="回溯法常见题型"></a>回溯法常见题型</h1><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><ul>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></li>
</ul>
<blockquote>
<ol start="40">
<li> <strong>组合总和</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个数字只能使用一次</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先对数组进行排序，便于之后剪枝</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[len];  <span class="comment">// 用于标志数组中的元素是否使用过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        backtracking(startIndex, candidates, target, len, flag, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> len, <span class="type">boolean</span>[] flag, <span class="type">int</span> sum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 收集</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果是排序后的数组，那么相同的元素一定紧挨在一起，所以说如果第i个元素与第i-1个元素相等，那么它们得到的组合一定是重复的，这时候就可以跳过这个重复的元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>] &amp;&amp; flag[i-<span class="number">1</span>] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 path、sum、flag</span></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            backtracking(i+<span class="number">1</span>, candidates, target, len, flag, sum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组合总和中的去重问题：</strong></p>
<ul>
<li>  首先，要明确去重的概念，<strong>去重就是使用过的元素不能重复选取</strong>。</li>
<li>  组合问题可以抽象为树形结构，那么在“使用过”这个问题上，是可以抽象成两个维度的，<strong>一个维度是在同一树层上使用过，另一个维度是在同一树枝上使用过</strong>。</li>
<li>  在本题中，我们可以看到，元素在同一个组合内是可以重复的，但是最终结果内的任意两个组合是不能重复的。所以本题中的去重可以理解为：在同一树层间去重。【对同一树层去重的话，先要对数组中的元素进行排序】</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/26/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/26/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">约瑟夫环问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-26 17:13:36" itemprop="dateCreated datePublished" datetime="2021-08-26T17:13:36+08:00">2021-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-24 18:47:10" itemprop="dateModified" datetime="2021-09-24T18:47:10+08:00">2021-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  约瑟夫环问题</p>
</blockquote>
<blockquote>
<p>  <strong>LeetCode地址</strong></p>
</blockquote>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></li>
</ul>
<h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><blockquote>
<p>  <strong>分析</strong></p>
</blockquote>
<ol>
<li> 模拟：建立一个数组，里面存放的就是每个人的编号，一步一步模拟出队的过程，当出队了 n-1 次之后，数组中最后剩下的数字就是要求得的数字。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数组长度都设置为0，表示对应编号的人没有出局</span><br><span class="line">int n， int m	// 表示总共有n 人，数到m时出局</span><br><span class="line">int count	计数器</span><br><span class="line">int i = 0; 表示当前报数开始的编号（初始为0）</span><br><span class="line"></span><br><span class="line">// 只有当出局的人数小于 n 时循环才有必要继续</span><br><span class="line">while(count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="循环链表实现"><a href="#循环链表实现" class="headerlink" title="循环链表实现"></a>循环链表实现</h2><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" class="post-title-link" itemprop="url">数据结构——栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-25 10:07:36 / Modified: 10:39:56" itemprop="dateCreated datePublished" datetime="2021-08-25T10:07:36+08:00">2021-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="中缀-前缀-后缀-表达式之间的互相转换"><a href="#中缀-前缀-后缀-表达式之间的互相转换" class="headerlink" title="中缀 / 前缀 / 后缀 表达式之间的互相转换"></a>中缀 / 前缀 / 后缀 表达式之间的互相转换</h2><ul>
<li>  中缀表达式就是我们常见的算术表达式</li>
<li>  中缀表达式是由括号，而前缀和后缀表达式都是没有括号的。</li>
<li>  编译系统对算术表达式的处理是先把它转换为后缀表达式。所以<strong>计算机底层执行的是没有括号的后缀表达式</strong>。</li>
</ul>
<blockquote>
<p>  <strong>基本转换规则</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：a+b</span><br><span class="line">前缀表达式：+ab</span><br><span class="line">后缀表达式：ab+</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>中缀 –&gt; 前缀</strong></p>
</blockquote>
<ul>
<li>  基本转换规则中的每一部分都可以视为一个整体，中缀转前缀的手工转换写法就是把一个复杂的表达式划分成两部分，将符号部分提到数据后面即可。</li>
<li>步骤：<ol>
<li> 每一个表达式用括号括起来</li>
<li> 两个表达式中间的运算符提到括号前面</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：(a+b)*c+d-(e+g)*h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、将该中缀表达式分成两部分</span><br><span class="line">[(a+b)*c+d] - [(e+g)*h]</span><br><span class="line"><span class="number">2</span>、将运算符移动到最前端</span><br><span class="line">-[(a+b)*c+d]  [(e+g)*h]</span><br><span class="line"><span class="number">3</span>、再依次递归地拆分两个子表达式，同理也是将每个子表达式拆成两部分，将运算符提到最前面</span><br><span class="line">	(a+b)*c+d </span><br><span class="line">==&gt; ((a+b)*c)+d</span><br><span class="line">==&gt; +((a+b)*c) d</span><br><span class="line">==&gt; + * (a+b) <span class="type">c</span> <span class="variable">d</span></span><br><span class="line"><span class="operator">=</span>=&gt; + * + a b c <span class="title function_">d</span></span><br><span class="line">	</span><br><span class="line">	<span class="params">(e+g)</span>*h</span><br><span class="line">==&gt; * (e+g)h</span><br><span class="line">==&gt; * + egh</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、将三部分拼接起来</span><br><span class="line">-  +*+abcd  *+egh  ==&gt; -+*+abcd*+egh</span><br></pre></td></tr></table></figure>



<ul>
<li>  中缀转前缀表达式不是唯一的，因为交换律的存在。比如上面的例子中缀表达式可以拆分为 <code>[(a+b)*c] + [d-(e+g)*h]</code>，也可以拆分为 <code>[(a+b)*c+d] - [(e+g)*h]</code>，这样得到的前缀表达式就是不一样的，但是这两种都是正确的。</li>
</ul>
<blockquote>
<p>  <strong>中缀 –&gt; 后缀</strong></p>
</blockquote>
<ul>
<li>  中缀转后缀表达式的手工写法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：(a+b)*c+d-(e+g)*h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、给所有的子表达式都加上括号</span><br><span class="line">	(((a+b)*c)+d)-((e+g)*h)</span><br><span class="line"><span class="number">2</span>、遇到左括号跳过，遇到右括号就将子表达式的符号提到括号后面，并去掉括号</span><br><span class="line">	(((a+b)*c)+d)-((e+g)*h)</span><br><span class="line">==&gt; (((ab+)*c)+d)-((e+g)*h)</span><br><span class="line">==&gt; ((ab+c*)+d)-((e+g)*h)</span><br><span class="line">==&gt; (ab+c*d+)-((e+g)*h)</span><br><span class="line">==&gt; (ab+c*d+)((e+g)*h)-</span><br><span class="line">==&gt; (ab+c*d+)-((eg+)*h)</span><br><span class="line">==&gt; (ab+c*d+)-(eg+h*)</span><br><span class="line">==&gt; (ab+c*d+)(eg+h*)-</span><br><span class="line">==&gt; ab+c*d+eg+h*-</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">位运算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-17 10:58:27" itemprop="dateCreated datePublished" datetime="2021-08-17T10:58:27+08:00">2021-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-25 10:47:10" itemprop="dateModified" datetime="2021-10-25T10:47:10+08:00">2021-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><blockquote>
<p>  <strong>原码、反码、补码的关系</strong></p>
</blockquote>
<p><strong>正数：</strong></p>
<ul>
<li>  三码合一</li>
</ul>
<p><strong>负数：</strong></p>
<ul>
<li>  负数的反码是在其原码的基础上，符号位不变，其余各位取反。</li>
<li>  负数的补码是在反码的基础上+1</li>
</ul>
<hr>
<h1 id="1-位运算基本操作"><a href="#1-位运算基本操作" class="headerlink" title="1    位运算基本操作"></a>1    位运算基本操作</h1><blockquote>
<ul>
<li>  与：<code>&amp;</code></li>
<li>  或：<code>|</code></li>
<li>  异或：<code>^</code></li>
<li>  取反：<code>~</code></li>
<li>  左移：<code>&lt;&lt;</code></li>
<li>  右移：<code>&gt;&gt;</code></li>
<li>  无符号右移：<code>&gt;&gt;&gt;</code></li>
</ul>
</blockquote>
<h2 id="1-1-与、或、异或、取反"><a href="#1-1-与、或、异或、取反" class="headerlink" title="1.1    与、或、异或、取反"></a>1.1    与、或、异或、取反</h2><blockquote>
<p>  <strong>逻辑运算符 与 位运算符 中的 <code>&amp;</code> 和 <code>|</code></strong></p>
</blockquote>
<ul>
<li>  位运算符是对操作数的二进制位进行运算，操作数和计算结果都是<strong>整型</strong>；</li>
<li>  逻辑运算符的操作数和计算结果都是<strong>布尔类型</strong>。</li>
</ul>
<blockquote>
<p>  <strong>常用的位运算符</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">实例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移</td>
<td align="center"><code>4&lt;&lt;2</code></td>
<td align="center">16</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">右移</td>
<td align="center"><code>4&gt;&gt;1</code></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;&gt;</code></td>
<td align="center">无符号右移</td>
<td align="center"><code>4&gt;&gt;&gt;1</code></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="center">与</td>
<td align="center"><code>4 &amp; 2</code></td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">`</td>
<td align="center"><code>或</code></td>
<td align="center">` 4</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">异或</td>
<td align="center"><code>4 ^ 2</code></td>
<td align="center">6</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center">取反</td>
<td align="center"><code>-4</code></td>
<td align="center">-5</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>位运算符规则1</strong></p>
</blockquote>
<ul>
<li>  &amp; ：两个二进制位只有全为 1 时结果为 1 ，否则结果为 0 。</li>
<li>  | ：两个二进制位只要有一个为 1 那么结果就为 1 ，否则结果为 0 。</li>
<li>  ^ ：任何相同二进制位进行 ^ 运算，结果是 0；不相同二进制位 ^ 运算结果是 1 。【同0异1】</li>
<li>  ~ ：取反。0 变 1，1 变 0 。</li>
</ul>
<p><strong>助记</strong>：记忆 <code>&amp;</code> 和 <code>|</code> 时，可以类比的把 1 看做 TRUE，0 看做 FALSE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 和 1 之间的 &amp; 和 | 分别都有三种情况：</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 1 视为 true， 0 视为 false，则可得到如下转化关系</span></span><br><span class="line"><span class="literal">false</span> &amp; <span class="literal">false</span> = <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span> &amp; <span class="literal">true</span> = <span class="literal">false</span></span><br><span class="line"><span class="literal">true</span> &amp; <span class="literal">true</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，| 的三种情况为：</span></span><br><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">================</span><br><span class="line"><span class="literal">false</span> | <span class="literal">false</span> = <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span> | <span class="literal">true</span> = <span class="literal">true</span></span><br><span class="line"><span class="literal">true</span> | <span class="literal">true</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//与</span></span><br><span class="line">        System.out.println(<span class="number">3</span> &amp; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        System.out.println(<span class="number">3</span> | <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//异或</span></span><br><span class="line">        System.out.println(<span class="number">3</span> ^ <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//取反</span></span><br><span class="line">        System.out.println(~<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">-<span class="number">4</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>分析</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>） <span class="number">3</span> &amp; <span class="number">4</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 4的二进制</span></span><br><span class="line">	</span><br><span class="line">	&amp;运算：有<span class="number">0</span>则<span class="number">0</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		</span><br><span class="line">	&amp;</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br><span class="line">	------------------------------------------------</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">	结果是：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>） <span class="number">3</span> | <span class="number">4</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 4的二进制</span></span><br><span class="line">	</span><br><span class="line">	|运算：有<span class="number">1</span>则<span class="number">1</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		</span><br><span class="line">	&amp;</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br><span class="line">	------------------------------------------------</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000111</span></span><br><span class="line">	结果是：<span class="number">7</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span>） <span class="number">3</span> ^ <span class="number">4</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 4的二进制</span></span><br><span class="line">	</span><br><span class="line">	^运算：相同为<span class="number">0</span>，不同为<span class="number">1</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		</span><br><span class="line">	&amp;</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br><span class="line">	------------------------------------------------</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000111</span></span><br><span class="line">	结果是：<span class="number">7</span></span><br></pre></td></tr></table></figure>





<h2 id="1-2-左移和右移"><a href="#1-2-左移和右移" class="headerlink" title="1.2    左移和右移"></a>1.2    左移和右移</h2><h3 id="1-2-1-左移"><a href="#1-2-1-左移" class="headerlink" title="1.2.1    左移"></a>1.2.1    左移</h3><blockquote>
<p>  <strong>语法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 &lt;&lt; 位数</span><br></pre></td></tr></table></figure>

<p>将符号左边的操作数左移指定的位数。</p>
<ul>
<li>  首先将左边的操作数转为二进制。</li>
<li>  然后按照要求左移指定位数，左边最高位丢弃，右边补齐0。</li>
</ul>
<blockquote>
<p>  <strong>例子：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> &lt;&lt; <span class="number">2</span></span><br><span class="line"><span class="comment">// 3的二进制：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span></span><br><span class="line"><span class="comment">// 左移2位，左边最高位丢弃，右边补齐0：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001100</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-右移"><a href="#1-2-2-右移" class="headerlink" title="1.2.2    右移"></a>1.2.2    右移</h3><blockquote>
<p>  <strong>语法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 &gt;&gt; 位数</span><br></pre></td></tr></table></figure>

<p>将符号左边的操作数右移指定的位数。</p>
<ul>
<li>  首先将左边的操作数转为二进制。</li>
<li>  然后按照要求右移指定位数，<strong>最高位为 0，左边补齐 0；最高为为 1，左边补齐 1</strong>。</li>
</ul>
<blockquote>
<p>  <strong>例子：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 24的二进制：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span></span><br><span class="line"><span class="comment">// 右移2位，最高位是0，左边补齐0；最高位是1，左边补齐1：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000110</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-3-无符号数右移"><a href="#1-2-3-无符号数右移" class="headerlink" title="1.2.3    无符号数右移"></a>1.2.3    无符号数右移</h3><blockquote>
<p>  <strong>语法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 &gt;&gt;&gt; 拉数</span><br></pre></td></tr></table></figure>

<p>将符号左边的操作数右移指定的位数。</p>
<ul>
<li>  首先将左边的操作数转为二进制。</li>
<li>  然后按照要求右移指定位数，<strong>无论最高位是 0 还是 1 左边补齐 0</strong>。</li>
</ul>
<h3 id="1-2-4-程序测试"><a href="#1-2-4-程序测试" class="headerlink" title="1.2.4    程序测试"></a>1.2.4    程序测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	位运算测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// &lt;&lt; 左移1位即左边数乘以2的1次方，左移2位即左边数乘以2的2次方，以此类推</span></span><br><span class="line">		System.out.println(<span class="number">3</span> &lt;&lt; <span class="number">2</span>); </span><br><span class="line">		<span class="comment">// &gt;&gt; 右移1位即左边数除以2的1次方，右移2位即左边数除以2的2次方，以此类推</span></span><br><span class="line">		System.out.println(<span class="number">24</span> &gt;&gt; <span class="number">2</span>); </span><br><span class="line">		<span class="comment">// 负数转成二进制要用补码，最终将补码右移，再转成原码</span></span><br><span class="line">		System.out.println(-<span class="number">24</span> &gt;&gt; <span class="number">2</span>); </span><br><span class="line">		<span class="comment">// 无符号数右移无论最高位是0还是1左边都补齐0</span></span><br><span class="line">		System.out.println(<span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">		System.out.println(-<span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">-<span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1073741818</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>） <span class="number">3</span>&lt;&lt;<span class="number">2</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	左移两位</span><br><span class="line">    <span class="number">00000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0000001100</span></span><br><span class="line">	结果是：<span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>） <span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">    计算出<span class="number">24</span>的二进制码如下（计算机中所有数据都以补码的形式保存）：</span><br><span class="line">    正数的补码与原码相同！</span><br><span class="line"> </span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 原码 </span></span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 补码</span></span><br><span class="line"></span><br><span class="line">	补码右移<span class="number">2</span>位，左边补<span class="number">0</span></span><br><span class="line">	<span class="number">0000000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000110</span>	</span><br><span class="line">	结果是：<span class="number">6</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span>） -<span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">    负数的补码等于反码 +<span class="number">1</span></span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 原码 </span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100111</span>		<span class="comment">// 反码</span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11101000</span>		<span class="comment">// 补码</span></span><br><span class="line">	补码右移两位，左边补<span class="number">1</span></span><br><span class="line">    <span class="number">1111111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111010</span></span><br><span class="line">	</span><br><span class="line">    得到右移的结果后，存储到计算机中的仍然是补码，开发人员在判断时还需要将补码转为原码</span><br><span class="line">    原码 = （补码 - <span class="number">1</span>） + 取反</span><br><span class="line">    </span><br><span class="line">    <span class="number">1111111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111001</span>		<span class="comment">// 减一操作</span></span><br><span class="line">    <span class="number">1000000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000110</span>		<span class="comment">// 取反(符号位不变)</span></span><br><span class="line">    结果是：-<span class="number">6</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>） <span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">    无符号右移，由于 <span class="number">24</span> 为正数，其方法等价于 <span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">    结果是：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="number">5</span>） -<span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">    计算出 -<span class="number">24</span> 的补码如下</span><br><span class="line">    <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 原码 </span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100111</span>		<span class="comment">// 反码</span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11101000</span>		<span class="comment">// 补码</span></span><br><span class="line">    右移两位，无论最高位是<span class="number">0</span>还是<span class="number">1</span>，左边补<span class="number">0</span></span><br><span class="line">    <span class="number">0011111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111010</span></span><br><span class="line">    对于正数来说，补码与原码相同</span><br><span class="line">    结果：</span><br><span class="line">    将二进制 <span class="number">0011111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111010</span> 转换为十进制的结果是：<span class="number">1073741818</span></span><br></pre></td></tr></table></figure>





<h3 id="1-2-5-总结（重要）"><a href="#1-2-5-总结（重要）" class="headerlink" title="1.2.5    总结（重要）"></a>1.2.5    总结（重要）</h3><p>在位运算中</p>
<ul>
<li>  <code>&lt;&lt;</code> 左移 1 位即左边数乘以 2^1^ ，左移2位即左边数乘以2^2^ ，以此类推。</li>
<li>  <code>&gt;&gt;</code> 右移 1 位即左边数除以 2^1^ ，右移2位即左边数除以2^2^ ，以此类推。</li>
</ul>
<hr>
<h1 id="2-位运算应用"><a href="#2-位运算应用" class="headerlink" title="2    位运算应用"></a>2    位运算应用</h1><h2 id="2-1-奇偶判断"><a href="#2-1-奇偶判断" class="headerlink" title="2.1    奇偶判断"></a>2.1    奇偶判断</h2><ul>
<li>  位运算是直接操作二进制位，效率较高，一些算法会采用位运算。</li>
<li>  奇偶判断是判断一个是奇数还是偶数，如何使用位运算实现呢？</li>
</ul>
<blockquote>
<p>  <strong>原理：</strong></p>
</blockquote>
<ol>
<li> 位运算。&amp; 运算的特点是：两个二进制位只要有一个为 0 那么结果就为 0，否则结果为 1。</li>
<li> <strong>二进制的最低位为 1 一定是奇数，为 0 则一定是偶数</strong>，我们让某个数和 1 进行与运算，结果为 1 则是奇数，为 0 则是偶数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int i = 6;</span><br><span class="line">int j = 7;</span><br><span class="line">// 对应的二进制</span><br><span class="line">6	0110</span><br><span class="line">7	0111</span><br><span class="line"></span><br><span class="line">原理解释：二进制的最低位为 1 一定是奇数，为 0 则一定是偶数</span><br><span class="line">7 = 0111 = 1*2^0 + 1*2^1 + 1*2^2 + 0*2^3 + ...</span><br><span class="line">6 = 0110 = 0*2^0 + 1*2^1 + 1*2^2 + 0*2^3 + ...</span><br><span class="line">除了最低位外，其余每位上的数都是2的倍数。也就是说，除了最低位外，</span><br><span class="line">其余数都是偶数，两个偶数之和还是偶数，所以每个二进制数是奇数还是</span><br><span class="line">偶数是由最低位决定的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 奇偶判断的方法：让这个数和 1 相与（&amp;）</span><br><span class="line">1） 6 &amp; 1 = 0</span><br><span class="line">	0110</span><br><span class="line">	0001</span><br><span class="line">	-------</span><br><span class="line">	0000	==&gt; 结果是 0</span><br><span class="line"></span><br><span class="line">2） 7 &amp; 1 = 1</span><br><span class="line">	0111</span><br><span class="line">	0001</span><br><span class="line">	-------</span><br><span class="line">	0001	==&gt; 结果是 1</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="comment">//和1与运算，结果为1则为奇数</span></span><br><span class="line">        System.out.println(x &amp; a);</span><br><span class="line">        <span class="comment">//和1与运算，结果为0则为偶数</span></span><br><span class="line">        System.out.println(y &amp; a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-2-两数交换"><a href="#2-2-两数交换" class="headerlink" title="2.2    两数交换"></a>2.2    两数交换</h2><blockquote>
<p>  <strong>不用二进制实现两数交换</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//======交换两个数方法1：使用中间变量======</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = tmp;</span><br><span class="line">        </span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>使用二进制的异或运算实现两数交换</strong></p>
</blockquote>
<ul>
<li>  <strong>原理</strong>：一个数对自己异或一次，再异或另一个数，结果为另一个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">5</span>, n = <span class="number">10</span>;</span><br><span class="line"><span class="number">0000</span> <span class="number">0101</span>	<span class="comment">// m</span></span><br><span class="line"><span class="number">0000</span> <span class="number">1010</span>	<span class="comment">// n</span></span><br><span class="line"></span><br><span class="line">m^m</span><br><span class="line">    <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">    <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">    ------------</span><br><span class="line">    <span class="number">0000</span> <span class="number">0000</span>  ==&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">m^m^n</span><br><span class="line">	<span class="number">0000</span> <span class="number">0000</span> </span><br><span class="line">	<span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">	---------------</span><br><span class="line">	<span class="number">0000</span> <span class="number">1010</span>	==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//======交换两个数方法2：使用异或运算======</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="comment">// 先测试异或运算的特点 </span></span><br><span class="line">		<span class="comment">// 一个数对自己异或一次，再异或另一个数，结果为另一个数</span></span><br><span class="line">		System.out.println(m ^ m ^ n); 	<span class="comment">// m变成了n，输出10</span></span><br><span class="line">		System.out.println(n ^ n ^ m ); <span class="comment">// n变成了m，输出5</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 下边通过异或交换变量的值</span></span><br><span class="line">		<span class="comment">// 下边是m和n没有交换之前的异或，存入m</span></span><br><span class="line">		m = m ^ n ;</span><br><span class="line">		<span class="comment">//下边的赋值语句相当于n=m ^ n ^ n，将m的值赋值给了n</span></span><br><span class="line">		n = m ^ n ;</span><br><span class="line">		<span class="comment">//此时n的值为m，所以m ^ n即m ^ m ^  n ，将n的值赋值给了m</span></span><br><span class="line">		m = m ^ n ;</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		System.out.println(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用二进制的好处：<ol>
<li> 不用额外创建空间保存临时变量；</li>
<li> 使用二进制数据进行运算，执行速度较快。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="3-位运算常见的规律（LeetCode刷题常用）"><a href="#3-位运算常见的规律（LeetCode刷题常用）" class="headerlink" title="3    位运算常见的规律（LeetCode刷题常用）"></a>3    位运算常见的规律（LeetCode刷题常用）</h1><h2 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h2><p>在位运算中</p>
<ul>
<li>  <code>&lt;&lt;</code> 左移 1 位即左边数乘以 2^1^ ，左移2位即左边数乘以2^2^ ，以此类推。</li>
<li>  <code>&gt;&gt;</code> 右移 1 位即左边数除以 2^1^ ，右移2位即左边数除以2^2^ ，以此类推。</li>
</ul>
<h2 id="与（-amp-）运算"><a href="#与（-amp-）运算" class="headerlink" title="与（&amp;）运算"></a>与（&amp;）运算</h2><blockquote>
<p>  <strong>任意数 和 1 相与（&amp;）</strong></p>
</blockquote>
<ul>
<li>任意数 和 1 相与（&amp;），结果为 1 是奇数，结果为 0 是偶数。</li>
</ul>
<blockquote>
<p>  <strong>n &amp; (n-1)</strong></p>
</blockquote>
<ul>
<li>  n 和 (n−1) 解析：（n-1）就是将二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。</li>
<li>  <code>n &amp; (n - 1)</code> 解析：<code>n &amp; (n - 1)</code> 就是将二进制数字 n 最右边的 1 变成 0 ，其余不变。</li>
</ul>
<p><img src="/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/9bc8ab7ba242888d5291770d35ef749ae76ee2f1a51d31d729324755fc4b1b1c-Picture10.png" alt="Picture10.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/10/LockSupport/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/10/LockSupport/" class="post-title-link" itemprop="url">LockSupport</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-10 18:16:57" itemprop="dateCreated datePublished" datetime="2021-08-10T18:16:57+08:00">2021-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-21 21:27:31" itemprop="dateModified" datetime="2021-08-21T21:27:31+08:00">2021-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1    是什么？"></a>1    是什么？</h1><img src="/2021/08/10/LockSupport/image-20210716173307046.png" alt="image-20210716173307046" style="zoom:80%;">

<ul>
<li>  <strong>LockSupport</strong> 是 JUC 包下的一个类，也用于多线程间的通信，<strong>是 <code>wait / notify</code> 机制的改良加强版</strong>。</li>
<li>  LockSupport 是一个线程阻塞唤醒的工具类，<strong>类中所有的方法都是静态方法</strong>，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。</li>
<li>  LockSupport 提供了 <code>park()</code> 和 <code>unpark()</code> 方法实现阻塞线程和解除线程阻塞的过程。</li>
<li>  归根结底，<strong>LockSupport 调用的是 Unsafe 类中的 native 方法</strong>。</li>
<li>  LockSupport 是用来创建锁和其它同步类的基本线程阻塞原语。</li>
</ul>
<p><img src="/2021/08/10/LockSupport/image-20210716173522862.png" alt="image-20210716173522862"></p>
<hr>
<h1 id="2-为什么学-LockSupport"><a href="#2-为什么学-LockSupport" class="headerlink" title="2    为什么学 LockSupport"></a>2    为什么学 LockSupport</h1><ol>
<li> LockSupport 是学习 AQS 的前置知识。</li>
<li> 传统的 等待/唤醒 机制在某些情况下不适用。</li>
</ol>
<hr>
<h1 id="3-三组让线程等待-唤醒的方法（传统等待-唤醒方法存在的缺陷）"><a href="#3-三组让线程等待-唤醒的方法（传统等待-唤醒方法存在的缺陷）" class="headerlink" title="3    三组让线程等待/唤醒的方法（传统等待/唤醒方法存在的缺陷）"></a>3    三组让线程等待/唤醒的方法（传统等待/唤醒方法存在的缺陷）</h1><blockquote>
<ol>
<li> <strong>Object</strong>：<code>wait()</code> 和 <code>notify()</code></li>
<li> <strong>Condition</strong>：<code>await()</code> 和 <code>signal()</code></li>
<li> <strong>LockSupport</strong>：<code>park()</code> 和 <code>unpark()</code></li>
</ol>
</blockquote>
<h2 id="3-1-wait-notify"><a href="#3-1-wait-notify" class="headerlink" title="3.1    wait / notify"></a>3.1    wait / notify</h2><blockquote>
<p>  <strong>Object 类中的 wait 和 notify 方法实现线程的等待和唤醒（wait/notify 限制）</strong></p>
</blockquote>
<h3 id="正常"><a href="#正常" class="headerlink" title="正常"></a>正常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.one;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/16 18:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行结果：</span></span><br><span class="line"><span class="comment"> *      T1 come in</span></span><br><span class="line"><span class="comment"> *      T1 进入Waiting状态</span></span><br><span class="line"><span class="comment"> *      T2 come in</span></span><br><span class="line"><span class="comment"> *      T2 唤醒Waiting中的线程</span></span><br><span class="line"><span class="comment"> *      T1 被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="异常1"><a href="#异常1" class="headerlink" title="异常1"></a>异常1</h3><ul>
<li>  将 <code>wait</code> 和 <code>notify</code> 方法，两个都去掉同步代码块。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            synchronized (obj)&#123;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            synchronized (obj)&#123;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>执行结果：</strong></p>
</blockquote>
<p><img src="/2021/08/10/LockSupport/image-20210716181135743.png" alt="image-20210716181135743"></p>
<blockquote>
<p>  <strong>结论</strong></p>
</blockquote>
<ul>
<li>  <strong>Object 类中的 wait、notify、notifyAll 方法必须放在 synchronized 同步代码（同步代码块或同步方法）中才能正常使用。</strong></li>
<li>  <strong>编译时不会报错，但是运行时会抛出 <code>IllegalMonitorStateException</code> 异常。</strong>【非法监听状态异常】</li>
</ul>
<hr>
<h3 id="异常2"><a href="#异常2" class="headerlink" title="异常2"></a>异常2</h3><ul>
<li>  让 <code>notify()</code> 先于 <code>wait()</code> 执行，会导致某个线程进入 Waiting 状态后无法被唤醒，程序无法结束。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                    obj.wait();		<span class="comment">// 13行</span></span><br><span class="line"><span class="comment">//                    obj.wait(1000);      // 超时唤醒可以单独出现              </span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>执行结果</strong></p>
</blockquote>
<p><img src="/2021/08/10/LockSupport/image-20210716181509277.png" alt="image-20210716181509277"></p>
<blockquote>
<p>  <strong>代码分析</strong></p>
</blockquote>
<ol>
<li> 在线程 T1 争夺锁对象之前让其先暂停 1s，让 T2 线程能先于 T1 执行；</li>
<li> T2 线程先得到锁对象，在控制台上输出指定的内容，并随机唤醒当前锁对象维护的等待队列中的一个线程，将其移动到锁对象的同步队列中，最后执行完毕释放锁对象。（由于当前锁对象的等待队列为空，所以这里并没有发生真正的唤醒线程的过程）</li>
<li> T1 线程休眠 1s 后醒来获得锁对象，执行代码块中的方法，将指定内容打印输出到控制台上。执行到 13 行 <code>obj.wait();</code> 代码后 T1 线程被挂起。</li>
<li> 但是由于锁对象的唤醒动作已经先于阻塞动作执行了，并且在此之后锁对象也没有其它的唤醒动作了，所以 T1 会一直陷入 Waiting 状态，该行代码之后的打印输出动作也就不会被执行到。</li>
<li> 整个进程无法结束。</li>
</ol>
<blockquote>
<p>  <strong>附加</strong></p>
</blockquote>
<ul>
<li>  如果将唤醒操作设置成超时唤醒，则 <strong>wait(long timeout)</strong> 可以不用与 <code>notify()</code> 方法成对出现，也可以不用关心与 <code>notify()</code> 方法出现的顺序。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>  <code>wait()</code> 和 <code>notify()</code> 方法必须<strong>要在 synchronized 同步代码里面</strong>且<strong>成对使用</strong>，且使用时必须先 <code>wait</code> 后 <code>notify</code>。【注意这里的 <code>wait()</code> 方法一定是空参的 wait 方法】</li>
</ul>
<hr>
<h2 id="3-2-await-signal"><a href="#3-2-await-signal" class="headerlink" title="3.2    await  / signal"></a>3.2    await  / signal</h2><blockquote>
<p>  <strong>Condition 接口中的 await 和 signal 方法实现线程的等待和唤醒</strong></p>
</blockquote>
<p>与<code>Object#wait</code>、<code>Object#notify</code> 方法遇到的问题基本一样。</p>
<h3 id="正常-1"><a href="#正常-1" class="headerlink" title="正常"></a>正常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/16 18:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                condition.await();  <span class="comment">// 当前线程被阻塞</span></span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行结果：</span></span><br><span class="line"><span class="comment"> *      T1 come in</span></span><br><span class="line"><span class="comment"> *      T1 进入Waiting状态</span></span><br><span class="line"><span class="comment"> *      T2 come in</span></span><br><span class="line"><span class="comment"> *      T2 唤醒Waiting中的线程</span></span><br><span class="line"><span class="comment"> *      T1 被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="异常1-1"><a href="#异常1-1" class="headerlink" title="异常1"></a>异常1</h3><p>如果注释掉 lock 和 unlock 方法，程序将会抛出 <strong>IllegalMonitorStateException</strong> 异常。</p>
<p><img src="/2021/08/10/LockSupport/image-20210716184240464.png" alt="image-20210716184240464"></p>
<h3 id="异常2-1"><a href="#异常2-1" class="headerlink" title="异常2"></a>异常2</h3><p>如果调换 <code>await()</code> 和 <code>signal()</code> 的执行顺序，将有一个线程永远处于 Waiting 状态，导致线程无法结束。</p>
<hr>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3    总结"></a>3.3    总结</h2><blockquote>
<p>  <strong>传统的 synchronized 和 Lock 实现等待唤醒的约束</strong></p>
</blockquote>
<ol>
<li> 等待和唤醒的方法必须写在锁代码块（synchronized 或 lock）中；</li>
<li> 等待 / 唤醒方法必须成对出现，成对使用。</li>
<li> 必须先等待后唤醒。如果先唤醒后等待，线程将陷入死等。</li>
</ol>
<hr>
<h2 id="3-4-park-unpark"><a href="#3-4-park-unpark" class="headerlink" title="3.4    park / unpark"></a>3.4    park / unpark</h2><blockquote>
<p>  <strong>LockSupport 类中 park 等待和 unpark 唤醒</strong></p>
</blockquote>
<ul>
<li>  见下文</li>
</ul>
<hr>
<h1 id="4-LockSupport"><a href="#4-LockSupport" class="headerlink" title="4    LockSupport"></a>4    LockSupport</h1><h2 id="4-1-常用方法"><a href="#4-1-常用方法" class="headerlink" title="4.1    常用方法"></a>4.1    常用方法</h2><p>在 LockSupport 中，通过 <code>park()</code> 和 <code>unpark(Thread thread)</code> 方法来实现阻塞和唤醒线程的操作。</p>
<p><img src="/2021/08/10/LockSupport/image-20210716203238382.png" alt="image-20210716203238382"></p>
<h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2    原理"></a>4.2    原理</h2><ul>
<li>  LockSupport 中使用了一种名为 Permit（许可证）的概念来实现阻塞和唤醒线程的功能，Permit 与线程绑定。</li>
<li>  Permit 只有两个值 1 和 0，默认是 0。</li>
<li>  0 表示线程没有许可证，1 表示线程拥有许可证。每个线程允许携带的许可证的最大上限是 1。</li>
</ul>
<h2 id="4-3-阻塞"><a href="#4-3-阻塞" class="headerlink" title="4.3    阻塞"></a>4.3    阻塞</h2><blockquote>
<p>  <strong>阻塞方法</strong></p>
</blockquote>
<ul>
<li>  <code>park()</code>：消耗一个许可证，若许可证个数为 0 则会阻塞当前线程，若许可证个数为 1 则会消耗掉一个许可证，并放行线程。</li>
<li>  <code>park(Object blocker)</code>：阻塞指定线程（会消耗掉一个许可证）</li>
</ul>
<blockquote>
<p>  <strong>阻塞原理</strong></p>
</blockquote>
<p>调用 <code>LockSupport#park()</code> 方法时，底层调用的是 <code>UNSAFE.park()</code> 方法</p>
<p><img src="/2021/08/10/LockSupport/image-20210716203521212.png" alt="image-20210716203521212"></p>
<p>默认情况 <code>permit == 0</code>，对于一个新的线程直接调用 <code>park()</code> 方法，该线程没有许可证可以被消耗，所以当前线程会直接阻塞，直到其它线程给该线程颁发一个许可证，即设置该线程的 <code>permit == 1</code> 时，该线程才会从阻塞状态中恢复运行，并消耗掉一个许可证，设置 <code>permit == 0</code> ，继续执行 <code>park()</code> 方法之后的代码。</p>
<h2 id="4-4-唤醒"><a href="#4-4-唤醒" class="headerlink" title="4.4    唤醒"></a>4.4    唤醒</h2><blockquote>
<p>  <strong>唤醒方法</strong></p>
</blockquote>
<ul>
<li>   <code>unpark(Thread thread)</code>：唤醒某个线程。</li>
</ul>
<blockquote>
<p>  <strong>唤醒原理</strong></p>
</blockquote>
<p><strong>严格意义上将并不是唤醒线程，而是给线程颁发了一个许可证，这个许可证并不会立即被消耗，而是保存在线程实例中，在遇到 park() 方法造成的阻塞时，消耗该许可证可以保证线程不被阻塞。</strong></p>
<p><img src="/2021/08/10/LockSupport/image-20210716203852897.png" alt="image-20210716203852897"></p>
<p>调用 <code>unpark(thread)</code> 方法后，设置 thread 线程的许可证 <code>permit == 1</code>（注意多次调用 <code>unpark()</code>，permit 的值不会累加，最高只能是 1），自动唤醒 thread 线程，即之前阻塞中的 <code>LockSupport.park()</code> 方法会立即返回。</p>
<h2 id="4-5-形象的理解"><a href="#4-5-形象的理解" class="headerlink" title="4.5    形象的理解"></a>4.5    形象的理解</h2><p><em>permit 许可证与线程绑定。</em></p>
<p><em>permit  是一张万能的通行证，可以提前发给线程，线程每遇到一个关卡（阻塞）就需要消耗一张通行证。如果有则通过关卡，没有则不让通过，即阻塞。且每个线程最大只能持有一张许可证。</em></p>
<p>线程阻塞时需要消耗凭证（permit），这个凭证每个线程最多只有 1 个。</p>
<ol>
<li>当调用 <code>park()</code> 方法时，<ul>
<li>  如果有凭证，则会直接消耗掉这个凭证，然后程序继续执行。</li>
<li>  如果无凭证，则必须阻塞等待凭证可用</li>
</ul>
</li>
<li> 而 <code>unpark()</code> 正好相反，它会增加一个凭证，但凭证最多只能有一个，累加无效。</li>
</ol>
<hr>
<h1 id="5-代码"><a href="#5-代码" class="headerlink" title="5    代码"></a>5    代码</h1><blockquote>
<p>  <strong>LockSupport 的优势</strong></p>
</blockquote>
<ul>
<li>  优势1：不需要锁块，唤醒和阻塞的代码可以写在任意位置。（之前的两组方法都只能写在锁代码块中）</li>
<li>  优势2：支持 <code>unpark()</code> 可以在 <code>park()</code> 之前执行（先唤醒后等待）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in \t&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 被唤醒 \t&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;唤醒&quot;</span> + t1.getName() + <span class="string">&quot;线程&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1); </span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>代码分析</strong></p>
</blockquote>
<ol>
<li> T1 线程即使抢到 CPU 资源后也会立即睡眠 3s，所以 T2 线程中的内容必定先于 T1 执行。</li>
<li> T2 调用 <code>unpark()</code> 方法给 t1 线程发放了一个通行证；</li>
<li> 3s 后 T1 线程睡醒，接着上次的位置继续执行，打印 <code>... come in ...</code> 在控制台上，接着执行 <code>park()</code> 方法阻塞线程，但是由于此时 T1 线程是有一个通行证 permit 的，所以这个阻塞校验可以通过，紧接着继续执行下面的操作。</li>
</ol>
<p><strong>最终的运行结果为</strong>：</p>
<p><img src="/2021/08/10/LockSupport/image-20210716213814924.png" alt="image-20210716213814924"></p>
<p>可以看到：<code>LockSupport.park()</code>前后执行时间是一样的，也就说明阻塞没有生效。</p>
<hr>
<h1 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6    面试题"></a>6    面试题</h1><blockquote>
<ol>
<li> <strong>为什么可以先唤醒线程后阻塞线程？</strong></li>
</ol>
</blockquote>
<p><code>unpark()</code> 方法并不是直接唤醒阻塞的线程，而是相当于给线程发放了一个万能的通行证，只要有这个通行证在，线程在遇到阻塞时，直接消费这个通行证就可以通过而不会被阻塞。</p>
<blockquote>
<ol start="2">
<li> <strong>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</strong></li>
</ol>
</blockquote>
<p>因为一个线程持有通行证的最大数量只能为 1，所以调用两次 <code>unpark()</code> 和调用一次 <code>unpark()</code> 效果一样，最多只能获得一个通行证。而调用两次 <code>park()</code> 则会消费两个通行证，证不够就不能放行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/BlockingQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/09/BlockingQueue/" class="post-title-link" itemprop="url">BlockingQueue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-09 15:45:50" itemprop="dateCreated datePublished" datetime="2021-08-09T15:45:50+08:00">2021-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-19 20:20:18" itemprop="dateModified" datetime="2021-10-19T20:20:18+08:00">2021-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>阻塞队列；BlockingQueue</strong></p>
</blockquote>
<h1 id="阻塞队列的由来"><a href="#阻塞队列的由来" class="headerlink" title="阻塞队列的由来"></a>阻塞队列的由来</h1><blockquote>
<p>  <strong>生产者-消费者模式</strong></p>
</blockquote>
<ul>
<li>  我们假设一种场景，生产者一直生产资源，消费者一直消费资源，资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的 <strong>生产者-消费者模式</strong>。</li>
<li>  该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</li>
<li>  我们自己编码实现这个模式的时候，因为需要让多个线程操作共享变量（即资源），所以很容易引发线程安全问题，造成重复消费和死锁，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个等待-唤醒逻辑都需要自己实现。</li>
</ul>
<blockquote>
<p>  <strong>为什么需要 BlockingQueue？有什么好处？</strong></p>
</blockquote>
<ul>
<li>  在多线程领域，所谓阻塞，就是指在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会被唤醒。[但是这些都是需要人工去判断挂起和唤醒的] [<strong>手动挂起和唤醒</strong>]</li>
<li>  在 juc 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，这会给开发带来不小的难度。</li>
<li>  由程序员手动去判断阻塞和唤醒条件是非常容易出错的，所以 JDK 中新增了 **阻塞队列(BlockingQueue)**，你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</li>
<li>  好处是我们不需要关心什么时候阻塞线程，什么时候唤醒线程，因为这一切都由 BlockingQueue 自动实现了。[<strong>自动挂起和唤醒</strong>]</li>
<li>  BlockingQueue⼀般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。BlockingQueue就是存放元素的容器。</li>
</ul>
<hr>
<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><ol>
<li> 阻塞队列首先是一个队列，满足队列 FIFO 的特性；</li>
<li>阻塞队列<ul>
<li>  当阻塞队列为空时，从队列中<strong>获取</strong>元素的操作将会被阻塞。</li>
<li>  当阻塞队列为满时，往队列里<strong>添加</strong>元素的操作将会被阻塞。</li>
</ul>
</li>
<li> 阻塞队列空了消费者阻塞，满了生产者阻塞。</li>
</ol>
<p><img src="/2021/08/09/BlockingQueue/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="阻塞队列"></p>
<hr>
<h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>
<table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center"><code>add(e)</code></td>
<td align="center"><code>offer(e)</code></td>
<td align="center"><code>put(e)</code></td>
<td align="center"><code>offer(e, time, unit)</code></td>
</tr>
<tr>
<td align="center">移出</td>
<td align="center"><code>remove()</code></td>
<td align="center"><code>poll()</code></td>
<td align="center"><code>take()</code></td>
<td align="center"><code>poll(time, unit)</code></td>
</tr>
<tr>
<td align="center">检查</td>
<td align="center"><code>element()</code></td>
<td align="center"><code>peek()</code></td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ul>
<li>  检查：检查队列是否为空，不为空则查到队头元素的值</li>
</ul>
<blockquote>
<p>  <strong>抛出异常：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，则抛出异常。</p>
<ul>
<li>  当阻塞队列满时，再往队列里插入元素会抛出 <strong>IllegalStateException: Queue full</strong> 异常；</li>
<li>  当阻塞队列空时，再从队列里删除元素会抛出 <strong>NoSuchElementException</strong> 异常。</li>
</ul>
<blockquote>
<p>  <strong>返回特殊值：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，会返回一个特殊值。</p>
<ul>
<li>  对于插入方法，成功返回 <strong>true</strong> 失败返回 <strong>false</strong>；</li>
<li>  对于移除方法，成功返回出队的元素，队列为空就返回 <strong>null</strong>。</li>
</ul>
<blockquote>
<p>  <strong>一直阻塞：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，则一直阻塞或者响应中断。</p>
<ul>
<li>  当阻塞队列满时，生产者线程继续往队列里 put 元素，队列会一直阻塞生产线程；</li>
<li>  当阻塞队列空时，消费者线程继续试图从队列中 take 元素，队列会一直阻塞消费者线程直到队列可用。</li>
</ul>
<blockquote>
<p>  <strong>超时退出：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 <code>true / false</code>。</p>
<ul>
<li>  当阻塞队列满时，继续向队列中添加元素，会阻塞生产者线程一段时间，若该段时间内队列中可以添加元素了，则添加成功，超过时间后生产者线程会退出，返回一个特定值告知该操作是否成功。</li>
<li>  当阻塞队列空时，继续从队列中移出元素，会阻塞消费者线程一段时间，若该段时间内可以从队列中移除元素了，则移除成功，超过时间后消费者线程会退出，返回一个特定值告知该操作是否成功。</li>
</ul>
<blockquote>
<p>  <strong>注意</strong></p>
</blockquote>
<ul>
<li>  不能往阻塞队列中插⼊null，会抛出空指针异常。</li>
<li>  可以访问阻塞队列中的任意元素，调用 <code>remove(o)</code> 可以将队列之中的特定对象移除，但并不⾼效，尽量避免使用。</li>
</ul>
<hr>
<h1 id="BlockingQueue-架构"><a href="#BlockingQueue-架构" class="headerlink" title="BlockingQueue 架构"></a>BlockingQueue 架构</h1><img src="/2021/08/09/BlockingQueue/BlockingQueue.png" alt="BlockingQueue">



<ul>
<li>  <strong>ArrayBlockingQueue：由数组结构组成的有界阻塞队列。类似于ArrayList</strong></li>
<li>  <strong>LinkedBlockedQueue：由链表结构组成的有界阻塞队列（但大小默认值为 Integer.MAX_VALUE）。类似于 LinkedArrayList</strong></li>
<li>  PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li>
<li>  DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</li>
<li>  <strong>SynchronousQueue：不存储元素的阻塞队列。</strong></li>
<li>  LinkedTransferQueue：由链表结构组成的无界阻塞队列。</li>
<li>  LinkedBlockingDeque：由链表结构组成的双向阻塞队列。</li>
</ul>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><blockquote>
<p>  <strong>构造方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span>&#123;</span><br><span class="line">    <span class="comment">//...省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  ArrayBlockingQueue 是由数组结构组成的<strong>有界</strong>阻塞队列。</li>
<li>  内部结构是<strong>数组</strong>，故具有数组的特性。</li>
<li>  可以初始化队列大小， 且一旦初始化不能改变。构造方法中的 <strong>fair</strong> 表示控制对象的内部锁是否采用公平锁，默认是非公平锁。</li>
</ul>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><ul>
<li>  由链表结构组成的<strong>有界</strong>阻塞队列。默认队列的大小是 <strong>Integer.MAX_VALUE</strong>，也可以指定大小。</li>
<li>  内部结构是链表，具有链表的特性。</li>
<li>  此队列按照先进先出的原则对元素进行排序。</li>
</ul>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><ul>
<li>  这个队列比较特殊，没有任何内部容量，甚至连一个队列的容量都没有。并且每个 <code>put</code> 必须等待一个 <code>take</code>，反之亦然。</li>
</ul>
<blockquote>
<p>  <strong>SynchronousQueue 与容量为 1 的 ArrayBlockingQueue、LinkedBlockingQueue 有什么区别？</strong></p>
</blockquote>
<p>在 SynchronousQueue 中：</p>
<ul>
<li>  <code>iterator()</code> 永远返回空，因为里面没有东西；</li>
<li>  <code>isEmpty()</code> 永远返回 true；</li>
<li>  <code>peek()</code> 永远返回 <strong>null</strong>；</li>
<li>  <code>put()</code> 往 queue 放进去一个 element 以后就一直 wait，直到有其他 thread 进来把这个 element 取走。</li>
<li>  <code>offer()</code> 往 queue 里放一个 element 后立即返回，如果碰巧这个 element 被另一个thread取走了，<code>offer()</code> 返回 true，认为 <code>offer()</code> 成功；否则返回 false。</li>
<li>  <code>take()</code> 取出并且 remove 掉 queue 里 的 element，取不到东西他会一直等。</li>
<li>  <code>poll()</code> 取出并且 remove 掉 queue 里的 element，只有到碰巧另外一个线程正在往 queue 里 offer 数据或者 put 数据的时候，该方法才会取到东西。否则立即返回 null。</li>
<li>  <code>remove()</code> &amp; <code>removeAll()</code> 永远返回 false。</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>  PriorityBlockingQueue 不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。</li>
<li>  因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</li>
<li>  对于使用默认大小的LinkedBlockingQueue也是一样的。</li>
</ul>
<hr>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h2 id="ArrayBlockingQueue-1"><a href="#ArrayBlockingQueue-1" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><h3 id="Case1：add-remove"><a href="#Case1：add-remove" class="headerlink" title="Case1：add / remove"></a>Case1：add / remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blockingQueue.add(<span class="string">&quot;A&quot;</span>);    <span class="comment">// 正常添加返回值为Boolean类型的true</span></span><br><span class="line">        blockingQueue.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        blockingQueue.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="comment">//        blockingQueue.add(&quot;X&quot;);   // 队列满时再向队列时添加元素会抛出异常：IllegalStateException: Queue full</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*检索*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> blockingQueue.element();   <span class="comment">// 正常检索返回队首元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.remove();     <span class="comment">// 正常出队返回值为队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.remove();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.remove();</span><br><span class="line"><span class="comment">//        String q4 = blockingQueue.remove();   // 队列空时继续出队会抛出异常：NoSuchElementException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  队列满时继续入队</li>
</ul>
<p><img src="/2021/08/09/BlockingQueue/image-20210713172132018.png" alt="image-20210713172132018"></p>
<ul>
<li>  队列为空时继续出队</li>
</ul>
<p><img src="/2021/08/09/BlockingQueue/image-20210713172625099.png" alt="image-20210713172625099"></p>
<h3 id="Case2：offer-poll"><a href="#Case2：offer-poll" class="headerlink" title="Case2：offer / poll"></a>Case2：offer / poll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blockingQueue.offer(<span class="string">&quot;A&quot;</span>);    <span class="comment">// 正常添加返回值为Boolean类型的true</span></span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;X&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*检索*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> blockingQueue.peek();   <span class="comment">// 正常检索返回队首元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.poll();     <span class="comment">// 正常出队返回值为队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.poll();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.poll();</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果：</span></span><br><span class="line"><span class="comment"> *      false</span></span><br><span class="line"><span class="comment"> *      null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Case3：put-take"><a href="#Case3：put-take" class="headerlink" title="Case3：put / take"></a>Case3：put / take</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;A&quot;</span>);    <span class="comment">// 正常添加无返回值</span></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;X&quot;);     // 当队列满时，继续入队元素，就会阻塞当前线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.take();     <span class="comment">// 正常出队返回队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">q4</span> <span class="operator">=</span> blockingQueue.take();       <span class="comment">// 当队列空时，继续出队，也会阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Case4：offer-poll"><a href="#Case4：offer-poll" class="headerlink" title="Case4：offer / poll"></a>Case4：offer / poll</h3><p><img src="/2021/08/09/BlockingQueue/image-20210713173931729.png" alt="image-20210713173931729"></p>
<p><img src="/2021/08/09/BlockingQueue/image-20210713174208204.png" alt="image-20210713174208204"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blockingQueue.offer(<span class="string">&quot;A&quot;</span>,<span class="number">2</span>, TimeUnit.SECONDS);    <span class="comment">// 正常添加返回值为Boolean类型的true</span></span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;X&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);  <span class="comment">// 队列满时继续添加，会阻塞当前线程 2s，之后继续运行线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);    <span class="comment">// 正常出队返回值为队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="type">String</span> <span class="variable">q4</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);    <span class="comment">// 队列空时继续出队，会阻塞当前线程线程2s，</span></span><br><span class="line">        <span class="comment">// 如果2s后队列还为空，则返回null，若2s后队列被其它线程入队了值，则返回队首的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="SynchronousQueue-1"><a href="#SynchronousQueue-1" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p><strong>原理</strong></p>
<ul>
<li>  SynchronousQueue 没有容量。与其它 BlockingQueue 不同，SynchronousQueue 是一个不存储元素的 BlockingQueue，每一个 put 元素操作必须等待一个 take 操作，否则不能继续添加元素，反之亦然。</li>
<li>  也可以理解为 SynchronousQueue 容量为 1，即每生产一个必须等消费之后才能继续生产下一个。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产者线程*/</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put A&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.put(<span class="string">&quot;A&quot;</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put B&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.put(<span class="string">&quot;B&quot;</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put C&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.put(<span class="string">&quot;C&quot;</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费者线程*/</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.take(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.take(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.take(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;customer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码分析</strong></p>
<ol>
<li> main 线程启动，创建 SynchronousQueue 类的实例对象，创建两个线程，生产者线程和消费者线程并发执行。</li>
<li> 生产者线程连续生产 3 个元素，但是由于 blockingQueue 是一个同步队列，最大容量是 1，所以只能添加进去一个，然后被挂起；</li>
<li> 消费者线程在 3s 后消费一个线程，消费完成后，生产者线程才能被唤醒继续生产。</li>
</ol>
<p>所有程序的输出结果是：</p>
<ol>
<li> 生产者线程添加 “A” 到同步阻塞队列，然后被挂起，等待队列中元素被消费；</li>
<li> 3s 后消费者线程被唤醒消费队列中队首元素，然后继续挂起 2s；</li>
<li> 生产者线程检测到阻塞队列为空，生产 “B” 到同步队列中，等待队列中的元素被消费；</li>
<li> 2s 后消费者线程被唤醒消费队列中队首元素，然后继续挂起 1s；</li>
<li> 生产者线程检测到阻塞队列为空，生产 “C” 到同步队列中，等待队列中的元素被消费，生产线程结束；</li>
<li> 1s 后消费者线程被唤醒消费队列中队首元素，消费者线程结束；</li>
<li> main 线程结束，程序执行完成。</li>
</ol>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">producer put A</span><br><span class="line">producer put B</span><br><span class="line">producer put C</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="用在哪里"><a href="#用在哪里" class="headerlink" title="用在哪里"></a>用在哪里</h1><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/14 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 知识点： volatile/CAS/atomicInteger/BlockQueue/线程交互/原子引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData3</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">// 默认开启，进行 生产+消费 。需要被多个线程知道，使用 volatile 修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="literal">null</span>;     <span class="comment">// 定义为接口类型，可以接受该接口的所有实现类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造器注入*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyData3</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName()); <span class="comment">// 通过反射的方式获取调用对象的全限定类名，方便出错时检查</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flag == true</span></span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet()+<span class="string">&quot;&quot;</span>; <span class="comment">// i++</span></span><br><span class="line">            result = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);    <span class="comment">// 加入阻塞队列，并返回执行结果</span></span><br><span class="line">            <span class="keyword">if</span> (result)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;加入队列成功***&quot;</span> + data);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;加入队列失败***&quot;</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flag == false</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;生产线程执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == result)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;超过2s没有取到阻塞队列中的数据，消费线程退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费&quot;</span> + result +<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProdConsumerDemo03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyData3</span> <span class="variable">myData3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData3</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;String&gt;(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产线程启动&quot;</span>);</span><br><span class="line">                myData3.product();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Product&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费线程启动&quot;</span>);</span><br><span class="line">                myData3.consumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5s钟后，生产和消费都结束</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        myData3.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong></p>
<img src="/2021/08/09/BlockingQueue/image-20210714203155396.png" alt="image-20210714203155396" style="zoom:80%;">



<p><strong>代码分析</strong></p>
<ol>
<li> main 线程启动，创建一个资源类，传入一个阻塞队列。</li>
<li> 启动一个生产线程（Product）和一个消费线程（Consumer），两个线程并发执行。</li>
<li> main 线程可以直接叫停这两个线程</li>
</ol>
<p><em>生产线程：</em></p>
<ol>
<li> 生产线程执行具有原子性的 i++ 操作，并将 i 加入阻塞队列（阻塞队列的最大容量为 3），每加入一次暂停 1s</li>
</ol>
<p><em>消费线程</em>：</p>
<ol>
<li>消费线程消费阻塞队列中的值，<ul>
<li>  如果阻塞队列中有值，则消费成功；</li>
<li>  如果超过 2s 消费队列中都没有值，则消费失败，消费线程退出。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">超链接：线程池</a></li>
</ul>
<blockquote>
<p>  <strong>线程池 ThreadPoolExecutor 的构造方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/09/NIO/" class="post-title-link" itemprop="url">NIO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-09 12:28:02" itemprop="dateCreated datePublished" datetime="2021-08-09T12:28:02+08:00">2021-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-25 18:26:13" itemprop="dateModified" datetime="2022-06-25T18:26:13+08:00">2022-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><p><img src="https://processon.com/chart_image/62a72a32e0b34d29447092bf.png"></p>
<h1 id="第一章-Java-I-O-模型"><a href="#第一章-Java-I-O-模型" class="headerlink" title="第一章 Java I/O 模型"></a>第一章 Java I/O 模型</h1><p>在真实开发中，<strong>非阻塞I/O</strong> 配合 <strong>I/O多路复用</strong>，是高性能网络编程中最常见的技术。</p>
<h2 id="1-阻塞-amp-非阻塞；同步-amp-异步"><a href="#1-阻塞-amp-非阻塞；同步-amp-异步" class="headerlink" title="1. 阻塞&amp;非阻塞；同步&amp;异步"></a>1. 阻塞&amp;非阻塞；同步&amp;异步</h2><h3 id="1-1-同步-synchronous-amp-异步-asynchronous"><a href="#1-1-同步-synchronous-amp-异步-asynchronous" class="headerlink" title="1.1 同步(synchronous) &amp; 异步(asynchronous)"></a>1.1 同步(synchronous) &amp; 异步(asynchronous)</h3><p><strong>同步/异步主要针对C(client)端：</strong></p>
<ul>
<li><strong>同步：</strong>简单来说，“同步”就是在C端发出一个功能调用时，在没有得到处理结果之前，该调用就不返回，而C端后续的任务必须等待当前调用返回后，才能进行下一步。这是一种串行化的思想，事情必须一件一件做，等前一件事情做完了才能做下一件事情。<ul>
<li>例如普通的同步B/S模式：提交请求-&gt;等待服务器处理-&gt;处理完毕返回。在此期间客户端浏览器不能干其它事情。</li>
</ul>
</li>
<li><strong>异步：</strong>异步的概念和同步相对，当C端发出一个异步调用后，调用者不会立刻得到结果。实际处理这个调用的部件在任务完成后，通过状态、通知和回调来通知调用者。<ul>
<li>例如Ajax请求(异步)：请求通过事件触发 -&gt; 服务器处理(这时浏览器仍然可以做其它事情) -&gt; 处理完毕。</li>
</ul>
</li>
</ul>
<p>简单来说，同步是一种可靠有序的运行机制。当我们进行同步操作时，后续的任务必须等待当前调用返回，才会进行下一步；而异步则相反，其它任务不需要等待当前调用返回，通常依靠回调、事件等机制来实现任务间次序关系。</p>
<h3 id="1-2-阻塞-Block-amp-非阻塞-Unblock"><a href="#1-2-阻塞-Block-amp-非阻塞-Unblock" class="headerlink" title="1.2 阻塞(Block) &amp; 非阻塞(Unblock)"></a>1.2 阻塞(Block) &amp; 非阻塞(Unblock)</h3><p><strong>阻塞/非阻塞主要针对S(Server)端：</strong></p>
<h4 id="1-2-1-什么是阻塞？"><a href="#1-2-1-什么是阻塞？" class="headerlink" title="1.2.1 什么是阻塞？"></a>1.2.1 什么是阻塞？</h4><p>当服务器上的应用程序(实际上是一个进程，对于单线程程序来说，一个应用程序只有一个线程)调用阻塞I/O完成某个操作时，应用程序会被挂起，等待操作系统内核完成操作后，再重新得到 CPU 继续执行应用程序，感觉上应用程序就像被“阻塞”了一样。实际上，在内核处理 I/O 操作的这段时间内，CPU 会被内核切换给其它有需要的进程，因此这个应用程序不能得到 CPU 资源来做其它的事情。</p>
<blockquote>
<p><strong>以“应用程序执行写数据的I/O操作”进行分析：</strong></p>
<p>当一个网络应用程序(用户态的进程)执行写操作时，首先等待写出的数据会保存在当前进程的内存空间中。当用户态进程发起“写操作”的系统调用后，CPU 需要将这份数据从用户进程的内存空间拷贝到当前操作系统的内核态空间中，当然这需要一定的时间。在没有得到这个系统调用的返回结果之前，这个用户态的进程将一直处于阻塞状态。直到得到了系统调用的返回结果后，用户进程重新轮询得到 CPU 资源后，进程才离开阻塞状态继续运行。</p>
</blockquote>
<p><strong>问：阻塞的是谁？</strong></p>
<p>答：阻塞的是应用程序（也就是应用程序对应的用户态进程）</p>
<h4 id="1-2-2-什么是非阻塞？"><a href="#1-2-2-什么是非阻塞？" class="headerlink" title="1.2.2 什么是非阻塞？"></a>1.2.2 什么是非阻塞？</h4><p>与阻塞 I/O 不同，当应用程序调用非阻塞 I/O 完成某个操作时，应用程序首先会通过系统调用来访问操作系统内核，但不会等待内核完成处理，而是立刻返回。这种情况下，内核就不会把 CPU 时间切换给其它进程，因此应用程序可以继续使用 CPU 资源来完成其它事情。</p>
<blockquote>
<p><strong>举例</strong></p>
<p>拿“去书店买书”举例子。</p>
<ul>
<li>阻塞 I/O 就是：你去了书店，告诉老板(内核)你想要某本书，然后你就一直在那儿等着，直到老板翻箱倒柜找到了你想要的书(本地阻塞)，有可能还要帮你联系全城的其它分店(网络阻塞)。注意：这个过程你一直滞留在书店等待老板的回复，就好像在书店老板这里“阻塞”住了。</li>
<li>而非阻塞 I/O 则是：你去了书店，问老板有没有你心仪的那本书，老板查了下电脑，告诉你没有，你就悻悻地离开了。一周以后，你又来这个书店，再问这个老板，老板一查，有了，于是你买了这本书。注意：这个过程中，你没有被阻塞，而是在不断地轮询。</li>
</ul>
<p><strong>I/O 多路复用</strong></p>
<ul>
<li>但是轮询的效率太低了，于是你跟老板商量：“老板，到货给我打电话吧，我再来付钱取书。”这就是所谓的 I/O 多路复用。</li>
</ul>
<p><strong>AIO(异步I/O)</strong></p>
<ul>
<li>再进一步，你连去书店取书也想省了，得了，让老板代劳吧。你留下地址，付了书费，让老板到货时寄给你，你直接在家里拿到书就可以看了。这就是传说中的异步 I/O。</li>
</ul>
</blockquote>
<h2 id="2-I-O模型"><a href="#2-I-O模型" class="headerlink" title="2. I/O模型"></a>2. I/O模型</h2><p>目前为止，Java 共支持 3 种 IO 模型：BIO、NIO、AIO</p>
<ul>
<li><strong>BIO（同步阻塞 I/O）</strong></li>
<li><strong>NIO（同步非阻塞I/O）</strong></li>
<li><strong>AIO（异步非阻塞I/O）</strong></li>
</ul>
<p>这里我们暂时不考虑同步和异步的问题，只从阻塞和非阻塞两个角度来学习常见的 I/O 模型。</p>
<h3 id="2-1-阻塞I-O"><a href="#2-1-阻塞I-O" class="headerlink" title="2.1 阻塞I/O"></a>2.1 阻塞I/O</h3><p><strong>所谓的阻塞I/O，就是在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其它任务，只有当条件就绪才能继续。如果读取数据，代码会阻塞直至用户线程的内存空间中有可供读取的数据。同样，如果写入数据，在内核写入完成前，用户线程会一直处于阻塞状态。</strong></p>
<p>传统的 Server/Client 模式基于 TPR(Thread per Request)原则，服务器会为每个客户端连接创建一个新的线程，由该线程单独负责处理当前次的客户请求。这种模式的缺点就是：服务器需要创建多个线程来维护多个连接，大量的线程会增大服务器的开销，甚至导致服务器宕机。</p>
<p><img src="http://processon.com/chart_image/62b5b7def346fb6dc5800047.png"></p>
<p>大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量。但这又带来了新的问题，如果线程池中有100个线程，而目前这100个线程都在进行文件传输，就会导致第101个用户的请求无法被及时处理，即便第101个用户只想请求一个几KB大小的页面。</p>
<h3 id="2-2-非阻塞I-O"><a href="#2-2-非阻塞I-O" class="headerlink" title="2.2 非阻塞I/O"></a>2.2 非阻塞I/O</h3><p>在 Java NIO 中，非阻塞 I/O 采用了基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，相反是注册感兴趣的特定 I/O 事件(如可读数据到达，新的套接字连接等)。在特定事件发生时，系统再通知我们。</p>
<blockquote>
<p>我要读数据 –&gt; 发起“系统调用” –&gt; 我不被阻塞，继续执行其它操作 –&gt; 我去注册一个感兴趣的读事件 –&gt; 数据达到用户进程内存空间时通知我 –&gt; 我去读数据</p>
<ul>
<li>注：“我” == 用户进程</li>
</ul>
</blockquote>
<p>NIO 中实现非阻塞 I/O 的核心对象就是 Selector。Selector 就是注册各种 I/O 事件的地方。当我们感兴趣的事件发生时，这个对象就会告诉我们所发生的事件。</p>
<p><img src="/2021/08/09/NIO/image-20210909171418839.png" alt="image-20210909171418839"></p>
<p>从图中可以看出，当用户进程空间有读或写等任何注册的事件发生时，可以从 Selector 中获得相应的 SelectionKey，同时从 SelectionKey 中可以找到发生的事件和该事件所发生的具体的 SelectableChannel，以获得客户端发送过来的数据。</p>
<p><strong>非阻塞指的是 I/O 事件本身不阻塞，但是获取 I/O 事件的 <code>select()</code> 方法是需要阻塞等待的。区别是阻塞 I/O 会阻塞在 I/O 操作上，NIO 阻塞在事件获取上，没有事件就没有 I/O，从更高的层次看 I/O 就不阻塞了。</strong></p>
<p><strong>也就是说只有 I/O 已经发生那么我们才评估 I/O 是否阻塞，但是 <code>select()</code> 阻塞的时候 I/O 还没有发生，何谈 I/O 的阻塞呢？NIO 的本质是延迟 I/O 操作到真正发生 I/O 的时候，而不是以前的只要 I/O 流打开了就一直等待 IO 操作。</strong></p>
<table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流（Stream Oriented）</td>
<td>面向缓冲区（Buffer Oriented）</td>
</tr>
<tr>
<td>阻塞IO（Blocking IO）</td>
<td>非阻塞IO（Non Blocking IO）</td>
</tr>
<tr>
<td>无</td>
<td>选择器（Selectors）</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-NIO-概述"><a href="#3-NIO-概述" class="headerlink" title="3. NIO 概述"></a>3. NIO 概述</h2><blockquote>
<p>  <strong>Java NIO；New IO 或 Non Blocking IO</strong></p>
</blockquote>
<p>Java NIO 是 JDK1.4 引入的一组全新的IO API，用于代替之前版本的 IO API。NIO 使用了<strong>面向缓冲区</strong>的、<strong>基于通道</strong>的IO操作，可以更加高效地执行文件的读写操作。</p>
<p>Java NIO 的三个核心组件：</p>
<ul>
<li><strong>Channels</strong></li>
<li><strong>Buffers</strong></li>
<li><strong>Selectors</strong></li>
</ul>
<p>虽然除此之外，Java NIO 中还有很多其它的类和组件，如 Pipe 和 FileLock。但其它 API 只不过是与三个核心组件配合使用的工具类。</p>
<h3 id="3-3-1-Channel"><a href="#3-3-1-Channel" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h3><blockquote>
<p>  <strong>Channel；通道</strong></p>
</blockquote>
<p>Channel 和传统 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream，OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。</p>
<p>NIO 中的 Channel 的主要实现类有：</p>
<ul>
<li>  FileChannel</li>
<li>  DatagramChannel</li>
<li>  SocketChannel</li>
<li>  ServerSocketChannel，</li>
</ul>
<p>这里看名字就可以猜出个所以然来：分别可以对应：</p>
<ul>
<li>  文件 I/O</li>
<li>  UDP 数据传输</li>
<li>  TCP 数据传输（Server 和 Client）</li>
</ul>
<h3 id="3-3-2-Buffer"><a href="#3-3-2-Buffer" class="headerlink" title="3.3.2 Buffer"></a>3.3.2 Buffer</h3><p>NIO 中的关于 Buffer 实现有：</p>
<ul>
<li>  <strong>ByteBuffer</strong></li>
<li>  <strong>CharBuffer</strong></li>
<li>  DoubleBuffer</li>
<li>  FloatBuffer</li>
<li>  IntBuffer</li>
<li>  LongBuffer</li>
<li>  ShortBuffer</li>
</ul>
<p>分别对应基本数据类型是：</p>
<ul>
<li>  byte</li>
<li>  char</li>
<li>  double</li>
<li>  float</li>
<li>  int</li>
<li>  long</li>
<li>  short</li>
</ul>
<h3 id="3-3-Selector"><a href="#3-3-Selector" class="headerlink" title="3.3 Selector"></a>3.3 Selector</h3><p><strong>Selector 运行单线程处理多个 Channel</strong>。</p>
<p>如果你的应用程序需要维护了多个通道，并且每个连接的流量都很低，使用 Selector 就会很方便。例如在一个聊天服务器中，使用 Selector，可以向 Selector 注册多个 Channel，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件。</p>
<hr>
<h1 id="第二章-缓冲区-Buffer"><a href="#第二章-缓冲区-Buffer" class="headerlink" title="第二章 缓冲区[Buffer]"></a>第二章 缓冲区[Buffer]</h1><h2 id="1-Buffer的属性"><a href="#1-Buffer的属性" class="headerlink" title="1. Buffer的属性"></a>1. Buffer的属性</h2><p>Buffer 实际上就是一个数组，这个数组的内容与元信息会被包装成一个 <code>java.nio.Buffer</code> 对象，并提供了一组访问这些信息的 API。</p>
<h3 id="Buffer-对象的重要属性"><a href="#Buffer-对象的重要属性" class="headerlink" title="Buffer 对象的重要属性"></a>Buffer 对象的重要属性</h3><ul>
<li><strong>capacity</strong>：容量。指缓冲区可以存储多少个字节的数据。<ul>
<li>容量在创建 Buffer 实例时指定，创建后不能再次修改。如果缓冲区满了，需要清空后才能继续写数据。</li>
</ul>
</li>
<li><strong>position</strong>：当前位置（读写指针）。指缓冲区当前写入/读取的位置。<ul>
<li>新的 Buffer 对象 position 初始值为 0，每读/写一个数据，position 自动向后移动一个单位，它的最大值是 <code>capacity-1</code>。当 Buffer 发生读写模式的切换时，position 会被重置为 0。</li>
</ul>
</li>
<li><strong>limit</strong>：上限。指第一个不能被读/写的位置。<ul>
<li>limit 上限后面的单元既不能读也不能写。在 Buffer 缓冲区的写模式下，limit 表示能够写入多少个数据；在读模式下，limit 表示最多可以读取多少个数据。</li>
</ul>
</li>
<li>mark：标记。设置一个标记位置。<ul>
<li>调用 mark() 方法会把标记设置在 position 位置，当调用 reset() 方法时，会把 position 设置为 mark 标记的位置。</li>
</ul>
</li>
</ul>
<p><img src="http://processon.com/chart_image/62a885837d9c082d0b2cb18d.png" alt="img"></p>
<p><code>CharBuffer.allocate(12)</code> 方法会创建一个大小为 12 个字符的 Buffer 数组。</p>
<ul>
<li>对于该 buffer 对象来说，新建的 buffer 对象默认处于写模式(因为新建的buffer里面没有内容，所以必然处于写模式)，position 初始为 0，capacity 和 limit 为 12。</li>
<li>向缓冲区中写入 5 个字符后，position 会移动到下标为 5 的地方，capacity 和 limit 未发生改变。</li>
<li>调用 flip() 方法切换到读模式后，capacity 仍不会发生变化，但 position 变为 0，limit 会变为 position 原来的位置(最多能读多少个字符)，即下标为 5 的位置。<ul>
<li>在写模式下，position 始终在真实数据的后一个位置，表示下一个要写的位置。而在读模式下，position 每次都指示当前次要读的数据的位置。</li>
</ul>
</li>
</ul>
<h2 id="2-Buffer的常用API"><a href="#2-Buffer的常用API" class="headerlink" title="2. Buffer的常用API"></a>2. Buffer的常用API</h2><p>在 NIO 中，Buffer 常见的子类有：</p>
<ul>
<li>ByteBuffer、CharBuff、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer</li>
</ul>
<p>这些 Buffer 覆盖了能够通过 I/O 发送的所有基本数据类型：</p>
<ul>
<li>byte、char、double、float、int、long、short 等。</li>
</ul>
<p>实际上使用比较多的是 <strong>ByteBuffer 和 CharBuffer</strong>。</p>
<ul>
<li>每个 Buffer 类都有一个静态方法 <code>allocate(capacity)</code> 可用于创建一个指定容量的缓冲区；</li>
<li>都有一个 <code>put()</code> 方法用于向缓冲区中写数据；一个 <code>get()</code> 方法用于从缓冲区中读数据；</li>
<li>当缓冲区中还有未读完的数据，而要求马上向缓冲区中写数据时，可以调用 <code>compact()</code> 方法进行压缩，将所有未读数据复制到 buffer 的起始位置，把 position 设置到最后一个未读元素的后面，limit 属性设置为 capacity。【可以理解为切换到了写模式，其实所谓的读写模式就是通过设置 position 和 limit 的位置来实现的】</li>
<li><code>capacity()</code> 方法返回缓冲区的大小。</li>
<li><code>hasRemaining()</code>：判断当前 position 后面是否还有待处理的数据。即判断 position 与 limit 之间是否还有有效数据。</li>
<li><code>limit()</code>：返回 limit 上限的位置</li>
<li><code>mark()</code>：设置缓冲区的标志位置，这个值只能在 0~position 之间。之后可以通过 <code>reset()</code> 方法返回到这个位置。</li>
<li><code>position()</code> 可以返回 position 当前位置。</li>
<li><code>remaining()</code> 返回当前 position 位置与 limit 之间的数据量</li>
<li><code>reset()</code> 方法可以将 position 设置为 mark 标志位</li>
<li><code>rewind()</code> 方法会将 position 设置为 0，并取消 mark 标志位。</li>
<li><code>clear()</code> 清空缓冲区。仅仅是修改 position 标志为 0，设置 limit 标志为 capacity，缓冲区中的数据还是存在的。</li>
<li><code>flip()</code> 方法可以把缓冲区由写模式切换到读模式。即先设置 limit 为 position 位置，再把 position 设置为 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 Buffer 的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBuffer01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建 CharBuffer 缓冲区对象</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、打印 capacity、limit、position</span></span><br><span class="line">    System.out.println(<span class="string">&quot;02************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、向缓冲区中写数据</span></span><br><span class="line">    buf.put(<span class="string">&quot;你&quot;</span>);</span><br><span class="line">    buf.put(<span class="string">&quot;好&quot;</span>);</span><br><span class="line">    buf.put(<span class="string">&quot;世&quot;</span>);</span><br><span class="line">    buf.put(<span class="string">&quot;界&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;03************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、调用 flip()，把缓冲区切换为读模式</span></span><br><span class="line">    buf.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;04************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、调用 get() 方法读取缓冲区中的数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;05************************************&quot;</span>);</span><br><span class="line">    System.out.println(buf.get()); <span class="comment">//你</span></span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、再次写数据，把数据保存在 position 位置(由于没有切换写模式，所以会直接覆盖position位置的数据)</span></span><br><span class="line">    buf.put(<span class="string">&quot;X&quot;</span>); <span class="comment">// 你X世界</span></span><br><span class="line">    System.out.println(<span class="string">&quot;06************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、设置标志</span></span><br><span class="line">    buf.mark(); <span class="comment">//标志设在了下标为2的位置上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8、再读一个字符</span></span><br><span class="line">    System.out.println(<span class="string">&quot;08************************************&quot;</span>);</span><br><span class="line">    System.out.println(buf.get()); <span class="comment">//世</span></span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9、调用 reset()，把position重置为mark标志位置</span></span><br><span class="line">    buf.reset();</span><br><span class="line">    System.out.println(<span class="string">&quot;09************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10、调用compact压缩，把buffer中未读的数据复制到 position 为 0 的位置【compact会完成读到写模式的转换】</span></span><br><span class="line">    buf.compact();</span><br><span class="line">    System.out.println(<span class="string">&quot;10************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11、调用 clear() 清空。仅仅是修改 position/limit 的值</span></span><br><span class="line">    buf.clear();</span><br><span class="line">    System.out.println(<span class="string">&quot;11************************************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buf.capacity()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buf.limit()); <span class="comment">//12</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buf.position()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12、clear() 清空以后，缓冲区的数据依然存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;12************************************&quot;</span>);</span><br><span class="line">    System.out.println(buf); <span class="comment">// 世界世界</span></span><br><span class="line">    <span class="comment">//通过循环把position与limit之间的内容逐个打印</span></span><br><span class="line">    <span class="keyword">while</span> (buf.hasRemaining())&#123;</span><br><span class="line">        System.out.println(buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用缓冲区就是为了提高数据传输效率，一次读写一个字符或者一个字节效率不高，可以进行批量处理操作。</span></span><br><span class="line"><span class="comment"> * 可以借助数组，把缓冲区中的一块数据读到数组中，也可以把数组中的部分内容保存到缓冲区。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBuffer02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 可以把字符串保存到 buffer 缓冲区中</span></span><br><span class="line">    buffer.put(<span class="string">&quot;你好世界，你好NIO&quot;</span>);</span><br><span class="line">    buffer.flip(); <span class="comment">// 切换为读模式(主要是为了改变limit的值)</span></span><br><span class="line">    System.out.println(buffer); <span class="comment">//你好世界，你好NIO</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] dst = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//调用 get() 方法把缓冲区中的数据读到字符数组中</span></span><br><span class="line">    <span class="comment">//注意：批量传输时大小总是固定的，如果没有指定传输的大小，意味着把数组填满。如果数组不能被填满，则会抛出异常</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">remainingCharBuffer</span> <span class="operator">=</span> buffer.get(dst);</span><br><span class="line">    System.out.println(<span class="string">&quot;数组中数据：&quot;</span> + Arrays.toString(dst)); <span class="comment">//数组中数据：[你, 好, 世, 界, ，, 你, 好, N]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;缓冲区中剩余数据：&quot;</span> + remainingCharBuffer); <span class="comment">// 缓冲区中剩余数据：IO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续把buffer中的内容读取到字符数组中，当缓冲区的数据量不足以填满整个数组时，会抛出异常</span></span><br><span class="line">    <span class="comment">// buffer.get(dst); //BufferUnderflowException</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在批量读取数据缓冲区的数据时，一定记得查询缓冲区中的剩余量。</span></span><br><span class="line">    <span class="comment">// 把小缓冲区中的数据填充到大数组中时，一定要指定缓冲区剩余量的长度。</span></span><br><span class="line">    buffer.get(dst, <span class="number">0</span>, buffer.remaining()); <span class="comment">// 把buffer缓冲区中剩余的数据(总大小为remaining)传输到dst数组0开始的位置</span></span><br><span class="line">    System.out.println(Arrays.toString(dst)); <span class="comment">// [I, O, 世, 界, ，, 你, 好, N]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取缓冲区中的数据</span></span><br><span class="line">    buffer.clear();</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(dst.length, buffer.remaining());</span><br><span class="line">        buffer.get(dst, <span class="number">0</span>, len);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(dst, <span class="number">0</span>, len)); <span class="comment">//你好世界，你好NIO</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量写入</span></span><br><span class="line">    <span class="type">char</span>[] contents = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">// 把字符数组中的数据写入到缓冲区中(如果缓冲区没有足够的空间，会抛出异常)</span></span><br><span class="line">    <span class="comment">//buffer.put(contents); //BufferOverflowException</span></span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer.capacity()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer.limit()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer.position()); <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">    buffer.clear();</span><br><span class="line">    buffer.put(contents);</span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(buffer); <span class="comment">//abcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Buffer 对象的创建方式：</span></span><br><span class="line"><span class="comment"> *      1、分配操作创建缓冲区。allocate() 方法分配一个私有的，指定容量大小的数据来存储元素。</span></span><br><span class="line"><span class="comment"> *      2、包装操作创建缓冲区。它使用现成的数组作为存储空间来充当一个缓冲区。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方式一：分配操作创建缓冲区</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buf1</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方式二：使用包装操作创建缓冲区</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">// 把现成的数组包装成一个Buffer对象</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buf2</span> <span class="operator">=</span> CharBuffer.wrap(charArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过调用 put() 方法向缓冲区中保存数据，也会直接影响到数组</span></span><br><span class="line">    buf2.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    buf2.flip();</span><br><span class="line">    System.out.println(buf2); <span class="comment">//hello</span></span><br><span class="line">    System.out.println(Arrays.toString(charArray)); <span class="comment">//[h, e, l, l, o,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组做的任何修改，也会影响到缓冲区对象</span></span><br><span class="line">    charArray[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    System.out.println(buf2); <span class="comment">//Xello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不管是 allocate() 还是通过 warp() 方法创建的缓冲区都是间接的。</span></span><br><span class="line"><span class="comment">     * 间接缓冲区会使用备份数组 hasArray() 方法判断是否有一个可存取的备份数组。</span></span><br><span class="line"><span class="comment">     * 如果 hasArray() 返回 true，可以通过 array() 返回缓冲区对象使用的备份数组的引用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (buf2.hasArray())&#123;</span><br><span class="line">        <span class="type">char</span>[] backupArray = buf2.array();</span><br><span class="line">        System.out.println(Arrays.toString(backupArray)); <span class="comment">//[X, e, l, l, o,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ,  ]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓冲区的复制与分隔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建缓冲区</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 2、存储数据</span></span><br><span class="line">    buffer.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;buffer.position=&quot;</span> + buffer.position()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、缓冲区的复制</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> buffer.duplicate();</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer2.capacity()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer2.limit()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer2.position()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    buffer2.flip();</span><br><span class="line">    System.out.println(buffer2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer 与 buffer2 实际引用同一个数组</span></span><br><span class="line">    buffer2.clear();</span><br><span class="line">    buffer2.put(<span class="string">&quot;NIO_world&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出 buffer 中的内容</span></span><br><span class="line">    buffer.flip(); <span class="comment">// 反转，把limit设置的值为上一个position的值5</span></span><br><span class="line">    System.out.println(buffer); <span class="comment">//NIO_w</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分隔缓冲区，slice() 方法根据 [position, limit) 区间创建一个新的缓冲区</span></span><br><span class="line">    buffer2.position(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer2.capacity()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer2.limit()); <span class="comment">//16</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer2.position()); <span class="comment">//3</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> buffer2.slice();</span><br><span class="line">    System.out.println(<span class="string">&quot;capacity===&quot;</span> + buffer3.capacity()); <span class="comment">//13</span></span><br><span class="line">    System.out.println(<span class="string">&quot;limit===&quot;</span> + buffer3.limit()); <span class="comment">//13</span></span><br><span class="line">    System.out.println(<span class="string">&quot;position===&quot;</span> + buffer3.position()); <span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-直接字节缓冲区-ByteBuffer"><a href="#3-直接字节缓冲区-ByteBuffer" class="headerlink" title="3. 直接字节缓冲区[ByteBuffer]"></a>3. 直接字节缓冲区[ByteBuffer]</h2><p>在硬盘和操作系统中处理的数据都是二进制的 01 数据，Buffer 的子类中只有 ByteBuffer 字节缓冲区有资格参与 IO 操作。</p>
<p>Channel 通道只能使用 ByteBuffer 作为它的参数。</p>
<p>直接字节缓冲区通常是 IO 操作最好的选择，如果使用非直接字节缓冲区可能会导致性能损耗。如果向通道传递一个非直接字节缓冲区，通道可能会先创建一个临时的直接字节缓冲区，将非直接缓冲区中的内容复制到这个临时的直接字节缓冲区中，使用临时直接字节缓冲区执行底层的 IO 操作。</p>
<p>直接缓冲区是 IO 的最佳选择，可能创建直接缓冲区比创建非直接缓冲区的成本要高。直接缓冲区使用的内存是通过调用本地操作系统分配的，绕过了 JVM 的堆栈。</p>
<p>现在 JVM 可能会执行缓冲区缓存的优化，作为入门初级开发人员，不要考虑优化的问题，先保证程序的正确性。</p>
<p><code>ByteBuffer.allocateDirect(16)</code> 方法创建直接字节缓冲区。</p>
<hr>
<h1 id="第三章-通道-Channel"><a href="#第三章-通道-Channel" class="headerlink" title="第三章 通道[Channel]"></a>第三章 通道[Channel]</h1><h2 id="1-Channel概述"><a href="#1-Channel概述" class="headerlink" title="1 Channel概述"></a>1 Channel概述</h2><p><strong>通道(Channel)负责将缓冲区的数据块移入到各种I/O源，如文件、socket、数据报等；或者是将各种 I/O 源的数据移入到缓冲区。</strong></p>
<ul>
<li>  通道与流(Stream)的不同之处在于通道是双向的，而流只在一个方向上移动(一个流必须是 InputStream 或 OutputStream)。</li>
<li>  而且通道可以用于读、写或同时用于读写。因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5/310007?fr=aladdin">全双工</a></li>
<li>  NIO 中通过 Channel 封装了对数据源的操作，通过 Channel 我们可以操作数据源，但又不必关心数据源的具体物理结构。这个数据源可以是多种的。比如，可以是文件，也可以是网络 socket。</li>
<li>  在大多数应用中，Channel 与文件描述符或者 socket 是一一对应的。</li>
<li>  <strong>Channel 用于在 Buffer 缓冲区和位于通道另一侧的实体(通常是一个文件或套接字)之间有效地传输数据。</strong></li>
</ul>
<blockquote>
<p>  <strong>Channel接口源码</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio.channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tells whether or not this channel is open.</span></span><br><span class="line"><span class="comment">     * 判断通道是否打开</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if, and only if, this channel is open</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this channel.</span></span><br><span class="line"><span class="comment">     * 关闭通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>  与缓冲区不同，Channel API 主要由接口指定。<strong>通道API仅仅进行了一些功能性的描述，具体的实现方式根据不同的操作系统会有根本性的差异。</strong>因此很自然地，Channel 的实现通常使用操作系统的本地代码。</li>
<li>  Channel 是一个对象，可以通过它读取和写入数据。拿 NIO 与传统 I/O 做个比较，通道就像是流，所有数据都通过 Buffer 对象来处理。你永远不会将字节直接写入通道中，相反，你是将数据写入包含一个或者多个字节的缓冲区。同样，你不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</li>
</ul>
<p>Java NIO 的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道中。但流的读写通常是单向的。</li>
<li>通道可以异步的读写。</li>
<li>通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：</li>
</ul>
<p><img src="http://processon.com/chart_image/62b5bc5d1efad40851a8a913.png"></p>
<hr>
<h2 id="2-Channel实现"><a href="#2-Channel实现" class="headerlink" title="2 Channel实现"></a>2 Channel实现</h2><p>下面是 Java NIO 中最重要的 Channel 的实现：</p>
<ul>
<li><strong>FileChannel</strong>：从文件中读写数据。</li>
<li><strong>DatagramChannel</strong>：能通过 UDP 协议读写网络中的数据。</li>
<li><strong>SocketChannel</strong>：能通过 TCP 协议读写网络中的数据。</li>
<li><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，像 Web 服务器那样。对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<p>这些通道涵盖了 UDP 和 TCP 网络 I/O，以及文件 I/O。</p>
<h2 id="3-FileChannel"><a href="#3-FileChannel" class="headerlink" title="3 FileChannel"></a>3 FileChannel</h2><h4 id="从-channel-中读数据"><a href="#从-channel-中读数据" class="headerlink" title="从 channel 中读数据"></a>从 channel 中读数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 FileChannel 读取文件中的数据到 Buffer 中</span></span><br><span class="line"><span class="comment">     *  1、创建 FileChannel 对象</span></span><br><span class="line"><span class="comment">     *  2、创建 Buffer 对象</span></span><br><span class="line"><span class="comment">     *  3、通过 FileChannel 读取文件中的数据到 Buffer 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建FileChannel对象（FileChannel不能直接创建，创建该对象要依赖于一个File对象）</span></span><br><span class="line">        <span class="comment">// args1：文件路径。 args2：文件模式（读/写/执行）</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">afile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\nio\\src\\resource\\demo.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> afile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建Buffer对象，并分配buffer的大小（4字节）</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将数据从文件读取到Buffer中</span></span><br><span class="line">        <span class="comment">// 返回值用于记录当前次读取的字节数，等于-1时表示读取到了最后一行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> fileChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取了：&quot;</span> + bytesRead + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 目的：验证数据是否已经读到了buffer中。</span></span><br><span class="line"><span class="comment">            * 方式：取出buffer对象中的数据，打印在控制台上</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="comment">// 进行读写模式的转换【在这里转换的目的是为了输出读到的内容】</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// hasRemaining方法用于判断Buffer中是否还有剩余的数据内容</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 获取buffer中的内容</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) buffer.get();</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 循环从文件中读取数据到buffer中（当buffer中无数据后，bytesRead变量应该为-1）</span></span><br><span class="line">            bytesRead = fileChannel.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、释放资源</span></span><br><span class="line">        afile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;操作结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">读取了：4字节</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">读取了：4字节</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">读取了：1字节</span><br><span class="line">9</span><br><span class="line">操作结束</span><br></pre></td></tr></table></figure>



<h4 id="向-channel-中写数据"><a href="#向-channel-中写数据" class="headerlink" title="向 channel 中写数据"></a>向 channel 中写数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 向 Channel 中写数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、进行数据传输时需要使用到 Channel（通道），也就是说需要先创建一个连通两端（发送方/接收方）的通道</span></span><br><span class="line"><span class="comment">        2、创建 Channel 需要两端，其中一端为连接的发起方，在这里就是我们的代码端，所以我们必须还要手动指定</span></span><br><span class="line"><span class="comment">        另一端，一般我们会指定为一个文件。</span></span><br><span class="line"><span class="comment">      整个流程也就是说，把我们在代码中的数据发送给本机上的某个文件，在这两端之间建立一个 channel 用于数据传输，</span></span><br><span class="line"><span class="comment">      当然也会用到 buffer，因为 channel 的读或写操作都直接依赖于 buffer ，用 buffer 作为一个中转站，再去</span></span><br><span class="line"><span class="comment">      访问到具体的文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建 channel 对象，需要提前指定好 channel 的另一端，一般是一个文件对象</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo02.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、建立 磁盘文件 到 Java程序虚拟内存 间的连接通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、分配一块缓冲区，用于向channel中写数据</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、在内存中新建一段数据，并将其写入 buffer 中</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;This is my world!&quot;</span>).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        buffer.clear(); <span class="comment">// 使用前先清空buffer中的数据，这是一个好习惯</span></span><br><span class="line">        buffer.put(bytes);</span><br><span class="line"></span><br><span class="line">        buffer.flip();  <span class="comment">// 切换为读模式(向channel中写就意味着从buffer中读)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、将 buffer 中的数据写入 channel 中</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())</span><br><span class="line">        &#123;</span><br><span class="line">            channel.write(buffer);	<span class="comment">// 注意 write() 方法需要在while循环中进行调用，因为无法保证 write() 方法一次能向 channel 中写入多少字节，因此需要重复调用 write() 方法，直到 buffer 为空</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="通道间的数据传输"><a href="#通道间的数据传输" class="headerlink" title="通道间的数据传输"></a>通道间的数据传输</h4><p>两个通道间的数据可以进行直接的数据传输</p>
<h5 id="FileChannel-transferTo-transferFrom"><a href="#FileChannel-transferTo-transferFrom" class="headerlink" title="FileChannel#transferTo/transferFrom"></a>FileChannel#transferTo/transferFrom</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通道间的数据传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、建立两个通道</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo02.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel1</span> <span class="operator">=</span> file1.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel2</span> <span class="operator">=</span> file2.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、通道间进行数据传输（将channel1中的数据传输到channel2中）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> channel1.size();</span><br><span class="line"><span class="comment">//        channel1.transferTo(position, count, channel2);   // 方法1</span></span><br><span class="line">        channel2.transferFrom(channel1, position, count);   <span class="comment">// 方法2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、关闭资源</span></span><br><span class="line">        channel1.close();</span><br><span class="line">        channel2.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<h4 id="FileChannel-size-方法"><a href="#FileChannel-size-方法" class="headerlink" title="FileChannel#size()方法"></a>FileChannel#size()方法</h4><ul>
<li>  FileChannel 对象是根据其所关联的具体文件来创建的，</li>
<li>  所以 FileChannel 实例的 size() 方法将返回该实例所关联的文件的大小。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> fileChannel.size();	</span><br></pre></td></tr></table></figure>



<h4 id="FileChannel-truncate-方法"><a href="#FileChannel-truncate-方法" class="headerlink" title="FileChannel#truncate() 方法"></a>FileChannel#truncate() 方法</h4><ul>
<li>  FileChannel 实例一定会关联到某一个具体的文件</li>
<li>  可以使用 <strong>FileChannel#truncate()</strong> 方法来截取这个文件，截取文件时，会将指定长度后面的部分删除掉。截取后得到一个新的 fileChannel 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">newFileChannel</span> <span class="operator">=</span> fileChannel.truncate(<span class="number">1024</span>);	<span class="comment">// 截取文件的前 1024 个字节</span></span><br></pre></td></tr></table></figure>



<h4 id="FileChannel-force-方法"><a href="#FileChannel-force-方法" class="headerlink" title="FileChannel#force() 方法"></a>FileChannel#force() 方法</h4><ul>
<li>  在使用 Channel 时，出于性能考虑，操作系统会先将 channel 中的数据写出到缓存中，缓存区满了之后再将缓存中的数据写到磁盘上，所以一般情况下 fileChannel 无法保证数据一定会即时写到磁盘上。</li>
<li>  若想保证这一点，可以使用 FileChannel 的 force() 方法会将通道中尚未写入磁盘中的数据和缓存中的数据强制写到磁盘上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.force(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// force() 方法有一个 boolean 类型的参数，指明是否将数据写到磁盘上</span></span><br></pre></td></tr></table></figure>





<hr>
<h4 id="FileChannel-position-方法"><a href="#FileChannel-position-方法" class="headerlink" title="FileChannel#position() 方法"></a>FileChannel#position() 方法</h4><ul>
<li>  <strong>FileChannel#position()</strong> 方法可以获取 filechannel 当前读/写到的位置，</li>
<li>  也可以调用 position(long pos) 方法设置 fileChannel 的读/写的位置。</li>
<li>  该功能用于对 fileChannel 的某个特定位置进行读/写操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();	<span class="comment">// 获取 fileChannel 的当前位置</span></span><br><span class="line">channel.position(pos + <span class="number">123</span>);	<span class="comment">// 设置 fileChannel 的新的当前位置</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>  如果将当前位置设置在文件结束符之后，再试图从文件通道中读取数据，读方法将返回 -1。</li>
<li>  如果将当前位置设置在文件结束符之后，然后向通道中写数据，文件将被撑大到当前位置并写入数据。但是这有可能导致<strong>“文件空洞”</strong>，即磁盘上物理文件中写入的数据间有空隙。</li>
</ul>
<hr>
<h2 id="4-TCP协议相关的Channel"><a href="#4-TCP协议相关的Channel" class="headerlink" title="4. TCP协议相关的Channel"></a>4. TCP协议相关的Channel</h2><p>Channel接口有很多实现类，但是对于网络编程来说，实际上只有3个重要的通道类：SocketChannel、ServerSocketChannel和DatagramChannel。对于TCP连接，只需要前两个通道类；对于UDP连接只需要第三个通道类。</p>
<h3 id="4-1-SocketChannel"><a href="#4-1-SocketChannel" class="headerlink" title="4.1 SocketChannel"></a>4.1 SocketChannel</h3><p>SocketChannel对象可以读写<code>TCP Socket</code>。每个SocketChannel都与一个Socket对象关联。这个Socket对象可用于高级配置，但有些应用采用默认选项就可以正常运行，对于这些应用程序，可以忽略这个需求。</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>SocketChannel类没有公共的构造函数。但提供了两个静态 open() 方法来创建新的SocketChannel对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">(SocketAddress remote)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>第一个方法会尝试建立连接(通过系统调用告知操作系统内核尝试与远端建立连接)。这个方法是一个阻塞方法。也就是说，在连接建立或抛出异常之前，当前线程将一直处于阻塞状态。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open(address);</span><br></pre></td></tr></table></figure>

<p>无参版本的方法不会立即建立连接。它会创建一个初始未连接socket，以后必须用 connect() 方法进行连接。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">channel.connect(address);</span><br></pre></td></tr></table></figure>

<p>如果你希望以非阻塞的方式打开通道时，还需要配置通道的各项属性。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">channel.connect(address);</span><br></pre></td></tr></table></figure>

<p>或者你还想在连接前配置 socket 的各种选项，你可以选择一种更迂回的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> channel.socket();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">socket.connect(address);</span><br></pre></td></tr></table></figure>

<p>使用非阻塞通道时，connect() 方法会立即返回。在等待操作系统与远端服务器建立连接时，程序可以做其它事情。不过，程序在实际使用这个连接之前，一定要调用 finshConnect() 方法验证连接是否完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回true表示连接现在可以使用；</span></span><br><span class="line"><span class="comment"> * 返回false表示连接还未建立成功；</span></span><br><span class="line"><span class="comment"> * 如果连接无法建立，比如网络出现故障，将会抛出一个异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">finishConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>当然，这只对非阻塞模式是必须的。对于阻塞通道，当线程可以继续正常向后执行时连接一定已经建立成功了。</p>
<p>如果程序想检查连接是否完成，可以使用以下两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isConnectionPending</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>如果连接处于打开状态，isConnected() 方法会返回true。如果连接仍在建立过程中，isConnectionPending() 返回 true。</p>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>为了读取 SocketChannel 通道中的数据，首先要创建一个 ByteBuffer 对象，可以读取通道中的数据写到 Buffer 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>通道会用尽可能多的数据填充缓冲区，然后返回写入缓冲区的字节数。如果遇到流末尾，通道会将所有的剩余字节数写出到缓冲区，并且在下一次调用 read() 时返回<code>-1</code>。</p>
<p>如果通道是阻塞的，这个方法至少读取一个字节(读取成功)，或者返回<code>-1</code>(读取完成)，或者抛出异常(读取失败)。但如果通道是非阻塞的，这个方法可能返回<code>0</code>。</p>
<blockquote>
<ul>
<li>在阻塞模式下，若 SocketChannel 中没有数据可读，或者缓冲区满了，就会阻塞，直到满足读的条件(源有数据可读，目的地可以写数据)。所以一般阻塞模式的 read() 是比较简单的。</li>
<li>在非阻塞模式下，read() 方法返回 0 有两种情况：<ul>
<li>（1）首先是：某一时刻的 socketChannel 中没有数据可读会返回0。</li>
<li>（2）其次是：byteBuffer 中的 position 等于 limit 了，即 byteBuffer 缓冲区满了也会返回0；</li>
</ul>
</li>
</ul>
</blockquote>
<p>例如，下面的循环会一直读取从 socketChannel 读取数据向缓冲区写入，直到缓冲区填满或检测到流末尾为止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (buffer.hasRemaining() &amp;&amp; channel.read(buffer) != -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>





<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>Socket通道提供了读写方法，一般情况下它们是全双工的。要想写入，只需先填充一个 ByteBuffer，再将 ByteBuffer 中的数据写入通道中即可。</p>
<p>基本的 write() 方法接收一个缓冲区对象作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>与读取一样，如果通道是非阻塞的，这个方法不能保证会一次性将缓冲区中的全部内容写入到通道中。不过基于缓冲区游标的特性，你可以很容易的反复调用这个方法，直到缓冲区完全排空，且数据已经完全写入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (buffer.hasRemaining() &amp;&amp; channel.write(buffer) != -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>就像正常的 Socket 一样，在用完通道后应该将其关闭，释放它使用的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>如果通道已经关闭，再进行重复关闭将没有任何效果。如果试图读/写已关闭的通道，将抛出一个异常。如果不确定通道是否已经关闭，可以使用 isOpen() 方法检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通道已经关闭时，该方法返回 false；</span></span><br><span class="line"><span class="comment"> * 如果通道是打开的，则返回 true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>close() 和 isOpen() 方法是 Channel 接口中声明的仅有的两个方法，所有的通道类都共享这两个方法。</p>
<hr>
<h3 id="4-2-ServerSocketChannel"><a href="#4-2-ServerSocketChannel" class="headerlink" title="4.2 ServerSocketChannel"></a>4.2 ServerSocketChannel</h3><p>与 SocketChannel、DatagramChannel 不同，ServerSocketChannel 类并没有定义读和写的功能。ServerSocketChannel 类只有两个目的：监听并接受一个新的客户端连接和创建新的 SocketChannel 对象，它本身从不传递数据。</p>
<p>ServerSocketChannel 类本身只声明了4个方法，其中 accept() 最重要。该类还从其超类继承了几个方法，主要与向 Selector 注册来得到客户端连接通知有关。最后，与所有的通道一样，它有一个 close() 方法，用于关闭服务器 Socket。</p>
<h4 id="创建服务器Socket通道"><a href="#创建服务器Socket通道" class="headerlink" title="创建服务器Socket通道"></a>创建服务器Socket通道</h4><p>静态工厂方法 ServerSocketChannel.open() 用于创建一个新的 ServerSocketChannel 对象。不过，在 JDK7 之前，这个方法实际并不打开一个新的服务器 Socket，而只是创建一个 Channel 对象。在使用之前，需要调用 socket() 方法来获得相应的 ServerSocket 对象。之后，你就可以使用 serverSocket 的各种设置方法配置任何服务器选项。比如接收缓冲区的大小或 Socket 的超时值。最后，对于你希望绑定的端口，将这个 serverSocket 连接到对应端口的 SocketAddress。例如，下面的代码希望在端口 80 上打开一个 ServerSocketChannel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> server.socket();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">80</span>);</span><br><span class="line">socket.bind(address);</span><br></pre></td></tr></table></figure>

<p>在 Java7 之后，这个过程会更简单一些，因为现在 ServerSocketChannel 有了一个自己的 bind() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">80</span>);</span><br><span class="line">server.bind(address);</span><br></pre></td></tr></table></figure>

<p>JVM 在创建 ServerSocketChannel 对象时使用了工厂方法而不是构造函数，但是不同的虚拟机可以提供这个类的不同实现，从而更适用于本地硬件和操作系统。</p>
<h4 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h4><p>一旦打开并绑定了 ServerSocketChannel 对象，accept() 方法就可以监听新入站的 TCP 连接了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title function_">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>accept() 可以在阻塞或非阻塞模式下操作。</p>
<p>在阻塞模式下，accept() 方法等待入站连接。然后它接受一个连接，并返回连接到到远程客户端的一个 SocketChannel 对象。在建立连接之前，线程无法进行任何操作。这种策略适用于立即响应每一个请求的简单服务器。阻塞模式是默认模式。</p>
<p>在非阻塞模式下，如果没有入站连接，accept() 方法会返回 null。非阻塞模式更适合于需要为每个连接完成大量工作的服务器，这样就可以并发地处理多个请求。非阻塞模式一般与 Selector 配合使用。为了使 ServerSocketChannel 处于非阻塞模式，要向其 configureBlocking() 方法传入 false。</p>
<p>accept() 方法声明：出现错误时将抛出一个 IOException。IOException 的几个常见的子类及运行时异常如下：</p>
<ul>
<li>ClosedChannelException    关闭后无法重新打开一个 ServerSocketChannel。</li>
<li>AsynchronousCloseException    执行 accept() 方法时，另一个线程管理了这个 ServerSocketChannel</li>
<li>ClosedByInterruptException    一个阻塞 ServerSocketChannel 在等待时，另一个线程中断了这个线程。</li>
<li>NotYetBoundException    调用了 open()，但在调用之前没有将 ServerSocketChannel 对应的 ServerSocket 对象与地址绑定。这是一个运行时异常，不是 IOException 异常。</li>
<li>SecurityException    安全管理器拒绝这个应用程序绑定所请求的端口。</li>
</ul>
<h3 id="4-3-实战"><a href="#4-3-实战" class="headerlink" title="4.3 实战"></a>4.3 实战</h3><p>ServerSocketChannel 可以监听新进来的 TCP 连接。</p>
<p>SocketChannel 是一个连接到 TCP 网络套接字的。</p>
<p><strong>ServerSocketChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Date</span> 2022/6/19 21:11</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerSocketChannelTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="comment">// 1、建立一个新的(未绑定ServerSocket服务器的)的Channel通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、得到与 channel 相连的 serverSocket，并为 serverSocket 绑定端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));   <span class="comment">// 由于当前在服务器端，IP就是本机IP，所以直接绑定端口号即可</span></span><br><span class="line">        <span class="comment">// 从JDK7开始，上述两步可合为一步，代码如下：</span></span><br><span class="line">        <span class="comment">//serverSocketChannel.bind(new InetSocketAddress(port));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、设置通道(Channel)为非阻塞模式。当没有传入连接时，accept()方法返回null</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、服务器始终保持监听状态，监测是否有客户端请求连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是ServerSocket服务器，已经准备就绪。&quot;</span>);</span><br><span class="line">            <span class="comment">// 服务器通过 accept() 方法接收客户端发生的 socketChannel。(socketChannel中携带了客户端发送过来的数据)</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">            <span class="comment">// 如果没有入站请求，accept() 方法默认的返回值为null</span></span><br><span class="line">            <span class="keyword">if</span> (socketChannel == <span class="literal">null</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">//这里设置了：当没有客户端接入时，服务器等待3000ms后再重新监测</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当有连接到达服务器时：</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 先给客户端发送一个问候(服务器端-&gt;Buffer-&gt;SocketChannel)</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charsets.UTF_8.encode(<span class="string">&quot;Hello，I&#x27;m from socketServer&quot;</span>);</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Channel支持全双工数据传输，既有读的通道，也有也的通道，同时读写并不冲突</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                <span class="comment">// 再读取客户端中发送来的内容</span></span><br><span class="line">                <span class="type">SocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> socketChannel.socket().getRemoteSocketAddress();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端地址：&quot;</span> + address.toString());</span><br><span class="line">                <span class="comment">// 读取客户端发来的数据保存到buffer中</span></span><br><span class="line">                buffer.clear(); <span class="comment">// 复用buffer</span></span><br><span class="line">                socketChannel.read(buffer);</span><br><span class="line">                <span class="comment">// 打印buffer中的内容</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端发来的信息：&quot;</span> + Charsets.UTF_8.decode(buffer));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>SocketChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ReadableByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/19 21:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketChannelTest</span> &#123;</span><br><span class="line">    <span class="comment">// 服务器IP和进程端口号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT); <span class="comment">// Server Socket的地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个未连接 ServerSocket 的 SocketChannel(客户端Channel，客户端发出/接收的数据都要经过该channel)</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="comment">// 连接 socketChannel 与 socket</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> socketChannel.socket();</span><br><span class="line">        <span class="comment">// 建立客户端 socket 与服务器 serverSocket 的连接</span></span><br><span class="line">        socket.connect(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TCP连接需要一定时间，两个连接的建立需要进行“三次握手”</span></span><br><span class="line">        <span class="comment">// 可以调用 finishConnect() 方法查看连接是否完成，如果没有连接成功返回false</span></span><br><span class="line">        <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在连接中，请稍后...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功! ^_^&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向服务器发送消息[客户端代码 -&gt; Buffer -&gt; 客户端Channel -&gt; 服务器Channel]</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charsets.UTF_8.encode(<span class="string">&quot;Hello, I&#x27;m form client socket&quot;</span>);</span><br><span class="line">        System.out.println(buffer.position());</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得服务器发送给客户端的消息(服务器返回 -&gt; 客户端Channel -&gt; buffer -&gt; 打印输出)</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socketChannel.socket().getInputStream();</span><br><span class="line">        <span class="type">ReadableByteChannel</span> <span class="variable">newChannel</span> <span class="operator">=</span> Channels.newChannel(inputStream);</span><br><span class="line">        <span class="comment">// 读 newChannel 中的数据到 buffer 中</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        newChannel.read(buffer);</span><br><span class="line">        <span class="comment">// 展示buffer中的数据</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(Charsets.UTF_8.decode(buffer));</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="第四章-选择器-Selector"><a href="#第四章-选择器-Selector" class="headerlink" title="第四章 选择器[Selector]"></a>第四章 选择器[Selector]</h1><h2 id="1-选择器基础"><a href="#1-选择器基础" class="headerlink" title="1. 选择器基础"></a>1. 选择器基础</h2><p>选择器提供了一种<strong>选择执行已经就绪任务的能力</strong>。</p>
<blockquote>
<p><strong>已就绪任务</strong>：该任务已经从操作系统内核返回用户态的进程空间了，对程序而言，这就是“就绪”了。</p>
</blockquote>
<p>Selector 选择器允许单线程处理多个通道。</p>
<p>如果服务器同时维护着多个连接通道，并且每个连接通道的流量都比较低，这时候就可以使用 Selector 来管理多个通道。</p>
<p>一个线程维护一个 Selector 实例，一个 Selector 实例维护多个 Channel 通道，这样就实现了一个线程同时管理多个 Channel 通道。 </p>
<p><img src="http://processon.com/chart_image/62b453cdf346fb075472e93a.png" alt="img"></p>
<ul>
<li>要使用 Selector 选择器，就需要向 Selector 实例注册 Channel 实例，注册成功后会返回一个维护 Channel 与 Selector 间关系的对象(SelectionKey)，并在 SelectionKey 实例中记录当前 Selector 关心的通道和通道中发生的操作。选择键 selectionKey 会追踪通道是否就绪。</li>
<li>selector 实例可以调用它的 <code>select()</code> 方法，来获取其关联的 selectionKey 的最新状态(调用 <code>select()</code> 方法后，与 selector 实例关联的所有的 channel 的信息都会被更新)。以此来检查所有被注册到 selector 的 channel 的最新消息，可以选择出两次调用 <code>selec()</code> 方法的间隔内新就绪的 channel。</li>
<li>Selector 选择器提供了一种询问 Channel 通道是否已经准备好执行 I/O 操作的能力。比如：了解 ServerSocketChannel 是否有新的连接，SocketChannel 是否还有更多的字节需要读取。</li>
</ul>
<h3 id="1-1-三个相关的类"><a href="#1-1-三个相关的类" class="headerlink" title="1.1 三个相关的类"></a>1.1 三个相关的类</h3><p><strong>Selector 选择器</strong></p>
<ul>
<li>Selector 选择器对象通过 SelectionKey 对象管理着所有注册成功的通道(Channel)，包括通道的基本信息和就绪状态。</li>
</ul>
<p><strong>SelectableChannel 可被选择的通道</strong></p>
<ul>
<li><p>SelectableChannel 是一个抽象类，是所有支持就绪检查的通道类的基类。</p>
</li>
<li><p>注意：FileChannel 不是 SelectableChannel 的子类，即 FileChannel 是不能注册到 Selector 选择器上的。</p>
</li>
<li><p>一个 selectableChannel 实例可以注册到多个 selector 实例上，但是不能多次注册到同一个一个选择器上。</p>
<p>  <img src="http://processon.com/chart_image/62b471935653bb104192d9ed.png" alt="img"></p>
</li>
</ul>
<p><strong>SelectionKey 选择键</strong></p>
<ul>
<li>SelectionKey 封装了 selectableChannel 与 selector 之间的一种关联关系。</li>
<li>selectionKey 包含了两个 byte 集合，一个指示注册关系所关心的通道操作，另一个表示通道已经准备好的操作。</li>
</ul>
<h3 id="1-2-如何创建Selector选择器"><a href="#1-2-如何创建Selector选择器" class="headerlink" title="1.2 如何创建Selector选择器"></a>1.2 如何创建Selector选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建Selector实例[工厂模式]</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、channel通道必须设置为非阻塞模式才能注册到Selector选择器上</span></span><br><span class="line"><span class="type">SelectableChannel</span> <span class="variable">selectableChannel1</span> <span class="operator">=</span> ...;</span><br><span class="line">selectableChannel1.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 创建两个channel实例</span></span><br><span class="line"><span class="type">SelectableChannel</span> <span class="variable">selectableChannel2</span> <span class="operator">=</span> ...;</span><br><span class="line">selectableChannel2.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、把channel通道的OP_READ事件注册到selector上，会返回一个选择键(SelectionKey实例)</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> selectableChannel1.register(selector, SelectionKey.OP_READ); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     arg1：把channel通道注册到哪个selector上；</span></span><br><span class="line"><span class="comment">     arg2：selector选择器关注channel通道中的哪些操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用位运算符把selector关注的多种操作连接起来</span></span><br><span class="line">selectableChannel2.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     SelectionKey 包含的操作有：</span></span><br><span class="line"><span class="comment">         1) OP_CONNECT  通道中是否发生了“客户端请求连接服务器”的事件   </span></span><br><span class="line"><span class="comment">         2) OP_ACCEPT  只有 ServerSocketChannel 有这个事件，通道中是否发生了“查看新的连接”的事件</span></span><br><span class="line"><span class="comment">         3) OP_READ  通道中是否发生了“读操作准备就绪”事件</span></span><br><span class="line"><span class="comment">         4) OP_WRITE  通道中是否发生了“写操作准备就绪”事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、注册完成后，可调用 select() 方法轮询是否有就绪的通道</span></span><br><span class="line"><span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> selector.select(); <span class="comment">// select()方法返回就绪通道的数量</span></span><br></pre></td></tr></table></figure>





<h2 id="2-SelectionKey相关的方法"><a href="#2-SelectionKey相关的方法" class="headerlink" title="2. SelectionKey相关的方法"></a>2. SelectionKey相关的方法</h2><p>向 Selector 注册一个 Channel 通道时，就会返回一个 SelectionKey 选择键对象，这个 selectionKey 对象表示一个通道与一个选择器之间的关联关系。</p>
<p><img src="http://processon.com/chart_image/62b453cdf346fb075472e93a.png" alt="img"></p>
<p><strong>selectionKey 对象中的方法：</strong></p>
<ul>
<li><p>channel()    返回该键对应的通道</p>
</li>
<li><p>selector()    返回该键对应的选择器</p>
</li>
<li><p>cancel()    删除选择器与通道间的关联关系</p>
</li>
<li><p>isValid()    判断选择器与通道的关联关系是否有效</p>
</li>
<li><p>interestOps()    返回 selector 对象关注的该通道中的操作/事件。</p>
<ul>
<li><p>返回结果是一个整数，该整数是一个比特掩码，可以使用位运算符检查所关心的操作。如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 selector 对象关注的该通道中的事件的编码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该编码是否对应 SelectionKey.OP_READ </span></span><br><span class="line"><span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> interestOps &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">if</span> (key == SelectionKey.OP_READ)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是一个 SelectionKey.OP_READ 事件&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>readyOps()    返回通道中已经就绪的操作。</p>
<ul>
<li>返回值也是一个整数，也可以使用类似上面的位运算操作检测通道中有哪个事件/操作已经准备就绪。</li>
</ul>
</li>
<li><p>除了按位与操作外，还可以使用 selectionKey 对象的 isReadable()、isWritable()、isConnectable()、isAccetable() 等方法来检测通道中哪些事件已就绪。</p>
</li>
</ul>
<h2 id="3-使用选择器"><a href="#3-使用选择器" class="headerlink" title="3. 使用选择器"></a>3. 使用选择器</h2><p>Selector 选择器通过 SelectionKey 对象维护着所有注册成功的集合通道。</p>
<p>每个 Selector 对象都有以下三个集合：</p>
<ul>
<li>已注册的 selectionKey 对象集合(<code>Set&lt;SelectionKey&gt;</code> )：通过 <code>selector.keys()</code> 方法返回这个集合。</li>
<li>已就绪的 selectionKey 对象集合：通过 <code>selector.selectedkeys()</code> 方法返回。该集合中的每个成员都是相关通道及关注的事件被选择器判断已经准备好了的。</li>
<li>已取消的 selectionKey 对象集合：这个集合包含了调用过 cancel() 方法的 selectionKey 对象集合。</li>
</ul>
<p>对于新创建的 Selector 对象，这三个集合都为空。</p>
<br>

<p>Selector 类的核心就是 select() 选择，该方法调用时，执行以下步骤：</p>
<ol>
<li>检查 <code>已取消的 selectionKey 对象集合</code>，如果该集合非空，就把该集合中的 selectionKey 对象从另外两个集合中移除，并注销相关的通道。该步骤结束后，<code>已取消的 selectionKey 对象集合</code> 应该是空的。</li>
<li>检查 <code>Set&lt;SelectionKey&gt;</code> 集合中所有 selectionKey 对象的 interset 集合，判断每个通道所关注的操作/事件是否已经就绪。</li>
<li>返回两次调用 <code>select()</code> 方法的时间间隔内进入就绪状态的通道的数量。</li>
</ol>
<p><strong>基本操作流程：</strong></p>
<p>通常使用以下方法来管理这些键：</p>
<ol>
<li>调用选择器对象的 select() 方法，如果就绪通道的数量大于 0，则执行下一步。</li>
<li>遍历 <code>selector.selectedkeys()</code> 方法的返回结果，得到所有已就绪的通道及通道中事件的数据：<ol>
<li>检查集合中的每个元素，查看相关通道的就绪信息，并进行处理；</li>
<li>处理完毕后，将 selectionKey 从  <code>Set&lt;SelectionKey&gt;</code> 集合中移除；</li>
<li>继续检查下一个元素。</li>
</ol>
</li>
</ol>
<p><strong>通用代码模板：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/25 16:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 服务端选择器模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerSelectorTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        serverSocketChannel.bind(address);</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 将serverSocketChannel的OP_ACCEPT事件注册到selector上</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 持续监听</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 接受连接</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// 读数据</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable())&#123;</span><br><span class="line">                    <span class="comment">// 写数据</span></span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 移除处理完的selectionKey</span></span><br><span class="line">                selectionKeys.remove(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="动力节点"><a href="#动力节点" class="headerlink" title="动力节点"></a>动力节点</h1><h2 id="JVM读取数据模型"><a href="#JVM读取数据模型" class="headerlink" title="JVM读取数据模型"></a>JVM读取数据模型</h2><p><img src="http://processon.com/chart_image/62a86862e0b34d294473999b.png"></p>
<p>假设现在的场景是一个Java程序从磁盘上读取数据。</p>
<p>任何程序都是运行在操作系统之上的，所以还会涉及到一个操作系统的内核空间，由操作系统内核来真正读取磁盘上的数据。在读取数据时，内核会启动一个磁盘控制器组件来读取磁盘上的数据到操作系统内核的缓冲区中。这个读取过程叫做DMA（Direct Memory Access）。</p>
<p>而我们的 Java 程序是从操作系统内核的缓冲区中读取的数据。把操作系统的缓冲区的数据读取到JVM的内存中。</p>
<p>这就是一个最简单的Java程序读取磁盘数据的模型。</p>
<p>对于目前的计算机，程序在读取数据的时候，CPU的处理速度往往不是程序运行效率的短板，CPU的处理速度非常快。更多的时候，程序运行的快慢是由I/O的效率决定的。</p>
<p>对于现代计算机的操作系统，它的IO性能已经发展的非常好了，操作系统可以快速的传输数据。</p>
<p>但对于JVM而言，它为了提供统一的操作环境，它对一些操作系统的强大的功能给屏蔽了，也就是说，由于JVM自身在IO方面的效率不足，导致了程序运行的效率变慢。在操作系统中，它可以从硬件上很快的读取数据到缓冲区，但是JVM的IO只能慢速地从缓冲区读取数据。</p>
<p>从JDK4开始，引入了NIO，在很大程序上提升了Java程序的IO效率。</p>
<p>主要有以下这些包：</p>
<ul>
<li>  <code>java.nio.*</code>：定义了各种与Buffer相关的API</li>
<li>  <code>java.nio.channel.*</code>：定义了与Channel和Selector相关的API</li>
<li>  <code>java.nio.charset.*</code>：定义了与字符集相关的API</li>
</ul>
<h2 id="NIO与传统IO的区别"><a href="#NIO与传统IO的区别" class="headerlink" title="NIO与传统IO的区别"></a>NIO与传统IO的区别</h2><p>传统的IO是面向流的，每次可以从流中读取一个或多个字节，只能向后读取，不能向前移动。</p>
<p>NIO是面向缓冲区的，把数据读到一个缓冲区中，可以在缓冲区中向前/向后移动，增加了程序的灵活性。</p>
<p>在NIO中，所有的数据都需要通过Channel传输，通道可以直接将一块数据映射到内存中。</p>
<p>Channel是双向的，不仅可以读取数据，还能保存数据。程序不能直接读写Channel通道，Channel只与Buffer缓冲区交互。</p>
<p>Java程序在读数据的时候，会先把数据源（比如操作系统中的缓冲区）上的数据读到Channel，通过Channel将数据传递到Buffer，Java程序是从Buffer中读取数据。</p>
<p><img src="http://processon.com/chart_image/62a87a9f1efad4656677a49d.png"></p>
<p>传统IO（IO流）是线程阻塞的。在调用 read()/write() 读写数据时，线程会阻塞，直到数据读/写完毕。在读写过程中，线程不能执行其它任务。</p>
<p>NIO是线程不阻塞的。当线程从Channel中读取数据时，如果通道中没有可用的数据，线程不会阻塞，可以继续做其它的任务。</p>
<hr>
<hr>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="1-Channel概述-1"><a href="#1-Channel概述-1" class="headerlink" title="1. Channel概述"></a>1. Channel概述</h2><p>Channel 是一种新的 I/O 的访问方式，用于在字节缓冲区与通道另一侧的实体(可以是文件也可以是 Socket)之间进行数据的传输。</p>
<p>Channel 可以双向读写数据，也可以实现异步读写。</p>
<p>程序不能直接访问 Channel，Channel 只能与 Buffer 缓冲区进行交互。即：在执行读操作时，需要先把通道中的数据读到 Buffer 缓冲区中，程序再从 Buffer 中读取数据；在执行写操作时，程序会先把数据写入 Buffer 缓冲区中，再把 Buffer 中的数据写到 Channel 中。</p>
<p>常用的 Channel 有：</p>
<ul>
<li>  FileChannel  读写文件的通道。</li>
<li>  DatagramChannel  通过UDP读写网络数据的通道。</li>
<li>  SocketChannel/ServerSocketChannel  读写Socket套接字中数据的通道。</li>
</ul>
<h2 id="2-Scatter-Gather"><a href="#2-Scatter-Gather" class="headerlink" title="2. Scatter/Gather"></a>2. Scatter/Gather</h2><p>有时候如果能从一个源填充到多个缓冲区，这会很有用。这称为**散布(Scatter)**。下面两个方法接收一个 ByteBuffer 数组作为参数，按顺序填充数组中的多个 ByteBuffer。</p>
<blockquote>
<p>所在类：interface ScatteringByteChannel</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">read</span><span class="params">(ByteBuffer[] dsts, <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>第一个方法填充所有缓冲区。第二个方法则从位于 offset 的缓冲区开始，填充 length 个缓冲区。</p>
<p>在填充缓冲数组时，常用的代码范式如下，只要列表中最后一个缓冲区还有剩余空间，就可以继续填充。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer[] buffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[<span class="number">2</span>];</span><br><span class="line">buffers[<span class="number">0</span>] =ByteBuffer.allocate(<span class="number">1000</span>);</span><br><span class="line">buffers[<span class="number">1</span>] =ByteBuffer.allocate(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">while</span> (buffers[<span class="number">1</span>].hasRemaining() &amp;&amp; channel.read(buffers) != -<span class="number">1</span>)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将多个缓冲区的数据写入到一个 Socket 通常很有用。这称为**聚集(Gather)**。例如，你可能希望在一个缓冲区存储 HTTP 首部，在另一个缓冲区存储 HTTP 主体。具体实现甚至可使用两个线程同时填充这两个缓冲区。下面两个方法接受一个 ByteBuffer 对象作为参数，并按顺序依次排空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">write</span><span class="params">(ByteBuffer[] srcs, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>第一个方法依次排空所有缓冲区。第二个方法则从位于 offset 的缓冲区开始，排空 length 个缓冲区。</p>
<p><strong>分散读，集中写</strong></p>
<p>Scatter(分散) 和 Gather(集中)是通道提供的一个重要功能。Scatter、Gather 是指在多个缓冲区中实现一个简单的 IO 操作(有时也被称为矢量 IO)。</p>
<p>Scatter 是指从 Channel 通道中读取数据，把这些数据按顺序分散写入到多个 Buffer 缓冲区中。</p>
<ul>
<li>  从 Channel 中读取数据，先把数组存储到 buffer1 缓冲区中；</li>
<li>  buffer1 缓冲区满了之后，再把通道中的数据写入到 buffer2，当 buffer2 也写满之后，最后把数据写到 buffer3 中。</li>
</ul>
<p><img src="http://processon.com/chart_image/62aef1cd1efad41af0432596.png"></p>
<p>Gather 是指在写操作时，将多个 Buffer 缓冲区中的数据写到同一个 Channel 中。</p>
<ul>
<li>  Gather 先把 buffer1 中的数据写到 Channel 中；</li>
<li>  再把 buffer2 中的数据写到 Channel 中；</li>
<li>  最后把 buffer3 中的数据写到 Channel 中。</li>
</ul>
<p><img src="http://processon.com/chart_image/62aef4d1e401fd5a4d73630a.png"></p>
<p>Scatter、Gather 经常用于需要将传输的数据分开的场景。</p>
<p>如 Scatter 从一个 Channel 中读取数据存储到多个 Buffer 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">ByteBuffer[] bufferArray = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1, buffer2, buffer3&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">channel.read(bufferArray); <span class="comment">// 从bufferArray中读取数据</span></span><br></pre></td></tr></table></figure>

<p>使用 read() 方法从 channel 中读取数据，将 channel 中的顺序按照 bufferArray 数组中 buffer 的顺序依次存储到缓冲区中。</p>
<p>注意：必须在 buffer1 缓冲区写满后才能写入 buffer2 缓冲区。</p>
<p>使用 Scatter/Gather 处理的数据大小都是固定的。</p>
<h2 id="3-FileChannel-1"><a href="#3-FileChannel-1" class="headerlink" title="3. FileChannel"></a>3. FileChannel</h2><p>FileChannel 可以通过 RandomAccessFile、FileInputStream 或 FileOutputStream 对象调用 <code>getChannel()</code> 方法获取。</p>
<p>FileChannel 虽然是双向的，既有 read() 方法又有 write() 方法。但是根据 FileInputStream 获得的通道是只读的，如果调用 write() 方法会产生异常。并且如果访问的文件是只读属性的，也不能执行 write() 写操作。</p>
<p>FileChannel 对象是线程安全的，不过并非所有的线程操作都是多线程的，影响通道位置或者影响文件大小的操作都是单线程的。即如果有一个线程在执行会影响通道位置的操作，那么其它尝试此类操作的线程需要等待。</p>
<h3 id="3-1-内存映射文件"><a href="#3-1-内存映射文件" class="headerlink" title="3.1 内存映射文件"></a>3.1 内存映射文件</h3><p>FileChannel 常用的三类方法：<code>map()</code>、<code>read()</code> 和 <code>write()</code>。</p>
<p>map() 方法会创建一个由磁盘文件支持的虚拟内存映射，并在这块虚拟内存空间上封装一个 MappedByteBuffer 对象。需要注意的是：为一个文件建立虚拟内存映射后，文件数据通常不会从硬盘读到内存。当然这并非是绝对的，这取决于操作系统。</p>
<p><code>read()/write()</code> 方法的作用是从 Buffer 中读写数据。</p>
<p>通过内存映射机制访问文件会比常规方法更高效，因为不需要做明确的系统调用，操作系统的虚拟内存可以自动缓存内存页，这些是使用系统内存缓存的，不会消耗 JVM 的堆内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存映射文件：</span></span><br><span class="line"><span class="comment"> *  即把磁盘上某个文件的数据映射到虚拟内存中，以这种方式访问文件数据的效率比较高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 把当前类文件(ChannelTest.java)以内存映射的方式读到 out.txt 文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件的 File 对象</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src/test/java/com/donglijiedian/buffer/ChannelTest.java&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 Channel 读取文件内容</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="comment">// 创建输出Channel，用于把文件把存到 out.txt 文件中</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>).getChannel();</span><br><span class="line">    <span class="comment">// 将 inChannel 中的数据映射到虚拟内存中</span></span><br><span class="line">    <span class="type">MappedByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, file.length());</span><br><span class="line">    <span class="comment">// 把缓冲区中的数据输出到 outChannel 中</span></span><br><span class="line">    outChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以把 buffer 中的内容打印出来</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> Charsets.UTF_8.decode(buffer);</span><br><span class="line">    System.out.println(charBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-2-FileChannel双向传输"><a href="#3-2-FileChannel双向传输" class="headerlink" title="3.2 FileChannel双向传输"></a>3.2 FileChannel双向传输</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-3-缓冲区设置固定大小"><a href="#3-3-缓冲区设置固定大小" class="headerlink" title="3.3 缓冲区设置固定大小"></a>3.3 缓冲区设置固定大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读写文件时，设置缓冲区为固定大小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 把 data.txt 文件的内容复制到 data_backup.txt 文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、磁盘(data.txt) -&gt; Channel -&gt; Buffer</span></span><br><span class="line">    <span class="comment">// 2、Buffer -&gt; Channel -&gt; 磁盘(data_backup.txt)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data_backup.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">srcChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">dstChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 srcChannel 中读数据写到 buffer 中</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> srcChannel.read(byteBuffer);</span><br><span class="line">    <span class="keyword">while</span> (readBytes != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 把 buffer 中的内容写到 dstChannel 中</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        dstChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">// 继续读 srcChannel 中的内容到 buffer 中</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        readBytes = srcChannel.read(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 dstChannel 到 data_backup.txt 的过程自动完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-Channel到Channel的传输"><a href="#3-4-Channel到Channel的传输" class="headerlink" title="3.4 Channel到Channel的传输"></a>3.4 Channel到Channel的传输</h3><p>如果经常需要将文件从一个位置传输到另一个位置，可以直接使用通道与通道之间的传输，而不需要中间缓冲区(Buffer)来传递数据。</p>
<p>Channel 到 Channel 间的传输是及其快速的，特别是在底层操作系统提供本地支持的时候，有的操作系统可以不经过用户空间而是直接使用内核空间传输数据。</p>
<blockquote>
<p>  <strong>注意：</strong></p>
<p>  只有 FileChannel 类有这两个方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通道与通道之间数据的传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  把 data.txt 复制到 data_backup.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;data_backup.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 inChannel 从 0 开始的所有字节传输到 outChannel 中</span></span><br><span class="line">    <span class="comment">//inChannel.transferTo(0, file.length(), outChannel); // 等价表达</span></span><br><span class="line">    outChannel.transferFrom(inChannel, <span class="number">0</span>, file.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-Gather"><a href="#3-5-Gather" class="headerlink" title="3.5 Gather"></a>3.5 Gather</h3><h2 id="4-SocketChannel和ServerSocketChannel"><a href="#4-SocketChannel和ServerSocketChannel" class="headerlink" title="4. SocketChannel和ServerSocketChannel"></a>4. SocketChannel和ServerSocketChannel</h2><hr>
<h2 id="5-DatagramChannel"><a href="#5-DatagramChannel" class="headerlink" title="5. DatagramChannel"></a>5. DatagramChannel</h2><p>DatagramChannel 是对 UDP 无连接用户数据报协议的通道。</p>
<p><strong>DatagramChannelServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/22 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * UDP 没有所谓的客户端和服务器端，服务器和客户端在实现上没有什么区别，</span></span><br><span class="line"><span class="comment"> * 所以需要人为地给设置哪个机器是客户端，哪个机器是服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 模拟服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatagramChannelServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个初始通道(未绑定Socket)的通道</span></span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">datagramChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、初始化通道(绑定本地机器的IP和端口号)</span></span><br><span class="line">        datagramChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9090</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、设置为非阻塞模式</span></span><br><span class="line">        datagramChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器启动后，持续监听，等待客户端发送数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 接收客户端发送的数据，写到buffer中</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> (InetSocketAddress)datagramChannel.receive(buffer);</span><br><span class="line">            <span class="comment">// 如果没有客户端向服务器发送数据，address默认为null</span></span><br><span class="line">            <span class="comment">// 没有客户端发送数据</span></span><br><span class="line">            <span class="keyword">if</span> (address == <span class="literal">null</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有客户端发送数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端IP：&quot;</span> + address);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端端口号：&quot;</span> + address.getPort());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端发送的数据：&quot;</span> + Charsets.UTF_8.decode(buffer));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回数据给客户端</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">// arg1:发送给客户端的内容。  arg2：客户端地址</span></span><br><span class="line">            datagramChannel.send(Charsets.UTF_8.encode(content), address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/22 21:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *  DatagramChannel 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatagramChannelClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器IP和进程端口号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 datagramChannel，但无需初始化，由随机分配的端口号发送数据</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">serverAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT);</span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">datagramChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">        datagramChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(Charsets.UTF_8.encode(line));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 buffer 中的数据发送到服务器</span></span><br><span class="line">            buffer.flip();  <span class="comment">// 切换到读模式</span></span><br><span class="line">            datagramChannel.send(buffer, serverAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收服务器返回的数据</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">SocketAddress</span> <span class="variable">receive</span> <span class="operator">=</span> datagramChannel.receive(buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 receive=null 时，表示未接收到数据</span></span><br><span class="line">            <span class="keyword">while</span> (receive == <span class="literal">null</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;正在等待服务器端的响应结果......&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(Charsets.UTF_8.decode(buffer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-Pipe"><a href="#6-Pipe" class="headerlink" title="6. Pipe"></a>6. Pipe</h2><p>Pipe(管道)：用于在两个线程之间进行单向的数据传输。</p>
<p>数据传输过程如下图所示：</p>
<p>Pipe 由 Source 通道和一个 Sink 通道两部分组成。线程A负责把数据写到 Sink 通道中，线程B负责从 Source 通道中获取数据。在管道中完成数据从 Sink 通道到 Source 通道的传递。</p>
<p><img src="http://processon.com/chart_image/62b322b7e0b34d0712cdaa9a.png"></p>
<p><strong>Tip：</strong>Pipe 是一个管道，但是它有两个通道(Channel)。</p>
<blockquote>
<p><strong>Pipe 使用说明：</strong></p>
</blockquote>
<ol>
<li><p>创建 Pipe 实例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pipe</span> <span class="variable">pipe</span> <span class="operator">=</span> Pipe.open();</span><br></pre></td></tr></table></figure></li>
<li><p>向管道中写数据(向 sink 通道中写数据)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写数据首先要拿到 Sink 通道对象</span></span><br><span class="line">Pipe.<span class="type">SinkChannel</span> <span class="variable">sinkChannel</span> <span class="operator">=</span> pipe.sink();</span><br><span class="line"><span class="comment">// 将数据保存到 buffer 对象中</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charsets.UTF_8.encode(<span class="string">&quot;Hello Pipe&quot;</span>);</span><br><span class="line"><span class="comment">// 向 sink 通道中写数据</span></span><br><span class="line">sinkChannel.write(buffer);</span><br></pre></td></tr></table></figure></li>
<li><p>从管道中读数据(从 source 通道中读数据)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读数据首先要拿到 source 通道对象</span></span><br><span class="line">Pipe.<span class="type">SourceChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> pipe.source();</span><br><span class="line">buffer.flip(); <span class="comment">// 切换为读模式</span></span><br><span class="line"><span class="comment">// 从 source 通道中读数据</span></span><br><span class="line">sourceChannel.read(buffer);</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Charsets;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Pipe;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/6/22 22:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 演示在两个线程之间通过 Pipe 管道实现数据的传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.io.PipedOutputStream&#125; 和 &#123;<span class="doctag">@link</span> java.io.PipedInputStream&#125;</span></span><br><span class="line"><span class="comment"> * 分别是管道输出流类和管道输入流类。</span></span><br><span class="line"><span class="comment"> * 在管道通信时，线程A向 &#123;<span class="doctag">@link</span> java.io.PipedOutputStream&#125; 中写入数据，这些数据会</span></span><br><span class="line"><span class="comment"> * 自动发送到对应的 &#123;<span class="doctag">@link</span> java.io.PipedInputStream&#125; 中，线程B就可以从 &#123;<span class="doctag">@link</span> java.io.PipedInputStream&#125;</span></span><br><span class="line"><span class="comment"> * 中读取数据，从而实现线程A到线程B的数据传输。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 输入流对象和输出流对象</span></span><br><span class="line">        <span class="type">PipedInputStream</span> <span class="variable">pipedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedInputStream</span>();</span><br><span class="line">        <span class="type">PipedOutputStream</span> <span class="variable">pipedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedOutputStream</span>();</span><br><span class="line">        <span class="comment">// 在输入流对象和输出流对象之间建立连接[重要]</span></span><br><span class="line">        pipedInputStream.connect(pipedOutputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程</span></span><br><span class="line">        <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sender</span>(pipedOutputStream);</span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>(pipedInputStream);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sender).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(receiver).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送数据的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PipedOutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sender</span><span class="params">(PipedOutputStream outputStream)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.outputStream = outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟发送数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello, sender：&quot;</span> + i + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">                <span class="comment">// 将字符串数据写到outputStream流中</span></span><br><span class="line">                outputStream.write(text.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收数据的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PipedInputStream inputStream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Receiver</span><span class="params">(PipedInputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inputStream = inputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">                len = inputStream.read(bytes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<hr>
<h1 id="咕泡教育"><a href="#咕泡教育" class="headerlink" title="咕泡教育"></a>咕泡教育</h1><h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2. ByteBuffer"></a>2. ByteBuffer</h2><h3 id="2-3-Buffer常见方法"><a href="#2-3-Buffer常见方法" class="headerlink" title="2.3 Buffer常见方法"></a>2.3 Buffer常见方法</h3><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>可以使用 allocate() 方法为 ByteBuffer 分配空间，其它 XxxBuffer 类也有类似的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  在 NIO 中，buffer 空间的大小，一经分配，就不能再发生改变。而在 Netty 中对这一点做了增强，Netty 支持对 buffer 的大小进行后修改。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testByteBufferAllocate</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(ByteBuffer.allocate(<span class="number">16</span>).getClass()); <span class="comment">//class java.nio.HeapByteBuffer</span></span><br><span class="line">    System.out.println(ByteBuffer.allocateDirect(<span class="number">16</span>).getClass()); <span class="comment">//class java.nio.DirectByteBuffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        class java.nio.HeapByteBuffer</span></span><br><span class="line"><span class="comment">            - Buffer空间使用的是JVM的堆内存。</span></span><br><span class="line"><span class="comment">            - 与操作系统的直接内存相比，堆内存的读写效率较低。</span></span><br><span class="line"><span class="comment">            - 堆内存空间会受到GC的影响。（可能会在GC时发生数据的移动，降低效率）</span></span><br><span class="line"><span class="comment">       **********************************************************</span></span><br><span class="line"><span class="comment">        class java.nio.DirectByteBuffer</span></span><br><span class="line"><span class="comment">            - Buffer空间使用的是直接内存。</span></span><br><span class="line"><span class="comment">            - 直接内存的读写效率较高。因为它相比于JVM堆内存少一次数据的拷贝。</span></span><br><span class="line"><span class="comment">            - 使用的是系统内存，不会受到GC的影响。</span></span><br><span class="line"><span class="comment">            - 缺点：</span></span><br><span class="line"><span class="comment">                - 需要调用操作系统来分配内存，分配时的效率较低。</span></span><br><span class="line"><span class="comment">                - 如果使用不当，可能会造成内存泄露。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="向Buffer中写入数据"><a href="#向Buffer中写入数据" class="headerlink" title="向Buffer中写入数据"></a>向Buffer中写入数据</h4><p>有两种方法。</p>
<ol>
<li><p>调用 channel 的 read() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取channel中的数据，写到buffer中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>

</li>
<li><p>调用 buffer 自己的 put() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.put((<span class="type">byte</span>) <span class="number">127</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h4><p>同样有两种办法。</p>
<ol>
<li><p>调用 channel 的 write() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将buffer中的数据写到channel中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buffer);</span><br></pre></td></tr></table></figure></li>
<li><p>调用 buffer 自己的 get() 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buffer.get();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get() 方法会让 position 指针向后走，如果想重复读取数据</p>
<ul>
<li>  可以调用 rewind() 方法将 position 重新置为 0。</li>
<li>  或者调用 get(int index) 获取索引 index 的内容，它不会移动指针。</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_rewind_and_getX</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    buffer.flip(); <span class="comment">// buffer的初始模式为写模式，如需读取数据需要切换为读模式</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//1</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//2</span></span><br><span class="line">    buffer.rewind();</span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//1</span></span><br><span class="line">    System.out.println(buffer.get(<span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="mark-amp-reset"><a href="#mark-amp-reset" class="headerlink" title="mark &amp; reset"></a>mark &amp; reset</h4><ul>
<li>  mark：做一个标记，记录 position 的位置</li>
<li>  reset：将 position 重置到 mark 的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_mark_and_reset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//1</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//2</span></span><br><span class="line">    buffer.mark(); <span class="comment">//加标记</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//3</span></span><br><span class="line">    buffer.reset(); <span class="comment">//回到标记</span></span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//3</span></span><br><span class="line">    buffer.reset();</span><br><span class="line">    System.out.println(buffer.get()); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h4><p><strong>字符串–&gt;ByteBuffer</strong></p>
<ol>
<li><p>手动分配buffer，手动将字符串转为字节数据，并添加到buffer中</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、字符串 --&gt; ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">buffer1.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li>
<li><p>Charset</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、Charset</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>wrap()</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、wrap()</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>  <strong>Tip</strong></p>
<p>  方式二和方式三在完成字符串到ByteBuffer的转换后，会自动将当前模式切换到读模式，在读模式下可以直接读取Buffer中的数据。而在方式一中，必须手动切换为读模式才能正常读到Buffer中的数据。</p>
</blockquote>
<p><strong>ByteBuffer –&gt; 字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StandardCharsets</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(buffer2).toString();</span><br><span class="line">System.out.println(string); <span class="comment">//hello</span></span><br></pre></td></tr></table></figure>





<h3 id="2-4-Scattering-Reads"><a href="#2-4-Scattering-Reads" class="headerlink" title="2.4 Scattering Reads"></a>2.4 Scattering Reads</h3><blockquote>
<p>  <strong>分散读，集中写</strong></p>
</blockquote>
<p>分散读取。</p>
<p><strong>需求：</strong>已知一个文本文件 3parts.txt。文件的三部分分别是3、3、5个字节。需要将这个文件读取到Buffer中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onetwothree</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>  思路一：将这三部分的内容（3+3+5=11字节）全部读到一个 ByteBuffer 中，之后再利用其它手段将ByteBuffer拆分为三部分。</li>
<li>  思路二：在读取的时候按照 3/3/5 字节将这个文件中的内容读取到三个 ByteBuffer 中。这种方式就叫做 Scattering Reads（分散读）</li>
</ul>
<p><strong>演示：</strong></p>
<p>使用如下方式读取，可以将数据填充到三个Buffer中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分散读（测试用例）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScatteringReads</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;src/main/resources/3parts.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 从channel中读数据写到多个buffer中</span></span><br><span class="line">    channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">    <span class="comment">// 尝试打印查看buffer中是否已经写入了数据</span></span><br><span class="line">    buffer1.flip();</span><br><span class="line">    buffer2.flip();</span><br><span class="line">    buffer3.flip();</span><br><span class="line">    System.out.println((<span class="type">char</span>) buffer1.get(<span class="number">0</span>)); <span class="comment">//o</span></span><br><span class="line">    System.out.println((<span class="type">char</span>) buffer2.get(<span class="number">0</span>)); <span class="comment">//t</span></span><br><span class="line">    System.out.println((<span class="type">char</span>) buffer3.get(<span class="number">1</span>)); <span class="comment">//h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-5-Gathering-Writes"><a href="#2-5-Gathering-Writes" class="headerlink" title="2.5 Gathering Writes"></a>2.5 Gathering Writes</h3><p>集中写</p>
<p><strong>需求：</strong>已有 3 个 ByteBuffer，先需将这 3 个 ByteBuffer 写入到一个文件中。</p>
<p><strong>思路：</strong></p>
<ul>
<li>  思路一：先将这 3 个 ByteBuffer 组合成一个更大的 ByteBuffer，再将大的 ByteBuffer 写入到文件中。</li>
<li>  思路二：按照一定的顺序分别将这 3 个 ByteBuffer 写到同一个文件中（追加写）。</li>
</ul>
<p><strong>演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集中写（测试用例）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGatheringWrites</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;am&quot;</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;are&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;3parts2.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    channel.write(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1, buffer2, buffer3&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结束后，查看文件可以看到数据已经写入。</p>
<hr>
<h2 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3. 文件编程"></a>3. 文件编程</h2><h3 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h3><blockquote>
<p>  <strong>注意</strong></p>
<p>  FileChannel 只能工作在阻塞模式下，不能配合 Selector 使用。只有网络编程中的 Channel，如 SocketChannel 等才能配合 Selector 工作在非阻塞模式下。</p>
</blockquote>
<p><strong>获取：</strong></p>
<p>FileChannel 不能直接创建，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 <strong>getChannel()</strong> 方法。</p>
<ul>
<li>  通过 FileInputStream 获取的 Channel 只能读；</li>
<li>  通过 FileOutputStream 获取的 Channel 只能写；</li>
<li>  通过 RandomAccessFile 获取的 Channel 的读写权限根据构造 RandomAccessFile 时的读写模式决定。</li>
</ul>
<p><strong>读取：</strong></p>
<p>读取 channel 中的数据写入到 buffer 中。返回值表示读取到了多少字节，<code>-1</code> 表示读取到了文件的末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>



<p><strong>写入：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ...;</span><br><span class="line">buffer.put(...); <span class="comment">//存入数据</span></span><br><span class="line">buffer.flip(); <span class="comment">//切换到读模式</span></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 while 中调用 channel.write() 方法时因为 write() 方法不能保证一次将 buffer 中的内容全部写入 channel 中。</p>
<p><strong>关闭：</strong></p>
<p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close() 方法会间接地调用 channel 的 close() 方法。</p>
<p><strong>位置：</strong></p>
<ul>
<li><p>获取当前位置</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();</span><br></pre></td></tr></table></figure></li>
<li><p>设置当前位置</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">newPos</span> <span class="operator">=</span> ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></table></figure>

<ul>
<li>设置当前位置时，如果设置为文件的末尾：<ul>
<li>  这时读会返回 <code>-1</code>；</li>
<li>  这时写入，会追加内容。但要注意，如果 position 超过了文件末尾，在执行写入时新内容和原末尾之间会用 0 填充。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>大小：</strong></p>
<p>使用 size 方法获取文件的大小。</p>
<p><strong>强制写入</strong></p>
<p>操作系统出于性能的考虑，会先将数据写入操作系统的缓存中，而不是立刻写入磁盘。但是可以调用 force(true) 方法将文件内容和元数据(文件的权限等信息)立刻写入磁盘。</p>
<hr>
<h3 id="3-2-两个Channel间传输数据"><a href="#3-2-两个Channel间传输数据" class="headerlink" title="3.2 两个Channel间传输数据"></a>3.2 两个Channel间传输数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个channel之间数据的传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_fileChannelTransferTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;b.txt&quot;</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">    <span class="comment">// 效率高，底层会利用操作系统的“零拷贝”进行优化</span></span><br><span class="line">    <span class="comment">// transferTo 方法每次传输的数据不能大于2G，超过2G的内容将被丢弃</span></span><br><span class="line">    from.transferTo(<span class="number">0</span>, from.size(), to);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    log.info(<span class="string">&quot;transferTo 用时&#123;&#125;秒&quot;</span>, (end-start)/<span class="number">1000_000.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-3-Path"><a href="#3-3-Path" class="headerlink" title="3.3 Path"></a>3.3 Path</h3><p>JDK7 引入了 Path 和 Paths 类。</p>
<ul>
<li>  Path 用来表示文件/目录。</li>
<li>  Paths 是工具类，用来获取 Path 实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\1.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">source3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:/1.txt&quot;</span>); <span class="comment">//另一种等价写法</span></span><br><span class="line"><span class="comment">// 目录+文件名</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source4</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>);</span><br><span class="line"><span class="comment">// 获取网络资源</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">source5</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;http://processon.com/chart_image/62a885837d9c082d0b2cb18d.png&quot;</span>);</span><br></pre></td></tr></table></figure>





<h3 id="3-4-Files"><a href="#3-4-Files" class="headerlink" title="3.4 Files"></a>3.4 Files</h3><p>检查文件/目录是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> Files.exists(path);</span><br></pre></td></tr></table></figure>



<p>创建一级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> ...;</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果目录已存在，会抛出 FileAlreadyExistsException 异常</li>
<li>  不能一次创建多级目录，否则会抛出 NoSuchFileException 异常。</li>
</ul>
<p>创建多级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> ...;</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>



<p>拷贝文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  如果目标文件已存在，会抛出 FileAlreadyExistsException 异常</p>
</li>
<li><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>移动文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>

<ul>
<li>  StandardCopyOption.ATOMIC_MOVE 用来保证文件移动时的原子性。</li>
</ul>
<p><strong>删除文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;target.txt&quot;</span>);</span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果文件不存在，会抛出 NoSuchFileException 异常。</li>
</ul>
<p><strong>删除目录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/a/b&quot;</span>);</span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果目录中还有内容，会抛出 DirectoryNotEmptyException 异常。</li>
</ul>
<p><strong>遍历目录中的文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历目录中的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilesWalkFileTree</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Software\\Dev\\Java\\jdk1.8.0_162&quot;</span>);</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Files.walkFileTree(source, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====&quot;</span> + dir);</span><br><span class="line">            dirCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;dir count&quot;</span> + dirCount);</span><br><span class="line">    System.out.println(<span class="string">&quot;file count&quot;</span> + fileCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>查看目录下的所有 jar 包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看目录下的所有jar包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilesWalkFileTreeExt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Software\\Dev\\Java\\jdk1.8.0_162&quot;</span>);</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">jarFileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Files.walkFileTree(source, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.toString().endsWith(<span class="string">&quot;.jar&quot;</span>))&#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                jarFileCount.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;file count：&quot;</span> + jarFileCount);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>使用 walkFileTree 实现删除多级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 walkFileTree 实现删除多级目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestWalkFileTreeDel</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\study\\http_study - 副本&quot;</span>);</span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====&gt; 进入&#123; &quot;</span> + dir + <span class="string">&quot; &#125;目录&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="comment">// 删除文件</span></span><br><span class="line">            Files.delete(file);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;==== 退出&#123; &quot;</span> + dir + <span class="string">&quot; &#125;目录&quot;</span>);</span><br><span class="line">            <span class="comment">// 删除目录</span></span><br><span class="line">            Files.delete(dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 walkFileTree 实现递归文件夹的拷贝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 walkFileTree 实现递归文件夹的拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWalkFileTreeCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\study\\http_study&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\study\\http_study - 副本&quot;</span>);</span><br><span class="line">    Files.walkFileTree(source, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====&gt; 进入&#123; &quot;</span> + dir + <span class="string">&quot; &#125;目录&quot;</span>);</span><br><span class="line">            <span class="comment">// 拷贝外层文件夹（文件夹需要创建，文件才需要拷贝）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> dir.toString().replace(source.toString(), target.toString());</span><br><span class="line">            Files.createDirectory(Paths.get(targetName));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            <span class="comment">// 拷贝内层文件</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> file.toString().replace(source.toString(), target.toString());</span><br><span class="line">            Files.copy(file, Paths.get(targetName));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4-网络编程（重点）"><a href="#4-网络编程（重点）" class="headerlink" title="4. 网络编程（重点）"></a>4. 网络编程（重点）</h2><h3 id="4-1-非阻塞-vs-阻塞"><a href="#4-1-非阻塞-vs-阻塞" class="headerlink" title="4.1 非阻塞 vs. 阻塞"></a>4.1 非阻塞 vs. 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>  在没有数据可读，或数据复制过程中，线程必须阻塞等待。不会占用CPU，但线程相当于闲置。</li>
<li>  32位JVM一个线程320K，64位JVM一个线程1024K。为了减少线程数，需要采用线程池技术。</li>
<li>  但即使使用了线程池，如果有很多连接建立，长时间的 inactive，会阻塞线程池中的所有线程。</li>
</ul>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>  在某个 Channel 没有可读事件时，线程不必阻塞，它可以去处理其它有可读事件的 Channel。</li>
<li>  但是在数据复制过程中，线程实际还是阻塞的（AIO改进的地方）</li>
<li>  写数据时，线程只是等待数据写入 Channel 中即可，无需等待 Channel 通过网络把数据发送出去。</li>
</ul>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>线程必须配合 Selector 才能完成对多个 Channel 可读事件的监控，这称之为多路复用。</p>
<ul>
<li>  多路复用仅针对网路IO，普通文件IO无法利用多路复用。</li>
<li>  如果不用 Selector 多路复用，那么 Channel 读取到的字节很多时候都是 0，而 Selector 保证了有可读事件才去读取。</li>
<li>  Channel 输入的数据一旦准备好，就会触发 Selector 的可读事件。</li>
</ul>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p><strong>BIO 执行流程</strong></p>
<ol>
<li> 服务器启动；</li>
<li> 客户端通过 Socket 向服务器发起通信，默认情况下服务器端会为每一个请求建立一个线程与之通讯；</li>
<li> 客户端发出请求后，会先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝；</li>
<li> 如果有响应，客户端线程会等待请求结束后，再执行其它操作。在请求未结束前，不允许执行其它操作，即会陷入阻塞。</li>
</ol>
<p>进程是不能直接发送网络包的，需要调用系统调用将数据复制到内核，内核使用网卡驱动程序进行发送。</p>
<p>服务器的实现模式为一个线程处理多个请求（连接），客户端发送的请求都会被注册到多路复用器（Selector）上，多路复用器轮询到连接有 IO 请求时就处理，没有则继续轮询。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/07/volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/07/volatile/" class="post-title-link" itemprop="url">volatile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-07 16:28:28" itemprop="dateCreated datePublished" datetime="2021-08-07T16:28:28+08:00">2021-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-08 11:08:26" itemprop="dateModified" datetime="2021-08-08T11:08:26+08:00">2021-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1    前置知识"></a>1    前置知识</h1><p>在 Java 内存模型中，我们知道了 JMM 有一个主内存，每个线程有自己的私有工作内存，工作内存中保存了一些变量在主内存的拷贝。</p>
<blockquote>
<p>  <strong>内存可见性：</strong></p>
</blockquote>
<p>指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。</p>
<blockquote>
<p>  <strong>重排序</strong></p>
</blockquote>
<p>为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。</p>
<hr>
<h1 id="2-Volatile-概述"><a href="#2-Volatile-概述" class="headerlink" title="2    Volatile 概述"></a>2    Volatile 概述</h1><ol>
<li> volatile 是 Java 提供的轻量级的同步机制（乞丐版的 syschorcize）</li>
<li>volatile <strong>三大特性</strong><ul>
<li>  保证变量的<strong>内存可见性</strong></li>
<li>  <strong>禁止 volatile 变量与普通变量重排序</strong></li>
<li>  不保证原子性</li>
</ul>
</li>
</ol>
<h1 id="3-内存可见性"><a href="#3-内存可见性" class="headerlink" title="3    内存可见性"></a>3    内存可见性</h1><ul>
<li>  可见性是指当一个线程运行时能感知到另一个线程对共享变量做出的改变。</li>
</ul>
<h2 id="3-1-验证普通变量之间的内存不可见性"><a href="#3-1-验证普通变量之间的内存不可见性" class="headerlink" title="3.1    验证普通变量之间的内存不可见性"></a>3.1    验证普通变量之间的内存不可见性</h2><ul>
<li>  如果两个线程不是同时执行的，而是先后执行，因为每次本地内存中对共享变量的改变都会写回到主内存中，另一个线程接着再取出来的是更改过的共享变量。这就相当于是一个单线程了。</li>
<li>  简单点就是说，A、B两个线程并发执行，B 线程正在用着 num，并且可能还要继续用一段时间，这时候线程 A 修改了 num 的值，B线程马上就知道了，这叫做线程间变量的可见性。（用着用着 num 突然变了）  </li>
<li>  而 A、B 两个线程先后被创建，然后开始并发执行，如果B线程在创建之前A线程就已经修改完 num 的值并将其写回主内存了，那么B线程得到的 num 变量的副本自然也是被 A 线程修改后的 num。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VisibleDemo</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag == <span class="literal">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">VisibleDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VisibleDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            	<span class="comment">// Thread.sleep(100);</span></span><br><span class="line">                demo.method1();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            demo.method2();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  我们来分析一下这段代码，线程 A 调用了 <code>method1()</code>，线程 B 调用了 <code>method2()</code>，线程A 和线程B 并发执行。</li>
<li>  我们想象中的是由于 flag 没有使用 volatile 修饰，那么在线程 A 中对 flag 的改变线程B 不能感知到，那么线程B 自然就会进入到死循环中了，导致 JVM 进程不能结束。</li>
<li>  但程序的真实结果是线程B执行了，即知道了 flag 的改变，死循环不会执行，而是会执行输出语句。这是为什么呢？难道不加 volatile 也能保证可见性吗？其实不是的。</li>
<li>  由于我们上面这段代码非常简单，在 main 方法中有创建 A、B 两个线程的操作，先创建A，再创建B。但是由于A线程执行的时间太短了，所以在线程B执行之前A线程已经执行完了 <code>method1()</code> 方法，并且把修改后的 flag 重写回了主内存。这时B线程才去执行 <code>run()</code>，所以B线程创建时从主内存中复制过去的变量 flag 已经是修改过的值了，即<code>flag==true</code>，所以自然不会进入死循环了。</li>
<li>  如果想要验证不加 volatile 就不具备可见性，可以让线程 A 先睡眠 100ms，让线程B先执行 method2 方法进入死循环，再让线程A去修改 flag 的值，发现程序不能结束，这也就验证了此时线程间确实是不具备可见性的。</li>
</ul>
<hr>
<h2 id="3-2-验证-volatile-能保证可见性"><a href="#3-2-验证-volatile-能保证可见性" class="headerlink" title="3.2    验证 volatile 能保证可见性"></a>3.2    验证 volatile 能保证可见性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/*volatile*/</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// child线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========End of Child Thread&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Child&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;turn flag off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面这段代码在运行时，存在两个线程 child 和 main，一个保存在主内存中的变量 flag。</p>
<ol>
<li>由于 main 线程在创建子线程后会睡眠100ms，所以 child 线程开始执行，检测到 <code>flag == true</code>，child 线程进入死循环中。</li>
<li>mian 线程在睡醒后继续执行，修改 <code>flag=false</code>并在控制台上输出指定内容，然后主线程结束。</li>
<li>但这是我们会发现程序并没有结束，因为 child 线程仍处于死循环状态。也就是说<strong>main 线程修改全局变量 flag=false ，并不能被 child 线程感知到</strong>。</li>
</ol>
<p><img src="/2021/08/07/volatile/image-20210506143613131.png" alt="image-20210506143613131"></p>
<p>但是如果我们将 <strong>volatile</strong> 关键字的注释打开，代码的执行流程就变成了：</p>
<ol>
<li>child 线程开始执行，检测到 <code>flag == true</code>，进入死循环中。</li>
<li>mian 线程在睡醒后继续执行，修改 <code>flag = false</code>并在控制台上输出指定内容，然后主线程结束。</li>
<li>但是此时 child 线程监听了到主线程对于 flag 变量的修改，即在 child 线程的感知中 <code>flag == false</code> 了，所以 child 线程退出死循环，在控制台上打印指定内容，child 线程结束。</li>
<li>整个 JVM 进程结束。</li>
</ol>
<p><img src="/2021/08/07/volatile/image-20210506143757319.png" alt="image-20210506143757319"></p>
<p><strong>总结：</strong></p>
<p>上面的代码可以证明：<strong>volatile 关键字可以保证多个线程之间共享变量的可见性</strong>。即共享变量在某个线程中的本地内存中发生了变化，其它的线程也可以监听到这种变化！当然这种<strong>监听的底层原理还是通过主内存作为传输纽带进行交互的</strong>，即单个线程在本地内存中对共享变量的操作最终还是要写回到主内存中，再由主内存将这种变化通知到其它所有使用这个共享变量的线程。</p>
<hr>
<h1 id="4-不保证原子性"><a href="#4-不保证原子性" class="headerlink" title="4    不保证原子性"></a>4    不保证原子性</h1><blockquote>
<p>  <strong>代码验证</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  验证 volatile 不保证原子性</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *      新建20个线程，每个线程都调用1000次 autoIncrement() 方法对共享变量num进行自增的操作，</span></span><br><span class="line"><span class="comment"> *      让 main 线程休眠一段时间直到这20个新建的线程执行完毕后再查看堆内存中num的值，在无错的情况下，</span></span><br><span class="line"><span class="comment"> *      num 的值应该是 0+20*1000=20000</span></span><br><span class="line"><span class="comment"> *      但是实际情况确实，大多数情况下这个值都小于20000，且值不确定。这说明了volatile并不能保证原子性，</span></span><br><span class="line"><span class="comment"> *      即 volatile 并不能保证线程安全。在某个线程执行的时候，可能会被其它线程加塞。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.autoIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(myData.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">     <span class="comment">/*  此时 num 前面是加了 volatile 关键字修饰的，但是 volatile 并不能保证变量的原子性   */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoIncrement</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>为什么说 volatile 不能保证原子性？</strong></p>
</blockquote>
<p>因为在 <code>MyData#autoIncrement()</code> 方法中，可能存在多个线程同时执行了 num++ 操作。</p>
<p><strong>num++</strong> 这一行代码的实际操作可分为三个步骤：<code>读 --&gt; 改 --&gt; 写</code></p>
<ol>
<li> 读：首先从主内存中拿到 num 的值，复制一份到自己的工作内存中；[<code>getfield #2 &lt;com/juc/day01/Test.n&gt;</code>]</li>
<li> 改：在自己的工作内存中对 num 进行自增操作；[<code>iadd</code>]</li>
<li> 写：将更改后的 num 写回到主内存中去。[<code>putfield #2 &lt;com/juc/day01/Test.n&gt;</code>]</li>
</ol>
<p><img src="/2021/08/07/volatile/image-20210709105405172.png" alt="image-20210709105405172"></p>
<p>原子性就是对 num 的操作，即 “读 –&gt; 改 –&gt; 写” 这三个步骤是不可分割的，而 volatile 不能保证原子性。</p>
<p>​        在保证原子性的情况下 num++ 的执行流程应该是：假设线程 A、B、C 并发执行，线程 A 拿到了 num=0，复制副本后在自己的工作空间中将其更新为 num=1，然后再将其写回到主内存中。这时候其它线程再去对 num 进行操作，这是一个完整的具备原子性的操作流程。</p>
<p>​        而在不能保证原子性的情况下则会出现，线程 A、B、C 同时拿到了主内存中的值 num=0，并在各自的内存空间将 num 更新为 1。接下来三个线程需要将更新后的值写回主内存中，假设 A 先写回主内存，主内存中的共享变量改变后需要通知其它线程，但是在这个通知还未发送到 B、C 线程的时候，B、C 线程就已经把写回主内存的操作都做完了，那么此时主内存中的值仍然会是 1，最后一个写入到主内存的 1 会覆盖前面两个写入到主内存的 1。而我们知道实际的运算结果本应该是 3。所以说在不能保证原子性的前提下，上述代码执行的结果大概率会小于 20000。</p>
<blockquote>
<p>  <strong>如何解决 volatile 不能保证原子性的问题？</strong></p>
</blockquote>
<ol>
<li> 使用 synchronized 关键字加锁（可以解决，但的锁太重）</li>
<li> 使用 JUC 包下的 AtomicInteger</li>
</ol>
<p>查看 JavaDoc 可知，在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html">java.util.concurrent.atomic</a> 包下包含了一系列的能保证原子性的数据类型。我们可以<strong>在使用 volatile 的基础上再使用 AtomicXXX 类型的对象就能保证多线程操作数据的可见性和原子性并存，并且不用添加重锁</strong>。</p>
<img src="/2021/08/07/volatile/image-20210709112717007.png" alt="image-20210709112717007" style="zoom:80%;">



<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html">AtomicInteger</a> 的构造方法<ul>
<li>  AtomicInteger 其实就是对 Integer 的又一层包装，二者最大的区别就是 Integer 不能保证原子性，但 AtomicInteger 可以。</li>
<li>  默认的无参构造函数会初始化一个满足原子性的值为 0 的 int 类型数据</li>
<li>  带参的构造函数可以自己指定初始化值。</li>
</ul>
</li>
</ul>
<p><img src="/2021/08/07/volatile/image-20210709113136165.png" alt="image-20210709113136165"></p>
<ul>
<li>  <strong>代码修改</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.autoIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(myData.num);		<span class="comment">// 此时输出结果必定为 20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoIncrement</span><span class="params">()</span>&#123;</span><br><span class="line">        num.getAndIncrement();   <span class="comment">// 等价于 num++;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>AtomicInteger#getAndIncrement() 方法源码</strong></p>
</blockquote>
<img src="/2021/08/07/volatile/image-20210709113659357.png" alt="image-20210709113659357" style="zoom:80%;">





<hr>
<h1 id="5-有序性（指令重排）"><a href="#5-有序性（指令重排）" class="headerlink" title="5    有序性（指令重排）"></a>5    有序性（指令重排）</h1><h2 id="为什么要禁止指令重排？"><a href="#为什么要禁止指令重排？" class="headerlink" title="为什么要禁止指令重排？"></a>为什么要禁止指令重排？</h2><p>在多线程程序中，如果发生了指令重排，可能会导致程序的执行结果每次都是不确定的。即线程不安全。</p>
<hr>
<h2 id="指令重排是什么？"><a href="#指令重排是什么？" class="headerlink" title="指令重排是什么？"></a>指令重排是什么？</h2><p>计算机在执行程序时，为了提高性能，编译器和处理器往往会<strong>对指令进行重排</strong>。</p>
<p>指令重排造成的结果是：程序员写的代码的执行的顺序与代码真正在底层执行的顺序是有偏差的。</p>
<p><img src="/2021/08/07/volatile/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png" alt="指令重排"></p>
<ul>
<li>  多线程环境中线程交替执行，由于指令优化重排的存在，多个线程中使用的变量能否保证一致性是无法确定的，程序执行的结果也就无法预测了。</li>
<li>  处理器在进行指令重排时必须要考虑指令之间的<strong>数据依赖性</strong>。（也就是说指令重排必须是在满足数据依赖性的基础上进行的）</li>
</ul>
<hr>
<h2 id="指令重排演示"><a href="#指令重排演示" class="headerlink" title="指令重排演示"></a>指令重排演示</h2><h3 id="指令重排案例1：数据依赖性"><a href="#指令重排案例1：数据依赖性" class="headerlink" title="指令重排案例1：数据依赖性"></a>指令重排案例1：数据依赖性</h3><p>​        程序进行指令重排的前提是一定要满足数据依赖性，那么什么是数据依赖性呢？很简单的一个例子就是，想要吃苹果就必须得先有苹果，在程序中就是想要使用变量 num 就必须先声明这个变量 num。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;	<span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">4</span>;	<span class="comment">// 2</span></span><br><span class="line">x = x + <span class="number">7</span>;	<span class="comment">// 3</span></span><br><span class="line">y = y + <span class="number">8</span>;	<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>​        在上面的程序中，源代码设计的执行顺序是 <code>1234</code>，但是如果发生了指令重排，它就有可能变成 <code>2143</code>、<code>1324</code>，这都是 OK 的，但是能不能变成 <code>4321</code> 呢？答案是不可以的，因为第3、4条语句对应的指令是需要依赖于 1、2条语句指令创建的变量的，这就是最简单的数据依赖性。</p>
<h3 id="指令重排案例2：数据间无依赖性"><a href="#指令重排案例2：数据间无依赖性" class="headerlink" title="指令重排案例2：数据间无依赖性"></a>指令重排案例2：数据间无依赖性</h3><ol>
<li> 在两个线程的程序中，源代码中设计的程序执行顺序为：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,x,y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 在声明完4个变量a，b，x，y 后，这4个变量之间无依赖性，执行顺序可以任意组合</span></span><br><span class="line">x = a;</span><br><span class="line">y = b;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">这段代码在执行结束后，x 和 y 的结果应该为：x=<span class="number">0</span>, y=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 但是如果编译器对这段程序代码执行指令重排优化后，可能会出现执行顺序变为：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line">x = a;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line">y = b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这段代码在执行结束后，x 和 y 的结果应该为：x=<span class="number">2</span>, y=<span class="number">1</span></span><br></pre></td></tr></table></figure>





<h3 id="指令重排案例3"><a href="#指令重排案例3" class="headerlink" title="指令重排案例3"></a>指令重排案例3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReSortDemo</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        num = <span class="number">1</span>;	<span class="comment">// 语句1</span></span><br><span class="line">        flag = <span class="literal">true</span>;	<span class="comment">// 语句2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            num = num + <span class="number">5</span>;	<span class="comment">// 语句3</span></span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设现在有两个线程 A、B 并发执行 method1 和 method2 方法。</p>
<blockquote>
<p>  <strong>未发生指令重排：</strong></p>
</blockquote>
<p>假设线程 A 先执行 <code>method1()</code>，更新 num 和 flag 的值，线程 B 再执行，执行 <code>num = num + 5;</code>，最终 num 的值为 6，<strong>输出的结果为 6</strong>。</p>
<blockquote>
<p>  <strong>发生指令重排：</strong></p>
</blockquote>
<p>发生指令重排后，假设语句1和语句2在重排后执行顺序发生了交换，线程A先执行 <code>flag=true</code>，紧接着又切换到线程B 执行 <code>num=num+5</code>，但此时 num == 0，因此线程 B <strong>输出的结果变成了 5</strong>，并且最后还是会执行语句1让<code>num = 1;</code>。可以看到发生指令重排后程序的运行结果每次可能不一样。</p>
<hr>
<h2 id="指令重排总结"><a href="#指令重排总结" class="headerlink" title="指令重排总结"></a>指令重排总结</h2><ul>
<li>  <code>volatile</code> 关键字能禁止指令重排，从而避免多线程环境下程序执行结果不确定的情况。</li>
<li>  单线程程序中发生指令重排是不会影响到最终的执行结果的，因为指令重排首先要满足对象的依赖性，所以不会出现某个对象还没有初始化就对其操作的情况。</li>
<li>  指令重排有时候有好处（执行速度比较快），有时候有坏处（执行结果得不到保证），需要根据具体场景判断是否需要使用指令重排。如果需要就不用加 <code>volatile</code> 修饰，如果不需要指令重排就加 <code>volatile</code> 修饰。</li>
</ul>
<hr>
<h1 id="6-线程安全性获得保证"><a href="#6-线程安全性获得保证" class="headerlink" title="6    线程安全性获得保证"></a>6    线程安全性获得保证</h1><blockquote>
<p>  <strong>多线程存在哪些隐患？</strong></p>
</blockquote>
<ol>
<li> 工作内存与主内存同步延迟现象导致的可见性问题。</li>
<li> 指令重排导致的有序性问题。</li>
</ol>
<blockquote>
<p>  <strong>如何解决？</strong></p>
</blockquote>
<ol>
<li> 对于多个工作内存间的可见性问题，可以使用 synchronized 或 volatile 关键字解决，它们都可以使一个线程<strong>修改后的变量立即对其它线程可见</strong>。</li>
<li> 对于指令重排导致的有序性问题，可以使用 volatile 关键字解决，因为 volatile 的另一个作用就是禁止指令重排。</li>
</ol>
<blockquote>
<p>  <strong>遗留问题：</strong></p>
</blockquote>
<ul>
<li>  <strong>synchronized 关键字不能禁止指令重排，却能保证有序性，这是为什么？</strong></li>
</ul>
<hr>
<h1 id="7-DCL-单例"><a href="#7-DCL-单例" class="headerlink" title="7    DCL 单例"></a>7    DCL 单例</h1><p>DCL（Double Check Lock）：双重检查锁</p>
<blockquote>
<ol>
<li><strong>饿汉式单例</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个单例对象（饿汉式）：</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      1、将构造方法私有化（不提供从外部创建对象的接口）</span></span><br><span class="line"><span class="comment"> *      2、提供一个公共的方法用于获取这个单例对象</span></span><br><span class="line"><span class="comment"> *	    3、在类加载时就创建一个实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleExample</span> <span class="variable">singleExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这种单例模式的弊端：无论这个单例对象在程序中是否会使用，在类加载阶段都会创建这个单例对象。会浪费服务器的性能。</li>
</ul>
<blockquote>
<ol start="2">
<li><strong>单例优化（懒加载）</strong>：类加载阶段不创建实例对象，在使用时才创建实例对象。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">            <span class="comment">// 线程不安全。假设在这个位置同时进入了多个线程</span></span><br><span class="line">            singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这种单例模式的弊端：线程不安全！！！</li>
<li>如果同时有多个线程进入了第 10 行的位置，显然这些线程都会执行 <code>new SingleExample()</code> 方法，就会创建多个对象实例。</li>
</ul>
<blockquote>
<ol start="3">
<li>继续优化：想要实现线程安全，就需要<strong>加锁</strong>。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;	<span class="comment">// 使用 synchronized 关键字加锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">            singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面这种单例模式的弊端：锁的粒度太大。</p>
<p>  除了第一次调用 <code>getInstance()</code> 方法时会执行创建 SingleExample 对象的动作外，以后的每一次调用都是直接返回 singleExample 对象的引用，返回对象引用这个操作的耗时是很小的，绝大部分的耗时都用在 synchronized 修饰符的同步准备上，也就是说对象创建好了之后再有多个线程访问该方法是安全的，直接在最外层的方法上加锁，每次仍然需要进行锁对象的争夺，就会影响程序执行的性能了。</p>
</li>
</ul>
<blockquote>
<ol start="4">
<li>继续优化：<strong>降低锁的粒度</strong>。将同步锁加在具体某一行或几行代码上。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample) &#123;</span><br><span class="line">            <span class="comment">// 可能存在多个线程同时进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample.class) &#123;</span><br><span class="line">                singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>弊端：违背了单例的原则。</li>
<li>分析：第 9 行可能存在多个线程同时进入，即使在第10行进行了加锁，但是第 9 行的多个线程已经通过了 if 判断，不会再次进行判断了，所以这多个线程最终还是会创建出来多个 SingleExample 对象，违背了单例的原则。</li>
</ul>
<blockquote>
<ol start="5">
<li>继续优化：<strong>DCL（Double Check Lock）</strong>，双重检查锁。在锁的前面和后面都进行一次判断</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 支持多线程操作且线程安全的代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample) &#123;    <span class="comment">/*第一次检查，如果已有实例对象就不会触发多线程操作，作用是节省性能*/</span></span><br><span class="line">            <span class="comment">// 可能存在多个线程同时进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample.class) &#123;    <span class="comment">/*第二次检查，作用是保证创建出来的实例对象只能有一个*/</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">                    singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>双重检查锁可以解决锁的粒度大且线程不安全的问题。</p>
</li>
<li><p>分析：</p>
<ol>
<li> 第一次检查的目的：如果 singleExample 对象已经被创建了出来，那么就不会进入到多个线程争夺锁对象的阶段，节省性能。</li>
<li> 第二次检查的目的：保证创建出来的实例对象只能有一个。</li>
</ol>
</li>
<li><p>隐患：</p>
<p>  DCL 单例看起来已经可以完美地创建出来一个单例对象了，但是由于存在指令重排的可能，因此 DCL 单例还能有进一步优化的可能。</p>
</li>
</ul>
<h2 id="DCL-单例存在的隐患及优化方法"><a href="#DCL-单例存在的隐患及优化方法" class="headerlink" title="DCL 单例存在的隐患及优化方法"></a>DCL 单例存在的隐患及优化方法</h2><p>​        DCL 单例并不一定线程安全，原因是可能会出现指令重排，所以还需要使用 volatile 关键字来防止高并发情况下，指令重排造成的线程安全问题。</p>
<h3 id="Java创建对象过程中CPU进行的操作"><a href="#Java创建对象过程中CPU进行的操作" class="headerlink" title="Java创建对象过程中CPU进行的操作"></a>Java创建对象过程中CPU进行的操作</h3><p><img src="/2021/08/07/volatile/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%843%E4%B8%AA%E9%98%B6%E6%AE%B5.png"></p>
<p>Java 创建对象的过程可分为三个部分：</p>
<ol>
<li>在堆中给将要创建的对象分配一块内存空间，并赋初始零值。</li>
<li>根据对象的构造函数进行初始化（显式初始化）。</li>
<li>在栈中建立指针与对象的对应关系。</li>
</ol>
<p>​        Java 创建对象的每一步都需要 CPU 提供相应的指令，且对象数据保存在堆内存中，CPU 需要从内存中去读取这部分数据并拿回来运算，这就有可能会发生指令重排。</p>
<p>​        步骤2 和 步骤3 不存在数据依赖关系，所以可能会存在指令重排，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排是允许的。</p>
<blockquote>
<p>  <strong>重排前</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();	<span class="comment">// 1、给对象分配内存空间</span></span><br><span class="line">instance(memory);		<span class="comment">// 2、初始化对象</span></span><br><span class="line">instance = memory;		<span class="comment">// 3、设置栈中变量 instance 指向刚分配的内存地址，此时 instance != null</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>重排后</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();	<span class="comment">// 1、给对象分配内存空间</span></span><br><span class="line">instance = memory;		<span class="comment">// 3、设置栈中变量 instance 指向刚分配的内存地址，此时 instance != null，但是对象还没有初始化完成</span></span><br><span class="line">instance(memory);		<span class="comment">// 2、初始化对象</span></span><br></pre></td></tr></table></figure>



<ul>
<li>如果发生指令重排，则原本执行顺序可能变为<code>1-&gt; 3-&gt; 2</code>，指令重排在单线程下是不会对程序产生大的影响的，因为单线程操作的过程中不会有其它线程来访问程序执行的某个中间阶段，最终的结果不会改变。</li>
<li>但是如果在多线程的情况下（假设指令重排后顺序变为<code>1-&gt; 3-&gt; 2</code>），线程A 创建单例对象，执行了1，3步骤后，切换到线程B 执行读取单例对象并返回的操作，因为线程A 执行完1、3步骤后 <code>instance != null</code>，所以线程B 不会再去执行创建对象的代码，而是直接返回单例对象的引用，但是此时这个引用指向的单例对象的值是类加载阶段赋的初始零值 null，而不是构造器中显式指定的初始值，显然这是不对的。如果线程B 拿着这个错误的单例对象去使用了，线程B 对应的程序就不能够正常运行了。</li>
<li>即便之后线程A 再执行第2步骤，完成了构造器显式赋值，并且之后也不会再出现读取到默认零值的情况，但是起码存在这样一种出错的可能性。</li>
<li>而 <strong>volatile</strong> 关键字的作用就是保证指令不被重排。当创建单例对象时，保证指令的执行顺序一定是是 <code>1-&gt; 2 -&gt;3</code>。</li>
</ul>
<blockquote>
<p>  <strong>null != single 有两种情况：</strong></p>
</blockquote>
<ol>
<li> 已经完整地创建过 SingleExample 对象了，没有发生指令重排，或者在指令重排的时候没有多个线程访问。</li>
<li> 正在创建 SingleExample 对象，但是发生了指令重排，并且有多个线程访问，并且有 A线程得到了锁对象，但是只执行了分配内存空间和设置 instance 指向内存地址后，CPU 资源就切换到 B线程去执行了，这时候 instance 确实是有值的（地址值），但是地址中没有数据，如果 B线程拿到了 instance 并使用，就会出现程序执行错误了。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
