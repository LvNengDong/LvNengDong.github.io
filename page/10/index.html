<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/10/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/10/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/05/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/05/%E5%9B%BE/" class="post-title-link" itemprop="url">图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-05 11:19:45" itemprop="dateCreated datePublished" datetime="2021-08-05T11:19:45+08:00">2021-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-06 17:32:24" itemprop="dateModified" datetime="2021-08-06T17:32:24+08:00">2021-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="图是什么"><a href="#图是什么" class="headerlink" title="图是什么"></a>图是什么</h1><blockquote>
<p>  <strong>图 = 节点集合 + 边的集合</strong></p>
</blockquote>
<p>​        图是一种用来表示相连数据的数据结构，类似我们的社交网络，图中有很多的节点，每个节点代表一个数据，每个节点可以和其他节点相连。其中每个节点叫做<strong>顶点（vertex）</strong>，连接顶点之间的线叫做<strong>边（edge）</strong>。</p>
<p>​        下图就是一个用来表示社交网络的图数据结构：在此图中，我们含有 5 个顶点和 6 条相连线，每个顶点包含了人名，而连接线代表相连人名之间是朋友关系。</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph1.jpg" alt="img"></p>
<p>​        如果我们要更正式地表示图，那么图就可以用一对<strong>（V，E）集合</strong>来表示，其中 V 是一堆<strong>顶点的集合</strong>，而 E 是一堆<strong>边的集合</strong>，如下图所示：在此图中：<code>V = &#123;a, b, c, d, e&#125;，E = &#123;ab, ac, bd, cd, de&#125;</code></p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph2.jpg" alt="img"></p>
<p>上面提到的图是无向图，而常见的图有以下三种：</p>
<ol>
<li> <strong>无向图（Undirected Graph）</strong>：在无向图中，每个顶点和其他顶点通过边连接。</li>
<li> <strong>有向图（Directed Graph）</strong>：有向图中的边是有方向的。</li>
<li> <strong>权重图（Weighted Graph）</strong>：在权重图中，每条边有各自的权重。</li>
</ol>
<p>下图是有向图：此图可以用来表示用户之间相互关注的情况，如果Mark指向Alice，则代表Mark关注了Alice。</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph3.jpg" alt="img"></p>
<p>下图是权重图：此图可以用来表示两个好友之间的亲密程度，数值越高代表越亲密。</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph4.jpg" alt="img"></p>
<hr>
<h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>图有多种存储方式，常见的两种：一种是用<strong>矩阵（Matrix）</strong>的形式来实现，另一种是用<strong>链表（List）</strong>的形式来实现。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><img src="/2021/08/05/%E5%9B%BE/Graph5.png" alt="img"></p>
<p>每行代表相应的顶点，如果 <code>M[i][j] = 1</code>，那么就代表顶点 i 连向 j，如果是 0，则表达顶点间没有联系。用矩阵的方式来实现图的优势很明显，我们可以很快地判断两个顶点之间是否相连，可是用矩阵实现的空间复杂度很高，我们需要 <strong>O(V^2^)</strong> 来记录所有的数据，不管顶点之间是否有相连线。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>为了解决空间复杂度的问题，我们可以使用链表的方式来实现图：</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph6.png" alt="img"></p>
<p>在链表实现中，我们实际上使用了储存链表的数组来表示图，图的左侧用数组来实现，代表我们的所有顶点，而每个顶点含有一个链表，链表上储存了该顶点指向的顶点。</p>
<h1 id="图存储结构的代码实现（Java）"><a href="#图存储结构的代码实现（Java）" class="headerlink" title="图存储结构的代码实现（Java）"></a>图存储结构的代码实现（Java）</h1><h2 id="无向图的矩阵实现"><a href="#无向图的矩阵实现" class="headerlink" title="无向图的矩阵实现"></a>无向图的矩阵实现</h2><blockquote>
<p>  <strong>Graph.java</strong>：无向图的数据结构</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图</span></span><br><span class="line"><span class="comment"> *  1、图 = 节点集合 + 边的集合</span></span><br><span class="line"><span class="comment"> *  2、图的表示方法：①邻接矩阵（二维数组）  ②邻接表（链表形式）</span></span><br><span class="line"><span class="comment"> *     本例中我们采用邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="comment">// 节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;  <span class="comment">// 边的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; <span class="comment">// 表示边的数目【非必需】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化顶点集合和边的集合（矩阵）</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边（建立两个顶点之间的联系）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    起始顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    结束顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    边的权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向图而言，所有的边都是双向的，构造成的矩阵是一个对称矩阵，</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据下标得到对应的顶点数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到顶点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rows : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>测试类</strong></p>
</blockquote>
<img src="/2021/08/05/%E5%9B%BE/image-20210806153141817.png" alt="image-20210806153141817" style="zoom: 67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 12:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 顶点的个数</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        </span><br><span class="line">        String[] vertexes = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : vertexes) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 总共的边为：A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>执行结果</strong></p>
</blockquote>
<p><img src="/2021/08/05/%E5%9B%BE/image-20210805122136982.png" alt="image-20210805122136982"></p>
<hr>
<h1 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h1><blockquote>
<p>  <strong>思想</strong></p>
</blockquote>
<ol>
<li> 首先访问出发点 <strong>v</strong> ，并将其标记为已访问过；</li>
<li> 然后选取与 v 邻接的、未被访问的任意一个顶点 <strong>w</strong> ，并访问它；</li>
<li> 再选取与 w 邻接的未被访问的任一顶点并访问，以此重复进行；</li>
<li> 当一个顶点的所有邻接顶点都被访问过时，则依次退回到最近被访问过的顶点，若该顶点还有其它邻接顶点未被访问，则从这些未被访问的顶点中取一个并重复上述访问过程，直至图中所有顶点都被访问过为止。</li>
</ol>
<blockquote>
<p>  <strong>图示</strong></p>
</blockquote>
<p>下面以“有向图”为例，来对深度优先搜索进行演示：</p>
<img src="/2021/08/05/%E5%9B%BE/Graph7.png" alt="img" style="zoom:150%;">

<p>对于上面的图，我们从顶点A开始搜索：</p>
<img src="/2021/08/05/%E5%9B%BE/Graph8.png" alt="img" style="zoom: 150%;">



<p>以下是具体的遍历步骤：</p>
<blockquote>
<ol>
<li> 访问A</li>
<li> 访问B（在访问A之后，接下来应该访问的是A出发的另一个顶点，既顶点B）</li>
<li> 访问C（在访问B之后，接下来访问的是从B出发的另一个顶点，既C，E，F。在此图中，我们按照字母排序顺序访问，因此先访问C。）</li>
<li> 访问E（接下来访问与C连接的另一个顶点E。）</li>
<li> 访问D（接下来访问从E出发的顶点B和D，因为B已被访问过，所以访问顶点D。）</li>
<li> 访问F（接下来回溯“访问B的另一个连接顶点F”）</li>
<li> 访问G</li>
</ol>
</blockquote>
<p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G。</p>
<p>在图的深度优先搜索中，我们尽可能先遍历一个顶点可以达到的最深处，其中可能会出现的问题就是会有循环出现，所以我们需要一个数组来记录哪些节点已经被访问过。</p>
<blockquote>
<p>  <strong>代码实现</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图</span></span><br><span class="line"><span class="comment"> *  1、图 = 节点集合 + 边的集合</span></span><br><span class="line"><span class="comment"> *  2、图的表示方法：①邻接矩阵（二维数组）  ②邻接表（链表形式）</span></span><br><span class="line"><span class="comment"> *     本例中我们采用邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="comment">// 节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;  <span class="comment">// 边的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; <span class="comment">// 表示边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[] isVisited; <span class="comment">// 定义布尔型数组，记录某个节点是否被访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化节点集合和边的集合（矩阵）</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    边的起始顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    边的结束顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向图而言，构造成的矩阵是一个对称矩阵，所有的边都是双向的</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回顶点i对应的数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rows : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个顶点的深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 随机选择一个顶点作为深度优先遍历的起始顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">// 首先访问顶点 v 并输出</span></span><br><span class="line">        System.out.print(getValueByIndex(v) + <span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 将该节点设置为已访问过</span></span><br><span class="line">        isVisited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找与顶点 v 邻接的、未被访问的任意任一个顶点 w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getEffectiveNeighbor(v);</span><br><span class="line">        <span class="keyword">if</span> (w != -<span class="number">1</span>)&#123;   <span class="comment">// 说明存在邻接顶点未被访问</span></span><br><span class="line">            <span class="comment">// 递归地访问顶点 w</span></span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不存在满足条件的顶点 w，则说明顶点 v 已经遍历完毕了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找与与顶点 v 邻接的、未被访问的任一顶点 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEffectiveNeighbor</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][j] == <span class="number">1</span> &amp;&amp; isVisited[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 dfs 进行一个重载，完成整体图中所有的顶点的遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 isVisited 数组</span></span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的节点，进行 dfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h1><blockquote>
<p>  <strong>思想</strong></p>
</blockquote>
<ol>
<li> 首先访问起始顶点 v ，</li>
<li> 然后选取与 v 邻接的、未被访问过的全部顶点 w<del>1</del>，w<del>2</del>，…，w<del>n</del> 进行访问；</li>
<li> 再依次访问 w<del>1</del>，w<del>2</del>，…，w<del>n</del> 邻接的全部顶点（已访问过的除外）</li>
<li> 以此类推，直到所有顶点都被访问过了为止。</li>
</ol>
<blockquote>
<p>  <strong>主要步骤：</strong></p>
</blockquote>
<ol>
<li> 任取图中的一个顶点访问，入队，并将这个顶点标记为已访问；</li>
<li> 当队列不为空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队；</li>
<li> 当队列为空时跳出循环，广度优先搜索即完成。</li>
</ol>
<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jmx.remote.internal.ArrayQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图</span></span><br><span class="line"><span class="comment"> *  1、图 = 节点集合 + 边的集合</span></span><br><span class="line"><span class="comment"> *  2、图的表示方法：①邻接矩阵（二维数组）  ②邻接表（链表形式）</span></span><br><span class="line"><span class="comment"> *     本例中我们采用邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="comment">// 节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;  <span class="comment">// 边的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; <span class="comment">// 表示边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[] isVisited; <span class="comment">// 定义布尔型数组，记录某个节点是否被访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化节点集合和边的集合（矩阵）</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    边的起始顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    边的结束顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向图而言，构造成的矩阵是一个对称矩阵，所有的边都是双向的</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回顶点i对应的数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rows : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个顶点的深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 随机选择一个顶点作为深度优先遍历的起始顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">// 首先访问顶点 v 并输出</span></span><br><span class="line">        System.out.print(getValueByIndex(v) + <span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 将该节点设置为已访问过</span></span><br><span class="line">        isVisited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找与顶点 v 邻接的、未被访问的任意任一个顶点 w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getEffectiveNeighbor(v);</span><br><span class="line">        <span class="keyword">if</span> (w != -<span class="number">1</span>)&#123;   <span class="comment">// 说明存在邻接顶点未被访问</span></span><br><span class="line">            <span class="comment">// 递归地访问顶点 w</span></span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不存在满足条件的顶点 w，则说明顶点 v 已经遍历完毕了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找与与顶点 v 邻接的、未被访问的任一顶点 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEffectiveNeighbor</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][j] == <span class="number">1</span> &amp;&amp; isVisited[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 dfs 进行一个重载，完成整体图中所有的顶点的遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 isVisited 数组</span></span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的节点，进行 dfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对顶点 v 进行广度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        LinkedList&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、访问顶点 v 并输出</span></span><br><span class="line">        System.out.print(getValueByIndex(v) + <span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、将节点标记为已访问</span></span><br><span class="line">        isVisited[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 3、将顶点加入队列</span></span><br><span class="line">        queue.addLast(v);</span><br><span class="line">        <span class="comment">// 4、当队列不为空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队；</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出队头节点的下标 u，访问 u 的所有未被访问过的邻接节点</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">u</span> <span class="operator">=</span> (Integer) queue.removeFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="built_in">this</span>.getEffectiveNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>)&#123;    <span class="comment">// 证明顶点 u 存在未被访问过的邻接节点 w</span></span><br><span class="line">                System.out.print(getValueByIndex(w) + <span class="string">&quot;--&gt;&quot;</span>);   <span class="comment">//输出</span></span><br><span class="line">                isVisited[w] = <span class="literal">true</span>;    <span class="comment">// 标记为已访问</span></span><br><span class="line">                queue.addLast(w);   <span class="comment">// 入队</span></span><br><span class="line">                w = <span class="built_in">this</span>.getEffectiveNeighbor(u);   <span class="comment">// 更新 w 的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以下一个队头顶点 u 为起始顶点，查找其未被访问的所有邻接顶点（提现广度优先）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 bfs 进行一个重载，完成整体图中所有的顶点的遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                bfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>测试</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 12:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 节点的个数</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line"></span><br><span class="line">        String[] vertexes = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : vertexes) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 总共的边为：A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：dfs深度优先遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;深度优先遍历=================&quot;</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：bfs广度优先遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;广度优先遍历=================&quot;</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">JVM体系结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-02 22:47:30" itemprop="dateCreated datePublished" datetime="2021-08-02T22:47:30+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 09:53:06" itemprop="dateModified" datetime="2021-08-03T09:53:06+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><p>​        JVM 只是一个概念，而 <code>Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</code> 则是 JVM 的一个落地产品，HotSpot 是 Orecle 平台默认的 Java 虚拟机。常见的 JVM 的落地产品还有：JRockit、J9 等。</p>
<h2 id="1-HotSpot"><a href="#1-HotSpot" class="headerlink" title="1    HotSpot"></a>1    HotSpot</h2><p>​        在装有JDK的电脑上，输入 <code>java -version</code> 命令，会展示如下信息：</p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210416102603356.png"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_141&quot;</span>	</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>  <code>Java HotSpot(TM)</code>，是指<code>Java HotSpot</code>虚拟机，它是JVM的一个落地产品，TM 是 TradeMark，就是商标，就像苹果一样，是个牌子。</li>
<li>  <code>64-Bit</code> 指的是当前安装的虚拟机版本是64位，版本号为 <code>build 25.141-b15</code>，</li>
<li>  运行在<code>mixed mode</code>下，因为 Java 是一种办解释半编译型语言，<code>mixed mode</code> 代表混合模式。</li>
</ul>
</blockquote>
<hr>
<h2 id="2-Java——跨平台的语言"><a href="#2-Java——跨平台的语言" class="headerlink" title="2    Java——跨平台的语言"></a>2    Java——跨平台的语言</h2><p>Java 语言具有跨平台性！可以实现 <strong>write once，run anywhere</strong> ，一次编译，到处运行。</p>
<ol>
<li> Java 程序即开发人员编写的源代码文件；</li>
<li> 源代码文件首先会被编译成字节码文件；</li>
<li> 这些所有的字节码文件可以在任何安装了 JVM 虚拟机的平台上运行。</li>
</ol>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg"></p>
<hr>
<h2 id="3-JVM——跨语言的平台"><a href="#3-JVM——跨语言的平台" class="headerlink" title="3    JVM——跨语言的平台"></a>3    JVM——跨语言的平台</h2><p>​        JVM 并不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心<strong>字节码</strong>文件。 也就是说 <strong>JVM 拥有语言无关性</strong>，并不与 Java 语言绑定，只要其它编程语言的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其它的辅助信息，它就是一个有效的字节码文件，就能被 JVM 识别、装载和运行！</p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"></p>
<blockquote>
<ul>
<li><strong>字节码文件</strong> 可以是由不同的编程语言编译后形成的。</li>
<li>只要不同的编程语言通过各自的编译器编译形成的字节码文件遵循Java虚拟机的规范，就可以在Java虚拟机上解释运行！</li>
<li>也就是说，JVM 虚拟机并不强制要求开发的源代码是否是用Java语言实现的。</li>
</ul>
</blockquote>
<hr>
<h2 id="4-字节码"><a href="#4-字节码" class="headerlink" title="4    字节码"></a>4    字节码</h2><ul>
<li><p>我们一般讲的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说：任何能在 JVM 平台上执行的字节码格式都是一样的，所以应该统称为：<strong>JVM 字节码</strong></p>
</li>
<li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</p>
<p>  [比如要实现在控制台输出 “HelloWorld！” 的功能，我们可以通过 Java 语言实现也可以通过 Js 语言实现，这两种编程语言各自的源代码文件是不同的，分别是 <code>.java</code> 和 <code>.js</code>，但是通过各自的编译器编译成的 JVM 字节码文件就是一样的，也就是通过不同的编译器编译出相同的字节码文件。    当然，这个字节码文件也可以在不同的 JVM 虚拟机上运行]</p>
</li>
<li><p>Java 虚拟机 与 Java 语言并没有必然的联系，它只与特定的二进制文件格式——Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或称为字节码、Bytecodes）和符号表，还有一些其它辅助信息。</p>
</li>
</ul>
<h2 id="5-多语言混合编程"><a href="#5-多语言混合编程" class="headerlink" title="5    多语言混合编程"></a>5    多语言混合编程</h2><ul>
<li><p><em>Java 平台上的多语言混合编程正在成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</em></p>
</li>
<li><p>什么是多语言混合编程？</p>
<blockquote>
<p>在一个项目之中，并行处理用 Clojure 语言开发，展示层使用 JRuby/Rails 语言开发，中间层则用 Java 开发，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<strong>各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便透明，因为它们都运行在一个虚拟机上</strong>。</p>
</blockquote>
</li>
<li><p>能够实现这样一个组合的原因，是因为大家都能在 JVM 平台上运行。</p>
</li>
</ul>
<h2 id="6-虚拟机"><a href="#6-虚拟机" class="headerlink" title="6    虚拟机"></a>6    虚拟机</h2><ul>
<li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。</p>
</li>
<li><p>虚拟机的作用就是为程序提供一个运行环境，例如我们的JVM虚拟机就是给字节码文件提供一个运行环境，如果没有JVM虚拟机，就无法直接在Windows环境下运行字节码文件。</p>
</li>
<li><p>大体上，虚拟机可分为 <strong>系统虚拟机</strong> 和 <strong>程序虚拟机</strong>。</p>
<blockquote>
<p>常见的 Visual Box、VMware 就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</p>
<p>程序虚拟机的典型代表就是 Java 虚拟机，它专门为执行单个计算机程序而设计，在 Java 虚拟机中执行的指令被称为 Java 字节码指令。 </p>
</blockquote>
<p>  程序虚拟机只作用于某个特定的程序上，而系统虚拟机就相当于另一台电脑，在系统虚拟机中可以继续安装程序虚拟机。</p>
</li>
<li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
</li>
</ul>
<h2 id="7-Java-虚拟机"><a href="#7-Java-虚拟机" class="headerlink" title="7    Java 虚拟机"></a>7    Java 虚拟机</h2><ul>
<li><p>Java 虚拟机就是一台执行 JVM 字节码的虚拟计算机，它拥有独立的运行机制，其运行的字节码未必由 Java 语言编译而成。</p>
</li>
<li><p>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。</p>
</li>
<li><p>Java 技术的核心就是 Java 虚拟机（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机上。</p>
</li>
<li><p><strong>Java 虚拟机就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释/编译为对应操作系统上的机器指令执行。  每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数、怎么处理操作数、处理结果放在哪里。</p>
</li>
<li><p>特点</p>
<blockquote>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h2 id="8-JVM-的位置"><a href="#8-JVM-的位置" class="headerlink" title="8    JVM 的位置"></a>8    JVM 的位置</h2><ul>
<li>  JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</li>
</ul>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg"></p>
<ul>
<li></li>
</ul>
<h2 id="9-JVM-的整体结构"><a href="#9-JVM-的整体结构" class="headerlink" title="9    JVM 的整体结构"></a>9    JVM 的整体结构</h2><ul>
<li>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构。</li>
</ul>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg"></p>
<h3 id="Class-Loader-Subsystem"><a href="#Class-Loader-Subsystem" class="headerlink" title="Class Loader Subsystem"></a>Class Loader Subsystem</h3><blockquote>
<p><strong>类加载器子系统</strong></p>
</blockquote>
<ul>
<li>主要作用就是将 <code>.class</code> 字节码文件加载到<strong>内存</strong>中形成一个 Class 对象。</li>
</ul>
<h3 id="Runtime-Data-Area"><a href="#Runtime-Data-Area" class="headerlink" title="Runtime Data Area"></a>Runtime Data Area</h3><blockquote>
<p><strong>运行时数据区</strong></p>
</blockquote>
<ul>
<li>方法区 和 堆 是多线程共享的，</li>
<li>程序计数器、本地方法栈和虚拟机栈是每个线程独有一份的。</li>
</ul>
<h3 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h3><blockquote>
<p>执行引擎</p>
</blockquote>
<ul>
<li>主要作用就是将内存中 <code>.class</code> 字节码文件形成的 Class 对象编译成底层机器能够识别的机器指令。</li>
</ul>
<h2 id="10-Java-代码的执行流程"><a href="#10-Java-代码的执行流程" class="headerlink" title="10    Java 代码的执行流程"></a>10    Java 代码的执行流程</h2><p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210416190414894.png"></p>
<h2 id="11-JVM-的架构模型"><a href="#11-JVM-的架构模型" class="headerlink" title="11    JVM 的架构模型"></a>11    JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另一种指令集架构则是基于寄存器的指令集架构。</p>
<blockquote>
<p>  <strong>总结：</strong></p>
</blockquote>
<p><strong>由于跨平台的设计，Java 的指令都是根据栈来设计的。</strong>  不同平台 CPU 架构不同，所以不能设计为基于寄存器的。  优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>​           </p>
<h2 id="12-JVM-的生命周期"><a href="#12-JVM-的生命周期" class="headerlink" title="12    JVM 的生命周期"></a>12    JVM 的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java 虚拟机的启动是通过引导类加载器（BootStrap Class Loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机内部实现的。</p>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul>
<li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</li>
<li>程序开始执行它才运行，程序结束时它就停止。</li>
<li>执行一个所谓的 Java 程序的时候，真正执行的是一个叫做 Java 虚拟机的进程。</li>
</ul>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下几种情况：</p>
<ol>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到了异常或错误而异常终止。</li>
<li>由于操作系统出现错误而导致 Java 虚拟机进程终止。</li>
<li>某线程调用 Runtime 类或 System 类的 <code>exist</code> 方法，或 Runtime 类的 <code>halt</code> 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或写在 Java 虚拟机时，Java 虚拟机的退出情况。</li>
</ol>
<hr>
<h1 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h1><p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E8%8B%B1.jpg"></p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE-1621267020283.jpg" alt="第02章_JVM架构-简图"></p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E8%8B%B1-1621267020283.jpg" alt="第02章_JVM架构-英"></p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E4%B8%AD-1621267020284.jpg" alt="第02章_JVM架构-中"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-02 22:19:15" itemprop="dateCreated datePublished" datetime="2021-08-02T22:19:15+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 09:22:58" itemprop="dateModified" datetime="2021-08-03T09:22:58+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>排序算法稳定性小结：</strong></p>
</blockquote>
<p><strong>快些选一堆</strong>是不稳定的排序算法，其它都是稳定的！</p>
<ul>
<li>  快排</li>
<li>  希尔</li>
<li>  选择</li>
<li>  堆排</li>
</ul>
<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li> 选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</li>
<li> 从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。</li>
<li>找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的<br> 值才交换。</li>
<li> 直到 <strong>从前往后的比较索引&gt;从后往前比较的索引</strong>，结束第一次循环。</li>
<li> 此时，对于基准值来说，左边都比基准值小，右边都比基准值大，这个基准值就到达排序的最终位置了。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">注解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-02 19:18:11 / Modified: 20:37:52" itemprop="dateCreated datePublished" datetime="2021-08-02T19:18:11+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java<code>注解(Annotation)</code>又称为<code>元数据</code>。</p>
<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><blockquote>
<p><code>元注解</code>就是用来标志注解的注解。</p>
</blockquote>
<ol>
<li><p><code>@Retention</code></p>
<p> 标识如何存储，是只在代码中，还是编入class文件中，或者在运行阶段可以通过反射访问。</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：注解只保留在源文件，当Java被编译成<code>.class</code>文件后，注解被遗弃。</li>
<li><code>RetentionPolicy.CLASS</code>：注解被保留到<code>.class</code>文件，但当JVM将<code>.class</code>文件加载到内存中时，注解被遗弃。<strong>这是缺省值</strong>。</li>
<li><code>RetentionPolicy.RUNTIME</code>：注解不仅被保存到<code>.class</code>文件，而且JVM加载<code>.class</code>文件后依然存在。</li>
</ul>
</li>
<li><p><code>@Documented</code>：</p>
<p> 标记这些注解是否保存在JavaDoc中。</p>
</li>
<li><p><code>@Target</code>：</p>
<p> 标记这个注解可以修饰的范围。<code>Annotation</code>的修饰范围：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span>&#123;</span><br><span class="line">    TYPE,</span><br><span class="line">    FIELD,</span><br><span class="line">    METHOD,</span><br><span class="line">    PARAMETER,</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    PACKAGE,</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    TYPE_USE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Inherited</code>：</p>
<p> 标记这个注解是继承于哪个<strong>注解类</strong>的。</p>
<blockquote>
<p>注解是不支持继承的。</p>
</blockquote>
</li>
<li><p><code>@SafeVarargs</code>：</p>
<p> 在声明可变参数的构造函数或方法时，Java编译器会包<code>unchecked</code>警告，使用该注解可忽略这些警告。</p>
</li>
<li><p><code>@FunctionalInterface</code>：</p>
<p> 标识这个方法是一个函数式接口</p>
</li>
<li><p><code>@Repeatable</code>：</p>
<p> 标识某注解可以在同一个声明上使用多次。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%9E%9A%E4%B8%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%9E%9A%E4%B8%BE/" class="post-title-link" itemprop="url">枚举</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-02 18:42:10 / Modified: 19:17:41" itemprop="dateCreated datePublished" datetime="2021-08-02T18:42:10+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><ul>
<li>  Java中，被 <strong>enum</strong> 关键字修饰的类型就是枚举类型。</li>
<li>  枚举类型是一种特殊的数据类型。它是一种与 Class、Interface、Annotation 平级的数据类型。</li>
<li>  <strong>枚举是指具有固定实例个数的类</strong>。普通的类可以根据需求创建任意多个实例，但是在枚举中实例的个数是有限制的。</li>
<li>  枚举虽然<strong>有构造函数</strong>，但其构造函数默认都是私有的，所以只能在当前类中使用<code>new</code>关键字创建对象。</li>
<li>  <strong>当需要定义一组常量时，强烈建议使用枚举类。</strong></li>
<li>  <strong>如果枚举类中只一个对象，则可以作为一种单例模式的实现方式。</strong></li>
<li>  <code>枚举类型(enum)</code>、<code>类(Class)</code>、<code>接口(Interface)</code>、<code>注解类(Annotation)</code>处于同一级。</li>
<li>  注解类不是注解，注解类的作用是定义注解的业务逻辑</li>
</ul>
<p><img src="/2021/08/02/%E6%9E%9A%E4%B8%BE/image-20201026191110428.png" alt="image-20201026191110428"></p>
<hr>
<h1 id="如何定义枚举类"><a href="#如何定义枚举类" class="headerlink" title="如何定义枚举类"></a>如何定义枚举类</h1><blockquote>
<p>  <strong>Before：没有枚举类之前，定义一组常量的方式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeekDemo</span>&#123;</span><br><span class="line">	<span class="comment">// 一组常量，表示周一到周日</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> MONDAY=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> TUESDAY=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> WEDNESDAY=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> THURSDAY=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> FRIDAY=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> SATURDAY=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> SUNDAY=<span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>After：利用枚举重新定义：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumWeekDemo</span> &#123;</span><br><span class="line">    MONDAY,</span><br><span class="line">    Tuesday,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY,</span><br><span class="line">    SUNDAY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="枚举的实现原理"><a href="#枚举的实现原理" class="headerlink" title="枚举的实现原理"></a>枚举的实现原理</h1><ol>
<li> 我们使用关键字 <code>enum</code> 定义枚举类，这个类在编译后，编译器会为我们生成一个相关的 class 类，也就是说枚举类型在编译后也是一个 class 类型，而且类继承自 <strong>java.lang.Enum</strong>。</li>
<li> 上文中的代码在加载到内存中后，会生成<strong>一个 Class 对象</strong>：<strong>EnumWeekDemo</strong>；</li>
<li> 除此之外，还会生成 <strong>7 个 EnumWeekDemo 类的实例对象</strong>，分别对应枚举类中定义的7个日期；</li>
</ol>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<ul>
<li>  枚举类表示有固定实例个数的类，这些实例就是根据自身枚举类创建的实例对象，具体有多个个实例根据你在枚举类中写了多少个就有多少个。</li>
<li>  枚举类中的每个实例对象是 <strong>public static final</strong> 的，即可以通过类名直接访问，且不可变，可用于存储常量对象。</li>
</ul>
<hr>
<h1 id="枚举类中常用的静态方法"><a href="#枚举类中常用的静态方法" class="headerlink" title="枚举类中常用的静态方法"></a>枚举类中常用的静态方法</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>values()</code></td>
<td align="center">获取枚举中的所有变量，并作为数组返回</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>valueOf(String name)</code></td>
<td align="center">根据名称获取枚举变量</td>
</tr>
</tbody></table>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h2 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h2><p>模拟枚举类的内部实现，即不适用 enum 关键字实现与枚举类型相同的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明Season对象的属性: private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.私化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.其他诉求2：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-enum"><a href="#使用-enum" class="headerlink" title="使用 enum"></a>使用 enum</h2><p>JDK 5 中新增了 enum 用于定义枚举类。</p>
<blockquote>
<p>  <strong>使用 enum 关键字的枚举类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的实例对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.私化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="枚举类常用方法（继承于java-lang-Enum类）"><a href="#枚举类常用方法（继承于java-lang-Enum类）" class="headerlink" title="枚举类常用方法（继承于java.lang.Enum类）"></a>枚举类常用方法（继承于java.lang.Enum类）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line">    <span class="comment">// toString():返回枚举类对象的名称（枚举类默认继承的Enum类中重写了toString方法，这里可以直接调用）</span></span><br><span class="line">    System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line">    System.out.println(Season1.class.getSuperclass());</span><br><span class="line">    System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// values():返回所的枚举类对象构成的数组</span></span><br><span class="line">    Season1[] values = Season1.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        System.out.println(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line">    <span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line">    System.out.println(winter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="如何让枚举类对象实现接口"><a href="#如何让枚举类对象实现接口" class="headerlink" title="如何让枚举类对象实现接口"></a>如何让枚举类对象实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">泛型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-02 16:33:49 / Modified: 18:32:18" itemprop="dateCreated datePublished" datetime="2021-08-02T16:33:49+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="泛型的引入背景"><a href="#泛型的引入背景" class="headerlink" title="泛型的引入背景"></a>泛型的引入背景</h1><blockquote>
<p>  <strong>JDK5 之前</strong></p>
</blockquote>
<p>​        集合类在设计阶段阶段不能确定这个集合到底实际存的是什么类型的对象，所以在 JDK5 之前只能把元素类型设计为 Object，如果我们对集合不做任何限定，它就可以存储任何类型的对象。如果一个集合中存储了多种数据类型的元素，那么在编译后这些元素都会向上转型为Object类型。这样的话，当我们取出任一元素想执行其特有的方法时，就必须采用向下转型。然而由于集合中元素的数据类型不同，所以没有一个统一的标准可以一次性将集合中的所有元素向下转型。</p>
<blockquote>
<p>  <strong>从 JDK5 开始</strong></p>
</blockquote>
<p>​        在JDK1.5++，新增了<strong>泛型（Generic）</strong>语法。让你在设计 API 时可以指定类或方法支持泛型，这样我们使用API时也变得更为简洁，并得到了编译时期的语法检查。</p>
<p>​        JDK5 之后使用泛型来解决这个问题。因为这个时候除了元素的类型不确定，其它的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此<strong>此时把元素的类型设计成一个参数</strong>，这个类型参数叫做<strong>泛型</strong>。</p>
<h1 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h1><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<ul>
<li>  <strong>泛型</strong>：可以在<strong>类中或方法</strong>中预支的使用未知的类型。</li>
<li>  所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时确定。比如：①继承或实现这个接口时；  ②创建对象时；  ③传入实际的类型参数时，也称为类型实参；</li>
<li>  <strong>泛型的使用</strong>：定义时不指定数据类型，使用时再指定数据类型。</li>
</ul>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<ol>
<li> <strong>泛型是在定义时使用的；</strong></li>
<li> 使用时才指定泛型的具体类型；</li>
<li> <strong>当没有指定泛型时，默认类型为 Object 类型。</strong></li>
<li> Collection虽然可以存储不同类型的对象，但实际使用时我们建议一般只存储同一类型的对象。</li>
</ol>
<hr>
<h1 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h1><ol>
<li>将运行时期的<code>ClassCastException</code>，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ol>
<hr>
<h1 id="泛型在集合中的使用"><a href="#泛型在集合中的使用" class="headerlink" title="泛型在集合中的使用"></a>泛型在集合中的使用</h1><h2 id="JDK5-之前"><a href="#JDK5-之前" class="headerlink" title="JDK5 之前"></a>JDK5 之前</h2><blockquote>
<p>  <strong>存在的问题：</strong></p>
</blockquote>
<ol>
<li> 类型不安全</li>
<li> 强转时，可能出现 ClassCastException</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// 需求：存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">76</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题一：类型不安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">        <span class="comment">// 问题二：强转时，可能出现ClassCastException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/02/%E6%B3%9B%E5%9E%8B/image-20210802165130946.png" alt="image-20210802165130946"></p>
<hr>
<h2 id="JDK5-之后"><a href="#JDK5-之后" class="headerlink" title="JDK5 之后"></a>JDK5 之后</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">87</span>);</span><br><span class="line">    list.add(<span class="number">99</span>);</span><br><span class="line">    <span class="comment">// 编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);	// 发生编译时异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//        for(Integer score : list)&#123;</span></span><br><span class="line"><span class="comment">//            //避免了强转操作</span></span><br><span class="line"><span class="comment">//            int stuScore = score;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            System.out.println(stuScore);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二：</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/02/%E6%B3%9B%E5%9E%8B/image-20210802165301817.png" alt="image-20210802165301817"></p>
<h2 id="JDK7-新特性：类型推断"><a href="#JDK7-新特性：类型推断" class="headerlink" title="JDK7 新特性：类型推断"></a>JDK7 新特性：类型推断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以HashMap为例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();	// JDK7之前</span></span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();	<span class="comment">// jdk7新特性：类型推断</span></span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">67</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型的嵌套</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="集合中使用泛型总结"><a href="#集合中使用泛型总结" class="headerlink" title="集合中使用泛型总结"></a>集合中使用泛型总结</h2><ul>
<li><p>  集合接口或集合类从 JDK5 开始都修改为带泛型的结构。</p>
</li>
<li><p>  在实例化集合类时，可以指明具体的泛型类型。</p>
</li>
<li><p>指明完以后，在集合类或接口中凡是使用到泛型的位置，都会转换为具体的数据类型。</p>
<p>  比如：add(E e)  —&gt; 实例化以后：add(Integer e)</p>
</li>
<li><p>  注意点：<strong>泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型时，拿包装类替换</strong>。</p>
</li>
<li><p>  <strong>如果实例化时，没指明泛型的类型。默认类型为 <code>java.lang.Object</code> 类型。</strong></p>
</li>
</ul>
<hr>
<h1 id="泛型的语法（自定义泛型类、泛型接口、泛型方法）"><a href="#泛型的语法（自定义泛型类、泛型接口、泛型方法）" class="headerlink" title="泛型的语法（自定义泛型类、泛型接口、泛型方法）"></a>泛型的语法（自定义泛型类、泛型接口、泛型方法）</h1><h2 id="1-定义和使用带泛型的类"><a href="#1-定义和使用带泛型的类" class="headerlink" title="1    定义和使用带泛型的类"></a>1    定义和使用带泛型的类</h2><blockquote>
<p>  <strong>定义：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>使用：</strong>（== 什么时候确定泛型）</p>
</blockquote>
<p>定义类的时候，只是表明了该类将会使用泛型，但<strong>具体的泛型类型，是在创建实例对象的时候指定的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义带泛型的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArratList</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用：创建对象时，根据创建对象时指定的泛型不同，集合中保存数据的类型也不同。但是class类只有一个。</span></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>





<h2 id="2-定义和使用含有泛型的接口"><a href="#2-定义和使用含有泛型的接口" class="headerlink" title="2    定义和使用含有泛型的接口"></a>2    定义和使用含有泛型的接口</h2><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>使用：</strong></p>
</blockquote>
<ol>
<li> <strong>定义实现类(子类)时确定泛型的类型</strong>。</li>
<li> <strong>始终不缺定泛型的类型，直到创建对象时，才确定泛型的类型</strong>。</li>
</ol>
<ul>
<li>  <strong>接口A</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&lt;T&gt;&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用：</span></span><br><span class="line"><span class="comment">      1. 定义实现类时确定泛型的类型</span></span><br><span class="line"><span class="comment">      2. 始终不缺定泛型的类型，直到创建对象时，才确定泛型的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> Class C&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">A</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">psvm&#123;</span><br><span class="line">    C&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">C</span>&lt;Integer&gt;();    <span class="comment">// 直到创建对象时，才确定泛型的类型为Integer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  定义实现类 B 的时候确定泛型的类型：此时 <code>class B</code> 就不再是泛型类了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&lt;Integer&gt;&#123; <span class="comment">// 此时，泛型E的值就是Integer，类 B 就不是泛型类了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  直到创建对象 C 时，才确定泛型的类型：此时 <code>class C</code> 仍然是泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">A</span>&lt;T&gt;&#123;  <span class="comment">// 在实现类的定义阶段并没有确定泛型的类型， class C 仍然是泛型类</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        C&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">C</span>&lt;&gt;();   <span class="comment">// 直到创建对象时，才确定泛型的类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-定义和使用带泛型的方法"><a href="#3-定义和使用带泛型的方法" class="headerlink" title="3    定义和使用带泛型的方法"></a>3    定义和使用带泛型的方法</h2><blockquote>
<p>  <strong>定义：</strong></p>
</blockquote>
<ul>
<li>  泛型方法：在方法中出现了泛型结构的方法就叫做泛型方法。</li>
<li>  <strong>泛型参数与类的泛型参数没任何关系。</strong></li>
<li>  换句话说就是，<strong>泛型方法所属的类是不是泛型类都没关系</strong>。</li>
<li>  泛型方法，可以是一个静态方法。【原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。】</li>
<li>  泛型可以声明在参数列表中的参数上；</li>
<li>  也可以声明在方法的返回值上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;E&gt; 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4    代码演示"></a>4    代码演示</h2><blockquote>
<ol>
<li> <strong>Order.java</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的内部结构就可以使用类的泛型</span></span><br><span class="line">    T orderT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        T[] arr = new T[10];</span></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String orderName, <span class="type">int</span> orderId, T orderT)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下的个方法都是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span>&#123;   <span class="comment">// 泛型声明在返回值中</span></span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span>&#123;    <span class="comment">// 泛型声明在参数列表中</span></span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, orderT=&quot;</span> + orderT +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法中不能使用类的泛型。</span></span><br><span class="line"><span class="comment">//    public static void show(T orderT)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        try&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;catch(T t)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 泛型方法可以是静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (E e : arr) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li> <strong>SubOrder.java</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubOrder</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (E e : arr) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li> <strong>测试</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">    <span class="comment">// 要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setOrderT(<span class="number">123</span>);</span><br><span class="line">    order.setOrderT(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建议：实例化时指明类的泛型</span></span><br><span class="line">    Order&lt;String&gt; order1 = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;String&gt;(<span class="string">&quot;orderAA&quot;</span>, <span class="number">1001</span>, <span class="string">&quot;order:AA&quot;</span>);</span><br><span class="line">    order1.setOrderT(<span class="string">&quot;AA:hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SubOrder</span> <span class="variable">sub1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubOrder</span>();</span><br><span class="line">    <span class="comment">// 由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。</span></span><br><span class="line">    sub1.setOrderT(<span class="number">1122</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 泛型不同的引用不能相互赋值。</span></span><br><span class="line">    <span class="comment">// list1 = list2;   // 编译时异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试泛型方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;();</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 泛型方法在调用时，指明泛型参数的类型。</span></span><br><span class="line">    List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-注意点"><a href="#5-注意点" class="headerlink" title="5    注意点"></a>5    注意点</h2><ol>
<li> 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：<code>&lt;E, T, K, V&gt;</code></li>
<li> 泛型的不同引用之间不能相互赋值。</li>
<li> 泛型如果不指定，将被擦除，泛型对应的类型均按照 Object 处理。</li>
<li> 如果泛型结构是一个抽象类或接口，则不可能创建一个泛型类的对象。</li>
<li> JDK7 中，新增了自动类型推断，简化了泛型的操作。</li>
<li> 泛型在使用时不能用基本数据类型，可以使用包装类替代。</li>
<li> 在 <code>类/接口</code> 上声明的泛型，在本类或本接口中即代表某种具体类型，可以作为非静态属性的类型，非静态方法的参数类型和返回值类型。但<strong>在静态方法中不能使用类的泛型</strong>。</li>
<li> <strong>静态方法中也可以使用泛型，但静态方法中使用的泛型是独立的泛型，而不是泛型类（或泛型接口）上声明的泛型。</strong></li>
<li> <strong>异常类不能是泛型的</strong>。即如果一个类实现或继承了 Exception 系列的类或接口，它就不能再使用泛型了。</li>
<li> 不能使用 <code>E e = new E[]</code>，但可以使用 **E[] = (E[])new Object[capacity]**。</li>
<li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型<ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>  ①没有类型，擦除；    </li>
<li>  ②指定具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>  ①全部保留</li>
<li>  ②部分保留</li>
</ul>
</li>
</ul>
</li>
<li> 子类除了指定或保留父类的泛型外，还可以增加自己的泛型。</li>
</ol>
<hr>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><ul>
<li>  在定义类、接口或方法时，使用泛型可以将数据类型的确定延后到创建对象或调用方法时，但是如果直到创建对象或调用方法时也还不能确定使用什么数据类型或要使用多种数据类型时，可以采用通配符<code>&lt;?&gt;</code>表示。</li>
<li>  但是一旦使用泛型通配符后，就只能使用Object类中的公共方法，集合中对象自身特有的方法就无法被调用。</li>
</ul>
<h2 id="1-通配符的基本使用"><a href="#1-通配符的基本使用" class="headerlink" title="1    通配符的基本使用"></a>1    通配符的基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        getElements(list1);</span><br><span class="line">        Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        getElements(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElements</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;</span><br><span class="line">        <span class="comment">// ?代表可以接收任意类型数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> <code>getElements</code> 方法第一次传递了 Integer 类型的集合，第二次传递了 String 类型的集合；</li>
<li> 如果要想通过同一个方法处理这些参数，可通过设置 <code>getElements()</code> 方法的形参为 <code>(ArrayList&lt;?&gt; arr)</code>或其父类表示。</li>
</ol>
<h2 id="2-通配符的高级使用——受限泛型"><a href="#2-通配符的高级使用——受限泛型" class="headerlink" title="2    通配符的高级使用——受限泛型"></a>2    通配符的高级使用——受限泛型</h2><p>在 Java 中，通过通配符可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<blockquote>
<ol>
<li> <strong>泛型的上限</strong></li>
</ol>
</blockquote>
<ul>
<li><p>格式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名称 &lt;? extends 类&gt; 对象名称</span><br></pre></td></tr></table></figure></li>
<li><p>  含义：在指定泛型的类型时，只能设置为该类型或其子类。</p>
</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>泛型的下限</strong></li>
</ol>
</blockquote>
<ul>
<li><p>格式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名称 &lt;? <span class="built_in">super</span> 类&gt; 对象名称</span><br></pre></td></tr></table></figure></li>
<li><p>  含义：：在指定泛型的类型时，只能设置为该类型或其父类。</p>
</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>代码演示</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// Number类型是Integer类型的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        ArrayList&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        getElement1(list1);</span><br><span class="line">        getElement1(list2);     <span class="comment">// 报错</span></span><br><span class="line">        getElement1(list3);</span><br><span class="line">        getElement1(list4);     <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        getElement2(list1);     <span class="comment">// 报错</span></span><br><span class="line">        getElement2(list2);     <span class="comment">// 报错</span></span><br><span class="line">        getElement2(list3);</span><br><span class="line">        getElement2(list4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用getElement1方法时，只能接收Number类型及其子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(ArrayList&lt;? extends Number&gt; arr)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用getElement2方法时，只能接收Number类型及其父类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Number&gt; arr)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3    注意点"></a>3    注意点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list = list1;	<span class="comment">// 编译通过</span></span><br><span class="line">    list = list2;	<span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">//        list1 = list2;  // 编译时异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list = list3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加(写入)：对于List&lt;?&gt;，不能向其内部添加数据，除了添加null之外。</span></span><br><span class="line">    <span class="comment">//        list.add(&quot;DD&quot;);	// 编译时异常</span></span><br><span class="line">    list.add(<span class="literal">null</span>);	<span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>涉及通配符的集合的数据的写入和读取</strong>：如上面代码所示</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/31/%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/31/%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-31 10:35:42 / Modified: 12:34:29" itemprop="dateCreated datePublished" datetime="2021-07-31T10:35:42+08:00">2021-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1    是什么"></a>1    是什么</h2><p><strong>定义</strong>：异常是指程序在执行过程中出现的非正常情况，最终会导致程序的非正常停止。</p>
<p>【异常并不是语法错误，语法错误的话编译时就会直接报错，不会产生字节码文件，根本不能运行。】</p>
<ul>
<li>在 Java 等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出了一个异常对象。</li>
<li>Java处理异常的方式是<strong>中断处理</strong>。</li>
</ul>
<h2 id="2-异常的体系结构"><a href="#2-异常的体系结构" class="headerlink" title="2    异常的体系结构"></a>2    异常的体系结构</h2><blockquote>
<ul>
<li>  Throwable 是<strong>类</strong>，不是接口</li>
<li>  同样的，Error 和 Exception 继承了 Throwable ，所以它俩也是<strong>类</strong></li>
<li>  RuntimeException 继承了 Exception，也是一个<strong>类</strong>；</li>
<li>  但是 CheckedException 并没有真正地继承 Exception 类，并且它是一个<strong>接口</strong>。</li>
</ul>
</blockquote>
<p><img src="/2021/07/31/%E5%BC%82%E5%B8%B8/Throwable.png"></p>
<p>​        在 Java 中，所有的异常都有一个共同的祖先 <strong>java.lang.Throwable</strong> 类。Throwable 类有两个重要的子类 <strong>Exception</strong>（异常） 和 <strong>Error</strong>（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* java.lang.Throwable</span><br><span class="line">* 		|-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">* 		|-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">* 			|------编译时异常(checked)</span><br><span class="line">* 					|-----IOException</span><br><span class="line">* 						|-----FileNotFoundException</span><br><span class="line">* 					|-----ClassNotFoundException</span><br><span class="line">* 			|------运行时异常(unchecked,RuntimeException)</span><br><span class="line">* 					|-----NullPointerException</span><br><span class="line">* 					|-----ArrayIndexOutOfBoundsException</span><br><span class="line">* 					|-----ClassCastException</span><br><span class="line">* 					|-----NumberFormatException</span><br><span class="line">* 					|-----InputMismatchException</span><br><span class="line">* 					|-----ArithmeticException</span><br></pre></td></tr></table></figure>





<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><blockquote>
<p>  <strong>java.lang.Error</strong></p>
</blockquote>
<p><strong>Error 错误是程序无法处理的错误</strong>。大多数是 JVM 层面的问题。即代码在逻辑上是正确的，但是由于 JVM 内存不足或者某些对象申请的内存空间过大导致等原因导致程序出现错误。 这些错误是在编译期是不可查的，因为它们在应用程序的控制和处理能力之外。</p>
<p>​        例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 <code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><blockquote>
<p>  <strong>java.lang.Exception</strong></p>
</blockquote>
<p><strong>Exception 是程序本身可以处理的异常</strong>。Exception 又可分为 <strong>编译时异常</strong> 与 <strong>运行时异常</strong> 两大类。</p>
<p><img src="/2021/07/31/%E5%BC%82%E5%B8%B8/image-20210730163920638.png" alt="image-20210730163920638"></p>
<ul>
<li>  编译时异常：执行 <code>javac.exe</code> 命名时，可能出现的异常；</li>
<li>  运行时异常：执行 <code>java.exe</code> 命名时，出现的异常；</li>
</ul>
<h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><blockquote>
<p>  <strong>执行 <code>javac.exe</code> 命名时，可能出现的异常；</strong></p>
</blockquote>
<p>以下是一个编译时异常的简单例子。由于我们使用的是 IDEA 集成开发工具，代码是即时编译的，所以可以编译时异常不会在控制台上输出，而是非常智能的提示出来了。但是如果我们使用基本的文本工具进行开发，编写的 <code>.java</code> 代码是不会自动提示错误的，只有在经过 javac 编译后才会提示，这就是所谓的<strong>编译时异常</strong>。</p>
<img src="/2021/07/31/%E5%BC%82%E5%B8%B8/image-20210730163330302.png" alt="image-20210730163330302" style="zoom: 67%;">



<h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><blockquote>
<p>  <strong>执行 <code>java.exe</code> 命名时，出现的异常；</strong></p>
</blockquote>
<p>程序在执行 <code>java.exe</code> 运行后提示的异常。</p>
<blockquote>
<p>  常见的运行时异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException	<span class="comment">// 要访问的变量没有引用任何对象时，抛出该异常）、</span></span><br><span class="line">ArithmeticException		<span class="comment">// 算术运算异常，一个整数除以0时，抛出该异常）和 </span></span><br><span class="line">ArrayIndexOutOfBoundsException	<span class="comment">// 下标越界异常</span></span><br></pre></td></tr></table></figure>





<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>异常和错误的区别</strong>：异常能被程序本身可以处理，错误是无法处理。</p>
<p><strong>如何理解</strong></p>
<p>我们可以看到，无论是编译期异常还是运行期异常，产生异常后程序员可以在代码层面纠正，使程序能继续正常运行。如上面的编译期异常，可以通过 <code>try...catch</code> 捕获处理；对于运行时期的各种异常，如空指针异常，可以通过加判断条件来避免。这些异常都是代码层面可以处理的。而对于一些虚拟机的异常，主要是涉及到了虚拟机的配置，可能出现在某写配置较好的虚拟机上可以正常运行，而在性能较差的虚拟机上就不能运行了的情况，所以说 Error 是无法避免的。</p>
<h2 id="3-Throwable类常用方法"><a href="#3-Throwable类常用方法" class="headerlink" title="3    Throwable类常用方法"></a>3    Throwable类常用方法</h2><table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>printStackTrace()</code></td>
<td align="center"><code>void</code></td>
<td align="center">在控制台上打印异常的详细信息</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>getMessage()</code></td>
<td align="center"><code>String</code></td>
<td align="center">获取发生异常的原因</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>toString</code></td>
<td align="center"><code>String</code></td>
<td align="center">获取异常的类型和详细信息</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-异常处理方式"><a href="#4-异常处理方式" class="headerlink" title="4    异常处理方式"></a>4    异常处理方式</h2><p>异常的两种处理方式：1、<strong>“抛”</strong>  2、<strong>“抓”</strong></p>
<blockquote>
<ol>
<li> <strong>“抛”</strong> </li>
</ol>
</blockquote>
<ul>
<li>  程序在正常执行的过程中，一旦出现异常，就会在异常代码处产生一个对应异常类的对象，并将此对象抛出。</li>
<li>  一旦抛出异常对象以后，其后的代码就不再执行。</li>
</ul>
<p><strong>关于异常对象的产生：</strong></p>
<ol>
<li> 系统自动生成的异常对象；</li>
<li> 手动的生成一个异常对象，并抛出（throw）。</li>
</ol>
<blockquote>
<ol start="2">
<li> <strong>“抓”</strong></li>
</ol>
</blockquote>
<p>可以理解为异常的处理方式：①<code>try-catch-finally</code>  ②<code>throws</code></p>
<h3 id="异常处理方式一：try-catch-finally"><a href="#异常处理方式一：try-catch-finally" class="headerlink" title="异常处理方式一：try-catch-finally"></a>异常处理方式一：try-catch-finally</h3><blockquote>
<p>  <strong>使用说明：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码。</span></span><br><span class="line">    <span class="comment">// 代码中出现的异常可能不止一种，针对不同类型异常可以使用多个catch语句分别做不同的处理 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><code>finally</code> 是可选的。</li>
<li>使用 <code>try</code> 将可能出现异常代码包起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此异常对象的类型，去 <code>catch</code> 中进行匹配；</li>
<li>一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构，继续执行 <code>try</code> 中后续的代码，最后再执行 <code>finally</code> 中的代码。</li>
<li><code>catch</code> 中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。但是 <strong><code>catch</code> 中的异常类型如果满足子父类关系，则要求子类异常类型一定要声明在父类异常类型的上面</strong>，否则报错。【因为 <code>catch</code> 是从上向下匹配的，如果父类异常类型声明在先，则该父类异常的所有子类异常都会被父类异常拦截（多态），根本执行不到子类异常处 】</li>
<li>常用的异常对象处理的方式： <code>① String  getMessage()    ② printStackTrace()</code></li>
<li>在 <code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用。</li>
<li><code>try-catch-finally</code> 结构可以嵌套。</li>
</ol>
<blockquote>
<p>  <strong>如何看待代码中的编译时异常和运行时异常？</strong></p>
</blockquote>
<ol>
<li> 使用 <code>try-catch-finally</code> 处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</li>
<li> 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。针对于编译时异常，我们则一定要考虑异常的处理。</li>
</ol>
<h3 id="异常处理方式二：throws"><a href="#异常处理方式二：throws" class="headerlink" title="异常处理方式二：throws"></a>异常处理方式二：throws</h3><ul>
<li>  <strong>throws + 异常类型</strong> 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。</li>
<li>  一旦当方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 <code>throws</code> 抛出的异常类型时，就会被抛出。异常代码后续的代码，就不再执行。</li>
</ul>
<h3 id="对比两种处理方式"><a href="#对比两种处理方式" class="headerlink" title="对比两种处理方式"></a>对比两种处理方式</h3><ul>
<li>  <code>try-catch-finally</code>：真正的将异常给处理掉了。</li>
<li>  <code>throws</code>：只是将异常抛给了方法的调用者，并没真正将异常处理掉。</li>
</ul>
<h3 id="体会开发中应该如何选择两种处理方式？"><a href="#体会开发中应该如何选择两种处理方式？" class="headerlink" title="体会开发中应该如何选择两种处理方式？"></a>体会开发中应该如何选择两种处理方式？</h3><ul>
<li>  如果父类中被重写的方法没 <code>throws</code> 方式处理异常，则子类重写的方法也不能使用 <code>throws</code>。这意味着如果子类重写的方法中异常，必须使用 <code>try-catch-finally</code> 方式处理。</li>
<li>  执行的方法 <code>methodA()</code> 中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用 <code>throws</code> 的方式进行处理，而执行的方法 <code>methodA()</code> 可以考虑使用 <code>try-catch-finally</code> 方式进行处理。</li>
<li>  使用 <code>throws</code> 抛出的异常最外层还是要落实到使用 <code>try-catch-finally</code> 处理。</li>
</ul>
<blockquote>
<p>  <strong>补充：</strong></p>
</blockquote>
<ul>
<li>  方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。【因为父类是子类的顶级抽象，如果子类的异常类型范围大于父类类型的话，则父类就会无法处理超出范围的异常类型】</li>
</ul>
<hr>
<h2 id="5-手动抛出异常对象"><a href="#5-手动抛出异常对象" class="headerlink" title="5    手动抛出异常对象"></a>5    手动抛出异常对象</h2><blockquote>
<ol>
<li> <strong>使用说明</strong></li>
</ol>
</blockquote>
<p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以通过 <code>throw</code> 手动抛出一个异常类的对象。</p>
<blockquote>
<ol start="2">
<li> <strong>throw 和  throws 的区别？</strong></li>
</ol>
</blockquote>
<p><strong>throw</strong>：</p>
<ul>
<li>  动词，表示抛出一个异常类的对象。</li>
<li>  生成异常对象的过程，声明在方法体内。</li>
<li>  <code>throw</code> 抛出的对象会由 <code>throws</code> 接收并抛给上一层，并在最外层由 <code>try-catch-finally</code> 处理，或直接中断程序。</li>
</ul>
<p><strong>throws</strong>：</p>
<ul>
<li>  名词，属于异常处理的一种方式。声明在方法的声明处。</li>
<li>  <code>throws</code> 用于接收程序运行时由系统抛出或者用户自定义抛出的异常，并交给 <code>try-catch-finally</code> 处理。  </li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 手动抛出异常对象</span></span><br><span class="line"><span class="comment">//			throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="comment">//			throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);	<span class="comment">// 自定义异常对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-自定义异常类"><a href="#6-自定义异常类" class="headerlink" title="6    自定义异常类"></a>6    自定义异常类</h2><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/11/26/%E9%80%9A%E7%94%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/">超链接：开发中的通用异常处理</a></p>
</blockquote>
<blockquote>
<p>  <strong>如何自定义一个异常类？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何自定义异常类？</span></span><br><span class="line"><span class="comment"> * 1. 继承于现的异常结构：RuntimeException 、Exception</span></span><br><span class="line"><span class="comment"> * 2. 提供全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment"> * 3. 提供重载的构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">红黑树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-30 22:42:04" itemprop="dateCreated datePublished" datetime="2021-07-30T22:42:04+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-31 12:03:42" itemprop="dateModified" datetime="2021-08-31T12:03:42+08:00">2021-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="红黑树基础：二叉搜索树"><a href="#红黑树基础：二叉搜索树" class="headerlink" title="红黑树基础：二叉搜索树"></a>红黑树基础：二叉搜索树</h1><blockquote>
<p>  <strong>二叉搜索树</strong></p>
</blockquote>
<p><strong>二叉搜索树（binary search tree）</strong>就是在二叉树的基础上增加了一些额外的条件，二叉搜索树是一种特殊的二叉树。</p>
<blockquote>
<p>  <strong>二叉搜索树要求：</strong></p>
</blockquote>
<ol>
<li> 若左子树不为空，则左子树上所有结点的值均小于根结点的值； </li>
<li> 若右子树不为空，则右子树上所有结点的值均大于根结点的值； </li>
<li> 左、右子树也分别为二叉排序树。</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p>
<hr>
<h2 id="二叉搜索树-查找节点："><a href="#二叉搜索树-查找节点：" class="headerlink" title="二叉搜索树-查找节点："></a>二叉搜索树-查找节点：</h2><p>查找某个节点，我们必须从根节点开始查找。</p>
<ol>
<li> 查找值比当前节点值大，则搜索右子树；</li>
<li> 查找值等于当前节点值，停止搜索（终止条件）；</li>
<li> 查找值小于当前节点值，则搜索左子树；</li>
</ol>
<hr>
<h2 id="二叉搜索树-插入节点："><a href="#二叉搜索树-插入节点：" class="headerlink" title="二叉搜索树-插入节点："></a>二叉搜索树-插入节点：</h2><ul>
<li>  要插入节点，必须先找到插入的位置。</li>
<li>  与查找操作相似，由于二叉搜索树的特殊性，待插入的节点也需要从根节点开始进行比较，小于根节点则与根节点左子树比较，反之则与右子树比较，直到左子树为空或右子树为空，则插入到相应为空的位置。</li>
</ul>
<hr>
<h2 id="二叉搜索树-遍历节点："><a href="#二叉搜索树-遍历节点：" class="headerlink" title="二叉搜索树-遍历节点："></a>二叉搜索树-遍历节点：</h2><p>二叉搜索树的遍历与普通二叉树的遍历一样，常见的有：</p>
<ul>
<li>  前序遍历</li>
<li>  中序遍历</li>
<li>  后序遍历</li>
</ul>
<h2 id="二叉搜索树-查找最大值和最小值"><a href="#二叉搜索树-查找最大值和最小值" class="headerlink" title="二叉搜索树-查找最大值和最小值"></a>二叉搜索树-查找最大值和最小值</h2><ul>
<li>  要找最小值，先找根的左节点，然后一直找这个左节点的左节点，直到找到没有左节点的节点，那么这个节点就是最小值。</li>
<li>  同理要找最大值，一直找根节点的右节点，直到没有右节点，则就是最大值。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC.png" alt="最大值和最小值"></p>
<hr>
<h2 id="二叉搜索树-删除节点："><a href="#二叉搜索树-删除节点：" class="headerlink" title="二叉搜索树-删除节点："></a>二叉搜索树-删除节点：</h2><p>删除节点是二叉搜索树中最复杂的操作，删除的节点有三种情况，前两种比较简单，但是第三种却很复杂。</p>
<blockquote>
<ol>
<li> 待删除的节点是叶节点（没有子节点）</li>
<li> 待删除的节点有一个子节点</li>
<li> 待删除的节点有两个子节点</li>
</ol>
</blockquote>
<h3 id="Case1：删除叶子节点"><a href="#Case1：删除叶子节点" class="headerlink" title="Case1：删除叶子节点"></a>Case1：删除叶子节点</h3><ul>
<li>  找到待删除的叶子节点，将其父节点指向该节点的引用改为null即可。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9.png" alt="删除叶子节点"></p>
<hr>
<h3 id="Case2：删除有一个子节点的节点"><a href="#Case2：删除有一个子节点的节点" class="headerlink" title="Case2：删除有一个子节点的节点"></a>Case2：删除有一个子节点的节点</h3><ul>
<li>  删除有一个子节点的节点，我们只需要将其父节点原本指向该节点的引用，改为指向该节点的子节点即可。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="删除拥有一个子节点的节点"></p>
<hr>
<h3 id="Case3：删除有两个子节点的节点"><a href="#Case3：删除有两个子节点的节点" class="headerlink" title="Case3：删除有两个子节点的节点"></a>Case3：删除有两个子节点的节点</h3><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E6%8B%A5%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9_01.png" alt="删除拥有两个子节点的节点_01"></p>
<ul>
<li>  当待删除的节点存在两个子节点，那么删除之后，两个子节点的位置我们就没办法处理了。</li>
<li>  既然处理不了，我们就想到一种办法，<strong>用其中一个节点来代替被删除的节点</strong>，那么用哪一个节点来代替呢？</li>
<li>  我们知道二叉搜索树中的节点是按照关键字来进行排列的，某个节点的关键字次高节点是它的中序遍历<strong>后继节点</strong>。</li>
<li>  用后继节点来代替删除的节点，显然该二叉搜索树还是有序的。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E6%8B%A5%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="删除拥有两个子节点的节点"></p>
<blockquote>
<p>  <strong>如何找到删除节点的中序后继节点？</strong></p>
</blockquote>
<ul>
<li>  实际上就是要找比删除节点关键值大的节点集合中最小的一个节点，只有这样代替删除节点后才能满足二叉搜索树的特性。</li>
<li>  后继节点也就是：<strong>比删除节点大的最小节点</strong>。</li>
</ul>
<hr>
<h3 id="Case4：删除有必要吗？"><a href="#Case4：删除有必要吗？" class="headerlink" title="Case4：删除有必要吗？"></a>Case4：删除有必要吗？</h3><ul>
<li>  通过上面的删除分类讨论，我们发现删除其实是挺复杂的，那么其实我们<strong>可以不用真正的删除该节点，只需要在Node类中增加一个标识字段 isDelete</strong>，当该字段为true时，表示该节点已经删除，反之则没有删除。这样删除节点就不会改变树的结构了。</li>
<li>  影响就是查询时需要判断一下节点是否已被删除。</li>
</ul>
<hr>
<h2 id="二叉搜索树-时间复杂度分析："><a href="#二叉搜索树-时间复杂度分析：" class="headerlink" title="二叉搜索树-时间复杂度分析："></a>二叉搜索树-时间复杂度分析：</h2><h3 id="回顾经典：二分查找算法"><a href="#回顾经典：二分查找算法" class="headerlink" title="回顾经典：二分查找算法"></a>回顾经典：二分查找算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,8,9。。。。。。。100]</span><br></pre></td></tr></table></figure>

<ul>
<li>  暴力算法：运气好时 性能不错，运气不好时 性能暴跌。</li>
<li>  二分查找算法：数据源必须是<strong>有序数组</strong>，性能较好，每次迭代查询可以排除掉一半的结果。</li>
</ul>
<blockquote>
<p>  <strong>二分查找算法最大的缺陷是什么？</strong></p>
</blockquote>
<ul>
<li>  <strong>数组必须有序</strong></li>
<li>  数组自身缺陷：没有办法快速插入，也没有办法扩容</li>
</ul>
<blockquote>
<p>  <strong>怎么样才能拥有二分查找的高性能又能拥有链表一样的灵活性？</strong></p>
</blockquote>
<ul>
<li>  二叉搜索树</li>
</ul>
<blockquote>
<p>  二分查找算法时间复杂度推算过程：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">第几次查询</th>
<th align="center">剩余待查询元素数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">N/2</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">N/(2^2)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">N/(2^3)</td>
</tr>
<tr>
<td align="center">K</td>
<td align="center">N/(2^K)</td>
</tr>
</tbody></table>
<ul>
<li>  从上表可以看出 <strong>N/(2^K)</strong> 肯定是大于等于1，也就是 <strong>N/(2^K)&gt;=1</strong> ，我们计算时间复杂度是按照<strong>最坏的情况</strong>进行计算，也就是是查到剩余最后一个数才查到我们想要的数据，也就是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">N/(2^K)=1   =&gt;   2^K = N   =&gt; K = log2 (N)    </span><br><span class="line">=&gt;  二分查找算法时间复杂度：O(log2(N))  =&gt; O(logN)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="普通二叉搜索树致命缺陷："><a href="#普通二叉搜索树致命缺陷：" class="headerlink" title="普通二叉搜索树致命缺陷："></a>普通二叉搜索树致命缺陷：</h2><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5.png" alt="二叉搜索树-极端情况"></p>
<ul>
<li>  <strong>这颗二叉树查询效率咋样呢？O(N)</strong></li>
<li>  <strong>怎么解决 二叉搜索树 退化成线性链表的问题？</strong></li>
<li>  <strong>如果插入元素时，树可以自动调整两边平衡，会保持不错的查找性能。</strong></li>
</ul>
<h2 id="AVL树简介："><a href="#AVL树简介：" class="headerlink" title="AVL树简介："></a>AVL树简介：</h2><blockquote>
<p>  <strong>AVL树有什么特点？</strong></p>
</blockquote>
<ol>
<li> 具有二叉查找树的全部特性。</li>
<li> 每个节点的左子树和右子树的<strong>高度差至多等于1</strong>。</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/AVL%E6%A0%91.png" alt="AVL树"></p>
<ul>
<li>  平衡树基于这种特点就可以保证不会出现大量节点偏向于一边的情况了！</li>
<li>  <strong>插入或者删除时，会发生左旋、右旋操作，使这棵树再次左右保持一定的平衡</strong>。</li>
</ul>
<hr>
<h2 id="为什么有了平衡树还需要红黑树？"><a href="#为什么有了平衡树还需要红黑树？" class="headerlink" title="为什么有了平衡树还需要红黑树？"></a>为什么有了平衡树还需要红黑树？</h2><ul>
<li>  虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 <code>O(logn)</code>，不过却<strong>不是最佳</strong>的，</li>
<li>  因为平衡树要求每个节点的左子树和右子树的高度差至多等于 1，这个要求实在是太严了，导致每次进行【插入/删除】节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树！</li>
</ul>
<hr>
<h1 id="红黑树原理讲解"><a href="#红黑树原理讲解" class="headerlink" title="红黑树原理讲解"></a>红黑树原理讲解</h1><blockquote>
<ol>
<li> 红黑树的性质</li>
<li>红黑树自平衡的策略<ul>
<li>  改变颜色</li>
<li>  左旋</li>
<li>  右旋</li>
</ul>
</li>
<li> 红黑树的查找</li>
<li>红黑树的插入<ul>
<li>  Case1：红黑树为空树</li>
<li>  Case2：插入节点的 key 已经存在</li>
<li>  Case3：插入节点的父节点为黑色</li>
<li>Case4：插入节点的父节点为红色<ul>
<li>  Case4.1：叔叔节点存在，并且为红色（父-叔 双红）</li>
<li>Case4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树<ul>
<li>  Case4.2.1：插入节点为其父节点的左子节点（LL情况）</li>
<li>  Case4.2.2：插入节点为其父节点的右子节点（LR情况）</li>
</ul>
</li>
<li>Case4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树<ul>
<li>  Case4.3.1：插入节点为其父节点的右子节点（RR情况）</li>
<li>  Case4.3.2：插入节点为其父节点的左子节点（RL情况）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li> 红黑树插入案例分析</li>
</ol>
</blockquote>
<h2 id="红黑树的性质："><a href="#红黑树的性质：" class="headerlink" title="红黑树的性质："></a>红黑树的性质：</h2><table>
<thead>
<tr>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">性质1：</td>
<td>每个节点要么是<strong>黑色</strong>，要么是<strong>红色</strong>。</td>
</tr>
<tr>
<td align="center">性质2：</td>
<td>根节点是<strong>黑色</strong>。</td>
</tr>
<tr>
<td align="center">性质3：</td>
<td>每个叶子节点（<strong>包括NULL</strong>）是<strong>黑色</strong>。</td>
</tr>
<tr>
<td align="center">性质4：</td>
<td>每个<strong>红色</strong>节点的两个子节点一定都是<strong>黑色</strong>。</td>
</tr>
<tr>
<td align="center">性质5：</td>
<td>任意一节点到每个叶子节点的路径都包含<strong>数量相同</strong>的<strong>黑结点</strong>。</td>
</tr>
<tr>
<td align="center">性质5.1：</td>
<td>从性质5又可以推出：如果一个节点存在黑子节点，那么该结点肯定有两个子节点</td>
</tr>
</tbody></table>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<ul>
<li>  红黑树并<strong>不是一个平衡二叉查找树</strong>，从图上可以看到，根结点 P 的左子树显然比右子树高，</li>
<li>  但<strong>左子树和右子树的黑色结点的层数是相等的</strong>，即任意一个结点到到每个叶子结点的路径都包含数量相同的黑色结点(性质5)。</li>
<li>  所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong>。</li>
</ul>
<hr>
<h2 id="红黑树自平衡："><a href="#红黑树自平衡：" class="headerlink" title="红黑树自平衡："></a>红黑树自平衡：</h2><blockquote>
<p>  <strong>前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。</strong></p>
</blockquote>
<ol>
<li> <strong>变色：</strong>结点的颜色由红变黑或由黑变红。</li>
<li> <strong>左旋：</strong>以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。</li>
<li> <strong>右旋：</strong>以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li>
</ol>
<blockquote>
<p>  <strong>左旋</strong></p>
</blockquote>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%B7%A6%E6%97%8B.gif" alt="左旋"></p>
<blockquote>
<p>  <strong>右旋</strong></p>
</blockquote>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%8F%B3%E6%97%8B.gif" alt="右旋"></p>
<h2 id="红黑树查找："><a href="#红黑树查找：" class="headerlink" title="红黑树查找："></a>红黑树查找：</h2><p>红黑树查找与二叉搜索树查找一样，都是左边小、右边大。</p>
<h2 id="红黑树插入："><a href="#红黑树插入：" class="headerlink" title="红黑树插入："></a>红黑树插入：</h2><p>插入操作包括两部分工作：</p>
<blockquote>
<ol>
<li> 查找插入的位置</li>
<li> <strong>插入后自平衡</strong></li>
</ol>
</blockquote>
<p><strong>注意：</strong>插入节点，必须为<strong>红色</strong>。</p>
<p>理由很简单，如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多 1，必须做自平衡。而红色在父节点（如果存在）为黑色节点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。</p>
<p>在开始每个情景的讲解前，我们还是先来约定下：</p>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A6%E5%AE%9A.png" alt="约定"></p>
<hr>
<h2 id="红黑树插入节点情况分析"><a href="#红黑树插入节点情况分析" class="headerlink" title="红黑树插入节点情况分析"></a>红黑树插入节点情况分析</h2><h3 id="情景1：红黑树为空树"><a href="#情景1：红黑树为空树" class="headerlink" title="情景1：红黑树为空树"></a>情景1：红黑树为空树</h3><ul>
<li>  最简单的一种情景，直接把插入结点作为根结点就行</li>
<li>  注意：根据红黑树性质2，根节点必须是黑色，但是因为插入的节点一定一定是红色节点，所以还需要把新插入结点设为黑色。</li>
</ul>
<h3 id="情景2：插入结点的Key已存在"><a href="#情景2：插入结点的Key已存在" class="headerlink" title="情景2：插入结点的Key已存在"></a>情景2：插入结点的Key已存在</h3><ul>
<li>  处理：更新当前节点的值，为插入节点的值</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B5%E4%BA%8C_%E6%9B%BF%E6%8D%A2%20(2).png" alt="情况二_替换 (2)"></p>
<h3 id="情景3：插入结点的父结点为黑结点"><a href="#情景3：插入结点的父结点为黑结点" class="headerlink" title="情景3：插入结点的父结点为黑结点"></a>情景3：插入结点的父结点为黑结点</h3><p>由于插入的结点是红色的，当插入结点的父节点时黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B5%E4%B8%89_%E9%BB%91%E7%88%B6.png" alt="情况三_黑父"></p>
<h3 id="情景4：插入节点的父节点为红色"><a href="#情景4：插入节点的父节点为红色" class="headerlink" title="情景4：插入节点的父节点为红色"></a>情景4：插入节点的父节点为红色</h3><ul>
<li>  根据红黑树的<strong>性质2：根结点是黑色</strong>。如果插入节点的父结点为<strong>红结点</strong>，那么该父结点不可能为根结点，所以插入结点总是存在爷爷结点。</li>
<li>  这一点很关键，因为后续的旋转操作肯定需要爷爷结点的参与。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B5%E5%9B%9B_%E7%88%B6%E8%8A%82%E7%82%B9%E7%BA%A2%E8%89%B2.png" alt="情况四_父节点红色"></p>
<h4 id="插入情景4-1：叔叔结点存在并且为红结点"><a href="#插入情景4-1：叔叔结点存在并且为红结点" class="headerlink" title="插入情景4.1：叔叔结点存在并且为红结点"></a>插入情景4.1：叔叔结点存在并且为红结点</h4><ul>
<li>  依据红黑树<strong>性质4可知，红色节点不能相连 ==&gt; 祖父结点肯定为黑结点</strong>；</li>
<li>  因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。</li>
<li>  首先第一步处理就是变色，将其改为：<strong>红黑红</strong></li>
</ul>
<blockquote>
<p>  <strong>处理：</strong></p>
</blockquote>
<ol>
<li> 将黑红红改为红黑红</li>
<li> 以 PP 作为新的当前节点，进行后续处理</li>
<li><ul>
<li>  如果 PP 的父结点是黑色，那么无需再做任何处理；</li>
<li>  但如果 PP 的父结点是红色，则违反红黑树性质了。所以需要将 PP 设置为当前节点，继续做插入操作自平衡处理，直到平衡为止。</li>
</ul>
</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B54.1_%E5%8F%94%E5%8F%94%E7%BA%A2%E8%89%B2.png" alt="情况4.1_叔叔红色"></p>
<h4 id="插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点"><a href="#插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点" class="headerlink" title="插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点"></a>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点</h4><ul>
<li>  <strong>注意</strong>：单纯从插入前来看，叔叔节点非红即空（NIL节点），否则的话破坏了红黑树性质5，此路径会比其它路径多一个黑色节点。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.png" alt="4.2"></p>
<h5 id="插入情景4-2-1：新插入节点，为其父节点的左子节点（LL红色情况）"><a href="#插入情景4-2-1：新插入节点，为其父节点的左子节点（LL红色情况）" class="headerlink" title="插入情景4.2.1：新插入节点，为其父节点的左子节点（LL红色情况）"></a>插入情景4.2.1：新插入节点，为其父节点的左子节点（LL红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.1_LL.png" alt="4.2.1_LL"></p>
<blockquote>
<p>  处理：</p>
</blockquote>
<ol>
<li> 变色：将P设置为黑色，将PP设置为红色；</li>
<li> 对 PP 节点进行<strong>右旋</strong>。</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.1_LL_%E5%A4%84%E7%90%86.png" alt="4.2.1_LL_处理"></p>
<h5 id="插入情景4-2-2：新插入节点，为其父节点的右子节点（LR红色情况）"><a href="#插入情景4-2-2：新插入节点，为其父节点的右子节点（LR红色情况）" class="headerlink" title="插入情景4.2.2：新插入节点，为其父节点的右子节点（LR红色情况）"></a>插入情景4.2.2：新插入节点，为其父节点的右子节点（LR红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.2_LR.png" alt="4.2.2_LR"></p>
<blockquote>
<p>  <strong>处理：</strong></p>
</blockquote>
<ol>
<li> 对 P 进行左旋，得到 LL 红色情况</li>
<li>按照 LL 红色情况处理<ol>
<li> 变颜色</li>
<li> 右旋PP</li>
</ol>
</li>
</ol>
<h4 id="插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点"><a href="#插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点" class="headerlink" title="插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点"></a>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点</h4><p>该情景对应情景4.2，只是方向反转，直接看图。</p>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.png" alt="4.3"></p>
<h5 id="插入情景4-3-1：新插入节点，为其父节点的右子节点（RR红色情况）"><a href="#插入情景4-3-1：新插入节点，为其父节点的右子节点（RR红色情况）" class="headerlink" title="插入情景4.3.1：新插入节点，为其父节点的右子节点（RR红色情况）"></a>插入情景4.3.1：新插入节点，为其父节点的右子节点（RR红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.1_RR.png" alt="4.3.1_RR"></p>
<blockquote>
<p>  处理：</p>
</blockquote>
<ol>
<li> 变颜色：将P设置为黑色，将PP设置为红色</li>
<li> 对PP节点进行<strong>左旋</strong></li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.1_RR_%E5%A4%84%E7%90%86.png" alt="4.3.1_RR_处理"></p>
<h5 id="插入情景4-3-2：新插入节点，为其父节点的左子节点（RL红色情况）"><a href="#插入情景4-3-2：新插入节点，为其父节点的左子节点（RL红色情况）" class="headerlink" title="插入情景4.3.2：新插入节点，为其父节点的左子节点（RL红色情况）"></a>插入情景4.3.2：新插入节点，为其父节点的左子节点（RL红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.2_RL.png" alt="4.3.2_RL"></p>
<blockquote>
<p>  处理：</p>
</blockquote>
<ol>
<li> 对P进行右旋，得到RR红色情况</li>
<li>按照RR红色情况处理<ol>
<li> 变颜色</li>
<li> 左旋PP</li>
</ol>
</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.2_RL_%E5%A4%84%E7%90%86.png" alt="4.3.2_RL_处理"></p>
<h2 id="红黑树插入案例分析"><a href="#红黑树插入案例分析" class="headerlink" title="红黑树插入案例分析"></a>红黑树插入案例分析</h2><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%A1%88%E4%BE%8B%20(3).png" alt="红黑树插入案例 (3)"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/25/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/LeetCode/" class="post-title-link" itemprop="url">LeetCode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-25 21:11:47" itemprop="dateCreated datePublished" datetime="2021-07-25T21:11:47+08:00">2021-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-02 20:48:36" itemprop="dateModified" datetime="2021-08-02T20:48:36+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="斐波那契数列的多种解法"><a href="#斐波那契数列的多种解法" class="headerlink" title="斐波那契数列的多种解法"></a>斐波那契数列的多种解法</h1><blockquote>
<p>  <strong>斐波那契数列</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 斐波那契数列</span><br><span class="line">*      F(<span class="number">0</span>) = <span class="number">0</span>，</span><br><span class="line">*      F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">*      F(n) = F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>)，其中 n &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="普通递归解法（性能最差）"><a href="#普通递归解法（性能最差）" class="headerlink" title="普通递归解法（性能最差）"></a>普通递归解法（性能最差）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.binarySearch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求：给出 n计算 F(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution509</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fib</span> <span class="operator">=</span> fib(<span class="number">6</span>);</span><br><span class="line">        System.out.println(fib);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>  n;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="递归优化解法"><a href="#递归优化解法" class="headerlink" title="递归优化解法"></a>递归优化解法</h2><p>斐波那契数列递归的时候会造成大量的重复计算，比如就计算 <code>fib(6)</code> 为例来看：<code>F(6) = F(5)+F(4)</code>，当我们计算出 F(5) 的时候，F(4) 也已经被计算出来了，如果我们在 F(6) 的右子节点中能够调用已经计算出来的值的话，那么该节点就不用继续向下展开了。这在 n 非常大时，节省的效率很高，接近于一半。</p>
<p><img src="/2021/07/25/LeetCode/a6f819589ee5e50ec378f2c10835e9a510529bac44618444beb2202486062eee-image.png" alt="image.png"></p>
<p>我们看到上面相同颜色的都是重复计算，当 n 越大，重复的就会越多。</p>
<p>所以我们可以使用一个 map 把计算过的值存起来，每次计算的时候先查看 map 中有没有，</p>
<ul>
<li>  如果有就表示计算过，直接从 map 中取；</li>
<li>  如果没有就先计算，计算完之后再把结果存到map中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.binarySearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 斐波那契数列</span></span><br><span class="line"><span class="comment"> *      F(0) = 0，</span></span><br><span class="line"><span class="comment"> *      F(1) = 1</span></span><br><span class="line"><span class="comment"> *      F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求：给出 n计算 F(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution509</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution509</span>().fib(<span class="number">7</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  fib(int n, HashMap&lt;Integer, Integer&gt; map) 的重载方法，简化调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> fib(n, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  计算斐波那契数的方法（递归优化）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n, HashMap&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// 每次计算的时候先查看 map 中有没有，</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n))&#123;</span><br><span class="line">            <span class="comment">// 如果有直接从 map 中取；</span></span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有就先计算，计算完之后再把结果存到map中。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> fib(n - <span class="number">1</span>, map) + fib(n - <span class="number">2</span>, map);</span><br><span class="line">            map.put(n, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="动态规划（非递归解法）"><a href="#动态规划（非递归解法）" class="headerlink" title="动态规划（非递归解法）"></a>动态规划（非递归解法）</h2><ul>
<li>  想要计算 <strong>F(n)</strong> 的值，就需要知道 F(n-1) 和 F(n-2) 的值；</li>
<li>  想要计算 F(n-1) 的值，就要知道 F(n-2) 和 F(n-3) 的值；</li>
<li>  以此类推，一直到 F(0) 和 F(1)。</li>
</ul>
<p>​        正如上面讲的普通的递归算法的弊端一样，如果每次 F(n-1) 和 F(n-2) 都独立运算，那么重复计算的值就太多了。上面的优化方式是将已经计算过的值保存到一个 Map  中避免重复运算，而且采用的是<strong>自顶向下</strong>的计算方式，即从 F(n-1) 算到 F(1)。</p>
<p>​        而所谓的斐波那契的动态规划解法，其实可以看做是一种穷举法。就是将从 F(1) 到 F(n-1) 的所有值都计算出来，保存到一个 List（或者 Map 均可）中，但是这里采用的是<strong>自底向上</strong>，即从 F(1) 计算到 F(n-1) 。</p>
<p>​        所以，在计算 F(n) 之前，动态规划必定已经建立好了一个从 <code>F(0) ~ F(n-1)</code> 的数组。而结算结果就是从数组中取出对应的元素即可。</p>
<p><img src="/2021/07/25/LeetCode/1600679988-ufqRKk-file_1600679988859" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.binarySearch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 斐波那契数列</span></span><br><span class="line"><span class="comment"> *      F(0) = 0，</span></span><br><span class="line"><span class="comment"> *      F(1) = 1</span></span><br><span class="line"><span class="comment"> *      F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求：给出 n计算 F(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution509</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution509</span>().fib(<span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划：</span></span><br><span class="line"><span class="comment">     *    自底向上构建一个数组，数组中保存着每个 F(n) 的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 0~n 共有 n+1 个元素，length 设为 n+2 是为了满足初始条件。</span></span><br><span class="line">        <span class="comment">// 即 f(0)=0 和 f(1)=1 是初始状态，数组的最小长度为 2</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建一个保存了从 f(0) 到 f(n) 的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="977-有序数组的平方（双指针）"><a href="#977-有序数组的平方（双指针）" class="headerlink" title="977. 有序数组的平方（双指针）"></a>977. 有序数组的平方（双指针）</h1><blockquote>
<p>  <strong>题目</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
</blockquote>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.cursor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/26 9:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 977. 有序数组的平方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> *      给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</span></span><br><span class="line"><span class="comment"> *      【非递减顺序 = 递增顺序】</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> *      难点在于如何让新数组也按非递减顺序排列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路一：暴力解法，先计算出所有数字的平方，再进行排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution977</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;-<span class="number">4</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] squares = <span class="keyword">new</span> <span class="title class_">Solution977</span>().sortedSquares(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> square : squares) &#123;</span><br><span class="line">            System.out.println(square);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(squares);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力解法：</span></span><br><span class="line"><span class="comment">     *  1、计算出 nums 数组中每个元素的平方，保存到一个新的数组中；</span></span><br><span class="line"><span class="comment">     *  2、对新数组按非递减顺序排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  -- 毋庸置疑，虽然通过了，但时间复杂度很高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 1、计算出 nums 数组中每个元素的平方，保存到一个 sq 数组中；</span></span><br><span class="line">        <span class="type">int</span>[] sq = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sq[i] = nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、对 sq 数组排序</span></span><br><span class="line">        Arrays.sort(sq);</span><br><span class="line">        <span class="keyword">return</span> sq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="双指针-归并排序"><a href="#双指针-归并排序" class="headerlink" title="双指针 + 归并排序"></a>双指针 + 归并排序</h3><blockquote>
<p>  <strong>思路</strong></p>
</blockquote>
<p>暴力解法没有利用【数组 <code>nums</code> 已经按照升序排列】这个条件。显然，</p>
<ul>
<li>  如果数组 <code>nums</code> 中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；</li>
<li>  如果数组 <code>nums</code> 中的所有数都是负数，那么将每个数平方后，数组会保持降序。</li>
</ul>
<p>这样一来，如果我们能够<strong>找到升序数组 <code>nums</code> 中负数与非负数的分界线</strong>，那么就可以用类似<strong>「归并排序」</strong>的方法了。</p>
<p>​        具体地，我们设 <strong>neg</strong> 为数组 nums 中负数与非负数的分界线。也就是说，<code>nums[0] ~ nums[neg]</code> 均为负数，而 <code>nums[neg+1] ~ nums[n−1]</code> 均为非负数。当我们将数组 nums 中的数平方后，那么 <code>nums[0] ~ nums[neg]</code> 单调递减，<code>nums[neg+1] ~ nums[n−1]</code> 单调递增。 </p>
<p>​        由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置  <code>neg</code> 和 <code>neg+1</code>，每次比较两个指针对应的数，选择较小的那个放入答案数组并移动指针。<strong>当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。</strong></p>
<p>示例一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-<span class="number">4</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、首先取到正数和负数的分界点 neg;</span><br><span class="line"><span class="number">2</span>、构建一个 nums 数组的平方数组 sq；可以看到neg右边数组升序，neg右边数组降序;</span><br><span class="line"><span class="number">3</span>、用两个指针left和right分别进行正序和倒序遍历，每次取出较小的值放入新的数组中！！！</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/25/LeetCode/977%E5%8F%8C%E6%8C%87%E9%92%88.png" alt="977双指针"></p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 归并排序 + 双指针 解法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  1、找到正数与负数的分隔点，</span></span><br><span class="line"><span class="comment">    *  2、由于nums数组是升序的，所以求平方之后，分隔点之前的数降序排列，分隔点之后的数升序排列</span></span><br><span class="line"><span class="comment">    *  3、进行归并排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="comment">// 1、找到正数与负数的分隔点。(0,neg)&lt;0； [neg, length)&gt;=0</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">               neg = i;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果整个数组全为负数，就将 length 设置为分界点</span></span><br><span class="line">           neg = nums.length;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、构建 nums 的平方数组 sq</span></span><br><span class="line">       <span class="type">int</span>[] sq = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           sq[i] = nums[i]*nums[i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、进行归并排序【双指针】【可以利用之前的 nums 数组，该数组现在没有用了，这里为了方便理解新建了数组】</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> neg-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> neg;</span><br><span class="line">       <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 结果值数组的指针</span></span><br><span class="line">       <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">while</span> (left&gt;=<span class="number">0</span> &amp;&amp; right&lt;sq.length)&#123;</span><br><span class="line">           <span class="keyword">if</span> (sq[left] &lt; sq[right])&#123;</span><br><span class="line">               res[t++] = sq[left--];</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               res[t++] = sq[right++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (left &lt; <span class="number">0</span> &amp;&amp; right &lt; sq.length)&#123;   <span class="comment">// 将右边剩余的元素全部追加到res数组中</span></span><br><span class="line">           res[t++] = sq[right++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (right &gt; nums.length-<span class="number">1</span> &amp;&amp; left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">           res[t++] = sq[left--];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h1 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h1><blockquote>
<p>  <strong>题目</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></p>
</blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5,4,4], nums2 = [9,4,9,8,4,6]</span><br><span class="line">输出：[9,4,4]</span><br></pre></td></tr></table></figure>



<h2 id="HashMap-解法"><a href="#HashMap-解法" class="headerlink" title="HashMap 解法"></a>HashMap 解法</h2><p><img src="/2021/07/25/LeetCode/350%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.png" alt="350两个数组的交集"></p>
<p><strong>思路：</strong></p>
<ol>
<li><p> 分别为两个数组 nums1 和 nums2 建立各自对应的 HashMap map1 和 map2，其中 key 为数组中出现过的值，value 为数组中 key 值出现过的次数。</p>
</li>
<li><p>数组的交集为：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map1&#123;4,3&#125; ∩ map2&#123;4,2&#125; ==&gt; &#123;4,2&#125;</span><br><span class="line">map1&#123;9,1&#125; ∩ map2&#123;9,2&#125; ==&gt; &#123;9,1&#125;</span><br><span class="line">map1&#123;5,1&#125; ∩ map2&#123;null&#125; ==&gt; null</span><br><span class="line">map1&#123;null&#125; ∩ map2&#123;8,1&#125; ==&gt; null</span><br><span class="line">map1&#123;null&#125; ∩ map2&#123;6,1&#125; ==&gt; null</span><br></pre></td></tr></table></figure></li>
<li><p> 所以得到的最终结果是：<code>[4,4,9]</code></p>
</li>
</ol>
<p><strong>代码思路：</strong></p>
<p><img src="/2021/07/25/LeetCode/350_fig1.gif" alt="fig1"></p>
<ol>
<li> 建立起 nums1 的 hashMap 表；</li>
<li> 遍历 nums2 ，每发现一个元素在 hashMap 中存在，代表这就是 nums1 和 nums2 的交集部分，将该元素保存到 result 数组中，将 hashMap 中对应的元素个数减一。 </li>
<li> 这样最后得到的 result 数组就是 nums1 和 nums2 的交集。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.shuzu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/27 10:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定两个数组，编写一个函数来计算它们的交集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      输入：nums1 = [1,2,2,1], nums2 = [2,2]</span></span><br><span class="line"><span class="comment"> *      输出：[2,2]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span></span><br><span class="line"><span class="comment"> *      输出：[4,9]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  思路一：暴力解法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  思路二：HashTable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution350</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums1 = &#123;<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] nums2 = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">Solution350</span>().intersect(nums1, nums2);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashTable 解法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个数组，用于保存交集的数组</span></span><br><span class="line">        <span class="type">int</span>[] res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &lt; nums2.length)&#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、建立 nums1 的 HashMap</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map1.containsKey(nums1[i]))&#123;</span><br><span class="line">                map1.put(nums1[i], <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map1.containsKey(nums1[i]))&#123;</span><br><span class="line">                map1.put(nums1[i], map1.get(nums1[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、遍历 nums2，与 map1 进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 存在重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (map1.containsKey(nums2[j]))&#123;</span><br><span class="line">                <span class="keyword">if</span> (map1.get(nums2[j]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 输出到结果数组中</span></span><br><span class="line">                    res[t] = nums2[j];</span><br><span class="line">                    ++t;</span><br><span class="line">                    <span class="comment">// 更新 map</span></span><br><span class="line">                    <span class="keyword">if</span> (map1.get(nums2[j])-<span class="number">1</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        map1.put(nums2[j], map1.get(nums2[j])-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 小于等于0</span></span><br><span class="line">                        map1.remove(nums2[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、仅截取需要的那一段</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h2><p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p>
<ol>
<li> 首先对两个数组进行排序，然后使用两个指针遍历两个数组。</li>
<li> 初始时，两个指针分别指向两个数组的头部。</li>
<li> 每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。</li>
<li> 当至少有一个指针超出数组范围时，遍历结束。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  双指针解法</span></span><br><span class="line"><span class="comment">    * 1.  首先对两个数组进行排序，然后使用两个指针遍历两个数组。</span></span><br><span class="line"><span class="comment">    * 2.  初始时，两个指针分别指向两个数组的头部。</span></span><br><span class="line"><span class="comment">    * 3.  每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，</span></span><br><span class="line"><span class="comment">    *     如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。</span></span><br><span class="line"><span class="comment">    * 4.  当至少有一个指针超出数组范围时，遍历结束。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">       <span class="comment">// 0、创建一个数组，用于保存交集的数组</span></span><br><span class="line">       <span class="type">int</span>[] res;</span><br><span class="line">       <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nums1.length &lt; nums2.length)&#123;</span><br><span class="line">           res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           res = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1、对两个数组进行排序</span></span><br><span class="line">       Arrays.sort(nums1);</span><br><span class="line">       Arrays.sort(nums2);</span><br><span class="line">       <span class="comment">// 2、初始化两个指针</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 3、遍历比较</span></span><br><span class="line">       <span class="keyword">while</span>(i&lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">           <span class="comment">// 如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。</span></span><br><span class="line">           <span class="keyword">if</span> (nums1[i] == nums2[j])&#123;</span><br><span class="line">               res[t] = nums1[i];</span><br><span class="line">               i++;</span><br><span class="line">               j++;</span><br><span class="line">               t++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果两个数字不相等，则将指向较小数字的指针右移一位，</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4、当至少有一个指针超出数组范围时，遍历结束。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5、仅截取需要的那一段</span></span><br><span class="line">       <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/25/%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-25 12:48:34" itemprop="dateCreated datePublished" datetime="2021-07-25T12:48:34+08:00">2021-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-02 23:39:02" itemprop="dateModified" datetime="2021-10-02T23:39:02+08:00">2021-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<ul>
<li>  分治算法</li>
<li>  动态规划算法</li>
</ul>
</blockquote>
<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="分治算法介绍"><a href="#分治算法介绍" class="headerlink" title="分治算法介绍"></a>分治算法介绍</h2><p>​        分治法是一种很重要的算法，顾名思义就是“分而治之”，即把一个复杂的问题分解成两个或更多相同或相似的子问题，再继续把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<p>​        分治思想是很多高效算法的基础，如排序算法（快速排序、归并排序），傅立叶变换（快速傅立叶变换）等。</p>
<h2 id="分治算法的基本步骤"><a href="#分治算法的基本步骤" class="headerlink" title="分治算法的基本步骤"></a>分治算法的基本步骤</h2><p>分治法在每一层递归上都有三个步骤：</p>
<ol>
<li> <strong>分解</strong>：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
<li> <strong>解决</strong>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；</li>
<li> <strong>合并</strong>：将各个子问题的解合并为原问题的解。</li>
</ol>
<p>分治（Divide-and-Conquer）算法的设计模式如下<strong>：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> |P| ≤ n0</span><br><span class="line">    then <span class="title function_">return</span><span class="params">(ADHOC(P))</span></span><br><span class="line">    <span class="comment">//将P分解为较小的子问题 P1 ,P2 ,…,Pk</span></span><br><span class="line">    <span class="keyword">for</span> i←1 to k</span><br><span class="line">        <span class="keyword">do</span> yi ← Divide-and-<span class="title function_">Conquer</span><span class="params">(Pi)</span>   递归解决Pi</span><br><span class="line">            T ← <span class="title function_">MERGE</span><span class="params">(y1,y2,…,yk)</span>   合并子问题</span><br><span class="line">            <span class="title function_">return</span><span class="params">(T)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  其中 <code>|P|</code> 表示问题 P 的规模；<code>n0</code> 是一个阈值，表示当问题 <code>P</code> 的规模不超过 <code>n0</code> 时，问题已容易直接解出，不必再继续分解；</li>
<li>  <code>ADHOC(P)</code> 是该分治法中的基本子算法，用于直接解决小规模的问题 <code>P</code>。因此，当 <code>P</code> 的规模不超过 <code>n0</code> 时直接用算法 <code>ADHOC(P)</code> 求解。</li>
<li>  算法 <code>MERGE(y1,y2,…,yk)</code> 是该分治法中的合并子算法，用于将 <code>P</code> 的子问题 <code>P1 ,P2 ,…,Pk</code> 的相应的解 <code>y1,y2,…,yk</code> 合并为 <code>P</code> 的解。</li>
</ul>
<h2 id="分治算法可以求解的一些经典问题"><a href="#分治算法可以求解的一些经典问题" class="headerlink" title="分治算法可以求解的一些经典问题"></a>分治算法可以求解的一些经典问题</h2><ul>
<li>  二分查找</li>
<li>  大整数乘法</li>
<li>  棋盘覆盖</li>
<li>  合并排序</li>
<li>  快速排序</li>
<li>  线性时间选择</li>
<li>  最接近点对问题</li>
<li>  循环赛日程表</li>
<li>  汉诺塔</li>
</ul>
<hr>
<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p><img src="/2021/07/25/%E7%AE%97%E6%B3%95/image-20210725192445350.png" alt="image-20210725192445350"></p>
<p><strong>要求：</strong></p>
<ul>
<li>  将A塔的所有圆盘移动到C塔；</li>
<li>  规定小圆盘上不能放大圆盘；</li>
<li>  在三根柱子之间一次只能移动一个圆盘。</li>
</ul>
<p><strong>分析</strong></p>
<ol>
<li> 如果只有一个盘，<code>A-&gt;C</code></li>
<li>如果有 2 个盘：<ul>
<li>  <code>A上-&gt;B</code></li>
<li>  <code>A下-&gt;C</code></li>
<li>  <code>B-&gt;C</code></li>
</ul>
</li>
<li>如果有 n（n&gt;=2）个盘，可以把整座塔视为两部分，即下层的一个盘和上层的 (n-1) 个盘。思路也非常简单，就是:<ul>
<li>  <code>A上 -&gt; B</code></li>
<li>  <code>A下 -&gt; C</code></li>
<li>  <code>B -&gt; C</code></li>
</ul>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.dac;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 19:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 汉诺塔游戏 --&gt;&gt; 分治算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      * 1.  如果只有一个盘，A-&gt;C</span></span><br><span class="line"><span class="comment"> *      * 2.  如果有 2 个盘：</span></span><br><span class="line"><span class="comment"> *      *     -   A上-&gt;B</span></span><br><span class="line"><span class="comment"> *      *     -   A下-&gt;C</span></span><br><span class="line"><span class="comment"> *      *     -   B-&gt;C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanoiTower</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        hanoiTower(<span class="number">5</span>,<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  该方法用于将 A塔上的所有圆盘转移到 C塔上</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num   总共有多少个盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A A塔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B B塔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> C C塔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoiTower</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C)</span>&#123;</span><br><span class="line">        <span class="comment">/* 如果只有一个圆盘， A-&gt;C */</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(A + <span class="string">&quot;-&gt;&quot;</span> + C);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果有2个以上的盘，A上-&gt;B A下-&gt;C B-&gt;C*/</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// A上(num-1)-&gt;B</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>, A, C, B);</span><br><span class="line">            <span class="comment">// A下(1)—&gt;C</span></span><br><span class="line">            System.out.println(A + <span class="string">&quot;-&gt;&quot;</span> + C);</span><br><span class="line">            <span class="comment">// B(全部)-&gt;C</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>, B, A, C); <span class="comment">// 只看第2个和第4个参数就能确定源头塔和目标塔</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>动态规划的基础就是穷举</strong></p>
<p>用于计算最大/小值，最优解等</p>
<p>动态规划是一个自底向上的类递归算法。</p>
<p><strong>动态规划就是 【选/不选】 的问题！！！</strong></p>
<h2 id="最优解问题"><a href="#最优解问题" class="headerlink" title="最优解问题"></a>最优解问题</h2><p>我们通过一个实际问题来学习动态规划。</p>
<blockquote>
<p>  <strong>题目：</strong></p>
</blockquote>
<p>下图共有 7 项任务，横轴表示每项任务的工作时间，红字表示完成每项任务可以得到的报酬。比如任务一需要在 <code>1~4</code> 时间段进行，任务二需要在 <code>3~5</code> 时间段进行。也就是说想要完成任务一就必须放弃任务二、三、五，因为这几个任务的时间段冲突了。现在的问题是想知道从 0~11 时间段内最高报酬的任务组合是什么。</p>
<img src="/2021/07/25/%E7%AE%97%E6%B3%95/image-20210727171453446.png" alt="image-20210727171453446" style="zoom:50%;">



<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<p><strong>动态规划就是【选/不选】的问题！！！</strong></p>
<p>我们用 <strong>OPT(i)</strong> 函数表示包含第 i 个任务的情况下报酬最高的任务组合。【OPT：最优解】</p>
<p>比如选了任务 ⑧，肯定就不能再选任务 ⑥ 和 ⑦ 了。这时就会存在两种情况，到底是选择任务 ⑧ 后得到的总薪资最高还是不选任务⑧得到的总薪资最高呢？这就是 【选/不选】的问题。<br>$$<br>OPT(8) = max<br>    \begin{cases}<br>        V_8+OPT(5)    &amp;\text{// 选⑧就要放弃⑥和⑦}<br>    \\<br>        OPT(7)    &amp;\text{//不选⑧就相当于放弃⑧}<br>    \end{cases}<br>$$</p>
<blockquote>
<p>  <strong>公式：</strong></p>
</blockquote>
<p>以此类推，可以得到一个公式，<br>$$<br>OPT(i) = max<br>    \begin{cases}<br>        V_i+OPT(prev(i))    &amp;\text{// prev(i)表示在选择了第i个任务后剩余任务中的最优解下标}<br>    \\<br>        OPT(i-1)    &amp;\text{//不选}<br>    \end{cases}<br>$$</p>
<ol>
<li><p>建立 <strong>V<del>i</del> 表</strong>与 <strong>prev(i) 表</strong>如下：</p>
<ul>
<li><p>  <strong>V<del>i</del></strong> 表示第 i 个任务的薪资；</p>
</li>
<li><p><strong>prev(i)</strong> 表示选择第 i 个任务后，剩下任务中的最优解下标。</p>
<table>
<thead>
<tr>
<th align="center">i</th>
<th align="center">V<del>i</del></th>
<th align="center">prev(i)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>1</code></td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>2</code></td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>3</code></td>
<td align="center">8</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>4</code></td>
<td align="center">4</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>5</code></td>
<td align="center">6</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>6</code></td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>7</code></td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><code>8</code></td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>建立 OPT(i) 最优解的树形结构【递归思路】。</p>
<p> <img src="/2021/07/25/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="动态规划"></p>
<ul>
<li>  我们可以看到，在递归【自顶向下】的过程中，我们会多次用到已经计算过的 OPT(i) 的值，如果能够将已计算过的值保存起来，在需要使用的时候直接调用，就可以节省很大的计算性能。</li>
<li>  所以可以采用动态规划的算法，【自底向上】建立一个动态规划的数组，保存从 <code>OPT(0)~OPT(n)</code> 的所有值。</li>
</ul>
</li>
<li><p>建立动态规划数组。</p>
<table>
<thead>
<tr>
<th align="center">OPT(0)</th>
<th align="center">OPT(1)</th>
<th align="center">OPT(2)</th>
<th align="center">OPT(3)</th>
<th align="center">OPT(4)</th>
<th align="center">OPT(5)</th>
<th align="center">OPT(6)</th>
<th align="center">OPT(7)</th>
<th align="center">OPT(8)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">10</td>
<td align="center">13</td>
</tr>
</tbody></table>
</li>
</ol>
<p><img src="/2021/07/25/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E6%9C%80%E9%AB%98%E8%96%AA%E8%B5%84%E7%BB%84%E5%90%88.png" alt="动态规划_最高薪资组合"></p>
<hr>
<h2 id="动态规划算法介绍"><a href="#动态规划算法介绍" class="headerlink" title="动态规划算法介绍"></a>动态规划算法介绍</h2><ol>
<li> <strong>动态规划（Dynamic Programming）</strong>算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法。</li>
<li> 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li> 与分治法不同的是，<strong>适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。</strong>即下一个子问题的求解是建立在上一个子问题解的基础上得到的。</li>
<li> 动态规划可以通过<strong>填表的方式</strong>来逐步推进，得到最优解.</li>
</ol>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>给定一个固定容量的背包，若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。</p>
<p><strong>需求：</strong></p>
<p>有一个背包，容量为 4 磅，现有如下物品：</p>
<ul>
<li>  要求装入的背包的<u>总价值最大</u>，并且<u>重量不超出</u>。</li>
<li>  要求<u>装入的物品不能重复</u>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>物品</strong></th>
<th align="center"><strong>重量</strong></th>
<th align="center"><strong>价格</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">吉他(G)</td>
<td align="center">1</td>
<td align="center">1500</td>
</tr>
<tr>
<td align="center">音响(S)</td>
<td align="center">4</td>
<td align="center">3000</td>
</tr>
<tr>
<td align="center">电脑(L)</td>
<td align="center">3</td>
<td align="center">2000</td>
</tr>
</tbody></table>
<p><strong>背包问题分类：</strong></p>
<p>背包可分为 <strong>01背包</strong> 和 <strong>完全背包</strong>：</p>
<ul>
<li>  01 背包：同类物品只能放入一件，背包的物品种类不能重复。</li>
<li>  完全背包：每类物品可以放入多件到背包中。</li>
</ul>
<p><strong>思路分析：</strong></p>
<p>这里的问题属于 <strong>01背包</strong>，即每种物品最多放一件。【无限背包可以转化为01背包解决】</p>
<ul>
<li>  给定的 n 个物品，每次遍历到的第 i 个物品，根据 <code>w[i]</code> 和 <code>v[i]</code> 来确定是否需要将该物品放入背包中。</li>
<li>  设 <code>v[i]</code>、<code>w[i]</code> 分别为第 <code>i</code> 个物品的价值和重量，<code>C</code> 为背包的容量。</li>
<li>再令 <code>v[i][j]</code> 表示在前 <code>i</code> 个物品中能够装入容量为 <code>j</code> 的背包中的最大价值。则我们有下面的结果：<ol>
<li> <code>vi=v0=0</code>，表示填入表第一行和第一列是 0</li>
<li> 当 <code>w[i]&gt; j</code> 时 <code>vi=vi-1</code>，当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</li>
<li> 当 <code>j&gt;=w[i]</code> 时，<code>vi=max&#123;vi-1, v[i]+vi-1]&#125;</code> </li>
</ol>
</li>
</ul>
<p>// 当 准备加入的新增的商品的容量小于等于当前背包的容量,</p>
<p>// 装入的方式:</p>
<p>v[i-1][j]： 就是上一个单元格的装入的最大值</p>
<p>v[i] : 表示当前商品的价值 </p>
<p>v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值</p>
<p>当j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} :</p>
<p>w[i]：第 i 个物品的重量</p>
<p>v[i]：第  i 件物品的价值</p>
<h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、确定dp数组以及下标的含义</span><br><span class="line">2、确定动态转移方程</span><br><span class="line">3、dp数组如何初始化</span><br><span class="line">4、确定遍历顺序</span><br><span class="line">5、举例推导dp数组</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
