<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-02 22:19:15" itemprop="dateCreated datePublished" datetime="2021-08-02T22:19:15+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 09:22:58" itemprop="dateModified" datetime="2021-08-03T09:22:58+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>排序算法稳定性小结：</strong></p>
</blockquote>
<p><strong>快些选一堆</strong>是不稳定的排序算法，其它都是稳定的！</p>
<ul>
<li>  快排</li>
<li>  希尔</li>
<li>  选择</li>
<li>  堆排</li>
</ul>
<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li> 选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</li>
<li> 从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。</li>
<li>找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的<br> 值才交换。</li>
<li> 直到 <strong>从前往后的比较索引&gt;从后往前比较的索引</strong>，结束第一次循环。</li>
<li> 此时，对于基准值来说，左边都比基准值小，右边都比基准值大，这个基准值就到达排序的最终位置了。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">注解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-02 19:18:11 / Modified: 20:37:52" itemprop="dateCreated datePublished" datetime="2021-08-02T19:18:11+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java<code>注解(Annotation)</code>又称为<code>元数据</code>。</p>
<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><blockquote>
<p><code>元注解</code>就是用来标志注解的注解。</p>
</blockquote>
<ol>
<li><p><code>@Retention</code></p>
<p> 标识如何存储，是只在代码中，还是编入class文件中，或者在运行阶段可以通过反射访问。</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：注解只保留在源文件，当Java被编译成<code>.class</code>文件后，注解被遗弃。</li>
<li><code>RetentionPolicy.CLASS</code>：注解被保留到<code>.class</code>文件，但当JVM将<code>.class</code>文件加载到内存中时，注解被遗弃。<strong>这是缺省值</strong>。</li>
<li><code>RetentionPolicy.RUNTIME</code>：注解不仅被保存到<code>.class</code>文件，而且JVM加载<code>.class</code>文件后依然存在。</li>
</ul>
</li>
<li><p><code>@Documented</code>：</p>
<p> 标记这些注解是否保存在JavaDoc中。</p>
</li>
<li><p><code>@Target</code>：</p>
<p> 标记这个注解可以修饰的范围。<code>Annotation</code>的修饰范围：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span>&#123;</span><br><span class="line">    TYPE,</span><br><span class="line">    FIELD,</span><br><span class="line">    METHOD,</span><br><span class="line">    PARAMETER,</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    PACKAGE,</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    TYPE_USE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Inherited</code>：</p>
<p> 标记这个注解是继承于哪个<strong>注解类</strong>的。</p>
<blockquote>
<p>注解是不支持继承的。</p>
</blockquote>
</li>
<li><p><code>@SafeVarargs</code>：</p>
<p> 在声明可变参数的构造函数或方法时，Java编译器会包<code>unchecked</code>警告，使用该注解可忽略这些警告。</p>
</li>
<li><p><code>@FunctionalInterface</code>：</p>
<p> 标识这个方法是一个函数式接口</p>
</li>
<li><p><code>@Repeatable</code>：</p>
<p> 标识某注解可以在同一个声明上使用多次。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%9E%9A%E4%B8%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%9E%9A%E4%B8%BE/" class="post-title-link" itemprop="url">枚举</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-02 18:42:10 / Modified: 19:17:41" itemprop="dateCreated datePublished" datetime="2021-08-02T18:42:10+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><ul>
<li>  Java中，被 <strong>enum</strong> 关键字修饰的类型就是枚举类型。</li>
<li>  枚举类型是一种特殊的数据类型。它是一种与 Class、Interface、Annotation 平级的数据类型。</li>
<li>  <strong>枚举是指具有固定实例个数的类</strong>。普通的类可以根据需求创建任意多个实例，但是在枚举中实例的个数是有限制的。</li>
<li>  枚举虽然<strong>有构造函数</strong>，但其构造函数默认都是私有的，所以只能在当前类中使用<code>new</code>关键字创建对象。</li>
<li>  <strong>当需要定义一组常量时，强烈建议使用枚举类。</strong></li>
<li>  <strong>如果枚举类中只一个对象，则可以作为一种单例模式的实现方式。</strong></li>
<li>  <code>枚举类型(enum)</code>、<code>类(Class)</code>、<code>接口(Interface)</code>、<code>注解类(Annotation)</code>处于同一级。</li>
<li>  注解类不是注解，注解类的作用是定义注解的业务逻辑</li>
</ul>
<p><img src="/2021/08/02/%E6%9E%9A%E4%B8%BE/image-20201026191110428.png" alt="image-20201026191110428"></p>
<hr>
<h1 id="如何定义枚举类"><a href="#如何定义枚举类" class="headerlink" title="如何定义枚举类"></a>如何定义枚举类</h1><blockquote>
<p>  <strong>Before：没有枚举类之前，定义一组常量的方式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeekDemo</span>&#123;</span><br><span class="line">	<span class="comment">// 一组常量，表示周一到周日</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> MONDAY=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> TUESDAY=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> WEDNESDAY=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> THURSDAY=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> FRIDAY=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> SATURDAY=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> SUNDAY=<span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>After：利用枚举重新定义：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumWeekDemo</span> &#123;</span><br><span class="line">    MONDAY,</span><br><span class="line">    Tuesday,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY,</span><br><span class="line">    SUNDAY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="枚举的实现原理"><a href="#枚举的实现原理" class="headerlink" title="枚举的实现原理"></a>枚举的实现原理</h1><ol>
<li> 我们使用关键字 <code>enum</code> 定义枚举类，这个类在编译后，编译器会为我们生成一个相关的 class 类，也就是说枚举类型在编译后也是一个 class 类型，而且类继承自 <strong>java.lang.Enum</strong>。</li>
<li> 上文中的代码在加载到内存中后，会生成<strong>一个 Class 对象</strong>：<strong>EnumWeekDemo</strong>；</li>
<li> 除此之外，还会生成 <strong>7 个 EnumWeekDemo 类的实例对象</strong>，分别对应枚举类中定义的7个日期；</li>
</ol>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<ul>
<li>  枚举类表示有固定实例个数的类，这些实例就是根据自身枚举类创建的实例对象，具体有多个个实例根据你在枚举类中写了多少个就有多少个。</li>
<li>  枚举类中的每个实例对象是 <strong>public static final</strong> 的，即可以通过类名直接访问，且不可变，可用于存储常量对象。</li>
</ul>
<hr>
<h1 id="枚举类中常用的静态方法"><a href="#枚举类中常用的静态方法" class="headerlink" title="枚举类中常用的静态方法"></a>枚举类中常用的静态方法</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>values()</code></td>
<td align="center">获取枚举中的所有变量，并作为数组返回</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>valueOf(String name)</code></td>
<td align="center">根据名称获取枚举变量</td>
</tr>
</tbody></table>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h2 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h2><p>模拟枚举类的内部实现，即不适用 enum 关键字实现与枚举类型相同的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明Season对象的属性: private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.私化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.其他诉求2：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-enum"><a href="#使用-enum" class="headerlink" title="使用 enum"></a>使用 enum</h2><p>JDK 5 中新增了 enum 用于定义枚举类。</p>
<blockquote>
<p>  <strong>使用 enum 关键字的枚举类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的实例对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.私化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="枚举类常用方法（继承于java-lang-Enum类）"><a href="#枚举类常用方法（继承于java-lang-Enum类）" class="headerlink" title="枚举类常用方法（继承于java.lang.Enum类）"></a>枚举类常用方法（继承于java.lang.Enum类）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line">    <span class="comment">// toString():返回枚举类对象的名称（枚举类默认继承的Enum类中重写了toString方法，这里可以直接调用）</span></span><br><span class="line">    System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line">    System.out.println(Season1.class.getSuperclass());</span><br><span class="line">    System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// values():返回所的枚举类对象构成的数组</span></span><br><span class="line">    Season1[] values = Season1.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        System.out.println(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line">    <span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line">    System.out.println(winter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="如何让枚举类对象实现接口"><a href="#如何让枚举类对象实现接口" class="headerlink" title="如何让枚举类对象实现接口"></a>如何让枚举类对象实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">泛型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-02 16:33:49 / Modified: 18:32:18" itemprop="dateCreated datePublished" datetime="2021-08-02T16:33:49+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="泛型的引入背景"><a href="#泛型的引入背景" class="headerlink" title="泛型的引入背景"></a>泛型的引入背景</h1><blockquote>
<p>  <strong>JDK5 之前</strong></p>
</blockquote>
<p>​        集合类在设计阶段阶段不能确定这个集合到底实际存的是什么类型的对象，所以在 JDK5 之前只能把元素类型设计为 Object，如果我们对集合不做任何限定，它就可以存储任何类型的对象。如果一个集合中存储了多种数据类型的元素，那么在编译后这些元素都会向上转型为Object类型。这样的话，当我们取出任一元素想执行其特有的方法时，就必须采用向下转型。然而由于集合中元素的数据类型不同，所以没有一个统一的标准可以一次性将集合中的所有元素向下转型。</p>
<blockquote>
<p>  <strong>从 JDK5 开始</strong></p>
</blockquote>
<p>​        在JDK1.5++，新增了<strong>泛型（Generic）</strong>语法。让你在设计 API 时可以指定类或方法支持泛型，这样我们使用API时也变得更为简洁，并得到了编译时期的语法检查。</p>
<p>​        JDK5 之后使用泛型来解决这个问题。因为这个时候除了元素的类型不确定，其它的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此<strong>此时把元素的类型设计成一个参数</strong>，这个类型参数叫做<strong>泛型</strong>。</p>
<h1 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h1><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<ul>
<li>  <strong>泛型</strong>：可以在<strong>类中或方法</strong>中预支的使用未知的类型。</li>
<li>  所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时确定。比如：①继承或实现这个接口时；  ②创建对象时；  ③传入实际的类型参数时，也称为类型实参；</li>
<li>  <strong>泛型的使用</strong>：定义时不指定数据类型，使用时再指定数据类型。</li>
</ul>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<ol>
<li> <strong>泛型是在定义时使用的；</strong></li>
<li> 使用时才指定泛型的具体类型；</li>
<li> <strong>当没有指定泛型时，默认类型为 Object 类型。</strong></li>
<li> Collection虽然可以存储不同类型的对象，但实际使用时我们建议一般只存储同一类型的对象。</li>
</ol>
<hr>
<h1 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h1><ol>
<li>将运行时期的<code>ClassCastException</code>，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ol>
<hr>
<h1 id="泛型在集合中的使用"><a href="#泛型在集合中的使用" class="headerlink" title="泛型在集合中的使用"></a>泛型在集合中的使用</h1><h2 id="JDK5-之前"><a href="#JDK5-之前" class="headerlink" title="JDK5 之前"></a>JDK5 之前</h2><blockquote>
<p>  <strong>存在的问题：</strong></p>
</blockquote>
<ol>
<li> 类型不安全</li>
<li> 强转时，可能出现 ClassCastException</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// 需求：存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">76</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题一：类型不安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">        <span class="comment">// 问题二：强转时，可能出现ClassCastException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/02/%E6%B3%9B%E5%9E%8B/image-20210802165130946.png" alt="image-20210802165130946"></p>
<hr>
<h2 id="JDK5-之后"><a href="#JDK5-之后" class="headerlink" title="JDK5 之后"></a>JDK5 之后</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">87</span>);</span><br><span class="line">    list.add(<span class="number">99</span>);</span><br><span class="line">    <span class="comment">// 编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);	// 发生编译时异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//        for(Integer score : list)&#123;</span></span><br><span class="line"><span class="comment">//            //避免了强转操作</span></span><br><span class="line"><span class="comment">//            int stuScore = score;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            System.out.println(stuScore);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二：</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/02/%E6%B3%9B%E5%9E%8B/image-20210802165301817.png" alt="image-20210802165301817"></p>
<h2 id="JDK7-新特性：类型推断"><a href="#JDK7-新特性：类型推断" class="headerlink" title="JDK7 新特性：类型推断"></a>JDK7 新特性：类型推断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以HashMap为例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();	// JDK7之前</span></span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();	<span class="comment">// jdk7新特性：类型推断</span></span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">67</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型的嵌套</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="集合中使用泛型总结"><a href="#集合中使用泛型总结" class="headerlink" title="集合中使用泛型总结"></a>集合中使用泛型总结</h2><ul>
<li><p>  集合接口或集合类从 JDK5 开始都修改为带泛型的结构。</p>
</li>
<li><p>  在实例化集合类时，可以指明具体的泛型类型。</p>
</li>
<li><p>指明完以后，在集合类或接口中凡是使用到泛型的位置，都会转换为具体的数据类型。</p>
<p>  比如：add(E e)  —&gt; 实例化以后：add(Integer e)</p>
</li>
<li><p>  注意点：<strong>泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型时，拿包装类替换</strong>。</p>
</li>
<li><p>  <strong>如果实例化时，没指明泛型的类型。默认类型为 <code>java.lang.Object</code> 类型。</strong></p>
</li>
</ul>
<hr>
<h1 id="泛型的语法（自定义泛型类、泛型接口、泛型方法）"><a href="#泛型的语法（自定义泛型类、泛型接口、泛型方法）" class="headerlink" title="泛型的语法（自定义泛型类、泛型接口、泛型方法）"></a>泛型的语法（自定义泛型类、泛型接口、泛型方法）</h1><h2 id="1-定义和使用带泛型的类"><a href="#1-定义和使用带泛型的类" class="headerlink" title="1    定义和使用带泛型的类"></a>1    定义和使用带泛型的类</h2><blockquote>
<p>  <strong>定义：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>使用：</strong>（== 什么时候确定泛型）</p>
</blockquote>
<p>定义类的时候，只是表明了该类将会使用泛型，但<strong>具体的泛型类型，是在创建实例对象的时候指定的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义带泛型的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArratList</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用：创建对象时，根据创建对象时指定的泛型不同，集合中保存数据的类型也不同。但是class类只有一个。</span></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>





<h2 id="2-定义和使用含有泛型的接口"><a href="#2-定义和使用含有泛型的接口" class="headerlink" title="2    定义和使用含有泛型的接口"></a>2    定义和使用含有泛型的接口</h2><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>使用：</strong></p>
</blockquote>
<ol>
<li> <strong>定义实现类(子类)时确定泛型的类型</strong>。</li>
<li> <strong>始终不缺定泛型的类型，直到创建对象时，才确定泛型的类型</strong>。</li>
</ol>
<ul>
<li>  <strong>接口A</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&lt;T&gt;&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用：</span></span><br><span class="line"><span class="comment">      1. 定义实现类时确定泛型的类型</span></span><br><span class="line"><span class="comment">      2. 始终不缺定泛型的类型，直到创建对象时，才确定泛型的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> Class C&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">A</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">psvm&#123;</span><br><span class="line">    C&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">C</span>&lt;Integer&gt;();    <span class="comment">// 直到创建对象时，才确定泛型的类型为Integer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  定义实现类 B 的时候确定泛型的类型：此时 <code>class B</code> 就不再是泛型类了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&lt;Integer&gt;&#123; <span class="comment">// 此时，泛型E的值就是Integer，类 B 就不是泛型类了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  直到创建对象 C 时，才确定泛型的类型：此时 <code>class C</code> 仍然是泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">A</span>&lt;T&gt;&#123;  <span class="comment">// 在实现类的定义阶段并没有确定泛型的类型， class C 仍然是泛型类</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        C&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">C</span>&lt;&gt;();   <span class="comment">// 直到创建对象时，才确定泛型的类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-定义和使用带泛型的方法"><a href="#3-定义和使用带泛型的方法" class="headerlink" title="3    定义和使用带泛型的方法"></a>3    定义和使用带泛型的方法</h2><blockquote>
<p>  <strong>定义：</strong></p>
</blockquote>
<ul>
<li>  泛型方法：在方法中出现了泛型结构的方法就叫做泛型方法。</li>
<li>  <strong>泛型参数与类的泛型参数没任何关系。</strong></li>
<li>  换句话说就是，<strong>泛型方法所属的类是不是泛型类都没关系</strong>。</li>
<li>  泛型方法，可以是一个静态方法。【原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。】</li>
<li>  泛型可以声明在参数列表中的参数上；</li>
<li>  也可以声明在方法的返回值上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;E&gt; 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4    代码演示"></a>4    代码演示</h2><blockquote>
<ol>
<li> <strong>Order.java</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的内部结构就可以使用类的泛型</span></span><br><span class="line">    T orderT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        T[] arr = new T[10];</span></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String orderName, <span class="type">int</span> orderId, T orderT)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下的个方法都是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span>&#123;   <span class="comment">// 泛型声明在返回值中</span></span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span>&#123;    <span class="comment">// 泛型声明在参数列表中</span></span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, orderT=&quot;</span> + orderT +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法中不能使用类的泛型。</span></span><br><span class="line"><span class="comment">//    public static void show(T orderT)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        try&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;catch(T t)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 泛型方法可以是静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (E e : arr) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li> <strong>SubOrder.java</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubOrder</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (E e : arr) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li> <strong>测试</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">    <span class="comment">// 要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setOrderT(<span class="number">123</span>);</span><br><span class="line">    order.setOrderT(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建议：实例化时指明类的泛型</span></span><br><span class="line">    Order&lt;String&gt; order1 = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;String&gt;(<span class="string">&quot;orderAA&quot;</span>, <span class="number">1001</span>, <span class="string">&quot;order:AA&quot;</span>);</span><br><span class="line">    order1.setOrderT(<span class="string">&quot;AA:hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SubOrder</span> <span class="variable">sub1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubOrder</span>();</span><br><span class="line">    <span class="comment">// 由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。</span></span><br><span class="line">    sub1.setOrderT(<span class="number">1122</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 泛型不同的引用不能相互赋值。</span></span><br><span class="line">    <span class="comment">// list1 = list2;   // 编译时异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试泛型方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;();</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 泛型方法在调用时，指明泛型参数的类型。</span></span><br><span class="line">    List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-注意点"><a href="#5-注意点" class="headerlink" title="5    注意点"></a>5    注意点</h2><ol>
<li> 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：<code>&lt;E, T, K, V&gt;</code></li>
<li> 泛型的不同引用之间不能相互赋值。</li>
<li> 泛型如果不指定，将被擦除，泛型对应的类型均按照 Object 处理。</li>
<li> 如果泛型结构是一个抽象类或接口，则不可能创建一个泛型类的对象。</li>
<li> JDK7 中，新增了自动类型推断，简化了泛型的操作。</li>
<li> 泛型在使用时不能用基本数据类型，可以使用包装类替代。</li>
<li> 在 <code>类/接口</code> 上声明的泛型，在本类或本接口中即代表某种具体类型，可以作为非静态属性的类型，非静态方法的参数类型和返回值类型。但<strong>在静态方法中不能使用类的泛型</strong>。</li>
<li> <strong>静态方法中也可以使用泛型，但静态方法中使用的泛型是独立的泛型，而不是泛型类（或泛型接口）上声明的泛型。</strong></li>
<li> <strong>异常类不能是泛型的</strong>。即如果一个类实现或继承了 Exception 系列的类或接口，它就不能再使用泛型了。</li>
<li> 不能使用 <code>E e = new E[]</code>，但可以使用 **E[] = (E[])new Object[capacity]**。</li>
<li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型<ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>  ①没有类型，擦除；    </li>
<li>  ②指定具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>  ①全部保留</li>
<li>  ②部分保留</li>
</ul>
</li>
</ul>
</li>
<li> 子类除了指定或保留父类的泛型外，还可以增加自己的泛型。</li>
</ol>
<hr>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><ul>
<li>  在定义类、接口或方法时，使用泛型可以将数据类型的确定延后到创建对象或调用方法时，但是如果直到创建对象或调用方法时也还不能确定使用什么数据类型或要使用多种数据类型时，可以采用通配符<code>&lt;?&gt;</code>表示。</li>
<li>  但是一旦使用泛型通配符后，就只能使用Object类中的公共方法，集合中对象自身特有的方法就无法被调用。</li>
</ul>
<h2 id="1-通配符的基本使用"><a href="#1-通配符的基本使用" class="headerlink" title="1    通配符的基本使用"></a>1    通配符的基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        getElements(list1);</span><br><span class="line">        Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        getElements(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElements</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;</span><br><span class="line">        <span class="comment">// ?代表可以接收任意类型数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> <code>getElements</code> 方法第一次传递了 Integer 类型的集合，第二次传递了 String 类型的集合；</li>
<li> 如果要想通过同一个方法处理这些参数，可通过设置 <code>getElements()</code> 方法的形参为 <code>(ArrayList&lt;?&gt; arr)</code>或其父类表示。</li>
</ol>
<h2 id="2-通配符的高级使用——受限泛型"><a href="#2-通配符的高级使用——受限泛型" class="headerlink" title="2    通配符的高级使用——受限泛型"></a>2    通配符的高级使用——受限泛型</h2><p>在 Java 中，通过通配符可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<blockquote>
<ol>
<li> <strong>泛型的上限</strong></li>
</ol>
</blockquote>
<ul>
<li><p>格式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名称 &lt;? extends 类&gt; 对象名称</span><br></pre></td></tr></table></figure></li>
<li><p>  含义：在指定泛型的类型时，只能设置为该类型或其子类。</p>
</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>泛型的下限</strong></li>
</ol>
</blockquote>
<ul>
<li><p>格式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名称 &lt;? <span class="built_in">super</span> 类&gt; 对象名称</span><br></pre></td></tr></table></figure></li>
<li><p>  含义：：在指定泛型的类型时，只能设置为该类型或其父类。</p>
</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>代码演示</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// Number类型是Integer类型的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        ArrayList&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        getElement1(list1);</span><br><span class="line">        getElement1(list2);     <span class="comment">// 报错</span></span><br><span class="line">        getElement1(list3);</span><br><span class="line">        getElement1(list4);     <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        getElement2(list1);     <span class="comment">// 报错</span></span><br><span class="line">        getElement2(list2);     <span class="comment">// 报错</span></span><br><span class="line">        getElement2(list3);</span><br><span class="line">        getElement2(list4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用getElement1方法时，只能接收Number类型及其子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(ArrayList&lt;? extends Number&gt; arr)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用getElement2方法时，只能接收Number类型及其父类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Number&gt; arr)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3    注意点"></a>3    注意点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list = list1;	<span class="comment">// 编译通过</span></span><br><span class="line">    list = list2;	<span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">//        list1 = list2;  // 编译时异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list = list3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加(写入)：对于List&lt;?&gt;，不能向其内部添加数据，除了添加null之外。</span></span><br><span class="line">    <span class="comment">//        list.add(&quot;DD&quot;);	// 编译时异常</span></span><br><span class="line">    list.add(<span class="literal">null</span>);	<span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>涉及通配符的集合的数据的写入和读取</strong>：如上面代码所示</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/31/%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/31/%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-31 10:35:42 / Modified: 12:34:29" itemprop="dateCreated datePublished" datetime="2021-07-31T10:35:42+08:00">2021-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1    是什么"></a>1    是什么</h2><p><strong>定义</strong>：异常是指程序在执行过程中出现的非正常情况，最终会导致程序的非正常停止。</p>
<p>【异常并不是语法错误，语法错误的话编译时就会直接报错，不会产生字节码文件，根本不能运行。】</p>
<ul>
<li>在 Java 等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出了一个异常对象。</li>
<li>Java处理异常的方式是<strong>中断处理</strong>。</li>
</ul>
<h2 id="2-异常的体系结构"><a href="#2-异常的体系结构" class="headerlink" title="2    异常的体系结构"></a>2    异常的体系结构</h2><blockquote>
<ul>
<li>  Throwable 是<strong>类</strong>，不是接口</li>
<li>  同样的，Error 和 Exception 继承了 Throwable ，所以它俩也是<strong>类</strong></li>
<li>  RuntimeException 继承了 Exception，也是一个<strong>类</strong>；</li>
<li>  但是 CheckedException 并没有真正地继承 Exception 类，并且它是一个<strong>接口</strong>。</li>
</ul>
</blockquote>
<p><img src="/2021/07/31/%E5%BC%82%E5%B8%B8/Throwable.png"></p>
<p>​        在 Java 中，所有的异常都有一个共同的祖先 <strong>java.lang.Throwable</strong> 类。Throwable 类有两个重要的子类 <strong>Exception</strong>（异常） 和 <strong>Error</strong>（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* java.lang.Throwable</span><br><span class="line">* 		|-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">* 		|-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">* 			|------编译时异常(checked)</span><br><span class="line">* 					|-----IOException</span><br><span class="line">* 						|-----FileNotFoundException</span><br><span class="line">* 					|-----ClassNotFoundException</span><br><span class="line">* 			|------运行时异常(unchecked,RuntimeException)</span><br><span class="line">* 					|-----NullPointerException</span><br><span class="line">* 					|-----ArrayIndexOutOfBoundsException</span><br><span class="line">* 					|-----ClassCastException</span><br><span class="line">* 					|-----NumberFormatException</span><br><span class="line">* 					|-----InputMismatchException</span><br><span class="line">* 					|-----ArithmeticException</span><br></pre></td></tr></table></figure>





<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><blockquote>
<p>  <strong>java.lang.Error</strong></p>
</blockquote>
<p><strong>Error 错误是程序无法处理的错误</strong>。大多数是 JVM 层面的问题。即代码在逻辑上是正确的，但是由于 JVM 内存不足或者某些对象申请的内存空间过大导致等原因导致程序出现错误。 这些错误是在编译期是不可查的，因为它们在应用程序的控制和处理能力之外。</p>
<p>​        例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 <code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><blockquote>
<p>  <strong>java.lang.Exception</strong></p>
</blockquote>
<p><strong>Exception 是程序本身可以处理的异常</strong>。Exception 又可分为 <strong>编译时异常</strong> 与 <strong>运行时异常</strong> 两大类。</p>
<p><img src="/2021/07/31/%E5%BC%82%E5%B8%B8/image-20210730163920638.png" alt="image-20210730163920638"></p>
<ul>
<li>  编译时异常：执行 <code>javac.exe</code> 命名时，可能出现的异常；</li>
<li>  运行时异常：执行 <code>java.exe</code> 命名时，出现的异常；</li>
</ul>
<h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><blockquote>
<p>  <strong>执行 <code>javac.exe</code> 命名时，可能出现的异常；</strong></p>
</blockquote>
<p>以下是一个编译时异常的简单例子。由于我们使用的是 IDEA 集成开发工具，代码是即时编译的，所以可以编译时异常不会在控制台上输出，而是非常智能的提示出来了。但是如果我们使用基本的文本工具进行开发，编写的 <code>.java</code> 代码是不会自动提示错误的，只有在经过 javac 编译后才会提示，这就是所谓的<strong>编译时异常</strong>。</p>
<img src="/2021/07/31/%E5%BC%82%E5%B8%B8/image-20210730163330302.png" alt="image-20210730163330302" style="zoom: 67%;">



<h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><blockquote>
<p>  <strong>执行 <code>java.exe</code> 命名时，出现的异常；</strong></p>
</blockquote>
<p>程序在执行 <code>java.exe</code> 运行后提示的异常。</p>
<blockquote>
<p>  常见的运行时异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException	<span class="comment">// 要访问的变量没有引用任何对象时，抛出该异常）、</span></span><br><span class="line">ArithmeticException		<span class="comment">// 算术运算异常，一个整数除以0时，抛出该异常）和 </span></span><br><span class="line">ArrayIndexOutOfBoundsException	<span class="comment">// 下标越界异常</span></span><br></pre></td></tr></table></figure>





<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>异常和错误的区别</strong>：异常能被程序本身可以处理，错误是无法处理。</p>
<p><strong>如何理解</strong></p>
<p>我们可以看到，无论是编译期异常还是运行期异常，产生异常后程序员可以在代码层面纠正，使程序能继续正常运行。如上面的编译期异常，可以通过 <code>try...catch</code> 捕获处理；对于运行时期的各种异常，如空指针异常，可以通过加判断条件来避免。这些异常都是代码层面可以处理的。而对于一些虚拟机的异常，主要是涉及到了虚拟机的配置，可能出现在某写配置较好的虚拟机上可以正常运行，而在性能较差的虚拟机上就不能运行了的情况，所以说 Error 是无法避免的。</p>
<h2 id="3-Throwable类常用方法"><a href="#3-Throwable类常用方法" class="headerlink" title="3    Throwable类常用方法"></a>3    Throwable类常用方法</h2><table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>printStackTrace()</code></td>
<td align="center"><code>void</code></td>
<td align="center">在控制台上打印异常的详细信息</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>getMessage()</code></td>
<td align="center"><code>String</code></td>
<td align="center">获取发生异常的原因</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>toString</code></td>
<td align="center"><code>String</code></td>
<td align="center">获取异常的类型和详细信息</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-异常处理方式"><a href="#4-异常处理方式" class="headerlink" title="4    异常处理方式"></a>4    异常处理方式</h2><p>异常的两种处理方式：1、<strong>“抛”</strong>  2、<strong>“抓”</strong></p>
<blockquote>
<ol>
<li> <strong>“抛”</strong> </li>
</ol>
</blockquote>
<ul>
<li>  程序在正常执行的过程中，一旦出现异常，就会在异常代码处产生一个对应异常类的对象，并将此对象抛出。</li>
<li>  一旦抛出异常对象以后，其后的代码就不再执行。</li>
</ul>
<p><strong>关于异常对象的产生：</strong></p>
<ol>
<li> 系统自动生成的异常对象；</li>
<li> 手动的生成一个异常对象，并抛出（throw）。</li>
</ol>
<blockquote>
<ol start="2">
<li> <strong>“抓”</strong></li>
</ol>
</blockquote>
<p>可以理解为异常的处理方式：①<code>try-catch-finally</code>  ②<code>throws</code></p>
<h3 id="异常处理方式一：try-catch-finally"><a href="#异常处理方式一：try-catch-finally" class="headerlink" title="异常处理方式一：try-catch-finally"></a>异常处理方式一：try-catch-finally</h3><blockquote>
<p>  <strong>使用说明：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码。</span></span><br><span class="line">    <span class="comment">// 代码中出现的异常可能不止一种，针对不同类型异常可以使用多个catch语句分别做不同的处理 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><code>finally</code> 是可选的。</li>
<li>使用 <code>try</code> 将可能出现异常代码包起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此异常对象的类型，去 <code>catch</code> 中进行匹配；</li>
<li>一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构，继续执行 <code>try</code> 中后续的代码，最后再执行 <code>finally</code> 中的代码。</li>
<li><code>catch</code> 中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。但是 <strong><code>catch</code> 中的异常类型如果满足子父类关系，则要求子类异常类型一定要声明在父类异常类型的上面</strong>，否则报错。【因为 <code>catch</code> 是从上向下匹配的，如果父类异常类型声明在先，则该父类异常的所有子类异常都会被父类异常拦截（多态），根本执行不到子类异常处 】</li>
<li>常用的异常对象处理的方式： <code>① String  getMessage()    ② printStackTrace()</code></li>
<li>在 <code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用。</li>
<li><code>try-catch-finally</code> 结构可以嵌套。</li>
</ol>
<blockquote>
<p>  <strong>如何看待代码中的编译时异常和运行时异常？</strong></p>
</blockquote>
<ol>
<li> 使用 <code>try-catch-finally</code> 处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</li>
<li> 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。针对于编译时异常，我们则一定要考虑异常的处理。</li>
</ol>
<h3 id="异常处理方式二：throws"><a href="#异常处理方式二：throws" class="headerlink" title="异常处理方式二：throws"></a>异常处理方式二：throws</h3><ul>
<li>  <strong>throws + 异常类型</strong> 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。</li>
<li>  一旦当方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 <code>throws</code> 抛出的异常类型时，就会被抛出。异常代码后续的代码，就不再执行。</li>
</ul>
<h3 id="对比两种处理方式"><a href="#对比两种处理方式" class="headerlink" title="对比两种处理方式"></a>对比两种处理方式</h3><ul>
<li>  <code>try-catch-finally</code>：真正的将异常给处理掉了。</li>
<li>  <code>throws</code>：只是将异常抛给了方法的调用者，并没真正将异常处理掉。</li>
</ul>
<h3 id="体会开发中应该如何选择两种处理方式？"><a href="#体会开发中应该如何选择两种处理方式？" class="headerlink" title="体会开发中应该如何选择两种处理方式？"></a>体会开发中应该如何选择两种处理方式？</h3><ul>
<li>  如果父类中被重写的方法没 <code>throws</code> 方式处理异常，则子类重写的方法也不能使用 <code>throws</code>。这意味着如果子类重写的方法中异常，必须使用 <code>try-catch-finally</code> 方式处理。</li>
<li>  执行的方法 <code>methodA()</code> 中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用 <code>throws</code> 的方式进行处理，而执行的方法 <code>methodA()</code> 可以考虑使用 <code>try-catch-finally</code> 方式进行处理。</li>
<li>  使用 <code>throws</code> 抛出的异常最外层还是要落实到使用 <code>try-catch-finally</code> 处理。</li>
</ul>
<blockquote>
<p>  <strong>补充：</strong></p>
</blockquote>
<ul>
<li>  方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。【因为父类是子类的顶级抽象，如果子类的异常类型范围大于父类类型的话，则父类就会无法处理超出范围的异常类型】</li>
</ul>
<hr>
<h2 id="5-手动抛出异常对象"><a href="#5-手动抛出异常对象" class="headerlink" title="5    手动抛出异常对象"></a>5    手动抛出异常对象</h2><blockquote>
<ol>
<li> <strong>使用说明</strong></li>
</ol>
</blockquote>
<p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以通过 <code>throw</code> 手动抛出一个异常类的对象。</p>
<blockquote>
<ol start="2">
<li> <strong>throw 和  throws 的区别？</strong></li>
</ol>
</blockquote>
<p><strong>throw</strong>：</p>
<ul>
<li>  动词，表示抛出一个异常类的对象。</li>
<li>  生成异常对象的过程，声明在方法体内。</li>
<li>  <code>throw</code> 抛出的对象会由 <code>throws</code> 接收并抛给上一层，并在最外层由 <code>try-catch-finally</code> 处理，或直接中断程序。</li>
</ul>
<p><strong>throws</strong>：</p>
<ul>
<li>  名词，属于异常处理的一种方式。声明在方法的声明处。</li>
<li>  <code>throws</code> 用于接收程序运行时由系统抛出或者用户自定义抛出的异常，并交给 <code>try-catch-finally</code> 处理。  </li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 手动抛出异常对象</span></span><br><span class="line"><span class="comment">//			throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="comment">//			throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);	<span class="comment">// 自定义异常对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-自定义异常类"><a href="#6-自定义异常类" class="headerlink" title="6    自定义异常类"></a>6    自定义异常类</h2><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/11/26/%E9%80%9A%E7%94%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/">超链接：开发中的通用异常处理</a></p>
</blockquote>
<blockquote>
<p>  <strong>如何自定义一个异常类？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何自定义异常类？</span></span><br><span class="line"><span class="comment"> * 1. 继承于现的异常结构：RuntimeException 、Exception</span></span><br><span class="line"><span class="comment"> * 2. 提供全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment"> * 3. 提供重载的构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">红黑树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-30 22:42:04" itemprop="dateCreated datePublished" datetime="2021-07-30T22:42:04+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-31 12:03:42" itemprop="dateModified" datetime="2021-08-31T12:03:42+08:00">2021-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="红黑树基础：二叉搜索树"><a href="#红黑树基础：二叉搜索树" class="headerlink" title="红黑树基础：二叉搜索树"></a>红黑树基础：二叉搜索树</h1><blockquote>
<p>  <strong>二叉搜索树</strong></p>
</blockquote>
<p><strong>二叉搜索树（binary search tree）</strong>就是在二叉树的基础上增加了一些额外的条件，二叉搜索树是一种特殊的二叉树。</p>
<blockquote>
<p>  <strong>二叉搜索树要求：</strong></p>
</blockquote>
<ol>
<li> 若左子树不为空，则左子树上所有结点的值均小于根结点的值； </li>
<li> 若右子树不为空，则右子树上所有结点的值均大于根结点的值； </li>
<li> 左、右子树也分别为二叉排序树。</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p>
<hr>
<h2 id="二叉搜索树-查找节点："><a href="#二叉搜索树-查找节点：" class="headerlink" title="二叉搜索树-查找节点："></a>二叉搜索树-查找节点：</h2><p>查找某个节点，我们必须从根节点开始查找。</p>
<ol>
<li> 查找值比当前节点值大，则搜索右子树；</li>
<li> 查找值等于当前节点值，停止搜索（终止条件）；</li>
<li> 查找值小于当前节点值，则搜索左子树；</li>
</ol>
<hr>
<h2 id="二叉搜索树-插入节点："><a href="#二叉搜索树-插入节点：" class="headerlink" title="二叉搜索树-插入节点："></a>二叉搜索树-插入节点：</h2><ul>
<li>  要插入节点，必须先找到插入的位置。</li>
<li>  与查找操作相似，由于二叉搜索树的特殊性，待插入的节点也需要从根节点开始进行比较，小于根节点则与根节点左子树比较，反之则与右子树比较，直到左子树为空或右子树为空，则插入到相应为空的位置。</li>
</ul>
<hr>
<h2 id="二叉搜索树-遍历节点："><a href="#二叉搜索树-遍历节点：" class="headerlink" title="二叉搜索树-遍历节点："></a>二叉搜索树-遍历节点：</h2><p>二叉搜索树的遍历与普通二叉树的遍历一样，常见的有：</p>
<ul>
<li>  前序遍历</li>
<li>  中序遍历</li>
<li>  后序遍历</li>
</ul>
<h2 id="二叉搜索树-查找最大值和最小值"><a href="#二叉搜索树-查找最大值和最小值" class="headerlink" title="二叉搜索树-查找最大值和最小值"></a>二叉搜索树-查找最大值和最小值</h2><ul>
<li>  要找最小值，先找根的左节点，然后一直找这个左节点的左节点，直到找到没有左节点的节点，那么这个节点就是最小值。</li>
<li>  同理要找最大值，一直找根节点的右节点，直到没有右节点，则就是最大值。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC.png" alt="最大值和最小值"></p>
<hr>
<h2 id="二叉搜索树-删除节点："><a href="#二叉搜索树-删除节点：" class="headerlink" title="二叉搜索树-删除节点："></a>二叉搜索树-删除节点：</h2><p>删除节点是二叉搜索树中最复杂的操作，删除的节点有三种情况，前两种比较简单，但是第三种却很复杂。</p>
<blockquote>
<ol>
<li> 待删除的节点是叶节点（没有子节点）</li>
<li> 待删除的节点有一个子节点</li>
<li> 待删除的节点有两个子节点</li>
</ol>
</blockquote>
<h3 id="Case1：删除叶子节点"><a href="#Case1：删除叶子节点" class="headerlink" title="Case1：删除叶子节点"></a>Case1：删除叶子节点</h3><ul>
<li>  找到待删除的叶子节点，将其父节点指向该节点的引用改为null即可。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9.png" alt="删除叶子节点"></p>
<hr>
<h3 id="Case2：删除有一个子节点的节点"><a href="#Case2：删除有一个子节点的节点" class="headerlink" title="Case2：删除有一个子节点的节点"></a>Case2：删除有一个子节点的节点</h3><ul>
<li>  删除有一个子节点的节点，我们只需要将其父节点原本指向该节点的引用，改为指向该节点的子节点即可。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="删除拥有一个子节点的节点"></p>
<hr>
<h3 id="Case3：删除有两个子节点的节点"><a href="#Case3：删除有两个子节点的节点" class="headerlink" title="Case3：删除有两个子节点的节点"></a>Case3：删除有两个子节点的节点</h3><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E6%8B%A5%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9_01.png" alt="删除拥有两个子节点的节点_01"></p>
<ul>
<li>  当待删除的节点存在两个子节点，那么删除之后，两个子节点的位置我们就没办法处理了。</li>
<li>  既然处理不了，我们就想到一种办法，<strong>用其中一个节点来代替被删除的节点</strong>，那么用哪一个节点来代替呢？</li>
<li>  我们知道二叉搜索树中的节点是按照关键字来进行排列的，某个节点的关键字次高节点是它的中序遍历<strong>后继节点</strong>。</li>
<li>  用后继节点来代替删除的节点，显然该二叉搜索树还是有序的。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E6%8B%A5%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="删除拥有两个子节点的节点"></p>
<blockquote>
<p>  <strong>如何找到删除节点的中序后继节点？</strong></p>
</blockquote>
<ul>
<li>  实际上就是要找比删除节点关键值大的节点集合中最小的一个节点，只有这样代替删除节点后才能满足二叉搜索树的特性。</li>
<li>  后继节点也就是：<strong>比删除节点大的最小节点</strong>。</li>
</ul>
<hr>
<h3 id="Case4：删除有必要吗？"><a href="#Case4：删除有必要吗？" class="headerlink" title="Case4：删除有必要吗？"></a>Case4：删除有必要吗？</h3><ul>
<li>  通过上面的删除分类讨论，我们发现删除其实是挺复杂的，那么其实我们<strong>可以不用真正的删除该节点，只需要在Node类中增加一个标识字段 isDelete</strong>，当该字段为true时，表示该节点已经删除，反之则没有删除。这样删除节点就不会改变树的结构了。</li>
<li>  影响就是查询时需要判断一下节点是否已被删除。</li>
</ul>
<hr>
<h2 id="二叉搜索树-时间复杂度分析："><a href="#二叉搜索树-时间复杂度分析：" class="headerlink" title="二叉搜索树-时间复杂度分析："></a>二叉搜索树-时间复杂度分析：</h2><h3 id="回顾经典：二分查找算法"><a href="#回顾经典：二分查找算法" class="headerlink" title="回顾经典：二分查找算法"></a>回顾经典：二分查找算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,8,9。。。。。。。100]</span><br></pre></td></tr></table></figure>

<ul>
<li>  暴力算法：运气好时 性能不错，运气不好时 性能暴跌。</li>
<li>  二分查找算法：数据源必须是<strong>有序数组</strong>，性能较好，每次迭代查询可以排除掉一半的结果。</li>
</ul>
<blockquote>
<p>  <strong>二分查找算法最大的缺陷是什么？</strong></p>
</blockquote>
<ul>
<li>  <strong>数组必须有序</strong></li>
<li>  数组自身缺陷：没有办法快速插入，也没有办法扩容</li>
</ul>
<blockquote>
<p>  <strong>怎么样才能拥有二分查找的高性能又能拥有链表一样的灵活性？</strong></p>
</blockquote>
<ul>
<li>  二叉搜索树</li>
</ul>
<blockquote>
<p>  二分查找算法时间复杂度推算过程：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">第几次查询</th>
<th align="center">剩余待查询元素数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">N/2</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">N/(2^2)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">N/(2^3)</td>
</tr>
<tr>
<td align="center">K</td>
<td align="center">N/(2^K)</td>
</tr>
</tbody></table>
<ul>
<li>  从上表可以看出 <strong>N/(2^K)</strong> 肯定是大于等于1，也就是 <strong>N/(2^K)&gt;=1</strong> ，我们计算时间复杂度是按照<strong>最坏的情况</strong>进行计算，也就是是查到剩余最后一个数才查到我们想要的数据，也就是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">N/(2^K)=1   =&gt;   2^K = N   =&gt; K = log2 (N)    </span><br><span class="line">=&gt;  二分查找算法时间复杂度：O(log2(N))  =&gt; O(logN)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="普通二叉搜索树致命缺陷："><a href="#普通二叉搜索树致命缺陷：" class="headerlink" title="普通二叉搜索树致命缺陷："></a>普通二叉搜索树致命缺陷：</h2><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5.png" alt="二叉搜索树-极端情况"></p>
<ul>
<li>  <strong>这颗二叉树查询效率咋样呢？O(N)</strong></li>
<li>  <strong>怎么解决 二叉搜索树 退化成线性链表的问题？</strong></li>
<li>  <strong>如果插入元素时，树可以自动调整两边平衡，会保持不错的查找性能。</strong></li>
</ul>
<h2 id="AVL树简介："><a href="#AVL树简介：" class="headerlink" title="AVL树简介："></a>AVL树简介：</h2><blockquote>
<p>  <strong>AVL树有什么特点？</strong></p>
</blockquote>
<ol>
<li> 具有二叉查找树的全部特性。</li>
<li> 每个节点的左子树和右子树的<strong>高度差至多等于1</strong>。</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/AVL%E6%A0%91.png" alt="AVL树"></p>
<ul>
<li>  平衡树基于这种特点就可以保证不会出现大量节点偏向于一边的情况了！</li>
<li>  <strong>插入或者删除时，会发生左旋、右旋操作，使这棵树再次左右保持一定的平衡</strong>。</li>
</ul>
<hr>
<h2 id="为什么有了平衡树还需要红黑树？"><a href="#为什么有了平衡树还需要红黑树？" class="headerlink" title="为什么有了平衡树还需要红黑树？"></a>为什么有了平衡树还需要红黑树？</h2><ul>
<li>  虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 <code>O(logn)</code>，不过却<strong>不是最佳</strong>的，</li>
<li>  因为平衡树要求每个节点的左子树和右子树的高度差至多等于 1，这个要求实在是太严了，导致每次进行【插入/删除】节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树！</li>
</ul>
<hr>
<h1 id="红黑树原理讲解"><a href="#红黑树原理讲解" class="headerlink" title="红黑树原理讲解"></a>红黑树原理讲解</h1><blockquote>
<ol>
<li> 红黑树的性质</li>
<li>红黑树自平衡的策略<ul>
<li>  改变颜色</li>
<li>  左旋</li>
<li>  右旋</li>
</ul>
</li>
<li> 红黑树的查找</li>
<li>红黑树的插入<ul>
<li>  Case1：红黑树为空树</li>
<li>  Case2：插入节点的 key 已经存在</li>
<li>  Case3：插入节点的父节点为黑色</li>
<li>Case4：插入节点的父节点为红色<ul>
<li>  Case4.1：叔叔节点存在，并且为红色（父-叔 双红）</li>
<li>Case4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树<ul>
<li>  Case4.2.1：插入节点为其父节点的左子节点（LL情况）</li>
<li>  Case4.2.2：插入节点为其父节点的右子节点（LR情况）</li>
</ul>
</li>
<li>Case4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树<ul>
<li>  Case4.3.1：插入节点为其父节点的右子节点（RR情况）</li>
<li>  Case4.3.2：插入节点为其父节点的左子节点（RL情况）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li> 红黑树插入案例分析</li>
</ol>
</blockquote>
<h2 id="红黑树的性质："><a href="#红黑树的性质：" class="headerlink" title="红黑树的性质："></a>红黑树的性质：</h2><table>
<thead>
<tr>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">性质1：</td>
<td>每个节点要么是<strong>黑色</strong>，要么是<strong>红色</strong>。</td>
</tr>
<tr>
<td align="center">性质2：</td>
<td>根节点是<strong>黑色</strong>。</td>
</tr>
<tr>
<td align="center">性质3：</td>
<td>每个叶子节点（<strong>包括NULL</strong>）是<strong>黑色</strong>。</td>
</tr>
<tr>
<td align="center">性质4：</td>
<td>每个<strong>红色</strong>节点的两个子节点一定都是<strong>黑色</strong>。</td>
</tr>
<tr>
<td align="center">性质5：</td>
<td>任意一节点到每个叶子节点的路径都包含<strong>数量相同</strong>的<strong>黑结点</strong>。</td>
</tr>
<tr>
<td align="center">性质5.1：</td>
<td>从性质5又可以推出：如果一个节点存在黑子节点，那么该结点肯定有两个子节点</td>
</tr>
</tbody></table>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<ul>
<li>  红黑树并<strong>不是一个平衡二叉查找树</strong>，从图上可以看到，根结点 P 的左子树显然比右子树高，</li>
<li>  但<strong>左子树和右子树的黑色结点的层数是相等的</strong>，即任意一个结点到到每个叶子结点的路径都包含数量相同的黑色结点(性质5)。</li>
<li>  所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong>。</li>
</ul>
<hr>
<h2 id="红黑树自平衡："><a href="#红黑树自平衡：" class="headerlink" title="红黑树自平衡："></a>红黑树自平衡：</h2><blockquote>
<p>  <strong>前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。</strong></p>
</blockquote>
<ol>
<li> <strong>变色：</strong>结点的颜色由红变黑或由黑变红。</li>
<li> <strong>左旋：</strong>以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。</li>
<li> <strong>右旋：</strong>以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li>
</ol>
<blockquote>
<p>  <strong>左旋</strong></p>
</blockquote>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%B7%A6%E6%97%8B.gif" alt="左旋"></p>
<blockquote>
<p>  <strong>右旋</strong></p>
</blockquote>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%8F%B3%E6%97%8B.gif" alt="右旋"></p>
<h2 id="红黑树查找："><a href="#红黑树查找：" class="headerlink" title="红黑树查找："></a>红黑树查找：</h2><p>红黑树查找与二叉搜索树查找一样，都是左边小、右边大。</p>
<h2 id="红黑树插入："><a href="#红黑树插入：" class="headerlink" title="红黑树插入："></a>红黑树插入：</h2><p>插入操作包括两部分工作：</p>
<blockquote>
<ol>
<li> 查找插入的位置</li>
<li> <strong>插入后自平衡</strong></li>
</ol>
</blockquote>
<p><strong>注意：</strong>插入节点，必须为<strong>红色</strong>。</p>
<p>理由很简单，如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多 1，必须做自平衡。而红色在父节点（如果存在）为黑色节点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。</p>
<p>在开始每个情景的讲解前，我们还是先来约定下：</p>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A6%E5%AE%9A.png" alt="约定"></p>
<hr>
<h2 id="红黑树插入节点情况分析"><a href="#红黑树插入节点情况分析" class="headerlink" title="红黑树插入节点情况分析"></a>红黑树插入节点情况分析</h2><h3 id="情景1：红黑树为空树"><a href="#情景1：红黑树为空树" class="headerlink" title="情景1：红黑树为空树"></a>情景1：红黑树为空树</h3><ul>
<li>  最简单的一种情景，直接把插入结点作为根结点就行</li>
<li>  注意：根据红黑树性质2，根节点必须是黑色，但是因为插入的节点一定一定是红色节点，所以还需要把新插入结点设为黑色。</li>
</ul>
<h3 id="情景2：插入结点的Key已存在"><a href="#情景2：插入结点的Key已存在" class="headerlink" title="情景2：插入结点的Key已存在"></a>情景2：插入结点的Key已存在</h3><ul>
<li>  处理：更新当前节点的值，为插入节点的值</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B5%E4%BA%8C_%E6%9B%BF%E6%8D%A2%20(2).png" alt="情况二_替换 (2)"></p>
<h3 id="情景3：插入结点的父结点为黑结点"><a href="#情景3：插入结点的父结点为黑结点" class="headerlink" title="情景3：插入结点的父结点为黑结点"></a>情景3：插入结点的父结点为黑结点</h3><p>由于插入的结点是红色的，当插入结点的父节点时黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B5%E4%B8%89_%E9%BB%91%E7%88%B6.png" alt="情况三_黑父"></p>
<h3 id="情景4：插入节点的父节点为红色"><a href="#情景4：插入节点的父节点为红色" class="headerlink" title="情景4：插入节点的父节点为红色"></a>情景4：插入节点的父节点为红色</h3><ul>
<li>  根据红黑树的<strong>性质2：根结点是黑色</strong>。如果插入节点的父结点为<strong>红结点</strong>，那么该父结点不可能为根结点，所以插入结点总是存在爷爷结点。</li>
<li>  这一点很关键，因为后续的旋转操作肯定需要爷爷结点的参与。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B5%E5%9B%9B_%E7%88%B6%E8%8A%82%E7%82%B9%E7%BA%A2%E8%89%B2.png" alt="情况四_父节点红色"></p>
<h4 id="插入情景4-1：叔叔结点存在并且为红结点"><a href="#插入情景4-1：叔叔结点存在并且为红结点" class="headerlink" title="插入情景4.1：叔叔结点存在并且为红结点"></a>插入情景4.1：叔叔结点存在并且为红结点</h4><ul>
<li>  依据红黑树<strong>性质4可知，红色节点不能相连 ==&gt; 祖父结点肯定为黑结点</strong>；</li>
<li>  因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。</li>
<li>  首先第一步处理就是变色，将其改为：<strong>红黑红</strong></li>
</ul>
<blockquote>
<p>  <strong>处理：</strong></p>
</blockquote>
<ol>
<li> 将黑红红改为红黑红</li>
<li> 以 PP 作为新的当前节点，进行后续处理</li>
<li><ul>
<li>  如果 PP 的父结点是黑色，那么无需再做任何处理；</li>
<li>  但如果 PP 的父结点是红色，则违反红黑树性质了。所以需要将 PP 设置为当前节点，继续做插入操作自平衡处理，直到平衡为止。</li>
</ul>
</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B54.1_%E5%8F%94%E5%8F%94%E7%BA%A2%E8%89%B2.png" alt="情况4.1_叔叔红色"></p>
<h4 id="插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点"><a href="#插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点" class="headerlink" title="插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点"></a>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点</h4><ul>
<li>  <strong>注意</strong>：单纯从插入前来看，叔叔节点非红即空（NIL节点），否则的话破坏了红黑树性质5，此路径会比其它路径多一个黑色节点。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.png" alt="4.2"></p>
<h5 id="插入情景4-2-1：新插入节点，为其父节点的左子节点（LL红色情况）"><a href="#插入情景4-2-1：新插入节点，为其父节点的左子节点（LL红色情况）" class="headerlink" title="插入情景4.2.1：新插入节点，为其父节点的左子节点（LL红色情况）"></a>插入情景4.2.1：新插入节点，为其父节点的左子节点（LL红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.1_LL.png" alt="4.2.1_LL"></p>
<blockquote>
<p>  处理：</p>
</blockquote>
<ol>
<li> 变色：将P设置为黑色，将PP设置为红色；</li>
<li> 对 PP 节点进行<strong>右旋</strong>。</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.1_LL_%E5%A4%84%E7%90%86.png" alt="4.2.1_LL_处理"></p>
<h5 id="插入情景4-2-2：新插入节点，为其父节点的右子节点（LR红色情况）"><a href="#插入情景4-2-2：新插入节点，为其父节点的右子节点（LR红色情况）" class="headerlink" title="插入情景4.2.2：新插入节点，为其父节点的右子节点（LR红色情况）"></a>插入情景4.2.2：新插入节点，为其父节点的右子节点（LR红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.2_LR.png" alt="4.2.2_LR"></p>
<blockquote>
<p>  <strong>处理：</strong></p>
</blockquote>
<ol>
<li> 对 P 进行左旋，得到 LL 红色情况</li>
<li>按照 LL 红色情况处理<ol>
<li> 变颜色</li>
<li> 右旋PP</li>
</ol>
</li>
</ol>
<h4 id="插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点"><a href="#插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点" class="headerlink" title="插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点"></a>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点</h4><p>该情景对应情景4.2，只是方向反转，直接看图。</p>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.png" alt="4.3"></p>
<h5 id="插入情景4-3-1：新插入节点，为其父节点的右子节点（RR红色情况）"><a href="#插入情景4-3-1：新插入节点，为其父节点的右子节点（RR红色情况）" class="headerlink" title="插入情景4.3.1：新插入节点，为其父节点的右子节点（RR红色情况）"></a>插入情景4.3.1：新插入节点，为其父节点的右子节点（RR红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.1_RR.png" alt="4.3.1_RR"></p>
<blockquote>
<p>  处理：</p>
</blockquote>
<ol>
<li> 变颜色：将P设置为黑色，将PP设置为红色</li>
<li> 对PP节点进行<strong>左旋</strong></li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.1_RR_%E5%A4%84%E7%90%86.png" alt="4.3.1_RR_处理"></p>
<h5 id="插入情景4-3-2：新插入节点，为其父节点的左子节点（RL红色情况）"><a href="#插入情景4-3-2：新插入节点，为其父节点的左子节点（RL红色情况）" class="headerlink" title="插入情景4.3.2：新插入节点，为其父节点的左子节点（RL红色情况）"></a>插入情景4.3.2：新插入节点，为其父节点的左子节点（RL红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.2_RL.png" alt="4.3.2_RL"></p>
<blockquote>
<p>  处理：</p>
</blockquote>
<ol>
<li> 对P进行右旋，得到RR红色情况</li>
<li>按照RR红色情况处理<ol>
<li> 变颜色</li>
<li> 左旋PP</li>
</ol>
</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.2_RL_%E5%A4%84%E7%90%86.png" alt="4.3.2_RL_处理"></p>
<h2 id="红黑树插入案例分析"><a href="#红黑树插入案例分析" class="headerlink" title="红黑树插入案例分析"></a>红黑树插入案例分析</h2><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%A1%88%E4%BE%8B%20(3).png" alt="红黑树插入案例 (3)"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/25/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/LeetCode/" class="post-title-link" itemprop="url">LeetCode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-25 21:11:47" itemprop="dateCreated datePublished" datetime="2021-07-25T21:11:47+08:00">2021-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-02 20:48:36" itemprop="dateModified" datetime="2021-08-02T20:48:36+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="斐波那契数列的多种解法"><a href="#斐波那契数列的多种解法" class="headerlink" title="斐波那契数列的多种解法"></a>斐波那契数列的多种解法</h1><blockquote>
<p>  <strong>斐波那契数列</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 斐波那契数列</span><br><span class="line">*      F(<span class="number">0</span>) = <span class="number">0</span>，</span><br><span class="line">*      F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">*      F(n) = F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>)，其中 n &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="普通递归解法（性能最差）"><a href="#普通递归解法（性能最差）" class="headerlink" title="普通递归解法（性能最差）"></a>普通递归解法（性能最差）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.binarySearch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求：给出 n计算 F(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution509</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fib</span> <span class="operator">=</span> fib(<span class="number">6</span>);</span><br><span class="line">        System.out.println(fib);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>  n;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="递归优化解法"><a href="#递归优化解法" class="headerlink" title="递归优化解法"></a>递归优化解法</h2><p>斐波那契数列递归的时候会造成大量的重复计算，比如就计算 <code>fib(6)</code> 为例来看：<code>F(6) = F(5)+F(4)</code>，当我们计算出 F(5) 的时候，F(4) 也已经被计算出来了，如果我们在 F(6) 的右子节点中能够调用已经计算出来的值的话，那么该节点就不用继续向下展开了。这在 n 非常大时，节省的效率很高，接近于一半。</p>
<p><img src="/2021/07/25/LeetCode/a6f819589ee5e50ec378f2c10835e9a510529bac44618444beb2202486062eee-image.png" alt="image.png"></p>
<p>我们看到上面相同颜色的都是重复计算，当 n 越大，重复的就会越多。</p>
<p>所以我们可以使用一个 map 把计算过的值存起来，每次计算的时候先查看 map 中有没有，</p>
<ul>
<li>  如果有就表示计算过，直接从 map 中取；</li>
<li>  如果没有就先计算，计算完之后再把结果存到map中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.binarySearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 斐波那契数列</span></span><br><span class="line"><span class="comment"> *      F(0) = 0，</span></span><br><span class="line"><span class="comment"> *      F(1) = 1</span></span><br><span class="line"><span class="comment"> *      F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求：给出 n计算 F(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution509</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution509</span>().fib(<span class="number">7</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  fib(int n, HashMap&lt;Integer, Integer&gt; map) 的重载方法，简化调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> fib(n, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  计算斐波那契数的方法（递归优化）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n, HashMap&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// 每次计算的时候先查看 map 中有没有，</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n))&#123;</span><br><span class="line">            <span class="comment">// 如果有直接从 map 中取；</span></span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有就先计算，计算完之后再把结果存到map中。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> fib(n - <span class="number">1</span>, map) + fib(n - <span class="number">2</span>, map);</span><br><span class="line">            map.put(n, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="动态规划（非递归解法）"><a href="#动态规划（非递归解法）" class="headerlink" title="动态规划（非递归解法）"></a>动态规划（非递归解法）</h2><ul>
<li>  想要计算 <strong>F(n)</strong> 的值，就需要知道 F(n-1) 和 F(n-2) 的值；</li>
<li>  想要计算 F(n-1) 的值，就要知道 F(n-2) 和 F(n-3) 的值；</li>
<li>  以此类推，一直到 F(0) 和 F(1)。</li>
</ul>
<p>​        正如上面讲的普通的递归算法的弊端一样，如果每次 F(n-1) 和 F(n-2) 都独立运算，那么重复计算的值就太多了。上面的优化方式是将已经计算过的值保存到一个 Map  中避免重复运算，而且采用的是<strong>自顶向下</strong>的计算方式，即从 F(n-1) 算到 F(1)。</p>
<p>​        而所谓的斐波那契的动态规划解法，其实可以看做是一种穷举法。就是将从 F(1) 到 F(n-1) 的所有值都计算出来，保存到一个 List（或者 Map 均可）中，但是这里采用的是<strong>自底向上</strong>，即从 F(1) 计算到 F(n-1) 。</p>
<p>​        所以，在计算 F(n) 之前，动态规划必定已经建立好了一个从 <code>F(0) ~ F(n-1)</code> 的数组。而结算结果就是从数组中取出对应的元素即可。</p>
<p><img src="/2021/07/25/LeetCode/1600679988-ufqRKk-file_1600679988859" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.binarySearch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 斐波那契数列</span></span><br><span class="line"><span class="comment"> *      F(0) = 0，</span></span><br><span class="line"><span class="comment"> *      F(1) = 1</span></span><br><span class="line"><span class="comment"> *      F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求：给出 n计算 F(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution509</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution509</span>().fib(<span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划：</span></span><br><span class="line"><span class="comment">     *    自底向上构建一个数组，数组中保存着每个 F(n) 的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 0~n 共有 n+1 个元素，length 设为 n+2 是为了满足初始条件。</span></span><br><span class="line">        <span class="comment">// 即 f(0)=0 和 f(1)=1 是初始状态，数组的最小长度为 2</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建一个保存了从 f(0) 到 f(n) 的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="977-有序数组的平方（双指针）"><a href="#977-有序数组的平方（双指针）" class="headerlink" title="977. 有序数组的平方（双指针）"></a>977. 有序数组的平方（双指针）</h1><blockquote>
<p>  <strong>题目</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
</blockquote>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.cursor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/26 9:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 977. 有序数组的平方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> *      给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</span></span><br><span class="line"><span class="comment"> *      【非递减顺序 = 递增顺序】</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> *      难点在于如何让新数组也按非递减顺序排列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路一：暴力解法，先计算出所有数字的平方，再进行排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution977</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;-<span class="number">4</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] squares = <span class="keyword">new</span> <span class="title class_">Solution977</span>().sortedSquares(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> square : squares) &#123;</span><br><span class="line">            System.out.println(square);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(squares);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力解法：</span></span><br><span class="line"><span class="comment">     *  1、计算出 nums 数组中每个元素的平方，保存到一个新的数组中；</span></span><br><span class="line"><span class="comment">     *  2、对新数组按非递减顺序排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  -- 毋庸置疑，虽然通过了，但时间复杂度很高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 1、计算出 nums 数组中每个元素的平方，保存到一个 sq 数组中；</span></span><br><span class="line">        <span class="type">int</span>[] sq = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sq[i] = nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、对 sq 数组排序</span></span><br><span class="line">        Arrays.sort(sq);</span><br><span class="line">        <span class="keyword">return</span> sq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="双指针-归并排序"><a href="#双指针-归并排序" class="headerlink" title="双指针 + 归并排序"></a>双指针 + 归并排序</h3><blockquote>
<p>  <strong>思路</strong></p>
</blockquote>
<p>暴力解法没有利用【数组 <code>nums</code> 已经按照升序排列】这个条件。显然，</p>
<ul>
<li>  如果数组 <code>nums</code> 中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；</li>
<li>  如果数组 <code>nums</code> 中的所有数都是负数，那么将每个数平方后，数组会保持降序。</li>
</ul>
<p>这样一来，如果我们能够<strong>找到升序数组 <code>nums</code> 中负数与非负数的分界线</strong>，那么就可以用类似<strong>「归并排序」</strong>的方法了。</p>
<p>​        具体地，我们设 <strong>neg</strong> 为数组 nums 中负数与非负数的分界线。也就是说，<code>nums[0] ~ nums[neg]</code> 均为负数，而 <code>nums[neg+1] ~ nums[n−1]</code> 均为非负数。当我们将数组 nums 中的数平方后，那么 <code>nums[0] ~ nums[neg]</code> 单调递减，<code>nums[neg+1] ~ nums[n−1]</code> 单调递增。 </p>
<p>​        由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置  <code>neg</code> 和 <code>neg+1</code>，每次比较两个指针对应的数，选择较小的那个放入答案数组并移动指针。<strong>当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。</strong></p>
<p>示例一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-<span class="number">4</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、首先取到正数和负数的分界点 neg;</span><br><span class="line"><span class="number">2</span>、构建一个 nums 数组的平方数组 sq；可以看到neg右边数组升序，neg右边数组降序;</span><br><span class="line"><span class="number">3</span>、用两个指针left和right分别进行正序和倒序遍历，每次取出较小的值放入新的数组中！！！</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/25/LeetCode/977%E5%8F%8C%E6%8C%87%E9%92%88.png" alt="977双指针"></p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 归并排序 + 双指针 解法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  1、找到正数与负数的分隔点，</span></span><br><span class="line"><span class="comment">    *  2、由于nums数组是升序的，所以求平方之后，分隔点之前的数降序排列，分隔点之后的数升序排列</span></span><br><span class="line"><span class="comment">    *  3、进行归并排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="comment">// 1、找到正数与负数的分隔点。(0,neg)&lt;0； [neg, length)&gt;=0</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">               neg = i;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果整个数组全为负数，就将 length 设置为分界点</span></span><br><span class="line">           neg = nums.length;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、构建 nums 的平方数组 sq</span></span><br><span class="line">       <span class="type">int</span>[] sq = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           sq[i] = nums[i]*nums[i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、进行归并排序【双指针】【可以利用之前的 nums 数组，该数组现在没有用了，这里为了方便理解新建了数组】</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> neg-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> neg;</span><br><span class="line">       <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 结果值数组的指针</span></span><br><span class="line">       <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">while</span> (left&gt;=<span class="number">0</span> &amp;&amp; right&lt;sq.length)&#123;</span><br><span class="line">           <span class="keyword">if</span> (sq[left] &lt; sq[right])&#123;</span><br><span class="line">               res[t++] = sq[left--];</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               res[t++] = sq[right++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (left &lt; <span class="number">0</span> &amp;&amp; right &lt; sq.length)&#123;   <span class="comment">// 将右边剩余的元素全部追加到res数组中</span></span><br><span class="line">           res[t++] = sq[right++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (right &gt; nums.length-<span class="number">1</span> &amp;&amp; left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">           res[t++] = sq[left--];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h1 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h1><blockquote>
<p>  <strong>题目</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></p>
</blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5,4,4], nums2 = [9,4,9,8,4,6]</span><br><span class="line">输出：[9,4,4]</span><br></pre></td></tr></table></figure>



<h2 id="HashMap-解法"><a href="#HashMap-解法" class="headerlink" title="HashMap 解法"></a>HashMap 解法</h2><p><img src="/2021/07/25/LeetCode/350%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.png" alt="350两个数组的交集"></p>
<p><strong>思路：</strong></p>
<ol>
<li><p> 分别为两个数组 nums1 和 nums2 建立各自对应的 HashMap map1 和 map2，其中 key 为数组中出现过的值，value 为数组中 key 值出现过的次数。</p>
</li>
<li><p>数组的交集为：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map1&#123;4,3&#125; ∩ map2&#123;4,2&#125; ==&gt; &#123;4,2&#125;</span><br><span class="line">map1&#123;9,1&#125; ∩ map2&#123;9,2&#125; ==&gt; &#123;9,1&#125;</span><br><span class="line">map1&#123;5,1&#125; ∩ map2&#123;null&#125; ==&gt; null</span><br><span class="line">map1&#123;null&#125; ∩ map2&#123;8,1&#125; ==&gt; null</span><br><span class="line">map1&#123;null&#125; ∩ map2&#123;6,1&#125; ==&gt; null</span><br></pre></td></tr></table></figure></li>
<li><p> 所以得到的最终结果是：<code>[4,4,9]</code></p>
</li>
</ol>
<p><strong>代码思路：</strong></p>
<p><img src="/2021/07/25/LeetCode/350_fig1.gif" alt="fig1"></p>
<ol>
<li> 建立起 nums1 的 hashMap 表；</li>
<li> 遍历 nums2 ，每发现一个元素在 hashMap 中存在，代表这就是 nums1 和 nums2 的交集部分，将该元素保存到 result 数组中，将 hashMap 中对应的元素个数减一。 </li>
<li> 这样最后得到的 result 数组就是 nums1 和 nums2 的交集。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.shuzu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/27 10:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定两个数组，编写一个函数来计算它们的交集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      输入：nums1 = [1,2,2,1], nums2 = [2,2]</span></span><br><span class="line"><span class="comment"> *      输出：[2,2]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span></span><br><span class="line"><span class="comment"> *      输出：[4,9]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  思路一：暴力解法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  思路二：HashTable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution350</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums1 = &#123;<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] nums2 = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">Solution350</span>().intersect(nums1, nums2);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashTable 解法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个数组，用于保存交集的数组</span></span><br><span class="line">        <span class="type">int</span>[] res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &lt; nums2.length)&#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、建立 nums1 的 HashMap</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map1.containsKey(nums1[i]))&#123;</span><br><span class="line">                map1.put(nums1[i], <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map1.containsKey(nums1[i]))&#123;</span><br><span class="line">                map1.put(nums1[i], map1.get(nums1[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、遍历 nums2，与 map1 进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 存在重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (map1.containsKey(nums2[j]))&#123;</span><br><span class="line">                <span class="keyword">if</span> (map1.get(nums2[j]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 输出到结果数组中</span></span><br><span class="line">                    res[t] = nums2[j];</span><br><span class="line">                    ++t;</span><br><span class="line">                    <span class="comment">// 更新 map</span></span><br><span class="line">                    <span class="keyword">if</span> (map1.get(nums2[j])-<span class="number">1</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        map1.put(nums2[j], map1.get(nums2[j])-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 小于等于0</span></span><br><span class="line">                        map1.remove(nums2[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、仅截取需要的那一段</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h2><p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p>
<ol>
<li> 首先对两个数组进行排序，然后使用两个指针遍历两个数组。</li>
<li> 初始时，两个指针分别指向两个数组的头部。</li>
<li> 每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。</li>
<li> 当至少有一个指针超出数组范围时，遍历结束。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  双指针解法</span></span><br><span class="line"><span class="comment">    * 1.  首先对两个数组进行排序，然后使用两个指针遍历两个数组。</span></span><br><span class="line"><span class="comment">    * 2.  初始时，两个指针分别指向两个数组的头部。</span></span><br><span class="line"><span class="comment">    * 3.  每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，</span></span><br><span class="line"><span class="comment">    *     如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。</span></span><br><span class="line"><span class="comment">    * 4.  当至少有一个指针超出数组范围时，遍历结束。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">       <span class="comment">// 0、创建一个数组，用于保存交集的数组</span></span><br><span class="line">       <span class="type">int</span>[] res;</span><br><span class="line">       <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nums1.length &lt; nums2.length)&#123;</span><br><span class="line">           res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           res = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1、对两个数组进行排序</span></span><br><span class="line">       Arrays.sort(nums1);</span><br><span class="line">       Arrays.sort(nums2);</span><br><span class="line">       <span class="comment">// 2、初始化两个指针</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 3、遍历比较</span></span><br><span class="line">       <span class="keyword">while</span>(i&lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">           <span class="comment">// 如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。</span></span><br><span class="line">           <span class="keyword">if</span> (nums1[i] == nums2[j])&#123;</span><br><span class="line">               res[t] = nums1[i];</span><br><span class="line">               i++;</span><br><span class="line">               j++;</span><br><span class="line">               t++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果两个数字不相等，则将指向较小数字的指针右移一位，</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4、当至少有一个指针超出数组范围时，遍历结束。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5、仅截取需要的那一段</span></span><br><span class="line">       <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/25/%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-25 12:48:34" itemprop="dateCreated datePublished" datetime="2021-07-25T12:48:34+08:00">2021-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-02 23:39:02" itemprop="dateModified" datetime="2021-10-02T23:39:02+08:00">2021-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<ul>
<li>  分治算法</li>
<li>  动态规划算法</li>
</ul>
</blockquote>
<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="分治算法介绍"><a href="#分治算法介绍" class="headerlink" title="分治算法介绍"></a>分治算法介绍</h2><p>​        分治法是一种很重要的算法，顾名思义就是“分而治之”，即把一个复杂的问题分解成两个或更多相同或相似的子问题，再继续把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<p>​        分治思想是很多高效算法的基础，如排序算法（快速排序、归并排序），傅立叶变换（快速傅立叶变换）等。</p>
<h2 id="分治算法的基本步骤"><a href="#分治算法的基本步骤" class="headerlink" title="分治算法的基本步骤"></a>分治算法的基本步骤</h2><p>分治法在每一层递归上都有三个步骤：</p>
<ol>
<li> <strong>分解</strong>：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
<li> <strong>解决</strong>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；</li>
<li> <strong>合并</strong>：将各个子问题的解合并为原问题的解。</li>
</ol>
<p>分治（Divide-and-Conquer）算法的设计模式如下<strong>：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> |P| ≤ n0</span><br><span class="line">    then <span class="title function_">return</span><span class="params">(ADHOC(P))</span></span><br><span class="line">    <span class="comment">//将P分解为较小的子问题 P1 ,P2 ,…,Pk</span></span><br><span class="line">    <span class="keyword">for</span> i←1 to k</span><br><span class="line">        <span class="keyword">do</span> yi ← Divide-and-<span class="title function_">Conquer</span><span class="params">(Pi)</span>   递归解决Pi</span><br><span class="line">            T ← <span class="title function_">MERGE</span><span class="params">(y1,y2,…,yk)</span>   合并子问题</span><br><span class="line">            <span class="title function_">return</span><span class="params">(T)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  其中 <code>|P|</code> 表示问题 P 的规模；<code>n0</code> 是一个阈值，表示当问题 <code>P</code> 的规模不超过 <code>n0</code> 时，问题已容易直接解出，不必再继续分解；</li>
<li>  <code>ADHOC(P)</code> 是该分治法中的基本子算法，用于直接解决小规模的问题 <code>P</code>。因此，当 <code>P</code> 的规模不超过 <code>n0</code> 时直接用算法 <code>ADHOC(P)</code> 求解。</li>
<li>  算法 <code>MERGE(y1,y2,…,yk)</code> 是该分治法中的合并子算法，用于将 <code>P</code> 的子问题 <code>P1 ,P2 ,…,Pk</code> 的相应的解 <code>y1,y2,…,yk</code> 合并为 <code>P</code> 的解。</li>
</ul>
<h2 id="分治算法可以求解的一些经典问题"><a href="#分治算法可以求解的一些经典问题" class="headerlink" title="分治算法可以求解的一些经典问题"></a>分治算法可以求解的一些经典问题</h2><ul>
<li>  二分查找</li>
<li>  大整数乘法</li>
<li>  棋盘覆盖</li>
<li>  合并排序</li>
<li>  快速排序</li>
<li>  线性时间选择</li>
<li>  最接近点对问题</li>
<li>  循环赛日程表</li>
<li>  汉诺塔</li>
</ul>
<hr>
<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p><img src="/2021/07/25/%E7%AE%97%E6%B3%95/image-20210725192445350.png" alt="image-20210725192445350"></p>
<p><strong>要求：</strong></p>
<ul>
<li>  将A塔的所有圆盘移动到C塔；</li>
<li>  规定小圆盘上不能放大圆盘；</li>
<li>  在三根柱子之间一次只能移动一个圆盘。</li>
</ul>
<p><strong>分析</strong></p>
<ol>
<li> 如果只有一个盘，<code>A-&gt;C</code></li>
<li>如果有 2 个盘：<ul>
<li>  <code>A上-&gt;B</code></li>
<li>  <code>A下-&gt;C</code></li>
<li>  <code>B-&gt;C</code></li>
</ul>
</li>
<li>如果有 n（n&gt;=2）个盘，可以把整座塔视为两部分，即下层的一个盘和上层的 (n-1) 个盘。思路也非常简单，就是:<ul>
<li>  <code>A上 -&gt; B</code></li>
<li>  <code>A下 -&gt; C</code></li>
<li>  <code>B -&gt; C</code></li>
</ul>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.dac;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 19:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 汉诺塔游戏 --&gt;&gt; 分治算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      * 1.  如果只有一个盘，A-&gt;C</span></span><br><span class="line"><span class="comment"> *      * 2.  如果有 2 个盘：</span></span><br><span class="line"><span class="comment"> *      *     -   A上-&gt;B</span></span><br><span class="line"><span class="comment"> *      *     -   A下-&gt;C</span></span><br><span class="line"><span class="comment"> *      *     -   B-&gt;C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanoiTower</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        hanoiTower(<span class="number">5</span>,<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  该方法用于将 A塔上的所有圆盘转移到 C塔上</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num   总共有多少个盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A A塔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B B塔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> C C塔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoiTower</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C)</span>&#123;</span><br><span class="line">        <span class="comment">/* 如果只有一个圆盘， A-&gt;C */</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(A + <span class="string">&quot;-&gt;&quot;</span> + C);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果有2个以上的盘，A上-&gt;B A下-&gt;C B-&gt;C*/</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// A上(num-1)-&gt;B</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>, A, C, B);</span><br><span class="line">            <span class="comment">// A下(1)—&gt;C</span></span><br><span class="line">            System.out.println(A + <span class="string">&quot;-&gt;&quot;</span> + C);</span><br><span class="line">            <span class="comment">// B(全部)-&gt;C</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>, B, A, C); <span class="comment">// 只看第2个和第4个参数就能确定源头塔和目标塔</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>动态规划的基础就是穷举</strong></p>
<p>用于计算最大/小值，最优解等</p>
<p>动态规划是一个自底向上的类递归算法。</p>
<p><strong>动态规划就是 【选/不选】 的问题！！！</strong></p>
<h2 id="最优解问题"><a href="#最优解问题" class="headerlink" title="最优解问题"></a>最优解问题</h2><p>我们通过一个实际问题来学习动态规划。</p>
<blockquote>
<p>  <strong>题目：</strong></p>
</blockquote>
<p>下图共有 7 项任务，横轴表示每项任务的工作时间，红字表示完成每项任务可以得到的报酬。比如任务一需要在 <code>1~4</code> 时间段进行，任务二需要在 <code>3~5</code> 时间段进行。也就是说想要完成任务一就必须放弃任务二、三、五，因为这几个任务的时间段冲突了。现在的问题是想知道从 0~11 时间段内最高报酬的任务组合是什么。</p>
<img src="/2021/07/25/%E7%AE%97%E6%B3%95/image-20210727171453446.png" alt="image-20210727171453446" style="zoom:50%;">



<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<p><strong>动态规划就是【选/不选】的问题！！！</strong></p>
<p>我们用 <strong>OPT(i)</strong> 函数表示包含第 i 个任务的情况下报酬最高的任务组合。【OPT：最优解】</p>
<p>比如选了任务 ⑧，肯定就不能再选任务 ⑥ 和 ⑦ 了。这时就会存在两种情况，到底是选择任务 ⑧ 后得到的总薪资最高还是不选任务⑧得到的总薪资最高呢？这就是 【选/不选】的问题。<br>$$<br>OPT(8) = max<br>    \begin{cases}<br>        V_8+OPT(5)    &amp;\text{// 选⑧就要放弃⑥和⑦}<br>    \\<br>        OPT(7)    &amp;\text{//不选⑧就相当于放弃⑧}<br>    \end{cases}<br>$$</p>
<blockquote>
<p>  <strong>公式：</strong></p>
</blockquote>
<p>以此类推，可以得到一个公式，<br>$$<br>OPT(i) = max<br>    \begin{cases}<br>        V_i+OPT(prev(i))    &amp;\text{// prev(i)表示在选择了第i个任务后剩余任务中的最优解下标}<br>    \\<br>        OPT(i-1)    &amp;\text{//不选}<br>    \end{cases}<br>$$</p>
<ol>
<li><p>建立 <strong>V<del>i</del> 表</strong>与 <strong>prev(i) 表</strong>如下：</p>
<ul>
<li><p>  <strong>V<del>i</del></strong> 表示第 i 个任务的薪资；</p>
</li>
<li><p><strong>prev(i)</strong> 表示选择第 i 个任务后，剩下任务中的最优解下标。</p>
<table>
<thead>
<tr>
<th align="center">i</th>
<th align="center">V<del>i</del></th>
<th align="center">prev(i)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>1</code></td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>2</code></td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>3</code></td>
<td align="center">8</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>4</code></td>
<td align="center">4</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>5</code></td>
<td align="center">6</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>6</code></td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>7</code></td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><code>8</code></td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>建立 OPT(i) 最优解的树形结构【递归思路】。</p>
<p> <img src="/2021/07/25/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="动态规划"></p>
<ul>
<li>  我们可以看到，在递归【自顶向下】的过程中，我们会多次用到已经计算过的 OPT(i) 的值，如果能够将已计算过的值保存起来，在需要使用的时候直接调用，就可以节省很大的计算性能。</li>
<li>  所以可以采用动态规划的算法，【自底向上】建立一个动态规划的数组，保存从 <code>OPT(0)~OPT(n)</code> 的所有值。</li>
</ul>
</li>
<li><p>建立动态规划数组。</p>
<table>
<thead>
<tr>
<th align="center">OPT(0)</th>
<th align="center">OPT(1)</th>
<th align="center">OPT(2)</th>
<th align="center">OPT(3)</th>
<th align="center">OPT(4)</th>
<th align="center">OPT(5)</th>
<th align="center">OPT(6)</th>
<th align="center">OPT(7)</th>
<th align="center">OPT(8)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">10</td>
<td align="center">13</td>
</tr>
</tbody></table>
</li>
</ol>
<p><img src="/2021/07/25/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E6%9C%80%E9%AB%98%E8%96%AA%E8%B5%84%E7%BB%84%E5%90%88.png" alt="动态规划_最高薪资组合"></p>
<hr>
<h2 id="动态规划算法介绍"><a href="#动态规划算法介绍" class="headerlink" title="动态规划算法介绍"></a>动态规划算法介绍</h2><ol>
<li> <strong>动态规划（Dynamic Programming）</strong>算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法。</li>
<li> 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li> 与分治法不同的是，<strong>适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。</strong>即下一个子问题的求解是建立在上一个子问题解的基础上得到的。</li>
<li> 动态规划可以通过<strong>填表的方式</strong>来逐步推进，得到最优解.</li>
</ol>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>给定一个固定容量的背包，若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。</p>
<p><strong>需求：</strong></p>
<p>有一个背包，容量为 4 磅，现有如下物品：</p>
<ul>
<li>  要求装入的背包的<u>总价值最大</u>，并且<u>重量不超出</u>。</li>
<li>  要求<u>装入的物品不能重复</u>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>物品</strong></th>
<th align="center"><strong>重量</strong></th>
<th align="center"><strong>价格</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">吉他(G)</td>
<td align="center">1</td>
<td align="center">1500</td>
</tr>
<tr>
<td align="center">音响(S)</td>
<td align="center">4</td>
<td align="center">3000</td>
</tr>
<tr>
<td align="center">电脑(L)</td>
<td align="center">3</td>
<td align="center">2000</td>
</tr>
</tbody></table>
<p><strong>背包问题分类：</strong></p>
<p>背包可分为 <strong>01背包</strong> 和 <strong>完全背包</strong>：</p>
<ul>
<li>  01 背包：同类物品只能放入一件，背包的物品种类不能重复。</li>
<li>  完全背包：每类物品可以放入多件到背包中。</li>
</ul>
<p><strong>思路分析：</strong></p>
<p>这里的问题属于 <strong>01背包</strong>，即每种物品最多放一件。【无限背包可以转化为01背包解决】</p>
<ul>
<li>  给定的 n 个物品，每次遍历到的第 i 个物品，根据 <code>w[i]</code> 和 <code>v[i]</code> 来确定是否需要将该物品放入背包中。</li>
<li>  设 <code>v[i]</code>、<code>w[i]</code> 分别为第 <code>i</code> 个物品的价值和重量，<code>C</code> 为背包的容量。</li>
<li>再令 <code>v[i][j]</code> 表示在前 <code>i</code> 个物品中能够装入容量为 <code>j</code> 的背包中的最大价值。则我们有下面的结果：<ol>
<li> <code>vi=v0=0</code>，表示填入表第一行和第一列是 0</li>
<li> 当 <code>w[i]&gt; j</code> 时 <code>vi=vi-1</code>，当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</li>
<li> 当 <code>j&gt;=w[i]</code> 时，<code>vi=max&#123;vi-1, v[i]+vi-1]&#125;</code> </li>
</ol>
</li>
</ul>
<p>// 当 准备加入的新增的商品的容量小于等于当前背包的容量,</p>
<p>// 装入的方式:</p>
<p>v[i-1][j]： 就是上一个单元格的装入的最大值</p>
<p>v[i] : 表示当前商品的价值 </p>
<p>v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值</p>
<p>当j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} :</p>
<p>w[i]：第 i 个物品的重量</p>
<p>v[i]：第  i 件物品的价值</p>
<h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、确定dp数组以及下标的含义</span><br><span class="line">2、确定动态转移方程</span><br><span class="line">3、dp数组如何初始化</span><br><span class="line">4、确定遍历顺序</span><br><span class="line">5、举例推导dp数组</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/" class="post-title-link" itemprop="url">MySQL高级</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-23 15:24:27" itemprop="dateCreated datePublished" datetime="2021-07-23T15:24:27+08:00">2021-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-06 14:24:47" itemprop="dateModified" datetime="2021-10-06T14:24:47+08:00">2021-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h1><h2 id="1-1-MySQL逻辑架构"><a href="#1-1-MySQL逻辑架构" class="headerlink" title="1.1    MySQL逻辑架构"></a>1.1    MySQL逻辑架构</h2><p>MySQL 可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构</strong>将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。其主要逻辑架构可分为四层，从上到下分别是：</p>
<blockquote>
<ol>
<li>  <strong>连接层</strong></li>
<li>  <strong>服务层</strong></li>
<li>  <strong>引擎层</strong></li>
<li>  <strong>存储层</strong></li>
</ol>
</blockquote>
<p><img src="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/1411859-20180617124155105-273948974.png" alt="img"></p>
<p><img src="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/1411859-20180617123859211-1860022440.png" alt="img"></p>
<h3 id="1-1-1-连接层"><a href="#1-1-1-连接层" class="headerlink" title="1.1.1    连接层"></a>1.1.1    连接层</h3><ul>
<li>  <strong>连接层主要处理客户端与 MySQL 服务端的连接、授权认证、连接安全等问题</strong>。包含本地 socket 通信和大多数基于客户端/服务端工具实现的网络通信。</li>
<li>  主要完成一些类似于连接处理、授权认证、及相关的安全方案。同样在该层上可以实现基于 SSL 的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li>  在该层上<strong>引入了线程池的概念</strong>，为通过认证安全接入的客户端提供线程。</li>
</ul>
<hr>
<h3 id="1-1-2-服务层"><a href="#1-1-2-服务层" class="headerlink" title="1.1.2    服务层"></a>1.1.2    服务层</h3><table>
<thead>
<tr>
<th>名字</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Management Serveices &amp; Utilities</strong></td>
<td>系统管理和控制工具</td>
</tr>
<tr>
<td><strong>SQL Interface</strong></td>
<td>SQL 接口。接受用户的SQL 命令，并且返回用户需要查询的结果。</td>
</tr>
<tr>
<td><strong>Parser</strong></td>
<td>解析器。SQL 命令传递到解析器的时候会被解析器验证和解析</td>
</tr>
<tr>
<td><strong>Optimizer</strong></td>
<td>查询优化器。SQL 语句在查询之前会使用查询优化器对查询进行优化。</td>
</tr>
<tr>
<td><strong>Cache 和Buffer</strong></td>
<td>查询缓存。</td>
</tr>
</tbody></table>
<h4 id="1、Management-Serveices-amp-Utilities：系统管理控制工具"><a href="#1、Management-Serveices-amp-Utilities：系统管理控制工具" class="headerlink" title="1、Management Serveices &amp; Utilities：系统管理控制工具"></a>1、Management Serveices &amp; Utilities：系统管理控制工具</h4><p>可以看做是类似于 Hadoop 中的 Zookeeper，或者是 SpringCloud 中的配置中心，主要作用是协调整管理个系统的各个模块。</p>
<hr>
<h4 id="2、SQL-Interface：SQL-接口"><a href="#2、SQL-Interface：SQL-接口" class="headerlink" title="2、SQL Interface：SQL 接口"></a>2、SQL Interface：SQL 接口</h4><p>类似于 MVC 三层架构中的 Controller 层，只是负责接收请求和返回最终的结果，具体的业务逻辑交给更底层的服务去做。比如 <code>select ... from ...</code> 就会调用 SQL Interface。</p>
<hr>
<h4 id="3、Parser：解析器"><a href="#3、Parser：解析器" class="headerlink" title="3、Parser：解析器"></a>3、Parser：解析器</h4><p>SQL Interface 中的 SQL 命令传递到解析器的时候会被解析器验证和解析。主要功能有：</p>
<ul>
<li>  <strong>验证</strong>：对接收的 SQL 语句进行语义和语法的分析，如果在分解构成中遇到错误，那么就说明这个 SQL 语句是不合理的，验证失败，不继续网下执行，直接抛出错误。</li>
<li>  <strong>解析</strong>：如果验证成功，则根据语义和语法，将 SQL 语句划分为不同的操作类型，然后进行针对性的转发到后续步骤。比如查询语句就转发到查询对应的服务，更新操作就转发到更新对应的服务。</li>
</ul>
<hr>
<h4 id="4、Optimizer：查询优化器"><a href="#4、Optimizer：查询优化器" class="headerlink" title="4、Optimizer：查询优化器"></a>4、Optimizer：查询优化器</h4><ul>
<li>  SQL 语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 SQL 语句，根据客户端请求的 SQL 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何执行这个 SQL 语句。（机器认为最优的数据检索方式，但 BDA 不一定认为是最优的）</li>
<li>  查询优化器就类似于指令重排，对于开发人员来说，写一条 SQL 可能自我感觉良好，性能天下第一，但是对于底层机器来说，它有自己的优化标准，经过查询优化器优化后的 SQL 语句的执行顺序并不一定与开发人员设计的 SQL 执行顺序相同。</li>
<li>  当客户端向 MySQL 服务器请求一条 SQL ，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL_Query_Qptimizer 时， MySQL_Query_Qptimizer 首先会对整条 SQL 进行优化，处理掉一些常量表达式的预算，直接转换成常量值。并对 SQL 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。</li>
</ul>
<hr>
<h4 id="5、Cache和Buffer：查询缓存"><a href="#5、Cache和Buffer：查询缓存" class="headerlink" title="5、Cache和Buffer：查询缓存"></a>5、Cache和Buffer：查询缓存</h4><p>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等。</p>
<hr>
<h3 id="1-1-3-引擎层"><a href="#1-1-3-引擎层" class="headerlink" title="1.1.3    引擎层"></a>1.1.3    引擎层</h3><ul>
<li>  存储引擎主要负责数据存储和提取，存储引擎不会去解析 sql，不同存储引擎之间不会通讯，只会简单地响应上层服务器的请求。</li>
<li>  存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。</li>
<li>  存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层<strong>数据存储引擎的插件式管理</strong>。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL <strong>可插拔存储引擎的特色</strong>。</li>
<li>  可插拔的存储引擎的实现，让 MySQL 在处理不同的业务逻辑时，可以根据实际应用场景选择效率尽可能高的存储引擎。这就是 MySQL 相较于其它同类数据库产品的最大优势。</li>
<li>  注意：<strong>存储引擎是基于表的，而不是数据库</strong>。</li>
</ul>
<hr>
<h3 id="1-1-4-存储层"><a href="#1-1-4-存储层" class="headerlink" title="1.1.4    存储层"></a>1.1.4    存储层</h3><p>数据存储层，主要是将数据存储在硬件层面的文件系统上，并与存储引擎交互。</p>
<hr>
<h2 id="1-2-存储引擎"><a href="#1-2-存储引擎" class="headerlink" title="1.2    存储引擎"></a>1.2    存储引擎</h2><blockquote>
<p>  <strong>如何查看 MySQL 支持的存储引擎</strong></p>
</blockquote>
<p><img src="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/image-20210723163415302.png" alt="image-20210723163415302"></p>
<blockquote>
<p>  <strong>MyISAM vs. InnoDB</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">对比项</th>
<th align="center">MyISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主/外键</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">事务</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">行/表锁</td>
<td align="center">表锁</td>
<td align="center">行锁</td>
</tr>
<tr>
<td align="center">索引</td>
<td align="center">非聚簇索引</td>
<td align="center">聚簇索引</td>
</tr>
<tr>
<td align="center">表空间</td>
<td align="center">小</td>
<td align="center">大</td>
</tr>
<tr>
<td align="center">行数统计</td>
<td align="center">MyISAM保存表的具体行数</td>
<td align="center">InnoDB保存表的具体行数</td>
</tr>
<tr>
<td align="center">关注点</td>
<td align="center">性能</td>
<td align="center">事务</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>行锁</strong>：操作时只锁某一行，不会对其它行产生影响。<strong>适合高并发的操作</strong>。</li>
<li>  <strong>表锁</strong>：即使只操作一条记录也会锁住整张表，不适合高并发的操作。【这是 MyISAM 被逐渐淘汰的主要原因之一】</li>
<li>  既缓存索引又缓存真实数据对内存要求高，而内存大小对性能有着决定性的影响，已使用的内存越大，性能就越差。</li>
</ul>
<hr>
<h2 id="1-3-大致查询流程"><a href="#1-3-大致查询流程" class="headerlink" title="1.3    大致查询流程"></a>1.3    大致查询流程</h2><p>MySQL 查询的流程大致是：</p>
<ol>
<li> MySQL 客户端通过协议与 MySQL 服务器建连接；</li>
<li> 发送查询语句，先查询缓存，如果命中，直接返回结果；</li>
<li>否则进行语句解析，也就是说，在解析查询之前，服务器会先访问查询缓存（Query Cache）——它存储了 SQL 语句以及<br> 相应的查询结果集。</li>
<li> 如果某个查询结果已经位于缓存中，服务器就不会再对 SQL 语句进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。</li>
</ol>
<hr>
<h1 id="SQL-的执行顺序"><a href="#SQL-的执行顺序" class="headerlink" title="SQL 的执行顺序"></a>SQL 的执行顺序</h1><p>随着 MySQL 版本的更新换代，其优化器也在不断的升级，优化器会根据同一条 SQL 语句的不同执行顺序产生的性能消耗不同而动<br>态调整执行顺序。下面是比较常见的一种的查询顺序：</p>
<blockquote>
<p>  <strong>SQL语句</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="operator">&lt;</span> select_list <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="operator">&lt;</span> left_table <span class="operator">&gt;</span> </span><br><span class="line"><span class="operator">&lt;</span> join_type <span class="operator">&gt;</span> <span class="keyword">JOIN</span> </span><br><span class="line">  <span class="operator">&lt;</span> right_table <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line">  <span class="operator">&lt;</span> join_condition <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="operator">&lt;</span> where_condition <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">  <span class="operator">&lt;</span> group_by_list <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">  <span class="operator">&lt;</span> having_condition <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">  <span class="operator">&lt;</span> order_by_condition <span class="operator">&gt;</span> </span><br><span class="line">LIMIT </span><br><span class="line">  <span class="operator">&lt;</span> limit_number <span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>底层执行顺序</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  <span class="operator">&lt;</span> left_table <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">ON</span>  <span class="operator">&lt;</span> join_condition <span class="operator">&gt;</span> </span><br><span class="line"><span class="operator">&lt;</span> join_type <span class="operator">&gt;</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span> right_table <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span> where_condition <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span> group_by_list <span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">HAVING</span> <span class="operator">&lt;</span> having_condition <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span> select_list <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span> order_by_condition <span class="operator">&gt;</span></span><br><span class="line">LIMIT <span class="operator">&lt;</span> limit_number <span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/image-20210724120203199.png" alt="image-20210724120203199"></p>
<h1 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h1><p>基础的 Join 关系有 4 种：</p>
<blockquote>
<ol>
<li> 内连接</li>
<li> 左外连接</li>
<li> 右外连接</li>
<li> 全外连接</li>
</ol>
</blockquote>
<p>由此演化出来的常见的 Join 关系有 7 种，如图所示：</p>
<img src="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/image-20210724120245430.png" alt="image-20210724120245430" style="zoom:100%;">





<h2 id="3-1-内连接"><a href="#3-1-内连接" class="headerlink" title="3.1    内连接"></a>3.1    内连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tb_A A </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> tb_B B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>





<h2 id="3-2-左外连接"><a href="#3-2-左外连接" class="headerlink" title="3.2    左外连接"></a>3.2    左外连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tb_A A </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tb_B B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<p>左外连接保存 LEFT_TABLE（这里是 tb_A） 中的全部记录，对于 tb_A 中存在而 tb_B 中不存在的记录，则用 null 填充。所以查询结果中可能会存在这样一类记录。</p>
<table>
<thead>
<tr>
<th align="center">A.id</th>
<th align="center">A.name</th>
<th align="center">B.id</th>
<th align="center">B.dep</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">余则成</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">（A独有）</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">王大治</td>
<td align="center">5</td>
<td align="center">体育部</td>
<td align="center">（A、B共有）</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-3-左外连接扩展"><a href="#3-3-左外连接扩展" class="headerlink" title="3.3    左外连接扩展"></a>3.3    左外连接扩展</h2><p>在左外连接的基础上，只选择左表独有的数据。（即对于两表的公共数据不要）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tb_A A </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tb_B B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key</span><br><span class="line"><span class="keyword">WHERE</span> B.KEY <span class="keyword">IS</span> <span class="keyword">NULL</span> ;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-4-右外连接"><a href="#3-4-右外连接" class="headerlink" title="3.4    右外连接"></a>3.4    右外连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tb_A A </span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> tb_B B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<p>右外连接保存 RIGHT_TABLE（这里是 tb_B） 中的全部记录，对于 tb_B 中存在而 tb_A 中不存在的记录，则用 NULL 填充。所以查询结果中可能会存在这样一类记录。</p>
<table>
<thead>
<tr>
<th align="center">A.id</th>
<th align="center">A.name</th>
<th align="center">B.id</th>
<th align="center">B.dep</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">7</td>
<td align="center">“市场部”</td>
<td align="center">B独有</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">王大治</td>
<td align="center">5</td>
<td align="center">体育部</td>
<td align="center">（A、B共有）</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-5-右外连接扩展"><a href="#3-5-右外连接扩展" class="headerlink" title="3.5    右外连接扩展"></a>3.5    右外连接扩展</h2><p>在右外连接的基础上，只选择右表独有的数据。（即对于两表的公共数据不要）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tb_A A </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tb_B B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key</span><br><span class="line"><span class="keyword">WHERE</span> A.KEY <span class="keyword">IS</span> <span class="keyword">NULL</span> ;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-6-全外连接"><a href="#3-6-全外连接" class="headerlink" title="3.6    全外连接"></a>3.6    全外连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tb_A A </span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> tb_B B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<p>全外连接会保存 LEFT_TABLE 和 RIGHT_TABLE 中共有的数据和独有的数据。查询结果的类型如下：</p>
<table>
<thead>
<tr>
<th align="center">A.id</th>
<th align="center">A.name</th>
<th align="center">B.id</th>
<th align="center">B.dep</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">7</td>
<td align="center">“市场部”</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">“余则成”</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">“派大星”</td>
<td align="center">4</td>
<td align="center">“营销部”</td>
</tr>
</tbody></table>
<h2 id="3-7-全外连接扩展"><a href="#3-7-全外连接扩展" class="headerlink" title="3.7    全外连接扩展"></a>3.7    全外连接扩展</h2><p>在全外连接的基础上，只选择左表和右表独有的部分记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tb_A A </span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> tb_B B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br><span class="line"><span class="keyword">WHERE</span> A.key <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">OR</span> B.key <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>



<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p><strong>MySQL 不支持 FULL OUTER JOIN 查询</strong>（Oracle 支持），但是 ，所以 MySQL 中要想实现同样的效果，需要使用 <strong>union</strong> 关键字。</p>
<ul>
<li>  UNION 操作符用于合并两个或多个 SELECT 语句的结果。</li>
<li>  UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</li>
<li>  默认地，UNION 操作符选取不同的值（默认去重）。如果允许重复的值，请使用 UNION ALL。</li>
</ul>
<hr>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul>
<li>  超链接：<a href>MySQL索引</a></li>
</ul>
<hr>
<h1 id="MySQL-锁机制"><a href="#MySQL-锁机制" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h1><ul>
<li>  超链接：<a href>MySQL锁机制</a></li>
</ul>
<hr>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><blockquote>
<p>  <strong>SQL 性能下降的表现</strong>：</p>
</blockquote>
<ol>
<li> 执行时间长</li>
<li> 等待时间长</li>
</ol>
<blockquote>
<p>  <strong>SQL 性能下降的原因：</strong></p>
</blockquote>
<ol>
<li> SQL 语句写得烂</li>
<li> 索引失效</li>
<li> 关联查询太多join（设计缺陷或不得已的需求）【某些业务涉及的表太多，需要关联查询太多】</li>
<li> 服务器调优及各个参数设置不合理（缓存、线程数等）</li>
<li> ….</li>
</ol>
<blockquote>
<p>  <strong>MySQL 的常见瓶颈</strong></p>
</blockquote>
<ol>
<li> <strong>CPU</strong>：CPU 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候。</li>
<li> <strong>IO</strong>：磁盘 IO 瓶颈发生在装入数据远大于内存容量的时候。</li>
<li> <strong>服务器硬件的性能瓶颈</strong>：top，free，iostat 和 vmstat 来查看系统的性能状态。</li>
</ol>
<hr>
<h1 id="主从复制（MySQL-集群）"><a href="#主从复制（MySQL-集群）" class="headerlink" title="主从复制（MySQL 集群）"></a>主从复制（MySQL 集群）</h1><img src="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/image-20210814164014357.png" alt="image-20210814164014357" style="zoom: 50%;">

<blockquote>
<p>  <strong>一主多从</strong></p>
</blockquote>
<ul>
<li>  主节点用来执行写操作，从节点用于执行读操作</li>
<li>  所有在主节点上执行的写操作，都会被写入主节点的日志文件 <strong>Binary_log</strong> 中；</li>
<li>  从节点通过 IO 读取到主节点的日志文件，复制到 <strong>Relay_log</strong> 中，然后由当前备机执行日志文件，即可完成从机数据的同步。</li>
</ul>
<blockquote>
<p>  <strong>读写分离：</strong></p>
</blockquote>
<ul>
<li>  因为 MySQL 只会将主节点的 <code>Binary_log</code> 文件同步到从节点，而不会反过来同步。因此也就引出了读写分离的问题。</li>
<li>  如果要保证主从节点间的数据一致，<strong>写操作就只能发生在主节点</strong>，而读操作可以在集群中的任意节点上进行。</li>
</ul>
<hr>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="为什么要进行分库分表？"><a href="#为什么要进行分库分表？" class="headerlink" title="为什么要进行分库分表？"></a>为什么要进行分库分表？</h2><p>当单张表中的数据量过大时，整体的查询效率就会降低得非常明显。这时为了提升查询效率，就要将一个表中的数据分散到多个数据库的多个表中。</p>
<h2 id="多大数据量需要进行分库分表？"><a href="#多大数据量需要进行分库分表？" class="headerlink" title="多大数据量需要进行分库分表？"></a>多大数据量需要进行分库分表？</h2><p>阿里开发手册中建议：一个表的数据量超过 500W 条或者数据文件超过 2G，就要考虑进行分库分表了。</p>
<h2 id="分库分表的方式"><a href="#分库分表的方式" class="headerlink" title="分库分表的方式"></a>分库分表的方式</h2><ul>
<li>  分库分表包括<strong>分库</strong>和<strong>分表</strong>两个部分，而这两个部分统称为<strong>数据分片</strong>，其目的都是将数据拆分成不同的存储单元。</li>
<li>  另外，从拆分的角度上，可以划分为<strong>垂直分片</strong>和<strong>水平分片</strong>。</li>
</ul>
<h3 id="垂直分片"><a href="#垂直分片" class="headerlink" title="垂直分片"></a>垂直分片</h3><ul>
<li>  按照业务来对数据进行分片，又称为纵向分片。它的核心理念就是专库专用。</li>
<li>  在拆分之前，一个数据库由多张数据表组成，每张表对应不同的业务，而拆分之后，则是按照业务将表归类，分布到不同的数据库或表中，从而将压力分散至不同的数据库或表。</li>
<li>  例如：下图将用户表和订单表垂直分片到不同的数据库。</li>
</ul>
<img src="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/image-20210814175705485.png" alt="image-20210814175705485" style="zoom:50%;">

<p>垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对业务需求快速变化的。而且，也无法真正地解决单点数据库的性能瓶颈。垂直分片可以缓解数据量和访问量带来的问题，但无法根治。如果垂直分片之后，表中的数据量依然超过单节点所能承受的阈值，则需要水平分片来进一步处理。</p>
<h3 id="水平分片"><a href="#水平分片" class="headerlink" title="水平分片"></a>水平分片</h3><ul>
<li>  水平分片又称为横向分片。</li>
<li>  相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某几个字段，根据某种规则将数据分散到多个库或表中，每个分片仅包含数据的一部分。</li>
<li>  水平分片从理论上突破了单击数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案</li>
<li>  如下图所示，根据取余的策略，将一张表中的数据分散到了两张表中保存。</li>
</ul>
<img src="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/image-20210814180055407.png" alt="image-20210814180055407" style="zoom:50%;">





<blockquote>
<p>  <strong>常用的水平分片的策略：</strong></p>
</blockquote>
<p><strong>取模：</strong></p>
<ul>
<li>  优点：均匀存放数据。</li>
<li>  缺点：扩容非常麻烦</li>
</ul>
<p><strong>按范围划分：</strong>比如，一个月分一个库。</p>
<ul>
<li>  优点：比较容易扩容，</li>
<li>  缺点：数据分布不够均匀。对于大部分的行业来讲，存在淡季和旺季，淡季数据量较少，单独占一个库过于奢侈，旺季数据量大，可能会出现一个库存不在。</li>
</ul>
<h2 id="分库分表后，SQL语句的执行流程是怎样的？"><a href="#分库分表后，SQL语句的执行流程是怎样的？" class="headerlink" title="分库分表后，SQL语句的执行流程是怎样的？"></a>分库分表后，SQL语句的执行流程是怎样的？</h2><blockquote>
<p>  <strong>分库分表后的执行流程</strong></p>
</blockquote>
<img src="/2021/07/23/MySQL%E9%AB%98%E7%BA%A7/image-20210814172920328.png" alt="image-20210814172920328" style="zoom:50%;">

<p>分布分表后，在执行查询语句时，由于查询语句中使用的是逻辑上的表，但是在分库分表后，逻辑上的表结构实际存储在多个库的多个表中。</p>
<ol>
<li> 在执行 SQL 语句时，首先依然需要解析器解析和查询优化；</li>
<li> 但是在查询时，由于数据保存在多张表中，所以需要进行 SQL 路由，根据查询条件去不同库的表中查询；</li>
<li> 这时候需要使用到真实的库名称和表名称，所以会有一步 SQL 改写的过程，将逻辑上的 SQL 语句改写成一条或多条真正要去执行查询的 SQL 语句，然后再执行查询；</li>
<li> 得到查询结果后，可能查询结果来自多个库的多张表，所以还需要将这多个结果进行归并，最后才能得到一个唯一的结果返回给客户端。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">MySQL索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-23 15:19:07" itemprop="dateCreated datePublished" datetime="2021-07-23T15:19:07+08:00">2021-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-21 21:55:41" itemprop="dateModified" datetime="2021-10-21T21:55:41+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h1><p><strong>定义：</strong></p>
<ol>
<li> 索引是一种<strong>文件</strong>。</li>
<li> 索引是一种<strong>数据结构</strong>。</li>
</ol>
<blockquote>
<p>  <strong>文件：</strong></p>
</blockquote>
<p>索引是一个文件，它是要占据物理空间的。</p>
<ul>
<li>  对于聚簇索引（如 InnoDB）而言，索引表中直接保存了对应的真实数据表中的所有的记录，所以 InnoDB 持久化后只会得到一个文件，即索引表数据和真实数据表数据都保存在一起。</li>
<li>  对于非聚簇索引（如 MyISAM）而言，索引表中保存了数据表中对应记录的引用（也就是主键），所以对于 MyISAM 而言，持久化后会得到两个文件，一个文件用于保存索引表的数据，另一个文件用于保存真实表的数据。</li>
</ul>
<blockquote>
<p>  <strong>数据结构：</strong></p>
</blockquote>
<ul>
<li>  索引是一种数据结构。可以理解为“<strong>排好序的可以实现快速查找的数据结构</strong>”，能够用于提高数据查找的效率。</li>
<li>  索引的具体实现可以有多种，常见的有 B-树、B+树、AVL树、Hash 等等。</li>
<li>  通过对某些列建立索引，可以避免对数据的全局扫描，以更少的查找次数快速找到要查询的数据。</li>
</ul>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<p>索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。MySQL 索引的建立对于 MySQL 的高效运行是很重要的，索引可以大大提高 MySQL 的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。</p>
<blockquote>
<p>  <strong>解释说明：</strong></p>
</blockquote>
<p><strong>Before：</strong></p>
<ul>
<li>  如果没有索引，想要查询 <code>tb_user</code> 表中 <code>name=&quot;张三&quot;</code> 的这条数据，我们需要挨个查询 <code>tb_user</code> 表中的所有数据，直到找到 <code>name=&quot;张三&quot;</code> 的数据。当然这种查询存在随机性，可能第一个就直接查到了，也有可能直到最后一个才查到，平均时间复杂度为 <code>O(n)</code> 。</li>
</ul>
<p><strong>After：</strong></p>
<ul>
<li>  假设我们为 name 这一列建立了一个索引（假设索引的数据结构为 B+Tree），这时 name 列中的所有数据就会按照某种规则映射到 B+Tree 上，想要查询 <code>name=&quot;张三&quot;</code> 的这条数据时，用 <code>“张三”</code> 对应的值与 B+Tree 第一层的多个范围空间进行对比，找到满足条件的范围进入下一层对比，这样只需要很少的几次比较，就能够定位到 “张三” 在 BTree 中的位置，再从索引直接关联到数据库中真实数据的内存地址，即完成了一次快速的查询。</li>
</ul>
<blockquote>
<p>  <strong>索引会影响到两大功能的执行效率：</strong></p>
</blockquote>
<ol>
<li> 排序：<code>ORDER BY</code> </li>
<li> 查找：<code>WHERE；HAVING</code></li>
</ol>
<p><strong>解释：</strong></p>
<ul>
<li>  查找时，如果对应的字段建立了索引，就不会出现在某张表中挨个查找的情况，而是跳着查找，效率更高。</li>
<li>  排序时，因为索引结构本身就是有序的，所以对应的字段直接按照索引顺序正序或倒序排列即可。</li>
</ul>
<hr>
<h1 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2. 优缺点"></a>2. 优缺点</h1><blockquote>
<p>  <strong>优点</strong>：</p>
</blockquote>
<ol>
<li><strong>索引能提高数据检索速率</strong>，对于一些常用于查询的字段，如果将其设置为索引，能大大地提高查询的速率。<ul>
<li>  将频繁使用的字段就将其设置为索引，比不设索引时查询速度要快。</li>
</ul>
</li>
<li> <strong>对索引列的数据进行排序，排序的成本将大大降低</strong>。</li>
</ol>
<blockquote>
<p>  <strong>缺点</strong>：</p>
</blockquote>
<ol>
<li> <strong>需要维护额外的索引表的空间</strong>。索引也是一张表，该表保存了索引字段（主键天生就是索引字段），并指向实体表中的记录。所以索引也是要占用空间的。</li>
<li><strong>在发生写操作时，创建和维护索引需要额外的时间</strong>。虽然索引大大提高了查询速度，但同时会降低写操作的执行效率。比如在对表进行 CRUD 操作时，不仅需要更新表中的数据，还要更新对应的索引表。<ul>
<li>  对于 UPDATE 操作，记录变更后索引字段在索引表中的位置就可能发生变化，需要更新索引表。</li>
<li>  对于 INSERT 操作，添加记录后需要将新记录的索引字段加到索引表中。</li>
<li>  DELETE 同上。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h1><h2 id="按应用层次分类"><a href="#按应用层次分类" class="headerlink" title="按应用层次分类"></a>按应用层次分类</h2><ul>
<li>  <strong>单列索引</strong>：一个索引只包含单个列，一个表可以有多个单列索引。</li>
<li>  <strong>复合索引</strong>：即一个索引包含多个列。</li>
<li>  <strong>唯一索引</strong>：索引列的值必须唯一（即用于建立索引的列必须符合 UNIQUE），但<strong>允许有空值</strong>。【主键就是一种唯一索引】</li>
</ul>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><ul>
<li>  MySQL 可以使用多个字段同时建立一个索引，叫做复合索引。</li>
<li>  <strong>在复合索引中，如果想要命中索引，筛选条件需要严格按照建立索引时的字段顺序，否则无法命中索引</strong>。</li>
</ul>
<blockquote>
<p>   <strong>具体原因：</strong></p>
</blockquote>
<ul>
<li>  MySQL 使用索引时需要筛选条件按照索引的创建方式严格有序。</li>
<li>  假设现在建立了 <code>(id, name，age)</code> 的联合索引，那么索引的排序为： 先按照 id 排序，如果 id 相同，再按照 name 排序；如果 name 的值也相同，再按照 age 排序，以此类推。</li>
<li>  在进行查询时，如果仅仅按照 id 查询，是可以命中索引的；按照 <code>(id,name)</code> 或者 <code>(id,name.age)</code> 的顺序查询，也是可以命中索引的。但是如果调换了顺序，比如将 name 或 age 提到 id 之前，按照 <code>(name, id)</code> 的顺序来查询，就无法命中索引了。</li>
</ul>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><ul>
<li>  <strong>最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where 子句中使用最频繁的一列放在最左边</strong>。</li>
<li>  MySQL 会<strong>一直向右匹配直到遇到范围查询</strong>(&gt;、&lt;、between、like)就停止匹配，比如 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立 <code>(a,b,c,d)</code> 顺序的索引，d 是用不到索引的，如果建立 <code>(a,b,d,c)</code> 的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>  = 和 in 可以乱序，比如 <code>a = 1 and b = 2 and c = 3</code> 建立 <code>(a,b,c)</code> 索引可以任意顺序，MySQL 的查询优化器会帮你优化成索引可以识别的形式。</li>
</ul>
<hr>
<h2 id="按是否聚簇分类"><a href="#按是否聚簇分类" class="headerlink" title="按是否聚簇分类"></a>按是否聚簇分类</h2><blockquote>
<ul>
<li>  <strong>聚簇索引（聚集索引）</strong>：<strong>聚簇索引</strong>就是将索引数据和真实数据在物理上保存在一起，找到索引也就找到了数据。</li>
<li>  <strong>非聚簇索引</strong>：<strong>非聚簇索引</strong>就是真实数据和索引数据物理上不保存在一起，但是索引表中保存了指向真实数据的指针，要获取表中的真实数据有时还需要通过索引对应的地址空间到另一张专门保存数据的表中去找。</li>
</ul>
</blockquote>
<h3 id="InnoDB-中的聚簇索引-amp-非聚簇索引"><a href="#InnoDB-中的聚簇索引-amp-非聚簇索引" class="headerlink" title="InnoDB 中的聚簇索引 &amp; 非聚簇索引"></a>InnoDB 中的聚簇索引 &amp; 非聚簇索引</h3><p>在 InnoDB 里，</p>
<ul>
<li>  索引 <code>B+Tree</code> 的叶子节点存储了整行数据的索引是主键索引，也被称之为聚簇索引，即将整行数据与索引放到了一块，找到索引也就找到了数据。</li>
<li>  而索引 <code>B+Tree</code> 的叶子节点存储了主键的值（在这里主键的值就是指向真实数据的指针）的是非主键索引，也被称之为非聚簇索引、二级索引。</li>
</ul>
<blockquote>
<p>  <strong>聚簇索引与非聚簇索引的区别：</strong></p>
</blockquote>
<ul>
<li>  InnoDB 的聚簇索引其实就是在同一个结构中保存了 B+Tree 索引和数据行。</li>
<li>  非聚簇索引与聚簇索引的区别在于非聚簇索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）。</li>
<li>  对于 InnoDB 来说，想要查找数据我们还需要根据主键再去聚簇索引中进行查找，这个再根据聚簇索引查找数据的过程，我们称为<strong>回表</strong>。</li>
<li>  <strong>MyISAM 无论主键索引还是二级索引都是非聚簇索引，而 InnoDB 的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引</strong>。</li>
<li>  聚簇索引要求真实数据与索引存放在一起，所以<strong>一个表当中最好只有一个聚簇索引</strong>，而非聚簇索引可以有多个。如果想要一个表中能有多个聚簇索引，就需要给每一个聚簇索引分配一份真实表数据的副本。</li>
</ul>
<h3 id="MyISAM-只有非聚簇索引"><a href="#MyISAM-只有非聚簇索引" class="headerlink" title="MyISAM 只有非聚簇索引"></a>MyISAM 只有非聚簇索引</h3><ul>
<li>  MyISAM 使用的就是非聚簇索引，树的叶子节点上的 Data 不是数据本身，而是数据存放的地址。InnoDB 采用的是聚簇索引，树的叶子节点上的 Data 就是数据本身。</li>
<li>  MySQL 的 MyISAM 引擎在建立索引时，会专门维护一张索引表，索引表中除了索引值外，还有一列用于存储真实数据的内存地址，这就叫做非聚簇索引。</li>
<li>  因为</li>
<li>  InnoDB 中，如果表定义了 PrimaryKey，那么 PrimaryKey 就是聚簇索引。如果没有 PrimaryKey ，就会找第一个非空的 unique 列作用聚簇索引。否则，InnoDB 会创建一个隐藏的 row_id 作为聚簇索引。</li>
</ul>
<h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据（记录了真实真实数据的地址），在这些数据结构上我们可以实现高效的查找算法。这种数据结构，就是<strong>索引</strong>。</p>
<p>下图就是一种非聚簇索引的实现方式示例：</p>
<p><img src="file://E:/blog/source/_posts/MySQL%E7%B4%A2%E5%BC%95/image-20210724170912841.png?lastModify=1632123618" alt="image-20210724170912841"></p>
<ul>
<li>  左边是索引表，一共有两列七条记录，最左边记录的是真实数据的物理地址，Col1 是主键字段，Col2 是索引字段。</li>
<li>  为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</li>
<li>  一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</li>
</ul>
<h2 id="按存储结构分类"><a href="#按存储结构分类" class="headerlink" title="按存储结构分类"></a>按存储结构分类</h2><blockquote>
<ul>
<li>  二叉排序树（BST）</li>
<li>  平衡二叉树（AVL）</li>
<li>  B-Tree（B树）</li>
<li>  <strong>B+Tree（MySQL 的 InnoDB 引擎使用的是 B+Tree 索引）</strong></li>
<li>  Hash 索引</li>
<li>  Full-Text 全文索引</li>
<li>  R-Tree 索引</li>
</ul>
</blockquote>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><ul>
<li>  若它的左子树不为空，则左子树上所有关键字的值均小于根关键字的值；</li>
<li>  若它的右子树不为空，则右子树上所有关键字的值均大于根关键字的值；</li>
<li>  左右子树又是一棵二叉排序树。</li>
</ul>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><ul>
<li>  平衡二叉树首先是一棵二叉排序树，但是其要满足左右子树高度之差的绝对值不超过 1。</li>
<li>  平衡二叉树的左右子树也是平衡二叉树。</li>
</ul>
<hr>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B-Tree 能加快数据的访问速度。</p>
<ul>
<li>  因为存储引擎不再需要进行全表扫描来获取数据，</li>
<li>  数据分布在各个节点之中。</li>
</ul>
<p><img src="/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/image-20210920161141312.png" alt="image-20210920161141312"></p>
<hr>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><blockquote>
<p>  <strong>【概述】</strong></p>
</blockquote>
<ul>
<li>  <code>B+Tree</code> 是 <code>B-Tree</code> 的改进版本，<strong>数据都在叶子节点上</strong>，并且<strong>增加了顺序访问指针</strong>，每个叶子节点都有指向相邻的叶子节点的指针。</li>
<li>  相比 <code>B-Tree</code> 来说，进行范围查找时只需要查找两个节点，进行遍历即可。而 B-Tree 需要获取所有节点，相比之下 B+Tree 效率更高。</li>
</ul>
<blockquote>
<p>  <strong>【B+Tree性质】</strong></p>
</blockquote>
<ul>
<li>  非叶子节点不用来保存数据而是保存数据的索引。</li>
<li>  所有的叶子结点中包含了 <strong>① 全部关键字的信息，② 及指向含这些关键字记录的指针</strong>，并且叶子结点本身按关键字的大小从小到大顺序链接。</li>
<li>  所有的非叶子结点都起到了索引的作用，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>  B+Tree 中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>  B+Tree 有 2 个头指针，一个是树的根节点，一个是最小叶子节点的头结点。</li>
</ul>
<p><img src="/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/BTree.png" alt="BTree"></p>
<blockquote>
<p>  <strong>【初始化介绍】</strong></p>
</blockquote>
<p>一颗 B+树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含了<strong>数据项</strong>（深蓝色所示）和<strong>指针</strong>（黄色所示）。如磁盘块1 包含数据项 17 和 35，包含指针 P1、P2、P3。</p>
<ul>
<li>  P1 指向数据项小于 17 的磁盘块，P2 指向数据项在17~35 之间的磁盘块，P3 指向数据项大于 35 的磁盘块。</li>
<li>  真实的数据存储在于叶子节点中，即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。</li>
<li>  <strong>非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项</strong>。如 17、35 并不真实存在于数据表中。</li>
</ul>
<blockquote>
<p>  <strong>【查找过程】</strong></p>
</blockquote>
<ol>
<li> 如果要查找数据项 29，那么首先会把磁盘块 1 中的数据加载到内存中，发生第一次 IO，在内存中用二分查找确定 29 在17~35 之间，锁定磁盘块 1 的 P2 指针；</li>
<li> 通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 中的数据加载到内存中，发生第二次 IO，在内存中用二分查找确定 29 在 26~30 之间，锁定磁盘块 3 的 P2 指针；</li>
<li> 加载磁盘块 8 中的数据到内存中，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，总计三次 IO。</li>
</ol>
<blockquote>
<p>  <strong>【小总结】</strong></p>
</blockquote>
<p>在实际生产中，3 层的 BTree 可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。</p>
<hr>
<h3 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h3><blockquote>
<p>  <strong>【原理】</strong></p>
</blockquote>
<p>基于哈希表实现，对于每一行数据，存储引擎都会根据其索引列计算一个哈希值（HashCode），并且将所有的哈希码存储在索引表中，同时在索引表中保存指向每个数据行的指针。</p>
<p><img src="/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/java3-1562726249.jpeg"></p>
<blockquote>
<p>  <strong>【缺点】</strong></p>
</blockquote>
<p>对于 Hash 索引而言，只有精确匹配索引所有列的查询才有效。</p>
<ul>
<li>  这句话的意思是：对于复合索引，包含两个或两个以上的列。比如现在有一个复合索引包含了（id，name，age）三列，而 Hash 索引实现时是把这三列看做一个整体计算出一个 HashCode，所以想要利用 Hash 索引加快查找速度时，必须同时根据这三列算出的 HashCode 才是一个有效的 HashCode，如果仅仅包含了其中的一列或者两列，得到的 HashCode 就是一个非法的 HashCode，最终得到的结果自然也是不正确的。</li>
</ul>
<hr>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul>
<li>  如果索引的字段非常长，这既占内存空间，也不利于维护。如果只把很长字段的前面的公共部分作为一个索引，就变成了一个前缀索引。</li>
</ul>
<hr>
<h1 id="4-语法"><a href="#4-语法" class="headerlink" title="4. 语法"></a>4. 语法</h1><blockquote>
<p>  <strong>语法</strong></p>
</blockquote>
<ol>
<li> 创建：</li>
<li> 删除</li>
<li> 查看表的所有索引</li>
</ol>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="1-创建表时创建索引"><a href="#1-创建表时创建索引" class="headerlink" title="1. 创建表时创建索引"></a>1. 创建表时创建索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_index2 (</span><br><span class="line">  id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  first_name VARCHAR (16),</span><br><span class="line">  last_name VARCHAR (16),</span><br><span class="line">  id_card VARCHAR (18),</span><br><span class="line">  information TEXT,</span><br><span class="line">  KEY NAME (first_name, last_name),	# 复合索引</span><br><span class="line">  FULLTEXT KEY (information),	# 全文索引</span><br><span class="line">  UNIQUE KEY (id_card) # 唯一索引</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="2-对已有的表新增索引"><a href="#2-对已有的表新增索引" class="headerlink" title="2. 对已有的表新增索引"></a>2. 对已有的表新增索引</h3><h4 id="2-1-使用-CREATE-INDEX-命令创建索引"><a href="#2-1-使用-CREATE-INDEX-命令创建索引" class="headerlink" title="2.1 使用 CREATE INDEX 命令创建索引"></a>2.1 使用 CREATE INDEX 命令创建索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 创建：</span><br><span class="line">CREATE [UNIQUE] INDEX [indexName] ON table_name(column1, column2);	# 方式一</span><br></pre></td></tr></table></figure>

<h4 id="2-2-使用-ALTER-TABLE-命令增加索引"><a href="#2-2-使用-ALTER-TABLE-命令增加索引" class="headerlink" title="2.2 使用 ALTER TABLE 命令增加索引"></a>2.2 使用 ALTER TABLE 命令增加索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用 Alter 命令</span><br><span class="line">ALTER TABLE tb_name ADD PRIMARY KEY(column_list);	# 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</span><br><span class="line">ALTER TABLE tb_name ADD INDEX index_name(column_list) # 添加普通索引，索引值可出现多次。</span><br><span class="line">ALTER TABLE tb_name ADD UNIQUE INDEX index_name(column_list) # 添加唯一索引，要求被添加的列必须是唯一的</span><br><span class="line">ALTER TABLE tb_name ADD FULLTEXT index_name (column_list) # 该语句指定了索引为FULLTEXT ，用于全文索引。</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：主键天生就是一种唯一索引**</p>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除</span><br><span class="line">DROP INDEX [indexName] ON table_name;</span><br></pre></td></tr></table></figure>



<h2 id="查看一张表中创建的所有索引"><a href="#查看一张表中创建的所有索引" class="headerlink" title="查看一张表中创建的所有索引"></a>查看一张表中创建的所有索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查看</span><br><span class="line">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>案例</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 假设 name 和 openid 这两个字段在查询时频繁被使用，就可以将其设置为索引来增加查询速度</span><br><span class="line">SELECT * FROM USER WHERE NAME=&quot;&quot; AND openid=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">-- 单值索引</span><br><span class="line">CREATE INDEX idx_user_name ON USER(NAME)</span><br><span class="line"></span><br><span class="line">-- 复合索引</span><br><span class="line">CREATE INDEX idx_user_nameOpenid ON USER(NAME, openid) </span><br></pre></td></tr></table></figure>





<h2 id="查看MySQL语句执行时有没有用到索引"><a href="#查看MySQL语句执行时有没有用到索引" class="headerlink" title="查看MySQL语句执行时有没有用到索引"></a>查看MySQL语句执行时有没有用到索引</h2><ul>
<li>  通过 <strong>explain</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM user_info WHERE user_id = &#x27;1397023890531721218&#x27;;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/image-20210920174400590.png" alt="image-20210920174400590"></p>
<ul>
<li><p><strong>type</strong>：type 字段是判断查询是否高效的重要依据依据。<strong>通过 type 字段，我们可以判断此次查询是 全表扫描 还是 索引扫描</strong>。</p>
<ul>
<li>  <code>const</code>：主键索引或者唯一二级索引进行等值匹配的情况)</li>
<li>  <code>ref</code>：普通的二级索引列与常量进⾏等值匹配；</li>
<li>  <code>index</code>：扫描全表索引的覆盖索引。index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</li>
<li>  <code>ALL</code>：全表扫描。在相同的查询条件下, 它是速度最慢的。</li>
</ul>
<p>  通常来说，不同的 type 类型的性能关系如下：<strong>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</strong></p>
</li>
<li><p>  <strong>possible_key</strong>：查询中可能用到的索引(可以把用不到的删掉，降低优化器的优化时间) 。</p>
</li>
<li><p>  <strong>key</strong>：此字段是 MySQL 在当前查询时所真正使用到的索引。</p>
</li>
</ul>
<hr>
<h1 id="5-索引失效的几种情况"><a href="#5-索引失效的几种情况" class="headerlink" title="5. 索引失效的几种情况"></a>5. 索引失效的几种情况</h1><blockquote>
<ol>
<li> <strong>类型不一致（隐式类型转换）</strong>：</li>
</ol>
</blockquote>
<p>如果索引列出现了隐式类型转换，则 MySQL 不会使⽤索引。常见的情况是在 SQL 的 WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。【数据库中字段设置的为字符串类型，但是在查询的时候 where 语句后面的条件上使用的是数值类型，那么就不会使用索引】</p>
<blockquote>
<ol start="2">
<li> <strong>自动判断</strong>：</li>
</ol>
</blockquote>
<p>如果 MySQL 判断全表扫描⽐使⽤索引查询更快，则不会使⽤索引。</p>
<blockquote>
<ol start="3">
<li> <strong>函数导致索引失效</strong>：</li>
</ol>
</blockquote>
<ul>
<li>  函数导致索引失效的原因是：索引表中保存的数据表中的字段值，如果对索引字段使用函数，在进行检索时，就需要把索引表中的每个索引都进行一遍函数运算，然后再用函数运算得到的结果去与 where 条件比较，显然成本太大，这会导致索引失效。、</li>
<li>  正确的做法是，将函数放在筛选条件上而不是索引列上。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user` WHERE DATE(create_time) = &#x27;2020-09-03&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li> <strong>运算符导致的索引失效</strong>：</li>
</ol>
</blockquote>
<p>原因与函数导致索引失效一样，解决方法是将运算过程放在等号后面的条件上而不是索引列上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user` WHERE age - 1 = 20;	// 索引失效</span><br><span class="line">SELECT * FROM `user` WHERE age = 20+1;	// 解决方法</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="5">
<li> <strong>OR引起的索引失效</strong>：</li>
</ol>
</blockquote>
<p>OR 导致索引并不是一定会发生。如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user` WHERE `name` = &#x27;张三&#x27; OR height = &#x27;175&#x27;;	// 索引失效</span><br><span class="line">SELECT * FROM `user` WHERE `name` = &#x27;张三&#x27; OR name = &#x27;李四&#x27;;	// 索引不失效</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="6">
<li> <strong>模糊搜索导致索引失效</strong>：</li>
</ol>
</blockquote>
<ul>
<li>  模糊搜索导致索引失效也并不是一定会发生的。</li>
<li>  当 <code>%</code> 或者 <code>_</code> 放在匹配字段最前面是不走索引的，放在后面才会走索引。索引设计的时候就是从最左边的字符串开始匹配的，所以如果左边的字符串是确定的，就会走索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user` WHERE `name` LIKE &#x27;%冰&#x27;;	# 不走索引</span><br><span class="line">SELECT * FROM `user` WHERE `name` LIKE &#x27;张%&#x27;;	# 走索引</span><br></pre></td></tr></table></figure>

<ol>
<li></li>
</ol>
<blockquote>
<ol start="7">
<li> <strong>部分范围查询导致索引失效</strong>：</li>
</ol>
</blockquote>
<ul>
<li>  NOT IN、NOT EXISTS 导致索引失效。</li>
<li>  使用 != 或者 &lt;、&gt; 导致索引失效。</li>
<li>  因为使用索引查询的是是什么，而这些查询要求的结果是“不是什么”，</li>
</ul>
<hr>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="1、为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？"><a href="#1、为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？" class="headerlink" title="1、为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？"></a>1、为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</h2><blockquote>
<p>  <strong>B-Tree 的缺点：</strong> </p>
</blockquote>
<ol>
<li> B+Tree 的磁盘读写代价更低。B+Tree 的非叶子节点并没有保存指向关键字具体信息的指针，因此其非叶子节点相对 B-Tree 更小。也就是同一磁盘块能够容纳的节点数量越多，即同一磁盘块盘块所能容纳的关键字数量越多，一次性读入内存的需要查找的关键字也就越多，那么<strong>相对 IO 读写次数就降低了</strong>。</li>
<li> 由于 B+Tree 的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可。但是 B-Tree 因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以 <strong>B+Tree 更加适合区间查询的情况</strong>，所以通常B+树用于数据库索引。</li>
</ol>
<blockquote>
<p>  <strong>Hash 的缺点：</strong></p>
</blockquote>
<ul>
<li>  虽然可以快速定位，但是<strong>没有顺序，不支持排序</strong>；</li>
<li>  适合等值查询，如<code> =、in()、&lt;=&gt;</code>，<strong>不支持范围查询</strong>；因为 Hash 索引中的数据也是无序的，如果想要得到有序结果的话，同样需要全盘扫描。</li>
<li>  因为不是按照索引值顺序存储的，就不能像 <code>B+Tree </code>索引一样利用索引完成排序 ；</li>
<li>  Hash索引在查询等值时非常快 ；</li>
<li>  因为 Hash 索引始终索引的所有列的全部内容，所以<strong>不支持部分索引列的匹配查找</strong> ；</li>
<li>  如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。</li>
</ul>
<blockquote>
<p>  <strong>二叉树缺点：</strong></p>
</blockquote>
<ul>
<li><strong>查找效率不稳定</strong>。二叉树的查找效率跟树的高度有关，并且二叉树不能自平衡，如果出现某些极端数据，可能会导致二叉树的查询效率下降到接近于一个单链表。</li>
</ul>
<blockquote>
<p>  <strong>红黑树缺点：</strong></p>
</blockquote>
<ul>
<li>  树的高度随着数据量增加而增加。</li>
</ul>
<h2 id="2、非聚簇索引一定会回表查询吗？"><a href="#2、非聚簇索引一定会回表查询吗？" class="headerlink" title="2、非聚簇索引一定会回表查询吗？"></a>2、非聚簇索引一定会回表查询吗？</h2><ul>
<li>  不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为”<strong>覆盖索引</strong>“。</li>
<li>  举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行 <code>select score from student where score &gt; 90</code> 的查询时，在索引的叶子节点上，已经包含了score 信息，就不会再次进行回表查询。</li>
</ul>
<h2 id="3、创建索引时需要注意什么？"><a href="#3、创建索引时需要注意什么？" class="headerlink" title="3、创建索引时需要注意什么？"></a>3、创建索引时需要注意什么？</h2><ul>
<li>  <strong>索引字段应该设置非空约束</strong>。索引应该指定列为 NOT NULL，除非你想存储 NULL。在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。在使用时应该用 0 或者 空字符串 或者 其它特殊值代替 NULL。</li>
<li>  <strong>索引字段应该取离散程度高的字段</strong>：如果是单列索引，应该尽量选取离散程度高的字段作为索引。如果是复合索引，应该尽量让离散程度高的索引列放在复合索引的前面。可以通过 <code>count()</code> 函数查看字段的差异值，返回值越大说明字段的唯一值越多，字段的离散程度越高。</li>
</ul>
<h2 id="4、哪些情况下需要创建索引？"><a href="#4、哪些情况下需要创建索引？" class="headerlink" title="4、哪些情况下需要创建索引？"></a>4、哪些情况下需要创建索引？</h2><ol>
<li> <strong>主键</strong>天生就是唯一索引；</li>
<li> <strong>频繁作为查询条件的字段</strong>应该创建索引；</li>
<li> 查询中与其它表关联的字段，<strong>外键</strong>字段应该建立索引；</li>
<li> 查询中<strong>排序的字段</strong>。排序字段若通过索引去访问将大大提高排序速度；</li>
<li> 单键/组合索引的选择问题，<strong>组合索引性价比更高</strong>；</li>
<li> 查询中统计或者分组字段；</li>
</ol>
<h2 id="5、哪些情况不需要创建索引？"><a href="#5、哪些情况不需要创建索引？" class="headerlink" title="5、哪些情况不需要创建索引？"></a>5、哪些情况不需要创建索引？</h2><ol>
<li> 表记录太少；【表记录过少的话遍历查找也能很快就找到所有数据，而为此再专门维护一张索引表是不合适的】</li>
<li> 频繁更新的字段（经常增删改的表或者字段）不适合创建索引；【因为每次更新不单单要更新数据库表记录还会更新索引表记录】</li>
<li> Where 条件里用不到的字段不创建索引（不用做查询条件的字段）</li>
<li> <strong>过滤性不好的不适合建索引。</strong></li>
</ol>
<ul>
<li>假如一个表中有 10w 条记录，有一个字段 gender 只有 0 和 1 两种值，且每个值的分布概率大约为 50%，那么对这种字段建立索引一般不会提高数据库的查询速度。<ul>
<li>  索引的选择是指索引列中不同值的数量与表中记录数的比。如果一个表中有 2000 条记录，表索引列有 1980 个不同的值，那么这个索引的选择性就接近于 1，这个索引的效率越高。</li>
</ul>
</li>
</ul>
<h2 id="6、建索引的原则有哪些？"><a href="#6、建索引的原则有哪些？" class="headerlink" title="6、建索引的原则有哪些？"></a>6、建索引的原则有哪些？</h2><blockquote>
<ol>
<li> <strong>最左前缀匹配原则</strong></li>
</ol>
</blockquote>
<p>MySQL 会一直向右匹配直到遇到<strong>范围查询</strong><code>（&gt;、&lt;、between、like）</code>就停止匹配，比如 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立<code>(a,b,c,d)</code> 顺序的索引，d 是用不到索引的，如果建立 <code>(a,b,d,c)</code> 的索引则都可以用到，<code>a,b,d</code> 的顺序可以任意调整。</p>
<blockquote>
<ol start="2">
<li> <strong>= 和 in 可以乱序</strong></li>
</ol>
</blockquote>
<p>比如 <code>a = 1 and b = 2 and c = 3</code> 建立 <code>(a,b,c)</code> 索引可以任意顺序，MySQL 的查询优化器会帮你优化成索引可以识别的形式。</p>
<blockquote>
<ol start="3">
<li> <strong>尽量选择离散度高的列作为索引</strong></li>
</ol>
</blockquote>
<p>计算离散度的公式是 <code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的离散度是1，而一些状态、性别字段可能在海量数据面前区分度接近于 0。一般情况下索引字段的离散度应该在 0.1 以上，即平均 1 条索引扫描10条记录。</p>
<blockquote>
<ol start="4">
<li> <strong>索引列不能参与计算</strong></li>
</ol>
</blockquote>
<p>索引列不能参与计算，保持列“干净”，比如 <code>from_unixtime(create_time) = ’2014-05-29’</code> 就没有使用到索引，原因很简单，b+Tree 中存的都是数据表中的字段值，但进行检索时，需要把所有元素都用函数计算后才能比较，显然成本太大。所以语句应该写成 <code>create_time = unix_timestamp(’2014-05-29’)</code>。</p>
<blockquote>
<ol start="5">
<li> <strong>尽量扩展已有的索引，不要新建索引。</strong></li>
</ol>
</blockquote>
<p>比如表中已经有 a 的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可。</p>
<h2 id="7、使用索引查询一定能提高查询的性能吗？"><a href="#7、使用索引查询一定能提高查询的性能吗？" class="headerlink" title="7、使用索引查询一定能提高查询的性能吗？"></a>7、使用索引查询一定能提高查询的性能吗？</h2><ul>
<li>  通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</li>
<li>  索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出 4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。</li>
</ul>
<hr>
<h2 id="8、联合索引及最左匹配原则"><a href="#8、联合索引及最左匹配原则" class="headerlink" title="8、联合索引及最左匹配原则"></a>8、联合索引及最左匹配原则</h2><p>MySQL 可以使用多个字段同时建立一个索引，叫复合索引。但是在使用复合索引的时候，需要注意<strong>最左匹配原则</strong>。比如：</p>
<p>假设现在建立了 <code>idx_test(id, name, age)</code> 的复合索引，那么索引的排序为：先按照 id 排序，如果 id 相同，则按照 name 排序，如果 name 也相同，则按照 age 进行排序。</p>
<p>当进行查询时，此时索引仅仅按照 id 严格有序，因此必须首先使用 id 字段进行等值查询，之后对于匹配到的列而言，此时可以使用 name 字段用作索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁的列放在前面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、where id=5 and name=&#x27;zs&#x27; and age=23; 	# 可以走索引idx_test</span><br><span class="line">2、where name=&#x27;zs&#x27; and id=5 and age=23; 	# 可以走索引idx_test【MySQL底层默认的优化策略】</span><br><span class="line">3、where id=5 and name=&#x27;zs&#x27;;	# 可以走索引</span><br><span class="line">4、where id=5 and age=23;	# 可以走索引</span><br><span class="line">5、where id=5;	 # 可以走索引</span><br><span class="line">6、where name=&#x27;zs&#x27;;	# 不走索引</span><br><span class="line">7、where age=23;		# 不走索引</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>  如果条件里含有联合索引的第一个字段，那么不管 where 条件的顺序和个数，这次查询都会走索引。</li>
<li>  联合索引的使用和 and 条件的顺序无关。</li>
<li>  只要列中包含有 NULL 值都将不会被包含在索引中，复合索引只要有一列含有 NULL 值，那么这一列对于复合索引就是无效的。</li>
</ul>
<p><strong>联合索引的好处：</strong></p>
<ol>
<li> <strong>减少了建立索引的开销</strong>。建立一个 <code>(a,b,c)</code> 的复合索引，实际上等于建立了 <code>(a)，(a,b)，(a,b,c)</code> 三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销，对于大量数据的表，这是一笔不小的开销。</li>
<li> <strong>覆盖索引</strong>。对于复合索引 <code>(a,b,c)</code>，如果有如下的 <code>select a,b,c from table where a=1</code>，那么 MySQL 可以直接通过遍历索引取得数据，而无需会标。这将减少很多 IO 操作。</li>
<li> <strong>缩小筛选范围</strong>。对于 1000W 条数据的表，如果有如下 <code>select * from table where a=1 and b=2 and c=3</code>，假设每个条件可以筛选出 10% 的数据，如果只有单值索引，那么通过该索引只能筛选出 1000W*10%=100W 条数据，然后再回表从 100W 条数据中找到符合 <code>b=2 and c=3</code> 的数据，然后再排序、再分页。如果是复合索引，通过索引就可以筛选出 <code>1000W * 10% * 10% * 10% = 1W</code>，然后再回表查询这 1W 条数据即可。</li>
</ol>
<hr>
<h2 id="10、主键设计-UUID-和-自增主键的区别"><a href="#10、主键设计-UUID-和-自增主键的区别" class="headerlink" title="10、主键设计 UUID 和 自增主键的区别"></a>10、主键设计 UUID 和 自增主键的区别</h2><ul>
<li>  自增主键，在进行数据库插入时，位置相对固定（B+树的右下角），数据插入效率要高一些，能更好的支持区间查找</li>
<li>  UUID：由于 UUID 是随机生成的，插入时位置具有不确定性，插入效率要低一些。区间查找也没有自增主键性能优越。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
