<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/07/Spring%E2%80%94%E2%80%94IoC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/" class="post-title-link" itemprop="url">Spring——IoC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-07 12:22:09" itemprop="dateCreated datePublished" datetime="2021-08-07T12:22:09+08:00">2021-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-30 16:42:05" itemprop="dateModified" datetime="2022-03-30T16:42:05+08:00">2022-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IoC-是什么？"><a href="#IoC-是什么？" class="headerlink" title="IoC 是什么？"></a>IoC 是什么？</h1><p><strong>IOC 的概念：</strong></p>
<p>IOC（Inversion of Control） 最初被叫做“Hollywood Principe”，即好莱坞原则。为什么要起这个名字呢？好莱坞原则的意思就是：在拍摄某部电影时，演员不是主动去申请拍摄这部电影的，而是由导演来挑选演员的。类比到 Spring 中就是：实例对象不是主动去创建的，而是由 Spring 容器在适当的时候去创建出来提供给程序使用的。官方一点的解释就是：</p>
<blockquote>
<ul>
<li>  IOC 就是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。 </li>
<li>  Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</li>
</ul>
</blockquote>
<p><strong>IoC 作用：</strong></p>
<ol>
<li> 创建对象并维护对象之间的依赖关系。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的。</li>
<li> 解耦，由容器去维护具体的对象</li>
</ol>
<p><strong>实现 IoC 设计原则的2种方式：</strong></p>
<ol>
<li><strong>依赖注入（DI）</strong></li>
<li>依赖查找（Dependency Lookup）</li>
</ol>
<p><strong>Spring 中 IOC 的实现原理：</strong></p>
<p>Spring 中 IOC 的实现原理就是 <u><strong>工厂模式+反射机制</strong></u>。我们通过一个例子来解释一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getInstance</span><span class="params">(String ClassName)</span> &#123;</span><br><span class="line">        Fruit f=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;cn.lnd.springtest.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="程序的耦合和解耦"><a href="#程序的耦合和解耦" class="headerlink" title="程序的耦合和解耦"></a>程序的耦合和解耦</h2><blockquote>
<ul>
<li><p>耦合性（Coupling），是对模块间关联程度的度量。</p>
</li>
<li><p>划分模块的一个准则就是<strong>高内聚低耦合</strong>。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>程序的耦合</strong>，就是程序间的依赖关系。包括：<ul>
<li>类之间的依赖</li>
<li>方法之间的依赖</li>
</ul>
</li>
<li><strong>解耦</strong>，就是降低程序间的依赖关系。在实际开发中，应该做到：<ul>
<li>编译期不依赖，运行时才依赖。</li>
</ul>
</li>
<li><strong>解耦的思路</strong>：<ul>
<li>step1：通过反射来创建对象，而避免使用new关键字。</li>
<li>step2：通过读取配置文件来获取想要创建的对象的全限定类名。</li>
</ul>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在开发中，有些依赖关系必须是显式的，有些依赖关系可以通过优化代码来避免。</p>
<p><strong>问：</strong>在使用 JDBC 注册驱动时，为什么不使用<code>DriverManger</code>中的静态方法 <code>registerDriver()</code>，而是采用<code>Class.forName()</code>的方式？</p>
<p><strong>答：</strong></p>
<ol>
<li><code>DriverManager.registerDriver(Driver driver)</code> 是 <code>java.sql</code> 包下的一个静态方法，接收的参数是一个数据库驱动实现类实例，作用是注册数据库驱动程序。如果我们直接调用该方法来注册驱动当然是可以的，需要我们创建一个数据库驱动实现类的实例并将对象传递给<code>registerDriver()</code>方法即可。但是此时：<ul>
<li>如果更换了数据库驱动，假设从 MySQL 数据库驱动换为 Oracle 数据库驱动，那么必须修改代码，重新创建一个 Oracle 数据库驱动对象并传递给 <code>registerDriver()</code> 方法。</li>
<li>如果需要的数据库驱动类不存在，那么在编译期就会直接报错。</li>
</ul>
</li>
<li>使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>反射机制将 MySQL 数据库驱动类对象加载进内存。<ul>
<li>使用反射机制的好处是，消除了编译期依赖，<code>Class.forName()</code>方法中接收的形参是String类型，在编译期传递任意错误的值都不会报错，当然运行时必定会出现错误。 </li>
<li>但是更换数据库驱动时仍然要修改源代码。</li>
</ul>
</li>
<li> 但是第2种方法仍然不是耦合度最低方法。耦合度最低的方式是将数据库配置信息保存在外部配置文件(如<code>.properties</code>)中，在源码中通过读取配置文件的方式将数据库驱动加载进内存中。当我们更换了数据库品牌的时候，只需要修改外部的配置文件即可，而不用对源码做任何修改。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.jdbc;<span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo01</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;        </span><br><span class="line">        <span class="comment">// 注册数据库驱动        </span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);     <span class="comment">// 方式2：通过反射的方式注册数据库驱动</span></span><br><span class="line">        <span class="comment">// DriverManager.registerDriver(new com.mysql.jdbc.Driver());    // 方式1：通过DriverManager中的静态方法registerDriver(Driver driver)来注册驱动</span></span><br><span class="line">        <span class="comment">// 获取连接对象Connection        </span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);    </span><br><span class="line">        <span class="comment">// 获取数据预处理对象PreparedStatement        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user;&quot;</span>;        </span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);        </span><br><span class="line">        <span class="comment">// 执行（查询）语句，并接收返回值        </span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();        </span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 提交事务（MySQL自动提交）        </span></span><br><span class="line">        <span class="comment">// 释放资源        </span></span><br><span class="line">        resultSet.close();        </span><br><span class="line">        preparedStatement.close();        </span><br><span class="line">        connection.close();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="容器-amp-工厂"><a href="#容器-amp-工厂" class="headerlink" title="容器 &amp; 工厂"></a>容器 &amp; 工厂</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1 容器"></a>1 容器</h2><p>Spring 的作者 Rod Johnson 设计了两个顶级接口来表示容器，分别是：</p>
<ul>
<li>  <strong>BeanFactory</strong></li>
<li>  <strong>ApplicationContext</strong></li>
</ul>
<p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，key 是 BeanName，value 是 Bean 的 Class 对象。通常只提供注册（put），获取（get）这两个功能，我们一般称其为 “<strong>低级容器</strong>”。</p>
<p>那么相对的，ApplicationContext 一般被称为 “<strong>高级容器</strong>”。它继承了包括 BeanFactory 在内的多个接口，在 BeanFactory 的基础上提供了更多的功能。</p>
<p>例如资源的获取，支持多种消息（例如 JSP tag 的支持），相较于 BeanFactory 多了工具级别的支持。所以它的名字已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。</p>
<p>ApplicationContext 接口的源码中定义了一个 <code>refresh()</code> 方法（高级容器特有的方法），此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p>
<h3 id="低级容器的-IOC-过程"><a href="#低级容器的-IOC-过程" class="headerlink" title="低级容器的 IOC 过程"></a>低级容器的 IOC 过程</h3><p>IOC 在 Spring 里，只需要低级容器就可以实现：</p>
<ol>
<li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li>
<li>调用 <code>getBean</code> 的时候，从 BeanDefinition 所属 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 <code>getBean</code> 方法完成多个类的依赖注入。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>  Spring 应用程序在启动时，就会读取并加载配置文件到内存中，根据配置文件中的全限定类名创建对应的 Class 类对象并保存到容器中。</li>
<li>  <strong>懒加载</strong>是指需要实例对象的时候，将 Class 对象拿出来创建对象的实例对象。而 Class 对象则是在程序启动时一次性加载到内存中的的，并且会将 Class 实例保存到容器中作为 Value。</li>
</ul>
<hr>
<h2 id="2-工厂"><a href="#2-工厂" class="headerlink" title="2 工厂"></a>2 工厂</h2><p>Spring 的 IoC 是通过 <strong>简单工厂模式 + 反射机制</strong> 来实现的。</p>
<p>工厂主要有如下几个作用：</p>
<ol>
<li><p> 在程序启动时，读取配置文件，根据配置文件中 bean 的全限定类名创建其对应的 Class 类对象并保存到一个 Map 结构的容器中。【反射】</p>
</li>
<li><p> 对外提供 getInstance 方法，在需要使用实例对象的时候提供对应的实例对象，而不用自己去创建<code>(new)</code></p>
</li>
<li><p>工厂模式内部是通过反射机制，从容器中拿到对应的 Class 对象，根据 Class 对象动态的创建对应的对象实例。</p>
</li>
</ol>
<h3 id="2-1-工厂的体系结构（BeanFactory-vs-ApplicationContext）"><a href="#2-1-工厂的体系结构（BeanFactory-vs-ApplicationContext）" class="headerlink" title="2.1 工厂的体系结构（BeanFactory vs. ApplicationContext）"></a>2.1 工厂的体系结构（BeanFactory vs. ApplicationContext）</h3><blockquote>
<p><strong>Spring容器体系结构图（部分）</strong></p>
</blockquote>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/Spring%E5%AE%B9%E5%99%A8%E7%B1%BB.png" alt="Spring容器类"></p>
<h5>BeanFactory 和 ApplicationContext 的继承关系：</h5>


<p>BeanFactory 和 ApplicationContext 是 Spring 容器的两大顶级接口，都可以当做 Spring 容器。其中 BeanFactory 是 Spring 容器最顶级的接口，ApplicationContext 是 BeanFactory 的子接口。</p>
<p>BeanFactory 接口内部定义了一系列顶级抽象方法（包含各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系等）。</p>
<p>ApplicationContext 接口作为 BeanFactory 的子接口，除了拥有 BeanFactory 声明的所有功能外，还继承了很多其它的接口，因此可以提供更多的功能。如：</p>
<ul>
<li>  支持国际化。</li>
<li>  支持统一的资源文件访问方式。</li>
<li>  提供在监听器中注册bean的事件。</li>
<li>  支持同时加载多个配置文件。</li>
<li>  载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层。</li>
</ul>
<h5>BeanFactory 和 ApplicationContext 对应的不同加载方式：</h5>


<p>​    <code>BeanFactroy</code> 采用的是<strong>懒加载</strong>的形式来注入 Bean 的，即只有在使用到某个Bean时（调用 <code>getBean()</code>）才对该 Bean 进行加载实例化。这样，我们就不能第一时间发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入，BeanFacotry 加载后，直至第一次使用调用 <code>getBean()</code> 方法才会抛出异常。</p>
<p>​    <code>ApplicationContext</code> 是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，如果存在的配置错误就会直接报错，这样有利于检查所依赖属性是否注入。这种方式的优点是：<code>ApplicationContext</code> 启动后预载入所有的单例 Bean，当你需要使用的时候，无需等待，因为它们已经创建好了，可以直接使用。缺点是：相对于基本的 <code>BeanFactory</code>，<code>ApplicationContext</code> 唯一的不足是占用内存空间。当应用程序配置 Bean 较多时，程序启动较慢。</p>
<h5>ApplicationContext接口常用的实现类：</h5>


<ul>
<li>  <strong>ClassPathXmlApplicationContext</strong>：它是从类的根路径下加载配置文件【推荐使用】</li>
<li>  <strong>FileSystemXmlApplicationContext</strong>：它是从磁盘路径上加载配置文件。</li>
<li>  <strong>AnnotationConfigApplicationContext</strong>：当我们使用Spring的纯注解开发时，需要使用此类来加载<strong>配置类</strong>。</li>
</ul>
<hr>
<h1 id="Spring中基于XML的IoC环境搭建"><a href="#Spring中基于XML的IoC环境搭建" class="headerlink" title="Spring中基于XML的IoC环境搭建"></a>Spring中基于XML的IoC环境搭建</h1><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1 代码实现"></a>1 代码实现</h2><ol>
<li><p>创建Maven工程并导入 <code>spring-contex</code> 依赖。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个配置文件 <code>bean.xml</code>，保存要创建的对象的全限定类名以及对应的<code>id</code>，用于通过反射创建对象。</p>
<ul>
<li><code>bean.xml</code>配置文件的约束：</li>
</ul>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>       </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--待创建的bean对象--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;自定义id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;全限定类名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用注解配置 IoC 时配置文件的约束：</li>
</ul>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>       </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--告知spring创建时，容器要扫描的包--&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xsyu&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>创建测试类。在测试类中读取配置文件，创建Spring容器（底层是Map结构），并使用 <code>getBean()</code> 方法中从 Spring容器中获取对应的实例对象。</p>
<ul>
<li>  Spring 容器中的的 key 是 <code>bean.xml</code> 配置文件中<code>&lt;bean&gt;</code>标签的 id 属性；</li>
<li>  Spring 容器中的的 value 是根据 <code>bean.xml</code> 配置文件中<code>&lt;bean&gt;</code>标签中的 class 属性对应的全限定类名通过反射创建出来的 <strong>Class类对象</strong>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建工厂实例</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 工厂实例从IoC容器中获取实例对象</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="2-IoC中bean标签和管理对象细节"><a href="#2-IoC中bean标签和管理对象细节" class="headerlink" title="2 IoC中bean标签和管理对象细节"></a>2 IoC中bean标签和管理对象细节</h2><p><code>bean.xml</code> 是一个配置文件，该文件内所有的数据都被用来根据反射创建对象。</p>
<h3 id="2-1-bean标签"><a href="#2-1-bean标签" class="headerlink" title="2.1 bean标签"></a>2.1 bean标签</h3><p><strong>作用：</strong></p>
<ul>
<li>用于配置要添加到容器中的对象的信息（id和全限定类名）。</li>
<li><u>默认情况下，工厂创建实例对象时使用的是类的无参构造函数，如果没有无参构造函数则不能创建成功。</u></li>
</ul>
<p><strong>属性：</strong></p>
<ul>
<li><code>id</code>：是对象在 Spring 容器中的 key，用于获取对象。</li>
<li><code>class</code>：指定类的全限定类名。[全类名被用于通过反射创建对象，默认情况下调用无参构造函数初始化。]</li>
<li><code>scope</code>：指定对象的作用范围。<ol>
<li><code>singleton</code>：单例的。默认值</li>
<li><code>prototype</code>：多例的</li>
<li><code>request</code>：一次请求范围内</li>
<li><code>session</code>：一次会话范围内</li>
<li><code>global session</code>：全局session，一个集群范围内。如果没有集群，等价于<code>session</code></li>
</ol>
</li>
<li><code>init-method</code>：指定类中初始法方法的名称。</li>
<li><code>destroy-method</code>：指定类中销毁方法的名称</li>
</ul>
<h3 id="2-2-Bean-的作用范围和生命周期"><a href="#2-2-Bean-的作用范围和生命周期" class="headerlink" title="2.2 Bean 的作用范围和生命周期"></a>2.2 Bean 的作用范围和生命周期</h3><table>
<thead>
<tr>
<th align="center">单例对象</th>
<th align="center">多例对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">scope=”singleton”</td>
<td align="center">scope=”prototype”</td>
</tr>
<tr>
<td align="center">容器中只有一个该类的实例对象。它的作用范围就是整个应用[即无论哪里用到该对象，都是同一个对象]。</td>
<td align="center">一个容器中<strong>可以有无数个</strong>该类的实例对象。每次需要使用该对象时，就会重新创建实例对象。</td>
</tr>
</tbody></table>
<p>单例对象的生命周期：</p>
<ul>
<li>  对象出生：当应用程序加载时，读取了配置文件，创建了Spring容器时，单例对象就被创建了。</li>
<li>  对象活着：只要容器还存在，单例对象就一直活着。</li>
<li>对象死亡：当应用程序关闭，容器被销毁时，对象就被销毁了。</li>
</ul>
<p>多例对象的生命周期：</p>
<ul>
<li>  对象创建：Spring 容器被创建时，对象并没有被创建。当程序中的某一步骤需要使用该对象时，才会创建对象的实例。[懒加载]</li>
<li>  对象活着：只要程序运行中某一步骤还需要使用该对象，多例对象就一直活着。</li>
<li>  对象死亡：当对象长时间不用时，由Java的垃圾回收器回收。</li>
</ul>
<h3 id="2-3-实例化Bean的三种方式"><a href="#2-3-实例化Bean的三种方式" class="headerlink" title="2.3 实例化Bean的三种方式"></a>2.3 实例化Bean的三种方式</h3><blockquote>
<ul>
<li>使用默认无参构造函数</li>
<li>使用静态工厂</li>
<li>使用实例化工厂</li>
</ul>
</blockquote>
<h4>1、使用默认无参构造函数</h4>


<p><strong>默认情况</strong>下，Spring容器会根据全限定类名找到对应的类，并根据类中无参构造器来创建实例对象。如果类中没有无参构造器，将会创建失败。</p>
<ul>
<li>  默认情况下，JVM 会给每个类提供一个无参构造函数，所以如果没有重写构造函数，是可以直接创建实例对象的。</li>
<li>  如果重写了无参构造函数，那么 Spring 容器会使用你重写的这个无参构造函数来创建实例对象，也是可以创建成功的。</li>
<li>  但是如果重写了构造函数，但是只重写了带参构造函数，而没有重写无参构造函数，则默认的无参构造函数则会失效，这时候使用Spring默认的实例化Bean的方式创建实例对象就会失败。</li>
</ul>
<p>所以说，<strong>对于Spring容器默认的实例化 Bean 的方式，只要存在无参构造函数，就可以成功创建对象。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认情况--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h4>2、Spring管理静态工厂，使用静态工厂中的方法创建对象</h4>


<ol>
<li>创建一个静态工厂，这个工厂中的方法用于实例化Bean对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 模拟一个静态工厂，创建dao层实现类*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置<code>bean.xml</code>文件中的<code>&lt;bean&gt;标签</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--	</span></span><br><span class="line"><span class="comment">使用StaticFactory类中的静态方法`createUserDao()`创建对象，并存入Spring容器。		</span></span><br><span class="line"><span class="comment">	id：指定bean的唯一标识，用于从容器中获取实例对象。		</span></span><br><span class="line"><span class="comment">	class：指定静态工厂的全限定类名。</span></span><br><span class="line"><span class="comment">  	factory-method：指定生产对象的静态方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span>       </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.factory.StaticFactory&quot;</span>      </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  分析：</p>
</blockquote>
<ol>
<li><code>&lt;bean&gt;</code>标签中存在<strong>静态工厂类的全限定类名</strong>，可以通过反射创建类对应的 Class 实例，通过 Class 实例直接调用类中的方法，不必实例化。**[即Spring容器中并没有<code>cn.xsyu.factory.StaticFactory</code>的实例对象]**</li>
<li><code>class=&quot;cn.xsyu.factory.StaticFactory&quot;</code>只是起到了一个代理的作用，通过类中的<code>createUserDao()</code>方法<strong>创建了<code>UserDaoImpl</code>实例对象，并将其加入spring容器</strong>，指定唯一标识<code>id=&quot;usertDao&quot;</code></li>
</ol>
<hr>
<h4>3、Spring管理实例工厂，使用实例工厂中的方法创建对象</h4>


<ol>
<li><p>创建一个实例工厂，这个工厂中的方法用于实例化Bean对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 模拟一个实例工厂，创建dao层实现类。</span></span><br><span class="line"><span class="comment">* 此工厂创建对象，必须要有工厂实例对象，才能调用方法。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置<code>bean.xml</code>文件中的<code>&lt;bean&gt;标签</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--	</span></span><br><span class="line"><span class="comment">	先把工厂的创建（实例化）交给spring来管理，然后再使用工厂的实例化对象`factory-bean`来调用对象中的方法，					factory-bean：用于指定实例工厂bean的唯一标识；		</span></span><br><span class="line"><span class="comment">		factory-method：用于指定实例工厂中的方法。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.factory.InstanceFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span>      </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-bean</span>=<span class="string">&quot;instanceFactory&quot;</span>      </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>  分析：</p>
</blockquote>
<ol>
<li><code>bean</code>标签中存在非静态工厂的全限定类名<code>cn.xsyu.factory.InstanceFactory</code>，要想使用实例工厂对象中的方法，则必须通过反射得到<code>InstanceFactory</code>对象的实例。</li>
<li>通过 Class 对象得到对应的实例对象，并将其交给 Spring 管理。**[内存中存在<code>cn.xsyu.factory.InstanceFactory</code>的实例对象]**</li>
<li>得到 <strong>InstanceFactory</strong> 实例对象后，再通过<code>factory-method</code>调用对象中的方法<code>createUserDao</code>，最后得到方法的返回值交给 Spring容器管理，并指定唯一标识<code>id=&quot;accountDao&quot;</code>。</li>
</ol>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E6%96%B9%E5%BC%8F-1598445621956.png"></p>
<hr>
<h1 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h1><blockquote>
<ul>
<li>依赖注入是什么</li>
<li>构造函数注入</li>
<li>set方法注入</li>
<li>注入集合属性（set方法）</li>
</ul>
</blockquote>
<h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1 是什么？"></a>1 是什么？</h2><ul>
<li>  IoC 的实现方式有 <strong>依赖查找</strong> 和 <strong>依赖注入</strong>。由于依赖查找使用的很少，因此 IoC 也叫做依赖注入（DI）。</li>
<li>  <strong>DI</strong> 的设计原则允许我们<strong>移除硬编码依赖来降低程序间的耦合度</strong>。</li>
<li>  我们的程序在编写时，通过控制反转，把对象的创建交给了spring，但是代码中不可能出现没有依赖的情况。IoC解耦只是降低它们的依赖关系，而不会消除。</li>
<li>  例如：我们的业务层仍然会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring自己来维护了。简单的说，w我们只进行声明，具体的过程就是坐等框架把持久层对象传入业务层，而不用我们自己在业务层去获取。</li>
</ul>
<hr>
<h2 id="2-依赖注入的3种方式"><a href="#2-依赖注入的3种方式" class="headerlink" title="2    依赖注入的3种方式"></a>2    依赖注入的3种方式</h2><blockquote>
<p>  依赖注入的数据类型（3类）：</p>
</blockquote>
<ul>
<li>基本类型和String</li>
<li>其它bean类型（在配置文件中配置或者注解配置过的bean）</li>
<li>复杂类型/集合类型</li>
</ul>
<blockquote>
<p>  依赖注入的方式（2种）：</p>
</blockquote>
<ul>
<li>使用构造函数注入</li>
<li>使用set方法注入</li>
</ul>
<h3 id="2-1-构造函数注入"><a href="#2-1-构造函数注入" class="headerlink" title="2.1    构造函数注入"></a>2.1    构造函数注入</h3><ul>
<li>  顾名思义，就是在使用指定的构造器初始化对象时，通过给构造器中的属性赋值，创建出有初始值的对象。</li>
<li>  实际上使用默认无参构造函数初始化类时，也就是<code>&lt;construct-arg&gt;</code>标签中没有任何内容，所以自然可以省略该标签，初始化时bean对象自然也就没有任何初始值了。</li>
<li>  注意：赋值的操作不是我们自己做的，而是通过设置配置文件让 Spring 框架来为我们注入，我们只需要提供 <strong>要使用的初始值</strong> 和 <strong>对应的构造函数</strong> 即可。</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<ol>
<li>定义一个类对象<code>AccountServiceImpl</code>，重写其中的构造方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;    </span><br><span class="line">    <span class="keyword">private</span> Date birthday;    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountServiceImpl</span><span class="params">(String name, <span class="type">int</span> age, Date birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;        </span><br><span class="line">        <span class="built_in">this</span>.age = age;        </span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;:&quot;</span>+age+<span class="string">&quot;:&quot;</span>+birthday);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在<code>bean.xml</code>配置文件中，使用<code>构造函数注入</code>的方式，给<code>AccountServiceImpl</code>类中的成员变量赋值。</p>
<ul>
<li><p>类中构造函数的参数列表需与配置文件中给出的初始化属性一一映射。</p>
</li>
<li><p>涉及的标签：**<code>&lt;constructor-arg&gt;</code>**</p>
</li>
<li><p>标签出现的位置：<code>&lt;bean&gt;</code>标签的内部</p>
</li>
<li><p>标签中的属性：标签中的属性可分为2类，一类用来与类中构造函数中的参数产生映射关系，另一类是对参数进行赋值。</p>
<ul>
<li><p>以下三个属性均可用于绑定构造函数中的某个参数：</p>
<blockquote>
<ol>
<li><code>type</code>：用于指定参数的数据类型；【如果该类型的参数在构造函数列表中只有唯一一个与之匹配，则能注入成功，否则注入失败】</li>
<li><code>index</code>：指定参数在构造函数参数列表中的索引位置，指定索引的位置从0开始。            </li>
<li><strong>name</strong>：用于给指定的构造函数中的指定名称的参数赋值。【常用】</li>
</ol>
</blockquote>
</li>
<li><p>下面两个参数则用于对绑定的参数进行赋值：</p>
<blockquote>
<ol>
<li><code>value</code>：用于提供基本类型和String类型的数据</li>
<li><code>ref</code>：用于指定其他bean类型的数据。它只能指定在spring的IoC核心容器中出现过的bean对象。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.AccountServiceImpl&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;飞龙在天&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;45&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;time&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置一个日期对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>







<hr>
<h3 id="2-2-set方法注入"><a href="#2-2-set方法注入" class="headerlink" title="2.2    set方法注入"></a>2.2    set方法注入</h3><blockquote>
<p>顾名思义，就是在类初始化时使用中 set 方法给类中的属性赋值，这样创建出来的对象就是有初始值的。</p>
</blockquote>
<ol>
<li>创建JavaBean类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="comment">// 要注入成员    </span></span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;    </span><br><span class="line">    <span class="keyword">private</span> Date birthday;	</span><br><span class="line">    <span class="comment">// set方法    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(Date birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(name+<span class="string">&quot;:&quot;</span>+age+<span class="string">&quot;:&quot;</span>+birthday);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建配置文件，通过配置文件给JavaBean中的属性传值。使用<code>set</code> 方法的方式。</p>
<ul>
<li><p>使用的标签：**<code>&lt;property&gt;</code> **</p>
</li>
<li><p>出现的位置：<code>&lt;bean&gt;</code>标签内部</p>
</li>
<li><p>标签的属性：</p>
<blockquote>
<ol>
<li><code>name</code>：name属性的值与类中字段的值无关，只与<code>set方法</code>有关【去掉set后首字母小写】</li>
<li><code>value</code>：给JavaBean中的属性赋的值是基本数据类型和String类型的。</li>
<li><code>ref</code>:给JavaBean中的属性赋的值是其它bean类型的</li>
</ol>
</blockquote>
</li>
<li><p>实际开发中，此种方法用的较多。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.AccountServiceImpl2&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;施瓦奇迹&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;time&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置一个日期对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="2-3-使用-set-方法注入集合属性"><a href="#2-3-使用-set-方法注入集合属性" class="headerlink" title="2.3    使用 set 方法注入集合属性"></a>2.3    使用 set 方法注入集合属性</h3><ul>
<li>顾名思义，就是给类中的集合成员传值。它用的是set方法注入的方式，只不过变量的数据类型都是集合。</li>
</ul>
<ol>
<li><p>创建一个JavaBean类。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl3</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] arrs;    </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;    </span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets;    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;    </span><br><span class="line">    <span class="keyword">private</span> Properties props;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArrs</span><span class="params">(String[] arrs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arrs = arrs;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLists</span><span class="params">(List&lt;String&gt; lists)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lists = lists;    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.sets = sets;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.maps = maps;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProps</span><span class="params">(Properties props)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.props = props;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;    </span><br><span class="line">        System.out.println(Arrays.toString(arrs));        </span><br><span class="line">        System.out.println(lists);        </span><br><span class="line">        System.out.println(sets);       </span><br><span class="line">        System.out.println(maps);      </span><br><span class="line">        System.out.println(props);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建一个配置文件<code>bean.xml</code>。</p>
<p> 注入集合数据：</p>
<ol>
<li><p>List结构的：</p>
<ul>
<li><p><code>&lt;array&gt;&lt;value&gt;</code></p>
</li>
<li><p><code>&lt;list&gt;&lt;value&gt;</code></p>
</li>
<li><p><code>&lt;set&gt;&lt;value&gt;</code></p>
</li>
</ul>
</li>
<li><p>Map结构的：</p>
<ul>
<li><p><code>&lt;map&gt;&lt;entry&gt;</code></p>
</li>
<li><p><code>&lt;props&gt;&lt;prop&gt;</code></p>
</li>
</ul>
</li>
<li><p>在注入集合数据时，只要结构相同，标签可以互换。</p>
</li>
</ol>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.AccountServiceImpl3&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arrs&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>C<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lists&quot;</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>A<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BB<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span>       </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>C<span class="tag">&lt;/<span class="name">value</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;testA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aaa&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;testB&quot;</span>&gt;</span>               </span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;props&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;propC&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;propD&quot;</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="3-案例：使用纯XML实现单表的CRUD操作"><a href="#3-案例：使用纯XML实现单表的CRUD操作" class="headerlink" title="3    案例：使用纯XML实现单表的CRUD操作"></a>3    案例：使用纯XML实现单表的CRUD操作</h2><blockquote>
<p>  <strong>需求</strong></p>
</blockquote>
<ul>
<li>实现用户的 CRUD 操作</li>
</ul>
<blockquote>
<p>  <strong>技术要求</strong></p>
</blockquote>
<ul>
<li>使用Spring的 IoC 实现对象的管理</li>
<li>使用<code>dbutils</code>作为持久层解决方案</li>
<li>使用<code>c3p0</code>数据源</li>
</ul>
<blockquote>
<p>  <strong>环境搭建</strong></p>
</blockquote>
<ul>
<li>导入依赖</li>
</ul>
<h3 id="1、创建数据库"><a href="#1、创建数据库" class="headerlink" title="1、创建数据库"></a>1、创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE TABLE IF NOT EXISTS USER(	</span><br><span class="line">    id INT(2) AUTO_INCREMENT PRIMARY KEY,	</span><br><span class="line">    username VARCHAR(9) NOT NULL,	</span><br><span class="line">    gender VARCHAR(3) NOT NULL,</span><br><span class="line">    hobby VARCHAR(32)</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO USER(username, gender, hobby)VALUES(&quot;里番&quot;, &quot;男&quot;, &quot;口琴&quot;);</span><br><span class="line">INSERT INTO USER(username, gender, hobby)VALUES(&quot;刘玉豪&quot;, &quot;男&quot;, &quot;篮球&quot;);</span><br><span class="line">INSERT INTO USER(username, gender, hobby)VALUES(&quot;谭思雨&quot;, &quot;男&quot;, &quot;足球&quot;);</span><br></pre></td></tr></table></figure>



<h3 id="2、-编写实体类"><a href="#2、-编写实体类" class="headerlink" title="2、 编写实体类"></a>2、 编写实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 用户的实体类 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;   </span><br><span class="line">    <span class="keyword">private</span> Integer id;   </span><br><span class="line">    <span class="keyword">private</span> String username;  </span><br><span class="line">    <span class="keyword">private</span> String gender;  </span><br><span class="line">    <span class="keyword">private</span> String hobby;   </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +       </span><br><span class="line">            <span class="string">&quot;id=&quot;</span> + id +           </span><br><span class="line">            <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +    </span><br><span class="line">            <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +          </span><br><span class="line">            <span class="string">&quot;, hobby=&#x27;&quot;</span> + hobby + <span class="string">&#x27;\&#x27;&#x27;</span> +        </span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> id;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.id = id; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> username;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.username = username; </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> gender;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHobby</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobby</span><span class="params">(String hobby)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、编写持久层代码"><a href="#3、编写持久层代码" class="headerlink" title="3、编写持久层代码"></a>3、编写持久层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 操作数据库接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;   </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 增   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span>; </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 删   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 改   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;  </span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 查询所有    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 根据id查询  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;&#125;</span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">/*	持久层接口的实现类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;  </span><br><span class="line">    <span class="comment">// dbutils中操作数据库的核心对象，需要注入数据 </span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunner</span><span class="params">(QueryRunner runner)</span> &#123;    </span><br><span class="line">        <span class="built_in">this</span>.runner = runner;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 增 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user (username, gender, hobby) values(?,?,?)&quot;</span>;  </span><br><span class="line">            result = runner.update(sql, user.getUsername(), user.getGender(), user.getHobby());   </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;       </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 删  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">try</span>&#123;         </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user where id=?&quot;</span>;  </span><br><span class="line">            result = runner.update(sql, id);   </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;         </span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;     </span><br><span class="line">            <span class="keyword">return</span> result;      </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 改   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">try</span> &#123;      </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set username=?,gender=?,hobby=? where id=?&quot;</span>;     </span><br><span class="line">            result = runner.update(sql, user.getUsername(), user.getGender(), user.getHobby(),user.getId());   </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;     </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 查询所有   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;      </span><br><span class="line">        List&lt;User&gt; users = <span class="literal">null</span>;     </span><br><span class="line">        <span class="keyword">try</span> &#123;          </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;    </span><br><span class="line">            users = runner.query(sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;User&gt;(User.class));    </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;      </span><br><span class="line">            <span class="keyword">return</span> users;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 查询一个 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;   </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;    </span><br><span class="line">        <span class="keyword">try</span> &#123;         </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id=?&quot;</span>;     </span><br><span class="line">            user = runner.query(sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;User&gt;(User.class), id);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();      </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;        </span><br><span class="line">            <span class="keyword">return</span> user;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、编写业务层代码"><a href="#4、编写业务层代码" class="headerlink" title="4、编写业务层代码"></a>4、编写业务层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 增  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 删  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 改  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 查    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 查  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	业务层接口的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> cn.xsyu.service.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="comment">// 依赖注入  </span></span><br><span class="line">    <span class="keyword">private</span> UserDao dao;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDao</span><span class="params">(UserDao dao)</span> &#123;   </span><br><span class="line">        <span class="built_in">this</span>.dao = dao;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> dao.create(user);  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> dao.delete(id);  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> dao.update(user);  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> dao.findAll();    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> dao.findById(id); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、创建并编写配置文件"><a href="#5、创建并编写配置文件" class="headerlink" title="5、创建并编写配置文件"></a>5、创建并编写配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans      </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--配置service--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.UserServiceImpl&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置dao--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.dao.impl.UserDaoImpl&quot;</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;queryRunner&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置QueryRunner--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;queryRunner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!--配置数据源--&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!--数据库连接必备的信息--&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>/&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="6、编写测试类代码"><a href="#6、编写测试类代码" class="headerlink" title="6、编写测试类代码"></a>6、编写测试类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.test;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 调用Junit单元测试，测试我们的配置 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 测试保存新成员方法 </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="meta">@Test</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate</span><span class="params">()</span>&#123;     </span><br><span class="line">        <span class="comment">// 创建spring工厂      </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);    </span><br><span class="line">        <span class="comment">// 获取可执行对象    </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);   </span><br><span class="line">        <span class="comment">// 执行对象中方法     </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); </span><br><span class="line">        user.setUsername(<span class="string">&quot;spring&quot;</span>);       </span><br><span class="line">        user.setGender(<span class="string">&quot;女&quot;</span>);      </span><br><span class="line">        user.setHobby(<span class="string">&quot;java&quot;</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> service.create(user);    </span><br><span class="line">        System.out.println(result); </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 测试删除方法     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="comment">// 创建spring容器  </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);   </span><br><span class="line">        <span class="comment">// 获取service层对象    </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);       </span><br><span class="line">        <span class="comment">// 调用service层的方法   </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> service.delete(<span class="number">7</span>);     </span><br><span class="line">        <span class="comment">// 获取返回结果      </span></span><br><span class="line">        System.out.println(result); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 测试查询所有 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;    </span><br><span class="line">        <span class="comment">// 获取spring容器    </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取service层对象 </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);   </span><br><span class="line">        <span class="comment">// 调用service层的方法       </span></span><br><span class="line">        List&lt;User&gt; users = service.findAll();    </span><br><span class="line">        <span class="comment">// 获取返回结果   </span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123; </span><br><span class="line">            System.out.println(user);     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 测试查询一个方法   </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindOne</span><span class="params">()</span>&#123;    </span><br><span class="line">        <span class="comment">// 获取sprig容器 </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取service层对象   </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);  </span><br><span class="line">        <span class="comment">// 调用service层的方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> service.findById(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取返回结果     </span></span><br><span class="line">        System.out.println(user); </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 测试update方法 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;   </span><br><span class="line">        <span class="comment">// 获取spring容器     </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);       </span><br><span class="line">        <span class="comment">// 获取service层对象    </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);      </span><br><span class="line">        <span class="comment">// 调用service层的方法     </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> service.findById(<span class="number">1</span>);      </span><br><span class="line">        user.setUsername(<span class="string">&quot;李帆&quot;</span>);        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> service.update(user);      </span><br><span class="line">        <span class="comment">// 获取返回结果  </span></span><br><span class="line">        System.out.println(result);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7、分析"><a href="#7、分析" class="headerlink" title="7、分析"></a>7、分析</h3><ul>
<li>通过上面的测试，我们可以看出，每个测试方法都重新获取了一次spring的核心容器，造成了不必要的重复代码，增加了开发的工作量。这种情况，在开发中应该避免发生。</li>
<li>解决方法：Junit单元测试</li>
</ul>
<hr>
<h1 id="IoC注解开发"><a href="#IoC注解开发" class="headerlink" title="IoC注解开发"></a>IoC注解开发</h1><ul>
<li>  基于XML配置文件开发：指定配置文件的位置，创建容器时加载配置文件，容器是一个 HashMap 结构，key 为 bean 对象的id，值为 id 对应的全限定类名加载到内存中的 Class 对象。</li>
<li>  注解开发：指定要扫描的包，将该包下指定注解的类加载并保存到容器中。</li>
</ul>
<h2 id="1-使用注解开发时要导入的约束"><a href="#1-使用注解开发时要导入的约束" class="headerlink" title="1    使用注解开发时要导入的约束"></a>1    使用注解开发时要导入的约束</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--告知spring创建时，容器要扫描的包[含有注解的包]--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xsyu&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-注解分类"><a href="#2-注解分类" class="headerlink" title="2    注解分类"></a>2    注解分类</h2><h3 id="2-1-用于创建对象的注解"><a href="#2-1-用于创建对象的注解" class="headerlink" title="2.1    用于创建对象的注解"></a>2.1    用于创建对象的注解</h3><p><strong>作用</strong>：它们的作用就和在XML配置文件中编写一个<code>&lt;bean&gt;</code>标签实现的功能是一样的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Component-value-””"><a href="#Component-value-””" class="headerlink" title="@Component(value=””)"></a>@Component(value=””)</h4><ol>
<li><p><strong>作用范围</strong>：作用在类上。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;	<span class="comment">// 类中的代码</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用</strong>：把资源交给容器来管理，把当前类的 Class 对象存入容器中。相当于在 xml 中配置一个<code>&lt;bean&gt;</code></p>
</li>
<li><p><strong>属性</strong>：<code>value</code>：指定<code>&lt;bean&gt;</code>的 id，如果不显式指定value属性，默认<code>&lt;bean&gt;</code>的id是当前类的类名，首字母小写。</p>
</li>
<li><p><strong>Tip</strong>：如果注解中有且仅有一个属性要赋值，且名称是 <code>value</code>时，<code>value</code>可以省略不写。 </p>
</li>
</ol>
<h4 id="Controller、-Service、-Repository"><a href="#Controller、-Service、-Repository" class="headerlink" title="@Controller、@Service、@Repository"></a>@Controller、@Service、@Repository</h4><p>这三个注解是 <strong>@Component</strong> 衍生的注解，它们的作用和属性都是一样的，只不过是提供了更加明确的语义化定义。</p>
<ol>
<li><code>@Controler</code>：    一般用于表现层的注解</li>
<li><code>@Service</code>：    一般用于业务层的注解</li>
<li><code>@Repository</code>：    一般用于持久层的注解</li>
</ol>
<hr>
<h3 id="2-2-依赖注入（注解）"><a href="#2-2-依赖注入（注解）" class="headerlink" title="2.2    依赖注入（注解）"></a>2.2    依赖注入（注解）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--等价于xml中的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1、-Autowired"><a href="#1、-Autowired" class="headerlink" title="1、@Autowired"></a>1、@Autowired</h4><ol>
<li><p>作用范围：①成员变量 ②成员方法</p>
</li>
<li><p>作用：<strong>自动按照类型注入</strong>。    <strong><code>比较顺序：[待注入数据的数据类型--&gt;&gt;待注入数据的变量名]</code></strong></p>
<ul>
<li>如果类代码中待注入对象的数据类型无法和 Spring 容器中的任何一个实例对象相匹配，则报错。</li>
<li>如果 Spring 容器中只有唯一一个实例对象的数据类型与类代码中的数据类型匹配，直接注入成功。    <ul>
<li>如果在 Spring 容器中同时存在多个实例对象可以与类代码中某个对象的数据类型相匹配时，则继续使用类代码中对象的<code>变量名</code>与容器中的<code>id</code>进行匹配，找到了也可以注入成功，找不到就报错。</li>
</ul>
</li>
<li>当使用注解注入属性时，<code>set</code>方法可以省略。</li>
<li><code>@Autowired</code>只能注入其它<code>bean</code>类型【除了基本类型和String以外的类型】。</li>
</ul>
</li>
</ol>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/%E8%87%AA%E5%8A%A8%E6%8C%89%E7%85%A7%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5-1598445621956.png"></p>
<hr>
<h4 id="2、-Qualifier"><a href="#2、-Qualifier" class="headerlink" title="2、@Qualifier"></a>2、@Qualifier</h4><ol>
<li><p>作用范围：①成员变量 ②成员方法中的形式参数</p>
</li>
<li><p>作用：按照名称注入。</p>
<ul>
<li><strong>它在给成员变量注入时不能单独使用，必须在使用<code>@Autowired</code>注解的基础之上再按照名称注入。</strong></li>
<li><strong>但是在给方法中的局部变量（形式参数）注入时可以单独使用。</strong></li>
</ul>
</li>
<li><p>属性：<code>value</code>：指定要注入的数据在IoC容器中<code>bean</code>对应的id。</p>
</li>
<li><p>示例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向账户中存入了2000元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="meta">@Repository()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向账户中存入了1000元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired()</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;accountDaoImpl2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao dao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	执行过程分析：</span></span><br><span class="line"><span class="comment">	  1. 使用 @Repository()注解将 AccountDaoImpl2 加入IoC容器。</span></span><br><span class="line"><span class="comment">	  	 使用 @Repository()注解将 AccountDaoImpl 加入IoC容器。</span></span><br><span class="line"><span class="comment">	  	   [</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl2&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl2&quot;&#125;</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl&quot;&#125;</span></span><br><span class="line"><span class="comment">      		......													    ]</span></span><br><span class="line"><span class="comment">       使用 @Autowired() 注解查找IoC容器中类型为 `AccountDao` 类型的数据，共找到2个</span></span><br><span class="line"><span class="comment">      	[</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl2&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl2&quot;&#125;</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl&quot;&#125;</span></span><br><span class="line"><span class="comment">      																    ]</span></span><br><span class="line"><span class="comment">       3. 使用 `@Qualifier(value=&quot;accountDaoImpl2&quot;)` 注解在容器中筛选出来的字集合中查找id为			     `accountDaoImpl2`的数据，最终找到了:</span></span><br><span class="line"><span class="comment">       		&#123;id=&quot;accountDaoImpl2&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl2&quot;&#125;,</span></span><br><span class="line"><span class="comment">        并将对应的类对象的数据注入。（在这里是创建实例对象，并将引用传给`dao`）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="3、-Resource"><a href="#3、-Resource" class="headerlink" title="3、@Resource"></a>3、@Resource</h4><ol>
<li>作用范围：①成员变量  ②成员方法</li>
<li>作用：直接按照<code>bean</code>的 id 注入，它可以独立使用。它也只能注入其它<code>bean</code>类型</li>
<li>属性：<code>name</code>：指定要注入的数据在 IoC 容器中<code>bean</code>对应的 id。</li>
</ol>
<h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip:"></a>Tip:</h4><ul>
<li>以上3个注入都只能注入其它bean类型的数据，而基本类型和String类型无法使用上述注解实现。</li>
</ul>
<hr>
<h4 id="4、-Value"><a href="#4、-Value" class="headerlink" title="4、@Value"></a>4、@Value</h4><ol>
<li><strong>作用范围</strong>：成员变量</li>
<li><strong>作用</strong>：可以注入基本类型数据和String类型数据</li>
<li><strong>属性</strong>：<code>value</code>：用于指定值。它可以使用 <strong>SpEL</strong> 表达式(Spring的EL表达式)。<ul>
<li>SpEL格式：<code>$&#123;表达式&#125;</code></li>
</ul>
</li>
<li>示例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(value = &quot;666&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向账户中存入了&quot;</span>+money+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="2-3-用于改变作用范围的注解"><a href="#2-3-用于改变作用范围的注解" class="headerlink" title="2.3    用于改变作用范围的注解"></a>2.3    用于改变作用范围的注解</h3><ul>
<li>它们的作用就和<code>&lt;bean&gt;</code>标签中使用<code>scope</code>属性实现的功能时一样的。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><ol>
<li><strong>作用</strong>：用于指定<code>bean</code>的作用范围</li>
<li><strong>属性</strong>：<code>value</code>：指定范围的取值。常用取值：<ol>
<li><code>singleton[单例]</code></li>
<li><code>prototype[多例]</code></li>
<li><code>request</code></li>
<li><code>session</code></li>
<li><code>globalsession</code></li>
</ol>
</li>
</ol>
<h3 id="2-4-和生命周期相关的注解"><a href="#2-4-和生命周期相关的注解" class="headerlink" title="2.4    和生命周期相关的注解"></a>2.4    和生命周期相关的注解</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--相当于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h4><ol>
<li><strong>作用</strong>：用于指定类的初始化方法，即类初始化时先执行的方法。</li>
</ol>
<h4 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h4><ol>
<li><strong>作用</strong>：用于指定类的销毁方法，即类销毁前先执行的方法。</li>
</ol>
<hr>
<h3 id="2-5-关于Spring注解和XML的选择问题"><a href="#2-5-关于Spring注解和XML的选择问题" class="headerlink" title="2.5    关于Spring注解和XML的选择问题"></a>2.5    关于Spring注解和XML的选择问题</h3><blockquote>
<p>  注解的优势</p>
</blockquote>
<ul>
<li>配置简单，维护方便（我们找到了类，就相当于找到了对应的配置）</li>
</ul>
<blockquote>
<p>  XML的优势</p>
</blockquote>
<ul>
<li>修改时，不用修改源码。不涉及重新编译和部署</li>
</ul>
<blockquote>
<p>  Spring管理Bean方式的比较</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">基于XML配置</th>
<th align="left">基于注解配置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Bean定义</td>
<td align="left"><code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code></td>
<td align="left"><code>@Component</code>；衍生类：<code>@Controller、@Service、@Repository</code></td>
</tr>
<tr>
<td align="left">Bean名称</td>
<td align="left">通过<code>id</code>或<code>name</code>指定</td>
<td align="left"><code>@Compoonent(value=&quot;person&quot;)</code></td>
</tr>
<tr>
<td align="left">Bean注入</td>
<td align="left"><code>&lt;property&gt;</code>或<code>&lt;constructor-arg&gt;</code></td>
<td align="left"><code>@Autowired</code>()：按类型注入；  <code>@Qualifier()</code>：按名称注入</td>
</tr>
<tr>
<td align="left">Bean生命周期</td>
<td align="left"><code>init-method</code>；<code>destroy-method</code></td>
<td align="left"><code>@PostConstruct</code>；<code>@PreDestroy</code></td>
</tr>
<tr>
<td align="left">Bean作用范围</td>
<td align="left"><code>scope属性</code></td>
<td align="left"><code>@Scope()</code></td>
</tr>
<tr>
<td align="left">适合场景</td>
<td align="left">Bean来自第三方，使用其它</td>
<td align="left">Bean的实现类由用户自己开发</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-6-新注解说明-区别于XML中功能的注解"><a href="#2-6-新注解说明-区别于XML中功能的注解" class="headerlink" title="2.6    新注解说明(区别于XML中功能的注解)"></a>2.6    新注解说明(区别于XML中功能的注解)</h3><h4 id="1、-Configuration"><a href="#1、-Configuration" class="headerlink" title="1、@Configuration"></a>1、@Configuration</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>用于指定当前类是一个spring的配置类，Spring工厂会读取该类中的配置信息创建容器，相当于读取<code>bean.xml</code>配置文件。</li>
<li>获取容器时需要使用<code>AnnotationApplicationContext(有@Configration注解的类.class)</code>【纯注解开发】</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>value</code>：用于指定配置类的字节码</p>
</li>
<li><p>示例代码</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring配置类，相当于bean.xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ul>
<li>我们已经把配置文件用配置类来代替了，但是如何配置创建容器时要扫描的包呢？</li>
<li>答：<code>@ComponentScan</code>注解</li>
</ul>
</li>
</ol>
<h4 id="2、-ComponentScan"><a href="#2、-ComponentScan" class="headerlink" title="2、@ComponentScan"></a>2、@ComponentScan</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li><p>开启注解扫描，用于指定 Spring 在初始化容器时要扫描的包。</p>
</li>
<li><p>作用和XML配置文件中的 <code>component-scan</code> 是一样的。：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xsyu&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>属性</strong>：</p>
<ul>
<li><code>basePackages</code>：用于指定要扫描的包。</li>
<li><code>value</code>：和<code>basePackages</code>属性的作用是一样的。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring配置类，相当于bean.xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;cn.xsyu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>存在的问题</strong>：</p>
<ul>
<li>我们已经配置好了要扫描的包，但是数据源和<code>JDBCTemplete</code>对象如何从配置文件中转移到注解中呢？</li>
<li>答：<code>@Bean</code>注解</li>
</ul>
</li>
</ol>
<h4 id="3、-Bean"><a href="#3、-Bean" class="headerlink" title="3、@Bean"></a>3、@Bean</h4><ol>
<li><p><strong>作用范围</strong>：方法上【@Component 注解用于将类对象装载到容器中，而 @Bean 注解则用于将方法返回值对象装载到容器中】</p>
</li>
<li><p><strong>作用</strong>：该注解只能作用于方法上，表示将此方法的返回值对象存入 Spring 容器中，并指定唯一标识。</p>
</li>
<li><p><strong>属性</strong>：<code>name</code>：给当前<code>@Bean注解</code>方法创建的对象指定一个唯一标识名称。</p>
</li>
<li><p><strong>示例代码</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接数据库的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个DataSource，并存入spring容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">            ds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            ds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>);</span><br><span class="line">            ds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个QueryRunner对象，并存入spring容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queryRunner&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> QueryRunner <span class="title function_">createQueryRunner</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(dataSource);</span><br><span class="line">        <span class="keyword">return</span> queryRunner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>存在的问题</strong>：</p>
<ul>
<li>我们已经把数据源<code>dataSource对象</code>和<code>queryRunner对象</code>从配置文件中转移到<code>JdbcConfig.java</code>类中了，此时就可以删除<code>bean.xml</code>了。</li>
<li>但是由于没有了配置文件，创建数据源<code>DataSource</code>的配置信息又写死在类中了。如何把它们分离出来呢？</li>
<li>答：<code>@PropertySource</code></li>
</ul>
</li>
</ol>
<hr>
<h4 id="4、-PropertySource"><a href="#4、-PropertySource" class="headerlink" title="4、@PropertySource"></a>4、@PropertySource</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>用于加载<code>xxx.properties</code>文件中的配置信息到内存中。</li>
<li>例如我们配置数据源时，就可以把连接数据库的信息写到<code>properties</code>配置文件中，就可以使用此注解指定<code>properties</code>配置文件的位置。</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>vlaue[]</code>：用于指定<code>properties</code>文件位置。如果配置文件在类路径下，需要写上：<strong>classpath：</strong>。</p>
</li>
<li><p><strong>示例代码</strong>：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.config;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接数据库的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span>	<span class="comment">// 指定配置文件的位置，并加载到容器中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>	<span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个DataSource，并存入spring容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">            ds.setDriverClass(driver);</span><br><span class="line">            ds.setJdbcUrl(url);</span><br><span class="line">            ds.setUser(username);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个QueryRunner对象，并存入spring容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queryRunner&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> QueryRunner <span class="title function_">createQueryRunner</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(dataSource);</span><br><span class="line">        <span class="keyword">return</span> queryRunner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*——————————————————————————————————————————————————————————————————————————————————————————*/</span></span><br><span class="line"></span><br><span class="line">jdbc.properties文件：</span><br><span class="line">    jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">    jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/db5</span></span><br><span class="line">    jdbc.username=root</span><br><span class="line">    jdbc.password=root</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  注意：此时，我们已经有了2个配置类：<code>SpringConfiguration.java</code>和<code>JdbcConfig.java</code>，但是它们之间还没有关系。如何建立它们之间的关系呢？</p>
</blockquote>
<ul>
<li>答：<code>@Import</code></li>
</ul>
<hr>
<h4 id="5、-Import"><a href="#5、-Import" class="headerlink" title="5、@Import"></a>5、@Import</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>用于导入其它配置类。【一个项目中可以有多个配置类】</li>
<li>如果不使用<code>@Import</code>注解，则所有配置类都必须通过添加 <code>@Configuration</code> 来表明自己是一个配置类。</li>
<li>如果使用<code>@Import</code>注解在主配置类中引入其它配置类时，子配置类中的<code>@Configuration</code>注解可以省略。当然，写上也没任何问题。</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>value[]</code>：用于指定子配置类的 Class 类对象。</p>
</li>
<li><p>示例代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring配置类，相当于bean.xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;cn.xsyu&quot;)</span></span><br><span class="line"><span class="meta">@Import(value = &#123;JdbcConfig.class&#125;)</span>		<span class="comment">// 导入`JdbcConfig`子配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>存在的问题</strong>：</p>
<ul>
<li>我们已经把要配置的都配置好了，但是有新的问题产生了，由于没有配置文件了，如何获取Spring容器呢？</li>
</ul>
</li>
</ol>
<h4 id="6、获取容器（注解）"><a href="#6、获取容器（注解）" class="headerlink" title="6、获取容器（注解）"></a>6、获取容器（注解）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);	<span class="comment">// 读取配置类就相当于读取配置文件</span></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h1><blockquote>
<p>  <strong>存在的问题</strong></p>
</blockquote>
<ul>
<li><p>在测试类中，每个测试方法都有以下2行代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取spring容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);</span><br><span class="line"><span class="comment">// 获取service层对象</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>这2行代码的作用是获取spring核心容器，如果不写的话，直接会出现空指针异常，所以又不能轻易删掉。</p>
</li>
</ul>
<blockquote>
<p>  <strong>解决思路</strong></p>
</blockquote>
<ul>
<li>针对上述问题，我们需要的是<strong>程序能自动帮助我们读取配置文件/配置类，并创建Spring容器</strong>。一旦程序能自动为我们创建 Spring 容器，我们就无需手动创建了，问题也自然就解决了。</li>
</ul>
<h2 id="1-junit单元测试的原理"><a href="#1-junit单元测试的原理" class="headerlink" title="1    junit单元测试的原理"></a>1    junit单元测试的原理</h2><ol>
<li>所有程序的入口：<ul>
<li><code>main</code>方法</li>
</ul>
</li>
<li>junit单元测试中，没有<code>main方法</code>也能执行的原理：<ul>
<li>junit单元测试集成了一个<code>main方法</code></li>
<li>该集成方法会判断当前测试类中哪些方法有<code>@Test</code>注解</li>
<li>junit就会让有<code>@Test</code>注解的方法执行。</li>
</ul>
</li>
<li>junit不会关注我们是否使用了<code>spring</code>框架。<ul>
<li>也就是说，在执行测试方法时，junit根本不知道我们是否使用了spring框架。</li>
<li>所以也就不会为我们读取配置文件/配置类，创建spring容器。</li>
</ul>
</li>
<li>由以上3点可知：<ul>
<li>当测试方法执行时，就算添加<code>@Autowired</code>注解，由于没有spring核心容器，也无法实现注入。</li>
</ul>
</li>
<li>解决方案：<ul>
<li>但是junit给我们提供了一个注解，让我们可以替换掉它的运行器。</li>
<li>只要把junit的运行器替换成可以自动读取配置文件，创建spring容器的运行器，就可以解决上述问题了。</li>
<li>Spring框架正好提供了一个运行器，可以<strong>自动</strong>读取配置文件/配置类来创建spring容器。我们只需要告诉它配置文件在哪里就行了。</li>
</ul>
</li>
</ol>
<h2 id="2-配置步骤"><a href="#2-配置步骤" class="headerlink" title="2    配置步骤"></a>2    配置步骤</h2><blockquote>
<p>  Spring整合Junit的配置：</p>
</blockquote>
<ol>
<li><p>导入spring整合Junit的jar(坐标)；</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>使用Junit提供的一个注解把替换原有运行器。</p>
<ul>
<li><code>@Runwith</code></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br></pre></td></tr></table></figure>

</li>
<li><p>告知Spring的运行器，spring的核心容器是基于XML还是注解的，并且说明位置。</p>
<ul>
<li><p><code>@ContextConfiguration</code></p>
<p>  属性：</p>
<ul>
<li><code>locations</code>：指定xml文件的位置。加上<code>classpath关键字</code>，表示在类路径下。</li>
<li><code>classes</code>：指定注解类所在的位置。</li>
</ul>
</li>
<li><p>示例代码</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="comment">// 或 @ContextConfiguration(locations = &#123;&quot;classpath:bean.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
<li><p>使用<code>@Autowired</code>和<code>@Qualifier</code>注解给测试类中的变量注入数据。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;    </span><br><span class="line">    <span class="comment">// 数据注入    </span></span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> UserService service;        </span><br><span class="line">    <span class="meta">@Test</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;        </span><br><span class="line">        <span class="comment">// 调用service层的方法        </span></span><br><span class="line">        List&lt;User&gt; users = service.findAll();        </span><br><span class="line">        <span class="comment">// 获取返回结果        </span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>当我们使用<code>spring 5.X</code>版本时，要求<code>junit</code>的jar必须是<code>12++</code></p>
</li>
</ol>
<hr>
<h1 id="Refresh-源码分析"><a href="#Refresh-源码分析" class="headerlink" title="Refresh 源码分析"></a>Refresh 源码分析</h1><p>refresh 的 12 个步骤</p>
<p><strong>一、准备工作</strong></p>
<ol>
<li> prepareRefresh——做好准备工作</li>
</ol>
<p><strong>二、创建和准备 BeanFactory（基础容器）</strong></p>
<ol start="2">
<li> obtainFreshBeanFactory——创建或获取空的 BeanFactory</li>
<li> prepareBeanFactory——准备 BeanFactory</li>
<li> postProcessBeanFactory——子类扩展 BeanFactory</li>
<li> invokeBeanFactoryPostProcessors——后处理器扩展 BeanFactory</li>
<li> registerBeanPostProcessors——准备 Bean 的后处理器</li>
</ol>
<p><strong>三、创建和准备 ApplicationContext（增强容器）</strong></p>
<ol start="7">
<li> initMessageSource——为 ApplicationContext提供国际化功能</li>
<li> initApplicationEventMulticaster——为ApplicationContext 提供事件发布器</li>
<li> onRefresh——留给子类扩展</li>
<li> registerListeners——为 ApplicationContext 准备监听器</li>
<li> <strong>finishBeanFactoryInitialization</strong>——初始化单例 Bean，执行 Bean 后处理器扩展</li>
<li> finishRefresh——准备生命周期管理器，发布 ContextRefreshed 事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1、prepareRefresh"><a href="#1、prepareRefresh" class="headerlink" title="1、prepareRefresh"></a>1、prepareRefresh</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002093938014.png" alt="image-20211002093938014"></p>
<blockquote>
<p>  <strong>prepareRefresh 方法的作用</strong></p>
</blockquote>
<ol>
<li> 创建（初始化）一个容器，这个容器刚被创建出来的时候是一个空的容器；</li>
<li> 创建（初始化）一个 Environment 对象加入到容器中。</li>
</ol>
<blockquote>
<p>  <strong>Environment 对象的作用</strong></p>
</blockquote>
<p>Environment 实例对象主要负责管理各种键值信息。主要包括：</p>
<ol>
<li> 系统属性的键值对形式（systemProperties）</li>
<li> 系统环境变量的键值对形式（systemEnvironment）</li>
<li>自定义的键值对属性（PropertySource）<ul>
<li>  一般是配置文件中的键值对属性。最常见的就是 SpringBoot 中 <code>application.properties</code> 配置文件，该配置文件中的所有配置信息都是由这个 environment 对象加载并保存的，然后再将这个 environment 实例对象加入到 ApplicationContext 中，容器就间接的知道了配置信息。</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>Environment 使用场景</strong></p>
</blockquote>
<ul>
<li>  Environment 的作用之一就是在 @Value 注解中，根据对应的键注入值，这个值就是从 Environment 中获取的。</li>
</ul>
<hr>
<h2 id="2、obtainFreshBeanFactory"><a href="#2、obtainFreshBeanFactory" class="headerlink" title="2、obtainFreshBeanFactory"></a>2、obtainFreshBeanFactory</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211001211518869.png" alt="image-20211001211518869"></p>
<blockquote>
<p>  <strong>obtainFreshBeanFactory 方法的作用：</strong></p>
</blockquote>
<ul>
<li>  创建（或获取）最新的 BeanFactory 对象。</li>
<li>  虽然 ApplicationContext 在结构上属于 BeanFactory 的子类，但实际上 ApplicationContext 类中包含了一个 BeanFactory ，因为在 ApplicationContext 中，有一些基础功能它并没有自己去实现，而是通过去复用 BeanFactory 内部现成的功能实现的。</li>
</ul>
<blockquote>
<p>  <strong>BeanDefinition</strong></p>
</blockquote>
<ul>
<li>  BeanDefinition 保存了具体对象的键值信息，单例还是多例、等等</li>
<li>  <strong>BeanDefinition 的来源：</strong>BeanDefinition 的来源有多种多样，可以通过 xml 获得、通过配置类获得、通过组件扫描获得、也可以通过编程添加。</li>
</ul>
<blockquote>
<p>  <strong>总结：</strong></p>
</blockquote>
<ul>
<li>  BeanFactory 的作用是负责 Bean 的创建、依赖注入和初始化；</li>
<li>  而 BeanDefinition 作为 Bean 的设计蓝图，则规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等；</li>
</ul>
<blockquote>
<p>  <strong>测试：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; 一开始&quot;</span>);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();  <span class="comment">// BeanFactory 的一个实现类</span></span><br><span class="line">        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames));</span><br><span class="line">        <span class="comment">// 刚创建好的 beanFactory 对象，内部是没有任何 BeanDefinition 信息的</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; （1）从 xml 中获取&quot;</span>);</span><br><span class="line">        <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">        reader.loadBeanDefinitions(<span class="string">&quot;myBean.xml&quot;</span>);   <span class="comment">// 从 xml 文件中获取 BeanDefinition 信息</span></span><br><span class="line">        String[] beanDefinitionNames1 = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames1));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; （2）从配置类中获取&quot;</span>);</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;myConfig&quot;</span>, BeanDefinitionBuilder.genericBeanDefinition(MyConfig.class).getBeanDefinition());  <span class="comment">// 将配置类加入到容器中</span></span><br><span class="line">        <span class="comment">// 通过后处理器，将配置类中还存在的其它对象也加入到容器中</span></span><br><span class="line">        <span class="type">ConfigurationClassPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassPostProcessor</span>();</span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(beanFactory);</span><br><span class="line">        String[] beanDefinitionNames2 = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; （3）扫描获取（包扫描）&quot;</span>);</span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(beanFactory);</span><br><span class="line">        scanner.scan(<span class="string">&quot;cn.xsyu&quot;</span>);    <span class="comment">// 指定要扫描的包</span></span><br><span class="line">        String[] beanDefinitionNames3 = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3、prepareBeanFactory"><a href="#3、prepareBeanFactory" class="headerlink" title="3、prepareBeanFactory"></a>3、prepareBeanFactory</h2><blockquote>
<p>  <strong>prepareBeanFactory 方法的作用</strong></p>
</blockquote>
<ol>
<li> 完善 BeanFactory ==&gt; 继续初始化 BeanFactory 中的成员变量</li>
<li> 解析 SpEL</li>
<li> 执行类型转换</li>
<li> 特殊 bean 的注入</li>
<li> 两个内置的 BeanPostProcessor 的作用</li>
</ol>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211001214801077.png" alt="image-20211001214801077"></p>
<ul>
<li>  上图中 BeanFactory 内部的变量，由白色变为绿色部分就是在 prepareBeanFactory 方法中进行变量初始化的。</li>
<li>  beanExpressResolver：解析 SpEL 表达式的</li>
<li>  propertyEditorRegistars：注册类型转换器（在值注入的时候可能会发生类型转换，比如 String 类型转为 Integer 类型等等）</li>
<li>  resolvableDependencies：管理特殊 bean 的一个 Map 结构，在 Spring 中，大部分的 bean 对象都被单例池（singletonObjects）所管理，但是还有一部分特殊对象，比如 BeanFactory 自身、或者 ApplicationContext 等等，这些对象并没有保存在单例池中，但是我们从使用者的角度来看，依然能够调用到它们，这是因为这些特殊对象被保存在 resolvableDependencies 对象池中</li>
<li>  beanPostProcessors：主要用于对 bean 创建时能够使用一些扩展功能。</li>
</ul>
<h2 id="4、postProcessBeanFactory"><a href="#4、postProcessBeanFactory" class="headerlink" title="4、postProcessBeanFactory"></a>4、postProcessBeanFactory</h2><blockquote>
<p>  <strong>postProcessBeanFactory 方法的作用</strong></p>
</blockquote>
<ul>
<li>  这一步是空实现，留给子类扩展</li>
<li>  掌握对应的设计模式：模板方法设计模式——主要的脉络都由父类规定死了，但是有一些可以扩展的方法留空了，留给子类去扩展。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  总结：</p>
</blockquote>
<p>一般 Web 环境下的 ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory。</p>
<hr>
<h2 id="5、invokeBeanFactoryPostProcessors"><a href="#5、invokeBeanFactoryPostProcessors" class="headerlink" title="5、invokeBeanFactoryPostProcessors"></a>5、invokeBeanFactoryPostProcessors</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211001221038451.png" alt="image-20211001221038451"></p>
<blockquote>
<p>  <strong>invokeBeanFactoryPostProcessors 方法的作用</strong></p>
</blockquote>
<p>beanFactory 有两个扩展点，</p>
<ul>
<li>  第一个扩展点就是在第 4 步提到的 postProcessBeanFactory ，在父类中没有具体的方法实现，交由子类进行扩展；</li>
<li>  第二个扩展点就是在第 5 步由 Bean 工厂的后处理器来进行扩展，主要用来补充或修改 BeanDefinition</li>
</ul>
<blockquote>
<p>  <strong>常见的 beanFactory 后处理器</strong></p>
</blockquote>
<ul>
<li>  ConfigurationClassPostProcessor：解析 @Configuration、@Bean、@Import、@PropertySource 等修饰的对象，并加载其 BeanDefinition 到 ApplicationContext 中</li>
</ul>
<blockquote>
<p>  <strong>总结：</strong></p>
</blockquote>
<ul>
<li>  beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition</li>
</ul>
<h2 id="6、registerBeanPostProcessors"><a href="#6、registerBeanPostProcessors" class="headerlink" title="6、registerBeanPostProcessors"></a>6、registerBeanPostProcessors</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002153102533.png" alt="image-20211002153102533"></p>
<ol>
<li> bean 的后处理器（第5步的是BeanFactory的后处理器）</li>
<li> 常见的 bean 后处理器</li>
</ol>
<p>在 BeanDefinitionMap 中查看是否有自定义的类实现了 BeanPostProcessors 接口，如果实现了就把这个自定义的类作为一个 bean 的后处理器注册到容器中，具体就是 beanPostProcessors 集合中去。</p>
<blockquote>
<p>  总结：</p>
</blockquote>
<ul>
<li>  bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段</li>
<li>常见的 bean 的后处理器<ul>
<li>  AutowiredAnnotationBeanPostProcessor，功能：解析 @Autowired，@Value 注解</li>
<li>  CommonAnnotationBeanPostProcessor，功能：解析 @Resource，@PostConstruct，@PreDestory 注解</li>
<li>  AnnotationAwareAspectJAutoProxyCreator，功能：为符合切点的目标 bean 自动创建代理</li>
</ul>
</li>
</ul>
<h2 id="7、initMessageSource"><a href="#7、initMessageSource" class="headerlink" title="7、initMessageSource"></a>7、initMessageSource</h2><p>从第 7 开始，回到 ApplicationContext 。</p>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002153624068.png" alt="image-20211002153624068"></p>
<ol>
<li> 新加入一个 MessageSource 对象，用于提供国际化功能。</li>
</ol>
<p>MessageSource 从哪里来？</p>
<ul>
<li>  在容器中 BeanDefinitionMap 中查找是否存在一个 messageSource 的 bean（实现了 MessageSource 接口的对象），如果没有，则提供空的 MessageSource 的实现（空实现就是不支持国际化）。</li>
</ul>
<h2 id="8、initApplicationEventMulticaster"><a href="#8、initApplicationEventMulticaster" class="headerlink" title="8、initApplicationEventMulticaster"></a>8、initApplicationEventMulticaster</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002153714170.png" alt="image-20211002153714170"></p>
<blockquote>
<p>  作用</p>
</blockquote>
<ul>
<li>  初始化一个事件广播器</li>
<li>  广播器的作用就是发送事件给监听器，将发生的事件发送给各个监听器对象</li>
<li>  监听器的作用是监听广播器发送的事件</li>
</ul>
<blockquote>
<p>  广播器从哪里来</p>
</blockquote>
<ul>
<li>  先去 BeanDefinitionMap 中找，如果能找到，则使用自定义的事件广播器</li>
<li>  如果没有提供，则使用默认的事件广播器</li>
<li>  广播器内部有一个集合，这个集合中维护了所有的监听器</li>
<li>  可以从容器中找名为 applicationEventMulticaster 的 bea 作为事件广播器，若没有，则会新建默认的事件广播器</li>
<li>  可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件</li>
</ul>
<blockquote>
<p>  如何发布事件</p>
</blockquote>
<h2 id="9、onRefresh"><a href="#9、onRefresh" class="headerlink" title="9、onRefresh"></a>9、onRefresh</h2><ul>
<li>  这一步是空实现，留给子类扩展</li>
<li>  掌握对应的设计模式——模板方法设计模式</li>
</ul>
<ul>
<li>  SpringBoot 中的子类可以在这里准备 WebServer，即内嵌 web 容器</li>
</ul>
<h2 id="10、registerListeners"><a href="#10、registerListeners" class="headerlink" title="10、registerListeners"></a>10、registerListeners</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002154659370.png" alt="image-20211002154659370"></p>
<ul>
<li>  注册监听器对象</li>
<li>  用来接收事件</li>
</ul>
<blockquote>
<p>  监听器从何而来</p>
</blockquote>
<ol>
<li> 通过编程事先添加</li>
<li> BeanDefinitionMap 中存在实现了 ApplicationListener 的接口，</li>
<li> 还有一部分来自于 @EventListenr 注解的解析</li>
</ol>
<p>会把容器中的监听器都找到，添加到对应的广播器的集合中去，当发生事件后，广播器就会发送消息给监听器</p>
<ul>
<li>  如何接收事件</li>
</ul>
<p>实现 ApplicationListener 接口，必须重写其中的 onApplicationEvent(E e) 方法，方法参数 E 就是监听的对象，当对象发生改变时，就会触发该方法，可以在该方法中编写具体的业务处理逻辑。</p>
<h2 id="11、finishBeanFactoryInitialization"><a href="#11、finishBeanFactoryInitialization" class="headerlink" title="11、finishBeanFactoryInitialization"></a>11、finishBeanFactoryInitialization</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002155343583.png" alt="image-20211002155343583"></p>
<ol>
<li> conversionService：用来做类型转换，作为对 propertyEditorRegister 的补充，都是类型转换，但是这个功能更加强大</li>
<li> embeddedValueResolvers：解析 <code>$&#123;&#125;</code>，对 Environment 进行再一次的封装，底层调用的还是 Environment 中的方法来完成对 <code>$&#123;&#125;</code> 的解析，只不过它是属于 BeanFactory 的成员方法。</li>
<li> singletonObjects：找到所有的非延迟创建的单例对象，创建对象并保存到单例池中</li>
</ol>
<blockquote>
<p>  总结</p>
</blockquote>
<ul>
<li>  conversionService 也是一套类型转换机制，作为对 PropertyEditor 的补充</li>
<li>  内嵌值解析器用来解析 @Value 中的 ${} ，借用的是 Environment 中的功能</li>
<li>  单例池用来缓存所有的单例对象，对象的创建都分为三个阶段，每一阶段都有不同的 bean 后处理器参与进来，进行功能上的扩展。</li>
</ul>
<h2 id="12、finishRefresh"><a href="#12、finishRefresh" class="headerlink" title="12、finishRefresh"></a>12、finishRefresh</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002160408973.png" alt="image-20211002160408973"></p>
<ol>
<li> 创建 lifecycleProcessor，生命周期处理器。</li>
<li> 发布 ContextRefreshed 事件，表示整个容器创建已经完成</li>
</ol>
<blockquote>
<p>  从哪来？</p>
</blockquote>
<ol>
<li> 先去 BeanDefinitionMap 中找，没有则创建一个默认的</li>
</ol>
<blockquote>
<p>  总结</p>
</blockquote>
<ol>
<li> 用来控制容器内，需要生命周期管理的 bean</li>
<li> 如果容器中有名为 lifecycleProcessor 的 bean 就用它，如果没有就创建默认的生命周期管理器。</li>
<li> 调用 applicationContext 的 start 方法，就可以触发所有实现了 LifeCycle 接口的 bean 的 start。（总控）</li>
<li> 调用 applicationContext 的 stop 方法，就可以触发所有实现了 LifeCycle 接口的 bean 的 stop。（总控）</li>
</ol>
<hr>
<h1 id="Spring-bean-的生命周期"><a href="#Spring-bean-的生命周期" class="headerlink" title="Spring bean 的生命周期"></a>Spring bean 的生命周期</h1><ul>
<li>  阶段1：别名解析，查询缓存</li>
<li>  阶段2：检查父工厂</li>
<li>  阶段3：检查 DependsOn</li>
<li>阶段4：按 Scope 创建 bean<ul>
<li>  创建 singleton</li>
<li>  创建 prototype</li>
<li>  创建其它 scope</li>
</ul>
</li>
<li>阶段5：创建 bean<ul>
<li>  创建 bean 实例</li>
<li>  依赖注入</li>
<li>  初始化</li>
<li>  登记可销毁 bean</li>
</ul>
</li>
<li>  阶段6：类型转换</li>
<li>  阶段7：销毁 bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doGetBean 是 bean 对象生命周期的起点</span></span><br><span class="line"><span class="comment">// AbstractBeanFactory#doGetBean</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br></pre></td></tr></table></figure>

<p>为什么 doGetBean 是 bean 对象生命周期的起点？</p>
<ul>
<li>  因为 Spring 容器中的 bean 都是一些懒加载的对象，只要在第一次获取这个对象的时候，才会触发该 bean 的创建过程，所以起点方法名叫做 doGetBean</li>
</ul>
<h2 id="阶段1：别名解析，查询缓存"><a href="#阶段1：别名解析，查询缓存" class="headerlink" title="阶段1：别名解析，查询缓存"></a>阶段1：别名解析，查询缓存</h2><ol>
<li><p><strong>别名解析</strong></p>
<ul>
<li>  在 Spring 中，一个 bean 可以有多个别名，而在创建对象的时候希望通过不同的别名能够找到同一个 bean 对象。所以首先就需要把别名解析为真实名称（全限定类名），然后再进行后续处理。</li>
</ul>
</li>
<li><p><strong>查询缓存</strong></p>
<ul>
<li>  根据全限定类名从缓存中查看是否已经有创建好的实例对象</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singletonObjects 是一级缓存，存放单例成品对象</span><br><span class="line">earlySingletonObjects 是二级缓存，存放单例工程的产品，可称为提前单例对象</span><br><span class="line">singleFactories 是三级缓存，存放单例工厂。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  二级和三级缓存主要为了解决循环依赖</p>
</blockquote>
<hr>
<h2 id="阶段2：处理父子容器"><a href="#阶段2：处理父子容器" class="headerlink" title="阶段2：处理父子容器"></a>阶段2：处理父子容器</h2><ul>
<li>  在阶段 1 中我们了解到，在获取对象时，首先从缓存中查找，如果缓存中存在，就直接从缓存中获取。那如果缓存中不存在就会直接创建 bean 对象吗？也不是！</li>
<li>  如果容器还有父容器，那么会先去父容器中查找，在父容器中如果能直接匹配到 bean 对象，创建对象的流程也会直接结束。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>  父、子容器中的 bean 名称可以重复</li>
<li>  优先查找子容器的 bean，找到了直接返回，找不到再继续到父容器中去查找。</li>
</ul>
<hr>
<h2 id="阶段3：dependsOn"><a href="#阶段3：dependsOn" class="headerlink" title="阶段3：dependsOn"></a>阶段3：dependsOn</h2><ul>
<li>  大部分 bean 之间是有依赖关系的，比如 A 依赖了 B，B 依赖了 C，那么在创建 A 对象的时候，必须保证先将 B 和 C 创建出来。</li>
<li>  但是有一些 bean 之间是没有依赖关系的，但是我们又想要控制这些 bean 的创建顺序，那么就需要用到 dependsOn。比如 A、B 两个对象间没有依赖关系，但是又希望 B 先于 A 创建，那么我们就需要设置 A dependsOn B，这样就能保证 B 一定先于 A 创建。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>  dependsOn 用于控制那些没有显式依赖的 bean 对象间的创建顺序</li>
</ul>
<h2 id="阶段4：按-Scope-创建-bean"><a href="#阶段4：按-Scope-创建-bean" class="headerlink" title="阶段4：按 Scope 创建 bean"></a>阶段4：按 Scope 创建 bean</h2><ul>
<li>  创建 singleton</li>
<li>  创建 prototype</li>
<li>  创建其它 scope</li>
</ul>
<h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSingletonScope</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    applicationContext.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">    applicationContext.registerBean(CommonAnnotationBeanPostProcessor.class);   <span class="comment">// 注册一个后处理器</span></span><br><span class="line">    applicationContext.refresh();   <span class="comment">// refresh方法在第11步底层就是调用了 getBean 方法 ==&gt; getBean 会调用 init 方法</span></span><br><span class="line">    applicationContext.close();     <span class="comment">// 当容器销毁的时候，就会调用 destroy 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrototypeScope</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    applicationContext.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class, bd -&gt; bd.setScope(<span class="string">&quot;prototype&quot;</span>));  <span class="comment">// 指定创建的对象为多例</span></span><br><span class="line">    applicationContext.registerBean(CommonAnnotationBeanPostProcessor.class);   <span class="comment">// 注册一个后处理器</span></span><br><span class="line">    applicationContext.refresh();   <span class="comment">// refresh方法在第11步底层就是调用了 getBean 方法 ==&gt; getBean 会调用 init 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 多例 bean 从首次 getBean 时才被创建，到调用 BeanFactory 的 destroyBean 方法销毁。（即如果只是单纯的refresh不会创建多例对象）*/</span></span><br><span class="line">    <span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> applicationContext.getBean(Bean2.class);</span><br><span class="line">    <span class="comment">/* 销毁方法也需要我们手动调用 */</span></span><br><span class="line">    applicationContext.getDefaultListableBeanFactory().destroyBean(bean2);</span><br><span class="line"></span><br><span class="line">    applicationContext.close();     <span class="comment">// 当容器销毁的时候，就会调用 destroy 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<ul>
<li>  scope 理解为从 xxx 范围内找这个 bean 更加贴切</li>
<li>  singleton 表示从单例池范围内获取 bean，如果没有，则创建并放入单例池。</li>
<li>  prototype 表示从不缓存 bean，每次都创建新的</li>
<li>  request 表示从 request 对象范围内获取 bean，如果没有，则创建并放入 request 中。</li>
</ul>
<h2 id="阶段5：创建-bean"><a href="#阶段5：创建-bean" class="headerlink" title="阶段5：创建 bean"></a>阶段5：创建 bean</h2><ul>
<li>  创建 bean 实例</li>
<li>  依赖注入</li>
<li>  初始化</li>
<li>  登记可销毁 bean</li>
</ul>
<p>146</p>
<h2 id="阶段6：类型转换"><a href="#阶段6：类型转换" class="headerlink" title="阶段6：类型转换"></a>阶段6：类型转换</h2><h2 id="阶段7：销毁-bean"><a href="#阶段7：销毁-bean" class="headerlink" title="阶段7：销毁 bean"></a>阶段7：销毁 bean</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/05/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/05/%E5%9B%BE/" class="post-title-link" itemprop="url">图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-05 11:19:45" itemprop="dateCreated datePublished" datetime="2021-08-05T11:19:45+08:00">2021-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-06 17:32:24" itemprop="dateModified" datetime="2021-08-06T17:32:24+08:00">2021-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="图是什么"><a href="#图是什么" class="headerlink" title="图是什么"></a>图是什么</h1><blockquote>
<p>  <strong>图 = 节点集合 + 边的集合</strong></p>
</blockquote>
<p>​        图是一种用来表示相连数据的数据结构，类似我们的社交网络，图中有很多的节点，每个节点代表一个数据，每个节点可以和其他节点相连。其中每个节点叫做<strong>顶点（vertex）</strong>，连接顶点之间的线叫做<strong>边（edge）</strong>。</p>
<p>​        下图就是一个用来表示社交网络的图数据结构：在此图中，我们含有 5 个顶点和 6 条相连线，每个顶点包含了人名，而连接线代表相连人名之间是朋友关系。</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph1.jpg" alt="img"></p>
<p>​        如果我们要更正式地表示图，那么图就可以用一对<strong>（V，E）集合</strong>来表示，其中 V 是一堆<strong>顶点的集合</strong>，而 E 是一堆<strong>边的集合</strong>，如下图所示：在此图中：<code>V = &#123;a, b, c, d, e&#125;，E = &#123;ab, ac, bd, cd, de&#125;</code></p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph2.jpg" alt="img"></p>
<p>上面提到的图是无向图，而常见的图有以下三种：</p>
<ol>
<li> <strong>无向图（Undirected Graph）</strong>：在无向图中，每个顶点和其他顶点通过边连接。</li>
<li> <strong>有向图（Directed Graph）</strong>：有向图中的边是有方向的。</li>
<li> <strong>权重图（Weighted Graph）</strong>：在权重图中，每条边有各自的权重。</li>
</ol>
<p>下图是有向图：此图可以用来表示用户之间相互关注的情况，如果Mark指向Alice，则代表Mark关注了Alice。</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph3.jpg" alt="img"></p>
<p>下图是权重图：此图可以用来表示两个好友之间的亲密程度，数值越高代表越亲密。</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph4.jpg" alt="img"></p>
<hr>
<h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>图有多种存储方式，常见的两种：一种是用<strong>矩阵（Matrix）</strong>的形式来实现，另一种是用<strong>链表（List）</strong>的形式来实现。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><img src="/2021/08/05/%E5%9B%BE/Graph5.png" alt="img"></p>
<p>每行代表相应的顶点，如果 <code>M[i][j] = 1</code>，那么就代表顶点 i 连向 j，如果是 0，则表达顶点间没有联系。用矩阵的方式来实现图的优势很明显，我们可以很快地判断两个顶点之间是否相连，可是用矩阵实现的空间复杂度很高，我们需要 <strong>O(V^2^)</strong> 来记录所有的数据，不管顶点之间是否有相连线。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>为了解决空间复杂度的问题，我们可以使用链表的方式来实现图：</p>
<p><img src="/2021/08/05/%E5%9B%BE/Graph6.png" alt="img"></p>
<p>在链表实现中，我们实际上使用了储存链表的数组来表示图，图的左侧用数组来实现，代表我们的所有顶点，而每个顶点含有一个链表，链表上储存了该顶点指向的顶点。</p>
<h1 id="图存储结构的代码实现（Java）"><a href="#图存储结构的代码实现（Java）" class="headerlink" title="图存储结构的代码实现（Java）"></a>图存储结构的代码实现（Java）</h1><h2 id="无向图的矩阵实现"><a href="#无向图的矩阵实现" class="headerlink" title="无向图的矩阵实现"></a>无向图的矩阵实现</h2><blockquote>
<p>  <strong>Graph.java</strong>：无向图的数据结构</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图</span></span><br><span class="line"><span class="comment"> *  1、图 = 节点集合 + 边的集合</span></span><br><span class="line"><span class="comment"> *  2、图的表示方法：①邻接矩阵（二维数组）  ②邻接表（链表形式）</span></span><br><span class="line"><span class="comment"> *     本例中我们采用邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="comment">// 节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;  <span class="comment">// 边的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; <span class="comment">// 表示边的数目【非必需】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化顶点集合和边的集合（矩阵）</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边（建立两个顶点之间的联系）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    起始顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    结束顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    边的权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向图而言，所有的边都是双向的，构造成的矩阵是一个对称矩阵，</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据下标得到对应的顶点数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到顶点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rows : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>测试类</strong></p>
</blockquote>
<img src="/2021/08/05/%E5%9B%BE/image-20210806153141817.png" alt="image-20210806153141817" style="zoom: 67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 12:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 顶点的个数</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        </span><br><span class="line">        String[] vertexes = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : vertexes) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 总共的边为：A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>执行结果</strong></p>
</blockquote>
<p><img src="/2021/08/05/%E5%9B%BE/image-20210805122136982.png" alt="image-20210805122136982"></p>
<hr>
<h1 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h1><blockquote>
<p>  <strong>思想</strong></p>
</blockquote>
<ol>
<li> 首先访问出发点 <strong>v</strong> ，并将其标记为已访问过；</li>
<li> 然后选取与 v 邻接的、未被访问的任意一个顶点 <strong>w</strong> ，并访问它；</li>
<li> 再选取与 w 邻接的未被访问的任一顶点并访问，以此重复进行；</li>
<li> 当一个顶点的所有邻接顶点都被访问过时，则依次退回到最近被访问过的顶点，若该顶点还有其它邻接顶点未被访问，则从这些未被访问的顶点中取一个并重复上述访问过程，直至图中所有顶点都被访问过为止。</li>
</ol>
<blockquote>
<p>  <strong>图示</strong></p>
</blockquote>
<p>下面以“有向图”为例，来对深度优先搜索进行演示：</p>
<img src="/2021/08/05/%E5%9B%BE/Graph7.png" alt="img" style="zoom:150%;">

<p>对于上面的图，我们从顶点A开始搜索：</p>
<img src="/2021/08/05/%E5%9B%BE/Graph8.png" alt="img" style="zoom: 150%;">



<p>以下是具体的遍历步骤：</p>
<blockquote>
<ol>
<li> 访问A</li>
<li> 访问B（在访问A之后，接下来应该访问的是A出发的另一个顶点，既顶点B）</li>
<li> 访问C（在访问B之后，接下来访问的是从B出发的另一个顶点，既C，E，F。在此图中，我们按照字母排序顺序访问，因此先访问C。）</li>
<li> 访问E（接下来访问与C连接的另一个顶点E。）</li>
<li> 访问D（接下来访问从E出发的顶点B和D，因为B已被访问过，所以访问顶点D。）</li>
<li> 访问F（接下来回溯“访问B的另一个连接顶点F”）</li>
<li> 访问G</li>
</ol>
</blockquote>
<p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G。</p>
<p>在图的深度优先搜索中，我们尽可能先遍历一个顶点可以达到的最深处，其中可能会出现的问题就是会有循环出现，所以我们需要一个数组来记录哪些节点已经被访问过。</p>
<blockquote>
<p>  <strong>代码实现</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图</span></span><br><span class="line"><span class="comment"> *  1、图 = 节点集合 + 边的集合</span></span><br><span class="line"><span class="comment"> *  2、图的表示方法：①邻接矩阵（二维数组）  ②邻接表（链表形式）</span></span><br><span class="line"><span class="comment"> *     本例中我们采用邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="comment">// 节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;  <span class="comment">// 边的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; <span class="comment">// 表示边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[] isVisited; <span class="comment">// 定义布尔型数组，记录某个节点是否被访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化节点集合和边的集合（矩阵）</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    边的起始顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    边的结束顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向图而言，构造成的矩阵是一个对称矩阵，所有的边都是双向的</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回顶点i对应的数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rows : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个顶点的深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 随机选择一个顶点作为深度优先遍历的起始顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">// 首先访问顶点 v 并输出</span></span><br><span class="line">        System.out.print(getValueByIndex(v) + <span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 将该节点设置为已访问过</span></span><br><span class="line">        isVisited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找与顶点 v 邻接的、未被访问的任意任一个顶点 w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getEffectiveNeighbor(v);</span><br><span class="line">        <span class="keyword">if</span> (w != -<span class="number">1</span>)&#123;   <span class="comment">// 说明存在邻接顶点未被访问</span></span><br><span class="line">            <span class="comment">// 递归地访问顶点 w</span></span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不存在满足条件的顶点 w，则说明顶点 v 已经遍历完毕了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找与与顶点 v 邻接的、未被访问的任一顶点 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEffectiveNeighbor</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][j] == <span class="number">1</span> &amp;&amp; isVisited[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 dfs 进行一个重载，完成整体图中所有的顶点的遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 isVisited 数组</span></span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的节点，进行 dfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h1><blockquote>
<p>  <strong>思想</strong></p>
</blockquote>
<ol>
<li> 首先访问起始顶点 v ，</li>
<li> 然后选取与 v 邻接的、未被访问过的全部顶点 w<del>1</del>，w<del>2</del>，…，w<del>n</del> 进行访问；</li>
<li> 再依次访问 w<del>1</del>，w<del>2</del>，…，w<del>n</del> 邻接的全部顶点（已访问过的除外）</li>
<li> 以此类推，直到所有顶点都被访问过了为止。</li>
</ol>
<blockquote>
<p>  <strong>主要步骤：</strong></p>
</blockquote>
<ol>
<li> 任取图中的一个顶点访问，入队，并将这个顶点标记为已访问；</li>
<li> 当队列不为空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队；</li>
<li> 当队列为空时跳出循环，广度优先搜索即完成。</li>
</ol>
<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jmx.remote.internal.ArrayQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 图</span></span><br><span class="line"><span class="comment"> *  1、图 = 节点集合 + 边的集合</span></span><br><span class="line"><span class="comment"> *  2、图的表示方法：①邻接矩阵（二维数组）  ②邻接表（链表形式）</span></span><br><span class="line"><span class="comment"> *     本例中我们采用邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="comment">// 节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;  <span class="comment">// 边的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; <span class="comment">// 表示边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[] isVisited; <span class="comment">// 定义布尔型数组，记录某个节点是否被访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化节点集合和边的集合（矩阵）</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    边的起始顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    边的结束顶点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于无向图而言，构造成的矩阵是一个对称矩阵，所有的边都是双向的</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回顶点i对应的数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rows : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(rows));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个顶点的深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 随机选择一个顶点作为深度优先遍历的起始顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">// 首先访问顶点 v 并输出</span></span><br><span class="line">        System.out.print(getValueByIndex(v) + <span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 将该节点设置为已访问过</span></span><br><span class="line">        isVisited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找与顶点 v 邻接的、未被访问的任意任一个顶点 w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getEffectiveNeighbor(v);</span><br><span class="line">        <span class="keyword">if</span> (w != -<span class="number">1</span>)&#123;   <span class="comment">// 说明存在邻接顶点未被访问</span></span><br><span class="line">            <span class="comment">// 递归地访问顶点 w</span></span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不存在满足条件的顶点 w，则说明顶点 v 已经遍历完毕了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找与与顶点 v 邻接的、未被访问的任一顶点 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEffectiveNeighbor</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][j] == <span class="number">1</span> &amp;&amp; isVisited[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 dfs 进行一个重载，完成整体图中所有的顶点的遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 isVisited 数组</span></span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的节点，进行 dfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对顶点 v 进行广度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        LinkedList&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、访问顶点 v 并输出</span></span><br><span class="line">        System.out.print(getValueByIndex(v) + <span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、将节点标记为已访问</span></span><br><span class="line">        isVisited[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 3、将顶点加入队列</span></span><br><span class="line">        queue.addLast(v);</span><br><span class="line">        <span class="comment">// 4、当队列不为空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队；</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出队头节点的下标 u，访问 u 的所有未被访问过的邻接节点</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">u</span> <span class="operator">=</span> (Integer) queue.removeFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="built_in">this</span>.getEffectiveNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>)&#123;    <span class="comment">// 证明顶点 u 存在未被访问过的邻接节点 w</span></span><br><span class="line">                System.out.print(getValueByIndex(w) + <span class="string">&quot;--&gt;&quot;</span>);   <span class="comment">//输出</span></span><br><span class="line">                isVisited[w] = <span class="literal">true</span>;    <span class="comment">// 标记为已访问</span></span><br><span class="line">                queue.addLast(w);   <span class="comment">// 入队</span></span><br><span class="line">                w = <span class="built_in">this</span>.getEffectiveNeighbor(u);   <span class="comment">// 更新 w 的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以下一个队头顶点 u 为起始顶点，查找其未被访问的所有邻接顶点（提现广度优先）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 bfs 进行一个重载，完成整体图中所有的顶点的遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                bfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>测试</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/5 12:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 节点的个数</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line"></span><br><span class="line">        String[] vertexes = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : vertexes) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 总共的边为：A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：dfs深度优先遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;深度优先遍历=================&quot;</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：bfs广度优先遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;广度优先遍历=================&quot;</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">JVM体系结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-02 22:47:30" itemprop="dateCreated datePublished" datetime="2021-08-02T22:47:30+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 09:53:06" itemprop="dateModified" datetime="2021-08-03T09:53:06+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><p>​        JVM 只是一个概念，而 <code>Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</code> 则是 JVM 的一个落地产品，HotSpot 是 Orecle 平台默认的 Java 虚拟机。常见的 JVM 的落地产品还有：JRockit、J9 等。</p>
<h2 id="1-HotSpot"><a href="#1-HotSpot" class="headerlink" title="1    HotSpot"></a>1    HotSpot</h2><p>​        在装有JDK的电脑上，输入 <code>java -version</code> 命令，会展示如下信息：</p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210416102603356.png"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_141&quot;</span>	</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>  <code>Java HotSpot(TM)</code>，是指<code>Java HotSpot</code>虚拟机，它是JVM的一个落地产品，TM 是 TradeMark，就是商标，就像苹果一样，是个牌子。</li>
<li>  <code>64-Bit</code> 指的是当前安装的虚拟机版本是64位，版本号为 <code>build 25.141-b15</code>，</li>
<li>  运行在<code>mixed mode</code>下，因为 Java 是一种办解释半编译型语言，<code>mixed mode</code> 代表混合模式。</li>
</ul>
</blockquote>
<hr>
<h2 id="2-Java——跨平台的语言"><a href="#2-Java——跨平台的语言" class="headerlink" title="2    Java——跨平台的语言"></a>2    Java——跨平台的语言</h2><p>Java 语言具有跨平台性！可以实现 <strong>write once，run anywhere</strong> ，一次编译，到处运行。</p>
<ol>
<li> Java 程序即开发人员编写的源代码文件；</li>
<li> 源代码文件首先会被编译成字节码文件；</li>
<li> 这些所有的字节码文件可以在任何安装了 JVM 虚拟机的平台上运行。</li>
</ol>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg"></p>
<hr>
<h2 id="3-JVM——跨语言的平台"><a href="#3-JVM——跨语言的平台" class="headerlink" title="3    JVM——跨语言的平台"></a>3    JVM——跨语言的平台</h2><p>​        JVM 并不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心<strong>字节码</strong>文件。 也就是说 <strong>JVM 拥有语言无关性</strong>，并不与 Java 语言绑定，只要其它编程语言的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其它的辅助信息，它就是一个有效的字节码文件，就能被 JVM 识别、装载和运行！</p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"></p>
<blockquote>
<ul>
<li><strong>字节码文件</strong> 可以是由不同的编程语言编译后形成的。</li>
<li>只要不同的编程语言通过各自的编译器编译形成的字节码文件遵循Java虚拟机的规范，就可以在Java虚拟机上解释运行！</li>
<li>也就是说，JVM 虚拟机并不强制要求开发的源代码是否是用Java语言实现的。</li>
</ul>
</blockquote>
<hr>
<h2 id="4-字节码"><a href="#4-字节码" class="headerlink" title="4    字节码"></a>4    字节码</h2><ul>
<li><p>我们一般讲的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说：任何能在 JVM 平台上执行的字节码格式都是一样的，所以应该统称为：<strong>JVM 字节码</strong></p>
</li>
<li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</p>
<p>  [比如要实现在控制台输出 “HelloWorld！” 的功能，我们可以通过 Java 语言实现也可以通过 Js 语言实现，这两种编程语言各自的源代码文件是不同的，分别是 <code>.java</code> 和 <code>.js</code>，但是通过各自的编译器编译成的 JVM 字节码文件就是一样的，也就是通过不同的编译器编译出相同的字节码文件。    当然，这个字节码文件也可以在不同的 JVM 虚拟机上运行]</p>
</li>
<li><p>Java 虚拟机 与 Java 语言并没有必然的联系，它只与特定的二进制文件格式——Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或称为字节码、Bytecodes）和符号表，还有一些其它辅助信息。</p>
</li>
</ul>
<h2 id="5-多语言混合编程"><a href="#5-多语言混合编程" class="headerlink" title="5    多语言混合编程"></a>5    多语言混合编程</h2><ul>
<li><p><em>Java 平台上的多语言混合编程正在成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</em></p>
</li>
<li><p>什么是多语言混合编程？</p>
<blockquote>
<p>在一个项目之中，并行处理用 Clojure 语言开发，展示层使用 JRuby/Rails 语言开发，中间层则用 Java 开发，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<strong>各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便透明，因为它们都运行在一个虚拟机上</strong>。</p>
</blockquote>
</li>
<li><p>能够实现这样一个组合的原因，是因为大家都能在 JVM 平台上运行。</p>
</li>
</ul>
<h2 id="6-虚拟机"><a href="#6-虚拟机" class="headerlink" title="6    虚拟机"></a>6    虚拟机</h2><ul>
<li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。</p>
</li>
<li><p>虚拟机的作用就是为程序提供一个运行环境，例如我们的JVM虚拟机就是给字节码文件提供一个运行环境，如果没有JVM虚拟机，就无法直接在Windows环境下运行字节码文件。</p>
</li>
<li><p>大体上，虚拟机可分为 <strong>系统虚拟机</strong> 和 <strong>程序虚拟机</strong>。</p>
<blockquote>
<p>常见的 Visual Box、VMware 就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</p>
<p>程序虚拟机的典型代表就是 Java 虚拟机，它专门为执行单个计算机程序而设计，在 Java 虚拟机中执行的指令被称为 Java 字节码指令。 </p>
</blockquote>
<p>  程序虚拟机只作用于某个特定的程序上，而系统虚拟机就相当于另一台电脑，在系统虚拟机中可以继续安装程序虚拟机。</p>
</li>
<li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
</li>
</ul>
<h2 id="7-Java-虚拟机"><a href="#7-Java-虚拟机" class="headerlink" title="7    Java 虚拟机"></a>7    Java 虚拟机</h2><ul>
<li><p>Java 虚拟机就是一台执行 JVM 字节码的虚拟计算机，它拥有独立的运行机制，其运行的字节码未必由 Java 语言编译而成。</p>
</li>
<li><p>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。</p>
</li>
<li><p>Java 技术的核心就是 Java 虚拟机（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机上。</p>
</li>
<li><p><strong>Java 虚拟机就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释/编译为对应操作系统上的机器指令执行。  每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数、怎么处理操作数、处理结果放在哪里。</p>
</li>
<li><p>特点</p>
<blockquote>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h2 id="8-JVM-的位置"><a href="#8-JVM-的位置" class="headerlink" title="8    JVM 的位置"></a>8    JVM 的位置</h2><ul>
<li>  JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</li>
</ul>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg"></p>
<ul>
<li></li>
</ul>
<h2 id="9-JVM-的整体结构"><a href="#9-JVM-的整体结构" class="headerlink" title="9    JVM 的整体结构"></a>9    JVM 的整体结构</h2><ul>
<li>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构。</li>
</ul>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg"></p>
<h3 id="Class-Loader-Subsystem"><a href="#Class-Loader-Subsystem" class="headerlink" title="Class Loader Subsystem"></a>Class Loader Subsystem</h3><blockquote>
<p><strong>类加载器子系统</strong></p>
</blockquote>
<ul>
<li>主要作用就是将 <code>.class</code> 字节码文件加载到<strong>内存</strong>中形成一个 Class 对象。</li>
</ul>
<h3 id="Runtime-Data-Area"><a href="#Runtime-Data-Area" class="headerlink" title="Runtime Data Area"></a>Runtime Data Area</h3><blockquote>
<p><strong>运行时数据区</strong></p>
</blockquote>
<ul>
<li>方法区 和 堆 是多线程共享的，</li>
<li>程序计数器、本地方法栈和虚拟机栈是每个线程独有一份的。</li>
</ul>
<h3 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h3><blockquote>
<p>执行引擎</p>
</blockquote>
<ul>
<li>主要作用就是将内存中 <code>.class</code> 字节码文件形成的 Class 对象编译成底层机器能够识别的机器指令。</li>
</ul>
<h2 id="10-Java-代码的执行流程"><a href="#10-Java-代码的执行流程" class="headerlink" title="10    Java 代码的执行流程"></a>10    Java 代码的执行流程</h2><p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210416190414894.png"></p>
<h2 id="11-JVM-的架构模型"><a href="#11-JVM-的架构模型" class="headerlink" title="11    JVM 的架构模型"></a>11    JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另一种指令集架构则是基于寄存器的指令集架构。</p>
<blockquote>
<p>  <strong>总结：</strong></p>
</blockquote>
<p><strong>由于跨平台的设计，Java 的指令都是根据栈来设计的。</strong>  不同平台 CPU 架构不同，所以不能设计为基于寄存器的。  优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>​           </p>
<h2 id="12-JVM-的生命周期"><a href="#12-JVM-的生命周期" class="headerlink" title="12    JVM 的生命周期"></a>12    JVM 的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java 虚拟机的启动是通过引导类加载器（BootStrap Class Loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机内部实现的。</p>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul>
<li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</li>
<li>程序开始执行它才运行，程序结束时它就停止。</li>
<li>执行一个所谓的 Java 程序的时候，真正执行的是一个叫做 Java 虚拟机的进程。</li>
</ul>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下几种情况：</p>
<ol>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到了异常或错误而异常终止。</li>
<li>由于操作系统出现错误而导致 Java 虚拟机进程终止。</li>
<li>某线程调用 Runtime 类或 System 类的 <code>exist</code> 方法，或 Runtime 类的 <code>halt</code> 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或写在 Java 虚拟机时，Java 虚拟机的退出情况。</li>
</ol>
<hr>
<h1 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h1><p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E8%8B%B1.jpg"></p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE-1621267020283.jpg" alt="第02章_JVM架构-简图"></p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E8%8B%B1-1621267020283.jpg" alt="第02章_JVM架构-英"></p>
<p><img src="/2021/08/02/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E4%B8%AD-1621267020284.jpg" alt="第02章_JVM架构-中"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-02 22:19:15" itemprop="dateCreated datePublished" datetime="2021-08-02T22:19:15+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-03 09:22:58" itemprop="dateModified" datetime="2021-08-03T09:22:58+08:00">2021-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>排序算法稳定性小结：</strong></p>
</blockquote>
<p><strong>快些选一堆</strong>是不稳定的排序算法，其它都是稳定的！</p>
<ul>
<li>  快排</li>
<li>  希尔</li>
<li>  选择</li>
<li>  堆排</li>
</ul>
<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li> 选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</li>
<li> 从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。</li>
<li>找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的<br> 值才交换。</li>
<li> 直到 <strong>从前往后的比较索引&gt;从后往前比较的索引</strong>，结束第一次循环。</li>
<li> 此时，对于基准值来说，左边都比基准值小，右边都比基准值大，这个基准值就到达排序的最终位置了。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">注解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-02 19:18:11 / Modified: 20:37:52" itemprop="dateCreated datePublished" datetime="2021-08-02T19:18:11+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java<code>注解(Annotation)</code>又称为<code>元数据</code>。</p>
<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><blockquote>
<p><code>元注解</code>就是用来标志注解的注解。</p>
</blockquote>
<ol>
<li><p><code>@Retention</code></p>
<p> 标识如何存储，是只在代码中，还是编入class文件中，或者在运行阶段可以通过反射访问。</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：注解只保留在源文件，当Java被编译成<code>.class</code>文件后，注解被遗弃。</li>
<li><code>RetentionPolicy.CLASS</code>：注解被保留到<code>.class</code>文件，但当JVM将<code>.class</code>文件加载到内存中时，注解被遗弃。<strong>这是缺省值</strong>。</li>
<li><code>RetentionPolicy.RUNTIME</code>：注解不仅被保存到<code>.class</code>文件，而且JVM加载<code>.class</code>文件后依然存在。</li>
</ul>
</li>
<li><p><code>@Documented</code>：</p>
<p> 标记这些注解是否保存在JavaDoc中。</p>
</li>
<li><p><code>@Target</code>：</p>
<p> 标记这个注解可以修饰的范围。<code>Annotation</code>的修饰范围：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span>&#123;</span><br><span class="line">    TYPE,</span><br><span class="line">    FIELD,</span><br><span class="line">    METHOD,</span><br><span class="line">    PARAMETER,</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    PACKAGE,</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    TYPE_USE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Inherited</code>：</p>
<p> 标记这个注解是继承于哪个<strong>注解类</strong>的。</p>
<blockquote>
<p>注解是不支持继承的。</p>
</blockquote>
</li>
<li><p><code>@SafeVarargs</code>：</p>
<p> 在声明可变参数的构造函数或方法时，Java编译器会包<code>unchecked</code>警告，使用该注解可忽略这些警告。</p>
</li>
<li><p><code>@FunctionalInterface</code>：</p>
<p> 标识这个方法是一个函数式接口</p>
</li>
<li><p><code>@Repeatable</code>：</p>
<p> 标识某注解可以在同一个声明上使用多次。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%9E%9A%E4%B8%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%9E%9A%E4%B8%BE/" class="post-title-link" itemprop="url">枚举</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-02 18:42:10 / Modified: 19:17:41" itemprop="dateCreated datePublished" datetime="2021-08-02T18:42:10+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><ul>
<li>  Java中，被 <strong>enum</strong> 关键字修饰的类型就是枚举类型。</li>
<li>  枚举类型是一种特殊的数据类型。它是一种与 Class、Interface、Annotation 平级的数据类型。</li>
<li>  <strong>枚举是指具有固定实例个数的类</strong>。普通的类可以根据需求创建任意多个实例，但是在枚举中实例的个数是有限制的。</li>
<li>  枚举虽然<strong>有构造函数</strong>，但其构造函数默认都是私有的，所以只能在当前类中使用<code>new</code>关键字创建对象。</li>
<li>  <strong>当需要定义一组常量时，强烈建议使用枚举类。</strong></li>
<li>  <strong>如果枚举类中只一个对象，则可以作为一种单例模式的实现方式。</strong></li>
<li>  <code>枚举类型(enum)</code>、<code>类(Class)</code>、<code>接口(Interface)</code>、<code>注解类(Annotation)</code>处于同一级。</li>
<li>  注解类不是注解，注解类的作用是定义注解的业务逻辑</li>
</ul>
<p><img src="/2021/08/02/%E6%9E%9A%E4%B8%BE/image-20201026191110428.png" alt="image-20201026191110428"></p>
<hr>
<h1 id="如何定义枚举类"><a href="#如何定义枚举类" class="headerlink" title="如何定义枚举类"></a>如何定义枚举类</h1><blockquote>
<p>  <strong>Before：没有枚举类之前，定义一组常量的方式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeekDemo</span>&#123;</span><br><span class="line">	<span class="comment">// 一组常量，表示周一到周日</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> MONDAY=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> TUESDAY=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> WEDNESDAY=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> THURSDAY=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> FRIDAY=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> SATURDAY=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> SUNDAY=<span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>After：利用枚举重新定义：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumWeekDemo</span> &#123;</span><br><span class="line">    MONDAY,</span><br><span class="line">    Tuesday,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY,</span><br><span class="line">    SUNDAY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="枚举的实现原理"><a href="#枚举的实现原理" class="headerlink" title="枚举的实现原理"></a>枚举的实现原理</h1><ol>
<li> 我们使用关键字 <code>enum</code> 定义枚举类，这个类在编译后，编译器会为我们生成一个相关的 class 类，也就是说枚举类型在编译后也是一个 class 类型，而且类继承自 <strong>java.lang.Enum</strong>。</li>
<li> 上文中的代码在加载到内存中后，会生成<strong>一个 Class 对象</strong>：<strong>EnumWeekDemo</strong>；</li>
<li> 除此之外，还会生成 <strong>7 个 EnumWeekDemo 类的实例对象</strong>，分别对应枚举类中定义的7个日期；</li>
</ol>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<ul>
<li>  枚举类表示有固定实例个数的类，这些实例就是根据自身枚举类创建的实例对象，具体有多个个实例根据你在枚举类中写了多少个就有多少个。</li>
<li>  枚举类中的每个实例对象是 <strong>public static final</strong> 的，即可以通过类名直接访问，且不可变，可用于存储常量对象。</li>
</ul>
<hr>
<h1 id="枚举类中常用的静态方法"><a href="#枚举类中常用的静态方法" class="headerlink" title="枚举类中常用的静态方法"></a>枚举类中常用的静态方法</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>values()</code></td>
<td align="center">获取枚举中的所有变量，并作为数组返回</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>valueOf(String name)</code></td>
<td align="center">根据名称获取枚举变量</td>
</tr>
</tbody></table>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h2 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h2><p>模拟枚举类的内部实现，即不适用 enum 关键字实现与枚举类型相同的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明Season对象的属性: private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.私化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.其他诉求2：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-enum"><a href="#使用-enum" class="headerlink" title="使用 enum"></a>使用 enum</h2><p>JDK 5 中新增了 enum 用于定义枚举类。</p>
<blockquote>
<p>  <strong>使用 enum 关键字的枚举类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的实例对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.私化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="枚举类常用方法（继承于java-lang-Enum类）"><a href="#枚举类常用方法（继承于java-lang-Enum类）" class="headerlink" title="枚举类常用方法（继承于java.lang.Enum类）"></a>枚举类常用方法（继承于java.lang.Enum类）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line">    <span class="comment">// toString():返回枚举类对象的名称（枚举类默认继承的Enum类中重写了toString方法，这里可以直接调用）</span></span><br><span class="line">    System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line">    System.out.println(Season1.class.getSuperclass());</span><br><span class="line">    System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// values():返回所的枚举类对象构成的数组</span></span><br><span class="line">    Season1[] values = Season1.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        System.out.println(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line">    <span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line">    System.out.println(winter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="如何让枚举类对象实现接口"><a href="#如何让枚举类对象实现接口" class="headerlink" title="如何让枚举类对象实现接口"></a>如何让枚举类对象实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/02/%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/02/%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">泛型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-02 16:33:49 / Modified: 18:32:18" itemprop="dateCreated datePublished" datetime="2021-08-02T16:33:49+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="泛型的引入背景"><a href="#泛型的引入背景" class="headerlink" title="泛型的引入背景"></a>泛型的引入背景</h1><blockquote>
<p>  <strong>JDK5 之前</strong></p>
</blockquote>
<p>​        集合类在设计阶段阶段不能确定这个集合到底实际存的是什么类型的对象，所以在 JDK5 之前只能把元素类型设计为 Object，如果我们对集合不做任何限定，它就可以存储任何类型的对象。如果一个集合中存储了多种数据类型的元素，那么在编译后这些元素都会向上转型为Object类型。这样的话，当我们取出任一元素想执行其特有的方法时，就必须采用向下转型。然而由于集合中元素的数据类型不同，所以没有一个统一的标准可以一次性将集合中的所有元素向下转型。</p>
<blockquote>
<p>  <strong>从 JDK5 开始</strong></p>
</blockquote>
<p>​        在JDK1.5++，新增了<strong>泛型（Generic）</strong>语法。让你在设计 API 时可以指定类或方法支持泛型，这样我们使用API时也变得更为简洁，并得到了编译时期的语法检查。</p>
<p>​        JDK5 之后使用泛型来解决这个问题。因为这个时候除了元素的类型不确定，其它的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此<strong>此时把元素的类型设计成一个参数</strong>，这个类型参数叫做<strong>泛型</strong>。</p>
<h1 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h1><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<ul>
<li>  <strong>泛型</strong>：可以在<strong>类中或方法</strong>中预支的使用未知的类型。</li>
<li>  所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时确定。比如：①继承或实现这个接口时；  ②创建对象时；  ③传入实际的类型参数时，也称为类型实参；</li>
<li>  <strong>泛型的使用</strong>：定义时不指定数据类型，使用时再指定数据类型。</li>
</ul>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<ol>
<li> <strong>泛型是在定义时使用的；</strong></li>
<li> 使用时才指定泛型的具体类型；</li>
<li> <strong>当没有指定泛型时，默认类型为 Object 类型。</strong></li>
<li> Collection虽然可以存储不同类型的对象，但实际使用时我们建议一般只存储同一类型的对象。</li>
</ol>
<hr>
<h1 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h1><ol>
<li>将运行时期的<code>ClassCastException</code>，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ol>
<hr>
<h1 id="泛型在集合中的使用"><a href="#泛型在集合中的使用" class="headerlink" title="泛型在集合中的使用"></a>泛型在集合中的使用</h1><h2 id="JDK5-之前"><a href="#JDK5-之前" class="headerlink" title="JDK5 之前"></a>JDK5 之前</h2><blockquote>
<p>  <strong>存在的问题：</strong></p>
</blockquote>
<ol>
<li> 类型不安全</li>
<li> 强转时，可能出现 ClassCastException</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// 需求：存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">76</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题一：类型不安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">        <span class="comment">// 问题二：强转时，可能出现ClassCastException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/02/%E6%B3%9B%E5%9E%8B/image-20210802165130946.png" alt="image-20210802165130946"></p>
<hr>
<h2 id="JDK5-之后"><a href="#JDK5-之后" class="headerlink" title="JDK5 之后"></a>JDK5 之后</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">87</span>);</span><br><span class="line">    list.add(<span class="number">99</span>);</span><br><span class="line">    <span class="comment">// 编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);	// 发生编译时异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//        for(Integer score : list)&#123;</span></span><br><span class="line"><span class="comment">//            //避免了强转操作</span></span><br><span class="line"><span class="comment">//            int stuScore = score;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            System.out.println(stuScore);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二：</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/02/%E6%B3%9B%E5%9E%8B/image-20210802165301817.png" alt="image-20210802165301817"></p>
<h2 id="JDK7-新特性：类型推断"><a href="#JDK7-新特性：类型推断" class="headerlink" title="JDK7 新特性：类型推断"></a>JDK7 新特性：类型推断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以HashMap为例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();	// JDK7之前</span></span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();	<span class="comment">// jdk7新特性：类型推断</span></span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">67</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型的嵌套</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="集合中使用泛型总结"><a href="#集合中使用泛型总结" class="headerlink" title="集合中使用泛型总结"></a>集合中使用泛型总结</h2><ul>
<li><p>  集合接口或集合类从 JDK5 开始都修改为带泛型的结构。</p>
</li>
<li><p>  在实例化集合类时，可以指明具体的泛型类型。</p>
</li>
<li><p>指明完以后，在集合类或接口中凡是使用到泛型的位置，都会转换为具体的数据类型。</p>
<p>  比如：add(E e)  —&gt; 实例化以后：add(Integer e)</p>
</li>
<li><p>  注意点：<strong>泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型时，拿包装类替换</strong>。</p>
</li>
<li><p>  <strong>如果实例化时，没指明泛型的类型。默认类型为 <code>java.lang.Object</code> 类型。</strong></p>
</li>
</ul>
<hr>
<h1 id="泛型的语法（自定义泛型类、泛型接口、泛型方法）"><a href="#泛型的语法（自定义泛型类、泛型接口、泛型方法）" class="headerlink" title="泛型的语法（自定义泛型类、泛型接口、泛型方法）"></a>泛型的语法（自定义泛型类、泛型接口、泛型方法）</h1><h2 id="1-定义和使用带泛型的类"><a href="#1-定义和使用带泛型的类" class="headerlink" title="1    定义和使用带泛型的类"></a>1    定义和使用带泛型的类</h2><blockquote>
<p>  <strong>定义：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>使用：</strong>（== 什么时候确定泛型）</p>
</blockquote>
<p>定义类的时候，只是表明了该类将会使用泛型，但<strong>具体的泛型类型，是在创建实例对象的时候指定的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义带泛型的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArratList</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用：创建对象时，根据创建对象时指定的泛型不同，集合中保存数据的类型也不同。但是class类只有一个。</span></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>





<h2 id="2-定义和使用含有泛型的接口"><a href="#2-定义和使用含有泛型的接口" class="headerlink" title="2    定义和使用含有泛型的接口"></a>2    定义和使用含有泛型的接口</h2><blockquote>
<p>  <strong>定义</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>使用：</strong></p>
</blockquote>
<ol>
<li> <strong>定义实现类(子类)时确定泛型的类型</strong>。</li>
<li> <strong>始终不缺定泛型的类型，直到创建对象时，才确定泛型的类型</strong>。</li>
</ol>
<ul>
<li>  <strong>接口A</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&lt;T&gt;&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用：</span></span><br><span class="line"><span class="comment">      1. 定义实现类时确定泛型的类型</span></span><br><span class="line"><span class="comment">      2. 始终不缺定泛型的类型，直到创建对象时，才确定泛型的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> Class C&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">A</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">psvm&#123;</span><br><span class="line">    C&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">C</span>&lt;Integer&gt;();    <span class="comment">// 直到创建对象时，才确定泛型的类型为Integer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  定义实现类 B 的时候确定泛型的类型：此时 <code>class B</code> 就不再是泛型类了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&lt;Integer&gt;&#123; <span class="comment">// 此时，泛型E的值就是Integer，类 B 就不是泛型类了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  直到创建对象 C 时，才确定泛型的类型：此时 <code>class C</code> 仍然是泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">A</span>&lt;T&gt;&#123;  <span class="comment">// 在实现类的定义阶段并没有确定泛型的类型， class C 仍然是泛型类</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        C&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">C</span>&lt;&gt;();   <span class="comment">// 直到创建对象时，才确定泛型的类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-定义和使用带泛型的方法"><a href="#3-定义和使用带泛型的方法" class="headerlink" title="3    定义和使用带泛型的方法"></a>3    定义和使用带泛型的方法</h2><blockquote>
<p>  <strong>定义：</strong></p>
</blockquote>
<ul>
<li>  泛型方法：在方法中出现了泛型结构的方法就叫做泛型方法。</li>
<li>  <strong>泛型参数与类的泛型参数没任何关系。</strong></li>
<li>  换句话说就是，<strong>泛型方法所属的类是不是泛型类都没关系</strong>。</li>
<li>  泛型方法，可以是一个静态方法。【原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。】</li>
<li>  泛型可以声明在参数列表中的参数上；</li>
<li>  也可以声明在方法的返回值上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;E&gt; 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4    代码演示"></a>4    代码演示</h2><blockquote>
<ol>
<li> <strong>Order.java</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的内部结构就可以使用类的泛型</span></span><br><span class="line">    T orderT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        T[] arr = new T[10];</span></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String orderName, <span class="type">int</span> orderId, T orderT)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下的个方法都是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span>&#123;   <span class="comment">// 泛型声明在返回值中</span></span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span>&#123;    <span class="comment">// 泛型声明在参数列表中</span></span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, orderT=&quot;</span> + orderT +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法中不能使用类的泛型。</span></span><br><span class="line"><span class="comment">//    public static void show(T orderT)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        try&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;catch(T t)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 泛型方法可以是静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (E e : arr) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li> <strong>SubOrder.java</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubOrder</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (E e : arr) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li> <strong>测试</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">    <span class="comment">// 要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setOrderT(<span class="number">123</span>);</span><br><span class="line">    order.setOrderT(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建议：实例化时指明类的泛型</span></span><br><span class="line">    Order&lt;String&gt; order1 = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;String&gt;(<span class="string">&quot;orderAA&quot;</span>, <span class="number">1001</span>, <span class="string">&quot;order:AA&quot;</span>);</span><br><span class="line">    order1.setOrderT(<span class="string">&quot;AA:hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SubOrder</span> <span class="variable">sub1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubOrder</span>();</span><br><span class="line">    <span class="comment">// 由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。</span></span><br><span class="line">    sub1.setOrderT(<span class="number">1122</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 泛型不同的引用不能相互赋值。</span></span><br><span class="line">    <span class="comment">// list1 = list2;   // 编译时异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试泛型方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;();</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 泛型方法在调用时，指明泛型参数的类型。</span></span><br><span class="line">    List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-注意点"><a href="#5-注意点" class="headerlink" title="5    注意点"></a>5    注意点</h2><ol>
<li> 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：<code>&lt;E, T, K, V&gt;</code></li>
<li> 泛型的不同引用之间不能相互赋值。</li>
<li> 泛型如果不指定，将被擦除，泛型对应的类型均按照 Object 处理。</li>
<li> 如果泛型结构是一个抽象类或接口，则不可能创建一个泛型类的对象。</li>
<li> JDK7 中，新增了自动类型推断，简化了泛型的操作。</li>
<li> 泛型在使用时不能用基本数据类型，可以使用包装类替代。</li>
<li> 在 <code>类/接口</code> 上声明的泛型，在本类或本接口中即代表某种具体类型，可以作为非静态属性的类型，非静态方法的参数类型和返回值类型。但<strong>在静态方法中不能使用类的泛型</strong>。</li>
<li> <strong>静态方法中也可以使用泛型，但静态方法中使用的泛型是独立的泛型，而不是泛型类（或泛型接口）上声明的泛型。</strong></li>
<li> <strong>异常类不能是泛型的</strong>。即如果一个类实现或继承了 Exception 系列的类或接口，它就不能再使用泛型了。</li>
<li> 不能使用 <code>E e = new E[]</code>，但可以使用 **E[] = (E[])new Object[capacity]**。</li>
<li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型<ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>  ①没有类型，擦除；    </li>
<li>  ②指定具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>  ①全部保留</li>
<li>  ②部分保留</li>
</ul>
</li>
</ul>
</li>
<li> 子类除了指定或保留父类的泛型外，还可以增加自己的泛型。</li>
</ol>
<hr>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><ul>
<li>  在定义类、接口或方法时，使用泛型可以将数据类型的确定延后到创建对象或调用方法时，但是如果直到创建对象或调用方法时也还不能确定使用什么数据类型或要使用多种数据类型时，可以采用通配符<code>&lt;?&gt;</code>表示。</li>
<li>  但是一旦使用泛型通配符后，就只能使用Object类中的公共方法，集合中对象自身特有的方法就无法被调用。</li>
</ul>
<h2 id="1-通配符的基本使用"><a href="#1-通配符的基本使用" class="headerlink" title="1    通配符的基本使用"></a>1    通配符的基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        getElements(list1);</span><br><span class="line">        Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        getElements(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElements</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;</span><br><span class="line">        <span class="comment">// ?代表可以接收任意类型数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> <code>getElements</code> 方法第一次传递了 Integer 类型的集合，第二次传递了 String 类型的集合；</li>
<li> 如果要想通过同一个方法处理这些参数，可通过设置 <code>getElements()</code> 方法的形参为 <code>(ArrayList&lt;?&gt; arr)</code>或其父类表示。</li>
</ol>
<h2 id="2-通配符的高级使用——受限泛型"><a href="#2-通配符的高级使用——受限泛型" class="headerlink" title="2    通配符的高级使用——受限泛型"></a>2    通配符的高级使用——受限泛型</h2><p>在 Java 中，通过通配符可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<blockquote>
<ol>
<li> <strong>泛型的上限</strong></li>
</ol>
</blockquote>
<ul>
<li><p>格式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名称 &lt;? extends 类&gt; 对象名称</span><br></pre></td></tr></table></figure></li>
<li><p>  含义：在指定泛型的类型时，只能设置为该类型或其子类。</p>
</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>泛型的下限</strong></li>
</ol>
</blockquote>
<ul>
<li><p>格式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名称 &lt;? <span class="built_in">super</span> 类&gt; 对象名称</span><br></pre></td></tr></table></figure></li>
<li><p>  含义：：在指定泛型的类型时，只能设置为该类型或其父类。</p>
</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>代码演示</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// Number类型是Integer类型的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        ArrayList&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        getElement1(list1);</span><br><span class="line">        getElement1(list2);     <span class="comment">// 报错</span></span><br><span class="line">        getElement1(list3);</span><br><span class="line">        getElement1(list4);     <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        getElement2(list1);     <span class="comment">// 报错</span></span><br><span class="line">        getElement2(list2);     <span class="comment">// 报错</span></span><br><span class="line">        getElement2(list3);</span><br><span class="line">        getElement2(list4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用getElement1方法时，只能接收Number类型及其子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(ArrayList&lt;? extends Number&gt; arr)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用getElement2方法时，只能接收Number类型及其父类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Number&gt; arr)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3    注意点"></a>3    注意点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list = list1;	<span class="comment">// 编译通过</span></span><br><span class="line">    list = list2;	<span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">//        list1 = list2;  // 编译时异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list = list3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加(写入)：对于List&lt;?&gt;，不能向其内部添加数据，除了添加null之外。</span></span><br><span class="line">    <span class="comment">//        list.add(&quot;DD&quot;);	// 编译时异常</span></span><br><span class="line">    list.add(<span class="literal">null</span>);	<span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>涉及通配符的集合的数据的写入和读取</strong>：如上面代码所示</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/31/%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/31/%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-07-31 10:35:42 / Modified: 12:34:29" itemprop="dateCreated datePublished" datetime="2021-07-31T10:35:42+08:00">2021-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1    是什么"></a>1    是什么</h2><p><strong>定义</strong>：异常是指程序在执行过程中出现的非正常情况，最终会导致程序的非正常停止。</p>
<p>【异常并不是语法错误，语法错误的话编译时就会直接报错，不会产生字节码文件，根本不能运行。】</p>
<ul>
<li>在 Java 等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出了一个异常对象。</li>
<li>Java处理异常的方式是<strong>中断处理</strong>。</li>
</ul>
<h2 id="2-异常的体系结构"><a href="#2-异常的体系结构" class="headerlink" title="2    异常的体系结构"></a>2    异常的体系结构</h2><blockquote>
<ul>
<li>  Throwable 是<strong>类</strong>，不是接口</li>
<li>  同样的，Error 和 Exception 继承了 Throwable ，所以它俩也是<strong>类</strong></li>
<li>  RuntimeException 继承了 Exception，也是一个<strong>类</strong>；</li>
<li>  但是 CheckedException 并没有真正地继承 Exception 类，并且它是一个<strong>接口</strong>。</li>
</ul>
</blockquote>
<p><img src="/2021/07/31/%E5%BC%82%E5%B8%B8/Throwable.png"></p>
<p>​        在 Java 中，所有的异常都有一个共同的祖先 <strong>java.lang.Throwable</strong> 类。Throwable 类有两个重要的子类 <strong>Exception</strong>（异常） 和 <strong>Error</strong>（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* java.lang.Throwable</span><br><span class="line">* 		|-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">* 		|-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">* 			|------编译时异常(checked)</span><br><span class="line">* 					|-----IOException</span><br><span class="line">* 						|-----FileNotFoundException</span><br><span class="line">* 					|-----ClassNotFoundException</span><br><span class="line">* 			|------运行时异常(unchecked,RuntimeException)</span><br><span class="line">* 					|-----NullPointerException</span><br><span class="line">* 					|-----ArrayIndexOutOfBoundsException</span><br><span class="line">* 					|-----ClassCastException</span><br><span class="line">* 					|-----NumberFormatException</span><br><span class="line">* 					|-----InputMismatchException</span><br><span class="line">* 					|-----ArithmeticException</span><br></pre></td></tr></table></figure>





<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><blockquote>
<p>  <strong>java.lang.Error</strong></p>
</blockquote>
<p><strong>Error 错误是程序无法处理的错误</strong>。大多数是 JVM 层面的问题。即代码在逻辑上是正确的，但是由于 JVM 内存不足或者某些对象申请的内存空间过大导致等原因导致程序出现错误。 这些错误是在编译期是不可查的，因为它们在应用程序的控制和处理能力之外。</p>
<p>​        例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 <code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><blockquote>
<p>  <strong>java.lang.Exception</strong></p>
</blockquote>
<p><strong>Exception 是程序本身可以处理的异常</strong>。Exception 又可分为 <strong>编译时异常</strong> 与 <strong>运行时异常</strong> 两大类。</p>
<p><img src="/2021/07/31/%E5%BC%82%E5%B8%B8/image-20210730163920638.png" alt="image-20210730163920638"></p>
<ul>
<li>  编译时异常：执行 <code>javac.exe</code> 命名时，可能出现的异常；</li>
<li>  运行时异常：执行 <code>java.exe</code> 命名时，出现的异常；</li>
</ul>
<h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><blockquote>
<p>  <strong>执行 <code>javac.exe</code> 命名时，可能出现的异常；</strong></p>
</blockquote>
<p>以下是一个编译时异常的简单例子。由于我们使用的是 IDEA 集成开发工具，代码是即时编译的，所以可以编译时异常不会在控制台上输出，而是非常智能的提示出来了。但是如果我们使用基本的文本工具进行开发，编写的 <code>.java</code> 代码是不会自动提示错误的，只有在经过 javac 编译后才会提示，这就是所谓的<strong>编译时异常</strong>。</p>
<img src="/2021/07/31/%E5%BC%82%E5%B8%B8/image-20210730163330302.png" alt="image-20210730163330302" style="zoom: 67%;">



<h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><blockquote>
<p>  <strong>执行 <code>java.exe</code> 命名时，出现的异常；</strong></p>
</blockquote>
<p>程序在执行 <code>java.exe</code> 运行后提示的异常。</p>
<blockquote>
<p>  常见的运行时异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException	<span class="comment">// 要访问的变量没有引用任何对象时，抛出该异常）、</span></span><br><span class="line">ArithmeticException		<span class="comment">// 算术运算异常，一个整数除以0时，抛出该异常）和 </span></span><br><span class="line">ArrayIndexOutOfBoundsException	<span class="comment">// 下标越界异常</span></span><br></pre></td></tr></table></figure>





<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>异常和错误的区别</strong>：异常能被程序本身可以处理，错误是无法处理。</p>
<p><strong>如何理解</strong></p>
<p>我们可以看到，无论是编译期异常还是运行期异常，产生异常后程序员可以在代码层面纠正，使程序能继续正常运行。如上面的编译期异常，可以通过 <code>try...catch</code> 捕获处理；对于运行时期的各种异常，如空指针异常，可以通过加判断条件来避免。这些异常都是代码层面可以处理的。而对于一些虚拟机的异常，主要是涉及到了虚拟机的配置，可能出现在某写配置较好的虚拟机上可以正常运行，而在性能较差的虚拟机上就不能运行了的情况，所以说 Error 是无法避免的。</p>
<h2 id="3-Throwable类常用方法"><a href="#3-Throwable类常用方法" class="headerlink" title="3    Throwable类常用方法"></a>3    Throwable类常用方法</h2><table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>printStackTrace()</code></td>
<td align="center"><code>void</code></td>
<td align="center">在控制台上打印异常的详细信息</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>getMessage()</code></td>
<td align="center"><code>String</code></td>
<td align="center">获取发生异常的原因</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>toString</code></td>
<td align="center"><code>String</code></td>
<td align="center">获取异常的类型和详细信息</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-异常处理方式"><a href="#4-异常处理方式" class="headerlink" title="4    异常处理方式"></a>4    异常处理方式</h2><p>异常的两种处理方式：1、<strong>“抛”</strong>  2、<strong>“抓”</strong></p>
<blockquote>
<ol>
<li> <strong>“抛”</strong> </li>
</ol>
</blockquote>
<ul>
<li>  程序在正常执行的过程中，一旦出现异常，就会在异常代码处产生一个对应异常类的对象，并将此对象抛出。</li>
<li>  一旦抛出异常对象以后，其后的代码就不再执行。</li>
</ul>
<p><strong>关于异常对象的产生：</strong></p>
<ol>
<li> 系统自动生成的异常对象；</li>
<li> 手动的生成一个异常对象，并抛出（throw）。</li>
</ol>
<blockquote>
<ol start="2">
<li> <strong>“抓”</strong></li>
</ol>
</blockquote>
<p>可以理解为异常的处理方式：①<code>try-catch-finally</code>  ②<code>throws</code></p>
<h3 id="异常处理方式一：try-catch-finally"><a href="#异常处理方式一：try-catch-finally" class="headerlink" title="异常处理方式一：try-catch-finally"></a>异常处理方式一：try-catch-finally</h3><blockquote>
<p>  <strong>使用说明：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码。</span></span><br><span class="line">    <span class="comment">// 代码中出现的异常可能不止一种，针对不同类型异常可以使用多个catch语句分别做不同的处理 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><code>finally</code> 是可选的。</li>
<li>使用 <code>try</code> 将可能出现异常代码包起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此异常对象的类型，去 <code>catch</code> 中进行匹配；</li>
<li>一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构，继续执行 <code>try</code> 中后续的代码，最后再执行 <code>finally</code> 中的代码。</li>
<li><code>catch</code> 中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。但是 <strong><code>catch</code> 中的异常类型如果满足子父类关系，则要求子类异常类型一定要声明在父类异常类型的上面</strong>，否则报错。【因为 <code>catch</code> 是从上向下匹配的，如果父类异常类型声明在先，则该父类异常的所有子类异常都会被父类异常拦截（多态），根本执行不到子类异常处 】</li>
<li>常用的异常对象处理的方式： <code>① String  getMessage()    ② printStackTrace()</code></li>
<li>在 <code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用。</li>
<li><code>try-catch-finally</code> 结构可以嵌套。</li>
</ol>
<blockquote>
<p>  <strong>如何看待代码中的编译时异常和运行时异常？</strong></p>
</blockquote>
<ol>
<li> 使用 <code>try-catch-finally</code> 处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</li>
<li> 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。针对于编译时异常，我们则一定要考虑异常的处理。</li>
</ol>
<h3 id="异常处理方式二：throws"><a href="#异常处理方式二：throws" class="headerlink" title="异常处理方式二：throws"></a>异常处理方式二：throws</h3><ul>
<li>  <strong>throws + 异常类型</strong> 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。</li>
<li>  一旦当方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 <code>throws</code> 抛出的异常类型时，就会被抛出。异常代码后续的代码，就不再执行。</li>
</ul>
<h3 id="对比两种处理方式"><a href="#对比两种处理方式" class="headerlink" title="对比两种处理方式"></a>对比两种处理方式</h3><ul>
<li>  <code>try-catch-finally</code>：真正的将异常给处理掉了。</li>
<li>  <code>throws</code>：只是将异常抛给了方法的调用者，并没真正将异常处理掉。</li>
</ul>
<h3 id="体会开发中应该如何选择两种处理方式？"><a href="#体会开发中应该如何选择两种处理方式？" class="headerlink" title="体会开发中应该如何选择两种处理方式？"></a>体会开发中应该如何选择两种处理方式？</h3><ul>
<li>  如果父类中被重写的方法没 <code>throws</code> 方式处理异常，则子类重写的方法也不能使用 <code>throws</code>。这意味着如果子类重写的方法中异常，必须使用 <code>try-catch-finally</code> 方式处理。</li>
<li>  执行的方法 <code>methodA()</code> 中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用 <code>throws</code> 的方式进行处理，而执行的方法 <code>methodA()</code> 可以考虑使用 <code>try-catch-finally</code> 方式进行处理。</li>
<li>  使用 <code>throws</code> 抛出的异常最外层还是要落实到使用 <code>try-catch-finally</code> 处理。</li>
</ul>
<blockquote>
<p>  <strong>补充：</strong></p>
</blockquote>
<ul>
<li>  方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。【因为父类是子类的顶级抽象，如果子类的异常类型范围大于父类类型的话，则父类就会无法处理超出范围的异常类型】</li>
</ul>
<hr>
<h2 id="5-手动抛出异常对象"><a href="#5-手动抛出异常对象" class="headerlink" title="5    手动抛出异常对象"></a>5    手动抛出异常对象</h2><blockquote>
<ol>
<li> <strong>使用说明</strong></li>
</ol>
</blockquote>
<p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以通过 <code>throw</code> 手动抛出一个异常类的对象。</p>
<blockquote>
<ol start="2">
<li> <strong>throw 和  throws 的区别？</strong></li>
</ol>
</blockquote>
<p><strong>throw</strong>：</p>
<ul>
<li>  动词，表示抛出一个异常类的对象。</li>
<li>  生成异常对象的过程，声明在方法体内。</li>
<li>  <code>throw</code> 抛出的对象会由 <code>throws</code> 接收并抛给上一层，并在最外层由 <code>try-catch-finally</code> 处理，或直接中断程序。</li>
</ul>
<p><strong>throws</strong>：</p>
<ul>
<li>  名词，属于异常处理的一种方式。声明在方法的声明处。</li>
<li>  <code>throws</code> 用于接收程序运行时由系统抛出或者用户自定义抛出的异常，并交给 <code>try-catch-finally</code> 处理。  </li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 手动抛出异常对象</span></span><br><span class="line"><span class="comment">//			throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="comment">//			throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);	<span class="comment">// 自定义异常对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-自定义异常类"><a href="#6-自定义异常类" class="headerlink" title="6    自定义异常类"></a>6    自定义异常类</h2><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/11/26/%E9%80%9A%E7%94%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/">超链接：开发中的通用异常处理</a></p>
</blockquote>
<blockquote>
<p>  <strong>如何自定义一个异常类？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何自定义异常类？</span></span><br><span class="line"><span class="comment"> * 1. 继承于现的异常结构：RuntimeException 、Exception</span></span><br><span class="line"><span class="comment"> * 2. 提供全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment"> * 3. 提供重载的构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">红黑树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-30 22:42:04" itemprop="dateCreated datePublished" datetime="2021-07-30T22:42:04+08:00">2021-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-31 12:03:42" itemprop="dateModified" datetime="2021-08-31T12:03:42+08:00">2021-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="红黑树基础：二叉搜索树"><a href="#红黑树基础：二叉搜索树" class="headerlink" title="红黑树基础：二叉搜索树"></a>红黑树基础：二叉搜索树</h1><blockquote>
<p>  <strong>二叉搜索树</strong></p>
</blockquote>
<p><strong>二叉搜索树（binary search tree）</strong>就是在二叉树的基础上增加了一些额外的条件，二叉搜索树是一种特殊的二叉树。</p>
<blockquote>
<p>  <strong>二叉搜索树要求：</strong></p>
</blockquote>
<ol>
<li> 若左子树不为空，则左子树上所有结点的值均小于根结点的值； </li>
<li> 若右子树不为空，则右子树上所有结点的值均大于根结点的值； </li>
<li> 左、右子树也分别为二叉排序树。</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p>
<hr>
<h2 id="二叉搜索树-查找节点："><a href="#二叉搜索树-查找节点：" class="headerlink" title="二叉搜索树-查找节点："></a>二叉搜索树-查找节点：</h2><p>查找某个节点，我们必须从根节点开始查找。</p>
<ol>
<li> 查找值比当前节点值大，则搜索右子树；</li>
<li> 查找值等于当前节点值，停止搜索（终止条件）；</li>
<li> 查找值小于当前节点值，则搜索左子树；</li>
</ol>
<hr>
<h2 id="二叉搜索树-插入节点："><a href="#二叉搜索树-插入节点：" class="headerlink" title="二叉搜索树-插入节点："></a>二叉搜索树-插入节点：</h2><ul>
<li>  要插入节点，必须先找到插入的位置。</li>
<li>  与查找操作相似，由于二叉搜索树的特殊性，待插入的节点也需要从根节点开始进行比较，小于根节点则与根节点左子树比较，反之则与右子树比较，直到左子树为空或右子树为空，则插入到相应为空的位置。</li>
</ul>
<hr>
<h2 id="二叉搜索树-遍历节点："><a href="#二叉搜索树-遍历节点：" class="headerlink" title="二叉搜索树-遍历节点："></a>二叉搜索树-遍历节点：</h2><p>二叉搜索树的遍历与普通二叉树的遍历一样，常见的有：</p>
<ul>
<li>  前序遍历</li>
<li>  中序遍历</li>
<li>  后序遍历</li>
</ul>
<h2 id="二叉搜索树-查找最大值和最小值"><a href="#二叉搜索树-查找最大值和最小值" class="headerlink" title="二叉搜索树-查找最大值和最小值"></a>二叉搜索树-查找最大值和最小值</h2><ul>
<li>  要找最小值，先找根的左节点，然后一直找这个左节点的左节点，直到找到没有左节点的节点，那么这个节点就是最小值。</li>
<li>  同理要找最大值，一直找根节点的右节点，直到没有右节点，则就是最大值。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC.png" alt="最大值和最小值"></p>
<hr>
<h2 id="二叉搜索树-删除节点："><a href="#二叉搜索树-删除节点：" class="headerlink" title="二叉搜索树-删除节点："></a>二叉搜索树-删除节点：</h2><p>删除节点是二叉搜索树中最复杂的操作，删除的节点有三种情况，前两种比较简单，但是第三种却很复杂。</p>
<blockquote>
<ol>
<li> 待删除的节点是叶节点（没有子节点）</li>
<li> 待删除的节点有一个子节点</li>
<li> 待删除的节点有两个子节点</li>
</ol>
</blockquote>
<h3 id="Case1：删除叶子节点"><a href="#Case1：删除叶子节点" class="headerlink" title="Case1：删除叶子节点"></a>Case1：删除叶子节点</h3><ul>
<li>  找到待删除的叶子节点，将其父节点指向该节点的引用改为null即可。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9.png" alt="删除叶子节点"></p>
<hr>
<h3 id="Case2：删除有一个子节点的节点"><a href="#Case2：删除有一个子节点的节点" class="headerlink" title="Case2：删除有一个子节点的节点"></a>Case2：删除有一个子节点的节点</h3><ul>
<li>  删除有一个子节点的节点，我们只需要将其父节点原本指向该节点的引用，改为指向该节点的子节点即可。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="删除拥有一个子节点的节点"></p>
<hr>
<h3 id="Case3：删除有两个子节点的节点"><a href="#Case3：删除有两个子节点的节点" class="headerlink" title="Case3：删除有两个子节点的节点"></a>Case3：删除有两个子节点的节点</h3><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E6%8B%A5%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9_01.png" alt="删除拥有两个子节点的节点_01"></p>
<ul>
<li>  当待删除的节点存在两个子节点，那么删除之后，两个子节点的位置我们就没办法处理了。</li>
<li>  既然处理不了，我们就想到一种办法，<strong>用其中一个节点来代替被删除的节点</strong>，那么用哪一个节点来代替呢？</li>
<li>  我们知道二叉搜索树中的节点是按照关键字来进行排列的，某个节点的关键字次高节点是它的中序遍历<strong>后继节点</strong>。</li>
<li>  用后继节点来代替删除的节点，显然该二叉搜索树还是有序的。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%88%A0%E9%99%A4%E6%8B%A5%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="删除拥有两个子节点的节点"></p>
<blockquote>
<p>  <strong>如何找到删除节点的中序后继节点？</strong></p>
</blockquote>
<ul>
<li>  实际上就是要找比删除节点关键值大的节点集合中最小的一个节点，只有这样代替删除节点后才能满足二叉搜索树的特性。</li>
<li>  后继节点也就是：<strong>比删除节点大的最小节点</strong>。</li>
</ul>
<hr>
<h3 id="Case4：删除有必要吗？"><a href="#Case4：删除有必要吗？" class="headerlink" title="Case4：删除有必要吗？"></a>Case4：删除有必要吗？</h3><ul>
<li>  通过上面的删除分类讨论，我们发现删除其实是挺复杂的，那么其实我们<strong>可以不用真正的删除该节点，只需要在Node类中增加一个标识字段 isDelete</strong>，当该字段为true时，表示该节点已经删除，反之则没有删除。这样删除节点就不会改变树的结构了。</li>
<li>  影响就是查询时需要判断一下节点是否已被删除。</li>
</ul>
<hr>
<h2 id="二叉搜索树-时间复杂度分析："><a href="#二叉搜索树-时间复杂度分析：" class="headerlink" title="二叉搜索树-时间复杂度分析："></a>二叉搜索树-时间复杂度分析：</h2><h3 id="回顾经典：二分查找算法"><a href="#回顾经典：二分查找算法" class="headerlink" title="回顾经典：二分查找算法"></a>回顾经典：二分查找算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,8,9。。。。。。。100]</span><br></pre></td></tr></table></figure>

<ul>
<li>  暴力算法：运气好时 性能不错，运气不好时 性能暴跌。</li>
<li>  二分查找算法：数据源必须是<strong>有序数组</strong>，性能较好，每次迭代查询可以排除掉一半的结果。</li>
</ul>
<blockquote>
<p>  <strong>二分查找算法最大的缺陷是什么？</strong></p>
</blockquote>
<ul>
<li>  <strong>数组必须有序</strong></li>
<li>  数组自身缺陷：没有办法快速插入，也没有办法扩容</li>
</ul>
<blockquote>
<p>  <strong>怎么样才能拥有二分查找的高性能又能拥有链表一样的灵活性？</strong></p>
</blockquote>
<ul>
<li>  二叉搜索树</li>
</ul>
<blockquote>
<p>  二分查找算法时间复杂度推算过程：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">第几次查询</th>
<th align="center">剩余待查询元素数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">N/2</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">N/(2^2)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">N/(2^3)</td>
</tr>
<tr>
<td align="center">K</td>
<td align="center">N/(2^K)</td>
</tr>
</tbody></table>
<ul>
<li>  从上表可以看出 <strong>N/(2^K)</strong> 肯定是大于等于1，也就是 <strong>N/(2^K)&gt;=1</strong> ，我们计算时间复杂度是按照<strong>最坏的情况</strong>进行计算，也就是是查到剩余最后一个数才查到我们想要的数据，也就是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">N/(2^K)=1   =&gt;   2^K = N   =&gt; K = log2 (N)    </span><br><span class="line">=&gt;  二分查找算法时间复杂度：O(log2(N))  =&gt; O(logN)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="普通二叉搜索树致命缺陷："><a href="#普通二叉搜索树致命缺陷：" class="headerlink" title="普通二叉搜索树致命缺陷："></a>普通二叉搜索树致命缺陷：</h2><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5.png" alt="二叉搜索树-极端情况"></p>
<ul>
<li>  <strong>这颗二叉树查询效率咋样呢？O(N)</strong></li>
<li>  <strong>怎么解决 二叉搜索树 退化成线性链表的问题？</strong></li>
<li>  <strong>如果插入元素时，树可以自动调整两边平衡，会保持不错的查找性能。</strong></li>
</ul>
<h2 id="AVL树简介："><a href="#AVL树简介：" class="headerlink" title="AVL树简介："></a>AVL树简介：</h2><blockquote>
<p>  <strong>AVL树有什么特点？</strong></p>
</blockquote>
<ol>
<li> 具有二叉查找树的全部特性。</li>
<li> 每个节点的左子树和右子树的<strong>高度差至多等于1</strong>。</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/AVL%E6%A0%91.png" alt="AVL树"></p>
<ul>
<li>  平衡树基于这种特点就可以保证不会出现大量节点偏向于一边的情况了！</li>
<li>  <strong>插入或者删除时，会发生左旋、右旋操作，使这棵树再次左右保持一定的平衡</strong>。</li>
</ul>
<hr>
<h2 id="为什么有了平衡树还需要红黑树？"><a href="#为什么有了平衡树还需要红黑树？" class="headerlink" title="为什么有了平衡树还需要红黑树？"></a>为什么有了平衡树还需要红黑树？</h2><ul>
<li>  虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 <code>O(logn)</code>，不过却<strong>不是最佳</strong>的，</li>
<li>  因为平衡树要求每个节点的左子树和右子树的高度差至多等于 1，这个要求实在是太严了，导致每次进行【插入/删除】节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树！</li>
</ul>
<hr>
<h1 id="红黑树原理讲解"><a href="#红黑树原理讲解" class="headerlink" title="红黑树原理讲解"></a>红黑树原理讲解</h1><blockquote>
<ol>
<li> 红黑树的性质</li>
<li>红黑树自平衡的策略<ul>
<li>  改变颜色</li>
<li>  左旋</li>
<li>  右旋</li>
</ul>
</li>
<li> 红黑树的查找</li>
<li>红黑树的插入<ul>
<li>  Case1：红黑树为空树</li>
<li>  Case2：插入节点的 key 已经存在</li>
<li>  Case3：插入节点的父节点为黑色</li>
<li>Case4：插入节点的父节点为红色<ul>
<li>  Case4.1：叔叔节点存在，并且为红色（父-叔 双红）</li>
<li>Case4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树<ul>
<li>  Case4.2.1：插入节点为其父节点的左子节点（LL情况）</li>
<li>  Case4.2.2：插入节点为其父节点的右子节点（LR情况）</li>
</ul>
</li>
<li>Case4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树<ul>
<li>  Case4.3.1：插入节点为其父节点的右子节点（RR情况）</li>
<li>  Case4.3.2：插入节点为其父节点的左子节点（RL情况）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li> 红黑树插入案例分析</li>
</ol>
</blockquote>
<h2 id="红黑树的性质："><a href="#红黑树的性质：" class="headerlink" title="红黑树的性质："></a>红黑树的性质：</h2><table>
<thead>
<tr>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">性质1：</td>
<td>每个节点要么是<strong>黑色</strong>，要么是<strong>红色</strong>。</td>
</tr>
<tr>
<td align="center">性质2：</td>
<td>根节点是<strong>黑色</strong>。</td>
</tr>
<tr>
<td align="center">性质3：</td>
<td>每个叶子节点（<strong>包括NULL</strong>）是<strong>黑色</strong>。</td>
</tr>
<tr>
<td align="center">性质4：</td>
<td>每个<strong>红色</strong>节点的两个子节点一定都是<strong>黑色</strong>。</td>
</tr>
<tr>
<td align="center">性质5：</td>
<td>任意一节点到每个叶子节点的路径都包含<strong>数量相同</strong>的<strong>黑结点</strong>。</td>
</tr>
<tr>
<td align="center">性质5.1：</td>
<td>从性质5又可以推出：如果一个节点存在黑子节点，那么该结点肯定有两个子节点</td>
</tr>
</tbody></table>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<ul>
<li>  红黑树并<strong>不是一个平衡二叉查找树</strong>，从图上可以看到，根结点 P 的左子树显然比右子树高，</li>
<li>  但<strong>左子树和右子树的黑色结点的层数是相等的</strong>，即任意一个结点到到每个叶子结点的路径都包含数量相同的黑色结点(性质5)。</li>
<li>  所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong>。</li>
</ul>
<hr>
<h2 id="红黑树自平衡："><a href="#红黑树自平衡：" class="headerlink" title="红黑树自平衡："></a>红黑树自平衡：</h2><blockquote>
<p>  <strong>前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。</strong></p>
</blockquote>
<ol>
<li> <strong>变色：</strong>结点的颜色由红变黑或由黑变红。</li>
<li> <strong>左旋：</strong>以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。</li>
<li> <strong>右旋：</strong>以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</li>
</ol>
<blockquote>
<p>  <strong>左旋</strong></p>
</blockquote>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%B7%A6%E6%97%8B.gif" alt="左旋"></p>
<blockquote>
<p>  <strong>右旋</strong></p>
</blockquote>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E5%8F%B3%E6%97%8B.gif" alt="右旋"></p>
<h2 id="红黑树查找："><a href="#红黑树查找：" class="headerlink" title="红黑树查找："></a>红黑树查找：</h2><p>红黑树查找与二叉搜索树查找一样，都是左边小、右边大。</p>
<h2 id="红黑树插入："><a href="#红黑树插入：" class="headerlink" title="红黑树插入："></a>红黑树插入：</h2><p>插入操作包括两部分工作：</p>
<blockquote>
<ol>
<li> 查找插入的位置</li>
<li> <strong>插入后自平衡</strong></li>
</ol>
</blockquote>
<p><strong>注意：</strong>插入节点，必须为<strong>红色</strong>。</p>
<p>理由很简单，如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多 1，必须做自平衡。而红色在父节点（如果存在）为黑色节点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。</p>
<p>在开始每个情景的讲解前，我们还是先来约定下：</p>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A6%E5%AE%9A.png" alt="约定"></p>
<hr>
<h2 id="红黑树插入节点情况分析"><a href="#红黑树插入节点情况分析" class="headerlink" title="红黑树插入节点情况分析"></a>红黑树插入节点情况分析</h2><h3 id="情景1：红黑树为空树"><a href="#情景1：红黑树为空树" class="headerlink" title="情景1：红黑树为空树"></a>情景1：红黑树为空树</h3><ul>
<li>  最简单的一种情景，直接把插入结点作为根结点就行</li>
<li>  注意：根据红黑树性质2，根节点必须是黑色，但是因为插入的节点一定一定是红色节点，所以还需要把新插入结点设为黑色。</li>
</ul>
<h3 id="情景2：插入结点的Key已存在"><a href="#情景2：插入结点的Key已存在" class="headerlink" title="情景2：插入结点的Key已存在"></a>情景2：插入结点的Key已存在</h3><ul>
<li>  处理：更新当前节点的值，为插入节点的值</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B5%E4%BA%8C_%E6%9B%BF%E6%8D%A2%20(2).png" alt="情况二_替换 (2)"></p>
<h3 id="情景3：插入结点的父结点为黑结点"><a href="#情景3：插入结点的父结点为黑结点" class="headerlink" title="情景3：插入结点的父结点为黑结点"></a>情景3：插入结点的父结点为黑结点</h3><p>由于插入的结点是红色的，当插入结点的父节点时黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B5%E4%B8%89_%E9%BB%91%E7%88%B6.png" alt="情况三_黑父"></p>
<h3 id="情景4：插入节点的父节点为红色"><a href="#情景4：插入节点的父节点为红色" class="headerlink" title="情景4：插入节点的父节点为红色"></a>情景4：插入节点的父节点为红色</h3><ul>
<li>  根据红黑树的<strong>性质2：根结点是黑色</strong>。如果插入节点的父结点为<strong>红结点</strong>，那么该父结点不可能为根结点，所以插入结点总是存在爷爷结点。</li>
<li>  这一点很关键，因为后续的旋转操作肯定需要爷爷结点的参与。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B5%E5%9B%9B_%E7%88%B6%E8%8A%82%E7%82%B9%E7%BA%A2%E8%89%B2.png" alt="情况四_父节点红色"></p>
<h4 id="插入情景4-1：叔叔结点存在并且为红结点"><a href="#插入情景4-1：叔叔结点存在并且为红结点" class="headerlink" title="插入情景4.1：叔叔结点存在并且为红结点"></a>插入情景4.1：叔叔结点存在并且为红结点</h4><ul>
<li>  依据红黑树<strong>性质4可知，红色节点不能相连 ==&gt; 祖父结点肯定为黑结点</strong>；</li>
<li>  因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。</li>
<li>  首先第一步处理就是变色，将其改为：<strong>红黑红</strong></li>
</ul>
<blockquote>
<p>  <strong>处理：</strong></p>
</blockquote>
<ol>
<li> 将黑红红改为红黑红</li>
<li> 以 PP 作为新的当前节点，进行后续处理</li>
<li><ul>
<li>  如果 PP 的父结点是黑色，那么无需再做任何处理；</li>
<li>  但如果 PP 的父结点是红色，则违反红黑树性质了。所以需要将 PP 设置为当前节点，继续做插入操作自平衡处理，直到平衡为止。</li>
</ul>
</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B54.1_%E5%8F%94%E5%8F%94%E7%BA%A2%E8%89%B2.png" alt="情况4.1_叔叔红色"></p>
<h4 id="插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点"><a href="#插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点" class="headerlink" title="插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点"></a>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的左子结点</h4><ul>
<li>  <strong>注意</strong>：单纯从插入前来看，叔叔节点非红即空（NIL节点），否则的话破坏了红黑树性质5，此路径会比其它路径多一个黑色节点。</li>
</ul>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.png" alt="4.2"></p>
<h5 id="插入情景4-2-1：新插入节点，为其父节点的左子节点（LL红色情况）"><a href="#插入情景4-2-1：新插入节点，为其父节点的左子节点（LL红色情况）" class="headerlink" title="插入情景4.2.1：新插入节点，为其父节点的左子节点（LL红色情况）"></a>插入情景4.2.1：新插入节点，为其父节点的左子节点（LL红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.1_LL.png" alt="4.2.1_LL"></p>
<blockquote>
<p>  处理：</p>
</blockquote>
<ol>
<li> 变色：将P设置为黑色，将PP设置为红色；</li>
<li> 对 PP 节点进行<strong>右旋</strong>。</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.1_LL_%E5%A4%84%E7%90%86.png" alt="4.2.1_LL_处理"></p>
<h5 id="插入情景4-2-2：新插入节点，为其父节点的右子节点（LR红色情况）"><a href="#插入情景4-2-2：新插入节点，为其父节点的右子节点（LR红色情况）" class="headerlink" title="插入情景4.2.2：新插入节点，为其父节点的右子节点（LR红色情况）"></a>插入情景4.2.2：新插入节点，为其父节点的右子节点（LR红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.2.2_LR.png" alt="4.2.2_LR"></p>
<blockquote>
<p>  <strong>处理：</strong></p>
</blockquote>
<ol>
<li> 对 P 进行左旋，得到 LL 红色情况</li>
<li>按照 LL 红色情况处理<ol>
<li> 变颜色</li>
<li> 右旋PP</li>
</ol>
</li>
</ol>
<h4 id="插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点"><a href="#插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点" class="headerlink" title="插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点"></a>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是爷爷结点的右子结点</h4><p>该情景对应情景4.2，只是方向反转，直接看图。</p>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.png" alt="4.3"></p>
<h5 id="插入情景4-3-1：新插入节点，为其父节点的右子节点（RR红色情况）"><a href="#插入情景4-3-1：新插入节点，为其父节点的右子节点（RR红色情况）" class="headerlink" title="插入情景4.3.1：新插入节点，为其父节点的右子节点（RR红色情况）"></a>插入情景4.3.1：新插入节点，为其父节点的右子节点（RR红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.1_RR.png" alt="4.3.1_RR"></p>
<blockquote>
<p>  处理：</p>
</blockquote>
<ol>
<li> 变颜色：将P设置为黑色，将PP设置为红色</li>
<li> 对PP节点进行<strong>左旋</strong></li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.1_RR_%E5%A4%84%E7%90%86.png" alt="4.3.1_RR_处理"></p>
<h5 id="插入情景4-3-2：新插入节点，为其父节点的左子节点（RL红色情况）"><a href="#插入情景4-3-2：新插入节点，为其父节点的左子节点（RL红色情况）" class="headerlink" title="插入情景4.3.2：新插入节点，为其父节点的左子节点（RL红色情况）"></a>插入情景4.3.2：新插入节点，为其父节点的左子节点（RL红色情况）</h5><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.2_RL.png" alt="4.3.2_RL"></p>
<blockquote>
<p>  处理：</p>
</blockquote>
<ol>
<li> 对P进行右旋，得到RR红色情况</li>
<li>按照RR红色情况处理<ol>
<li> 变颜色</li>
<li> 左旋PP</li>
</ol>
</li>
</ol>
<p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.2_RL_%E5%A4%84%E7%90%86.png" alt="4.3.2_RL_处理"></p>
<h2 id="红黑树插入案例分析"><a href="#红黑树插入案例分析" class="headerlink" title="红黑树插入案例分析"></a>红黑树插入案例分析</h2><p><img src="/2021/07/30/%E7%BA%A2%E9%BB%91%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%A1%88%E4%BE%8B%20(3).png" alt="红黑树插入案例 (3)"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/25/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/LeetCode/" class="post-title-link" itemprop="url">LeetCode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-25 21:11:47" itemprop="dateCreated datePublished" datetime="2021-07-25T21:11:47+08:00">2021-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-02 20:48:36" itemprop="dateModified" datetime="2021-08-02T20:48:36+08:00">2021-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="斐波那契数列的多种解法"><a href="#斐波那契数列的多种解法" class="headerlink" title="斐波那契数列的多种解法"></a>斐波那契数列的多种解法</h1><blockquote>
<p>  <strong>斐波那契数列</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 斐波那契数列</span><br><span class="line">*      F(<span class="number">0</span>) = <span class="number">0</span>，</span><br><span class="line">*      F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">*      F(n) = F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>)，其中 n &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="普通递归解法（性能最差）"><a href="#普通递归解法（性能最差）" class="headerlink" title="普通递归解法（性能最差）"></a>普通递归解法（性能最差）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.binarySearch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求：给出 n计算 F(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution509</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fib</span> <span class="operator">=</span> fib(<span class="number">6</span>);</span><br><span class="line">        System.out.println(fib);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>  n;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="递归优化解法"><a href="#递归优化解法" class="headerlink" title="递归优化解法"></a>递归优化解法</h2><p>斐波那契数列递归的时候会造成大量的重复计算，比如就计算 <code>fib(6)</code> 为例来看：<code>F(6) = F(5)+F(4)</code>，当我们计算出 F(5) 的时候，F(4) 也已经被计算出来了，如果我们在 F(6) 的右子节点中能够调用已经计算出来的值的话，那么该节点就不用继续向下展开了。这在 n 非常大时，节省的效率很高，接近于一半。</p>
<p><img src="/2021/07/25/LeetCode/a6f819589ee5e50ec378f2c10835e9a510529bac44618444beb2202486062eee-image.png" alt="image.png"></p>
<p>我们看到上面相同颜色的都是重复计算，当 n 越大，重复的就会越多。</p>
<p>所以我们可以使用一个 map 把计算过的值存起来，每次计算的时候先查看 map 中有没有，</p>
<ul>
<li>  如果有就表示计算过，直接从 map 中取；</li>
<li>  如果没有就先计算，计算完之后再把结果存到map中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.binarySearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 斐波那契数列</span></span><br><span class="line"><span class="comment"> *      F(0) = 0，</span></span><br><span class="line"><span class="comment"> *      F(1) = 1</span></span><br><span class="line"><span class="comment"> *      F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求：给出 n计算 F(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution509</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution509</span>().fib(<span class="number">7</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  fib(int n, HashMap&lt;Integer, Integer&gt; map) 的重载方法，简化调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> fib(n, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  计算斐波那契数的方法（递归优化）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n, HashMap&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="comment">// 每次计算的时候先查看 map 中有没有，</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n))&#123;</span><br><span class="line">            <span class="comment">// 如果有直接从 map 中取；</span></span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有就先计算，计算完之后再把结果存到map中。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> fib(n - <span class="number">1</span>, map) + fib(n - <span class="number">2</span>, map);</span><br><span class="line">            map.put(n, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="动态规划（非递归解法）"><a href="#动态规划（非递归解法）" class="headerlink" title="动态规划（非递归解法）"></a>动态规划（非递归解法）</h2><ul>
<li>  想要计算 <strong>F(n)</strong> 的值，就需要知道 F(n-1) 和 F(n-2) 的值；</li>
<li>  想要计算 F(n-1) 的值，就要知道 F(n-2) 和 F(n-3) 的值；</li>
<li>  以此类推，一直到 F(0) 和 F(1)。</li>
</ul>
<p>​        正如上面讲的普通的递归算法的弊端一样，如果每次 F(n-1) 和 F(n-2) 都独立运算，那么重复计算的值就太多了。上面的优化方式是将已经计算过的值保存到一个 Map  中避免重复运算，而且采用的是<strong>自顶向下</strong>的计算方式，即从 F(n-1) 算到 F(1)。</p>
<p>​        而所谓的斐波那契的动态规划解法，其实可以看做是一种穷举法。就是将从 F(1) 到 F(n-1) 的所有值都计算出来，保存到一个 List（或者 Map 均可）中，但是这里采用的是<strong>自底向上</strong>，即从 F(1) 计算到 F(n-1) 。</p>
<p>​        所以，在计算 F(n) 之前，动态规划必定已经建立好了一个从 <code>F(0) ~ F(n-1)</code> 的数组。而结算结果就是从数组中取出对应的元素即可。</p>
<p><img src="/2021/07/25/LeetCode/1600679988-ufqRKk-file_1600679988859" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.binarySearch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/25 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 斐波那契数列</span></span><br><span class="line"><span class="comment"> *      F(0) = 0，</span></span><br><span class="line"><span class="comment"> *      F(1) = 1</span></span><br><span class="line"><span class="comment"> *      F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求：给出 n计算 F(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution509</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution509</span>().fib(<span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划：</span></span><br><span class="line"><span class="comment">     *    自底向上构建一个数组，数组中保存着每个 F(n) 的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 0~n 共有 n+1 个元素，length 设为 n+2 是为了满足初始条件。</span></span><br><span class="line">        <span class="comment">// 即 f(0)=0 和 f(1)=1 是初始状态，数组的最小长度为 2</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建一个保存了从 f(0) 到 f(n) 的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="977-有序数组的平方（双指针）"><a href="#977-有序数组的平方（双指针）" class="headerlink" title="977. 有序数组的平方（双指针）"></a>977. 有序数组的平方（双指针）</h1><blockquote>
<p>  <strong>题目</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p>
</blockquote>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.cursor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/26 9:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 977. 有序数组的平方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> *      给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</span></span><br><span class="line"><span class="comment"> *      【非递减顺序 = 递增顺序】</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> *      难点在于如何让新数组也按非递减顺序排列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路一：暴力解法，先计算出所有数字的平方，再进行排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution977</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;-<span class="number">4</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] squares = <span class="keyword">new</span> <span class="title class_">Solution977</span>().sortedSquares(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> square : squares) &#123;</span><br><span class="line">            System.out.println(square);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(squares);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力解法：</span></span><br><span class="line"><span class="comment">     *  1、计算出 nums 数组中每个元素的平方，保存到一个新的数组中；</span></span><br><span class="line"><span class="comment">     *  2、对新数组按非递减顺序排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  -- 毋庸置疑，虽然通过了，但时间复杂度很高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 1、计算出 nums 数组中每个元素的平方，保存到一个 sq 数组中；</span></span><br><span class="line">        <span class="type">int</span>[] sq = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sq[i] = nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、对 sq 数组排序</span></span><br><span class="line">        Arrays.sort(sq);</span><br><span class="line">        <span class="keyword">return</span> sq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="双指针-归并排序"><a href="#双指针-归并排序" class="headerlink" title="双指针 + 归并排序"></a>双指针 + 归并排序</h3><blockquote>
<p>  <strong>思路</strong></p>
</blockquote>
<p>暴力解法没有利用【数组 <code>nums</code> 已经按照升序排列】这个条件。显然，</p>
<ul>
<li>  如果数组 <code>nums</code> 中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；</li>
<li>  如果数组 <code>nums</code> 中的所有数都是负数，那么将每个数平方后，数组会保持降序。</li>
</ul>
<p>这样一来，如果我们能够<strong>找到升序数组 <code>nums</code> 中负数与非负数的分界线</strong>，那么就可以用类似<strong>「归并排序」</strong>的方法了。</p>
<p>​        具体地，我们设 <strong>neg</strong> 为数组 nums 中负数与非负数的分界线。也就是说，<code>nums[0] ~ nums[neg]</code> 均为负数，而 <code>nums[neg+1] ~ nums[n−1]</code> 均为非负数。当我们将数组 nums 中的数平方后，那么 <code>nums[0] ~ nums[neg]</code> 单调递减，<code>nums[neg+1] ~ nums[n−1]</code> 单调递增。 </p>
<p>​        由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置  <code>neg</code> 和 <code>neg+1</code>，每次比较两个指针对应的数，选择较小的那个放入答案数组并移动指针。<strong>当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。</strong></p>
<p>示例一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-<span class="number">4</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、首先取到正数和负数的分界点 neg;</span><br><span class="line"><span class="number">2</span>、构建一个 nums 数组的平方数组 sq；可以看到neg右边数组升序，neg右边数组降序;</span><br><span class="line"><span class="number">3</span>、用两个指针left和right分别进行正序和倒序遍历，每次取出较小的值放入新的数组中！！！</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/25/LeetCode/977%E5%8F%8C%E6%8C%87%E9%92%88.png" alt="977双指针"></p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 归并排序 + 双指针 解法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  1、找到正数与负数的分隔点，</span></span><br><span class="line"><span class="comment">    *  2、由于nums数组是升序的，所以求平方之后，分隔点之前的数降序排列，分隔点之后的数升序排列</span></span><br><span class="line"><span class="comment">    *  3、进行归并排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="comment">// 1、找到正数与负数的分隔点。(0,neg)&lt;0； [neg, length)&gt;=0</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">               neg = i;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果整个数组全为负数，就将 length 设置为分界点</span></span><br><span class="line">           neg = nums.length;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、构建 nums 的平方数组 sq</span></span><br><span class="line">       <span class="type">int</span>[] sq = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           sq[i] = nums[i]*nums[i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、进行归并排序【双指针】【可以利用之前的 nums 数组，该数组现在没有用了，这里为了方便理解新建了数组】</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> neg-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> neg;</span><br><span class="line">       <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 结果值数组的指针</span></span><br><span class="line">       <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">while</span> (left&gt;=<span class="number">0</span> &amp;&amp; right&lt;sq.length)&#123;</span><br><span class="line">           <span class="keyword">if</span> (sq[left] &lt; sq[right])&#123;</span><br><span class="line">               res[t++] = sq[left--];</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               res[t++] = sq[right++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (left &lt; <span class="number">0</span> &amp;&amp; right &lt; sq.length)&#123;   <span class="comment">// 将右边剩余的元素全部追加到res数组中</span></span><br><span class="line">           res[t++] = sq[right++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (right &gt; nums.length-<span class="number">1</span> &amp;&amp; left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">           res[t++] = sq[left--];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h1 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h1><blockquote>
<p>  <strong>题目</strong>：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></p>
</blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5,4,4], nums2 = [9,4,9,8,4,6]</span><br><span class="line">输出：[9,4,4]</span><br></pre></td></tr></table></figure>



<h2 id="HashMap-解法"><a href="#HashMap-解法" class="headerlink" title="HashMap 解法"></a>HashMap 解法</h2><p><img src="/2021/07/25/LeetCode/350%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.png" alt="350两个数组的交集"></p>
<p><strong>思路：</strong></p>
<ol>
<li><p> 分别为两个数组 nums1 和 nums2 建立各自对应的 HashMap map1 和 map2，其中 key 为数组中出现过的值，value 为数组中 key 值出现过的次数。</p>
</li>
<li><p>数组的交集为：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map1&#123;4,3&#125; ∩ map2&#123;4,2&#125; ==&gt; &#123;4,2&#125;</span><br><span class="line">map1&#123;9,1&#125; ∩ map2&#123;9,2&#125; ==&gt; &#123;9,1&#125;</span><br><span class="line">map1&#123;5,1&#125; ∩ map2&#123;null&#125; ==&gt; null</span><br><span class="line">map1&#123;null&#125; ∩ map2&#123;8,1&#125; ==&gt; null</span><br><span class="line">map1&#123;null&#125; ∩ map2&#123;6,1&#125; ==&gt; null</span><br></pre></td></tr></table></figure></li>
<li><p> 所以得到的最终结果是：<code>[4,4,9]</code></p>
</li>
</ol>
<p><strong>代码思路：</strong></p>
<p><img src="/2021/07/25/LeetCode/350_fig1.gif" alt="fig1"></p>
<ol>
<li> 建立起 nums1 的 hashMap 表；</li>
<li> 遍历 nums2 ，每发现一个元素在 hashMap 中存在，代表这就是 nums1 和 nums2 的交集部分，将该元素保存到 result 数组中，将 hashMap 中对应的元素个数减一。 </li>
<li> 这样最后得到的 result 数组就是 nums1 和 nums2 的交集。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.shuzu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/27 10:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定两个数组，编写一个函数来计算它们的交集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      输入：nums1 = [1,2,2,1], nums2 = [2,2]</span></span><br><span class="line"><span class="comment"> *      输出：[2,2]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span></span><br><span class="line"><span class="comment"> *      输出：[4,9]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  思路一：暴力解法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  思路二：HashTable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution350</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums1 = &#123;<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] nums2 = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">Solution350</span>().intersect(nums1, nums2);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashTable 解法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个数组，用于保存交集的数组</span></span><br><span class="line">        <span class="type">int</span>[] res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &lt; nums2.length)&#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、建立 nums1 的 HashMap</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map1.containsKey(nums1[i]))&#123;</span><br><span class="line">                map1.put(nums1[i], <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map1.containsKey(nums1[i]))&#123;</span><br><span class="line">                map1.put(nums1[i], map1.get(nums1[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、遍历 nums2，与 map1 进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 存在重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (map1.containsKey(nums2[j]))&#123;</span><br><span class="line">                <span class="keyword">if</span> (map1.get(nums2[j]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 输出到结果数组中</span></span><br><span class="line">                    res[t] = nums2[j];</span><br><span class="line">                    ++t;</span><br><span class="line">                    <span class="comment">// 更新 map</span></span><br><span class="line">                    <span class="keyword">if</span> (map1.get(nums2[j])-<span class="number">1</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        map1.put(nums2[j], map1.get(nums2[j])-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 小于等于0</span></span><br><span class="line">                        map1.remove(nums2[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、仅截取需要的那一段</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h2><p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p>
<ol>
<li> 首先对两个数组进行排序，然后使用两个指针遍历两个数组。</li>
<li> 初始时，两个指针分别指向两个数组的头部。</li>
<li> 每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。</li>
<li> 当至少有一个指针超出数组范围时，遍历结束。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  双指针解法</span></span><br><span class="line"><span class="comment">    * 1.  首先对两个数组进行排序，然后使用两个指针遍历两个数组。</span></span><br><span class="line"><span class="comment">    * 2.  初始时，两个指针分别指向两个数组的头部。</span></span><br><span class="line"><span class="comment">    * 3.  每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，</span></span><br><span class="line"><span class="comment">    *     如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。</span></span><br><span class="line"><span class="comment">    * 4.  当至少有一个指针超出数组范围时，遍历结束。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">       <span class="comment">// 0、创建一个数组，用于保存交集的数组</span></span><br><span class="line">       <span class="type">int</span>[] res;</span><br><span class="line">       <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nums1.length &lt; nums2.length)&#123;</span><br><span class="line">           res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           res = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1、对两个数组进行排序</span></span><br><span class="line">       Arrays.sort(nums1);</span><br><span class="line">       Arrays.sort(nums2);</span><br><span class="line">       <span class="comment">// 2、初始化两个指针</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 3、遍历比较</span></span><br><span class="line">       <span class="keyword">while</span>(i&lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">           <span class="comment">// 如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。</span></span><br><span class="line">           <span class="keyword">if</span> (nums1[i] == nums2[j])&#123;</span><br><span class="line">               res[t] = nums1[i];</span><br><span class="line">               i++;</span><br><span class="line">               j++;</span><br><span class="line">               t++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果两个数字不相等，则将指向较小数字的指针右移一位，</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4、当至少有一个指针超出数组范围时，遍历结束。</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5、仅截取需要的那一段</span></span><br><span class="line">       <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
