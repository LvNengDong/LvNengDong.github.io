<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/30/Shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/30/Shell/" class="post-title-link" itemprop="url">Shell</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-30 16:20:00" itemprop="dateCreated datePublished" datetime="2021-10-30T16:20:00+08:00">2021-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-11-19 22:07:49" itemprop="dateModified" datetime="2021-11-19T22:07:49+08:00">2021-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Shell/" itemprop="url" rel="index"><span itemprop="name">Shell</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Shell 是一门解释性语言，也就是说在编写完 Shell 脚本后，可以直接使用 Shell 解释器解释执行，而无需像 Java 语言那样需要先经过 <code>javac</code> 进行编译，编译后才能被执行。</p>
<h1 id="Shell-编程怎么学"><a href="#Shell-编程怎么学" class="headerlink" title="Shell 编程怎么学"></a>Shell 编程怎么学</h1><ol>
<li> 学习 shell 语言的语法和格式要求</li>
<li> 使用 shell 语法尝试编写若干个 shell 脚本</li>
<li> 使用 shell 命令的解释器解释执行 shell 脚本。</li>
</ol>
<hr>
<h1 id="Shell-概述"><a href="#Shell-概述" class="headerlink" title="Shell 概述"></a>Shell 概述</h1><p><img src="Shell/image-20211030163357198.png" alt="image-20211030163357198"></p>
<p>Linux 系统的核心是<strong>内核</strong>，内核直接控制着计算机系统上的所有硬件和软件，应用程序在执行时都需要先向内核申请 CPU、内存等硬件资源。也就是说应用程序执行时会先向内核发送申请资源的指令，为了防止第三方程序发送一些恶意指令损坏内核，Linux 开发人员在应用程序和内核之间，设置了一个中间层——<strong>Shell</strong>。这样所有发送给内核的指令，都必须先由 Shell 层进行一次校验，校验通过后才可以继续发往内核，减少了内核被损坏的风险。</p>
<p><strong>本质上来说：</strong></p>
<ul>
<li>  Shell 是一种编程规范，类似于 Java、Python 等。Shell 是一种解释性语言，所有符合 shell 语法规定的指令都会先由 shell 解释器进行语法、安全校验，合法后再交给内核执行。</li>
<li>  <strong>shell命令</strong>：shell 命令就是按照 shell 编程规范编写的命令。</li>
<li>  <strong>shell脚本</strong>：shell 脚本就是一组 shell 命令的集合。多条 shell 命令，可以编写在一个文件中，文件中的 shell 指令，将会按照顺序执行，这个保存多条 shell 命令的文件就称为 shell 脚本。</li>
</ul>
<hr>
<h1 id="Shell-解释器"><a href="#Shell-解释器" class="headerlink" title="Shell 解释器"></a>Shell 解释器</h1><h2 id="查看-Linux-支持的-shell-解释器"><a href="#查看-Linux-支持的-shell-解释器" class="headerlink" title="查看 Linux 支持的 shell 解释器"></a>查看 Linux 支持的 shell 解释器</h2><ul>
<li>  在 Linux 中，<strong>一切皆文件</strong>，Linux 支持的所有 shell 解释器也包含在一个文件中。【文件目录：<code>/etc/shells</code>】</li>
<li>  shell 支持多种不同风格的解释器，我们可以通过查看 <code>/etc/shells</code> 文件得到当前 Linux 系统支持的 shell 解释器种类。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos ~]# cat -n /etc/shells</span><br><span class="line">     1	/bin/sh</span><br><span class="line">     2	/bin/bash</span><br><span class="line">     3	/sbin/nologin</span><br><span class="line">     4	/usr/bin/sh</span><br><span class="line">     5	/usr/bin/bash</span><br><span class="line">     6	/usr/sbin/nologin</span><br><span class="line">     7	/bin/tcsh</span><br><span class="line">     8	/bin/csh</span><br></pre></td></tr></table></figure>

<ul>
<li>  不同的 shell 解释器风格不同，比如 csh 就是一种符合 C 语言风格的 shell 解释器。</li>
<li>  Centos 默认使用 <code>/bin/sh</code> 和 <code>/bin/bash</code> 作为 shell 解析器。</li>
</ul>
<hr>
<h2 id="bash-和-sh-的关系"><a href="#bash-和-sh-的关系" class="headerlink" title="bash 和 sh 的关系"></a>bash 和 sh 的关系</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos ~]# ll | grep bash</span><br><span class="line">-rw-r--r-- 1 root root 25386 Jan  9  2021 bash</span><br><span class="line">lrwxrwxrwx 1 root root     4 Jan  9  2021 sh -&gt; bash</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<strong>sh 是 bash 的一个软链接</strong>，所以说，用 <code>/bin/sh</code> 执行命令和使用 <code>/bin/bash</code> 执行命令是一样的，最终都是调用 <code>bash</code> 执行的。</p>
<hr>
<h2 id="Linux-命令底层执行流程"><a href="#Linux-命令底层执行流程" class="headerlink" title="Linux 命令底层执行流程"></a>Linux 命令底层执行流程</h2><p>我们在终端窗口中输入的每一条 Linux 命令，其实都是一条 shell 指令，但是我们在使用的时候并没有去指定具体使用哪一个 shell 解释器，这是因为在未显式指定 shell 解释器的情况下，当前系统使用了自己默认的 shell 解释器。所以我们在执行 <code>cat -n /etc/shells</code> 命令时，底层执行的是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &#x27;cat -n /etc/shells&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  分析：</p>
</blockquote>
<ul>
<li>  Part1：**/bin/bash**，显式指定使用哪一个 shell 解释器。</li>
<li>  Part2：**-c**，因为 <code>/bin/bash</code> 默认只支持执行一个脚本，而我们当前要执行的是一条命令（command），所以要显式设置一下，表明要执行的是一条命令。</li>
<li>Part3：**’cat -n /etc/shells’**，待执行的 shell 命令。<ul>
<li>  <strong>为什么要用引号引起来？</strong> 因为 shell 在执行命令的时候，参数之间默认使用空格隔开的，如果不用引号引起来，那么当前命令的参数就会被识别成 4 个，显然与实际情况不符。而使用引号引起来后，参数个数就变成了 2 个，这样才是符合当前 shell 脚本的参数设置的，所以这里必须使用单引号将要执行的 shell 命令引起来。</li>
</ul>
</li>
</ul>
<p>执行该条命令同样能得出和上面相同的结果！</p>
<hr>
<h2 id="查看当前-Linux-系统默认使用的-shell-解释器"><a href="#查看当前-Linux-系统默认使用的-shell-解释器" class="headerlink" title="查看当前 Linux 系统默认使用的 shell 解释器"></a>查看当前 Linux 系统默认使用的 shell 解释器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos ~]# echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  <strong>$</strong> 表示引用一个已经定义好的变量，</p>
</li>
<li><p><strong>SHELL</strong> 是一个已经在 Linux 中已经定义好了的全局变量，其变量值就是 <code>/bin/bash</code>。类比于 Java 中就是：</p>
<p>  首先在定义了一个全局变量 SHELL，</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">SHELL</span> <span class="operator">=</span> <span class="string">&quot;/bin/bash&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>  那么在当前上下文中再次使用这个变量时，直接通过变量名调用即可。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SHELL);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Linux-中的常用目录"><a href="#Linux-中的常用目录" class="headerlink" title="Linux 中的常用目录"></a>Linux 中的常用目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bin 和 sbin 目录的位置</span></span><br><span class="line">/usr/bin/</span><br><span class="line">/usr/sbin/</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>/bin</strong>：该目录下保存着用户常用命令对应的脚本，如 <code>cd、pwd、ll</code> 等，所以在该目录下可以使用 shell 解释器直接执行这些脚本。</p>
<p>  <img src="Shell/image-20211030212648163.png" alt="image-20211030212648163"></p>
</li>
<li><p><strong>/sbin（superUser bin）</strong>：该目录下保存着 root 用户常用命令的脚本，一般用于对整个机器进行管理。如 <code>service</code> 等，在该目录下同样可以使用 shell 解释器执行这些脚本。</p>
<p>  <img src="Shell/image-20211030212915700.png" alt="image-20211030212915700"></p>
</li>
</ul>
<hr>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>在上一小节中，我们看到了 Linux 中常用的命令脚本一般都保存在 bin 或 sbin 目录下，那么按道理来说我们只能在 bin 或 sbin 目录下才能够直接执行目录中的命令脚本，但实际情况确实我们在 Linux 中的任何目录下都可以执行这些命令脚本，这是什么原因呢？这就是因为我们将 <code>/usr/bin/</code> 和 <code>/usr/sbin/</code> 目录添加到了环境变量中，这样我们在任何目录下执行命令的时候都会先在当前文件夹下查找，若没有再去检索环境变量对应的目录下是否有该命令，若这两个地方都没有最后再抛出错误信息。</p>
<h3 id="查看当前环境变量目录"><a href="#查看当前环境变量目录" class="headerlink" title="查看当前环境变量目录"></a>查看当前环境变量目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos sbin]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/module/jdk1.8.0_121/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><p>  我们可以看到，在 Linux 中，多个环境变量目录之间用<strong>冒号（:）</strong>分隔。</p>
</li>
<li><p>  而 <code>/usr/sbin:/usr/bin</code> 目录都配置在了环境变量中，所以 bin、sbin 下面的命令脚本在任何位置都能执行，而无需跳转到对应的文件夹下执行。</p>
</li>
<li><p>但是如果我们随便执行一个不存在的命令脚本，它会先查找当前目录下是否存在该命令脚本，若不存在再继续从环境变量对应的目录中去查找，若还不存在最后才报错。比如我们执行一个不存在的脚本命令，Linux 在查找不到后就会抛出一个错误 <strong>command not found（命令找不到）</strong></p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos sbin]# abcll</span><br><span class="line">-bash: abcll: command not found</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Shell-脚本入门"><a href="#Shell-脚本入门" class="headerlink" title="Shell 脚本入门"></a>Shell 脚本入门</h1><h2 id="第一个-shell-脚本"><a href="#第一个-shell-脚本" class="headerlink" title="第一个 shell 脚本"></a>第一个 shell 脚本</h2><ol>
<li><p>创建一个临时文件夹 myshells，编写测试脚本。</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]# mkdir myshells</span><br></pre></td></tr></table></figure></li>
<li><p>在该文件夹下创建一个脚本文件 （起名任意，因为<strong>在 Linux 系统下文件名可以不加后缀</strong>），这里为了见名知意，给它加一个后缀 <code>.sh</code>，表名当前文件是一个 shell 脚本。这里取名为 <code>helloworld.sh</code>。</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]# vim hellworld.sh</span><br></pre></td></tr></table></figure></li>
<li><p>编辑文件内容</p>
<ul>
<li>  格式要求</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、声明，这部分不是必须的，只是一个声明，但是为了语法语义的完整性一般要求必须要写</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 表示用 bash 解释器执行该脚本，同理，如果你写的脚本适配的是csh解释器，则应该声明为 `#!/bin/csh`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、正文：要求必须是shell解释器能解释执行的命令</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  示例</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> HelloWorld!</span><br></pre></td></tr></table></figure></li>
<li><p>执行脚本文件</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]# bash hellworld.sh </span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="脚本常用的执行方式"><a href="#脚本常用的执行方式" class="headerlink" title="脚本常用的执行方式"></a>脚本常用的执行方式</h2><ol>
<li><p><strong>采用 <code>bash</code> 或 <code>sh</code> + 脚本的相对路径或绝对路径</strong></p>
<ul>
<li><p>bash + 脚本文件的绝对路径</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># bash /tmp/hellworld.sh </span></span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure></li>
<li><p>bash + 脚本文件的相对路径</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># bash hellworld.sh </span></span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure></li>
<li><p>sh + 脚本文件的绝对路径</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># sh /tmp/hellworld.sh</span></span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure></li>
<li><p>sh + 脚本文件的相对路径</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># sh hellworld.sh </span></span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure></li>
</ul>
<p> <strong>特点：</strong></p>
<ul>
<li>  方式1的执行特点是会新开启一个 bash 解释器来执行对应的脚本文件，一旦脚本文件执行完毕，这个新开启的bash自动关闭。</li>
<li>  什么叫新开启一个 bash 解释器？就是说当前 Linux 系统已经在维护一个 bash 进程了，使用当前 bash 进程也是可以执行脚本的，但是使用 <code>bash+脚本路径</code> 的执行方式会在当前 bash 的基础上再新建一个 bash 用于执行脚本，形成了一种 bash 的嵌套，并在脚本执行完毕后关闭新建的 bash。</li>
</ul>
</li>
<li><p><strong>直接执行对应的脚本文件（前提：当前用户必须对脚本文件有执行权限）</strong></p>
<ul>
<li><p>首先要赋予 <code>helloworld.sh</code> 脚本文件具有执行权限</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># chmod 777 hellworld.sh </span></span><br></pre></td></tr></table></figure></li>
<li><p>直接执行 <code>helloworld.sh</code> 脚本文件</p>
<p>  1️⃣绝对路径</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># /tmp/hellworld.sh </span></span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure>

<p>  2️⃣相对路径</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># ./hellworld.sh</span></span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure></li>
</ul>
<p> Tip：第一种执行方法，本质上是 bash 解释器帮你执行脚本，所以脚本文件本身不需要执行权限。第二种执行方法，本质上是脚本文件自己执行，所以需要执行权限。</p>
</li>
<li><p><strong>在脚本的路径前加上点（.）</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相对路径</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># . hellworld.sh </span></span><br><span class="line">HelloWorld!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对路径</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># . /tmp/hellworld.sh </span></span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用 source 执行脚本文件</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># source /tmp/hellworld.sh </span></span><br><span class="line">HelloWorld!</span><br><span class="line"></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># source ./hellworld.sh </span></span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure>

<p> Tip：Source 和 点(.) 是相同的，<code>.</code> 实际上是 source 的一种简写，这种执行脚本的方式并不需要当前用户对脚本文件有执行权限。</p>
</li>
</ol>
<hr>
<h1 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h1><h2 id="变量定义规则"><a href="#变量定义规则" class="headerlink" title="变量定义规则"></a>变量定义规则</h2><ol>
<li> 变量名称可以由字母、数字和下划线组成，但是<strong>不能以数字开头</strong>，<strong>环境变量名建议大写</strong>。</li>
<li> <strong>等号两侧不能有空格；</strong>（因为在 shell 中，空格是用来分割参数的，所以等号两侧不能有空格，如果有就会被识别为多个参数）</li>
<li> 在 bash 中，变量默认类型都是字符串类型，<strong>无法直接进行数值运算</strong>。</li>
<li> 变量的值如果有空格，需要使用双引号或单引号括起来。</li>
<li> 使用双引号，可以识别空格之外的其他变量，使用单引号则会只会忽略空格！</li>
<li> 使用反引号，可以将语句运行的结果作为值赋值给变量！</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><ul>
<li>  新增一个变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=变量值 # 注意等号两侧不能有空格</span><br></pre></td></tr></table></figure>

<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><ul>
<li>  <strong>查看指定变量的值</strong>：新增了一个变量后，如果想要查看这个变量，一般使用 <code>echo $变量名</code> 就可以查看这个变量的值。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增变量a</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># a=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看变量a</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># echo $a</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>查看当前 bash 管理的所有变量</strong>：set</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于 set 的输出内容过多，我们可以截取一部分查看，可以看到，我们新定义的变量a也被当前shell所管理</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># set | grep a=1</span></span><br><span class="line">a=1</span><br></pre></td></tr></table></figure>



<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><ul>
<li>  修改操作与新增操作一样，就是把新的变量值赋值给旧的变量名。</li>
</ul>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><ul>
<li>  删除变量：<code>unset 变量名</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># unset a</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># set | grep a=1</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先删除变量a，再查看当前shell管理的所有变量时就发现变量a已经不存在了</span></span><br></pre></td></tr></table></figure>



<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><ul>
<li>  <code>readonly</code> 是一个修饰符，被该关键字修饰的变量只能被读，不能被写（修改或删除）。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个只读变量a</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># readonly a=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取变量a，OK</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># echo $a</span></span><br><span class="line">10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改变量a，Error</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># a=99</span></span><br><span class="line">-bash: a: <span class="built_in">readonly</span> variable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除变量a，Error</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># unset a</span></span><br><span class="line">-bash: <span class="built_in">unset</span>: a: cannot <span class="built_in">unset</span>: <span class="built_in">readonly</span> variable</span><br></pre></td></tr></table></figure>





<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><ul>
<li>  <code>export</code>，导出。作用是将一个变量提升为全局变量。</li>
</ul>
<p><strong>局部变量</strong>：默认只在当前 bash 进程中有效。如果希望在 bashA 中能访问 bashB 中定义的变量，则必须满足以下两点条件：</p>
<ol>
<li> 要求 bashB 不能关闭</li>
<li> 让 bashB 中的变量提升为全局变量，这样才能被 bashA 访问到。</li>
</ol>
<p><strong>Demo</strong></p>
<ol>
<li> 编写 <code>helloworld.sh</code> 脚本，内容为：①输出Hello；②输出变量b；③输出World</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Hello</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"><span class="built_in">echo</span> World</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 在当前 shell 中定义变量b，并测试输出</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># b=99</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># echo $b</span></span><br><span class="line">99</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 在当前 bash 中使用 sh 执行 <code>hellworld.sh</code> 脚本，这条命令会在当前 bash 的基础上新创建一个 bash，由于 <code>$b</code> 是局部变量，所以在新的 bash 中不能检测到该变量，输出为空。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># sh hellworld.sh</span></span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">World</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 将 <code>$b</code> 提升为一个全局变量，由于全局变量的特性，此时新建的 bash 可以访问到原 bash 中的 <code>$b</code>，所有此时的输出如下：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># export b</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># sh hellworld.sh</span></span><br><span class="line">Hello</span><br><span class="line">99</span><br><span class="line">World</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><h4 id="n"><a href="#n" class="headerlink" title="$n"></a>$n</h4><p><strong>基本语法：</strong><code>$n</code></p>
<ul>
<li>  功能描述：n 为数字，<code>$0</code> 代表该<strong>脚本名称</strong>，<code>$1 ~ $9</code> 代表第一到第九个参数，若该脚本含有十个以上的参数，十以上的参数需要用大括号包含，如<code>$&#123;10&#125;</code></li>
</ul>
<p><strong>Demo</strong></p>
<ol>
<li> 编写一个脚本文件：<code>test1.sh</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$0==》&#x27;</span> <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$1==》&#x27;</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$2==》&#x27;</span> <span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$3==》&#x27;</span> <span class="variable">$3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$4==》&#x27;</span> <span class="variable">$4</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$5==》&#x27;</span> <span class="variable">$5</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$6==》&#x27;</span> <span class="variable">$6</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$7==》&#x27;</span> <span class="variable">$7</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$8==》&#x27;</span> <span class="variable">$8</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$9==》&#x27;</span> <span class="variable">$9</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$10==》&#x27;</span> <span class="variable">$&#123;10&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$11==》&#x27;</span> <span class="variable">$&#123;11&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 脚本测试</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># bash test1.sh a b c d e f g h i j k</span></span><br><span class="line"><span class="variable">$0</span>==》 test1.sh</span><br><span class="line"><span class="variable">$1</span>==》 a</span><br><span class="line"><span class="variable">$2</span>==》 b</span><br><span class="line"><span class="variable">$3</span>==》 c</span><br><span class="line"><span class="variable">$4</span>==》 d</span><br><span class="line"><span class="variable">$5</span>==》 e</span><br><span class="line"><span class="variable">$6</span>==》 f</span><br><span class="line"><span class="variable">$7</span>==》 g</span><br><span class="line"><span class="variable">$8</span>==》 h</span><br><span class="line"><span class="variable">$9</span>==》 i</span><br><span class="line"><span class="variable">$10</span>==》 j</span><br><span class="line"><span class="variable">$11</span>==》 k</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分析：<ul>
<li>  执行脚本的时候共传入了 11 个参数；</li>
<li>  在脚本中，<code>$0</code> 输出了当前脚本文件的名称；</li>
<li>  <code>$1 ~ $9</code>，分别输出了第1~9个参数；</li>
<li>  <code>$&#123;10&#125;</code> 和 <code>$&#123;11&#125;</code> 分别输出了第 10 个和第 11 个参数。</li>
</ul>
</li>
</ol>
<hr>
<h4 id=""><a href="#" class="headerlink" title="$#"></a>$#</h4><p><strong>基本语法</strong>：<code>$#</code></p>
<ul>
<li>  功能描述：获取所有输入参数个数，常用于循环。</li>
</ul>
<p><strong>Demo</strong></p>
<ol>
<li> 编写一个脚本 <code>test2.sh</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 脚本测试</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># sh test2.sh</span></span><br><span class="line">0</span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># sh test2.sh 1 2 3 4 5</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="和"><a href="#和" class="headerlink" title="$* 和 $@"></a>$* 和 $@</h4><ul>
<li>  <code>$*</code>：打印执行这个脚本时输入的所有参数，也就是参数列表，<code>$*</code> 把所有的参数看成一个整体；</li>
<li>  <code>$@</code>：打印执行这个脚本时输入的所有参数，也就是参数列表，不过 <code>$@</code> 把每个参数区分对待。</li>
</ul>
<ol>
<li> 编写一个测试脚本</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$*==========================&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> $*</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$@==========================&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 脚本测试</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># sh test3.sh 1 2 3 4 5</span></span><br><span class="line">$*==========================</span><br><span class="line">1 2 3 4 5</span><br><span class="line"><span class="variable">$@</span>==========================</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="-1"><a href="#-1" class="headerlink" title="$?"></a>$?</h4><p><strong>基本语法</strong>：<code>$?</code></p>
<ul>
<li>  功能描述：返回上一条命令的执行状态。如果返回值为0，则证明上一条命令执行成功，如果返回值<strong>非0</strong>，则证明上一条命令执行失败。</li>
</ul>
<p><strong>Demo</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示上一条命令执行成功</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随便给一条必然会执行失败的指令</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># asdadad</span></span><br><span class="line">-bash: asdadad: <span class="built_in">command</span> not found</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次测试发现返回结果非0，表示上一条命令执行失败</span></span><br><span class="line">[root@VM-0-17-centos tmp]<span class="comment"># echo $?</span></span><br><span class="line">127</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h2><ul>
<li>  <strong>产生：</strong>在第一次创建变量时产生</li>
<li>  <strong>销毁：</strong>①变量在执行 unset 时会被销毁；②当关闭当前 bash 时，当前 bash 所定义的变量也会被全部销毁。</li>
</ul>
<h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><h2 id="和-反引号-的区别"><a href="#和-反引号-的区别" class="headerlink" title="$() 和 反引号 的区别"></a>$() 和 反引号<code> </code>的区别</h2><p>在 bash中，<code>$()</code>与 <code> </code>（反引号）都是用来作命令替换的。<strong>命令替换</strong>与变量替换差不多，都是用来重组命令行的，先完成引号里的命令行，然后将其结果替换出来，再重组成新的命令行。</p>
<ul>
<li>  <code>$()</code> 与｀｀</li>
</ul>
<p>在操作上，这两者都能达到相同的效果，但是建议使用 <code>$( )</code>，理由如下：</p>
<hr>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="整数运算符"><a href="#整数运算符" class="headerlink" title="整数运算符"></a>整数运算符</h2><p><strong>整数运算符</strong>：只适用于整数之间的运算，小数不适用，浮点运算需要借助其它的命令。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li>  方式一：使用 <code>$</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">((运算式))</span></span><br><span class="line">或</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">[运算式]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  案例一</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos ~]<span class="comment"># echo $(((1+1)*3-3))</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">[root@VM-0-17-centos ~]<span class="comment"># num=$[(1+2)*2-4]</span></span><br><span class="line">[root@VM-0-17-centos ~]<span class="comment"># echo $num</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<ul>
<li><p>方式二：使用 <code>expr</code> 表达式</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运算符：+ , - , \*, /, %</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<ol>
<li> <code>expr</code> 运算符间要有空格; </li>
<li> 在 Shell 中，<code>*</code> 默认被识别为通配符，所以如果想要进行乘运算，需要对 <code>*</code> 进行转义，转义为 <code>\*</code>，否则会被视为通配符；</li>
<li> <code>expr</code> 不支持括号，所以在进行复杂运算时经常需要和反引号（<code> </code>）或 <code>$()</code> 配合使用。</li>
</ol>
</li>
</ul>
</li>
<li><p>  案例二：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos ~]<span class="comment"># expr 2 + 3</span></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复杂运算：(1+1)*2</span></span><br><span class="line"><span class="comment"># 反引号 `` 或 $() ，可以将语句运行的结果作为值赋值给一个变量</span></span><br><span class="line">[root@VM-0-17-centos ~]<span class="comment"># expr `expr 1 + 1` \* 2</span></span><br><span class="line">4</span><br><span class="line"><span class="comment"># 分析：先计算 `expr 1 + 1` 结果为 2，再将结果代入外层的表达式继续进行运算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是使用反引号不适合多层括号嵌套的运算，理由是反引号无法进行智能识别，</span></span><br><span class="line"><span class="comment"># 例如计算 ((1+1)*2-1)/4，使用反引号表达式为：</span></span><br><span class="line">[root@VM-0-17-centos ~]<span class="comment"># expr `expr `expr 1 + 1` \* 2 - 1` / 4</span></span><br><span class="line"><span class="built_in">expr</span>: missing operand</span><br><span class="line">Try <span class="string">&#x27;expr --help&#x27;</span> <span class="keyword">for</span> more information.</span><br><span class="line">-bash: *: <span class="built_in">command</span> not found</span><br><span class="line"><span class="built_in">expr</span>: syntax error</span><br><span class="line"><span class="comment"># 因为反引号被提前识别了，在 `expr` 上消耗了一对反引号，导致剩余的反引号不能正确被识别，所以这时需要用 $() 来代替反引号</span></span><br><span class="line"></span><br><span class="line">[root@VM-0-17-centos ~]<span class="comment"># expr $(expr $(expr 1 + 1) \* 2 - 1) / 4</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><ol>
<li> 基本语法</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ condition ]	</span><br><span class="line"><span class="comment"># 1、condition 是一个条件表达式；</span></span><br><span class="line"><span class="comment"># 2、condition 的返回值是 Boolean 类型，在shell中，0为true，非0为false</span></span><br><span class="line"><span class="comment"># 3、注意condition前后要有空格</span></span><br><span class="line"><span class="comment"># 4、注意：如果 condition 不是一个条件表达式而是一个普通字符串，那么非空即为true，空为false。</span></span><br><span class="line"><span class="comment"># 如 [ newBoy ] 返回true，[] 返回false。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>常用判断条件</p>
<ol>
<li><p> <strong>字符串比较</strong>：字符串比较使用 <code>=</code>；</p>
</li>
<li><p><strong>两个整数之间比较</strong>：不能使用 <code>=</code> 而是要使用 shell 提供的比较符，注意<strong>在 shell 中比较复杂两边必须有空格</strong>。 常见的比较符如下：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-lt 小于（less than）            -le 小于等于（less equal）</span><br><span class="line"></span><br><span class="line">-eq 等于（equal）                   -gt 大于（greater than）</span><br><span class="line"></span><br><span class="line">-ge 大于等于（greater equal）  -ne 不等于（Not equal）</span><br></pre></td></tr></table></figure></li>
<li><p><strong>按照文件权限进行判断</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r 有读的权限（<span class="built_in">read</span>）          -w 有写的权限（write）</span><br><span class="line"></span><br><span class="line">-x 有执行的权限（execute）</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>按照文件类型进行判断</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-f 文件存在并且是一个常规的文件（file）</span><br><span class="line"></span><br><span class="line">-e 文件存在（existence）       -d 文件存在并是一个目录（directory）</span><br><span class="line"></span><br><span class="line">-s 文件存在且不为空      -L 文件存在且是一个链接(<span class="built_in">link</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>案例实操</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（1）23是否小于等于22</span></span><br><span class="line"></span><br><span class="line">[root@VM-0-17-centos ~]<span class="comment"># [ 23 -lt 32 ]</span></span><br><span class="line">[root@VM-0-17-centos ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#（2）当前用户对 /etc 目录是否有写的权限</span></span><br><span class="line">[root@VM-0-17-centos /]<span class="comment"># [ -w etc ]</span></span><br><span class="line">[root@VM-0-17-centos /]<span class="comment"># echo $?</span></span><br><span class="line">0	<span class="comment"># 0表示true，即有写的权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#（3）/etc 文件是否存在并且是一个目录</span></span><br><span class="line">[root@VM-0-17-centos /]<span class="comment"># [ -d /etc ]</span></span><br><span class="line">[root@VM-0-17-centos /]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）</span></span><br><span class="line"></span><br><span class="line">[root@VM-0-17-centos /]<span class="comment"># [ condition ] &amp;&amp; echo Yes || echo No</span></span><br><span class="line">Yes</span><br><span class="line">[root@VM-0-17-centos /]<span class="comment"># [ condition ] &amp;&amp; [ ] || echo No</span></span><br><span class="line">No</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h2><ol>
<li><p><strong>基本语法</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式 ] </span><br><span class="line">  	<span class="keyword">then</span> 程序 </span><br><span class="line"><span class="keyword">elif</span> [ 条件判断式 ] </span><br><span class="line">	<span class="keyword">then</span> 程序..</span><br><span class="line"><span class="keyword">else</span> 程序..</span><br><span class="line"><span class="keyword">fi</span>	<span class="comment"># if 是 if 的反写，表示if代码块结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">if</span> [ 条件判断式 ] ; <span class="keyword">then</span> 程序.. </span><br><span class="line"><span class="keyword">elif</span> [条件判断式] ; <span class="keyword">then</span> 程序..</span><br><span class="line"><span class="keyword">else</span> 程序</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项：<ol>
<li> <code>[ 条件判断式 ]</code>：中括号和条件判断式之间必须有空格</li>
<li> <strong><code>if</code> 后要有空格</strong></li>
</ol>
</li>
</ul>
</li>
<li><p>案例实操</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求：判断用户如果用户输入的参数是否为1，如果是1，就打印1；如果是2，就打印2；如果是3，就打印3；否则打印不是是1，2，3。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> -eq 1 ]</span><br><span class="line">  <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;用户输入的参数为：&quot;</span><span class="variable">$1</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> -eq 2 ]</span><br><span class="line">  <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;用户输入的参数为：&quot;</span><span class="variable">$1</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> -eq 3 ]</span><br><span class="line">  <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;用户输入的参数为：&quot;</span><span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">&quot;用户输入的参数不是1，2，3！&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h2><ol>
<li><p><strong>基本语法</strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $变量名 <span class="keyword">in</span> </span><br><span class="line">	<span class="string">&quot;值1&quot;</span>） </span><br><span class="line">		如果变量的值等于值1，则执行程序1 </span><br><span class="line">	;; </span><br><span class="line">	</span><br><span class="line">	<span class="string">&quot;值2&quot;</span>） </span><br><span class="line">		如果变量的值等于值2，则执行程序2 </span><br><span class="line">	;; </span><br><span class="line">	</span><br><span class="line">	*）</span><br><span class="line">		如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">	;; </span><br><span class="line"><span class="keyword">esac</span>	<span class="comment"># 反写case表示case结束</span></span><br></pre></td></tr></table></figure>

<p> <strong>注意事项：</strong></p>
<ul>
<li>  case 行尾必须为单词 <code>in</code>，每一个模式匹配必须以右括号 <code>)</code>结束。</li>
<li>  双分号 <code>;;</code> 表示命令序列结束，相当于 Java 中的 break。</li>
<li>  最后的 <code>*）</code> 表示默认模式，相当于 Java 中的 default。     </li>
</ul>
</li>
<li><p>案例实操</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断用户输入的参数是否为 guest，如果是 guest，输出欢迎光临；如果是admin，输出欢迎管理员；其它情况输出不欢迎。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">  guset)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;欢迎光临！&quot;</span></span><br><span class="line">  ;;</span><br><span class="line">  admin)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;欢迎管理员！&quot;</span></span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;不欢迎！&quot;</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span>	</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ol>
<li><p>基本语法</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">		程序</span><br><span class="line">    <span class="keyword">done</span>	<span class="comment"># 表示程序执行结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (( 初始值;循环控制条件;变量变化 )); <span class="keyword">do</span> 程序; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
<li><p>案例实操</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计1-100的和</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>=0</span><br><span class="line"><span class="keyword">for</span>((i=1; i&lt;=100; i++))</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">    	<span class="built_in">sum</span>=$[<span class="variable">$sum</span> + <span class="variable">$i</span>]</span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切记在shell中等号两边不能有空格</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><ol>
<li><p>基本语法</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 值1 值2 值3… </span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">		程序 </span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 1 2 3; <span class="keyword">do</span> 程序; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> &#123;1..3&#125;; <span class="keyword">do</span> 程序; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
<li><p>案例实操</p>
<ul>
<li><p>打印集合中的数字</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环遍历输出集合中每个元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> 数鸭子<span class="variable">$num</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>动态获取参数列表集合</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环遍历输出结合中每个元素的值</span></span><br><span class="line"><span class="comment"># 通过 $* 或 $@ 获取参数列表中的所有参数</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> $*</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> 数鸭子<span class="variable">$num</span></span><br><span class="line">    <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>  执行结果：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos 00temp]<span class="comment"># bash foreach.sh 1 3 5 7 9</span></span><br><span class="line">数鸭子1</span><br><span class="line">数鸭子3</span><br><span class="line">数鸭子5</span><br><span class="line">数鸭子7</span><br><span class="line">数鸭子9</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="比较-和-区别"><a href="#比较-和-区别" class="headerlink" title="比较 $* 和 $@ 区别"></a>比较 $* 和 $@ 区别</h3><ol>
<li><p><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号<code>“ ”</code>包含时，二者是等价的，都是以 <code>$1 $2 …$n</code> 的形式输出所有参数。</p>
<ul>
<li>  编写 dif.sh 脚本</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash      </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;张三打中了 <span class="variable">$i</span> 环&quot;</span>  </span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;李四打中了 <span class="variable">$j</span> 环&quot;</span>  </span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  运行 dif.sh 脚本</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos 00temp]<span class="comment"># bash dif.sh 10 9 8 7</span></span><br><span class="line">张三打中了 10 环</span><br><span class="line">张三打中了 9 环</span><br><span class="line">张三打中了 8 环</span><br><span class="line">张三打中了 7 环</span><br><span class="line">李四打中了 10 环</span><br><span class="line">李四打中了 9 环</span><br><span class="line">李四打中了 8 环</span><br><span class="line">李四打中了 7 环</span><br></pre></td></tr></table></figure></li>
<li><p>当它们被双引号 <code>“”</code> 包含时，<code>“$*”</code> 会将所有的参数作为一个整体，以 <code>“$1 $2 …$n”</code> 的形式输出所有参数；而 <code>“$@”</code> 会将各个参数分开，以<code>“$1” “$2”…”$n”</code>的形式输出所有参数。</p>
<ul>
<li>  编写 dif2.sh 脚本</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash      </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;张三打中了 <span class="variable">$i</span> 环&quot;</span>  </span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;李四打中了 <span class="variable">$j</span> 环&quot;</span>  </span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  运行 dif2.sh 脚本</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos 00temp]<span class="comment"># bash dif2.sh 10 9 8 7</span></span><br><span class="line">张三打中了 10 9 8 7 环</span><br><span class="line">李四打中了 10 环</span><br><span class="line">李四打中了 9 环</span><br><span class="line">李四打中了 8 环</span><br><span class="line">李四打中了 7 环</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>  当 <code>$@</code> 和 <code>$*</code> 都不被双引号包裹时，二者的作用是一样的；</li>
<li>  当 <code>$@</code> 和 <code>$*</code> 被双引号包裹时，即表现形式为 <code>&quot;$@&quot;</code> 和 <code>&quot;$*&quot;</code> ，<code>&quot;$@&quot;</code> 表示将参数列表中的所有参数分别处理，而 <code>&quot;$*&quot;</code> 表示将参数列表中的所有参数视为一个整体处理。</li>
</ul>
<hr>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><ol>
<li><p>基本语法</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件判断式 ] </span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">  		程序</span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((表达式))</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	    程序</span><br><span class="line">	<span class="keyword">done</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>案例实操</p>
<ul>
<li>  编写 <code>while.sh</code> 脚本</li>
</ul>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 从1累加到100，用while循环实现</span></span><br><span class="line"><span class="built_in">sum</span>=0</span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 100 ]</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">sum</span>=$[<span class="variable">$sum</span>+<span class="variable">$i</span>]</span><br><span class="line">    i=$[<span class="variable">$i</span>+1]</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h2><p><strong>作用：</strong>读取控制台输入</p>
<p><strong>基本语法</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(选项)(参数)</span><br><span class="line">  选项：</span><br><span class="line">	-p：指定读取值时的提示符；(<span class="built_in">print</span>)</span><br><span class="line">	-t：指定读取值时等待的时间（秒）。(time)</span><br><span class="line"></span><br><span class="line">  参数</span><br><span class="line">	变量：将读取到值赋值给一个变量，在这里设定变量名</span><br></pre></td></tr></table></figure>

<p><strong>Demo</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示通过 username 接收控制台的输入，-p 表示提供给控制台的展示信息，-t 表示在10s之后自动退出，如果不指定表示一直死等，永不退出</span></span><br><span class="line">[root@VM-0-17-centos 00temp]<span class="comment"># read -p 请输入用户名： -t 10 username</span></span><br><span class="line">请输入用户名：张三</span><br><span class="line">[root@VM-0-17-centos 00temp]<span class="comment"># echo $username</span></span><br><span class="line">张三</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="basename-和-dirname"><a href="#basename-和-dirname" class="headerlink" title="basename 和 dirname"></a>basename 和 dirname</h2><h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><p><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename [string / pathname] [suffix] </span><br></pre></td></tr></table></figure>

<ul>
<li>  功能描述：<code>basename</code> 命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。</li>
<li>  选项：<code>suffix</code> 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。</li>
</ul>
<p><strong>Demo</strong></p>
<ul>
<li>  截取该 <code>/opt/module/jdk1.8.0_121/</code> 路径的文件名称</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos module]<span class="comment"># basename /opt/module/jdk1.8.0_121/</span></span><br><span class="line">jdk1.8.0_121</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除后缀</span></span><br><span class="line">[root@VM-0-17-centos module]<span class="comment"># basename /opt/module/jdk1.8.0_121/ _121</span></span><br><span class="line">jdk1.8.0</span><br></pre></td></tr></table></figure>





<h3 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h3><p><strong>作用</strong>：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</p>
<p><strong>Demo</strong></p>
<ul>
<li>  比如当前系统有一个文件的绝对路径是：<code>/opt/module/jdk1.8.0_121/</code>，那么使用 <code>dirname</code> 函数后：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos module]<span class="comment"># dirname /opt/module/jdk1.8.0_121/</span></span><br><span class="line">/opt/module		<span class="comment"># 得到文件前的路径</span></span><br><span class="line">[root@VM-0-17-centos module]<span class="comment"># dirname jdk1.8.0_121/</span></span><br><span class="line">.	<span class="comment"># 得到文件前的相对路径， `.` 表示当前目录</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p><strong>基本语法</strong></p>
<ol>
<li> <strong>函数定义</strong></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">关键字 函数名()</span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line">	<span class="comment"># 如果没有定义return，默认返回函数中最后一条语句的执行结果</span></span><br><span class="line">	[<span class="built_in">return</span> int]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> funname[()]</span><br><span class="line">&#123;</span><br><span class="line">	Action;</span><br><span class="line">	[<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> <strong>函数调用</strong></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名 参数1 参数2 ...</span><br></pre></td></tr></table></figure>





<p><strong>Tip</strong></p>
<ul>
<li>  必须在调用函数之前先声明函数，因为 shell 脚本是逐行运行的，不会像其它语言一样先编译。</li>
<li>  函数返回值只能通过 <code>$?</code> 系统变量获得，可以通过显式声明 <code>return</code> 返回，如果没有显式声明，将以最后一条命令运行结果作为返回值，return 后跟的数值是整型且范围必须在 <code>0-255</code> 内。</li>
</ul>
<p><strong>Demo</strong></p>
<ul>
<li>  <code>add.sh</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求：两数之和</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    result=$[<span class="variable">$1</span>+<span class="variable">$2</span>]</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两数之和为<span class="variable">$result</span>&quot;</span></span><br><span class="line">    <span class="comment"># 如果没有显式指定return，返回函数中的最后一条语句的执行结果</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数调用：执行脚本时真正运行的程序</span></span><br><span class="line">  <span class="comment"># 1、读取用户输入的两个参数</span></span><br><span class="line"><span class="built_in">read</span> -p 请输入第一个参数：num1</span><br><span class="line"><span class="built_in">read</span> -p 请输入第二个参数：num2</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 2、调用自定义的 add 函数</span></span><br><span class="line">add num1 num2</span><br></pre></td></tr></table></figure>

<ul>
<li>  执行脚本</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos module]<span class="comment"># bash add.sh </span></span><br><span class="line">请输入第一个参数：10</span><br><span class="line">请输入第二个参数：20</span><br><span class="line">两数之和为30</span><br><span class="line">[root@VM-0-17-centos module]<span class="comment"># echo $?	</span></span><br><span class="line">30	<span class="comment"># 在控制台上打印上一个函数的返回结果</span></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="Shell-工具"><a href="#Shell-工具" class="headerlink" title="Shell 工具"></a>Shell 工具</h1><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p><strong>wc（WordCount）</strong>命令用来计算数字。利用<code>wc</code>指令我们可以用来统计文件行数、单词数、字符数、字节数。</p>
<p>若不指定文件名称，或是所给予的文件名为 “-” ，则wc指令会从标准输入设备读取数据。</p>
<p><strong>基本用法</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> [选项参数] filename</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>-l</code></td>
<td>统计文件行数</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>统计文件的单词数</td>
</tr>
<tr>
<td><code>-m</code></td>
<td>统计文件的字符数</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>统计文件的字节数</td>
</tr>
</tbody></table>
<p><strong>Demo</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos module]<span class="comment"># wc myfun.sh </span></span><br><span class="line"> 20  35 468 myfun.sh	<span class="comment"># 默认展示4个属性，包括：行数 单词数 字节数 文件名	</span></span><br><span class="line"> <span class="comment"># 行数 单词数 字节数 文件名	</span></span><br><span class="line"> </span><br><span class="line">[root@VM-0-17-centos module]<span class="comment"># wc -m myfun.sh </span></span><br><span class="line">272 myfun.sh	<span class="comment"># 单独展示字符数+文件名</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p><strong>cut</strong> 就是在文件中负责剪切数据用的。cut 命令从文件的<strong>每一行</strong>剪切字节、字符和字段并将这些字节、字符和字段输出。cut 不会改变源文件的数据。</p>
<p><strong>基本用法</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> [选项参数]  filename </span><br></pre></td></tr></table></figure>

<ul>
<li>  说明：默认分隔符是制表符</li>
</ul>
<p><strong>选项参数说明</strong></p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>-f</code></td>
<td>f 为 fileds，列号，提取第几列</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>d 为 Descriptor，分隔符，按照指定分隔符分割列</td>
</tr>
</tbody></table>
<p><strong>Demo</strong></p>
<ol>
<li> 首先查看 <code>$PATH</code> 变量的内容</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos module]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/module/jdk1.8.0_121/bin:/root/bin</span><br></pre></td></tr></table></figure>



<ol start="2">
<li> 以 <code>:</code> 为分隔符，切割 PATH 环境变量，并取出第一列</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos module]<span class="comment"># echo $PATH | cut -d : -f 1</span></span><br><span class="line">/usr/local/sbin</span><br></pre></td></tr></table></figure>



<ol start="3">
<li> 以 <code>:</code> 为分隔符，切割 PATH 环境变量，并取出第二、三列</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos module]<span class="comment"># echo $PATH | cut -d : -f 2,3</span></span><br><span class="line">/usr/local/bin:/usr/sbin</span><br></pre></td></tr></table></figure>



<ol start="4">
<li> 以 <code>:</code> 为分隔符，切割 PATH 环境变量，并取出第2个<code>:</code>开始后的所有路径：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos module]<span class="comment"># echo $PATH | cut -d : -f 2-</span></span><br><span class="line">/usr/local/bin:/usr/sbin:/usr/bin:/opt/module/jdk1.8.0_121/bin:/root/bin</span><br></pre></td></tr></table></figure>



<ol start="5">
<li> 以 <code>:</code> 为分隔符，切割 PATH 环境变量，并取出第第一到三列，和第五列</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-17-centos module]<span class="comment"># echo $PATH | cut -d : -f 1-3,5</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/opt/module/jdk1.8.0_121/bin</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p><strong>sed</strong> 是一种<strong>流</strong>处理器，用于批量处理，它每次处理的单位是一行。处理时，把当前要处理的行数据存储在临时缓冲区中，接着用 <code>sed</code> 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。<code>sed</code> 命令并不会修改源文件的内容。</p>
<p><strong>基本用法</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [选项参数] ‘<span class="built_in">command</span>’ filename</span><br></pre></td></tr></table></figure>



<p><strong>选项参数说明</strong></p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>-e</code></td>
<td>直接在指令列模式上进行sed的动作编辑。</td>
</tr>
</tbody></table>
<p><strong>命令功能描述</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>新增（add），a 的后面可以接字串，在下一行出现</td>
</tr>
<tr>
<td>d</td>
<td>删除（delete）</td>
</tr>
<tr>
<td>s</td>
<td>查找并替换（search）</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/28/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/28/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">Java序列化和反序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-10-28 23:36:17 / Modified: 23:36:31" itemprop="dateCreated datePublished" datetime="2021-10-28T23:36:17+08:00">2021-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/06/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">MySQL锁机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-06 14:21:52" itemprop="dateCreated datePublished" datetime="2021-10-06T14:21:52+08:00">2021-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-07 21:52:04" itemprop="dateModified" datetime="2021-10-07T21:52:04+08:00">2021-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><strong>定义：</strong></p>
<ul>
<li>  锁是<strong>计算机协调多个进程或线程并发访问某一资源时的机制</strong>。</li>
<li>  在数据库中的数据是一种供许多用户共享的资源，所以就可能出现多个用户并发访问的情况。<strong>如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题</strong>。锁冲突也是影响数据库并发访问性能的一个重要因素。</li>
<li>  在 MySQL 架构的连接层中，存在一个 ConnectionPool，与 MySQL 服务器连接的每个客户端都会维护一个会话（Session），当同时有多个 Session 操作同一数据库中的同一数据时，就会产生冲突，这时就需要 MySQL 的锁机制来维护数据的一致性了。</li>
</ul>
<p><strong>生活案例：</strong></p>
<p>淘宝秒杀抢手机，库存只剩最后一件了，如果同时有多个用户同时点击了购买，到底谁买到？</p>
<p>首先，这里肯定要使用到事务，我们先从库存表中取出商品数量，然后插入订单，付款后插入付款表信息，最后更新商品数量。在这个过程中，使用锁可以对共享资源进行保护，解决隔离和并发的矛盾。</p>
<p><strong>注意：</strong></p>
<ul>
<li>  <strong>数据库锁都是悲观锁！！！</strong></li>
</ul>
<hr>
<h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><blockquote>
<p>  <strong>一些概念：</strong></p>
</blockquote>
<ul>
<li>  开销：开销指实现锁需要消耗的资源</li>
<li>  加锁速度：</li>
<li>  死锁：</li>
<li>  粒度：</li>
<li>  并发性能：</li>
</ul>
<blockquote>
<p>  从<strong>对数据操作的类型</strong>来分可分为：</p>
</blockquote>
<ul>
<li>  <strong>读锁（共享锁）</strong>：针对同一份数据，多个读操作可以同时读而不会互相影响。</li>
<li>  <strong>写锁（排它锁）</strong>：当前写操作没有完成之前，它会阻断其它写锁和读锁。【注意：写和读都被阻断了】</li>
</ul>
<blockquote>
<p>  从<strong>对数据操作的粒度</strong>来分可分为：</p>
</blockquote>
<ul>
<li>  <strong>行锁（Row_Level_Lock）：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
<li>  <strong>表锁（Table_Level_Lock）：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
<li>  <strong>页锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<blockquote>
<p>  <strong>使用场景：</strong></p>
</blockquote>
<ul>
<li>  只能就具体应用的特点来说哪种锁更合适。</li>
<li>  表锁更适合以查询为主的表使用。</li>
<li>  行锁更适合以写为主的表使用。</li>
</ul>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">读锁（共享锁）</th>
<th align="center">写锁（独占锁）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>表锁</strong></td>
<td align="center">表共享读锁</td>
<td align="center">表独占写锁</td>
</tr>
<tr>
<td align="center"><strong>行锁</strong></td>
<td align="center">行共享读锁</td>
<td align="center">行独占写锁</td>
</tr>
</tbody></table>
<hr>
<h1 id="MySQL-锁机制"><a href="#MySQL-锁机制" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h1><h2 id="MySQL-中的锁"><a href="#MySQL-中的锁" class="headerlink" title="MySQL 中的锁"></a>MySQL 中的锁</h2><ol>
<li><p>MyISAM 表锁</p>
<ul>
<li>  MyISAM 表共享读锁</li>
<li>  MyISAM 表独占写锁</li>
</ul>
</li>
<li><p>InnoDB 行锁</p>
<ul>
<li>  InnoDB 行共享读锁</li>
<li>  InnoDB 行独占写锁</li>
</ul>
<p> InnoDB 表锁</p>
<ul>
<li>  InnoDB 表共享读锁</li>
<li>  InnoDB 表独占写锁</li>
</ul>
</li>
<li><p> Memory 表锁</p>
</li>
<li><p> ……</p>
</li>
</ol>
<h2 id="MySQL-锁机制-1"><a href="#MySQL-锁机制-1" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h2><p><strong>MySQL 的锁机制比较简单，就是不同的存储引擎支持不同的锁机制。</strong>比如：</p>
<ul>
<li>  InnoDB 默认使用行锁，但也支持表锁。</li>
<li>  MyISAM 默认使用表锁，且只支持表锁。</li>
</ul>
<hr>
<h1 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>  无死锁</li>
<li>  锁粒度大</li>
<li>  发生锁冲突的概率最高</li>
<li>  并发度最低</li>
<li>  开销小，加锁快【一张表只需加一个锁自然开销小，锁的粒度大，加锁自然快】</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>  查看数据库中所有表锁</li>
<li>  加（表）锁</li>
<li>  释放（表）锁</li>
</ul>
<ol>
<li> **创建表 tb_emp 和 tb_dep **</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS tb_emp (</span><br><span class="line">    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(20) DEFAULT &#x27;&#x27;</span><br><span class="line">)ENGINE=MYISAM;	# 使用MYISAM引擎建的表 </span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS tb_dep (</span><br><span class="line">    id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(20) DEFAULT &#x27;&#x27;</span><br><span class="line">)ENGINE=MYISAM;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> <strong>手动加锁（读锁或写锁）</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 语法</span><br><span class="line">lock table 表名1 read, 表名2 write;</span><br><span class="line"></span><br><span class="line">-- 给tb_emp表加读锁，给 tb_dep表加写锁</span><br><span class="line">lock table tb_emp read, tb_dep write;	</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> <strong>查看数据库中所有表的锁</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查看数据库中所有表的锁</span><br><span class="line">SHOW OPEN TABLES;</span><br></pre></td></tr></table></figure>

<p><img src="MySQL%E9%94%81%E6%9C%BA%E5%88%B6/image-20210725182834745.png" alt="image-20210725182834745"></p>
<ol start="4">
<li> <strong>释放锁</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 释放锁（Tip：释放锁使不能单个表释放，只能一次性释放所有表的锁）</span><br><span class="line">UNLOCK TABLE;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="给表加读锁"><a href="#给表加读锁" class="headerlink" title="给表加读锁"></a>给表加读锁</h3><ol>
<li> <strong>向上面建好的 tb_emp 表中插入数据</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tb_emp(NAME) VALUES(&#x27;张三&#x27;);</span><br><span class="line">INSERT INTO tb_emp(NAME) VALUES(&#x27;李四&#x27;);</span><br><span class="line">INSERT INTO tb_emp(NAME) VALUES(&#x27;王五&#x27;);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li> <strong>模拟两个连接同时操作 tb_emp 表</strong></li>
</ol>
<p><img src="MySQL%E9%94%81%E6%9C%BA%E5%88%B6/%E8%AF%BB%E9%94%81.png" alt="读锁"></p>
<table>
<thead>
<tr>
<th align="center">线程 T1</th>
<th align="center">线程 T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>lock table tb_emp read; </code>【OK】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>select * from tb_emp; </code>  【OK】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>select * from tb_emp; </code>  【OK】</td>
</tr>
<tr>
<td align="center"><code>UPDATE tb_emp SET NAME=&quot;张飞&quot; WHERE id=1;</code>  【Error】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>UPDATE tb_emp SET NAME=&quot;张飞&quot; WHERE id=1;</code>  【阻塞】</td>
</tr>
<tr>
<td align="center"><code>UNLOCK TABLES;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>UPDATE tb_emp SET NAME=&quot;张飞&quot; WHERE id=1;</code>  【OK】</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<p>两个线程同时操作数据库中的同一张表，</p>
<ol>
<li> 首先，线程 T1 先对 emp 表加表共享读锁；</li>
<li> 然后，T1 对加锁的表执行查询操作，OK；【因为 T1 本身就是持有锁的】</li>
<li> 再之，T2 对加锁的表进行查询操作，OK；【因为读锁是一种共享锁】</li>
<li> T1 在未释放锁之前，想要读取其它表（非加锁的表），发现<strong>报错</strong>；【拿着锁不干事反而想去操作其它表是不被允许的】</li>
<li> T2 读取未加锁的表，OK；</li>
<li> T1 在未释放锁之前，想要修改被加锁的表，<strong>报错</strong>；【读锁只能读不能写】</li>
<li> T2 想要修改未加锁的表，发现没有报错 ，但程序被<strong>阻塞</strong>【一直在转圈，但不能执行结束】</li>
<li> T1 释放读锁；</li>
<li> 这时 T2 立即执行未执行完的更新的操作。</li>
</ol>
<h3 id="给表加写锁"><a href="#给表加写锁" class="headerlink" title="给表加写锁"></a>给表加写锁</h3><ul>
<li>  当前线程对表的 查询+更新+插入 操作都可以执行；</li>
<li>  其它线程对表的查询被阻塞，需要等待锁被释放。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对所有使用 MyISAM 引擎的表进行操作，会有以下情况：</p>
<ul>
<li>  对 MyISAM 表的读操作，不会阻塞其它线程对同一表的读请求，但是会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它线程的写操作。</li>
<li>  对 MyISAM 表的写操作，会阻塞其它线程对同一表的读和写操作，只有当写锁释放后，才会执行其它线程的读写操作。</li>
</ul>
<p>简而言之，就是<strong>读的时候可以读，读的时候不能写，写的时候不能读，写的时候不能写</strong>（读就是共享读，其它的可以读，不能写；写是独占写，其它的不能读也不能写）</p>
<p><strong>MyISAM 不适合作为以写操作为主的表的引擎</strong>。因为对表中数据进行的写操作会造成表被自动加写锁，导致其它线程不能做任何操作，如果存在大量的更新会使得查询操作很难获取到锁，从而造成永远阻塞。</p>
<hr>
<h2 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h2><blockquote>
<p>  <strong>查看哪些表被加锁了</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW OPEN TABLES;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>表锁分析</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检查锁的状态</span><br><span class="line">SHOW STATUS LIKE &#x27;table%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="MySQL%E9%94%81%E6%9C%BA%E5%88%B6/image-20210727220206563.png" alt="image-20210727220206563"></p>
<p>这里有一些属性记录了某个表锁的运行情况，两个重要的属性说明如下：</p>
<ul>
<li>  <strong>table_locks_immediate</strong>：表锁被获取过的次数，每次获取锁时该值 <code>+1</code>。</li>
<li>  <strong>table_locks_waited</strong>：由于表锁争用而发生等待的次数（不能立即获取锁的次数，每等待一次该值 <code>+1</code>）。此值较高则说明存在着较严重的表级锁争用的情况。</li>
</ul>
<hr>
<h1 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>  会出现死锁</li>
<li>  锁的粒度小</li>
<li>  发生锁冲突的概率最低</li>
<li>  并发度最高</li>
<li>  开销大，加锁慢。（需要给每行数据都加锁，自然开销比较大，加锁比较慢）</li>
</ul>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><ul>
<li>  加<strong>行共享读锁</strong>：<code>lock in share mode</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">-- 手动</span><br><span class="line">SELECT * FROM tb_stu WHERE id=5 LOCK IN SHARE MODE;</span><br><span class="line"></span><br><span class="line">-- 事务提交后会自动释放锁</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>



<ul>
<li>  加<strong>行独占写锁</strong>：<code>FOR UPDATE</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">-- 手动锁定某一行</span><br><span class="line">SELECT * FROM tb_stu WHERE id=5 FOR UPDATE;</span><br><span class="line">-- 在 SELECT xxx... FOR UPDATE 执行后到事务提交之前，其它线程对该条记录的写操作都会被阻塞！！</span><br><span class="line"></span><br><span class="line">-- 事务提交后会自动释放锁</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>





<h2 id="行锁基本操作演示"><a href="#行锁基本操作演示" class="headerlink" title="行锁基本操作演示"></a>行锁基本操作演示</h2><blockquote>
<p>  <strong>建表</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-- 建表</span><br><span class="line">CREATE TABLE tb_stu (</span><br><span class="line">    id INT(11),</span><br><span class="line">    age VARCHAR(16)</span><br><span class="line">)ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO tb_stu VALUES(1,&#x27;10&#x27;);</span><br><span class="line">INSERT INTO tb_stu VALUES(3,&#x27;30&#x27;);</span><br><span class="line">INSERT INTO tb_stu VALUES(4,&#x27;40&#x27;);</span><br><span class="line">INSERT INTO tb_stu VALUES(5,&#x27;50&#x27;);</span><br><span class="line">INSERT INTO tb_stu VALUES(6,&#x27;60&#x27;);</span><br><span class="line">INSERT INTO tb_stu VALUES(7,&#x27;70&#x27;);</span><br><span class="line">INSERT INTO tb_stu VALUES(8,&#x27;80&#x27;);</span><br><span class="line">INSERT INTO tb_stu VALUES(9,&#x27;90&#x27;);</span><br><span class="line"># 注意：这里没有插入 id=2 的数据！！！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 分别为 id 和 age 创建索引 </span><br><span class="line">CREATE INDEX a ON tb_stu(id);</span><br><span class="line">CREATE INDEX b ON tb_stu(age);</span><br><span class="line"></span><br><span class="line">-- 关闭 MySQL 的自动提交功能</span><br><span class="line">SET autocommit = 0;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>模拟两个线程同时操作 <code>tb_stu</code> 表数据。建立两个会话分别为 Session1 和  Session2。</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Session1</th>
<th align="center">Session2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>SET autocommit = 0</code></td>
<td align="center"><code>SET autocommit = 0</code></td>
</tr>
<tr>
<td align="center"><code>UPDATE tb_stu SET age=11 WHERE id=1;</code>【OK】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>SELECT * FROM tb_stu;</code>【查看后发现更新成功】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>SELECT * FROM tb_stu;</code>【未读到Session1未提交的事务】</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>UPDATE tb_stu SET age=19 WHERE id=1;</code>【写操作被阻塞】</td>
</tr>
<tr>
<td align="center"><code>COMMIT;</code>【Session1 提交事务】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">【阻塞解除，更新操作继续执行成功。此时，id=1对应的age=19】</td>
</tr>
</tbody></table>
<ol>
<li> 分别关掉 Session1 和 Session2 事务的自动提交行为；</li>
<li> 更新 <code>id=1</code> 的这一条记录，在 Session1 中更新成功，但在 Session2 中并未读取到 Session1 的更新。这是由于 MySQL 默认的隔离级别（可重复读）导致的。</li>
<li> 此时，如果在 Session2 中想要更新同一行数据，发现 Session 的操作被阻塞，这是因为 InnoDB 默认给每行数据加了行锁。</li>
<li> 使用 COMMIT 提交事务后，行锁也会被释放，这时 Session2 的更新操作得以继续执行。</li>
</ol>
<hr>
<h2 id="InnoDB-的行锁的实现原理"><a href="#InnoDB-的行锁的实现原理" class="headerlink" title="InnoDB 的行锁的实现原理"></a>InnoDB 的行锁的实现原理</h2><p><strong>InnoDB 是基于索引来完成行锁</strong>。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where id = 1 for update;	-- 为查询语句加了行级写锁</span><br></pre></td></tr></table></figure>

<p><code>for update</code> 可以根据条件来完成行锁锁定，并且 <code>id</code> 必须是有索引键的列，如果 <code>id</code> 不是索引键那么 InnoDB 将升级为表锁，并发将无从谈起。</p>
<hr>
<h2 id="索引失效行锁升级为表锁"><a href="#索引失效行锁升级为表锁" class="headerlink" title="索引失效行锁升级为表锁"></a>索引失效行锁升级为表锁</h2><p><strong>原理</strong></p>
<ul>
<li>  <strong>行锁必须依赖于索引才能实现，否则会自动升级为表锁。</strong>    </li>
<li>所以在 InnoDB 表中有两种情况会导致行锁升级为表锁：<ul>
<li>  一是条件字段压根没有建立索引；</li>
<li>  二是条件字段的索引在使用中失效了。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/23/MySQL%E7%B4%A2%E5%BC%95/">索引失效的常见场景</a></p>
</blockquote>
<p><strong>举例</strong></p>
<p>在 <code>tb_stu</code> 表中，<code>id</code> 为 <code>int</code> 类型，<code>age</code> 为 <code>varchar</code> 类型。并且为这两个字段分别创建了索引 <code>a</code> 和 <code>b</code>。如果我们在更新数据的过程中，不小心把 <code>varchar</code> 类型的数据写成了 <code>int</code> 类型的数据，这就会发生隐式的类型转换，虽然 <code>int</code> 类型也能被识别而不会报错，但是此时就破坏了索引 <code>b</code> 的结构，就会导致索引 <code>b</code> 失效。从而导致行锁会升级到表锁。</p>
<ol>
<li> 破坏索引结构</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># UPDATE tb_stu SET id=1 WHERE age=&#x27;19&#x27;; # 正确写法</span><br><span class="line">UPDATE tb_stu SET id=1 WHERE age=19;	# 这里故意写错，目的是为了破坏索引结构</span><br><span class="line"></span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 经过上面的操作后，<code>age</code> 对应的索引 <code>b</code> 的结构已经失效了，如果接下来还有以 age 为条件字段的操作，则行锁会升级为表锁。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">Session1</th>
<th align="center">Session2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>BEGIN;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>UPDATE tb_stu SET id=66 WHERE age=&#39;60&#39;;</code>【OK】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>UPDATE tb_stu SET id=77 WHERE age=70</code>【被阻塞】</td>
</tr>
<tr>
<td align="center"><code>COMMIT;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">【更新操作继续执行】</td>
</tr>
</tbody></table>
<p>Session1 设置为手动事务提交，Session2 设置为自动事务提交。</p>
<ol>
<li> Session1 开启事务，更新  <code>age=&#39;60&#39;</code> 的行记录，OK；</li>
<li> Session2 更新 <code>age=&#39;70&#39;</code> 的行记录，却发现被阻塞。但是明明 tb_stu 表使用的是行锁呀？这就是索引失效后行锁自动升级为表锁了。</li>
<li> Session1 提交后，释放表锁，Session2 得以继续进行，修改成功。</li>
</ol>
<hr>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p><strong>间隙锁案例：</strong></p>
<table>
<thead>
<tr>
<th align="center">Session1</th>
<th align="center">Session2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>SET autocommit = 0</code></td>
<td align="center"><code>SET autocommit = 0</code></td>
</tr>
<tr>
<td align="center"><code>UPDATE tb_stu SET age=99 WHERE id&gt;1 AND id&lt;6;</code><br>【更新 <code>1&lt;id&lt;6</code>的所有数据】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>SELECT * FROM tb_stu;</code>【查看后发现更新成功】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>INSERT INTO tb_stu VALUES(2,&quot;20&quot;);</code><br>【产生阻塞，插入操作无法执行完毕】</td>
</tr>
<tr>
<td align="center"><code>COMMIT;</code>【Session1 提交事务】</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">【阻塞解除，插入操作继续执行成功。id=2的数据被成功插入】</td>
</tr>
</tbody></table>
<ol>
<li><p> 分别关闭 Session1 和 Session2 的事务自动提交；</p>
</li>
<li><p> 更新 id 为 <code>(1, 6)</code> 范围内的所有数据，由于当前表中没有 id 为 2 的数据，所以就是更新 id 为 3，4，5 的数据，设置 age=99。</p>
</li>
<li><p>但是我们此时使用 Session2 想要插入一条 <code>id=2</code> 的数据，却发现被阻塞了。这时为什么呢？</p>
<p>  按理来说，行锁只会作用于当前行，在本例中也就是第 3、4、5 行，而 Session2 操作的明明是第 2 行，为什么也会被阻塞呢？这时因为此时 id=2 的那一行也被加了行锁，这就是所谓的<strong>间隙锁</strong>。 </p>
</li>
<li><p> 只有当 Session1 的事务提交后，所有作用于行上的锁被释放了，Session2 的插入操作才能继续完成。</p>
</li>
</ol>
<blockquote>
<p>  <strong>什么是间隙锁？</strong></p>
</blockquote>
<ul>
<li>  当我们使用范围条件而不是相等条件读/写数据，并请求共享/排它锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁，这是显然的；</li>
<li>  对于索引的键值在条件范围内但并不存在的记录，叫做“<strong>间隙（GAP）</strong>”。InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的<strong>间隙锁（Next-Key锁）</strong>。</li>
<li>  <strong>总结：</strong> <code>间隙锁 = 使用范围条件加锁 +检索的字段是一个索引</code></li>
</ul>
<blockquote>
<p>  <strong>间隙锁的危害</strong></p>
</blockquote>
<ul>
<li>  间隙锁有一个致命的弱点就是当锁定一个范围的键值之后，即使某些不存在的键值也会被无辜的锁定，从而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</li>
<li>  因为 Query 执行过程中通过范围查找的话，它会锁定整个范围内所有的索引键值，即使这个键值在索引表中并不存在。</li>
</ul>
<hr>
<h2 id="InnoDB-优缺点"><a href="#InnoDB-优缺点" class="headerlink" title="InnoDB 优缺点"></a>InnoDB 优缺点</h2><blockquote>
<p>  <strong>优点：</strong></p>
</blockquote>
<ul>
<li>  InnoDB 存储引擎实现了行锁，虽然在实现锁时损耗的性能比表锁高一些，但其并发处理的能力是远优于 MyISAM 的表锁的。</li>
<li>  当系统并发量较高时，InnoDB 的整体性能和 MyISAM 相比就会有比较明显的优势了。</li>
</ul>
<blockquote>
<p>  <strong>缺点：</strong></p>
</blockquote>
<ul>
<li>  但是，InnoDB 也有其脆弱的一面，当我们使用不当时（如索引失效导致行锁升级为表锁 ），可能会让 InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差。</li>
</ul>
<hr>
<h2 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h2><blockquote>
<p>  <strong>如何分析行锁？</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 展示行锁的各个状态量</span><br><span class="line">SHOW STATUS LIKE &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="MySQL%E9%94%81%E6%9C%BA%E5%88%B6/image-20210729091146048.png" alt="image-20210729091146048"></p>
<p>对各个状态量的说明如下：</p>
<ul>
<li>  <strong>InnoDB_row_lock_current_waits</strong>：当前正在等待锁的数量；</li>
<li>  <strong>InnoDB_row_lock_time</strong>：从系统启动到当前时间该行数据被锁定的总时间；【★】</li>
<li>  <strong>InnoDB_row_lock_time_avg</strong>：每次等待所花的平均时间；【★】</li>
<li>  <strong>InnoDB_row_lock_time_max</strong>：从系统启动到当前时间等待最长的一次所花的时间；</li>
<li>  <strong>InnoDB_row_lock_waits</strong>：系统启动到当前时间总共等待的次数；【★】</li>
</ul>
<p>对于这五个状态量，比较重要的有三个。尤其是当等待次数很高，而且等待平均时长也不小的时候，我们就需要分析系统中为什么会有 这么多等待，然后根据分析结果制定优化计划。</p>
<hr>
<h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><ul>
<li>  尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁；</li>
<li>  合理设计索引，尽量缩小锁的范围；</li>
<li>  尽可能缩小检索条件，避免频繁出现间隙锁 ；</li>
<li>  尽量控制事务大小，减少锁定资源量和时间长度；</li>
<li>  尽可能低级别事务隔离。</li>
</ul>
<hr>
<h1 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h1><ul>
<li>  页锁的开销和加锁时间介于表锁和行锁之间；</li>
<li>  会出现死锁；</li>
<li>  锁的粒度介于表锁和行锁之间；</li>
<li>  并发度一般。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/06/MySQL%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/06/MySQL%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">MySQL事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-10-06 12:48:49 / Modified: 14:21:01" itemprop="dateCreated datePublished" datetime="2021-10-06T12:48:49+08:00">2021-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1    什么是事务"></a>1    什么是事务</h1><p>事务是<strong>一组 SQL 语句组成的逻辑处理单元</strong>，事务具有 ACID 四个属性。</p>
<table>
<thead>
<tr>
<th align="center">事务特性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">原子性（Atomicity）</td>
<td align="center">每个事务都是一个不可再分的整体，事务中的SQL语句要么全部成功，要么全部失败</td>
</tr>
<tr>
<td align="center">一致性（Consistency）</td>
<td align="center">SQL语句执行前后数据库的状态保持一致。</td>
</tr>
<tr>
<td align="center">隔离性（Isolation）</td>
<td align="center">事务之间不应该互相影响。</td>
</tr>
<tr>
<td align="center">持久性（Durability）</td>
<td align="center">一旦事务执行成功，对数据库的修改是永久的。</td>
</tr>
</tbody></table>
<h1 id="2-MySQL-中事务提交的方式"><a href="#2-MySQL-中事务提交的方式" class="headerlink" title="2    MySQL 中事务提交的方式"></a>2    MySQL 中事务提交的方式</h1><ol>
<li> 手动提交事务</li>
<li> 自动提交事务</li>
</ol>
<h2 id="2-1-手动提交事务"><a href="#2-1-手动提交事务" class="headerlink" title="2.1    手动提交事务"></a>2.1    手动提交事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1、开启事务：</span><br><span class="line">start transaction</span><br><span class="line"># 2、提交事务：</span><br><span class="line">commit</span><br><span class="line"># 3、回滚事务：</span><br><span class="line">rollback</span><br></pre></td></tr></table></figure>





<h2 id="2-2-自动提交事务（默认）"><a href="#2-2-自动提交事务（默认）" class="headerlink" title="2.2    自动提交事务（默认）"></a>2.2    自动提交事务（默认）</h2><p>MySQL 默认每一条 DML（增删改）语句都是一个单独的事务，即每条语句执行前都会自动开启一个事务，语句执行完毕自动提交事务。</p>
<p><img src="MySQL%E4%BA%8B%E5%8A%A1/image-20201008173026672.png" alt="image-20201008173026672"></p>
<h3 id="2-2-1-取消自动提交事务"><a href="#2-2-1-取消自动提交事务" class="headerlink" title="2.2.1    取消自动提交事务"></a>2.2.1    取消自动提交事务</h3><ol>
<li><p>查看 MySQL是否开启自动提交事务</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select @@autocommit;</span><br><span class="line">-- @@ 表示全局变量</span><br><span class="line">-- 查询得到的结果为0或1，1表示已开启自动提交，0表示已关闭自动提交</span><br></pre></td></tr></table></figure></li>
<li><p>取消事务的自动提交</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @@autocommit=0;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="3-事务的实现原理"><a href="#3-事务的实现原理" class="headerlink" title="3    事务的实现原理"></a>3    事务的实现原理</h1><ul>
<li>  MySQL 的事务是基于<strong>重做日志文件（redo log）</strong>  和<strong>回滚日志（undo log）</strong>实现的。</li>
</ul>
<h2 id="3-1-undo-log"><a href="#3-1-undo-log" class="headerlink" title="3.1    undo log"></a>3.1    undo log</h2><ul>
<li>  <code>undo log</code> 用来回滚数据库状态到某个版本。</li>
<li>  <code>undo log</code> 指事务开始之前，在操作任何数据之前，首先将当前状态下的数据库数据进行一次备份。</li>
<li>  当事务执行失败需要回滚时，根据  <code>undo log</code> 日志文件进行数据恢复。</li>
</ul>
<p><img src="MySQL%E4%BA%8B%E5%8A%A1/image-20211006133130410.png" alt="image-20211006133130410"></p>
<h2 id="3-2-redo-log"><a href="#3-2-redo-log" class="headerlink" title="3.2    redo log"></a>3.2    redo log</h2><ul>
<li>  当对数据库中的数据进行修改时（数据存在磁盘中），需要把数据从磁盘中读取到内存中的缓冲池（BufferPool）中，然后在 BufferPool 中进行修改。</li>
<li>  那么这个时候 BufferPool 中的数据与磁盘中的数据就是不一致的，称 BufferPool 中的数据为“脏数据”。</li>
<li>  如果这个时候发生 DB 宕机，那么这些内存中的数据就会丢失，如果这时候能有一个文件，把 BufferPool 中对数据的修改记录保存到本地磁盘中，当 DB 发生意外宕机时，可以在重启后根据这个日志文件的记录进行数据恢复，这个文件就是 <strong>redo log</strong>。</li>
</ul>
<ul>
<li>  <code>redo log</code> 日志文件记录了事务中对任何数据执行写的操作，当事务执行成功时，日志文件会被提交到数据库服务器中去执行，其它任何情况都会清空事务日志（<code>rollback</code>）。</li>
<li>  <code>redo log</code> 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</li>
</ul>
<p><img src="MySQL%E4%BA%8B%E5%8A%A1/image-20211006133111921.png" alt="image-20211006133111921"></p>
<hr>
<h1 id="4-回滚点"><a href="#4-回滚点" class="headerlink" title="4    回滚点"></a>4    回滚点</h1><h2 id="4-1-什么是回滚点"><a href="#4-1-什么是回滚点" class="headerlink" title="4.1    什么是回滚点"></a>4.1    什么是回滚点</h2><p>在某些成功的操作完成之后，后续操作有可能成功也有可能失败，但是不管成功还是失败，前面的操作都已经成功了，可以在当前成功的位置设置一个回滚点。可以供后续失败操作回滚到该位置，而不是回滚全部操作，这个点称为回滚点。</p>
<p><strong>设置回滚点可以让SQL语句在执行失败的时候回退到回滚点，而不是回退到事务开启的时候</strong>。</p>
<h2 id="4-2-回滚点的操作语句"><a href="#4-2-回滚点的操作语句" class="headerlink" title="4.2    回滚点的操作语句"></a>4.2    回滚点的操作语句</h2><ul>
<li>  设置回滚点：<code>savepoint 名字</code></li>
<li>  回到回滚点：<code>rollback to 名字</code></li>
</ul>
<h1 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5    事务的隔离级别"></a>5    事务的隔离级别</h1><h2 id="5-1-并发访问引发的问题"><a href="#5-1-并发访问引发的问题" class="headerlink" title="5.1    并发访问引发的问题"></a>5.1    并发访问引发的问题</h2><p>多个用户同时访问同一数据时，可能会引发如下问题：</p>
<table>
<thead>
<tr>
<th align="center">并发访问引发的问题</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>脏读</strong></td>
<td align="left">一个事务读取到了另一个事务中尚未提交的数据。</td>
</tr>
<tr>
<td align="center"><strong>不可重复读</strong></td>
<td align="left">一个事务中两次读取的数据<strong>内容</strong>不一致。[这是<code>update</code>时引发的问题]【行层面】</td>
</tr>
<tr>
<td align="center"><strong>幻读</strong></td>
<td align="left">一个事务中两次读取的数据的<strong>数量</strong>不一致。[这是<code>insert</code>或<code>delete</code>时引发的问题]【表层面】</td>
</tr>
</tbody></table>
<ol>
<li>解决脏读的办法？<ul>
<li>  将全局事务隔离级别提升到<code>read uncomitted</code>以上。</li>
</ul>
</li>
<li>解决不可重复读问题的办法？<ul>
<li>  将全局事务隔离级别提升到<code>repeatable read</code>以上</li>
</ul>
</li>
<li>解决幻读问题的办法？<ul>
<li>  设置全局事务隔离级别为最高<code>serializable</code>。</li>
<li>  使用<code>serializable</code>隔离级别，一个事务没有执行完，其它事务的SQL语句就执行不了，可以挡住幻读，</li>
</ul>
</li>
</ol>
<h3 id="5-1-1-不可重复读-vs-幻读"><a href="#5-1-1-不可重复读-vs-幻读" class="headerlink" title="5.1.1    不可重复读 vs. 幻读"></a>5.1.1    不可重复读 vs. 幻读</h3><ol>
<li> <code>不可重复读</code>：在同样的条件下，你已经读取过的数据，再次读取时发现值不一样了。</li>
<li> <code>幻读</code>：比如，在一张表中，事务A第一次读取时读到了3条记录，然后事务B对该表中的记录进行了删除或增加。此时事务A使用相同的条件读取表时读到了5条记录，这叫做幻读。</li>
</ol>
<h2 id="5-2-MySQL的4种隔离级别"><a href="#5-2-MySQL的4种隔离级别" class="headerlink" title="5.2    MySQL的4种隔离级别"></a>5.2    MySQL的4种隔离级别</h2><ul>
<li>  ✔表示会出现这种问题，✖表示不会出现这种问题。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">名字</th>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
<th align="center">数据库默认隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">读未提交</td>
<td align="center"><code>read uncommitted</code></td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">读已提交</td>
<td align="center"><code>read committed</code></td>
<td align="center">✖</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">Oracle和SqlServer</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">可重复读</td>
<td align="center"><code>repeatable read</code></td>
<td align="center">✖</td>
<td align="center">✖</td>
<td align="center">✔</td>
<td align="center">MySql</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">串行化</td>
<td align="center"><code>serializable</code></td>
<td align="center">✖</td>
<td align="center">✖</td>
<td align="center">✖</td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>  隔离级别越高，安全性越高，性能越差。</li>
</ul>
<h2 id="5-3-MySql事务隔离级别相关的命令"><a href="#5-3-MySql事务隔离级别相关的命令" class="headerlink" title="5.3    MySql事务隔离级别相关的命令"></a>5.3    MySql事务隔离级别相关的命令</h2><ul>
<li><p>查询全局事务隔离级别</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure></li>
<li><p>设置全局事务隔离级别；（每次设置后需要退出 MySQL 再重新登录才能看到隔离级别的变化）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set global Transaction isolation level 级别字符串;</span><br><span class="line">-- 隔离级别：</span><br><span class="line">    -- read uncommitted</span><br><span class="line">    -- read committed</span><br><span class="line">    -- repeatable read</span><br><span class="line">    -- serializable</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式——观察者模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-27 15:01:13" itemprop="dateCreated datePublished" datetime="2021-09-27T15:01:13+08:00">2021-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-30 15:55:52" itemprop="dateModified" datetime="2021-10-30T15:55:52+08:00">2021-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>观察者模式；Observer Pattern</strong></p>
</blockquote>
<p><strong>概念</strong>：定义对象间的一种一对多依赖关系，使得每次当一个对象发生状态改变时，其所有<strong>依赖</strong>的对象都能得到通知并执行状态改变后的逻辑。</p>
<h1 id="观察者模式案例"><a href="#观察者模式案例" class="headerlink" title="观察者模式案例"></a>观察者模式案例</h1><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p><strong>天气预报项目需求：</strong></p>
<ol>
<li> 气象站实时将测量到的温度、天气、空气质量等数据以公告的形式发布出去，比如发布给第三方，如Sina、Baidu、Tencent等，对应的第三方在自己的平台上展示。</li>
<li> 需要设计开放型的 API，使得第三方平台能接入气象站获取数据。</li>
<li> 当气象站测量到的数据发生更新时，要能实时的通知给第三方。</li>
</ol>
<hr>
<h1 id="方案（观察者模式）"><a href="#方案（观察者模式）" class="headerlink" title="方案（观察者模式）"></a>方案（观察者模式）</h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>气象站发布数据，并将最新的数据同步到订阅了气象服务的多个第三方平台上，主要有两种解决思路：</p>
<ol>
<li><strong>push</strong>：<ul>
<li>  由气象站发起，当天气数据发生变换时将最新数据推送给所有订阅了天气服务的第三方平台。</li>
<li>  气象站使用一个 List 集合管理所有订阅天气服务的第三方平台，每当天气数据发生变化时，就遍历这个 List 将最新的数据推送给 List 中的每个第三方平台。</li>
</ul>
</li>
<li><strong>pull</strong>：<ul>
<li>  由第三方平台发起，每个第三方平台设置自己的定时器，定时拉取气象局提供的最新数据。</li>
</ul>
</li>
</ol>
<h2 id="推送思路的设计："><a href="#推送思路的设计：" class="headerlink" title="推送思路的设计："></a>推送思路的设计：</h2><ul>
<li>  <strong>核心接口1：Subject接口</strong>，该接口最少需要声明 ①用户（观察者）注册、②注销 ③以及当气象站数据发生变化时通知所有用户 三个核心功能，具体的实现逻辑由其子类实现。</li>
<li>  <strong>核心类1：</strong>该接口通过上述分析，我们可以初步设计一个 WeatherData 类来保存气象站测到的实时数据，该类需要实现 Subject 接口，并对外提供公共的 getXxx() 方法，第三方平台可以通过这些方法来获取相关天气信息。当气象台的数据发生变化时，气象站就会调用 <strong>setData()</strong> 方法去更新数据，并在该方法中继续调用 <strong>notifyAllObserver()</strong> 方法将最新的数据推送给所有订阅天气服务的观察者。</li>
<li>  <strong>核心接口2：Observer接口</strong>，该接口中定义一个 <strong>update()</strong> 方法，Subject 对象推送最新数据时会触发该方法，对第三方平台的数据进行更新，具体逻辑由其子类实现。</li>
<li>  <strong>核心类2：</strong>Sina、Tencent、Baidu 等第三方平台类，这些类必须实现 Observer 接口，在类中一般会有一个 <code>upodate()</code> 方法用于接收最新的实时数据，和一个 <code>show()</code> 方法用于数据的展示。</li>
</ul>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20211030114431359.png" alt="image-20211030114431359"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@startuml</span></span><br><span class="line"><span class="string">&#x27;https://plantuml.com/class-diagram</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Subject ..&gt; Observer</span></span><br><span class="line"><span class="string">Observer --o WeatherData</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">interface Subject</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    void registerObserver(Observer o)</span></span><br><span class="line"><span class="string">    void removeObserver()</span></span><br><span class="line"><span class="string">    void notifyAllObserver()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class WeatherData implements Subject</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    List&lt;Observer&gt; observerList</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Observer</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    void update()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Sina implements Observer</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Tencent implements Observer</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Baidu implements Observer</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@enduml</span></span><br></pre></td></tr></table></figure>







<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul>
<li>  Subject 接口</li>
<li>  WeatherData 类</li>
<li>  Observer 接口</li>
<li>  Sina/Tencent/Baidu 类</li>
</ul>
<h3 id="Subject-接口"><a href="#Subject-接口" class="headerlink" title="Subject 接口"></a>Subject 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/29 21:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * “一对多” 中的 “一”</span></span><br><span class="line"><span class="comment"> * 主要包括以下几种功能：</span></span><br><span class="line"><span class="comment"> *  1、注册观察者（新增）</span></span><br><span class="line"><span class="comment"> *  2、注册观察者（新增）</span></span><br><span class="line"><span class="comment"> *  3、“一”中的数据发生变化时向所有注册过的用户发送通知</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者（新增）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除某个观察者（删除）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心对象中的数据发生变化时向通知所有注册过的观察者</span></span><br><span class="line"><span class="comment">     *  Tip：根据不同的需求，</span></span><br><span class="line"><span class="comment">     *      ①可以是让观察者来拉取数据，</span></span><br><span class="line"><span class="comment">     *      ②也可以是实施推送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="WeatherData-类"><a href="#WeatherData-类" class="headerlink" title="WeatherData 类"></a>WeatherData 类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/29 21:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 保存气象台测量的实时天气数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String temperature; <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> String weather; <span class="comment">// 天气（晴/阴/雨）</span></span><br><span class="line">    <span class="keyword">private</span> String airQuality;  <span class="comment">// 空气质量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于维护观察者列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者 Observer（新增）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (observerList.contains(observer)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该观察者已存在&quot;</span>);</span><br><span class="line">        observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除某个观察者Observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!observerList.contains(observer)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该观察者不是一个合法的观察者&quot;</span>);</span><br><span class="line">        observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有订阅服务的观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observerList) &#123;</span><br><span class="line">            observer.update(<span class="built_in">this</span>.temperature, <span class="built_in">this</span>.weather, <span class="built_in">this</span>.airQuality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实时更新数据，并将实时数据推送给所有订阅了天气服务的第三方平台</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weather</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> airQuality</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(String temperature, String weather, String airQuality)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实时更新数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将实时数据通知到所有订阅天气服务的第三方平台</span></span><br><span class="line">        <span class="built_in">this</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Observer&gt; <span class="title function_">getObserverList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> observerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObserverList</span><span class="params">(List&lt;Observer&gt; observerList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observerList = observerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemperature</span><span class="params">(String temperature)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weather;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeather</span><span class="params">(String weather)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAirQuality</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> airQuality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAirQuality</span><span class="params">(String airQuality)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Observer-接口"><a href="#Observer-接口" class="headerlink" title="Observer 接口"></a>Observer 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/29 21:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有观察者的父接口（所有观察者都必须实现该接口）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String temperature, String weather, String airQuality)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Sina-Tencent-Baidu-类"><a href="#Sina-Tencent-Baidu-类" class="headerlink" title="Sina/Tencent/Baidu 类"></a>Sina/Tencent/Baidu 类</h3><p><strong>Sina</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/30 11:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sina</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String temperature;</span><br><span class="line">    <span class="keyword">private</span> String weather;</span><br><span class="line">    <span class="keyword">private</span> String airQuality;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法由气象站来调用，当气象站天气数据发生变化时，就会调用该方法推送最新的数据给第三方平台</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weather</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> airQuality</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String temperature, String weather, String airQuality)</span> &#123;</span><br><span class="line">        <span class="comment">// 同步气象站发布的实时天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据展示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新浪天气（温度）&quot;</span> + <span class="built_in">this</span>.temperature);</span><br><span class="line">        System.out.println(<span class="string">&quot;新浪天气（天气）&quot;</span> + <span class="built_in">this</span>.weather);</span><br><span class="line">        System.out.println(<span class="string">&quot;新浪天气（空气质量）&quot;</span> + <span class="built_in">this</span>.airQuality);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Tencent</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/30 11:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tencent</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String temperature;</span><br><span class="line">    <span class="keyword">private</span> String weather;</span><br><span class="line">    <span class="keyword">private</span> String airQuality;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法由气象站来调用，当气象站天气数据发生变化时，就会调用该方法推送最新的数据给第三方平台</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weather</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> airQuality</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String temperature, String weather, String airQuality)</span> &#123;</span><br><span class="line">        <span class="comment">// 同步气象站发布的实时天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据展示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;腾讯天气（温度）&quot;</span> + <span class="built_in">this</span>.temperature);</span><br><span class="line">        System.out.println(<span class="string">&quot;腾讯天气（天气）&quot;</span> + <span class="built_in">this</span>.weather);</span><br><span class="line">        System.out.println(<span class="string">&quot;腾讯天气（空气质量）&quot;</span> + <span class="built_in">this</span>.airQuality);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Baidu</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/30 11:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Baidu</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String temperature;</span><br><span class="line">    <span class="keyword">private</span> String weather;</span><br><span class="line">    <span class="keyword">private</span> String airQuality;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法由气象站来调用，当气象站天气数据发生变化时，就会调用该方法推送最新的数据给第三方平台</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weather</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> airQuality</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String temperature, String weather, String airQuality)</span> &#123;</span><br><span class="line">        <span class="comment">// 同步气象站发布的实时天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据展示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;百度天气（温度）&quot;</span> + <span class="built_in">this</span>.temperature);</span><br><span class="line">        System.out.println(<span class="string">&quot;百度天气（天气）&quot;</span> + <span class="built_in">this</span>.weather);</span><br><span class="line">        System.out.println(<span class="string">&quot;百度天气（空气质量）&quot;</span> + <span class="built_in">this</span>.airQuality);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/30 11:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三方平台订阅气象台的天气服务</span></span><br><span class="line">        <span class="type">Sina</span> <span class="variable">sina</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sina</span>();</span><br><span class="line">        <span class="type">Tencent</span> <span class="variable">tencent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tencent</span>();</span><br><span class="line">        <span class="type">Baidu</span> <span class="variable">baidu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Baidu</span>();</span><br><span class="line">        weatherData.registerObserver(sina);</span><br><span class="line">        weatherData.registerObserver(tencent);</span><br><span class="line">        weatherData.registerObserver(baidu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Subject 实时更新数据</span></span><br><span class="line">        <span class="comment">// setData方法底层会自动同步最新数据给所有订阅了天气服务的第三方平台</span></span><br><span class="line">        weatherData.setData(<span class="string">&quot;25℃&quot;</span>, <span class="string">&quot;晴&quot;</span>, <span class="string">&quot;良&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【测试】第三方平台展示数据测试</span></span><br><span class="line">        sina.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        tencent.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        baidu.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试结果展示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    新浪天气（温度）25℃</span></span><br><span class="line"><span class="comment">    新浪天气（天气）晴</span></span><br><span class="line"><span class="comment">    新浪天气（空气质量）良</span></span><br><span class="line"><span class="comment">    ===================</span></span><br><span class="line"><span class="comment">    腾讯天气（温度）25℃</span></span><br><span class="line"><span class="comment">    腾讯天气（天气）晴</span></span><br><span class="line"><span class="comment">    腾讯天气（空气质量）良</span></span><br><span class="line"><span class="comment">    ===================</span></span><br><span class="line"><span class="comment">    百度天气（温度）25℃</span></span><br><span class="line"><span class="comment">    百度天气（天气）晴</span></span><br><span class="line"><span class="comment">    百度天气（空气质量）良</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/22/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/22/HashMap/" class="post-title-link" itemprop="url">HashMap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-22 18:00:49" itemprop="dateCreated datePublished" datetime="2021-09-22T18:00:49+08:00">2021-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-26 15:59:41" itemprop="dateModified" datetime="2021-10-26T15:59:41+08:00">2021-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">集合</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>前置知识</strong></p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算基础</a></li>
</ul>
<hr>
<h1 id="HashMap-特点"><a href="#HashMap-特点" class="headerlink" title="HashMap 特点"></a>HashMap 特点</h1><p><strong>特点</strong></p>
<ol>
<li> 存取无序的；</li>
<li> 线程不安全；</li>
<li> key，value 都可以为 null</li>
</ol>
<p><strong>数据结构</strong></p>
<ul>
<li>  JDK8 之前，HashMap 是由 <strong>数组+链表</strong> 组成的，数组是 HashMap 的主体，链表则是为了解决哈希冲突而存在的。</li>
<li>  从 JDK8 开始，解决哈希冲突的策略由<strong>链表</strong>变为了<strong>链表+红黑树</strong>，当<strong>链表长度大于阈值（默认为8）并且当前数组长度大于64</strong>时，此时哈希桶上的所有数据改为用红黑树存储。</li>
</ul>
<blockquote>
<p>  补充：当链表长度长度大于阈值但是数组长度小于 64 时，此时并不会将链表变为红黑树，而是选择对数组进行扩容。</p>
</blockquote>
<ul>
<li>  当数组长度比较小时，在发生 Hash 冲突后应尽量避免使用红黑树结构，在这种情况下将链表变为红黑树结构，反而会降低效率，因为红黑树需要通过变色、左旋、右旋等操作来保持黑节点平衡。同时，当数组长度小于 64 时，搜索时间相对要快一些。当链表长度大于阈值并且数组长度大于 64 时，链表转换为红黑树，查找效率更高一些。</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote>
<ol>
<li> HashMap 底层数据结构为什么从链表转换为红黑树？</li>
</ol>
</blockquote>
<p>JDK8 之前 HashMap 的底层实现是 <code>数组+链表</code>，当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下就会有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 **O(n)**。</p>
<p>针对这种情况，JDK8 中引入了 红黑树来优化这个问题（红黑树中查找的时间复杂度为 **O(logn)**）。并且只有当链表长度达到 8 并且数组长度大于 64 时，才转换为红黑树。而当链表长度很小的时候，即使遍历整个链表速度也非常快，只有当链表长度大于一定阈值后，遍历查询的性能才会发生下降，这时候才需要通过将链表转换为红黑树来提高查询效率。</p>
<blockquote>
<ol start="2">
<li> 为什么链表转换为红黑树的阈值是8？</li>
</ol>
</blockquote>
<h1 id="HashMap-存储过程"><a href="#HashMap-存储过程" class="headerlink" title="HashMap 存储过程"></a>HashMap 存储过程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/13 19:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;海绵宝宝&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        map.put(<span class="string">&quot;派大星&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;蟹老板&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        map.put(<span class="string">&quot;章鱼哥&quot;</span>, <span class="number">35</span>);</span><br><span class="line">        map.put(<span class="string">&quot;海绵宝宝&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建 HashMap 对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>  执行 <code>new HashMap&lt;&gt;()</code> 语句，在 JDK8 之前是在底层创建了一个长度为 16 的一维数组 <strong>Entry[] table</strong>；</li>
<li>  但是从 JDK8 开始，并没有在执行 <code>new HashMap&lt;&gt;()</code> 语句时就创建数组对象，而是直接引用了一个类初始化阶段就已经创建好的空的 HashMap 对象，直到首次调用 <strong>put()</strong> 方法时，才会在底层创建长度为 16 的 <strong>Node[] table</strong> 数组对象。</li>
</ul>
</li>
<li><p>添加元素</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;海绵宝宝&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  向 <strong>table</strong> 数组中存储数据 <code>(&quot;海绵宝宝&quot;, 6)</code>，首先会调用 <code>String#hashCode()</code> 方法计算出 “海绵宝宝” 的 hashCode 值，此 hashCode 值经过某种算法计算后，得到该 Node 对象在 table 数组中存放的位置（即桶位置），如果此位置上数据为空，直接插入 Node 对象到数组中，添加元素成功。假设此时计算得到的桶位置下标为2。</li>
</ul>
</li>
<li><p>继续添加元素</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;派大星&quot;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  继续向 <strong>table</strong> 数组中添加数据 <code>map.put(&quot;派大星&quot;, 8)</code>，如果根据 “派大星” 的 hashCode 和当前数组长度计算出的桶位置也为 2，那么此时会继续比较 “海绵宝宝” 和 “派大星” 的 hashCode，如果不相等，会在该桶位置上新建一个链表节点来存储 Node 对象 <code>(&quot;派大星&quot;, 8)</code>。</li>
</ul>
</li>
<li><p>覆盖元素</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;海绵宝宝&quot;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>假设向 <strong>table</strong> 数组中存储数据 <code>(&quot;海绵宝宝&quot;, 8)</code>，根据 key 的 hashCode 和当前数组长度计算出的桶位置是 2，但是此时数组中下标 2 的位置上已经有了数据，接下来会比较后添加元素的 hashCode 和已存在元素的 hashCode 是否相等，如果相同，使用  <code>equals()</code> 方法继续比较后添加元素 key 与已存在元素的 key 是否相同。如果 <code>equals()</code> 方法返回 false，证明新添加的元素在 HashMap 中不存在，则向链表（或红黑树）中添加元素；如果 <code>equals()</code> 方法返回 true，则证明新添加的元素在 HashMap 中已存在，用后添加元素的 value 值覆盖已存在元素的 value 值。</li>
</ul>
</li>
</ol>
<p><img src="HashMap/image-20211025234552648.png" alt="image-20211025234552648"></p>
<p><strong>说明：</strong></p>
<ul>
<li>  size 表示 HashMap 中 Node 对象实时数量，如果添加元素后 Node 对象的个数大于 threshold，也会触发数组的扩容机制。</li>
<li>**threshold(临界值) = capacity(容量) × loadFactory(加载因子) **。这个值是当前已占用数组长度的最大值。size 超过这个值就会触发扩容（resize）机制，扩容后数组的长度变为原来的两倍。<ul>
<li>  HashMap 并不追求把整个 table 数组完全填满之后才进行扩容，因为这样可能会导致链表（或红黑树）上的 Node 对象很多，一般情况下只要数组中的元素个数大于 threshold，就可以认为数组中的使用率已经很高了，可以进行扩容了。如果一味地追求数组填满之后再进行扩容，可能存在剩下一到两个空位置始终没有元素填充进来，反而会有大量元素挂在了链表（或红黑树）后面，导致链表（或红黑树）中的节点变得非常多，反而会影响插叙效率。</li>
</ul>
</li>
</ul>
<h2 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote>
<ol>
<li> <strong>在 JDK8 中如何根据 hashCode 计算出 Node 要保存的桶位置（下标）？除了这个还有哪些实现方式？</strong></li>
</ol>
</blockquote>
<p>对 <code>Node&lt;K, V&gt;</code> 对象的 key 的 hashCode 做哈希操作：①无符号右移16位  ②异或运算</p>
<ul>
<li>  优点：效率高</li>
</ul>
<p><strong>其它实现方式：</strong></p>
<p>平方取中法、除留余数法、伪随机数法</p>
<p>其余三种方式效率较低，在 Java 中位运算的效率较高。</p>
<blockquote>
<ol start="2">
<li> 当两个对象的 hashCode 相等时会怎么样？</li>
</ol>
</blockquote>
<p>当两个对象的 hashCode 相等时，根据该 hashCode 计算出的哈希值也必然相同，那么显然会发生哈希碰撞；发生了哈希碰撞之后首先会比较两个 key 对象的 hashCode 是否相等，在本题中是显然的；当 hashCode 相等后，接着使用 <code>equals()</code> 方法比较两个 key 对象是否相等，若不相等则将新的 Node 对象添加到链表（或红黑树）上，若相等则用新的 Node 节点中的 value 去覆盖旧的 Node 节点中的 value 值。</p>
<ul>
<li>  在将 Node 添加到链表中时，如果满足条件还会发生链表到红黑树的转换。</li>
</ul>
<hr>
<h1 id="HashMap-源码"><a href="#HashMap-源码" class="headerlink" title="HashMap 源码"></a>HashMap 源码</h1><h2 id="HashMap-类中的成员"><a href="#HashMap-类中的成员" class="headerlink" title="HashMap 类中的成员"></a>HashMap 类中的成员</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ol>
<li><p>序列化版本号</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组的初始化容量（必须是 2 的 n 次幂）</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量是16（1&amp;lt;&amp;lt;4 == 16）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure></li>
<li><p>table 数组的最大容量</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>默认的负载因子，默认值是 0.75</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>链表转换为红黑树的门槛</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>当链表的值小于6则会从红黑树转回链表</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>桶中链表结构转化为红黑树对应的数组长度最小的值</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>table 用来初始化(必须是二的n次幂)(重点)</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li>
<li><p>用来存放缓存</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放具体元素的集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

</li>
<li><p>HashMap中存放元素的个数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放元素的个数，注意这个不等于数组的长度。size为HashMap中K-V的实时数量，不是数组table的长度。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

</li>
<li><p>用来记录HashMap的修改次数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br></pre></td></tr></table></figure>

</li>
<li><p>用来调整大小下一个容量的值计算方式为(容量*负载因子)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>哈希表的加载因子(重点)</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Q-amp-A-2"><a href="#Q-amp-A-2" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><blockquote>
<p>  <strong>Q1：HashMap 中 table 数组的初始容量为什么必须是 2 的 n 次幂？</strong></p>
<p>  <strong>Q2：如果输入值不是 2 的幂比如 10 会怎么样？</strong></p>
</blockquote>
<p><strong>A1：</strong></p>
<ul>
<li>  在向 HashMap 中添加一个元素的时候，需要根据 <code>Node&lt;K, V&gt;</code> 中 key 的 hashCode 计算一个 hash 值，来确定 Node 对象在数组中的具体位置。HashMap 为了存取高效，需要尽量减少哈希冲突，也就是要把数据尽量分配均匀，每个哈希桶上的元素数量要大致相同，这个实现依赖于具体的 Hash 算法。</li>
<li>  这个算法实际上就是取模，<code>hashCode%length</code>，只不过计算机中位运算的效率要远大于取余运算，所以在源码中做了一些优化，用位运算代替取余运算，而实际上 <code>hashCode%length</code> 可以等于 **hashCode&amp;(length-1)**，而等于的充要条件就是数组长度 length 必须是 2 的 n 次幂。</li>
</ul>
<p><strong>小结：</strong></p>
<ul>
<li>  我们在根据 key 的哈希值确定桶位置时，如果数组长度 length 为 2 的 n 次幂，可以保证数据较为均匀的插入，如果 length 不是 2 的 n 次幂，可能数组的一些位置永远不会插入数据，造成数据空间的浪费和加大哈希冲突的概率。</li>
<li>  另一方面，一般我们可能会想到通过取余操作 % 来确定位置，这样虽然也可以，只不过性能不如与（&amp;）运算。而且当 n = 2^n 时，<code>hashCode&amp;(length-1) == hashCode%length</code>。</li>
<li>  因此，HashMap 中 table 数组容量为 2 的 n 次幂的原因就是为了使数据能均匀分布，减少哈希碰撞。因为哈希碰撞发生的次数越多，代表数组中一个桶位置的元素数量越多，这样会减低 HashMap 的性能。</li>
</ul>
<p><strong>Q2：</strong></p>
<ul>
<li><p>  如果创建 HashMap 时，手动指定 table 数组的长度为 10，而不是 <code>2^n</code>，HashMap 会通过位移运算和或运算得到一个大于给定长度的最小的 <code>2^n</code> 的值。比如给定数组长度为 10，就会得到大于 10 的最小 <code>2^n</code> 的值 16，也就是说此时创建的 table 数组的长度是 16。</p>
</li>
<li><p>源码分析：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建长度为 10 的 HashMap</span></span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 跳转到：HashMap的单参构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);	<span class="comment">// DEFAULT_LOAD_FACTOR 是默认加载因子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 跳转到：HashMap的双参构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// 若给定初始化容量小于0直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 若给定容量大于MAXIMUM_CAPACITY按MAXIMUM_CAPACITY处理</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 加载因子校验</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);	<span class="comment">// 计算table数组的容量，并赋值给threshold</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 跳转到：tableSizeFor 方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的初始值计算出数组容量，数组容量必然是2^n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>说明：</strong>根据源码可以看到，当在实例化 HashMap 时，如果给定了 initialCapacity（假设是10），最终会调用 <strong>tableSizeFor(int cap)</strong> 方法来计算 table 数组的真实容量，最终得到的结果是一个大于 10 的最小的 <code>2^n</code> 的值，在这里也就是 16。下面来分析这个算法：</p>
<ol>
<li><p>首先，对 cap 进行 -1 操作，<code>int n = cap - 1</code></p>
<blockquote>
<p>  为什么要对 cap 进行 -1 操作？</p>
</blockquote>
<p> 这是为了防止，cap 已经是 <code>2^n</code>。如果 cap 已经是 <code>2^n</code>，理论上此时数组的容量就应该是 cap，但是如果没有对 cap 进行 -1 操作，直接使用无符号右移运算，则最终得到的 cap 的容量是 <code>cap*2</code>，显然是不符合要求的；而如果执行了 -1 操作，那么最终得到的容量就是 cap，符合要求。</p>
</li>
<li><p> 如果 n 经过 cap-1 后结果是 0，则经过几次无符号右移后最终结果仍是 0，最后返回的 capacity 是 1。</p>
</li>
<li><p>当 cap = 10时，n=9</p>
<ul>
<li><p>第一次右移</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>	<span class="comment">// ①先进行右移运算 ②再进行或运算</span></span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span>	 	<span class="comment">// 9</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 无符号右移一位 ==&gt; 4</span></span><br><span class="line">------------------------------------------	</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>		<span class="comment">// 进行或运算 9|4 ==&gt; 13</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>第二次右移：n=13</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>	</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>	 	<span class="comment">// 13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 无符号右移2位 ==&gt; 3</span></span><br><span class="line">------------------------------------------	</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span>		<span class="comment">// 进行或运算 13|3 ==&gt; 15</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>第三次右移：n=15</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;	<span class="comment">// n=15</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span>		<span class="comment">// 15</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>		<span class="comment">// 无符号右移4位 ==&gt; 0</span></span><br><span class="line">------------------------------------------	</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span>		<span class="comment">// 进行或运算 15|3 ==&gt; 15</span></span><br></pre></td></tr></table></figure></li>
<li><p>第四次右移、第五次右移</p>
<p>  当 n 被扩展到 <code>2^n-1</code> 时，再进行右移运算也不会改变 n 的值，最终返回 capacity 容量时，用 n+1 就能得到 <code>2^n</code>。</p>
<p>  <img src="HashMap/image-20211026102557636.png" alt="image-20211026102557636"></p>
</li>
</ul>
</li>
<li><p>注意：得到的这个 capacity 最终被赋值给了 threshold</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<blockquote>
<p>  <strong>Q3：为什么 Map 桶中节点个数超过8才转为红黑树？</strong></p>
</blockquote>
<ol>
<li><p> <strong>从空间上考虑</strong>。因为树的节点大约是链表节点的两倍，所以我们只有在哈希桶中包含足够的节点时才会使用树节点。</p>
</li>
<li><p>并且当 hashCode 的离散性很好的时候，红黑树模型使用到的概率非常小，因为数据均匀分布在每个 Bucket 中，很少有 Bucket 中链表的长度会达到阈值。但是在随机 hashCode 的情况下，离散型就可能会变差，然而 JDK 又不能阻止用户实现这种不好的哈希算法，因此就可能导致不均匀的数据分布。不过理想情况下随机 hashCode 算法下的所有 Bucket 中的节点分布频率都会遵循泊松分布，我们可以看到，一个Bucket 中链表长度达到 8 个元素的概率为 0.00000006，几乎是不可能事件，所以，之所以选择 8 是由概率学决定的</p>
<blockquote>
<p>  泊松分布</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: 0.60653066</span><br><span class="line">1: 0.30326533</span><br><span class="line">2: 0.07581633</span><br><span class="line">3: 0.01263606</span><br><span class="line">4: 0.00157952</span><br><span class="line">5: 0.00015795</span><br><span class="line">6: 0.00001316</span><br><span class="line">7: 0.00000094</span><br><span class="line">8: 0.00000006</span><br></pre></td></tr></table></figure>

</li>
<li></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 数组的默认容量 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 数组的最大容量 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 加载因子*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** HashMap 中的数组 */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">     * for keySet() and values().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** HashMap 中节点元素的个数*/</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 阈值 */</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用：用传入的值对 HashMap 中的值进行赋值操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity	数组容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor	加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【校验】</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity); <span class="comment">// 数组容量小于 0 抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY; <span class="comment">// 数组容量大于 MAXIMUM_CAPACITY 也抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) <span class="comment">// 要求加载因子必须小于0 或者必须是数字</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/17/LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/17/LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/" class="post-title-link" itemprop="url">LeetCode_198_打家劫舍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-17 11:52:24 / Modified: 12:39:29" itemprop="dateCreated datePublished" datetime="2021-09-17T11:52:24+08:00">2021-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h4><p>  难度中等1650</p>
</li>
</ul>
<ul>
<li><p>  LeetCode链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></p>
</li>
<li><p>  LeetCode链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></p>
</li>
<li><p>LeetCode链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></p>
</li>
</ul>
<h2 id="198-打家劫舍-1"><a href="#198-打家劫舍-1" class="headerlink" title="198    打家劫舍"></a>198    打家劫舍</h2><blockquote>
<p>  <strong>题解</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/17 11:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 198. 打家劫舍</span></span><br><span class="line"><span class="comment"> *  输入：[1,2,3,1]</span></span><br><span class="line"><span class="comment"> *  输出：4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution198</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution198</span> <span class="variable">solution198</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution198</span>();</span><br><span class="line"><span class="comment">//        int[] nums = &#123;1, 2, 3, 1&#125;;</span></span><br><span class="line"><span class="comment">//        int[] nums = &#123;2,7,9,3,1&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rob</span> <span class="operator">=</span> solution198.rob(nums);</span><br><span class="line">        System.out.println(rob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == nums || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能闯入相邻的房屋</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]); <span class="comment">// 这行代码用到了nums[1]，所以在这之前必须保证nums数组中至少要有两个元素，否则会下标越界</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dp[i] 等于 Max(dp[i-1]， dp[i-2]+nums[i])</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213    打家劫舍 II"></a>213    打家劫舍 II</h2><blockquote>
<p>  <strong>题解</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/17 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 213. 打家劫舍 II</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution213</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution213</span> <span class="variable">solution213</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution213</span>();</span><br><span class="line"><span class="comment">//        int[] nums = &#123;2, 3, 2&#125;;</span></span><br><span class="line"><span class="comment">//        int[] nums = &#123;1,2,3,1&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rob</span> <span class="operator">=</span> solution213.rob(nums);</span><br><span class="line">        System.out.println(rob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本思路与 【198打家劫舍】 一致，只是相邻的条件发生了改变：</span></span><br><span class="line"><span class="comment">     *  在 1代版本中，是一个普通数组，</span></span><br><span class="line"><span class="comment">     *  而在 2 代版本中，变成了一个环形数组，即 第一个与最后一个是相邻的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以我们需要增加判断条件:</span></span><br><span class="line"><span class="comment">     *   环状排列意味着：第一个房子和最后一个房子只能选择一个偷窃，因此我们可以把环状排列的房间简化成两个单排列房间的子问题</span></span><br><span class="line"><span class="comment">     *   1、在不偷窃第一个房子的情况下能够获得的最大金额</span></span><br><span class="line"><span class="comment">     *   2、在不偷窃最后一个房子的情况下能够获得的最大金额</span></span><br><span class="line"><span class="comment">     *   3、比较得到两个金额中较大的金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == nums || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规情况</span></span><br><span class="line">        <span class="type">int</span>[] ignoreFirst = Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length);</span><br><span class="line">        <span class="type">int</span>[] ignoreLast = Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 不偷第一个房子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> subRob(ignoreFirst);</span><br><span class="line">        <span class="comment">// 不偷最后一个房子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> subRob(ignoreLast);</span><br><span class="line">        <span class="keyword">return</span> m&gt;n?m:n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subRob</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == nums || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规情况</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337    打家劫舍 III"></a>337    打家劫舍 III</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/17/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/17/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/" class="post-title-link" itemprop="url">LeetCode_42_接雨水</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-17 11:24:58 / Modified: 11:35:48" itemprop="dateCreated datePublished" datetime="2021-09-17T11:24:58+08:00">2021-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>  题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></li>
<li>  大佬视频讲解地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HE411Z7By">https://www.bilibili.com/video/BV1HE411Z7By</a></li>
</ul>
<blockquote>
<p>  <strong>题解</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/17 10:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 42. 接雨水</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution42</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution42</span> <span class="variable">solution42</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution42</span>();</span><br><span class="line"><span class="comment">//        int[] height = &#123;0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] height = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> solution42.trap(height);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 接雨水问题 类似于 木桶效应问题</span></span><br><span class="line"><span class="comment">        * 但是 “木桶效应” 只有一个桶，但是接雨水问题在大部分的情况下都有大于两个桶，即：以最高点为分界线，向左是一个桶，向右也是一个桶</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路：</span></span><br><span class="line"><span class="comment">         *  ① 找出最高点</span></span><br><span class="line"><span class="comment">         *  ② 分别从左右两边往最高点遍历，如果下一个数比当前数小，说明可以接到雨水。</span></span><br><span class="line"><span class="comment">         *  【因为最高点一定是最高的，而下一个数比当前数小则说明存在一个边界值可以作为木桶的另一个边界】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;   <span class="comment">// 最高点值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// 最高点下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前遇到的短板的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前遇到的短板的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、先找到最高点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = height[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理左半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left+<span class="number">1</span> &lt; maxIndex; left++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt; leftMax) leftMax = height[left];</span><br><span class="line">            <span class="comment">// 如果下一个数比当前数小，说明可以接到雨水，接到雨水的量由木桶效应的短板决定</span></span><br><span class="line">            <span class="keyword">if</span> (height[left+<span class="number">1</span>] &lt; leftMax)</span><br><span class="line">            &#123;</span><br><span class="line">                result = result + (leftMax-height[left+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果下一个数大于等于当前数，说明接不到雨水，指针向前走</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理右半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length-<span class="number">1</span>; right-<span class="number">1</span> &gt; maxIndex; right--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt; rightMax) rightMax = height[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果下一个数比当前数小，说明可以接到雨水，接到雨水的量由木桶效应的短板决定</span></span><br><span class="line">            <span class="keyword">if</span> (height[right-<span class="number">1</span>] &lt; rightMax)</span><br><span class="line">            &#123;</span><br><span class="line">                result = result + (rightMax-height[right-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果下一个数大于等于当前数，说明接不到雨水，指针向前走</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/14/synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/14/synchronized/" class="post-title-link" itemprop="url">synchronized</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-14 10:24:47 / Modified: 14:19:29" itemprop="dateCreated datePublished" datetime="2021-09-14T10:24:47+08:00">2021-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-synchronized-的底层实现原理"><a href="#1-synchronized-的底层实现原理" class="headerlink" title="1    synchronized 的底层实现原理"></a>1    synchronized 的底层实现原理</h1><blockquote>
<p>  monitor；监听器</p>
</blockquote>
<p><strong>synchronized 同步代码块</strong></p>
<ul>
<li>  synchronized <strong>同步代码块</strong>是通过 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令来实现的，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指向同步代码块的结束位置。</li>
<li>  当某个线程执行 monitorenter 指令时，线程就会去尝试获取锁对象对象头中的监听器 monitor 的持有权。（monitor 监听器存在于每个 Java 对象的对象头中，这也是为什么Java中任意对象可以作为锁的原因）</li>
<li>  监听器 monitor 其内部包含一个计数器，当计数器为 0 则可以成功获取，获取后将锁计数器 +1，相应的在执行 monitorexit 指令后，将锁计数器值 -1，表明锁被释放。</li>
<li>  如果线程获取对象锁失败，那么当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</li>
</ul>
<p><strong>synchronized 同步方法</strong></p>
<ul>
<li>  synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取而代之的是 <strong>ACC_SYNCHRONIZED</strong> 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来判断一个方法是否声明为同步方法，从而执行相应的同步调用。</li>
</ul>
<h1 id="2-synchronized-锁升级"><a href="#2-synchronized-锁升级" class="headerlink" title="2    synchronized 锁升级"></a>2    synchronized 锁升级</h1><blockquote>
<p>  <strong>无锁 | 偏向锁 | 轻量级锁 | 重量级锁</strong></p>
</blockquote>
<ul>
<li>  通过 synchronized 关键字加的锁会随着线程争用数量的变化锁状态也发生变化，其锁升级的过程为：<code>无锁 --&gt; 偏向锁 --&gt; 轻量级锁 --&gt; 重量级锁</code>。</li>
<li>  <strong>锁的升级的目的</strong>：为了提升性能、减少 synchronized 获得锁和释放锁所带来的消耗，在 Java6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。引入了 4 种<strong>锁状态</strong>：</li>
<li>  <strong>锁状态是一把锁在不同时刻的状态，本质上锁对象还是这个锁对象，只不过锁对象的状态发生了变换。</strong></li>
</ul>
<p><img src="synchronized/20190415101813830.png" alt="20190415101813830"></p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><ul>
<li>  无锁状态是锁对象初始化后的第一个状态，表示当前锁对象没有被任何线程持有过。</li>
<li>  无锁状态就是将锁对象对象头中 MarkWord 的标志位设置为 <strong>001</strong>。</li>
</ul>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><ul>
<li><p>  <strong>功能：减少同一线程获取锁的代价。</strong></p>
</li>
<li><p>  <strong>概念</strong>：偏向锁(Biased Locking) 是指它会偏向于第一个访问锁的线程。如果在运行过程中，只有一个线程来获取这个锁对象，不存在多线程竞争的情况，那么此时的锁对象是一个偏向锁对象。</p>
</li>
<li><p>  <strong>核心思想</strong>：如果一个线程获得了锁，那么锁就进入<strong>可偏向状态</strong>，当该线程再次请求获取锁时，只需要检查：① 锁对象的对象头中的 MarkWord 锁标志位是偏向锁，② 并且锁对象的对象头中的 MarkWord 中的 ThreadID 等于当前线程 ID 即可。这样就省去了大量有关锁申请的操作。</p>
</li>
<li><p><strong>解释说明：</strong></p>
<ol>
<li><p>偏向锁的实现是通过控制对象象对象头中的 <strong>Mark Word</strong> 中的标志位来实现的。在 MarkWord 中，有两个重要的参数：</p>
<p> ① 锁标志位</p>
<p> ② 偏向锁线程 ID</p>
</li>
<li><p> 如果一个锁对象第一次被线程 A 访问（线程 A 的线程 ID 是 <code>xxx001</code>），那么这个锁对象的 MarkWord 中就会记录锁标志位为 <strong>101</strong>，表示当前锁状态为可偏向，并且记录线程A 的线程 ID 到 MarkWord 中。</p>
</li>
<li><p> 线程 A 释放锁之后，若线程 A 想要再次获取这个锁对象，假设在线程 A 释放锁的这段时间内没有其它线程获取过这个锁对象，那么锁对象 MarkWord 中的锁标志位还是 101（可偏向），记录的线程 ID 还是 <code>xxx001</code>（线程A的线程ID）。此时，线程 A 获取锁对象的过程非常简单，① 先比较锁标志位是否为 101，② 如果是的话，再比较锁对象MarkWord 中记录的线程ID 是否与当前线程ID 相同，若相同则直接获取锁对象。</p>
</li>
<li><p> 如果在线程 A 释放锁之后，另外有一个线程 B 尝试获取锁对象，①首先比较锁标志位为101，②接着会比较锁对象中储存的线程ID是否为当前线程，发现不是（锁对象中存储的线程ID应该是线程A的线程ID），这时候锁的偏向状态就会被破坏，从而升级到轻量级锁。</p>
</li>
</ol>
</li>
</ul>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><ul>
<li>  轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。</li>
<li>  <strong>轻量级锁的下限</strong>：只要存在第二个线程申请锁，哪怕这个线程没有和之前持有锁的线程产生竞争关系，属于一前一后地交替执行，这时候锁状态也会从偏向锁升级到轻量级锁。</li>
<li>  <strong>轻量级锁的上限</strong>：如果存在第二个线程申请锁，并且这个线程和第一个线程产生了竞争关系，如果在自旋次数的指定范围内能够获取到锁，那么此时锁对象的状态仍然是轻量级锁，只有当自旋的次数超出了指定范围之后，轻量级锁才会升级到重量级锁。</li>
<li>  轻量级锁状态下，认为虽然虽然竞争是存在的，但是理想情况下竞争的程度很低，通过 <strong>自旋方式</strong> 等待上一个线程释放锁。</li>
<li>借用上面的例子就是：<ol>
<li> 线程 A 先持有锁对象，将锁对象打上了自己的标记，但是线程 A 又释放了锁对象，这时线程 B 尝试占有锁对象，由于线程 A 此时并没有占有锁对象，所以线程 B 是可以抢到锁对象的，但是即便线程 B 抢到了锁对象，锁对象的状态也会从偏向锁升级到轻量级锁。</li>
<li> 同样，线程A先持有锁对象，此时线程B同时也在尝试获取锁对象，发现锁对象被持有，就先通过自旋的方式等待，如果在很短的时间内，线程A释放了锁对象，线程B成功获取到了锁对象，那么此时锁对象的状态仍然会是轻量级锁。如果线程B自旋的时间超过了一定范围仍没有获取到锁对象，那么锁对象的状态就会升级到重量级锁。</li>
</ol>
</li>
</ul>
<h3 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h3><ul>
<li>  轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</li>
<li>  <strong>自旋锁</strong>：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，就可以通过让线程执行循环来等待锁的释放，而不让出 CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，这时才会将线程在操作系统层面挂起，这就是自旋锁的优化方式。</li>
<li>  但是它也存在<strong>缺点</strong>：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。</li>
<li>  <strong>自适应自旋锁</strong>：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</li>
</ul>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><ul>
<li>  重量级锁可以由轻量级锁升级而来。</li>
<li>  重量级锁的<strong>核心思想</strong>是：当<strong>同一时间</strong>有多个线程竞争锁时，并且未持有锁的线程的最大自旋次数超过指定范围后，锁就会被升级成重量级锁，此时申请锁带来的开销也就变大。</li>
<li>  重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。</li>
</ul>
<h2 id="为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？"><a href="#为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？" class="headerlink" title="为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？"></a>为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？</h2><ul>
<li>  重量级锁底层依赖于系统的同步函数来实现，这些底层的同步函数操作会涉及到：操作系统用户态和内核态的切换、进程的上下文切换，而这些操作都是比较耗时的，因此重量级锁操作的开销比较大。</li>
<li>  然而在很多情况下，可能获取锁时只有一个线程，或者是多个线程交替获取锁，在这种情况下，使用重量级锁就不划算了，因此引入了偏向锁和轻量级锁来降低没有并发竞争时的锁开销。</li>
</ul>
<p>​        </p>
<h1 id="3-JVM-对-synchronized的优化有哪些？"><a href="#3-JVM-对-synchronized的优化有哪些？" class="headerlink" title="3    JVM 对 synchronized的优化有哪些？"></a>3    JVM 对 synchronized的优化有哪些？</h1><blockquote>
<ol>
<li> <strong>锁升级</strong>（见上一章）</li>
<li> <strong>锁粗化</strong></li>
<li> <strong>锁消除</strong></li>
<li> <strong>自旋锁与自适应自旋锁</strong>（见上一章）</li>
</ol>
</blockquote>
<ul>
<li>  <strong>锁升级、锁粗化 和 锁消除</strong> 都是由 JVM 虚拟机在底层帮我们优化的。</li>
</ul>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p><strong>锁粗化</strong> 就是将多个同步块的数量减少，并将单个同步块的作用范围扩大，本质上就是将多次上锁、解锁的请求合并为一次同步请求。</p>
<blockquote>
<ol>
<li> 举个例子，一个循环体中有一个代码同步块，每次循环都会执行加锁解锁操作。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(LOCK)&#123;</span><br><span class="line">        <span class="comment">// do some things</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li> 经过<code>锁粗化</code>后就变成下面这个样子了：</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">synchronized</span>(LOCK)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// do some things</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p><strong>锁消除</strong> 是指虚拟机编译器如果在运行时检测到了多个线程间的共享数据不会产生竞争关系，就会将加在共享数据上的锁进行消除。</p>
<blockquote>
<p>  举个例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    stringBuffer.append(s1);</span><br><span class="line">    stringBuffer.append(s2);</span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>test()</code> 主要用于是将字符串 s1 和字符串 s2 拼接起来。</li>
<li>  方法中的三个变量 <code>s1、s2、stringBuffer</code> 都是局部变量，保存在栈上。栈是线程私有的，所以就算有多个线程访问 <code>test()</code> 方法也是线程安全的。</li>
<li>  我们都知道 StringBuffer 是线程安全的，<code>append()</code> 方法是同步方法（被 synchronized 修饰），但是 <code>test()</code> 方法本来就是线程安全的，为了提升效率，虚拟机就会帮我们消除 <code>append()</code> 方法上的同步锁，这个过程就被称为<strong>锁消除</strong>。</li>
</ul>
<hr>
<h1 id="4-synchronized-锁降级"><a href="#4-synchronized-锁降级" class="headerlink" title="4    synchronized 锁降级"></a>4    synchronized 锁降级</h1><ul>
<li>  synchronized 锁是允许降级的。</li>
<li><strong>触发时机</strong>：在全局安全点（safepoint）中，执行清理任务的时候会触发尝试降级锁。当锁降级时，主要进行了以下操作：<ol>
<li> 恢复锁对象的 markword 对象头；</li>
<li> 重置 ObjectMonitor，然后将该 ObjectMonitor 放入全局空闲列表，等待后续使用。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="5-synchronized的用法有哪些"><a href="#5-synchronized的用法有哪些" class="headerlink" title="5    synchronized的用法有哪些?"></a>5    synchronized的用法有哪些?</h1><ul>
<li>  修饰普通方法：作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</li>
<li>  修饰静态方法:作用于当前类，进入同步代码前要获得当前类对象的锁,synchronized 关键字加到</li>
<li>  修饰代码块:指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>  static 静态方法和 <code>synchronized(xxx.class)</code> 代码块上都是是给 Class 类上锁</li>
<li>  如果一个线程A调用一个实例对象的非静态的 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的是当前对象的对象锁。</li>
<li>  尽量不要使用 <code>synchronized(String s)</code> ，因为 JVM 中，字符串常量池具有缓冲功能。</li>
</ul>
<hr>
<h1 id="6-synchronized的作用有哪些？"><a href="#6-synchronized的作用有哪些？" class="headerlink" title="6    synchronized的作用有哪些？"></a>6    synchronized的作用有哪些？</h1><ol>
<li><strong>原子性</strong>：确保多个线程互斥的访问同步代码；</li>
<li><strong>可见性</strong>：保证共享变量的修改能够及时可见，其实是通过 JMM 中的 “<strong>对一个变量 unlock 操作之前，必须要同步到主内存中；如果对一个变量进行 lock 操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中 load 操作或 assign 操作初始化变量值</strong>” 来保证的；</li>
<li><strong>有序性</strong>：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的 lock 操作”。</li>
</ol>
<h1 id="7-synchronized-的非公平体现在哪些地方？"><a href="#7-synchronized-的非公平体现在哪些地方？" class="headerlink" title="7    synchronized 的非公平体现在哪些地方？"></a>7    synchronized 的非公平体现在哪些地方？</h1><p>当持有锁的线程释放锁时，该线程会执行以下两个重要操作：</p>
<ol>
<li><p>先将锁的持有者 owner 属性赋值为 null</p>
</li>
<li><p>唤醒等待队列中的一个线程：</p>
</li>
</ol>
<p>  ① 在线程 A 和线程 B 之间，如果有其他线程刚好在尝试获取锁（例如自旋），则可以马上获取到锁。</p>
<p>  ② 随机唤醒。当线程尝试获取锁失败，进入阻塞时，加入队列的顺序，和最终被唤醒的顺序是不一致的，也就是说你先进入队列，不代表你就会先被唤醒。</p>
<hr>
<h1 id="8-synchronized-和-ReentrantLock-区别是什么？"><a href="#8-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="8    synchronized 和 ReentrantLock 区别是什么？"></a>8    synchronized 和 ReentrantLock 区别是什么？</h1><blockquote>
<ol>
<li> <strong>两者都是可重入锁</strong></li>
</ol>
</blockquote>
<p>可重入锁指的是在一个线程中可以多次获取同一把锁，比如：一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁，两者都是同一个线程每进入一次，锁的计数器都自增1，在释放锁的时候需要等到锁的计数器下降为 0 时才能释放锁。</p>
<blockquote>
<ol start="2">
<li> <strong>synchronized 是在 JVM 层面实现的，而 ReentrantLock 是在 API 层面实现的</strong></li>
</ol>
</blockquote>
<ul>
<li>  synchronized 是在 JVM 层面实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的</li>
<li>  ReentrantLock 是在 API 层面实现的，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong></li>
</ol>
</blockquote>
<p>相比 synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：</p>
<ol>
<li> <strong>等待可中断</strong>；通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，从等待队列中出队（AQS 中的 waitStatus 状态码发生改变），改为处理其他事情。</li>
<li> <strong>可实现公平锁</strong>；ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。</li>
<li> <strong>可实现定点通知</strong>：ReentrantLock 类线程对象可以注册在指定的 Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 <code>notify()/notifyAll()</code> 方法进行通知时，被通知的线程是由 JVM 随机选择的，而使用 ReentrantLock 类结 Condition 实例可以实现“定点通知”。</li>
</ol>
<blockquote>
<ol start="4">
<li> <strong>使用选择</strong></li>
</ol>
</blockquote>
<ul>
<li>  除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。</li>
<li>  synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</li>
</ul>
<hr>
<h1 id="9-synchronized-和-Lock-有什么区别？"><a href="#9-synchronized-和-Lock-有什么区别？" class="headerlink" title="9    synchronized 和 Lock 有什么区别？"></a>9    synchronized 和 Lock 有什么区别？</h1><ul>
<li>  synchronized 可以给 <strong>方法和代码块</strong> 加锁；而 lock 只能给<strong>代码块</strong>加锁。</li>
<li>  synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock() 去释放锁就会造成死锁。</li>
<li>  通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ul>
<hr>
<h1 id="10-synchronized-和-volatile-的区别是什么？"><a href="#10-synchronized-和-volatile-的区别是什么？" class="headerlink" title="10    synchronized 和 volatile 的区别是什么？"></a>10    synchronized 和 volatile 的区别是什么？</h1><ol>
<li> volatile 本质是在告诉 JVM 当前变量在工作内存中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li> volatile 仅能使用在变量级别；synchronized 则可以使用在变量和方法级别的</li>
<li> volatile 仅能实现变量的修改可见性，不能保证原子性；而synchronized 则可以 保证变量的修改可见性和原子性</li>
<li> volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li> volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/06/AQS/" class="post-title-link" itemprop="url">AQS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-06 17:27:18" itemprop="dateCreated datePublished" datetime="2021-09-06T17:27:18+08:00">2021-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-08 22:02:01" itemprop="dateModified" datetime="2021-10-08T22:02:01+08:00">2021-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<ul>
<li>  AQS简介</li>
<li>  AQS数据结构</li>
<li>  资源共享模式</li>
<li>  AQS 源码分析</li>
<li>  释放资源</li>
</ul>
</blockquote>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><blockquote>
<ol>
<li> 公平锁和非公平锁</li>
<li> 可重入锁</li>
<li> LockSupport</li>
<li> 自旋锁</li>
<li> 数据结构链表</li>
<li> 设计模式——模板设计模式</li>
</ol>
</blockquote>
<hr>
<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="1-为什么学"><a href="#1-为什么学" class="headerlink" title="1    为什么学"></a>1    为什么学</h2><h3 id="1-1-重要性"><a href="#1-1-重要性" class="headerlink" title="1.1    重要性"></a>1.1    重要性</h3><ul>
<li>  JUC 底层原理就是 AQS，就相当于 JVM 之于 Java。</li>
<li>  AQS 是 JUC 内容中最重要的基石</li>
</ul>
<blockquote>
<p>  <strong>为什么需要 AQS ？</strong></p>
</blockquote>
<p>在不同的多线程场景中，往往需要使用不同的同步器（锁），如果为每一个同步器都实现一遍所有功能的话，虽然可以但并不方便，因为有一部分功能是所有子类同步器都需要实现的公共功能。而 AQS 就是这样一个抽象类，它里面包含了部分抽象方法，这些抽象方法的具体实现交给了子类（模板方法设计模式），还有一部分非抽象方法，这些方法是所有子类同步器都需要使用到的方法，并且无序子类重写。AQS 大大地减少了重复代码量，降低了代码耦合程度。</p>
<blockquote>
<p>  <strong>AQS 为什么是 JUC 内容中最重要的基石？</strong></p>
</blockquote>
<p>JUC 中和 AQS 有关的类：</p>
<ul>
<li>  Semaphore 信号量</li>
<li>  CyclicBarrier</li>
<li>  ReentrantLock</li>
<li>  CountDownLatch</li>
<li>  ReentrantReadWriteLock</li>
</ul>
<p>以上列举的几种类，虽然是不同的 API，但其内部都有一些共同的操作，例如加锁、释放锁。如果为每个 API 都重写一份功能实现的话，虽然可以，但并不划算。而 AQS 就是这样一个 API ，它把同步器（包括锁）中需要实现的功能抽取出来，在  AQS 中进行声明和简单逻辑的实现。这样子类同步器只需要实现 AQS 类，并实现 AQS 类中部分未实现的方法，就可以轻易的实现自定义的同步器。</p>
<ol>
<li> <strong>ReentrantLock</strong></li>
</ol>
<p><img src="AQS/image-20210716222211925.png" alt="image-20210716222211925"></p>
<ol start="2">
<li> <strong>CountDownLatch</strong></li>
</ol>
<p><img src="AQS/image-20210716222347766.png" alt="image-20210716222347766"></p>
<ol start="3">
<li> <strong>ReentrantReadWriteLock</strong></li>
</ol>
<p><img src="AQS/image-20210716222507442.png" alt="image-20210716222507442"></p>
<ol start="4">
<li> <strong>Semaphore</strong></li>
</ol>
<p><img src="AQS/image-20210716222601965.png" alt="image-20210716222601965"></p>
<h3 id="1-2-必要性"><a href="#1-2-必要性" class="headerlink" title="1.2    必要性"></a>1.2    必要性</h3><ul>
<li>  多线程环境下，为保证线程安访问共享资源时就会加锁，加锁就会导致抢不到锁的其它线程阻塞，如果有多个线程被阻塞后就需要对这些线程进行排队，实现排队必然需要队列（抢不到锁的线程被阻塞后就得去排队）。</li>
<li>  抢到锁的线程直接访问临界资源执行业务逻辑，抢不到锁的线程必然涉及一种排队等候机制。抢占锁失败的线程继续等待，但等候的线程仍保留获取锁的可能性。【在锁被前一个持有锁的线程释放后等待队列中的线程就有可能获取到锁】</li>
<li>  如果锁被占用，就需要一定的阻塞等待和唤醒机制来保证锁分配。这个机制主要是通过 CLH（CLH 是三个科学家的首字母缩写）队列的变体实现的，将暂时获取不到锁（被阻塞）的线程加入到等待队列中，这个队列就是 AQS 的抽象表现。它被阻塞的线程封装成一个个节点（Node）加入等待队列中，通过 CAS、自旋以及 <code>LockSupport#part()</code> 等方式，维护 state 变量的状态，使并发达到同步的控制效果。</li>
<li>  <strong>AQS 管理的是没有抢到锁的、将要被加入到阻塞队列的线程。</strong></li>
</ul>
<hr>
<h2 id="2-是什么"><a href="#2-是什么" class="headerlink" title="2    是什么"></a>2    是什么</h2><blockquote>
<p>  <strong>AQS；AbstractQueuedSynchronizer；抽象队列同步器</strong></p>
</blockquote>
<ul>
<li>  <strong>抽象</strong>：抽象类，只进行方法的声明和部分通用方法的实现，其余细节都交给子类去实现；</li>
<li>  <strong>队列</strong>：使用先进先出（FIFO）队列存储数据；</li>
<li>  <strong>同步</strong>：实现了同步的功能。</li>
</ul>
<h2 id="3-有什么用"><a href="#3-有什么用" class="headerlink" title="3    有什么用"></a>3    有什么用</h2><ul>
<li>  <strong>AQS 是用来构建锁或者其它同步器的基础框架</strong>。</li>
<li>  使用 AQS 能简单且高效地构造出应用广泛的同步器，比如我们学过的 ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 实现的。</li>
<li>  当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器，只要在子类中实现它的几个 <code>protected</code> 方法就可以了。</li>
</ul>
<blockquote>
<p>  <strong>锁和同步器的关系：</strong></p>
</blockquote>
<ul>
<li><p>  锁：面向锁的<strong>使用者</strong>。定义了程序员和锁交互的 API，隐藏了实现细节。</p>
</li>
<li><p>  同步器：面向锁的<strong>实现者</strong>，即怎样实现一个锁。提出了统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。</p>
</li>
</ul>
<hr>
<h2 id="4-AQS-数据结构"><a href="#4-AQS-数据结构" class="headerlink" title="4    AQS 数据结构"></a>4    AQS 数据结构</h2><ul>
<li><p>  AQS 内部通过一个 FIFO <strong>双端队列</strong>来完成资源获取线程的排队工作，</p>
</li>
<li><p>使用 <strong>volatile int state</strong> 变量作为资源的标识。同时定义了几个获取和改变 <code>state</code> 的 <code>protectd</code> 方法，子方法可以通过重写这些方法来实现自己的逻辑。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState()</span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure></li>
<li><p>  这 3 个方法均是原子操作，其中 <code>compareAndSetState</code> 的实现依赖于 Unsafe 的 <code>compareAndSwapInt()</code> 方法。</p>
</li>
<li><p>  AQS 类本身实现的是⼀些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针 <code>head</code> 和 <code>tail</code> 用于标识队列的头部和尾部。其数据结构如图：</p>
</li>
</ul>
<p><img src="AQS/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="AQS数据结构"></p>
<ul>
<li>  但它并不是直接储存线程，而是存储与线程绑定的 Node 节点。</li>
</ul>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<ul>
<li>  AQS 就是一个双向队列 + 一个 int 类型的变量 state</li>
<li>  <strong>AQS = 双向队列 + state</strong> </li>
</ul>
<hr>
<h3 id="4-1-AQS内部体系架构"><a href="#4-1-AQS内部体系架构" class="headerlink" title="4.1    AQS内部体系架构"></a>4.1    AQS内部体系架构</h3><p><img src="AQS/AbstractQueuedSynchronizer.png" alt="AbstractQueuedSynchronizer"></p>
<ul>
<li>  AQS 有两个内部类：<strong>ConditionObject</strong> 和 <strong>Node</strong></li>
<li>  Sync 实现了 AQS，NofairSync 和 FairSync 实现了 Sync，所以说它们两个也实现了 AQS</li>
<li>  Sync、NofairSync 和 FairSync 都是 ReentrantLock 的内部类，也即 Lock 的内部类</li>
</ul>
<hr>
<h2 id="5-AQS-成员变量"><a href="#5-AQS-成员变量" class="headerlink" title="5    AQS 成员变量"></a>5    AQS 成员变量</h2><h3 id="5-1-AQS-成员变量"><a href="#5-1-AQS-成员变量" class="headerlink" title="5.1    AQS 成员变量"></a>5.1    AQS 成员变量</h3><p><img src="AQS/image-20210717091946871.png" alt="image-20210717091946871"></p>
<ol>
<li><p>静态内部类 <strong>Node</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span>;	<span class="comment">// Node 节点是对线程的抽象，与线程绑定</span></span><br></pre></td></tr></table></figure></li>
<li><p>同步状态码 <strong>state</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;	<span class="comment">// 同步状态码，有3种状态。0 表示无人占用，1 表示有线程正在占用，大于 1 表示可重入锁。</span></span><br></pre></td></tr></table></figure></li>
<li><p>等待队列的头结点 <strong>head</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;	<span class="comment">// 等待队列中的头结点</span></span><br></pre></td></tr></table></figure></li>
<li><p>等待队列的尾节点 <strong>tail</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;	<span class="comment">// 等待队列中的尾节点</span></span><br></pre></td></tr></table></figure></li>
<li><p>AQS 的父类 AbstractOwnableSynchronizer 中的成员变量 <strong>exclusiveOwnerThread</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;	<span class="comment">// 独占线程的线程ID</span></span><br></pre></td></tr></table></figure></li>
<li><p> 静态内部类 ConditionObject</p>
</li>
<li><p> 其它</p>
</li>
</ol>
<hr>
<h3 id="5-2-静态内部类Node"><a href="#5-2-静态内部类Node" class="headerlink" title="5.2    静态内部类Node"></a>5.2    静态内部类Node</h3><h4 id="1、资源共享模式"><a href="#1、资源共享模式" class="headerlink" title="1、资源共享模式"></a>1、资源共享模式</h4><p>资源共享的两种模式：</p>
<ul>
<li>  独占模式（Exclusive）：单个线程独占资源，一次只能被一个线程获取。如 <code>ReentrantLock</code>。</li>
<li>  共享模式（Share）：资源可同时可以被多个线程获取，具体的资源个数可以通过参数指定。如 <code>Semaphore/CountDownLatch</code>。</li>
</ul>
<p>两种不同的共享模式分别用于实现不同的同步器（锁），即独占锁或者共享锁。</p>
<p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如 ReadWriteLock 。</p>
<p>AQS 中关于这两种资源共享模式的定义源码（均在内部类Node中）。</p>
<h4 id="2、AQS-Node-类源码"><a href="#2、AQS-Node-类源码" class="headerlink" title="2、AQS$Node 类源码"></a>2、AQS$Node 类源码</h4><h5 id="Node-类成员变量"><a href="#Node-类成员变量" class="headerlink" title="Node 类成员变量"></a>Node 类成员变量</h5><ol>
<li> 前驱节点 <strong>prev</strong></li>
<li> 后继节点 <strong>next</strong></li>
<li> 当前节点的等待状态 <strong>waitStatus</strong></li>
<li> 结点对应的线程 thread</li>
<li> 等待队列里下一个等待条件的结点 nextWaiter</li>
<li> 其它</li>
</ol>
<h5 id="Node-类小结"><a href="#Node-类小结" class="headerlink" title="Node 类小结"></a>Node 类小结</h5><ul>
<li>  <strong>Node = waitStatus + 前后指针</strong></li>
</ul>
<h5 id="AQS-Node-类源码："><a href="#AQS-Node-类源码：" class="headerlink" title="AQS$Node 类源码："></a>AQS$Node 类源码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">       <span class="comment">// 标记一个（线程）节点在共享模式下等待（节点与线程绑定）</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">       <span class="comment">// 标记一个（线程）节点在独占模式下等待（节点与线程绑定）</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">/* 小总结：</span></span><br><span class="line"><span class="comment">		1、只有进入等待队列的线程，才会给其分配一个节点与线程绑定。</span></span><br><span class="line"><span class="comment">		2、换言之就是，如果一个线程抢占到了资源，就无需再给这个线程绑定节点对象了</span></span><br><span class="line"><span class="comment">        */</span>		</span><br><span class="line"></span><br><span class="line">       <span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消，即从等待队列中移除</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">      	<span class="comment">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// waitStatus的值，表示该结点（对应的线程）在等待某⼀条件，当 Condition 条件满足时会被唤醒</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">   	<span class="comment">// waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点(共享模式下，同步获取状态将会无条件的传播下去)</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">       <span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1。初始值是0，</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">		</span><br><span class="line">       <span class="keyword">volatile</span> Node prev;	<span class="comment">// 前置节点</span></span><br><span class="line">       <span class="keyword">volatile</span> Node next;	<span class="comment">// 后继节点</span></span><br><span class="line">       <span class="keyword">volatile</span> Thread thread;	<span class="comment">// 结点对应的线程</span></span><br><span class="line">       Node nextWaiter; <span class="comment">// 等待队列⾥下一个等待条件的结点</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断共享模式的方法</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">return</span> <span class="variable">nextWaiter</span> <span class="operator">=</span>= SHARED;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 返回 node 节点的前驱节点，或抛出 NullPointerException</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev; <span class="comment">// 让节点p指向当前线程绑定的节点的前驱结点</span></span><br><span class="line">           <span class="comment">// 如果这个前驱节点为空，抛出异常；如果前驱节点不为空，返回这个前驱节点即可</span></span><br><span class="line">           <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">           <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">           <span class="built_in">this</span>.thread = thread;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">           <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">           <span class="built_in">this</span>.thread = thread;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：通过 Node 我们可以实现两个队列：</p>
<ul>
<li>  一是通过 <code>prev</code> 和 <code>next</code> 实现 CLH 队列（阻塞线程的等待队列，双向队列）；</li>
<li>  二是 <code>nextWaiter</code> 实现 Condition 条件上的等待线程队列（单向队列），这个 Condition 主要用在 ReentrantLock 类中。</li>
</ul>
<blockquote>
<p>  <strong>AQS 中的 addWaiter() 私有方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用了Node类的 Node(Thread thread, Node mode) 构造函数</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="6-AQS-主要方法的源码解析"><a href="#6-AQS-主要方法的源码解析" class="headerlink" title="6    AQS 主要方法的源码解析"></a>6    AQS 主要方法的源码解析</h2><p>AQS 的设计是基于<strong>模板方法模式</strong>的，它有一些方法是必须要子类去实现的，主要包括：</p>
<ul>
<li>  **isHeldExclusively()**：该线程是否正在独占资源。只有用到 condition 时才需要去实现它。</li>
<li>  **tryAcquire(int)**：独占方式。尝试获取资源，成功则返回 true，失败则返回 false 。</li>
<li>  **tryRelease(int)**：独占方式。尝试释放资源，成功则返回 true，失败则返回 false 。</li>
<li>  **tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>  **tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。</li>
</ul>
<p>这些方法虽然都是 protected 方法，但是它们并没有在AQS具体实现，而是直接抛出异常（这里采用了模板设计模式，只要子类不实现这个方法，直接抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 AQS 实现了⼀系列主要的逻辑。下⾯我们从源码来分析⼀下<strong>获取和释放资源的主要逻辑</strong>：</p>
<h3 id="6-1-获取资源"><a href="#6-1-获取资源" class="headerlink" title="6.1    获取资源"></a>6.1    获取资源</h3><p>获取资源的入口是 <strong>acquire(int arg)</strong> 方法。arg 是要获取的资源的个数，在独占模式下始终为 1。这个方法的逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li> 首先调用 <strong>tryAcquire(arg)</strong> 尝试去获取资源。【这个方法要由子类提供具体的实现】</li>
</ol>
</blockquote>
<ul>
<li>  如果尝试获取资源成功，<code>tryAcquire(arg)</code> 方法返回值 true，取反后是 false，直接退出当前方法，转去执行获取锁成功后的代码逻辑，也就不会再将当前线程封装成 Node 节点并加入等待队列了。</li>
<li>  如果获取资源失败，<code>tryAcquire(arg)</code> 方法返回值 false，取反后是 true，继续执行 <code>&amp;&amp;</code> 符号后面的方法。即通过 <strong>addWaiter(Node.EXCLUSIVE)</strong> 方法把这个线程封装成 Node 节点并插入到等待队列中。其中传入的参数代表要插入的 Node 是独占式的。这个方法的具体实现如下：</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>addWaiter(Node.EXCLUSIVE)</strong> 方法源码</li>
</ol>
</blockquote>
<ul>
<li>  方法介绍：将未获取到资源的线程封装到一个 Node 节点中，并追加到等待队列尾部。</li>
<li>  方法参数：接收一个指定模式（mode）的节点。（独占式 &amp; 共享式）</li>
<li>  返回值：返回值是追加到尾部的那个节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为当前线程新建一个Node节点并与线程绑定（独占式/共享式）</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	也就是说，如果线程获取资源成功，就不会被加入等待队列，自然也不会生成线程对应的Node节点。</span></span><br><span class="line"><span class="comment">    	换言之，只有线程获取资源不成功时，才会为当前线程新建一个对应模式的Node节点（这个节点绑</span></span><br><span class="line"><span class="comment">    	定一个线程），并将节点加入等待队列</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	将Node节点插入等待队列中，成为新的尾节点</span></span><br><span class="line"><span class="comment">    		1.让node节点的前驱节点指向旧的尾节点</span></span><br><span class="line"><span class="comment">    		2.更新旧的尾节点，让其指向当前节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail; <span class="comment">// 让当前node节点的前驱节点指向队尾节点。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	1、如果当前等待队列为空，则尾节点一定为 null，则 pred 指向 null，不进入if判断的代码块内</span></span><br><span class="line"><span class="comment">    	2、如果当前等待队列不为空，则尾节点一定不为null，则 pred 也不为 null，进入if判断的代码块内执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred; <span class="comment">// 让当前node节点的前驱节点指向当前队列的尾节点</span></span><br><span class="line">        <span class="comment">// 修改结果回写的时候要进行CAS比较，防止队列的尾节点被其它线程提前修改。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">            <span class="comment">// 如果CAS比较成功，让尾节点的next指针指向当前节点，尾插结束，返回被新插入的节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待队列为空或者上述CAS失败，继续使用CAS循环插入【因为上述的CAS只比较了一次，enq则是一个循环的CAS插入过程】</span></span><br><span class="line">    enq(node);	</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li> <strong>enq(node)</strong> 方法源码</li>
</ol>
</blockquote>
<ul>
<li>  方法介绍：使用循环 CAS 的方式将等待线程的节点对象插入等待队列</li>
<li>  循环 CAS 就叫做 <strong>自旋</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;	<span class="comment">// 拿到当前等待队列的尾节点</span></span><br><span class="line">        <span class="comment">// 如果尾节点为空（即队列为空），就新建一个空的头结点，并把当先线程绑定的node节点通过CAS的方式追加到新的头结点之后</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果尾节点不为空，就通过CAS的方式把当前线程节点node插入等待队列尾部</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) </span><br><span class="line">            &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li> <strong>小总结</strong></li>
</ol>
</blockquote>
<p>上面的两个函数⽐较好理解，就是在队列的尾部插入新的 Node 节点，但是需要注意的是由于 AQS 中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这⾥是通过 CAS 自旋的方式保证了操作的线程安全性。</p>
<p>OK，现在回到最开始的 <code>aquire(int arg)</code> 方法。现在通过 <code>addWaiter </code>方法，已经把⼀个 Node 放到等待队列尾部了。而处于等待队列中的结点是从头结点⼀个⼀个按顺序去获取资源的。具体的实现我们来看看 <strong>acquireQueued</strong> 方法</p>
<blockquote>
<ol start="5">
<li> **acquireQueued(final Node node, int arg) **方法源码</li>
</ol>
</blockquote>
<ul>
<li>  方法介绍：</li>
<li>方法参数：<ul>
<li>  node 节点是最新插入等待队列的节点，即等待队列中的最后一个节点。</li>
<li>  arg 是要获取的资源的个数，在独占模式下始终为 1。</li>
</ul>
</li>
<li>  返回值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); <span class="comment">// 获取node节点的前驱节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果node的前驱结点p是head，表示node是第⼆个结点，就可以尝试去获取资源了【因为第一个节点是无数据的节点，只标志队列的开始】</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) </span><br><span class="line">            &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="6-2-释放资源"><a href="#6-2-释放资源" class="headerlink" title="6.2    释放资源"></a>6.2    释放资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="AQS-原理概述（以-ReentrantLock-为例）"><a href="#AQS-原理概述（以-ReentrantLock-为例）" class="headerlink" title="AQS 原理概述（以 ReentrantLock 为例）"></a>AQS 原理概述（以 ReentrantLock 为例）</h1><h2 id="ReentrantLock-和-AQS-的关系"><a href="#ReentrantLock-和-AQS-的关系" class="headerlink" title="ReentrantLock 和 AQS 的关系"></a>ReentrantLock 和 AQS 的关系</h2><p><img src="AQS/ReentrantLock_AQS_01.png" alt="ReentrantLock_AQS_01"></p>
<p>ReentrantLock 类有一个内部类 Sync 继承了 AbstractQueuedSynchronizer 抽象类，说白了就是 ReentrantLock 中包含了一个 AQS 对象，AQS 对象是 ReentrantLock 实现加锁和释放锁的关键性核心组件。</p>
<h2 id="ReentrantLock-加锁和释放锁的底层原理"><a href="#ReentrantLock-加锁和释放锁的底层原理" class="headerlink" title="ReentrantLock 加锁和释放锁的底层原理"></a>ReentrantLock 加锁和释放锁的底层原理</h2><blockquote>
<ol>
<li> <strong>线程 T1 加锁</strong></li>
</ol>
</blockquote>
<p>如果现在有一个线程尝试调用 <code>ReentrantLock</code> 的 <code>lock()</code> 方法进行加锁，会发生什么事情呢？</p>
<p>很简单。这个 AQS 对象内部有一个核心变量 <code>private volatile int state</code>，代表了加锁的状态。初始状态下，<code>state == 0</code>，另外，这个 AQS 内部还有一个关键变量，用来记录当前加锁的是哪个线程，初始化状态下，这个变量是 null。</p>
<p><img src="AQS/ReentrantLock_AQS_01_1.png" alt="ReentrantLock_AQS_01_1"></p>
<p>接着线程 T1 调用 ReentrantLock#lock() 方法尝试进行加锁，这个加锁的过程，就是用 CAS 操作将 state 值从 0 变成 1。</p>
<p>如果 T1 之前没有其它线程加锁锁，那么 <code>state==0</code> 恒成立。此时线程 T1 就可以加锁成功。</p>
<p>一旦线程 T1 加锁成功后，就可以设置当前加锁线程是自己。如下图所示，就是线程 T1 加锁的过程。</p>
<p><img src="AQS/ReentrantLock_AQS_02.png" alt="ReentrantLock_AQS_02"></p>
<p>说白了，AQS 其实就是 JUC 包中的一个核心组件，里面有 <strong>state 变量</strong>、<strong>加锁线程变量</strong>等核心的东西，维护了加锁的状态。</p>
<p>而<strong>ReentrantLock 只是一个外层的 API，内核中的锁机制实现都是依赖于 AQS 组件的。</strong></p>
<p>ReentrantLock 顾名思义是一个可重入锁，即可以使用一个 ReentrantLock 对象执行多次 <code>lock()</code> 和 <code>unlock()</code> 方法。</p>
<p>那么 AQS 是如何实现可重入加锁的呢？线程 T1 每调用一次 <code>lock()</code> 方法，如果 CAS 比较发现 state != 0，接着会再判断当前加锁线程是不是自己，如果是就把 state 的值累加 1，其余不变。同理，调用 <code>unlock()</code> 释放锁的时候就是把 state 值累减 1。</p>
<blockquote>
<ol start="2">
<li> <strong>线程 T2 加锁</strong></li>
</ol>
</blockquote>
<p>如果线程 T1 加锁之后，线程 T2 想要争夺锁会怎么样？（<strong>互斥锁</strong>）</p>
<ol>
<li> 线程 T2 尝试获取锁，调用 <code>lock()</code> 方法，首先会去检查 <code>ReentrantLock.AQS.state</code> 变量是否为 0，发现不为 0，说明有线程正在使用锁，CAS 校验失败；</li>
<li> 接着线程 T2 会继续查看当前加锁的线程是不是自己，“<strong>加锁线程</strong>”这个变量明确记录了是线程 T1 占用了这个锁，所以此时线程 T2 会加锁失败。</li>
</ol>
<p><img src="AQS/ReentrantLock_AQS_03.png" alt="ReentrantLock_AQS_03"></p>
<blockquote>
<ol start="3">
<li> <strong>加锁失败</strong></li>
</ol>
</blockquote>
<p>接着，线程 T2 会将自己放入 AQS 的同步等待队列中，因为自己尝试加锁失败了，此时就要将自己放入等待队列中，直到线程 T1 释放锁之后，自己就可以重新尝试加锁了。</p>
<p>所以 AQS 内部还有一个同步等待队列，专门存放那些加锁失败的线程。</p>
<p><img src="AQS/ReentrantLock_AQS_03_02.png" alt="ReentrantLock_AQS_03_02"></p>
<blockquote>
<ol start="4">
<li> <strong>释放锁</strong></li>
</ol>
</blockquote>
<p>接着，线程 T1 在执行完自己的业务逻辑代码之后，就会释放锁。释放锁的过程非常简单，就是将 AQS 内的 state 变量的值递减 1，如果 state 为 0，则彻底释放锁，会将“加锁线程”变量的值也设置为 null。</p>
<blockquote>
<ol start="5">
<li> <strong>释放锁之后</strong></li>
</ol>
</blockquote>
<p>接下来，会从等待队列的队头唤醒线程 T2 重新尝试加锁。</p>
<p>线程 T2 重新尝试加锁，还是使用 CAS 操作将 state 从 0 变成 1，此时就会加锁成功，并将 state 设置为 1，同时把 “<strong>加锁线程”</strong> 设置为线程 T2 自己，同时线程 T2 从同步等待队列中出队。 </p>
<hr>
<h1 id="从-ReentrantLock-开始解读-AQS"><a href="#从-ReentrantLock-开始解读-AQS" class="headerlink" title="从 ReentrantLock 开始解读 AQS"></a>从 ReentrantLock 开始解读 AQS</h1><p>Lock 接口的实现类（如 ReentrantLock ），基本都是通过【聚合】了一个【队列同步器】的子类（sync ）完成线程访问控制的。</p>
<p><img src="AQS/ReentrantLock.png" alt="ReentrantLock"></p>
<p>ReentrantLock 类：</p>
<ol>
<li> 实现了 Lock 接口</li>
<li>包含一个内部抽象类 Sync<ul>
<li>  Sync 实现了 AbstractQueuedSynchronizer 接口</li>
<li>  Sync 包含两个实现类 FairSync 和 NonfairSync </li>
</ul>
</li>
</ol>
<p>对比公平锁和非公平锁的 tryAcquire() 方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少一个判断 hasQueuedPredecessors()。该方法中判断了是否需要排队，导致公平锁和非公平锁的差异如下：</p>
<p>公平锁：公平锁讲究先来后到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入到等待队列之中。</p>
<p>非公平锁：不管是否有等待队列，如果可以获取锁，就马上占有锁对象。也就是说等待队列中的第一个线程在 unpark() 之后还是需要 竞争锁（存在线程竞争锁的情况）</p>
<p><strong>整个 ReentrantLock 加锁（非公平）的过程可以分为三个阶段：</strong></p>
<ol>
<li> <strong>尝试加锁</strong>，加锁成功则正常调用资源</li>
<li> <strong>加锁失败，线程进入AQS队列</strong></li>
<li> <strong>线程进入队列后，进入阻塞状态</strong></li>
</ol>
<blockquote>
<p>  lock()</p>
<p>  acquire()</p>
<p>  tryAcquire(arg)</p>
<p>  addWaiter(Node.EXCLUSIVE)：将线程节点加入等待队列</p>
<p>  acquireQueued(addWaiter(Node.EXCLUSIVE)， arg)</p>
</blockquote>
<p>acquire(1) 表示占用 1 个</p>
<blockquote>
<ol>
<li> <strong>ReentrantLock 底层源码01</strong></li>
</ol>
</blockquote>
<p><img src="AQS/ReentrantLock%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%8101.png" alt="ReentrantLock底层源码01"></p>
<blockquote>
<ol start="2">
<li> <strong>公平锁和非公平锁的 tryAcquire() 方法</strong></li>
</ol>
</blockquote>
<p><img src="AQS/fair_nonfair$tryAcquire.png" alt="fair_nonfair$tryAcquire"></p>
<ul>
<li>  hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 reentrantLock.lock() 方法</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层调用的是 sync.lock(); 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sync 是 AQS 的一个静态抽象子类，包含两个实现类 FairSync 和 NonfairSync。</span></span><br><span class="line"><span class="comment">// 在 sync 中，lock 方法被声明为一个抽象方法，具体的方法实现包含在子类 FairSync 和 NonfairSync 中，我们以 ReentrantLock 默认的非公平锁 NonfairSync 为例。NonfairSync#lock 方法为：</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))	</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分支1：CAS 比较  state 的值是否为 0，如果为 0 则更新为 1，并设置锁的占用线程为当前线程。【锁对象空闲时】</span></span><br><span class="line"><span class="comment">// 分支2：在非公平锁中，即使发现锁对象被占用，也会调用 acquire(1) 方法尝试抢占锁。【锁对象已被占用】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来我们来看一下 acquire() 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;	</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;	</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tryAcquire(1) 方法：返回 true 表示加锁成功，返回 false 表示加锁失败。如果加锁成功，取反后为 false ，则不执行 &amp;&amp; 后面的方法。如果加锁失败，取反后为 true，则还需判断 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 方法的执行结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// addWaiter(Node.EXCLUSIVE) 方法</span></span><br><span class="line"><span class="comment">// acquireQueued(__, 1)) 方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>s</p>
<p><strong>tryAcquire()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryAcquire() 方法是一个顶级方法，具体的实现在其实现类中，我们选择了 NonfairSync#tryAcquire 方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;	 	<span class="comment">// tryAcquire(1)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonfairSync#tryAcquire</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;	<span class="comment">// tryAcquire(1)</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);		<span class="comment">// nonfairTryAcquire(1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回 true 表示加锁成功，false 表示加锁失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync#nonfairTryAcquire()</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分支1：如果 state==0（代表当前锁无线程占用），就更新 state 为 1，并设置锁对象的占用线程为为当前线程，返回 true；</span></span><br><span class="line"><span class="comment">// 分支2：state!=0，但是当前线程与锁对象绑定的线程相同（可重入锁），就将 state 累加 1，返回 true；</span></span><br><span class="line"><span class="comment">// 分支3：state!=0 &amp;&amp; 加锁线程！=当前线程，则说明加锁失败，返回 false</span></span><br></pre></td></tr></table></figure>



<p><strong>addWaiter(Node.EXCLUSIVE)</strong>  加强</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、将线程封装成 node 节点</span></span><br><span class="line"><span class="comment">// 2、Node 的</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;	<span class="comment">// 失败的标志位</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">//是否被打断的标志位。被打断与失败刚好是相反的。如果被打断一定失败</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果失败的标志位为 true，该线程就取消排队</span></span><br><span class="line">        <span class="keyword">if</span> (failed)	</span><br><span class="line">        &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>  调用 unpark 后线程才真正进入阻塞状态，之前虽然被连接到了等待队列中，但是仍然会总是尝试去 CAS 比较锁是否空闲，仍然想要去抢夺锁</li>
<li>  而调用 unpark 后，就不会再主动去监测锁是否空闲了，只有当持有锁的线程调用 unpark 方法唤醒后线程才会继续执行。</li>
<li>  【阻塞】</li>
</ul>
<h1 id="2021-10-08附加"><a href="#2021-10-08附加" class="headerlink" title="2021.10.08附加"></a>2021.10.08附加</h1><ol>
<li> AQS类内部</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
