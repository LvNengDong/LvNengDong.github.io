<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">并查集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-30 09:55:15 / Modified: 16:19:23" itemprop="dateCreated datePublished" datetime="2021-08-30T09:55:15+08:00">2021-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  参考地址：力扣大佬</p>
<p>  链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/">https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/</a></p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>  并查集是一种数据结构</li>
<li>  并查集这三个字，一个字代表一个意思。</li>
<li>  <strong>并（Union）</strong>，代表合并</li>
<li>  <strong>查（Find）</strong>，代表查找</li>
<li>  <strong>集（Set）</strong>，代表这是一个以字典为基础的数据结构，它的基本功能是合并集合中的元素，查找集合中的元素</li>
<li>  并查集的典型应用是有关<strong>连通分量</strong>的问题</li>
</ul>
<hr>
<h2 id="并查集实现"><a href="#并查集实现" class="headerlink" title="并查集实现"></a>并查集实现</h2><blockquote>
<ol>
<li> <strong>数据结构</strong></li>
</ol>
</blockquote>
<ul>
<li>  并查集跟树有些类似，只不过它跟树是相反的。在树这个数据结构里面，每个节点会记录它的子节点。在并查集里，每个节点会记录它的父节点。</li>
<li>  通常用 Map 来实现这个结构，Map 的 K 表示当前节点，V 表示当前节点的父节点</li>
</ul>
<p><img src="/2021/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/1609980000-ofFjdW-%E5%B9%BB%E7%81%AF%E7%89%871.JPG" alt="幻灯片1.JPG"></p>
<p>可以看到，如果节点是相互连通的（从一个节点可以到达另一个节点），那么他们在同一棵树里，或者说在同一个集合里，或者说他们的<strong>祖先是相同的</strong>。</p>
<blockquote>
<ol start="2">
<li> <strong>初始化节点</strong></li>
</ol>
</blockquote>
<p>初始化时每个节点的父节点都为空，也就是说每个节点最初都是一个独立的子集</p>
<blockquote>
<ol start="3">
<li> <strong>合并两个节点</strong></li>
</ol>
</blockquote>
<ul>
<li>  如果发现两个节点是连通的（一般通过题目中给定的条件来判断两个节点是否连通），就把它们合并。</li>
<li>  合并就是设置两个节点的祖宗相同，可以把 A 节点的祖宗设置为 A、B 共同的祖宗或者把 B 节点的祖宗设置为 A、B 共同的祖宗。</li>
</ul>
<blockquote>
<ol start="4">
<li> <strong>判断两节点是否连通</strong></li>
</ol>
</blockquote>
<ul>
<li>  就是判断两个节点的祖先是否相同，相同处于同一连通分量中</li>
</ul>
<blockquote>
<ol start="5">
<li> <strong>查找祖宗（通用方法）</strong></li>
</ol>
</blockquote>
<ul>
<li>  如果该节点的父节点不为空，就一直迭代向上查找，直到找到某个节点的父节点为空</li>
</ul>
<h2 id="并查集基本模板代码-Java"><a href="#并查集基本模板代码-Java" class="headerlink" title="并查集基本模板代码(Java)"></a>并查集基本模板代码(Java)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.unionFind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/30 9:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并查集模板类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// K 表示当前节点，V表示当前节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、【初始化节点】当新加入一个节点时节点的父节点为空，即每个节点初始都是一个独立的子集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> newNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(newNode))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(newNode, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、【合并两个节点】如果两个节点是连通的，就把它们合并到一个子集中。</span></span><br><span class="line">    <span class="comment">// ==&gt; 就是设置祖先相同，可以把 A 子树的祖先作为两个节点共同的祖先，也可以把B子树作为两个节点共同的祖先</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB)	<span class="comment">// 只有当不在同一个连通分量中时才需要设置到一块去，如果已经在了就无需重复设置</span></span><br><span class="line">        &#123;</span><br><span class="line">            map.put(rootB, rootA);  <span class="comment">// 将 rootA 作为合并后的新的祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、【判断两个节点是否连通】就是判断两个节点是否有同一个祖先，如果有，则证明连通；否则不连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line">        <span class="keyword">return</span> rootA==rootB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、【查找祖先】通用功能，如果父节点不为空，就一直迭代向上查找，直到找到父节点为空的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (map.get(root) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 map.get(node) == null 时，返回 node 即可</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h2><h3 id="LeetCode547：省份数量"><a href="#LeetCode547：省份数量" class="headerlink" title="LeetCode547：省份数量"></a>LeetCode547：省份数量</h3><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="comment">// 共有 n 个城市，依次初始化，每次初始化新的城市就判断是否与已添加的城市相连，如果相连就将它们连接起来，最后统计一共有多少个连通分量</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;isConnected.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将 i 添加到 uf 中</span></span><br><span class="line">            uf.add(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果两个城市相连，就将它们并入一个连通分量</span></span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uf.merge(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 UnionFind 中增加一个方法用于统计连通分量</span></span><br><span class="line">        <span class="keyword">return</span> uf.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// K 表示当前节点，V表示当前节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连通分量个数。每新增一个节点连通分量个数就加一，每合并一次节点连通分量个数就减一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="built_in">this</span>.num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、【初始化节点】当新加入一个节点时节点的父节点为空，即每个节点初始都是一个独立的子集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> newNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(newNode))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(newNode, <span class="literal">null</span>);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、【合并两个节点】如果两个节点是连通的，就把它们合并到一个子集中。</span></span><br><span class="line">    <span class="comment">// ==&gt; 就是设置祖先相同，可以把 A 子树的祖先作为两个节点共同的祖先，也可以把B子树作为两个节点共同的祖先</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 当两个节点连通，且这两个节点不在同一个连通分量中时，才进行合并</span></span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(rootB, rootA);  <span class="comment">// 将 rootA 作为合并后的新的祖先</span></span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、【判断两个节点是否连通】就是判断两个节点是否有同一个祖先，如果有，则证明连通；否则不连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line">        <span class="keyword">return</span> rootA==rootB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、【查找祖先】通用功能，如果父节点不为空，就一直迭代向上查找，直到找到父节点为空的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (map.get(root) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 map.get(node) == null 时，返回 node 即可</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="LeetCode200：岛屿数量"><a href="#LeetCode200：岛屿数量" class="headerlink" title="LeetCode200：岛屿数量"></a>LeetCode200：岛屿数量</h3><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/30 12:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求岛屿的数量，可以转换为求连通分量的数量。可以考虑用并查集来求解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution200_02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] grid = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution200_02</span> <span class="variable">solution200</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution200_02</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> solution200.numIslands(grid);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*【特殊情况】*/</span></span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*【一般情况】</span></span><br><span class="line"><span class="comment">        *   1、从头到尾遍历：遇到“0”跳过，遇到 &quot;1&quot; 就并入集合。</span></span><br><span class="line"><span class="comment">        *   2、最终看有几个连通分量</span></span><br><span class="line"><span class="comment">        *   */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【首先把矩阵中所有陆地的数量统计出来，加入到集合中】</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uf.add(i*cols+j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="comment">//                    uf.add(i*cols+j);</span></span><br><span class="line">                    <span class="comment">// 查看上下左右是否可以并入并查集</span></span><br><span class="line">                    <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage((i-<span class="number">1</span>)*cols+j, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i+<span class="number">1</span> &lt; rows &amp;&amp; grid[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage((i+<span class="number">1</span>)*cols+j, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage(i*cols+j-<span class="number">1</span>, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j+<span class="number">1</span> &lt; cols &amp;&amp; grid[i][j+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage(i*cols+j+<span class="number">1</span>, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> num;   <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新加入的节点设置其父节点为 null</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(node))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(node, <span class="literal">null</span>);</span><br><span class="line">            num++;  <span class="comment">// 连通分量+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点合并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merage</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果两个节点之间是连通的，就将其合并，合并后连通分量的数目-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当两个节点连通，且这两个节点不在同一个连通分量中时，才进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(rootA != rootB)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(rootA, rootB);</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点的祖宗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span>(map.get(root) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/28/%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/28/%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="post-title-link" itemprop="url">回溯法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-28 16:13:17" itemprop="dateCreated datePublished" datetime="2021-08-28T16:13:17+08:00">2021-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-01 22:02:24" itemprop="dateModified" datetime="2021-10-01T22:02:24+08:00">2021-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  力扣大佬解释链接：</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></p>
<blockquote>
<p>  <strong>核心要义：</strong></p>
</blockquote>
<p><strong>集合的大小构成了树的宽度，递归的深度构成了树的深度。</strong></p>
<blockquote>
<p>  <strong>回溯法模板</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、方法名 || 返回值 || 参数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、终止条件</span></span><br><span class="line"><span class="keyword">if</span>(终止条件)</span><br><span class="line">&#123;</span><br><span class="line">    结果收集;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、回溯搜索 + 遍历【集合的大小构成了树的宽度，递归的深度构成了树的深度】</span></span><br><span class="line"><span class="keyword">for</span>(本层集合中的元素)</span><br><span class="line">&#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径, 选择列表);	<span class="comment">// 递归</span></span><br><span class="line">    回溯;	<span class="comment">// 撤销处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="回溯法常见题型"><a href="#回溯法常见题型" class="headerlink" title="回溯法常见题型"></a>回溯法常见题型</h1><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><ul>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></li>
</ul>
<blockquote>
<ol start="40">
<li> <strong>组合总和</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个数字只能使用一次</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先对数组进行排序，便于之后剪枝</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[len];  <span class="comment">// 用于标志数组中的元素是否使用过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        backtracking(startIndex, candidates, target, len, flag, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> len, <span class="type">boolean</span>[] flag, <span class="type">int</span> sum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 收集</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果是排序后的数组，那么相同的元素一定紧挨在一起，所以说如果第i个元素与第i-1个元素相等，那么它们得到的组合一定是重复的，这时候就可以跳过这个重复的元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>] &amp;&amp; flag[i-<span class="number">1</span>] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 path、sum、flag</span></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            backtracking(i+<span class="number">1</span>, candidates, target, len, flag, sum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组合总和中的去重问题：</strong></p>
<ul>
<li>  首先，要明确去重的概念，<strong>去重就是使用过的元素不能重复选取</strong>。</li>
<li>  组合问题可以抽象为树形结构，那么在“使用过”这个问题上，是可以抽象成两个维度的，<strong>一个维度是在同一树层上使用过，另一个维度是在同一树枝上使用过</strong>。</li>
<li>  在本题中，我们可以看到，元素在同一个组合内是可以重复的，但是最终结果内的任意两个组合是不能重复的。所以本题中的去重可以理解为：在同一树层间去重。【对同一树层去重的话，先要对数组中的元素进行排序】</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/26/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/26/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">约瑟夫环问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-26 17:13:36" itemprop="dateCreated datePublished" datetime="2021-08-26T17:13:36+08:00">2021-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-24 18:47:10" itemprop="dateModified" datetime="2021-09-24T18:47:10+08:00">2021-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  约瑟夫环问题</p>
</blockquote>
<blockquote>
<p>  <strong>LeetCode地址</strong></p>
</blockquote>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></li>
</ul>
<h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><blockquote>
<p>  <strong>分析</strong></p>
</blockquote>
<ol>
<li> 模拟：建立一个数组，里面存放的就是每个人的编号，一步一步模拟出队的过程，当出队了 n-1 次之后，数组中最后剩下的数字就是要求得的数字。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数组长度都设置为0，表示对应编号的人没有出局</span><br><span class="line">int n， int m	// 表示总共有n 人，数到m时出局</span><br><span class="line">int count	计数器</span><br><span class="line">int i = 0; 表示当前报数开始的编号（初始为0）</span><br><span class="line"></span><br><span class="line">// 只有当出局的人数小于 n 时循环才有必要继续</span><br><span class="line">while(count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="循环链表实现"><a href="#循环链表实现" class="headerlink" title="循环链表实现"></a>循环链表实现</h2><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" class="post-title-link" itemprop="url">数据结构——栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-25 10:07:36 / Modified: 10:39:56" itemprop="dateCreated datePublished" datetime="2021-08-25T10:07:36+08:00">2021-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="中缀-前缀-后缀-表达式之间的互相转换"><a href="#中缀-前缀-后缀-表达式之间的互相转换" class="headerlink" title="中缀 / 前缀 / 后缀 表达式之间的互相转换"></a>中缀 / 前缀 / 后缀 表达式之间的互相转换</h2><ul>
<li>  中缀表达式就是我们常见的算术表达式</li>
<li>  中缀表达式是由括号，而前缀和后缀表达式都是没有括号的。</li>
<li>  编译系统对算术表达式的处理是先把它转换为后缀表达式。所以<strong>计算机底层执行的是没有括号的后缀表达式</strong>。</li>
</ul>
<blockquote>
<p>  <strong>基本转换规则</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：a+b</span><br><span class="line">前缀表达式：+ab</span><br><span class="line">后缀表达式：ab+</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>中缀 –&gt; 前缀</strong></p>
</blockquote>
<ul>
<li>  基本转换规则中的每一部分都可以视为一个整体，中缀转前缀的手工转换写法就是把一个复杂的表达式划分成两部分，将符号部分提到数据后面即可。</li>
<li>步骤：<ol>
<li> 每一个表达式用括号括起来</li>
<li> 两个表达式中间的运算符提到括号前面</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：(a+b)*c+d-(e+g)*h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、将该中缀表达式分成两部分</span><br><span class="line">[(a+b)*c+d] - [(e+g)*h]</span><br><span class="line"><span class="number">2</span>、将运算符移动到最前端</span><br><span class="line">-[(a+b)*c+d]  [(e+g)*h]</span><br><span class="line"><span class="number">3</span>、再依次递归地拆分两个子表达式，同理也是将每个子表达式拆成两部分，将运算符提到最前面</span><br><span class="line">	(a+b)*c+d </span><br><span class="line">==&gt; ((a+b)*c)+d</span><br><span class="line">==&gt; +((a+b)*c) d</span><br><span class="line">==&gt; + * (a+b) <span class="type">c</span> <span class="variable">d</span></span><br><span class="line"><span class="operator">=</span>=&gt; + * + a b c <span class="title function_">d</span></span><br><span class="line">	</span><br><span class="line">	<span class="params">(e+g)</span>*h</span><br><span class="line">==&gt; * (e+g)h</span><br><span class="line">==&gt; * + egh</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、将三部分拼接起来</span><br><span class="line">-  +*+abcd  *+egh  ==&gt; -+*+abcd*+egh</span><br></pre></td></tr></table></figure>



<ul>
<li>  中缀转前缀表达式不是唯一的，因为交换律的存在。比如上面的例子中缀表达式可以拆分为 <code>[(a+b)*c] + [d-(e+g)*h]</code>，也可以拆分为 <code>[(a+b)*c+d] - [(e+g)*h]</code>，这样得到的前缀表达式就是不一样的，但是这两种都是正确的。</li>
</ul>
<blockquote>
<p>  <strong>中缀 –&gt; 后缀</strong></p>
</blockquote>
<ul>
<li>  中缀转后缀表达式的手工写法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：(a+b)*c+d-(e+g)*h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、给所有的子表达式都加上括号</span><br><span class="line">	(((a+b)*c)+d)-((e+g)*h)</span><br><span class="line"><span class="number">2</span>、遇到左括号跳过，遇到右括号就将子表达式的符号提到括号后面，并去掉括号</span><br><span class="line">	(((a+b)*c)+d)-((e+g)*h)</span><br><span class="line">==&gt; (((ab+)*c)+d)-((e+g)*h)</span><br><span class="line">==&gt; ((ab+c*)+d)-((e+g)*h)</span><br><span class="line">==&gt; (ab+c*d+)-((e+g)*h)</span><br><span class="line">==&gt; (ab+c*d+)((e+g)*h)-</span><br><span class="line">==&gt; (ab+c*d+)-((eg+)*h)</span><br><span class="line">==&gt; (ab+c*d+)-(eg+h*)</span><br><span class="line">==&gt; (ab+c*d+)(eg+h*)-</span><br><span class="line">==&gt; ab+c*d+eg+h*-</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">位运算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-17 10:58:27" itemprop="dateCreated datePublished" datetime="2021-08-17T10:58:27+08:00">2021-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-25 10:47:10" itemprop="dateModified" datetime="2021-10-25T10:47:10+08:00">2021-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><blockquote>
<p>  <strong>原码、反码、补码的关系</strong></p>
</blockquote>
<p><strong>正数：</strong></p>
<ul>
<li>  三码合一</li>
</ul>
<p><strong>负数：</strong></p>
<ul>
<li>  负数的反码是在其原码的基础上，符号位不变，其余各位取反。</li>
<li>  负数的补码是在反码的基础上+1</li>
</ul>
<hr>
<h1 id="1-位运算基本操作"><a href="#1-位运算基本操作" class="headerlink" title="1    位运算基本操作"></a>1    位运算基本操作</h1><blockquote>
<ul>
<li>  与：<code>&amp;</code></li>
<li>  或：<code>|</code></li>
<li>  异或：<code>^</code></li>
<li>  取反：<code>~</code></li>
<li>  左移：<code>&lt;&lt;</code></li>
<li>  右移：<code>&gt;&gt;</code></li>
<li>  无符号右移：<code>&gt;&gt;&gt;</code></li>
</ul>
</blockquote>
<h2 id="1-1-与、或、异或、取反"><a href="#1-1-与、或、异或、取反" class="headerlink" title="1.1    与、或、异或、取反"></a>1.1    与、或、异或、取反</h2><blockquote>
<p>  <strong>逻辑运算符 与 位运算符 中的 <code>&amp;</code> 和 <code>|</code></strong></p>
</blockquote>
<ul>
<li>  位运算符是对操作数的二进制位进行运算，操作数和计算结果都是<strong>整型</strong>；</li>
<li>  逻辑运算符的操作数和计算结果都是<strong>布尔类型</strong>。</li>
</ul>
<blockquote>
<p>  <strong>常用的位运算符</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">实例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移</td>
<td align="center"><code>4&lt;&lt;2</code></td>
<td align="center">16</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">右移</td>
<td align="center"><code>4&gt;&gt;1</code></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;&gt;</code></td>
<td align="center">无符号右移</td>
<td align="center"><code>4&gt;&gt;&gt;1</code></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="center">与</td>
<td align="center"><code>4 &amp; 2</code></td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">`</td>
<td align="center"><code>或</code></td>
<td align="center">` 4</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">异或</td>
<td align="center"><code>4 ^ 2</code></td>
<td align="center">6</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center">取反</td>
<td align="center"><code>-4</code></td>
<td align="center">-5</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>位运算符规则1</strong></p>
</blockquote>
<ul>
<li>  &amp; ：两个二进制位只有全为 1 时结果为 1 ，否则结果为 0 。</li>
<li>  | ：两个二进制位只要有一个为 1 那么结果就为 1 ，否则结果为 0 。</li>
<li>  ^ ：任何相同二进制位进行 ^ 运算，结果是 0；不相同二进制位 ^ 运算结果是 1 。【同0异1】</li>
<li>  ~ ：取反。0 变 1，1 变 0 。</li>
</ul>
<p><strong>助记</strong>：记忆 <code>&amp;</code> 和 <code>|</code> 时，可以类比的把 1 看做 TRUE，0 看做 FALSE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 和 1 之间的 &amp; 和 | 分别都有三种情况：</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 1 视为 true， 0 视为 false，则可得到如下转化关系</span></span><br><span class="line"><span class="literal">false</span> &amp; <span class="literal">false</span> = <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span> &amp; <span class="literal">true</span> = <span class="literal">false</span></span><br><span class="line"><span class="literal">true</span> &amp; <span class="literal">true</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，| 的三种情况为：</span></span><br><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">================</span><br><span class="line"><span class="literal">false</span> | <span class="literal">false</span> = <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span> | <span class="literal">true</span> = <span class="literal">true</span></span><br><span class="line"><span class="literal">true</span> | <span class="literal">true</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//与</span></span><br><span class="line">        System.out.println(<span class="number">3</span> &amp; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        System.out.println(<span class="number">3</span> | <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//异或</span></span><br><span class="line">        System.out.println(<span class="number">3</span> ^ <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//取反</span></span><br><span class="line">        System.out.println(~<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">-<span class="number">4</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>分析</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>） <span class="number">3</span> &amp; <span class="number">4</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 4的二进制</span></span><br><span class="line">	</span><br><span class="line">	&amp;运算：有<span class="number">0</span>则<span class="number">0</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		</span><br><span class="line">	&amp;</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br><span class="line">	------------------------------------------------</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">	结果是：<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>） <span class="number">3</span> | <span class="number">4</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 4的二进制</span></span><br><span class="line">	</span><br><span class="line">	|运算：有<span class="number">1</span>则<span class="number">1</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		</span><br><span class="line">	&amp;</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br><span class="line">	------------------------------------------------</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000111</span></span><br><span class="line">	结果是：<span class="number">7</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span>） <span class="number">3</span> ^ <span class="number">4</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 4的二进制</span></span><br><span class="line">	</span><br><span class="line">	^运算：相同为<span class="number">0</span>，不同为<span class="number">1</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		</span><br><span class="line">	&amp;</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span></span><br><span class="line">	------------------------------------------------</span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000111</span></span><br><span class="line">	结果是：<span class="number">7</span></span><br></pre></td></tr></table></figure>





<h2 id="1-2-左移和右移"><a href="#1-2-左移和右移" class="headerlink" title="1.2    左移和右移"></a>1.2    左移和右移</h2><h3 id="1-2-1-左移"><a href="#1-2-1-左移" class="headerlink" title="1.2.1    左移"></a>1.2.1    左移</h3><blockquote>
<p>  <strong>语法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 &lt;&lt; 位数</span><br></pre></td></tr></table></figure>

<p>将符号左边的操作数左移指定的位数。</p>
<ul>
<li>  首先将左边的操作数转为二进制。</li>
<li>  然后按照要求左移指定位数，左边最高位丢弃，右边补齐0。</li>
</ul>
<blockquote>
<p>  <strong>例子：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> &lt;&lt; <span class="number">2</span></span><br><span class="line"><span class="comment">// 3的二进制：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span></span><br><span class="line"><span class="comment">// 左移2位，左边最高位丢弃，右边补齐0：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001100</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-右移"><a href="#1-2-2-右移" class="headerlink" title="1.2.2    右移"></a>1.2.2    右移</h3><blockquote>
<p>  <strong>语法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 &gt;&gt; 位数</span><br></pre></td></tr></table></figure>

<p>将符号左边的操作数右移指定的位数。</p>
<ul>
<li>  首先将左边的操作数转为二进制。</li>
<li>  然后按照要求右移指定位数，<strong>最高位为 0，左边补齐 0；最高为为 1，左边补齐 1</strong>。</li>
</ul>
<blockquote>
<p>  <strong>例子：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 24的二进制：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span></span><br><span class="line"><span class="comment">// 右移2位，最高位是0，左边补齐0；最高位是1，左边补齐1：</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000110</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-3-无符号数右移"><a href="#1-2-3-无符号数右移" class="headerlink" title="1.2.3    无符号数右移"></a>1.2.3    无符号数右移</h3><blockquote>
<p>  <strong>语法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 &gt;&gt;&gt; 拉数</span><br></pre></td></tr></table></figure>

<p>将符号左边的操作数右移指定的位数。</p>
<ul>
<li>  首先将左边的操作数转为二进制。</li>
<li>  然后按照要求右移指定位数，<strong>无论最高位是 0 还是 1 左边补齐 0</strong>。</li>
</ul>
<h3 id="1-2-4-程序测试"><a href="#1-2-4-程序测试" class="headerlink" title="1.2.4    程序测试"></a>1.2.4    程序测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	位运算测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// &lt;&lt; 左移1位即左边数乘以2的1次方，左移2位即左边数乘以2的2次方，以此类推</span></span><br><span class="line">		System.out.println(<span class="number">3</span> &lt;&lt; <span class="number">2</span>); </span><br><span class="line">		<span class="comment">// &gt;&gt; 右移1位即左边数除以2的1次方，右移2位即左边数除以2的2次方，以此类推</span></span><br><span class="line">		System.out.println(<span class="number">24</span> &gt;&gt; <span class="number">2</span>); </span><br><span class="line">		<span class="comment">// 负数转成二进制要用补码，最终将补码右移，再转成原码</span></span><br><span class="line">		System.out.println(-<span class="number">24</span> &gt;&gt; <span class="number">2</span>); </span><br><span class="line">		<span class="comment">// 无符号数右移无论最高位是0还是1左边都补齐0</span></span><br><span class="line">		System.out.println(<span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">		System.out.println(-<span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">-<span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1073741818</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>） <span class="number">3</span>&lt;&lt;<span class="number">2</span></span><br><span class="line">	<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 3的二进制</span></span><br><span class="line">	左移两位</span><br><span class="line">    <span class="number">00000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0000001100</span></span><br><span class="line">	结果是：<span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>） <span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">    计算出<span class="number">24</span>的二进制码如下（计算机中所有数据都以补码的形式保存）：</span><br><span class="line">    正数的补码与原码相同！</span><br><span class="line"> </span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 原码 </span></span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 补码</span></span><br><span class="line"></span><br><span class="line">	补码右移<span class="number">2</span>位，左边补<span class="number">0</span></span><br><span class="line">	<span class="number">0000000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000110</span>	</span><br><span class="line">	结果是：<span class="number">6</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span>） -<span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">    负数的补码等于反码 +<span class="number">1</span></span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 原码 </span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100111</span>		<span class="comment">// 反码</span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11101000</span>		<span class="comment">// 补码</span></span><br><span class="line">	补码右移两位，左边补<span class="number">1</span></span><br><span class="line">    <span class="number">1111111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111010</span></span><br><span class="line">	</span><br><span class="line">    得到右移的结果后，存储到计算机中的仍然是补码，开发人员在判断时还需要将补码转为原码</span><br><span class="line">    原码 = （补码 - <span class="number">1</span>） + 取反</span><br><span class="line">    </span><br><span class="line">    <span class="number">1111111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111001</span>		<span class="comment">// 减一操作</span></span><br><span class="line">    <span class="number">1000000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000110</span>		<span class="comment">// 取反(符号位不变)</span></span><br><span class="line">    结果是：-<span class="number">6</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>） <span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">    无符号右移，由于 <span class="number">24</span> 为正数，其方法等价于 <span class="number">24</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">    结果是：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="number">5</span>） -<span class="number">24</span> &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">    计算出 -<span class="number">24</span> 的补码如下</span><br><span class="line">    <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span>		<span class="comment">// 原码 </span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11100111</span>		<span class="comment">// 反码</span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11101000</span>		<span class="comment">// 补码</span></span><br><span class="line">    右移两位，无论最高位是<span class="number">0</span>还是<span class="number">1</span>，左边补<span class="number">0</span></span><br><span class="line">    <span class="number">0011111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111010</span></span><br><span class="line">    对于正数来说，补码与原码相同</span><br><span class="line">    结果：</span><br><span class="line">    将二进制 <span class="number">0011111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111010</span> 转换为十进制的结果是：<span class="number">1073741818</span></span><br></pre></td></tr></table></figure>





<h3 id="1-2-5-总结（重要）"><a href="#1-2-5-总结（重要）" class="headerlink" title="1.2.5    总结（重要）"></a>1.2.5    总结（重要）</h3><p>在位运算中</p>
<ul>
<li>  <code>&lt;&lt;</code> 左移 1 位即左边数乘以 2^1^ ，左移2位即左边数乘以2^2^ ，以此类推。</li>
<li>  <code>&gt;&gt;</code> 右移 1 位即左边数除以 2^1^ ，右移2位即左边数除以2^2^ ，以此类推。</li>
</ul>
<hr>
<h1 id="2-位运算应用"><a href="#2-位运算应用" class="headerlink" title="2    位运算应用"></a>2    位运算应用</h1><h2 id="2-1-奇偶判断"><a href="#2-1-奇偶判断" class="headerlink" title="2.1    奇偶判断"></a>2.1    奇偶判断</h2><ul>
<li>  位运算是直接操作二进制位，效率较高，一些算法会采用位运算。</li>
<li>  奇偶判断是判断一个是奇数还是偶数，如何使用位运算实现呢？</li>
</ul>
<blockquote>
<p>  <strong>原理：</strong></p>
</blockquote>
<ol>
<li> 位运算。&amp; 运算的特点是：两个二进制位只要有一个为 0 那么结果就为 0，否则结果为 1。</li>
<li> <strong>二进制的最低位为 1 一定是奇数，为 0 则一定是偶数</strong>，我们让某个数和 1 进行与运算，结果为 1 则是奇数，为 0 则是偶数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int i = 6;</span><br><span class="line">int j = 7;</span><br><span class="line">// 对应的二进制</span><br><span class="line">6	0110</span><br><span class="line">7	0111</span><br><span class="line"></span><br><span class="line">原理解释：二进制的最低位为 1 一定是奇数，为 0 则一定是偶数</span><br><span class="line">7 = 0111 = 1*2^0 + 1*2^1 + 1*2^2 + 0*2^3 + ...</span><br><span class="line">6 = 0110 = 0*2^0 + 1*2^1 + 1*2^2 + 0*2^3 + ...</span><br><span class="line">除了最低位外，其余每位上的数都是2的倍数。也就是说，除了最低位外，</span><br><span class="line">其余数都是偶数，两个偶数之和还是偶数，所以每个二进制数是奇数还是</span><br><span class="line">偶数是由最低位决定的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 奇偶判断的方法：让这个数和 1 相与（&amp;）</span><br><span class="line">1） 6 &amp; 1 = 0</span><br><span class="line">	0110</span><br><span class="line">	0001</span><br><span class="line">	-------</span><br><span class="line">	0000	==&gt; 结果是 0</span><br><span class="line"></span><br><span class="line">2） 7 &amp; 1 = 1</span><br><span class="line">	0111</span><br><span class="line">	0001</span><br><span class="line">	-------</span><br><span class="line">	0001	==&gt; 结果是 1</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="comment">//和1与运算，结果为1则为奇数</span></span><br><span class="line">        System.out.println(x &amp; a);</span><br><span class="line">        <span class="comment">//和1与运算，结果为0则为偶数</span></span><br><span class="line">        System.out.println(y &amp; a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-2-两数交换"><a href="#2-2-两数交换" class="headerlink" title="2.2    两数交换"></a>2.2    两数交换</h2><blockquote>
<p>  <strong>不用二进制实现两数交换</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//======交换两个数方法1：使用中间变量======</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = tmp;</span><br><span class="line">        </span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>使用二进制的异或运算实现两数交换</strong></p>
</blockquote>
<ul>
<li>  <strong>原理</strong>：一个数对自己异或一次，再异或另一个数，结果为另一个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">5</span>, n = <span class="number">10</span>;</span><br><span class="line"><span class="number">0000</span> <span class="number">0101</span>	<span class="comment">// m</span></span><br><span class="line"><span class="number">0000</span> <span class="number">1010</span>	<span class="comment">// n</span></span><br><span class="line"></span><br><span class="line">m^m</span><br><span class="line">    <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">    <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">    ------------</span><br><span class="line">    <span class="number">0000</span> <span class="number">0000</span>  ==&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">m^m^n</span><br><span class="line">	<span class="number">0000</span> <span class="number">0000</span> </span><br><span class="line">	<span class="number">0000</span> <span class="number">1010</span></span><br><span class="line">	---------------</span><br><span class="line">	<span class="number">0000</span> <span class="number">1010</span>	==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//======交换两个数方法2：使用异或运算======</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="comment">// 先测试异或运算的特点 </span></span><br><span class="line">		<span class="comment">// 一个数对自己异或一次，再异或另一个数，结果为另一个数</span></span><br><span class="line">		System.out.println(m ^ m ^ n); 	<span class="comment">// m变成了n，输出10</span></span><br><span class="line">		System.out.println(n ^ n ^ m ); <span class="comment">// n变成了m，输出5</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 下边通过异或交换变量的值</span></span><br><span class="line">		<span class="comment">// 下边是m和n没有交换之前的异或，存入m</span></span><br><span class="line">		m = m ^ n ;</span><br><span class="line">		<span class="comment">//下边的赋值语句相当于n=m ^ n ^ n，将m的值赋值给了n</span></span><br><span class="line">		n = m ^ n ;</span><br><span class="line">		<span class="comment">//此时n的值为m，所以m ^ n即m ^ m ^  n ，将n的值赋值给了m</span></span><br><span class="line">		m = m ^ n ;</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		System.out.println(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用二进制的好处：<ol>
<li> 不用额外创建空间保存临时变量；</li>
<li> 使用二进制数据进行运算，执行速度较快。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="3-位运算常见的规律（LeetCode刷题常用）"><a href="#3-位运算常见的规律（LeetCode刷题常用）" class="headerlink" title="3    位运算常见的规律（LeetCode刷题常用）"></a>3    位运算常见的规律（LeetCode刷题常用）</h1><h2 id="左移和右移"><a href="#左移和右移" class="headerlink" title="左移和右移"></a>左移和右移</h2><p>在位运算中</p>
<ul>
<li>  <code>&lt;&lt;</code> 左移 1 位即左边数乘以 2^1^ ，左移2位即左边数乘以2^2^ ，以此类推。</li>
<li>  <code>&gt;&gt;</code> 右移 1 位即左边数除以 2^1^ ，右移2位即左边数除以2^2^ ，以此类推。</li>
</ul>
<h2 id="与（-amp-）运算"><a href="#与（-amp-）运算" class="headerlink" title="与（&amp;）运算"></a>与（&amp;）运算</h2><blockquote>
<p>  <strong>任意数 和 1 相与（&amp;）</strong></p>
</blockquote>
<ul>
<li>任意数 和 1 相与（&amp;），结果为 1 是奇数，结果为 0 是偶数。</li>
</ul>
<blockquote>
<p>  <strong>n &amp; (n-1)</strong></p>
</blockquote>
<ul>
<li>  n 和 (n−1) 解析：（n-1）就是将二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。</li>
<li>  <code>n &amp; (n - 1)</code> 解析：<code>n &amp; (n - 1)</code> 就是将二进制数字 n 最右边的 1 变成 0 ，其余不变。</li>
</ul>
<p><img src="/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/9bc8ab7ba242888d5291770d35ef749ae76ee2f1a51d31d729324755fc4b1b1c-Picture10.png" alt="Picture10.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/10/LockSupport/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/10/LockSupport/" class="post-title-link" itemprop="url">LockSupport</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-10 18:16:57" itemprop="dateCreated datePublished" datetime="2021-08-10T18:16:57+08:00">2021-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-21 21:27:31" itemprop="dateModified" datetime="2021-08-21T21:27:31+08:00">2021-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1    是什么？"></a>1    是什么？</h1><img src="/2021/08/10/LockSupport/image-20210716173307046.png" alt="image-20210716173307046" style="zoom:80%;">

<ul>
<li>  <strong>LockSupport</strong> 是 JUC 包下的一个类，也用于多线程间的通信，<strong>是 <code>wait / notify</code> 机制的改良加强版</strong>。</li>
<li>  LockSupport 是一个线程阻塞唤醒的工具类，<strong>类中所有的方法都是静态方法</strong>，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。</li>
<li>  LockSupport 提供了 <code>park()</code> 和 <code>unpark()</code> 方法实现阻塞线程和解除线程阻塞的过程。</li>
<li>  归根结底，<strong>LockSupport 调用的是 Unsafe 类中的 native 方法</strong>。</li>
<li>  LockSupport 是用来创建锁和其它同步类的基本线程阻塞原语。</li>
</ul>
<p><img src="/2021/08/10/LockSupport/image-20210716173522862.png" alt="image-20210716173522862"></p>
<hr>
<h1 id="2-为什么学-LockSupport"><a href="#2-为什么学-LockSupport" class="headerlink" title="2    为什么学 LockSupport"></a>2    为什么学 LockSupport</h1><ol>
<li> LockSupport 是学习 AQS 的前置知识。</li>
<li> 传统的 等待/唤醒 机制在某些情况下不适用。</li>
</ol>
<hr>
<h1 id="3-三组让线程等待-唤醒的方法（传统等待-唤醒方法存在的缺陷）"><a href="#3-三组让线程等待-唤醒的方法（传统等待-唤醒方法存在的缺陷）" class="headerlink" title="3    三组让线程等待/唤醒的方法（传统等待/唤醒方法存在的缺陷）"></a>3    三组让线程等待/唤醒的方法（传统等待/唤醒方法存在的缺陷）</h1><blockquote>
<ol>
<li> <strong>Object</strong>：<code>wait()</code> 和 <code>notify()</code></li>
<li> <strong>Condition</strong>：<code>await()</code> 和 <code>signal()</code></li>
<li> <strong>LockSupport</strong>：<code>park()</code> 和 <code>unpark()</code></li>
</ol>
</blockquote>
<h2 id="3-1-wait-notify"><a href="#3-1-wait-notify" class="headerlink" title="3.1    wait / notify"></a>3.1    wait / notify</h2><blockquote>
<p>  <strong>Object 类中的 wait 和 notify 方法实现线程的等待和唤醒（wait/notify 限制）</strong></p>
</blockquote>
<h3 id="正常"><a href="#正常" class="headerlink" title="正常"></a>正常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.one;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/16 18:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行结果：</span></span><br><span class="line"><span class="comment"> *      T1 come in</span></span><br><span class="line"><span class="comment"> *      T1 进入Waiting状态</span></span><br><span class="line"><span class="comment"> *      T2 come in</span></span><br><span class="line"><span class="comment"> *      T2 唤醒Waiting中的线程</span></span><br><span class="line"><span class="comment"> *      T1 被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="异常1"><a href="#异常1" class="headerlink" title="异常1"></a>异常1</h3><ul>
<li>  将 <code>wait</code> 和 <code>notify</code> 方法，两个都去掉同步代码块。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            synchronized (obj)&#123;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            synchronized (obj)&#123;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>执行结果：</strong></p>
</blockquote>
<p><img src="/2021/08/10/LockSupport/image-20210716181135743.png" alt="image-20210716181135743"></p>
<blockquote>
<p>  <strong>结论</strong></p>
</blockquote>
<ul>
<li>  <strong>Object 类中的 wait、notify、notifyAll 方法必须放在 synchronized 同步代码（同步代码块或同步方法）中才能正常使用。</strong></li>
<li>  <strong>编译时不会报错，但是运行时会抛出 <code>IllegalMonitorStateException</code> 异常。</strong>【非法监听状态异常】</li>
</ul>
<hr>
<h3 id="异常2"><a href="#异常2" class="headerlink" title="异常2"></a>异常2</h3><ul>
<li>  让 <code>notify()</code> 先于 <code>wait()</code> 执行，会导致某个线程进入 Waiting 状态后无法被唤醒，程序无法结束。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                    obj.wait();		<span class="comment">// 13行</span></span><br><span class="line"><span class="comment">//                    obj.wait(1000);      // 超时唤醒可以单独出现              </span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>执行结果</strong></p>
</blockquote>
<p><img src="/2021/08/10/LockSupport/image-20210716181509277.png" alt="image-20210716181509277"></p>
<blockquote>
<p>  <strong>代码分析</strong></p>
</blockquote>
<ol>
<li> 在线程 T1 争夺锁对象之前让其先暂停 1s，让 T2 线程能先于 T1 执行；</li>
<li> T2 线程先得到锁对象，在控制台上输出指定的内容，并随机唤醒当前锁对象维护的等待队列中的一个线程，将其移动到锁对象的同步队列中，最后执行完毕释放锁对象。（由于当前锁对象的等待队列为空，所以这里并没有发生真正的唤醒线程的过程）</li>
<li> T1 线程休眠 1s 后醒来获得锁对象，执行代码块中的方法，将指定内容打印输出到控制台上。执行到 13 行 <code>obj.wait();</code> 代码后 T1 线程被挂起。</li>
<li> 但是由于锁对象的唤醒动作已经先于阻塞动作执行了，并且在此之后锁对象也没有其它的唤醒动作了，所以 T1 会一直陷入 Waiting 状态，该行代码之后的打印输出动作也就不会被执行到。</li>
<li> 整个进程无法结束。</li>
</ol>
<blockquote>
<p>  <strong>附加</strong></p>
</blockquote>
<ul>
<li>  如果将唤醒操作设置成超时唤醒，则 <strong>wait(long timeout)</strong> 可以不用与 <code>notify()</code> 方法成对出现，也可以不用关心与 <code>notify()</code> 方法出现的顺序。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>  <code>wait()</code> 和 <code>notify()</code> 方法必须<strong>要在 synchronized 同步代码里面</strong>且<strong>成对使用</strong>，且使用时必须先 <code>wait</code> 后 <code>notify</code>。【注意这里的 <code>wait()</code> 方法一定是空参的 wait 方法】</li>
</ul>
<hr>
<h2 id="3-2-await-signal"><a href="#3-2-await-signal" class="headerlink" title="3.2    await  / signal"></a>3.2    await  / signal</h2><blockquote>
<p>  <strong>Condition 接口中的 await 和 signal 方法实现线程的等待和唤醒</strong></p>
</blockquote>
<p>与<code>Object#wait</code>、<code>Object#notify</code> 方法遇到的问题基本一样。</p>
<h3 id="正常-1"><a href="#正常-1" class="headerlink" title="正常"></a>正常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/16 18:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//            try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入Waiting状态&quot;</span>);</span><br><span class="line">                condition.await();  <span class="comment">// 当前线程被阻塞</span></span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被唤醒&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 唤醒Waiting中的线程&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行结果：</span></span><br><span class="line"><span class="comment"> *      T1 come in</span></span><br><span class="line"><span class="comment"> *      T1 进入Waiting状态</span></span><br><span class="line"><span class="comment"> *      T2 come in</span></span><br><span class="line"><span class="comment"> *      T2 唤醒Waiting中的线程</span></span><br><span class="line"><span class="comment"> *      T1 被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="异常1-1"><a href="#异常1-1" class="headerlink" title="异常1"></a>异常1</h3><p>如果注释掉 lock 和 unlock 方法，程序将会抛出 <strong>IllegalMonitorStateException</strong> 异常。</p>
<p><img src="/2021/08/10/LockSupport/image-20210716184240464.png" alt="image-20210716184240464"></p>
<h3 id="异常2-1"><a href="#异常2-1" class="headerlink" title="异常2"></a>异常2</h3><p>如果调换 <code>await()</code> 和 <code>signal()</code> 的执行顺序，将有一个线程永远处于 Waiting 状态，导致线程无法结束。</p>
<hr>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3    总结"></a>3.3    总结</h2><blockquote>
<p>  <strong>传统的 synchronized 和 Lock 实现等待唤醒的约束</strong></p>
</blockquote>
<ol>
<li> 等待和唤醒的方法必须写在锁代码块（synchronized 或 lock）中；</li>
<li> 等待 / 唤醒方法必须成对出现，成对使用。</li>
<li> 必须先等待后唤醒。如果先唤醒后等待，线程将陷入死等。</li>
</ol>
<hr>
<h2 id="3-4-park-unpark"><a href="#3-4-park-unpark" class="headerlink" title="3.4    park / unpark"></a>3.4    park / unpark</h2><blockquote>
<p>  <strong>LockSupport 类中 park 等待和 unpark 唤醒</strong></p>
</blockquote>
<ul>
<li>  见下文</li>
</ul>
<hr>
<h1 id="4-LockSupport"><a href="#4-LockSupport" class="headerlink" title="4    LockSupport"></a>4    LockSupport</h1><h2 id="4-1-常用方法"><a href="#4-1-常用方法" class="headerlink" title="4.1    常用方法"></a>4.1    常用方法</h2><p>在 LockSupport 中，通过 <code>park()</code> 和 <code>unpark(Thread thread)</code> 方法来实现阻塞和唤醒线程的操作。</p>
<p><img src="/2021/08/10/LockSupport/image-20210716203238382.png" alt="image-20210716203238382"></p>
<h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2    原理"></a>4.2    原理</h2><ul>
<li>  LockSupport 中使用了一种名为 Permit（许可证）的概念来实现阻塞和唤醒线程的功能，Permit 与线程绑定。</li>
<li>  Permit 只有两个值 1 和 0，默认是 0。</li>
<li>  0 表示线程没有许可证，1 表示线程拥有许可证。每个线程允许携带的许可证的最大上限是 1。</li>
</ul>
<h2 id="4-3-阻塞"><a href="#4-3-阻塞" class="headerlink" title="4.3    阻塞"></a>4.3    阻塞</h2><blockquote>
<p>  <strong>阻塞方法</strong></p>
</blockquote>
<ul>
<li>  <code>park()</code>：消耗一个许可证，若许可证个数为 0 则会阻塞当前线程，若许可证个数为 1 则会消耗掉一个许可证，并放行线程。</li>
<li>  <code>park(Object blocker)</code>：阻塞指定线程（会消耗掉一个许可证）</li>
</ul>
<blockquote>
<p>  <strong>阻塞原理</strong></p>
</blockquote>
<p>调用 <code>LockSupport#park()</code> 方法时，底层调用的是 <code>UNSAFE.park()</code> 方法</p>
<p><img src="/2021/08/10/LockSupport/image-20210716203521212.png" alt="image-20210716203521212"></p>
<p>默认情况 <code>permit == 0</code>，对于一个新的线程直接调用 <code>park()</code> 方法，该线程没有许可证可以被消耗，所以当前线程会直接阻塞，直到其它线程给该线程颁发一个许可证，即设置该线程的 <code>permit == 1</code> 时，该线程才会从阻塞状态中恢复运行，并消耗掉一个许可证，设置 <code>permit == 0</code> ，继续执行 <code>park()</code> 方法之后的代码。</p>
<h2 id="4-4-唤醒"><a href="#4-4-唤醒" class="headerlink" title="4.4    唤醒"></a>4.4    唤醒</h2><blockquote>
<p>  <strong>唤醒方法</strong></p>
</blockquote>
<ul>
<li>   <code>unpark(Thread thread)</code>：唤醒某个线程。</li>
</ul>
<blockquote>
<p>  <strong>唤醒原理</strong></p>
</blockquote>
<p><strong>严格意义上将并不是唤醒线程，而是给线程颁发了一个许可证，这个许可证并不会立即被消耗，而是保存在线程实例中，在遇到 park() 方法造成的阻塞时，消耗该许可证可以保证线程不被阻塞。</strong></p>
<p><img src="/2021/08/10/LockSupport/image-20210716203852897.png" alt="image-20210716203852897"></p>
<p>调用 <code>unpark(thread)</code> 方法后，设置 thread 线程的许可证 <code>permit == 1</code>（注意多次调用 <code>unpark()</code>，permit 的值不会累加，最高只能是 1），自动唤醒 thread 线程，即之前阻塞中的 <code>LockSupport.park()</code> 方法会立即返回。</p>
<h2 id="4-5-形象的理解"><a href="#4-5-形象的理解" class="headerlink" title="4.5    形象的理解"></a>4.5    形象的理解</h2><p><em>permit 许可证与线程绑定。</em></p>
<p><em>permit  是一张万能的通行证，可以提前发给线程，线程每遇到一个关卡（阻塞）就需要消耗一张通行证。如果有则通过关卡，没有则不让通过，即阻塞。且每个线程最大只能持有一张许可证。</em></p>
<p>线程阻塞时需要消耗凭证（permit），这个凭证每个线程最多只有 1 个。</p>
<ol>
<li>当调用 <code>park()</code> 方法时，<ul>
<li>  如果有凭证，则会直接消耗掉这个凭证，然后程序继续执行。</li>
<li>  如果无凭证，则必须阻塞等待凭证可用</li>
</ul>
</li>
<li> 而 <code>unpark()</code> 正好相反，它会增加一个凭证，但凭证最多只能有一个，累加无效。</li>
</ol>
<hr>
<h1 id="5-代码"><a href="#5-代码" class="headerlink" title="5    代码"></a>5    代码</h1><blockquote>
<p>  <strong>LockSupport 的优势</strong></p>
</blockquote>
<ul>
<li>  优势1：不需要锁块，唤醒和阻塞的代码可以写在任意位置。（之前的两组方法都只能写在锁代码块中）</li>
<li>  优势2：支持 <code>unpark()</code> 可以在 <code>park()</code> 之前执行（先唤醒后等待）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in \t&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            LockSupport.park(); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 被唤醒 \t&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;唤醒&quot;</span> + t1.getName() + <span class="string">&quot;线程&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1); </span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>代码分析</strong></p>
</blockquote>
<ol>
<li> T1 线程即使抢到 CPU 资源后也会立即睡眠 3s，所以 T2 线程中的内容必定先于 T1 执行。</li>
<li> T2 调用 <code>unpark()</code> 方法给 t1 线程发放了一个通行证；</li>
<li> 3s 后 T1 线程睡醒，接着上次的位置继续执行，打印 <code>... come in ...</code> 在控制台上，接着执行 <code>park()</code> 方法阻塞线程，但是由于此时 T1 线程是有一个通行证 permit 的，所以这个阻塞校验可以通过，紧接着继续执行下面的操作。</li>
</ol>
<p><strong>最终的运行结果为</strong>：</p>
<p><img src="/2021/08/10/LockSupport/image-20210716213814924.png" alt="image-20210716213814924"></p>
<p>可以看到：<code>LockSupport.park()</code>前后执行时间是一样的，也就说明阻塞没有生效。</p>
<hr>
<h1 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6    面试题"></a>6    面试题</h1><blockquote>
<ol>
<li> <strong>为什么可以先唤醒线程后阻塞线程？</strong></li>
</ol>
</blockquote>
<p><code>unpark()</code> 方法并不是直接唤醒阻塞的线程，而是相当于给线程发放了一个万能的通行证，只要有这个通行证在，线程在遇到阻塞时，直接消费这个通行证就可以通过而不会被阻塞。</p>
<blockquote>
<ol start="2">
<li> <strong>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</strong></li>
</ol>
</blockquote>
<p>因为一个线程持有通行证的最大数量只能为 1，所以调用两次 <code>unpark()</code> 和调用一次 <code>unpark()</code> 效果一样，最多只能获得一个通行证。而调用两次 <code>park()</code> 则会消费两个通行证，证不够就不能放行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/BlockingQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/09/BlockingQueue/" class="post-title-link" itemprop="url">BlockingQueue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-09 15:45:50" itemprop="dateCreated datePublished" datetime="2021-08-09T15:45:50+08:00">2021-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-19 20:20:18" itemprop="dateModified" datetime="2021-10-19T20:20:18+08:00">2021-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>阻塞队列；BlockingQueue</strong></p>
</blockquote>
<h1 id="阻塞队列的由来"><a href="#阻塞队列的由来" class="headerlink" title="阻塞队列的由来"></a>阻塞队列的由来</h1><blockquote>
<p>  <strong>生产者-消费者模式</strong></p>
</blockquote>
<ul>
<li>  我们假设一种场景，生产者一直生产资源，消费者一直消费资源，资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的 <strong>生产者-消费者模式</strong>。</li>
<li>  该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</li>
<li>  我们自己编码实现这个模式的时候，因为需要让多个线程操作共享变量（即资源），所以很容易引发线程安全问题，造成重复消费和死锁，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个等待-唤醒逻辑都需要自己实现。</li>
</ul>
<blockquote>
<p>  <strong>为什么需要 BlockingQueue？有什么好处？</strong></p>
</blockquote>
<ul>
<li>  在多线程领域，所谓阻塞，就是指在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会被唤醒。[但是这些都是需要人工去判断挂起和唤醒的] [<strong>手动挂起和唤醒</strong>]</li>
<li>  在 juc 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，这会给开发带来不小的难度。</li>
<li>  由程序员手动去判断阻塞和唤醒条件是非常容易出错的，所以 JDK 中新增了 **阻塞队列(BlockingQueue)**，你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</li>
<li>  好处是我们不需要关心什么时候阻塞线程，什么时候唤醒线程，因为这一切都由 BlockingQueue 自动实现了。[<strong>自动挂起和唤醒</strong>]</li>
<li>  BlockingQueue⼀般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。BlockingQueue就是存放元素的容器。</li>
</ul>
<hr>
<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><ol>
<li> 阻塞队列首先是一个队列，满足队列 FIFO 的特性；</li>
<li>阻塞队列<ul>
<li>  当阻塞队列为空时，从队列中<strong>获取</strong>元素的操作将会被阻塞。</li>
<li>  当阻塞队列为满时，往队列里<strong>添加</strong>元素的操作将会被阻塞。</li>
</ul>
</li>
<li> 阻塞队列空了消费者阻塞，满了生产者阻塞。</li>
</ol>
<p><img src="/2021/08/09/BlockingQueue/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="阻塞队列"></p>
<hr>
<h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>
<table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center"><code>add(e)</code></td>
<td align="center"><code>offer(e)</code></td>
<td align="center"><code>put(e)</code></td>
<td align="center"><code>offer(e, time, unit)</code></td>
</tr>
<tr>
<td align="center">移出</td>
<td align="center"><code>remove()</code></td>
<td align="center"><code>poll()</code></td>
<td align="center"><code>take()</code></td>
<td align="center"><code>poll(time, unit)</code></td>
</tr>
<tr>
<td align="center">检查</td>
<td align="center"><code>element()</code></td>
<td align="center"><code>peek()</code></td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ul>
<li>  检查：检查队列是否为空，不为空则查到队头元素的值</li>
</ul>
<blockquote>
<p>  <strong>抛出异常：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，则抛出异常。</p>
<ul>
<li>  当阻塞队列满时，再往队列里插入元素会抛出 <strong>IllegalStateException: Queue full</strong> 异常；</li>
<li>  当阻塞队列空时，再从队列里删除元素会抛出 <strong>NoSuchElementException</strong> 异常。</li>
</ul>
<blockquote>
<p>  <strong>返回特殊值：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，会返回一个特殊值。</p>
<ul>
<li>  对于插入方法，成功返回 <strong>true</strong> 失败返回 <strong>false</strong>；</li>
<li>  对于移除方法，成功返回出队的元素，队列为空就返回 <strong>null</strong>。</li>
</ul>
<blockquote>
<p>  <strong>一直阻塞：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，则一直阻塞或者响应中断。</p>
<ul>
<li>  当阻塞队列满时，生产者线程继续往队列里 put 元素，队列会一直阻塞生产线程；</li>
<li>  当阻塞队列空时，消费者线程继续试图从队列中 take 元素，队列会一直阻塞消费者线程直到队列可用。</li>
</ul>
<blockquote>
<p>  <strong>超时退出：</strong></p>
</blockquote>
<p>如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 <code>true / false</code>。</p>
<ul>
<li>  当阻塞队列满时，继续向队列中添加元素，会阻塞生产者线程一段时间，若该段时间内队列中可以添加元素了，则添加成功，超过时间后生产者线程会退出，返回一个特定值告知该操作是否成功。</li>
<li>  当阻塞队列空时，继续从队列中移出元素，会阻塞消费者线程一段时间，若该段时间内可以从队列中移除元素了，则移除成功，超过时间后消费者线程会退出，返回一个特定值告知该操作是否成功。</li>
</ul>
<blockquote>
<p>  <strong>注意</strong></p>
</blockquote>
<ul>
<li>  不能往阻塞队列中插⼊null，会抛出空指针异常。</li>
<li>  可以访问阻塞队列中的任意元素，调用 <code>remove(o)</code> 可以将队列之中的特定对象移除，但并不⾼效，尽量避免使用。</li>
</ul>
<hr>
<h1 id="BlockingQueue-架构"><a href="#BlockingQueue-架构" class="headerlink" title="BlockingQueue 架构"></a>BlockingQueue 架构</h1><img src="/2021/08/09/BlockingQueue/BlockingQueue.png" alt="BlockingQueue">



<ul>
<li>  <strong>ArrayBlockingQueue：由数组结构组成的有界阻塞队列。类似于ArrayList</strong></li>
<li>  <strong>LinkedBlockedQueue：由链表结构组成的有界阻塞队列（但大小默认值为 Integer.MAX_VALUE）。类似于 LinkedArrayList</strong></li>
<li>  PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li>
<li>  DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</li>
<li>  <strong>SynchronousQueue：不存储元素的阻塞队列。</strong></li>
<li>  LinkedTransferQueue：由链表结构组成的无界阻塞队列。</li>
<li>  LinkedBlockingDeque：由链表结构组成的双向阻塞队列。</li>
</ul>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><blockquote>
<p>  <strong>构造方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span>&#123;</span><br><span class="line">    <span class="comment">//...省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  ArrayBlockingQueue 是由数组结构组成的<strong>有界</strong>阻塞队列。</li>
<li>  内部结构是<strong>数组</strong>，故具有数组的特性。</li>
<li>  可以初始化队列大小， 且一旦初始化不能改变。构造方法中的 <strong>fair</strong> 表示控制对象的内部锁是否采用公平锁，默认是非公平锁。</li>
</ul>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><ul>
<li>  由链表结构组成的<strong>有界</strong>阻塞队列。默认队列的大小是 <strong>Integer.MAX_VALUE</strong>，也可以指定大小。</li>
<li>  内部结构是链表，具有链表的特性。</li>
<li>  此队列按照先进先出的原则对元素进行排序。</li>
</ul>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><ul>
<li>  这个队列比较特殊，没有任何内部容量，甚至连一个队列的容量都没有。并且每个 <code>put</code> 必须等待一个 <code>take</code>，反之亦然。</li>
</ul>
<blockquote>
<p>  <strong>SynchronousQueue 与容量为 1 的 ArrayBlockingQueue、LinkedBlockingQueue 有什么区别？</strong></p>
</blockquote>
<p>在 SynchronousQueue 中：</p>
<ul>
<li>  <code>iterator()</code> 永远返回空，因为里面没有东西；</li>
<li>  <code>isEmpty()</code> 永远返回 true；</li>
<li>  <code>peek()</code> 永远返回 <strong>null</strong>；</li>
<li>  <code>put()</code> 往 queue 放进去一个 element 以后就一直 wait，直到有其他 thread 进来把这个 element 取走。</li>
<li>  <code>offer()</code> 往 queue 里放一个 element 后立即返回，如果碰巧这个 element 被另一个thread取走了，<code>offer()</code> 返回 true，认为 <code>offer()</code> 成功；否则返回 false。</li>
<li>  <code>take()</code> 取出并且 remove 掉 queue 里 的 element，取不到东西他会一直等。</li>
<li>  <code>poll()</code> 取出并且 remove 掉 queue 里的 element，只有到碰巧另外一个线程正在往 queue 里 offer 数据或者 put 数据的时候，该方法才会取到东西。否则立即返回 null。</li>
<li>  <code>remove()</code> &amp; <code>removeAll()</code> 永远返回 false。</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>  PriorityBlockingQueue 不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。</li>
<li>  因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</li>
<li>  对于使用默认大小的LinkedBlockingQueue也是一样的。</li>
</ul>
<hr>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><h2 id="ArrayBlockingQueue-1"><a href="#ArrayBlockingQueue-1" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><h3 id="Case1：add-remove"><a href="#Case1：add-remove" class="headerlink" title="Case1：add / remove"></a>Case1：add / remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blockingQueue.add(<span class="string">&quot;A&quot;</span>);    <span class="comment">// 正常添加返回值为Boolean类型的true</span></span><br><span class="line">        blockingQueue.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        blockingQueue.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="comment">//        blockingQueue.add(&quot;X&quot;);   // 队列满时再向队列时添加元素会抛出异常：IllegalStateException: Queue full</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*检索*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> blockingQueue.element();   <span class="comment">// 正常检索返回队首元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.remove();     <span class="comment">// 正常出队返回值为队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.remove();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.remove();</span><br><span class="line"><span class="comment">//        String q4 = blockingQueue.remove();   // 队列空时继续出队会抛出异常：NoSuchElementException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  队列满时继续入队</li>
</ul>
<p><img src="/2021/08/09/BlockingQueue/image-20210713172132018.png" alt="image-20210713172132018"></p>
<ul>
<li>  队列为空时继续出队</li>
</ul>
<p><img src="/2021/08/09/BlockingQueue/image-20210713172625099.png" alt="image-20210713172625099"></p>
<h3 id="Case2：offer-poll"><a href="#Case2：offer-poll" class="headerlink" title="Case2：offer / poll"></a>Case2：offer / poll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blockingQueue.offer(<span class="string">&quot;A&quot;</span>);    <span class="comment">// 正常添加返回值为Boolean类型的true</span></span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;X&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*检索*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> blockingQueue.peek();   <span class="comment">// 正常检索返回队首元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.poll();     <span class="comment">// 正常出队返回值为队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.poll();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.poll();</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果：</span></span><br><span class="line"><span class="comment"> *      false</span></span><br><span class="line"><span class="comment"> *      null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Case3：put-take"><a href="#Case3：put-take" class="headerlink" title="Case3：put / take"></a>Case3：put / take</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;A&quot;</span>);    <span class="comment">// 正常添加无返回值</span></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;X&quot;);     // 当队列满时，继续入队元素，就会阻塞当前线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.take();     <span class="comment">// 正常出队返回队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">q4</span> <span class="operator">=</span> blockingQueue.take();       <span class="comment">// 当队列空时，继续出队，也会阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Case4：offer-poll"><a href="#Case4：offer-poll" class="headerlink" title="Case4：offer / poll"></a>Case4：offer / poll</h3><p><img src="/2021/08/09/BlockingQueue/image-20210713173931729.png" alt="image-20210713173931729"></p>
<p><img src="/2021/08/09/BlockingQueue/image-20210713174208204.png" alt="image-20210713174208204"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc.blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/13 17:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> blockingQueue.offer(<span class="string">&quot;A&quot;</span>,<span class="number">2</span>, TimeUnit.SECONDS);    <span class="comment">// 正常添加返回值为Boolean类型的true</span></span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;X&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS);  <span class="comment">// 队列满时继续添加，会阻塞当前线程 2s，之后继续运行线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q1</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);    <span class="comment">// 正常出队返回值为队首元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">q2</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="type">String</span> <span class="variable">q3</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="type">String</span> <span class="variable">q4</span> <span class="operator">=</span> blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);    <span class="comment">// 队列空时继续出队，会阻塞当前线程线程2s，</span></span><br><span class="line">        <span class="comment">// 如果2s后队列还为空，则返回null，若2s后队列被其它线程入队了值，则返回队首的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="SynchronousQueue-1"><a href="#SynchronousQueue-1" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p><strong>原理</strong></p>
<ul>
<li>  SynchronousQueue 没有容量。与其它 BlockingQueue 不同，SynchronousQueue 是一个不存储元素的 BlockingQueue，每一个 put 元素操作必须等待一个 take 操作，否则不能继续添加元素，反之亦然。</li>
<li>  也可以理解为 SynchronousQueue 容量为 1，即每生产一个必须等消费之后才能继续生产下一个。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产者线程*/</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put A&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.put(<span class="string">&quot;A&quot;</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put B&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.put(<span class="string">&quot;B&quot;</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put C&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.put(<span class="string">&quot;C&quot;</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*消费者线程*/</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">3000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.take(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.take(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; blockingQueue.take(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;customer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码分析</strong></p>
<ol>
<li> main 线程启动，创建 SynchronousQueue 类的实例对象，创建两个线程，生产者线程和消费者线程并发执行。</li>
<li> 生产者线程连续生产 3 个元素，但是由于 blockingQueue 是一个同步队列，最大容量是 1，所以只能添加进去一个，然后被挂起；</li>
<li> 消费者线程在 3s 后消费一个线程，消费完成后，生产者线程才能被唤醒继续生产。</li>
</ol>
<p>所有程序的输出结果是：</p>
<ol>
<li> 生产者线程添加 “A” 到同步阻塞队列，然后被挂起，等待队列中元素被消费；</li>
<li> 3s 后消费者线程被唤醒消费队列中队首元素，然后继续挂起 2s；</li>
<li> 生产者线程检测到阻塞队列为空，生产 “B” 到同步队列中，等待队列中的元素被消费；</li>
<li> 2s 后消费者线程被唤醒消费队列中队首元素，然后继续挂起 1s；</li>
<li> 生产者线程检测到阻塞队列为空，生产 “C” 到同步队列中，等待队列中的元素被消费，生产线程结束；</li>
<li> 1s 后消费者线程被唤醒消费队列中队首元素，消费者线程结束；</li>
<li> main 线程结束，程序执行完成。</li>
</ol>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">producer put A</span><br><span class="line">producer put B</span><br><span class="line">producer put C</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="用在哪里"><a href="#用在哪里" class="headerlink" title="用在哪里"></a>用在哪里</h1><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/7/14 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 知识点： volatile/CAS/atomicInteger/BlockQueue/线程交互/原子引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData3</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">// 默认开启，进行 生产+消费 。需要被多个线程知道，使用 volatile 修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="literal">null</span>;     <span class="comment">// 定义为接口类型，可以接受该接口的所有实现类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造器注入*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyData3</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName()); <span class="comment">// 通过反射的方式获取调用对象的全限定类名，方便出错时检查</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flag == true</span></span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet()+<span class="string">&quot;&quot;</span>; <span class="comment">// i++</span></span><br><span class="line">            result = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);    <span class="comment">// 加入阻塞队列，并返回执行结果</span></span><br><span class="line">            <span class="keyword">if</span> (result)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;加入队列成功***&quot;</span> + data);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;加入队列失败***&quot;</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flag == false</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;生产线程执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == result)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;超过2s没有取到阻塞队列中的数据，消费线程退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费&quot;</span> + result +<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProdConsumerDemo03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyData3</span> <span class="variable">myData3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData3</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;String&gt;(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产线程启动&quot;</span>);</span><br><span class="line">                myData3.product();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Product&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费线程启动&quot;</span>);</span><br><span class="line">                myData3.consumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5s钟后，生产和消费都结束</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        myData3.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong></p>
<img src="/2021/08/09/BlockingQueue/image-20210714203155396.png" alt="image-20210714203155396" style="zoom:80%;">



<p><strong>代码分析</strong></p>
<ol>
<li> main 线程启动，创建一个资源类，传入一个阻塞队列。</li>
<li> 启动一个生产线程（Product）和一个消费线程（Consumer），两个线程并发执行。</li>
<li> main 线程可以直接叫停这两个线程</li>
</ol>
<p><em>生产线程：</em></p>
<ol>
<li> 生产线程执行具有原子性的 i++ 操作，并将 i 加入阻塞队列（阻塞队列的最大容量为 3），每加入一次暂停 1s</li>
</ol>
<p><em>消费线程</em>：</p>
<ol>
<li>消费线程消费阻塞队列中的值，<ul>
<li>  如果阻塞队列中有值，则消费成功；</li>
<li>  如果超过 2s 消费队列中都没有值，则消费失败，消费线程退出。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">超链接：线程池</a></li>
</ul>
<blockquote>
<p>  <strong>线程池 ThreadPoolExecutor 的构造方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/09/NIO/" class="post-title-link" itemprop="url">NIO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-09 12:28:02" itemprop="dateCreated datePublished" datetime="2021-08-09T12:28:02+08:00">2021-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-27 15:18:40" itemprop="dateModified" datetime="2021-10-27T15:18:40+08:00">2021-10-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java网络编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h1><p>Java 共支持 3 种 IO 模型：BIO、NIO、AIO</p>
<h2 id="1-BIO（同步阻塞-IO）"><a href="#1-BIO（同步阻塞-IO）" class="headerlink" title="1    BIO（同步阻塞 IO）"></a>1    BIO（同步阻塞 IO）</h2><p><img src="/2021/08/09/NIO/BIO.png" alt="BIO"></p>
<p><strong>是什么</strong></p>
<ul>
<li>  服务器的实现模式是为一个连接创建一个新的线程，即客户端有连接请求时服务器就会新启动一个线程单独处理这个请求。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>  这种模式带来的一个问题就是：如果有多个客户端同时向服务器发送请求，服务器端就会创建多个线程来维护多个连接，当客户端的数量过大时，服务器就要创建大量的线程，这会增大服务器的开销，甚至导致服务器宕机。</li>
</ul>
<p><strong>怎么办</strong></p>
<ul>
<li>  为了避免这个问题，可以采用线程池模型，并设置线程池线程的最大数量。但是这又会带来新的问题，如果线程池中有 100 个线程，而目前已经有 100 个用户都在进行文件传输，这就会导致第 101 个用户的请求无法及时被处理，即便第 101 个用户只想请求一个几KB 大小的页面。</li>
</ul>
<p><strong>BIO 执行流程</strong></p>
<ol>
<li> 服务器端启动；</li>
<li> 客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要为每一个客户端建立一个线程与之通讯；</li>
<li> 客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝；</li>
<li> 如果有响应，客户端线程会等待请求结束后，在执行其它操作。在请求未结束前，不允许执行其它操作，即会陷入阻塞。</li>
</ol>
<h2 id="2-NIO（同步非阻塞IO）"><a href="#2-NIO（同步非阻塞IO）" class="headerlink" title="2    NIO（同步非阻塞IO）"></a>2    NIO（同步非阻塞IO）</h2><ul>
<li>  服务器的实现模式为一个线程处理多个请求（连接），客户端发送的请求都会被注册到多路复用器（Selector）上，多路复用器轮询到连接有 IO 请求时就处理，没有则继续轮询。</li>
</ul>
<h2 id="3-AIO（异步非阻塞IO）"><a href="#3-AIO（异步非阻塞IO）" class="headerlink" title="3    AIO（异步非阻塞IO）"></a>3    AIO（异步非阻塞IO）</h2><h1 id="Java-NIO-概述"><a href="#Java-NIO-概述" class="headerlink" title="Java NIO 概述"></a>Java NIO 概述</h1><blockquote>
<p>  <strong>Java NIO；New IO 或 Non Blocking IO</strong></p>
</blockquote>
<ul>
<li>  NIO 是从 JDK1.4 引入的一个新的 IO API，可以替代传统的Java IO API。</li>
<li>  NIO 支持面向缓冲区的、基于通道的IO操作。NIO 将以更加高效的方式进行文件的读写操作。</li>
</ul>
<p>NIO 中非阻塞 I/O 采用了基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，相反是注册感兴趣的特定 I/O 事件，如可读数据到达，新的套接字连接等等，在发生特定事件时，系统再通知我们。NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的事件，如下图所示：</p>
<p><img src="/2021/08/09/NIO/image-20210909171418839.png" alt="image-20210909171418839"></p>
<p>从图中可以看出，当有读或写等任何注册的事件发生时，可以从 Selector 中获得相应的 SelectionKey，同时从 SelectionKey 中可以找到发生的事件和该事件所发生的具体的 SelectableChannel，以获得客户端发送过来的数据。</p>
<p>非阻塞指的是 IO 事件本身不阻塞，但是获取 IO 事件的 <code>select()</code> 方法是需要阻塞等待的。区别是阻塞的 IO 会阻塞在 IO 操作上, NIO 阻塞在事件获取上，没有事件就没有 IO，从高层次看 IO 就不阻塞了。</p>
<p>也就是说只有 IO 已经发生那么我们才评估 IO 是否阻塞，但是 <code>select()</code> 阻塞的时候 IO 还没有发生，何谈 IO 的阻塞呢？NIO 的本质是延迟 IO 操作到真正发生 IO 的时候，而不是以前的只要 IO 流打开了就一直等待 IO 操作。</p>
<table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流（Stream Oriented）</td>
<td>面向缓冲区（Buffer Oriented）</td>
</tr>
<tr>
<td>阻塞IO（Blocking IO）</td>
<td>非阻塞IO（Non Blocking IO）</td>
</tr>
<tr>
<td><code>~</code></td>
<td>选择器（Selectors）</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-NIO-概述"><a href="#3-NIO-概述" class="headerlink" title="3    NIO 概述"></a>3    NIO 概述</h2><p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li><strong>Channels</strong></li>
<li><strong>Buffers</strong></li>
<li><strong>Selectors</strong></li>
</ul>
<p>虽然 Java NIO 中除此之外还有很多类和组件，但 Channel，Buffer 和 Selector 构成了核心的 API。其它组件，如 Pipe 和 FileLock，只不过是与三个核心组件共同使用的工具类。</p>
<h3 id="3-1-Channel"><a href="#3-1-Channel" class="headerlink" title="3.1    Channel"></a>3.1    Channel</h3><blockquote>
<p>  <strong>Channel；通道</strong></p>
</blockquote>
<p>Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream，OutputStream。而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO 中的 Channel 的主要实现有：FileChannel、DatagramChannel、SocketChannel 和 ServerSocketChannel，这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server和Client）。</p>
<h3 id="3-2-Buffer"><a href="#3-2-Buffer" class="headerlink" title="3.2    Buffer"></a>3.2    Buffer</h3><ul>
<li>  NIO 中的关键 Buffer 实现有：</li>
</ul>
<p>ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，</p>
<ul>
<li>  分别对应基本数据类型: </li>
</ul>
<p>byte, char, double, float, int, long, short。</p>
<h3 id="3-3-Selector"><a href="#3-3-Selector" class="headerlink" title="3.3    Selector"></a>3.3    Selector</h3><p><strong>Selector 运行单线程处理多个 Channel</strong>，如果你的应用打开了多个通道，但每个连接的流量都很低，使用 Selector 就会很方便。</p>
<p>例如在一个聊天服务器中。要使用 Selector，得向 Selector 注册Channel，然后调用它的 <code>select()</code> 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p>
<hr>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="1-Channel概述"><a href="#1-Channel概述" class="headerlink" title="1    Channel概述"></a>1    Channel概述</h2><ul>
<li>  Channel 是一个通道，可以通过它读取和写入数据，它就像水管一样，网络数据通过 Channel 读取和写入。</li>
<li>  通道与流的不同之处在于通道是双向的，流只是在一个方向上移动（一个流必须是 InputStream 或者 OutputStream 的子类），而且通道可以用于读、写或者同时用于读写。因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。</li>
<li>  NIO 中通过 channel 封装了对数据源的操作，通过 channel 我们可以操作数据源，但又不必关心数据源的具体物理结构。这个数据源可能是多种的。比如，可以是文件，也可以是网络 socket。在大多数应用中，channel 与文件描述符或者 socket 是一一对应的。</li>
<li>  Channel 用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。</li>
</ul>
<blockquote>
<p>  <strong>Channel接口源码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio.channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tells whether or not this channel is open.</span></span><br><span class="line"><span class="comment">     * 判断通道是否打开</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if, and only if, this channel is open</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this channel.</span></span><br><span class="line"><span class="comment">     * 关闭通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  与缓冲区不同，通道 API 主要由接口指定。<strong>通道 API 仅仅进行了一些功能性的描述，具体的实现方式根据不同的操作系统会有根本性的差异。</strong>因此很自然地，通道实现通常使用操作系统的本地代码。</li>
<li>  Channel 是一个对象，可以通过它读取和写入数据。拿 NIO 与传统 IO 做个比较，通道就像是流，所有数据都通过 Buffer 对象来处理。你永远不会将字节直接写入通道中，相反，你是将数据写入一个缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</li>
</ul>
<p>Java NIO 的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写。</li>
<li>通道中的数据总是要先读到一个 Buffer，或者总是要从一个Buffer中写入。正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：</li>
</ul>
<p><img src="/2021/08/09/NIO/image-20210909174621529.png" alt="image-20210909174621529"></p>
<hr>
<h2 id="2-Channel实现"><a href="#2-Channel实现" class="headerlink" title="2    Channel实现"></a>2    Channel实现</h2><p>下面是 Java NIO 中最重要的 Channel 的实现：</p>
<ul>
<li><strong>FileChannel</strong>：从文件中读写数据。</li>
<li><strong>DatagramChannel</strong>：能通过 UDP 读写网络中的数据。</li>
<li><strong>SocketChannel</strong>：能通过TCP读写网络中的数据。</li>
<li><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，像Web服务器那样。对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<p>这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO</p>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><h4 id="从-channel-中读数据"><a href="#从-channel-中读数据" class="headerlink" title="从 channel 中读数据"></a>从 channel 中读数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建FileChannel</span></span><br><span class="line">        <span class="comment">/*FileChannel并不能直接创建，创建该对象要依赖于一个File对象*/</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);   <span class="comment">// ①文件路径②文件模式（读/写/执行）</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建Buffer【Channel在使用中依赖于Buffer】</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、读取数据到Buffer中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> fileChannel.read(buffer);   <span class="comment">// 返回值用于记录当前次读取的字节数，等于-1时表示读取到了最后一行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取了：&quot;</span> + bytesRead);</span><br><span class="line">            buffer.flip();  <span class="comment">// 进行读写模式的转换【在这里转换的目的是为了输出读到的内容】</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining())   <span class="comment">// hasRemaining方法用于判断Buffer中是否还有剩余的数据内容</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) buffer.get();   <span class="comment">// 读取buffer中的内容</span></span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 更新bytesRead变量，当buffer中无数据后，改变量应该为-1</span></span><br><span class="line">            bytesRead = fileChannel.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、释放资源</span></span><br><span class="line">        file.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;操作结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="向-channel-中写数据"><a href="#向-channel-中写数据" class="headerlink" title="向 channel 中写数据"></a>向 channel 中写数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 向 Channel 中写数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、进行数据传输时需要使用到 Channel（通道），也就是说需要先创建一个连通两端（发送方/接收方）的通道</span></span><br><span class="line"><span class="comment">        2、创建 Channel 需要两端，其中一端为连接的发起方，在这里就是我们的代码端，所以我们必须还要手动指定</span></span><br><span class="line"><span class="comment">        另一端，一般我们会指定为一个文件。</span></span><br><span class="line"><span class="comment">      整个流程也就是说，把我们在代码中的数据发送给本机上的某个文件，在这两端之间建立一个 channel 用于数据传输，</span></span><br><span class="line"><span class="comment">      当然也会用到 buffer，因为 channel 的读或写操作都直接依赖于 buffer ，用 buffer 作为一个中转站，再去</span></span><br><span class="line"><span class="comment">      访问到具体的文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建 channel 对象，需要提前指定好 channel 的另一端，一般是一个文件对象</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo02.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、建立 磁盘文件 到 Java程序虚拟内存 间的连接通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、分配一块缓冲区，用于向channel中写数据</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、在内存中新建一段数据，并将其写入 buffer 中</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;This is my world!&quot;</span>).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        buffer.clear(); <span class="comment">// 使用前先清空buffer中的数据，这是一个好习惯</span></span><br><span class="line">        buffer.put(bytes);</span><br><span class="line"></span><br><span class="line">        buffer.flip();  <span class="comment">// 读写模式转换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、将 buffer 中的数据写入 channel 中</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())</span><br><span class="line">        &#123;</span><br><span class="line">            channel.write(buffer);	<span class="comment">// 注意 write() 方法需要在while循环中进行调用，因为无法保证 write() 方法一次能向 channel 中写入多少字节，因此需要重复调用 write() 方法，直到 buffer 为空</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="通道间的数据传输"><a href="#通道间的数据传输" class="headerlink" title="通道间的数据传输"></a>通道间的数据传输</h4><p>两个通道间的数据可以进行直接的数据传输</p>
<h5 id="FileChannel-transferTo-transferFrom"><a href="#FileChannel-transferTo-transferFrom" class="headerlink" title="FileChannel#transferTo/transferFrom"></a>FileChannel#transferTo/transferFrom</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lnd.demo.channel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/26 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通道间的数据传输</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、建立两个通道</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;E:\\workspace_java\\io\\demo02.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel1</span> <span class="operator">=</span> file1.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel2</span> <span class="operator">=</span> file2.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、通道间进行数据传输（将channel1中的数据传输到channel2中）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> channel1.size();</span><br><span class="line"><span class="comment">//        channel1.transferTo(position, count, channel2);   // 方法1</span></span><br><span class="line">        channel2.transferFrom(channel1, position, count);   <span class="comment">// 方法2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、关闭资源</span></span><br><span class="line">        channel1.close();</span><br><span class="line">        channel2.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<hr>
<h4 id="FileChannel-size-方法"><a href="#FileChannel-size-方法" class="headerlink" title="FileChannel#size()方法"></a>FileChannel#size()方法</h4><ul>
<li>  FileChannel 对象是根据其所关联的具体文件来创建的，</li>
<li>  所以 FileChannel 实例的 size() 方法将返回该实例所关联的文件的大小。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> fileChannel.size();	</span><br></pre></td></tr></table></figure>



<h4 id="FileChannel-truncate-方法"><a href="#FileChannel-truncate-方法" class="headerlink" title="FileChannel#truncate() 方法"></a>FileChannel#truncate() 方法</h4><ul>
<li>  FileChannel 实例一定会关联到某一个具体的文件</li>
<li>  可以使用 <strong>FileChannel#truncate()</strong> 方法来截取这个文件，截取文件时，会将指定长度后面的部分删除掉。截取后得到一个新的 fileChannel 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">newFileChannel</span> <span class="operator">=</span> fileChannel .truncate(<span class="number">1024</span>);	<span class="comment">// 截取文件的前 1024 个字节</span></span><br></pre></td></tr></table></figure>



<h4 id="FileChannel-force-方法"><a href="#FileChannel-force-方法" class="headerlink" title="FileChannel#force() 方法"></a>FileChannel#force() 方法</h4><ul>
<li>  在使用 Channel 的过程中，出于性能考虑，操作系统会先将 channel 中的数据写出到缓存中，缓存区满了之后再将缓存中的数据写到磁盘上，所以一般情况下 fileChannel 无法保证数据一定会即时写到磁盘上。</li>
<li>  若想保证这一点，可以使用 FileChannel 的 force() 方法会将通道中尚未写入磁盘中的数据和缓存中的数据强制写到磁盘上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.force(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// force() 方法有一个 boolean 类型的参数，指明是否将数据写到磁盘上</span></span><br></pre></td></tr></table></figure>





<hr>
<h4 id="FileChannel-position-方法"><a href="#FileChannel-position-方法" class="headerlink" title="FileChannel#position() 方法"></a>FileChannel#position() 方法</h4><ul>
<li>  <strong>FileChannel#position()</strong> 方法可以获取 filechannel 的当前位置，</li>
<li>  也可以调用 position(long pos) 方法设置 fileChannel 的当前位置。</li>
<li>  该功能用于对 fileChannel 的某个特定位置进行读/写操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();	<span class="comment">// 获取 fileChannel 的当前位置</span></span><br><span class="line">channel.position(pos + <span class="number">123</span>);	<span class="comment">// 设置 fileChannel 的新的当前位置</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>  如果将当前位置设置在文件结束符之后，再试图从文件通道中读取数据，读方法将返回 -1。</li>
<li>  如果将当前位置设置在文件结束符之后，然后向通道中写数据，文件将被撑大到当前位置并写入数据。但是这有可能导致<strong>“文件空洞”</strong>，即磁盘上物理文件中写入的数据间有空隙。</li>
</ul>
<hr>
<h3 id="Socket通道"><a href="#Socket通道" class="headerlink" title="Socket通道"></a>Socket通道</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/07/volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/07/volatile/" class="post-title-link" itemprop="url">volatile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-07 16:28:28" itemprop="dateCreated datePublished" datetime="2021-08-07T16:28:28+08:00">2021-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-08-08 11:08:26" itemprop="dateModified" datetime="2021-08-08T11:08:26+08:00">2021-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1    前置知识"></a>1    前置知识</h1><p>在 Java 内存模型中，我们知道了 JMM 有一个主内存，每个线程有自己的私有工作内存，工作内存中保存了一些变量在主内存的拷贝。</p>
<blockquote>
<p>  <strong>内存可见性：</strong></p>
</blockquote>
<p>指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。</p>
<blockquote>
<p>  <strong>重排序</strong></p>
</blockquote>
<p>为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。</p>
<hr>
<h1 id="2-Volatile-概述"><a href="#2-Volatile-概述" class="headerlink" title="2    Volatile 概述"></a>2    Volatile 概述</h1><ol>
<li> volatile 是 Java 提供的轻量级的同步机制（乞丐版的 syschorcize）</li>
<li>volatile <strong>三大特性</strong><ul>
<li>  保证变量的<strong>内存可见性</strong></li>
<li>  <strong>禁止 volatile 变量与普通变量重排序</strong></li>
<li>  不保证原子性</li>
</ul>
</li>
</ol>
<h1 id="3-内存可见性"><a href="#3-内存可见性" class="headerlink" title="3    内存可见性"></a>3    内存可见性</h1><ul>
<li>  可见性是指当一个线程运行时能感知到另一个线程对共享变量做出的改变。</li>
</ul>
<h2 id="3-1-验证普通变量之间的内存不可见性"><a href="#3-1-验证普通变量之间的内存不可见性" class="headerlink" title="3.1    验证普通变量之间的内存不可见性"></a>3.1    验证普通变量之间的内存不可见性</h2><ul>
<li>  如果两个线程不是同时执行的，而是先后执行，因为每次本地内存中对共享变量的改变都会写回到主内存中，另一个线程接着再取出来的是更改过的共享变量。这就相当于是一个单线程了。</li>
<li>  简单点就是说，A、B两个线程并发执行，B 线程正在用着 num，并且可能还要继续用一段时间，这时候线程 A 修改了 num 的值，B线程马上就知道了，这叫做线程间变量的可见性。（用着用着 num 突然变了）  </li>
<li>  而 A、B 两个线程先后被创建，然后开始并发执行，如果B线程在创建之前A线程就已经修改完 num 的值并将其写回主内存了，那么B线程得到的 num 变量的副本自然也是被 A 线程修改后的 num。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VisibleDemo</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag == <span class="literal">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">VisibleDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VisibleDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            	<span class="comment">// Thread.sleep(100);</span></span><br><span class="line">                demo.method1();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            demo.method2();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  我们来分析一下这段代码，线程 A 调用了 <code>method1()</code>，线程 B 调用了 <code>method2()</code>，线程A 和线程B 并发执行。</li>
<li>  我们想象中的是由于 flag 没有使用 volatile 修饰，那么在线程 A 中对 flag 的改变线程B 不能感知到，那么线程B 自然就会进入到死循环中了，导致 JVM 进程不能结束。</li>
<li>  但程序的真实结果是线程B执行了，即知道了 flag 的改变，死循环不会执行，而是会执行输出语句。这是为什么呢？难道不加 volatile 也能保证可见性吗？其实不是的。</li>
<li>  由于我们上面这段代码非常简单，在 main 方法中有创建 A、B 两个线程的操作，先创建A，再创建B。但是由于A线程执行的时间太短了，所以在线程B执行之前A线程已经执行完了 <code>method1()</code> 方法，并且把修改后的 flag 重写回了主内存。这时B线程才去执行 <code>run()</code>，所以B线程创建时从主内存中复制过去的变量 flag 已经是修改过的值了，即<code>flag==true</code>，所以自然不会进入死循环了。</li>
<li>  如果想要验证不加 volatile 就不具备可见性，可以让线程 A 先睡眠 100ms，让线程B先执行 method2 方法进入死循环，再让线程A去修改 flag 的值，发现程序不能结束，这也就验证了此时线程间确实是不具备可见性的。</li>
</ul>
<hr>
<h2 id="3-2-验证-volatile-能保证可见性"><a href="#3-2-验证-volatile-能保证可见性" class="headerlink" title="3.2    验证 volatile 能保证可见性"></a>3.2    验证 volatile 能保证可见性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/*volatile*/</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// child线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========End of Child Thread&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Child&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;turn flag off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面这段代码在运行时，存在两个线程 child 和 main，一个保存在主内存中的变量 flag。</p>
<ol>
<li>由于 main 线程在创建子线程后会睡眠100ms，所以 child 线程开始执行，检测到 <code>flag == true</code>，child 线程进入死循环中。</li>
<li>mian 线程在睡醒后继续执行，修改 <code>flag=false</code>并在控制台上输出指定内容，然后主线程结束。</li>
<li>但这是我们会发现程序并没有结束，因为 child 线程仍处于死循环状态。也就是说<strong>main 线程修改全局变量 flag=false ，并不能被 child 线程感知到</strong>。</li>
</ol>
<p><img src="/2021/08/07/volatile/image-20210506143613131.png" alt="image-20210506143613131"></p>
<p>但是如果我们将 <strong>volatile</strong> 关键字的注释打开，代码的执行流程就变成了：</p>
<ol>
<li>child 线程开始执行，检测到 <code>flag == true</code>，进入死循环中。</li>
<li>mian 线程在睡醒后继续执行，修改 <code>flag = false</code>并在控制台上输出指定内容，然后主线程结束。</li>
<li>但是此时 child 线程监听了到主线程对于 flag 变量的修改，即在 child 线程的感知中 <code>flag == false</code> 了，所以 child 线程退出死循环，在控制台上打印指定内容，child 线程结束。</li>
<li>整个 JVM 进程结束。</li>
</ol>
<p><img src="/2021/08/07/volatile/image-20210506143757319.png" alt="image-20210506143757319"></p>
<p><strong>总结：</strong></p>
<p>上面的代码可以证明：<strong>volatile 关键字可以保证多个线程之间共享变量的可见性</strong>。即共享变量在某个线程中的本地内存中发生了变化，其它的线程也可以监听到这种变化！当然这种<strong>监听的底层原理还是通过主内存作为传输纽带进行交互的</strong>，即单个线程在本地内存中对共享变量的操作最终还是要写回到主内存中，再由主内存将这种变化通知到其它所有使用这个共享变量的线程。</p>
<hr>
<h1 id="4-不保证原子性"><a href="#4-不保证原子性" class="headerlink" title="4    不保证原子性"></a>4    不保证原子性</h1><blockquote>
<p>  <strong>代码验证</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  验证 volatile 不保证原子性</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> *      新建20个线程，每个线程都调用1000次 autoIncrement() 方法对共享变量num进行自增的操作，</span></span><br><span class="line"><span class="comment"> *      让 main 线程休眠一段时间直到这20个新建的线程执行完毕后再查看堆内存中num的值，在无错的情况下，</span></span><br><span class="line"><span class="comment"> *      num 的值应该是 0+20*1000=20000</span></span><br><span class="line"><span class="comment"> *      但是实际情况确实，大多数情况下这个值都小于20000，且值不确定。这说明了volatile并不能保证原子性，</span></span><br><span class="line"><span class="comment"> *      即 volatile 并不能保证线程安全。在某个线程执行的时候，可能会被其它线程加塞。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.autoIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(myData.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">     <span class="comment">/*  此时 num 前面是加了 volatile 关键字修饰的，但是 volatile 并不能保证变量的原子性   */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoIncrement</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>为什么说 volatile 不能保证原子性？</strong></p>
</blockquote>
<p>因为在 <code>MyData#autoIncrement()</code> 方法中，可能存在多个线程同时执行了 num++ 操作。</p>
<p><strong>num++</strong> 这一行代码的实际操作可分为三个步骤：<code>读 --&gt; 改 --&gt; 写</code></p>
<ol>
<li> 读：首先从主内存中拿到 num 的值，复制一份到自己的工作内存中；[<code>getfield #2 &lt;com/juc/day01/Test.n&gt;</code>]</li>
<li> 改：在自己的工作内存中对 num 进行自增操作；[<code>iadd</code>]</li>
<li> 写：将更改后的 num 写回到主内存中去。[<code>putfield #2 &lt;com/juc/day01/Test.n&gt;</code>]</li>
</ol>
<p><img src="/2021/08/07/volatile/image-20210709105405172.png" alt="image-20210709105405172"></p>
<p>原子性就是对 num 的操作，即 “读 –&gt; 改 –&gt; 写” 这三个步骤是不可分割的，而 volatile 不能保证原子性。</p>
<p>​        在保证原子性的情况下 num++ 的执行流程应该是：假设线程 A、B、C 并发执行，线程 A 拿到了 num=0，复制副本后在自己的工作空间中将其更新为 num=1，然后再将其写回到主内存中。这时候其它线程再去对 num 进行操作，这是一个完整的具备原子性的操作流程。</p>
<p>​        而在不能保证原子性的情况下则会出现，线程 A、B、C 同时拿到了主内存中的值 num=0，并在各自的内存空间将 num 更新为 1。接下来三个线程需要将更新后的值写回主内存中，假设 A 先写回主内存，主内存中的共享变量改变后需要通知其它线程，但是在这个通知还未发送到 B、C 线程的时候，B、C 线程就已经把写回主内存的操作都做完了，那么此时主内存中的值仍然会是 1，最后一个写入到主内存的 1 会覆盖前面两个写入到主内存的 1。而我们知道实际的运算结果本应该是 3。所以说在不能保证原子性的前提下，上述代码执行的结果大概率会小于 20000。</p>
<blockquote>
<p>  <strong>如何解决 volatile 不能保证原子性的问题？</strong></p>
</blockquote>
<ol>
<li> 使用 synchronized 关键字加锁（可以解决，但的锁太重）</li>
<li> 使用 JUC 包下的 AtomicInteger</li>
</ol>
<p>查看 JavaDoc 可知，在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html">java.util.concurrent.atomic</a> 包下包含了一系列的能保证原子性的数据类型。我们可以<strong>在使用 volatile 的基础上再使用 AtomicXXX 类型的对象就能保证多线程操作数据的可见性和原子性并存，并且不用添加重锁</strong>。</p>
<img src="/2021/08/07/volatile/image-20210709112717007.png" alt="image-20210709112717007" style="zoom:80%;">



<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html">AtomicInteger</a> 的构造方法<ul>
<li>  AtomicInteger 其实就是对 Integer 的又一层包装，二者最大的区别就是 Integer 不能保证原子性，但 AtomicInteger 可以。</li>
<li>  默认的无参构造函数会初始化一个满足原子性的值为 0 的 int 类型数据</li>
<li>  带参的构造函数可以自己指定初始化值。</li>
</ul>
</li>
</ul>
<p><img src="/2021/08/07/volatile/image-20210709113136165.png" alt="image-20210709113136165"></p>
<ul>
<li>  <strong>代码修改</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.autoIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(myData.num);		<span class="comment">// 此时输出结果必定为 20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoIncrement</span><span class="params">()</span>&#123;</span><br><span class="line">        num.getAndIncrement();   <span class="comment">// 等价于 num++;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>AtomicInteger#getAndIncrement() 方法源码</strong></p>
</blockquote>
<img src="/2021/08/07/volatile/image-20210709113659357.png" alt="image-20210709113659357" style="zoom:80%;">





<hr>
<h1 id="5-有序性（指令重排）"><a href="#5-有序性（指令重排）" class="headerlink" title="5    有序性（指令重排）"></a>5    有序性（指令重排）</h1><h2 id="为什么要禁止指令重排？"><a href="#为什么要禁止指令重排？" class="headerlink" title="为什么要禁止指令重排？"></a>为什么要禁止指令重排？</h2><p>在多线程程序中，如果发生了指令重排，可能会导致程序的执行结果每次都是不确定的。即线程不安全。</p>
<hr>
<h2 id="指令重排是什么？"><a href="#指令重排是什么？" class="headerlink" title="指令重排是什么？"></a>指令重排是什么？</h2><p>计算机在执行程序时，为了提高性能，编译器和处理器往往会<strong>对指令进行重排</strong>。</p>
<p>指令重排造成的结果是：程序员写的代码的执行的顺序与代码真正在底层执行的顺序是有偏差的。</p>
<p><img src="/2021/08/07/volatile/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png" alt="指令重排"></p>
<ul>
<li>  多线程环境中线程交替执行，由于指令优化重排的存在，多个线程中使用的变量能否保证一致性是无法确定的，程序执行的结果也就无法预测了。</li>
<li>  处理器在进行指令重排时必须要考虑指令之间的<strong>数据依赖性</strong>。（也就是说指令重排必须是在满足数据依赖性的基础上进行的）</li>
</ul>
<hr>
<h2 id="指令重排演示"><a href="#指令重排演示" class="headerlink" title="指令重排演示"></a>指令重排演示</h2><h3 id="指令重排案例1：数据依赖性"><a href="#指令重排案例1：数据依赖性" class="headerlink" title="指令重排案例1：数据依赖性"></a>指令重排案例1：数据依赖性</h3><p>​        程序进行指令重排的前提是一定要满足数据依赖性，那么什么是数据依赖性呢？很简单的一个例子就是，想要吃苹果就必须得先有苹果，在程序中就是想要使用变量 num 就必须先声明这个变量 num。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;	<span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">4</span>;	<span class="comment">// 2</span></span><br><span class="line">x = x + <span class="number">7</span>;	<span class="comment">// 3</span></span><br><span class="line">y = y + <span class="number">8</span>;	<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>​        在上面的程序中，源代码设计的执行顺序是 <code>1234</code>，但是如果发生了指令重排，它就有可能变成 <code>2143</code>、<code>1324</code>，这都是 OK 的，但是能不能变成 <code>4321</code> 呢？答案是不可以的，因为第3、4条语句对应的指令是需要依赖于 1、2条语句指令创建的变量的，这就是最简单的数据依赖性。</p>
<h3 id="指令重排案例2：数据间无依赖性"><a href="#指令重排案例2：数据间无依赖性" class="headerlink" title="指令重排案例2：数据间无依赖性"></a>指令重排案例2：数据间无依赖性</h3><ol>
<li> 在两个线程的程序中，源代码中设计的程序执行顺序为：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,x,y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 在声明完4个变量a，b，x，y 后，这4个变量之间无依赖性，执行顺序可以任意组合</span></span><br><span class="line">x = a;</span><br><span class="line">y = b;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">这段代码在执行结束后，x 和 y 的结果应该为：x=<span class="number">0</span>, y=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 但是如果编译器对这段程序代码执行指令重排优化后，可能会出现执行顺序变为：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line">x = a;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line">y = b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这段代码在执行结束后，x 和 y 的结果应该为：x=<span class="number">2</span>, y=<span class="number">1</span></span><br></pre></td></tr></table></figure>





<h3 id="指令重排案例3"><a href="#指令重排案例3" class="headerlink" title="指令重排案例3"></a>指令重排案例3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReSortDemo</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        num = <span class="number">1</span>;	<span class="comment">// 语句1</span></span><br><span class="line">        flag = <span class="literal">true</span>;	<span class="comment">// 语句2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            num = num + <span class="number">5</span>;	<span class="comment">// 语句3</span></span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设现在有两个线程 A、B 并发执行 method1 和 method2 方法。</p>
<blockquote>
<p>  <strong>未发生指令重排：</strong></p>
</blockquote>
<p>假设线程 A 先执行 <code>method1()</code>，更新 num 和 flag 的值，线程 B 再执行，执行 <code>num = num + 5;</code>，最终 num 的值为 6，<strong>输出的结果为 6</strong>。</p>
<blockquote>
<p>  <strong>发生指令重排：</strong></p>
</blockquote>
<p>发生指令重排后，假设语句1和语句2在重排后执行顺序发生了交换，线程A先执行 <code>flag=true</code>，紧接着又切换到线程B 执行 <code>num=num+5</code>，但此时 num == 0，因此线程 B <strong>输出的结果变成了 5</strong>，并且最后还是会执行语句1让<code>num = 1;</code>。可以看到发生指令重排后程序的运行结果每次可能不一样。</p>
<hr>
<h2 id="指令重排总结"><a href="#指令重排总结" class="headerlink" title="指令重排总结"></a>指令重排总结</h2><ul>
<li>  <code>volatile</code> 关键字能禁止指令重排，从而避免多线程环境下程序执行结果不确定的情况。</li>
<li>  单线程程序中发生指令重排是不会影响到最终的执行结果的，因为指令重排首先要满足对象的依赖性，所以不会出现某个对象还没有初始化就对其操作的情况。</li>
<li>  指令重排有时候有好处（执行速度比较快），有时候有坏处（执行结果得不到保证），需要根据具体场景判断是否需要使用指令重排。如果需要就不用加 <code>volatile</code> 修饰，如果不需要指令重排就加 <code>volatile</code> 修饰。</li>
</ul>
<hr>
<h1 id="6-线程安全性获得保证"><a href="#6-线程安全性获得保证" class="headerlink" title="6    线程安全性获得保证"></a>6    线程安全性获得保证</h1><blockquote>
<p>  <strong>多线程存在哪些隐患？</strong></p>
</blockquote>
<ol>
<li> 工作内存与主内存同步延迟现象导致的可见性问题。</li>
<li> 指令重排导致的有序性问题。</li>
</ol>
<blockquote>
<p>  <strong>如何解决？</strong></p>
</blockquote>
<ol>
<li> 对于多个工作内存间的可见性问题，可以使用 synchronized 或 volatile 关键字解决，它们都可以使一个线程<strong>修改后的变量立即对其它线程可见</strong>。</li>
<li> 对于指令重排导致的有序性问题，可以使用 volatile 关键字解决，因为 volatile 的另一个作用就是禁止指令重排。</li>
</ol>
<blockquote>
<p>  <strong>遗留问题：</strong></p>
</blockquote>
<ul>
<li>  <strong>synchronized 关键字不能禁止指令重排，却能保证有序性，这是为什么？</strong></li>
</ul>
<hr>
<h1 id="7-DCL-单例"><a href="#7-DCL-单例" class="headerlink" title="7    DCL 单例"></a>7    DCL 单例</h1><p>DCL（Double Check Lock）：双重检查锁</p>
<blockquote>
<ol>
<li><strong>饿汉式单例</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个单例对象（饿汉式）：</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      1、将构造方法私有化（不提供从外部创建对象的接口）</span></span><br><span class="line"><span class="comment"> *      2、提供一个公共的方法用于获取这个单例对象</span></span><br><span class="line"><span class="comment"> *	    3、在类加载时就创建一个实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleExample</span> <span class="variable">singleExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这种单例模式的弊端：无论这个单例对象在程序中是否会使用，在类加载阶段都会创建这个单例对象。会浪费服务器的性能。</li>
</ul>
<blockquote>
<ol start="2">
<li><strong>单例优化（懒加载）</strong>：类加载阶段不创建实例对象，在使用时才创建实例对象。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">            <span class="comment">// 线程不安全。假设在这个位置同时进入了多个线程</span></span><br><span class="line">            singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这种单例模式的弊端：线程不安全！！！</li>
<li>如果同时有多个线程进入了第 10 行的位置，显然这些线程都会执行 <code>new SingleExample()</code> 方法，就会创建多个对象实例。</li>
</ul>
<blockquote>
<ol start="3">
<li>继续优化：想要实现线程安全，就需要<strong>加锁</strong>。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;	<span class="comment">// 使用 synchronized 关键字加锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">            singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面这种单例模式的弊端：锁的粒度太大。</p>
<p>  除了第一次调用 <code>getInstance()</code> 方法时会执行创建 SingleExample 对象的动作外，以后的每一次调用都是直接返回 singleExample 对象的引用，返回对象引用这个操作的耗时是很小的，绝大部分的耗时都用在 synchronized 修饰符的同步准备上，也就是说对象创建好了之后再有多个线程访问该方法是安全的，直接在最外层的方法上加锁，每次仍然需要进行锁对象的争夺，就会影响程序执行的性能了。</p>
</li>
</ul>
<blockquote>
<ol start="4">
<li>继续优化：<strong>降低锁的粒度</strong>。将同步锁加在具体某一行或几行代码上。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample) &#123;</span><br><span class="line">            <span class="comment">// 可能存在多个线程同时进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample.class) &#123;</span><br><span class="line">                singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>弊端：违背了单例的原则。</li>
<li>分析：第 9 行可能存在多个线程同时进入，即使在第10行进行了加锁，但是第 9 行的多个线程已经通过了 if 判断，不会再次进行判断了，所以这多个线程最终还是会创建出来多个 SingleExample 对象，违背了单例的原则。</li>
</ul>
<blockquote>
<ol start="5">
<li>继续优化：<strong>DCL（Double Check Lock）</strong>，双重检查锁。在锁的前面和后面都进行一次判断</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample singleExample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleExample <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 支持多线程操作且线程安全的代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == singleExample) &#123;    <span class="comment">/*第一次检查，如果已有实例对象就不会触发多线程操作，作用是节省性能*/</span></span><br><span class="line">            <span class="comment">// 可能存在多个线程同时进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample.class) &#123;    <span class="comment">/*第二次检查，作用是保证创建出来的实例对象只能有一个*/</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == singleExample)&#123;</span><br><span class="line">                    singleExample = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleExample;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>双重检查锁可以解决锁的粒度大且线程不安全的问题。</p>
</li>
<li><p>分析：</p>
<ol>
<li> 第一次检查的目的：如果 singleExample 对象已经被创建了出来，那么就不会进入到多个线程争夺锁对象的阶段，节省性能。</li>
<li> 第二次检查的目的：保证创建出来的实例对象只能有一个。</li>
</ol>
</li>
<li><p>隐患：</p>
<p>  DCL 单例看起来已经可以完美地创建出来一个单例对象了，但是由于存在指令重排的可能，因此 DCL 单例还能有进一步优化的可能。</p>
</li>
</ul>
<h2 id="DCL-单例存在的隐患及优化方法"><a href="#DCL-单例存在的隐患及优化方法" class="headerlink" title="DCL 单例存在的隐患及优化方法"></a>DCL 单例存在的隐患及优化方法</h2><p>​        DCL 单例并不一定线程安全，原因是可能会出现指令重排，所以还需要使用 volatile 关键字来防止高并发情况下，指令重排造成的线程安全问题。</p>
<h3 id="Java创建对象过程中CPU进行的操作"><a href="#Java创建对象过程中CPU进行的操作" class="headerlink" title="Java创建对象过程中CPU进行的操作"></a>Java创建对象过程中CPU进行的操作</h3><p><img src="/2021/08/07/volatile/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%843%E4%B8%AA%E9%98%B6%E6%AE%B5.png"></p>
<p>Java 创建对象的过程可分为三个部分：</p>
<ol>
<li>在堆中给将要创建的对象分配一块内存空间，并赋初始零值。</li>
<li>根据对象的构造函数进行初始化（显式初始化）。</li>
<li>在栈中建立指针与对象的对应关系。</li>
</ol>
<p>​        Java 创建对象的每一步都需要 CPU 提供相应的指令，且对象数据保存在堆内存中，CPU 需要从内存中去读取这部分数据并拿回来运算，这就有可能会发生指令重排。</p>
<p>​        步骤2 和 步骤3 不存在数据依赖关系，所以可能会存在指令重排，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排是允许的。</p>
<blockquote>
<p>  <strong>重排前</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();	<span class="comment">// 1、给对象分配内存空间</span></span><br><span class="line">instance(memory);		<span class="comment">// 2、初始化对象</span></span><br><span class="line">instance = memory;		<span class="comment">// 3、设置栈中变量 instance 指向刚分配的内存地址，此时 instance != null</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>重排后</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();	<span class="comment">// 1、给对象分配内存空间</span></span><br><span class="line">instance = memory;		<span class="comment">// 3、设置栈中变量 instance 指向刚分配的内存地址，此时 instance != null，但是对象还没有初始化完成</span></span><br><span class="line">instance(memory);		<span class="comment">// 2、初始化对象</span></span><br></pre></td></tr></table></figure>



<ul>
<li>如果发生指令重排，则原本执行顺序可能变为<code>1-&gt; 3-&gt; 2</code>，指令重排在单线程下是不会对程序产生大的影响的，因为单线程操作的过程中不会有其它线程来访问程序执行的某个中间阶段，最终的结果不会改变。</li>
<li>但是如果在多线程的情况下（假设指令重排后顺序变为<code>1-&gt; 3-&gt; 2</code>），线程A 创建单例对象，执行了1，3步骤后，切换到线程B 执行读取单例对象并返回的操作，因为线程A 执行完1、3步骤后 <code>instance != null</code>，所以线程B 不会再去执行创建对象的代码，而是直接返回单例对象的引用，但是此时这个引用指向的单例对象的值是类加载阶段赋的初始零值 null，而不是构造器中显式指定的初始值，显然这是不对的。如果线程B 拿着这个错误的单例对象去使用了，线程B 对应的程序就不能够正常运行了。</li>
<li>即便之后线程A 再执行第2步骤，完成了构造器显式赋值，并且之后也不会再出现读取到默认零值的情况，但是起码存在这样一种出错的可能性。</li>
<li>而 <strong>volatile</strong> 关键字的作用就是保证指令不被重排。当创建单例对象时，保证指令的执行顺序一定是是 <code>1-&gt; 2 -&gt;3</code>。</li>
</ul>
<blockquote>
<p>  <strong>null != single 有两种情况：</strong></p>
</blockquote>
<ol>
<li> 已经完整地创建过 SingleExample 对象了，没有发生指令重排，或者在指令重排的时候没有多个线程访问。</li>
<li> 正在创建 SingleExample 对象，但是发生了指令重排，并且有多个线程访问，并且有 A线程得到了锁对象，但是只执行了分配内存空间和设置 instance 指向内存地址后，CPU 资源就切换到 B线程去执行了，这时候 instance 确实是有值的（地址值），但是地址中没有数据，如果 B线程拿到了 instance 并使用，就会出现程序执行错误了。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/07/Spring%E2%80%94%E2%80%94IoC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/" class="post-title-link" itemprop="url">Spring——IoC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-07 12:22:09" itemprop="dateCreated datePublished" datetime="2021-08-07T12:22:09+08:00">2021-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-03-30 16:42:05" itemprop="dateModified" datetime="2022-03-30T16:42:05+08:00">2022-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IoC-是什么？"><a href="#IoC-是什么？" class="headerlink" title="IoC 是什么？"></a>IoC 是什么？</h1><p><strong>IOC 的概念：</strong></p>
<p>IOC（Inversion of Control） 最初被叫做“Hollywood Principe”，即好莱坞原则。为什么要起这个名字呢？好莱坞原则的意思就是：在拍摄某部电影时，演员不是主动去申请拍摄这部电影的，而是由导演来挑选演员的。类比到 Spring 中就是：实例对象不是主动去创建的，而是由 Spring 容器在适当的时候去创建出来提供给程序使用的。官方一点的解释就是：</p>
<blockquote>
<ul>
<li>  IOC 就是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。 </li>
<li>  Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</li>
</ul>
</blockquote>
<p><strong>IoC 作用：</strong></p>
<ol>
<li> 创建对象并维护对象之间的依赖关系。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的。</li>
<li> 解耦，由容器去维护具体的对象</li>
</ol>
<p><strong>实现 IoC 设计原则的2种方式：</strong></p>
<ol>
<li><strong>依赖注入（DI）</strong></li>
<li>依赖查找（Dependency Lookup）</li>
</ol>
<p><strong>Spring 中 IOC 的实现原理：</strong></p>
<p>Spring 中 IOC 的实现原理就是 <u><strong>工厂模式+反射机制</strong></u>。我们通过一个例子来解释一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getInstance</span><span class="params">(String ClassName)</span> &#123;</span><br><span class="line">        Fruit f=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;cn.lnd.springtest.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="程序的耦合和解耦"><a href="#程序的耦合和解耦" class="headerlink" title="程序的耦合和解耦"></a>程序的耦合和解耦</h2><blockquote>
<ul>
<li><p>耦合性（Coupling），是对模块间关联程度的度量。</p>
</li>
<li><p>划分模块的一个准则就是<strong>高内聚低耦合</strong>。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>程序的耦合</strong>，就是程序间的依赖关系。包括：<ul>
<li>类之间的依赖</li>
<li>方法之间的依赖</li>
</ul>
</li>
<li><strong>解耦</strong>，就是降低程序间的依赖关系。在实际开发中，应该做到：<ul>
<li>编译期不依赖，运行时才依赖。</li>
</ul>
</li>
<li><strong>解耦的思路</strong>：<ul>
<li>step1：通过反射来创建对象，而避免使用new关键字。</li>
<li>step2：通过读取配置文件来获取想要创建的对象的全限定类名。</li>
</ul>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在开发中，有些依赖关系必须是显式的，有些依赖关系可以通过优化代码来避免。</p>
<p><strong>问：</strong>在使用 JDBC 注册驱动时，为什么不使用<code>DriverManger</code>中的静态方法 <code>registerDriver()</code>，而是采用<code>Class.forName()</code>的方式？</p>
<p><strong>答：</strong></p>
<ol>
<li><code>DriverManager.registerDriver(Driver driver)</code> 是 <code>java.sql</code> 包下的一个静态方法，接收的参数是一个数据库驱动实现类实例，作用是注册数据库驱动程序。如果我们直接调用该方法来注册驱动当然是可以的，需要我们创建一个数据库驱动实现类的实例并将对象传递给<code>registerDriver()</code>方法即可。但是此时：<ul>
<li>如果更换了数据库驱动，假设从 MySQL 数据库驱动换为 Oracle 数据库驱动，那么必须修改代码，重新创建一个 Oracle 数据库驱动对象并传递给 <code>registerDriver()</code> 方法。</li>
<li>如果需要的数据库驱动类不存在，那么在编译期就会直接报错。</li>
</ul>
</li>
<li>使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>反射机制将 MySQL 数据库驱动类对象加载进内存。<ul>
<li>使用反射机制的好处是，消除了编译期依赖，<code>Class.forName()</code>方法中接收的形参是String类型，在编译期传递任意错误的值都不会报错，当然运行时必定会出现错误。 </li>
<li>但是更换数据库驱动时仍然要修改源代码。</li>
</ul>
</li>
<li> 但是第2种方法仍然不是耦合度最低方法。耦合度最低的方式是将数据库配置信息保存在外部配置文件(如<code>.properties</code>)中，在源码中通过读取配置文件的方式将数据库驱动加载进内存中。当我们更换了数据库品牌的时候，只需要修改外部的配置文件即可，而不用对源码做任何修改。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.jdbc;<span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo01</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;        </span><br><span class="line">        <span class="comment">// 注册数据库驱动        </span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);     <span class="comment">// 方式2：通过反射的方式注册数据库驱动</span></span><br><span class="line">        <span class="comment">// DriverManager.registerDriver(new com.mysql.jdbc.Driver());    // 方式1：通过DriverManager中的静态方法registerDriver(Driver driver)来注册驱动</span></span><br><span class="line">        <span class="comment">// 获取连接对象Connection        </span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);    </span><br><span class="line">        <span class="comment">// 获取数据预处理对象PreparedStatement        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user;&quot;</span>;        </span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);        </span><br><span class="line">        <span class="comment">// 执行（查询）语句，并接收返回值        </span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();        </span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 提交事务（MySQL自动提交）        </span></span><br><span class="line">        <span class="comment">// 释放资源        </span></span><br><span class="line">        resultSet.close();        </span><br><span class="line">        preparedStatement.close();        </span><br><span class="line">        connection.close();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="容器-amp-工厂"><a href="#容器-amp-工厂" class="headerlink" title="容器 &amp; 工厂"></a>容器 &amp; 工厂</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1 容器"></a>1 容器</h2><p>Spring 的作者 Rod Johnson 设计了两个顶级接口来表示容器，分别是：</p>
<ul>
<li>  <strong>BeanFactory</strong></li>
<li>  <strong>ApplicationContext</strong></li>
</ul>
<p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，key 是 BeanName，value 是 Bean 的 Class 对象。通常只提供注册（put），获取（get）这两个功能，我们一般称其为 “<strong>低级容器</strong>”。</p>
<p>那么相对的，ApplicationContext 一般被称为 “<strong>高级容器</strong>”。它继承了包括 BeanFactory 在内的多个接口，在 BeanFactory 的基础上提供了更多的功能。</p>
<p>例如资源的获取，支持多种消息（例如 JSP tag 的支持），相较于 BeanFactory 多了工具级别的支持。所以它的名字已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。</p>
<p>ApplicationContext 接口的源码中定义了一个 <code>refresh()</code> 方法（高级容器特有的方法），此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p>
<h3 id="低级容器的-IOC-过程"><a href="#低级容器的-IOC-过程" class="headerlink" title="低级容器的 IOC 过程"></a>低级容器的 IOC 过程</h3><p>IOC 在 Spring 里，只需要低级容器就可以实现：</p>
<ol>
<li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li>
<li>调用 <code>getBean</code> 的时候，从 BeanDefinition 所属 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 <code>getBean</code> 方法完成多个类的依赖注入。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>  Spring 应用程序在启动时，就会读取并加载配置文件到内存中，根据配置文件中的全限定类名创建对应的 Class 类对象并保存到容器中。</li>
<li>  <strong>懒加载</strong>是指需要实例对象的时候，将 Class 对象拿出来创建对象的实例对象。而 Class 对象则是在程序启动时一次性加载到内存中的的，并且会将 Class 实例保存到容器中作为 Value。</li>
</ul>
<hr>
<h2 id="2-工厂"><a href="#2-工厂" class="headerlink" title="2 工厂"></a>2 工厂</h2><p>Spring 的 IoC 是通过 <strong>简单工厂模式 + 反射机制</strong> 来实现的。</p>
<p>工厂主要有如下几个作用：</p>
<ol>
<li><p> 在程序启动时，读取配置文件，根据配置文件中 bean 的全限定类名创建其对应的 Class 类对象并保存到一个 Map 结构的容器中。【反射】</p>
</li>
<li><p> 对外提供 getInstance 方法，在需要使用实例对象的时候提供对应的实例对象，而不用自己去创建<code>(new)</code></p>
</li>
<li><p>工厂模式内部是通过反射机制，从容器中拿到对应的 Class 对象，根据 Class 对象动态的创建对应的对象实例。</p>
</li>
</ol>
<h3 id="2-1-工厂的体系结构（BeanFactory-vs-ApplicationContext）"><a href="#2-1-工厂的体系结构（BeanFactory-vs-ApplicationContext）" class="headerlink" title="2.1 工厂的体系结构（BeanFactory vs. ApplicationContext）"></a>2.1 工厂的体系结构（BeanFactory vs. ApplicationContext）</h3><blockquote>
<p><strong>Spring容器体系结构图（部分）</strong></p>
</blockquote>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/Spring%E5%AE%B9%E5%99%A8%E7%B1%BB.png" alt="Spring容器类"></p>
<h5>BeanFactory 和 ApplicationContext 的继承关系：</h5>


<p>BeanFactory 和 ApplicationContext 是 Spring 容器的两大顶级接口，都可以当做 Spring 容器。其中 BeanFactory 是 Spring 容器最顶级的接口，ApplicationContext 是 BeanFactory 的子接口。</p>
<p>BeanFactory 接口内部定义了一系列顶级抽象方法（包含各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系等）。</p>
<p>ApplicationContext 接口作为 BeanFactory 的子接口，除了拥有 BeanFactory 声明的所有功能外，还继承了很多其它的接口，因此可以提供更多的功能。如：</p>
<ul>
<li>  支持国际化。</li>
<li>  支持统一的资源文件访问方式。</li>
<li>  提供在监听器中注册bean的事件。</li>
<li>  支持同时加载多个配置文件。</li>
<li>  载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层。</li>
</ul>
<h5>BeanFactory 和 ApplicationContext 对应的不同加载方式：</h5>


<p>​    <code>BeanFactroy</code> 采用的是<strong>懒加载</strong>的形式来注入 Bean 的，即只有在使用到某个Bean时（调用 <code>getBean()</code>）才对该 Bean 进行加载实例化。这样，我们就不能第一时间发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入，BeanFacotry 加载后，直至第一次使用调用 <code>getBean()</code> 方法才会抛出异常。</p>
<p>​    <code>ApplicationContext</code> 是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，如果存在的配置错误就会直接报错，这样有利于检查所依赖属性是否注入。这种方式的优点是：<code>ApplicationContext</code> 启动后预载入所有的单例 Bean，当你需要使用的时候，无需等待，因为它们已经创建好了，可以直接使用。缺点是：相对于基本的 <code>BeanFactory</code>，<code>ApplicationContext</code> 唯一的不足是占用内存空间。当应用程序配置 Bean 较多时，程序启动较慢。</p>
<h5>ApplicationContext接口常用的实现类：</h5>


<ul>
<li>  <strong>ClassPathXmlApplicationContext</strong>：它是从类的根路径下加载配置文件【推荐使用】</li>
<li>  <strong>FileSystemXmlApplicationContext</strong>：它是从磁盘路径上加载配置文件。</li>
<li>  <strong>AnnotationConfigApplicationContext</strong>：当我们使用Spring的纯注解开发时，需要使用此类来加载<strong>配置类</strong>。</li>
</ul>
<hr>
<h1 id="Spring中基于XML的IoC环境搭建"><a href="#Spring中基于XML的IoC环境搭建" class="headerlink" title="Spring中基于XML的IoC环境搭建"></a>Spring中基于XML的IoC环境搭建</h1><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1 代码实现"></a>1 代码实现</h2><ol>
<li><p>创建Maven工程并导入 <code>spring-contex</code> 依赖。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个配置文件 <code>bean.xml</code>，保存要创建的对象的全限定类名以及对应的<code>id</code>，用于通过反射创建对象。</p>
<ul>
<li><code>bean.xml</code>配置文件的约束：</li>
</ul>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>       </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--待创建的bean对象--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;自定义id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;全限定类名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用注解配置 IoC 时配置文件的约束：</li>
</ul>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>       </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--告知spring创建时，容器要扫描的包--&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xsyu&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>创建测试类。在测试类中读取配置文件，创建Spring容器（底层是Map结构），并使用 <code>getBean()</code> 方法中从 Spring容器中获取对应的实例对象。</p>
<ul>
<li>  Spring 容器中的的 key 是 <code>bean.xml</code> 配置文件中<code>&lt;bean&gt;</code>标签的 id 属性；</li>
<li>  Spring 容器中的的 value 是根据 <code>bean.xml</code> 配置文件中<code>&lt;bean&gt;</code>标签中的 class 属性对应的全限定类名通过反射创建出来的 <strong>Class类对象</strong>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建工厂实例</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 工厂实例从IoC容器中获取实例对象</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="2-IoC中bean标签和管理对象细节"><a href="#2-IoC中bean标签和管理对象细节" class="headerlink" title="2 IoC中bean标签和管理对象细节"></a>2 IoC中bean标签和管理对象细节</h2><p><code>bean.xml</code> 是一个配置文件，该文件内所有的数据都被用来根据反射创建对象。</p>
<h3 id="2-1-bean标签"><a href="#2-1-bean标签" class="headerlink" title="2.1 bean标签"></a>2.1 bean标签</h3><p><strong>作用：</strong></p>
<ul>
<li>用于配置要添加到容器中的对象的信息（id和全限定类名）。</li>
<li><u>默认情况下，工厂创建实例对象时使用的是类的无参构造函数，如果没有无参构造函数则不能创建成功。</u></li>
</ul>
<p><strong>属性：</strong></p>
<ul>
<li><code>id</code>：是对象在 Spring 容器中的 key，用于获取对象。</li>
<li><code>class</code>：指定类的全限定类名。[全类名被用于通过反射创建对象，默认情况下调用无参构造函数初始化。]</li>
<li><code>scope</code>：指定对象的作用范围。<ol>
<li><code>singleton</code>：单例的。默认值</li>
<li><code>prototype</code>：多例的</li>
<li><code>request</code>：一次请求范围内</li>
<li><code>session</code>：一次会话范围内</li>
<li><code>global session</code>：全局session，一个集群范围内。如果没有集群，等价于<code>session</code></li>
</ol>
</li>
<li><code>init-method</code>：指定类中初始法方法的名称。</li>
<li><code>destroy-method</code>：指定类中销毁方法的名称</li>
</ul>
<h3 id="2-2-Bean-的作用范围和生命周期"><a href="#2-2-Bean-的作用范围和生命周期" class="headerlink" title="2.2 Bean 的作用范围和生命周期"></a>2.2 Bean 的作用范围和生命周期</h3><table>
<thead>
<tr>
<th align="center">单例对象</th>
<th align="center">多例对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">scope=”singleton”</td>
<td align="center">scope=”prototype”</td>
</tr>
<tr>
<td align="center">容器中只有一个该类的实例对象。它的作用范围就是整个应用[即无论哪里用到该对象，都是同一个对象]。</td>
<td align="center">一个容器中<strong>可以有无数个</strong>该类的实例对象。每次需要使用该对象时，就会重新创建实例对象。</td>
</tr>
</tbody></table>
<p>单例对象的生命周期：</p>
<ul>
<li>  对象出生：当应用程序加载时，读取了配置文件，创建了Spring容器时，单例对象就被创建了。</li>
<li>  对象活着：只要容器还存在，单例对象就一直活着。</li>
<li>对象死亡：当应用程序关闭，容器被销毁时，对象就被销毁了。</li>
</ul>
<p>多例对象的生命周期：</p>
<ul>
<li>  对象创建：Spring 容器被创建时，对象并没有被创建。当程序中的某一步骤需要使用该对象时，才会创建对象的实例。[懒加载]</li>
<li>  对象活着：只要程序运行中某一步骤还需要使用该对象，多例对象就一直活着。</li>
<li>  对象死亡：当对象长时间不用时，由Java的垃圾回收器回收。</li>
</ul>
<h3 id="2-3-实例化Bean的三种方式"><a href="#2-3-实例化Bean的三种方式" class="headerlink" title="2.3 实例化Bean的三种方式"></a>2.3 实例化Bean的三种方式</h3><blockquote>
<ul>
<li>使用默认无参构造函数</li>
<li>使用静态工厂</li>
<li>使用实例化工厂</li>
</ul>
</blockquote>
<h4>1、使用默认无参构造函数</h4>


<p><strong>默认情况</strong>下，Spring容器会根据全限定类名找到对应的类，并根据类中无参构造器来创建实例对象。如果类中没有无参构造器，将会创建失败。</p>
<ul>
<li>  默认情况下，JVM 会给每个类提供一个无参构造函数，所以如果没有重写构造函数，是可以直接创建实例对象的。</li>
<li>  如果重写了无参构造函数，那么 Spring 容器会使用你重写的这个无参构造函数来创建实例对象，也是可以创建成功的。</li>
<li>  但是如果重写了构造函数，但是只重写了带参构造函数，而没有重写无参构造函数，则默认的无参构造函数则会失效，这时候使用Spring默认的实例化Bean的方式创建实例对象就会失败。</li>
</ul>
<p>所以说，<strong>对于Spring容器默认的实例化 Bean 的方式，只要存在无参构造函数，就可以成功创建对象。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认情况--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h4>2、Spring管理静态工厂，使用静态工厂中的方法创建对象</h4>


<ol>
<li>创建一个静态工厂，这个工厂中的方法用于实例化Bean对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 模拟一个静态工厂，创建dao层实现类*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置<code>bean.xml</code>文件中的<code>&lt;bean&gt;标签</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--	</span></span><br><span class="line"><span class="comment">使用StaticFactory类中的静态方法`createUserDao()`创建对象，并存入Spring容器。		</span></span><br><span class="line"><span class="comment">	id：指定bean的唯一标识，用于从容器中获取实例对象。		</span></span><br><span class="line"><span class="comment">	class：指定静态工厂的全限定类名。</span></span><br><span class="line"><span class="comment">  	factory-method：指定生产对象的静态方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span>       </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.factory.StaticFactory&quot;</span>      </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  分析：</p>
</blockquote>
<ol>
<li><code>&lt;bean&gt;</code>标签中存在<strong>静态工厂类的全限定类名</strong>，可以通过反射创建类对应的 Class 实例，通过 Class 实例直接调用类中的方法，不必实例化。**[即Spring容器中并没有<code>cn.xsyu.factory.StaticFactory</code>的实例对象]**</li>
<li><code>class=&quot;cn.xsyu.factory.StaticFactory&quot;</code>只是起到了一个代理的作用，通过类中的<code>createUserDao()</code>方法<strong>创建了<code>UserDaoImpl</code>实例对象，并将其加入spring容器</strong>，指定唯一标识<code>id=&quot;usertDao&quot;</code></li>
</ol>
<hr>
<h4>3、Spring管理实例工厂，使用实例工厂中的方法创建对象</h4>


<ol>
<li><p>创建一个实例工厂，这个工厂中的方法用于实例化Bean对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 模拟一个实例工厂，创建dao层实现类。</span></span><br><span class="line"><span class="comment">* 此工厂创建对象，必须要有工厂实例对象，才能调用方法。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置<code>bean.xml</code>文件中的<code>&lt;bean&gt;标签</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--	</span></span><br><span class="line"><span class="comment">	先把工厂的创建（实例化）交给spring来管理，然后再使用工厂的实例化对象`factory-bean`来调用对象中的方法，					factory-bean：用于指定实例工厂bean的唯一标识；		</span></span><br><span class="line"><span class="comment">		factory-method：用于指定实例工厂中的方法。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.factory.InstanceFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span>      </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-bean</span>=<span class="string">&quot;instanceFactory&quot;</span>      </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>  分析：</p>
</blockquote>
<ol>
<li><code>bean</code>标签中存在非静态工厂的全限定类名<code>cn.xsyu.factory.InstanceFactory</code>，要想使用实例工厂对象中的方法，则必须通过反射得到<code>InstanceFactory</code>对象的实例。</li>
<li>通过 Class 对象得到对应的实例对象，并将其交给 Spring 管理。**[内存中存在<code>cn.xsyu.factory.InstanceFactory</code>的实例对象]**</li>
<li>得到 <strong>InstanceFactory</strong> 实例对象后，再通过<code>factory-method</code>调用对象中的方法<code>createUserDao</code>，最后得到方法的返回值交给 Spring容器管理，并指定唯一标识<code>id=&quot;accountDao&quot;</code>。</li>
</ol>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/%E5%AE%9E%E4%BE%8B%E5%8C%96bean%E7%9A%84%E6%96%B9%E5%BC%8F-1598445621956.png"></p>
<hr>
<h1 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h1><blockquote>
<ul>
<li>依赖注入是什么</li>
<li>构造函数注入</li>
<li>set方法注入</li>
<li>注入集合属性（set方法）</li>
</ul>
</blockquote>
<h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1 是什么？"></a>1 是什么？</h2><ul>
<li>  IoC 的实现方式有 <strong>依赖查找</strong> 和 <strong>依赖注入</strong>。由于依赖查找使用的很少，因此 IoC 也叫做依赖注入（DI）。</li>
<li>  <strong>DI</strong> 的设计原则允许我们<strong>移除硬编码依赖来降低程序间的耦合度</strong>。</li>
<li>  我们的程序在编写时，通过控制反转，把对象的创建交给了spring，但是代码中不可能出现没有依赖的情况。IoC解耦只是降低它们的依赖关系，而不会消除。</li>
<li>  例如：我们的业务层仍然会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring自己来维护了。简单的说，w我们只进行声明，具体的过程就是坐等框架把持久层对象传入业务层，而不用我们自己在业务层去获取。</li>
</ul>
<hr>
<h2 id="2-依赖注入的3种方式"><a href="#2-依赖注入的3种方式" class="headerlink" title="2    依赖注入的3种方式"></a>2    依赖注入的3种方式</h2><blockquote>
<p>  依赖注入的数据类型（3类）：</p>
</blockquote>
<ul>
<li>基本类型和String</li>
<li>其它bean类型（在配置文件中配置或者注解配置过的bean）</li>
<li>复杂类型/集合类型</li>
</ul>
<blockquote>
<p>  依赖注入的方式（2种）：</p>
</blockquote>
<ul>
<li>使用构造函数注入</li>
<li>使用set方法注入</li>
</ul>
<h3 id="2-1-构造函数注入"><a href="#2-1-构造函数注入" class="headerlink" title="2.1    构造函数注入"></a>2.1    构造函数注入</h3><ul>
<li>  顾名思义，就是在使用指定的构造器初始化对象时，通过给构造器中的属性赋值，创建出有初始值的对象。</li>
<li>  实际上使用默认无参构造函数初始化类时，也就是<code>&lt;construct-arg&gt;</code>标签中没有任何内容，所以自然可以省略该标签，初始化时bean对象自然也就没有任何初始值了。</li>
<li>  注意：赋值的操作不是我们自己做的，而是通过设置配置文件让 Spring 框架来为我们注入，我们只需要提供 <strong>要使用的初始值</strong> 和 <strong>对应的构造函数</strong> 即可。</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<ol>
<li>定义一个类对象<code>AccountServiceImpl</code>，重写其中的构造方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;    </span><br><span class="line">    <span class="keyword">private</span> Date birthday;    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountServiceImpl</span><span class="params">(String name, <span class="type">int</span> age, Date birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;        </span><br><span class="line">        <span class="built_in">this</span>.age = age;        </span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;:&quot;</span>+age+<span class="string">&quot;:&quot;</span>+birthday);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在<code>bean.xml</code>配置文件中，使用<code>构造函数注入</code>的方式，给<code>AccountServiceImpl</code>类中的成员变量赋值。</p>
<ul>
<li><p>类中构造函数的参数列表需与配置文件中给出的初始化属性一一映射。</p>
</li>
<li><p>涉及的标签：**<code>&lt;constructor-arg&gt;</code>**</p>
</li>
<li><p>标签出现的位置：<code>&lt;bean&gt;</code>标签的内部</p>
</li>
<li><p>标签中的属性：标签中的属性可分为2类，一类用来与类中构造函数中的参数产生映射关系，另一类是对参数进行赋值。</p>
<ul>
<li><p>以下三个属性均可用于绑定构造函数中的某个参数：</p>
<blockquote>
<ol>
<li><code>type</code>：用于指定参数的数据类型；【如果该类型的参数在构造函数列表中只有唯一一个与之匹配，则能注入成功，否则注入失败】</li>
<li><code>index</code>：指定参数在构造函数参数列表中的索引位置，指定索引的位置从0开始。            </li>
<li><strong>name</strong>：用于给指定的构造函数中的指定名称的参数赋值。【常用】</li>
</ol>
</blockquote>
</li>
<li><p>下面两个参数则用于对绑定的参数进行赋值：</p>
<blockquote>
<ol>
<li><code>value</code>：用于提供基本类型和String类型的数据</li>
<li><code>ref</code>：用于指定其他bean类型的数据。它只能指定在spring的IoC核心容器中出现过的bean对象。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.AccountServiceImpl&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;飞龙在天&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;45&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;time&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置一个日期对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>







<hr>
<h3 id="2-2-set方法注入"><a href="#2-2-set方法注入" class="headerlink" title="2.2    set方法注入"></a>2.2    set方法注入</h3><blockquote>
<p>顾名思义，就是在类初始化时使用中 set 方法给类中的属性赋值，这样创建出来的对象就是有初始值的。</p>
</blockquote>
<ol>
<li>创建JavaBean类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="comment">// 要注入成员    </span></span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;    </span><br><span class="line">    <span class="keyword">private</span> Date birthday;	</span><br><span class="line">    <span class="comment">// set方法    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(Date birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(name+<span class="string">&quot;:&quot;</span>+age+<span class="string">&quot;:&quot;</span>+birthday);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建配置文件，通过配置文件给JavaBean中的属性传值。使用<code>set</code> 方法的方式。</p>
<ul>
<li><p>使用的标签：**<code>&lt;property&gt;</code> **</p>
</li>
<li><p>出现的位置：<code>&lt;bean&gt;</code>标签内部</p>
</li>
<li><p>标签的属性：</p>
<blockquote>
<ol>
<li><code>name</code>：name属性的值与类中字段的值无关，只与<code>set方法</code>有关【去掉set后首字母小写】</li>
<li><code>value</code>：给JavaBean中的属性赋的值是基本数据类型和String类型的。</li>
<li><code>ref</code>:给JavaBean中的属性赋的值是其它bean类型的</li>
</ol>
</blockquote>
</li>
<li><p>实际开发中，此种方法用的较多。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.AccountServiceImpl2&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;施瓦奇迹&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;time&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置一个日期对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="2-3-使用-set-方法注入集合属性"><a href="#2-3-使用-set-方法注入集合属性" class="headerlink" title="2.3    使用 set 方法注入集合属性"></a>2.3    使用 set 方法注入集合属性</h3><ul>
<li>顾名思义，就是给类中的集合成员传值。它用的是set方法注入的方式，只不过变量的数据类型都是集合。</li>
</ul>
<ol>
<li><p>创建一个JavaBean类。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl3</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] arrs;    </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;    </span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets;    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;    </span><br><span class="line">    <span class="keyword">private</span> Properties props;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArrs</span><span class="params">(String[] arrs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arrs = arrs;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLists</span><span class="params">(List&lt;String&gt; lists)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lists = lists;    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.sets = sets;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.maps = maps;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProps</span><span class="params">(Properties props)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.props = props;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;    </span><br><span class="line">        System.out.println(Arrays.toString(arrs));        </span><br><span class="line">        System.out.println(lists);        </span><br><span class="line">        System.out.println(sets);       </span><br><span class="line">        System.out.println(maps);      </span><br><span class="line">        System.out.println(props);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建一个配置文件<code>bean.xml</code>。</p>
<p> 注入集合数据：</p>
<ol>
<li><p>List结构的：</p>
<ul>
<li><p><code>&lt;array&gt;&lt;value&gt;</code></p>
</li>
<li><p><code>&lt;list&gt;&lt;value&gt;</code></p>
</li>
<li><p><code>&lt;set&gt;&lt;value&gt;</code></p>
</li>
</ul>
</li>
<li><p>Map结构的：</p>
<ul>
<li><p><code>&lt;map&gt;&lt;entry&gt;</code></p>
</li>
<li><p><code>&lt;props&gt;&lt;prop&gt;</code></p>
</li>
</ul>
</li>
<li><p>在注入集合数据时，只要结构相同，标签可以互换。</p>
</li>
</ol>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.AccountServiceImpl3&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arrs&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>C<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lists&quot;</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>A<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BB<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span>       </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>B<span class="tag">&lt;/<span class="name">value</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>C<span class="tag">&lt;/<span class="name">value</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;testA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aaa&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;testB&quot;</span>&gt;</span>               </span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span>        </span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;props&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;propC&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;propD&quot;</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="3-案例：使用纯XML实现单表的CRUD操作"><a href="#3-案例：使用纯XML实现单表的CRUD操作" class="headerlink" title="3    案例：使用纯XML实现单表的CRUD操作"></a>3    案例：使用纯XML实现单表的CRUD操作</h2><blockquote>
<p>  <strong>需求</strong></p>
</blockquote>
<ul>
<li>实现用户的 CRUD 操作</li>
</ul>
<blockquote>
<p>  <strong>技术要求</strong></p>
</blockquote>
<ul>
<li>使用Spring的 IoC 实现对象的管理</li>
<li>使用<code>dbutils</code>作为持久层解决方案</li>
<li>使用<code>c3p0</code>数据源</li>
</ul>
<blockquote>
<p>  <strong>环境搭建</strong></p>
</blockquote>
<ul>
<li>导入依赖</li>
</ul>
<h3 id="1、创建数据库"><a href="#1、创建数据库" class="headerlink" title="1、创建数据库"></a>1、创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库</span><br><span class="line">CREATE TABLE IF NOT EXISTS USER(	</span><br><span class="line">    id INT(2) AUTO_INCREMENT PRIMARY KEY,	</span><br><span class="line">    username VARCHAR(9) NOT NULL,	</span><br><span class="line">    gender VARCHAR(3) NOT NULL,</span><br><span class="line">    hobby VARCHAR(32)</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO USER(username, gender, hobby)VALUES(&quot;里番&quot;, &quot;男&quot;, &quot;口琴&quot;);</span><br><span class="line">INSERT INTO USER(username, gender, hobby)VALUES(&quot;刘玉豪&quot;, &quot;男&quot;, &quot;篮球&quot;);</span><br><span class="line">INSERT INTO USER(username, gender, hobby)VALUES(&quot;谭思雨&quot;, &quot;男&quot;, &quot;足球&quot;);</span><br></pre></td></tr></table></figure>



<h3 id="2、-编写实体类"><a href="#2、-编写实体类" class="headerlink" title="2、 编写实体类"></a>2、 编写实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 用户的实体类 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;   </span><br><span class="line">    <span class="keyword">private</span> Integer id;   </span><br><span class="line">    <span class="keyword">private</span> String username;  </span><br><span class="line">    <span class="keyword">private</span> String gender;  </span><br><span class="line">    <span class="keyword">private</span> String hobby;   </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +       </span><br><span class="line">            <span class="string">&quot;id=&quot;</span> + id +           </span><br><span class="line">            <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +    </span><br><span class="line">            <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +          </span><br><span class="line">            <span class="string">&quot;, hobby=&#x27;&quot;</span> + hobby + <span class="string">&#x27;\&#x27;&#x27;</span> +        </span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> id;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.id = id; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> username;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.username = username; </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> gender;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHobby</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobby</span><span class="params">(String hobby)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、编写持久层代码"><a href="#3、编写持久层代码" class="headerlink" title="3、编写持久层代码"></a>3、编写持久层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 操作数据库接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;   </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 增   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span>; </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 删   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 改   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;  </span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 查询所有    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 根据id查询  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;&#125;</span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">/*	持久层接口的实现类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;  </span><br><span class="line">    <span class="comment">// dbutils中操作数据库的核心对象，需要注入数据 </span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunner</span><span class="params">(QueryRunner runner)</span> &#123;    </span><br><span class="line">        <span class="built_in">this</span>.runner = runner;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 增 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">try</span> &#123;       </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user (username, gender, hobby) values(?,?,?)&quot;</span>;  </span><br><span class="line">            result = runner.update(sql, user.getUsername(), user.getGender(), user.getHobby());   </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;       </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 删  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">try</span>&#123;         </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user where id=?&quot;</span>;  </span><br><span class="line">            result = runner.update(sql, id);   </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;         </span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;     </span><br><span class="line">            <span class="keyword">return</span> result;      </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 改   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">try</span> &#123;      </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set username=?,gender=?,hobby=? where id=?&quot;</span>;     </span><br><span class="line">            result = runner.update(sql, user.getUsername(), user.getGender(), user.getHobby(),user.getId());   </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">            e.printStackTrace();     </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;     </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 查询所有   </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;      </span><br><span class="line">        List&lt;User&gt; users = <span class="literal">null</span>;     </span><br><span class="line">        <span class="keyword">try</span> &#123;          </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;    </span><br><span class="line">            users = runner.query(sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;User&gt;(User.class));    </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;      </span><br><span class="line">            <span class="keyword">return</span> users;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 查询一个 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;   </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;    </span><br><span class="line">        <span class="keyword">try</span> &#123;         </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id=?&quot;</span>;     </span><br><span class="line">            user = runner.query(sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;User&gt;(User.class), id);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;      </span><br><span class="line">            e.printStackTrace();      </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;        </span><br><span class="line">            <span class="keyword">return</span> user;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、编写业务层代码"><a href="#4、编写业务层代码" class="headerlink" title="4、编写业务层代码"></a>4、编写业务层代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 增  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 删  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 改  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 查    </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 查  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	业务层接口的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> cn.xsyu.service.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="comment">// 依赖注入  </span></span><br><span class="line">    <span class="keyword">private</span> UserDao dao;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDao</span><span class="params">(UserDao dao)</span> &#123;   </span><br><span class="line">        <span class="built_in">this</span>.dao = dao;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">create</span><span class="params">(User user)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> dao.create(user);  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> dao.delete(id);  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> dao.update(user);  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> dao.findAll();    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> dao.findById(id); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、创建并编写配置文件"><a href="#5、创建并编写配置文件" class="headerlink" title="5、创建并编写配置文件"></a>5、创建并编写配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans      </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--配置service--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.service.impl.UserServiceImpl&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置dao--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xsyu.dao.impl.UserDaoImpl&quot;</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;queryRunner&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置QueryRunner--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;queryRunner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    <span class="comment">&lt;!--配置数据源--&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!--数据库连接必备的信息--&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>/&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="6、编写测试类代码"><a href="#6、编写测试类代码" class="headerlink" title="6、编写测试类代码"></a>6、编写测试类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.test;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 调用Junit单元测试，测试我们的配置 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;  </span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 测试保存新成员方法 </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="meta">@Test</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate</span><span class="params">()</span>&#123;     </span><br><span class="line">        <span class="comment">// 创建spring工厂      </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);    </span><br><span class="line">        <span class="comment">// 获取可执行对象    </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);   </span><br><span class="line">        <span class="comment">// 执行对象中方法     </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); </span><br><span class="line">        user.setUsername(<span class="string">&quot;spring&quot;</span>);       </span><br><span class="line">        user.setGender(<span class="string">&quot;女&quot;</span>);      </span><br><span class="line">        user.setHobby(<span class="string">&quot;java&quot;</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> service.create(user);    </span><br><span class="line">        System.out.println(result); </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 测试删除方法     </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="comment">// 创建spring容器  </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);   </span><br><span class="line">        <span class="comment">// 获取service层对象    </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);       </span><br><span class="line">        <span class="comment">// 调用service层的方法   </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> service.delete(<span class="number">7</span>);     </span><br><span class="line">        <span class="comment">// 获取返回结果      </span></span><br><span class="line">        System.out.println(result); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 测试查询所有 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;    </span><br><span class="line">        <span class="comment">// 获取spring容器    </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取service层对象 </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);   </span><br><span class="line">        <span class="comment">// 调用service层的方法       </span></span><br><span class="line">        List&lt;User&gt; users = service.findAll();    </span><br><span class="line">        <span class="comment">// 获取返回结果   </span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123; </span><br><span class="line">            System.out.println(user);     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * 测试查询一个方法   </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@Test</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindOne</span><span class="params">()</span>&#123;    </span><br><span class="line">        <span class="comment">// 获取sprig容器 </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取service层对象   </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);  </span><br><span class="line">        <span class="comment">// 调用service层的方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> service.findById(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取返回结果     </span></span><br><span class="line">        System.out.println(user); </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 测试update方法 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;   </span><br><span class="line">        <span class="comment">// 获取spring容器     </span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);       </span><br><span class="line">        <span class="comment">// 获取service层对象    </span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);      </span><br><span class="line">        <span class="comment">// 调用service层的方法     </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> service.findById(<span class="number">1</span>);      </span><br><span class="line">        user.setUsername(<span class="string">&quot;李帆&quot;</span>);        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> service.update(user);      </span><br><span class="line">        <span class="comment">// 获取返回结果  </span></span><br><span class="line">        System.out.println(result);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7、分析"><a href="#7、分析" class="headerlink" title="7、分析"></a>7、分析</h3><ul>
<li>通过上面的测试，我们可以看出，每个测试方法都重新获取了一次spring的核心容器，造成了不必要的重复代码，增加了开发的工作量。这种情况，在开发中应该避免发生。</li>
<li>解决方法：Junit单元测试</li>
</ul>
<hr>
<h1 id="IoC注解开发"><a href="#IoC注解开发" class="headerlink" title="IoC注解开发"></a>IoC注解开发</h1><ul>
<li>  基于XML配置文件开发：指定配置文件的位置，创建容器时加载配置文件，容器是一个 HashMap 结构，key 为 bean 对象的id，值为 id 对应的全限定类名加载到内存中的 Class 对象。</li>
<li>  注解开发：指定要扫描的包，将该包下指定注解的类加载并保存到容器中。</li>
</ul>
<h2 id="1-使用注解开发时要导入的约束"><a href="#1-使用注解开发时要导入的约束" class="headerlink" title="1    使用注解开发时要导入的约束"></a>1    使用注解开发时要导入的约束</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--告知spring创建时，容器要扫描的包[含有注解的包]--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xsyu&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-注解分类"><a href="#2-注解分类" class="headerlink" title="2    注解分类"></a>2    注解分类</h2><h3 id="2-1-用于创建对象的注解"><a href="#2-1-用于创建对象的注解" class="headerlink" title="2.1    用于创建对象的注解"></a>2.1    用于创建对象的注解</h3><p><strong>作用</strong>：它们的作用就和在XML配置文件中编写一个<code>&lt;bean&gt;</code>标签实现的功能是一样的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Component-value-””"><a href="#Component-value-””" class="headerlink" title="@Component(value=””)"></a>@Component(value=””)</h4><ol>
<li><p><strong>作用范围</strong>：作用在类上。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;	<span class="comment">// 类中的代码</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用</strong>：把资源交给容器来管理，把当前类的 Class 对象存入容器中。相当于在 xml 中配置一个<code>&lt;bean&gt;</code></p>
</li>
<li><p><strong>属性</strong>：<code>value</code>：指定<code>&lt;bean&gt;</code>的 id，如果不显式指定value属性，默认<code>&lt;bean&gt;</code>的id是当前类的类名，首字母小写。</p>
</li>
<li><p><strong>Tip</strong>：如果注解中有且仅有一个属性要赋值，且名称是 <code>value</code>时，<code>value</code>可以省略不写。 </p>
</li>
</ol>
<h4 id="Controller、-Service、-Repository"><a href="#Controller、-Service、-Repository" class="headerlink" title="@Controller、@Service、@Repository"></a>@Controller、@Service、@Repository</h4><p>这三个注解是 <strong>@Component</strong> 衍生的注解，它们的作用和属性都是一样的，只不过是提供了更加明确的语义化定义。</p>
<ol>
<li><code>@Controler</code>：    一般用于表现层的注解</li>
<li><code>@Service</code>：    一般用于业务层的注解</li>
<li><code>@Repository</code>：    一般用于持久层的注解</li>
</ol>
<hr>
<h3 id="2-2-依赖注入（注解）"><a href="#2-2-依赖注入（注解）" class="headerlink" title="2.2    依赖注入（注解）"></a>2.2    依赖注入（注解）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--等价于xml中的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1、-Autowired"><a href="#1、-Autowired" class="headerlink" title="1、@Autowired"></a>1、@Autowired</h4><ol>
<li><p>作用范围：①成员变量 ②成员方法</p>
</li>
<li><p>作用：<strong>自动按照类型注入</strong>。    <strong><code>比较顺序：[待注入数据的数据类型--&gt;&gt;待注入数据的变量名]</code></strong></p>
<ul>
<li>如果类代码中待注入对象的数据类型无法和 Spring 容器中的任何一个实例对象相匹配，则报错。</li>
<li>如果 Spring 容器中只有唯一一个实例对象的数据类型与类代码中的数据类型匹配，直接注入成功。    <ul>
<li>如果在 Spring 容器中同时存在多个实例对象可以与类代码中某个对象的数据类型相匹配时，则继续使用类代码中对象的<code>变量名</code>与容器中的<code>id</code>进行匹配，找到了也可以注入成功，找不到就报错。</li>
</ul>
</li>
<li>当使用注解注入属性时，<code>set</code>方法可以省略。</li>
<li><code>@Autowired</code>只能注入其它<code>bean</code>类型【除了基本类型和String以外的类型】。</li>
</ul>
</li>
</ol>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/%E8%87%AA%E5%8A%A8%E6%8C%89%E7%85%A7%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5-1598445621956.png"></p>
<hr>
<h4 id="2、-Qualifier"><a href="#2、-Qualifier" class="headerlink" title="2、@Qualifier"></a>2、@Qualifier</h4><ol>
<li><p>作用范围：①成员变量 ②成员方法中的形式参数</p>
</li>
<li><p>作用：按照名称注入。</p>
<ul>
<li><strong>它在给成员变量注入时不能单独使用，必须在使用<code>@Autowired</code>注解的基础之上再按照名称注入。</strong></li>
<li><strong>但是在给方法中的局部变量（形式参数）注入时可以单独使用。</strong></li>
</ul>
</li>
<li><p>属性：<code>value</code>：指定要注入的数据在IoC容器中<code>bean</code>对应的id。</p>
</li>
<li><p>示例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向账户中存入了2000元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="meta">@Repository()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向账户中存入了1000元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired()</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;accountDaoImpl2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao dao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	执行过程分析：</span></span><br><span class="line"><span class="comment">	  1. 使用 @Repository()注解将 AccountDaoImpl2 加入IoC容器。</span></span><br><span class="line"><span class="comment">	  	 使用 @Repository()注解将 AccountDaoImpl 加入IoC容器。</span></span><br><span class="line"><span class="comment">	  	   [</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl2&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl2&quot;&#125;</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl&quot;&#125;</span></span><br><span class="line"><span class="comment">      		......													    ]</span></span><br><span class="line"><span class="comment">       使用 @Autowired() 注解查找IoC容器中类型为 `AccountDao` 类型的数据，共找到2个</span></span><br><span class="line"><span class="comment">      	[</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl2&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl2&quot;&#125;</span></span><br><span class="line"><span class="comment">      		&#123;id=&quot;accountDaoImpl&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl&quot;&#125;</span></span><br><span class="line"><span class="comment">      																    ]</span></span><br><span class="line"><span class="comment">       3. 使用 `@Qualifier(value=&quot;accountDaoImpl2&quot;)` 注解在容器中筛选出来的字集合中查找id为			     `accountDaoImpl2`的数据，最终找到了:</span></span><br><span class="line"><span class="comment">       		&#123;id=&quot;accountDaoImpl2&quot;, class=&quot;cn.xsyu.dao.impl.AccountDaoImpl2&quot;&#125;,</span></span><br><span class="line"><span class="comment">        并将对应的类对象的数据注入。（在这里是创建实例对象，并将引用传给`dao`）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="3、-Resource"><a href="#3、-Resource" class="headerlink" title="3、@Resource"></a>3、@Resource</h4><ol>
<li>作用范围：①成员变量  ②成员方法</li>
<li>作用：直接按照<code>bean</code>的 id 注入，它可以独立使用。它也只能注入其它<code>bean</code>类型</li>
<li>属性：<code>name</code>：指定要注入的数据在 IoC 容器中<code>bean</code>对应的 id。</li>
</ol>
<h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip:"></a>Tip:</h4><ul>
<li>以上3个注入都只能注入其它bean类型的数据，而基本类型和String类型无法使用上述注解实现。</li>
</ul>
<hr>
<h4 id="4、-Value"><a href="#4、-Value" class="headerlink" title="4、@Value"></a>4、@Value</h4><ol>
<li><strong>作用范围</strong>：成员变量</li>
<li><strong>作用</strong>：可以注入基本类型数据和String类型数据</li>
<li><strong>属性</strong>：<code>value</code>：用于指定值。它可以使用 <strong>SpEL</strong> 表达式(Spring的EL表达式)。<ul>
<li>SpEL格式：<code>$&#123;表达式&#125;</code></li>
</ul>
</li>
<li>示例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(value = &quot;666&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向账户中存入了&quot;</span>+money+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="2-3-用于改变作用范围的注解"><a href="#2-3-用于改变作用范围的注解" class="headerlink" title="2.3    用于改变作用范围的注解"></a>2.3    用于改变作用范围的注解</h3><ul>
<li>它们的作用就和<code>&lt;bean&gt;</code>标签中使用<code>scope</code>属性实现的功能时一样的。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--等价于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><ol>
<li><strong>作用</strong>：用于指定<code>bean</code>的作用范围</li>
<li><strong>属性</strong>：<code>value</code>：指定范围的取值。常用取值：<ol>
<li><code>singleton[单例]</code></li>
<li><code>prototype[多例]</code></li>
<li><code>request</code></li>
<li><code>session</code></li>
<li><code>globalsession</code></li>
</ol>
</li>
</ol>
<h3 id="2-4-和生命周期相关的注解"><a href="#2-4-和生命周期相关的注解" class="headerlink" title="2.4    和生命周期相关的注解"></a>2.4    和生命周期相关的注解</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--相当于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h4><ol>
<li><strong>作用</strong>：用于指定类的初始化方法，即类初始化时先执行的方法。</li>
</ol>
<h4 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h4><ol>
<li><strong>作用</strong>：用于指定类的销毁方法，即类销毁前先执行的方法。</li>
</ol>
<hr>
<h3 id="2-5-关于Spring注解和XML的选择问题"><a href="#2-5-关于Spring注解和XML的选择问题" class="headerlink" title="2.5    关于Spring注解和XML的选择问题"></a>2.5    关于Spring注解和XML的选择问题</h3><blockquote>
<p>  注解的优势</p>
</blockquote>
<ul>
<li>配置简单，维护方便（我们找到了类，就相当于找到了对应的配置）</li>
</ul>
<blockquote>
<p>  XML的优势</p>
</blockquote>
<ul>
<li>修改时，不用修改源码。不涉及重新编译和部署</li>
</ul>
<blockquote>
<p>  Spring管理Bean方式的比较</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">基于XML配置</th>
<th align="left">基于注解配置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Bean定义</td>
<td align="left"><code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code></td>
<td align="left"><code>@Component</code>；衍生类：<code>@Controller、@Service、@Repository</code></td>
</tr>
<tr>
<td align="left">Bean名称</td>
<td align="left">通过<code>id</code>或<code>name</code>指定</td>
<td align="left"><code>@Compoonent(value=&quot;person&quot;)</code></td>
</tr>
<tr>
<td align="left">Bean注入</td>
<td align="left"><code>&lt;property&gt;</code>或<code>&lt;constructor-arg&gt;</code></td>
<td align="left"><code>@Autowired</code>()：按类型注入；  <code>@Qualifier()</code>：按名称注入</td>
</tr>
<tr>
<td align="left">Bean生命周期</td>
<td align="left"><code>init-method</code>；<code>destroy-method</code></td>
<td align="left"><code>@PostConstruct</code>；<code>@PreDestroy</code></td>
</tr>
<tr>
<td align="left">Bean作用范围</td>
<td align="left"><code>scope属性</code></td>
<td align="left"><code>@Scope()</code></td>
</tr>
<tr>
<td align="left">适合场景</td>
<td align="left">Bean来自第三方，使用其它</td>
<td align="left">Bean的实现类由用户自己开发</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-6-新注解说明-区别于XML中功能的注解"><a href="#2-6-新注解说明-区别于XML中功能的注解" class="headerlink" title="2.6    新注解说明(区别于XML中功能的注解)"></a>2.6    新注解说明(区别于XML中功能的注解)</h3><h4 id="1、-Configuration"><a href="#1、-Configuration" class="headerlink" title="1、@Configuration"></a>1、@Configuration</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>用于指定当前类是一个spring的配置类，Spring工厂会读取该类中的配置信息创建容器，相当于读取<code>bean.xml</code>配置文件。</li>
<li>获取容器时需要使用<code>AnnotationApplicationContext(有@Configration注解的类.class)</code>【纯注解开发】</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>value</code>：用于指定配置类的字节码</p>
</li>
<li><p>示例代码</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring配置类，相当于bean.xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ul>
<li>我们已经把配置文件用配置类来代替了，但是如何配置创建容器时要扫描的包呢？</li>
<li>答：<code>@ComponentScan</code>注解</li>
</ul>
</li>
</ol>
<h4 id="2、-ComponentScan"><a href="#2、-ComponentScan" class="headerlink" title="2、@ComponentScan"></a>2、@ComponentScan</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li><p>开启注解扫描，用于指定 Spring 在初始化容器时要扫描的包。</p>
</li>
<li><p>作用和XML配置文件中的 <code>component-scan</code> 是一样的。：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xsyu&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>属性</strong>：</p>
<ul>
<li><code>basePackages</code>：用于指定要扫描的包。</li>
<li><code>value</code>：和<code>basePackages</code>属性的作用是一样的。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring配置类，相当于bean.xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;cn.xsyu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>存在的问题</strong>：</p>
<ul>
<li>我们已经配置好了要扫描的包，但是数据源和<code>JDBCTemplete</code>对象如何从配置文件中转移到注解中呢？</li>
<li>答：<code>@Bean</code>注解</li>
</ul>
</li>
</ol>
<h4 id="3、-Bean"><a href="#3、-Bean" class="headerlink" title="3、@Bean"></a>3、@Bean</h4><ol>
<li><p><strong>作用范围</strong>：方法上【@Component 注解用于将类对象装载到容器中，而 @Bean 注解则用于将方法返回值对象装载到容器中】</p>
</li>
<li><p><strong>作用</strong>：该注解只能作用于方法上，表示将此方法的返回值对象存入 Spring 容器中，并指定唯一标识。</p>
</li>
<li><p><strong>属性</strong>：<code>name</code>：给当前<code>@Bean注解</code>方法创建的对象指定一个唯一标识名称。</p>
</li>
<li><p><strong>示例代码</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接数据库的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个DataSource，并存入spring容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">            ds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            ds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db5&quot;</span>);</span><br><span class="line">            ds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个QueryRunner对象，并存入spring容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queryRunner&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> QueryRunner <span class="title function_">createQueryRunner</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(dataSource);</span><br><span class="line">        <span class="keyword">return</span> queryRunner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>存在的问题</strong>：</p>
<ul>
<li>我们已经把数据源<code>dataSource对象</code>和<code>queryRunner对象</code>从配置文件中转移到<code>JdbcConfig.java</code>类中了，此时就可以删除<code>bean.xml</code>了。</li>
<li>但是由于没有了配置文件，创建数据源<code>DataSource</code>的配置信息又写死在类中了。如何把它们分离出来呢？</li>
<li>答：<code>@PropertySource</code></li>
</ul>
</li>
</ol>
<hr>
<h4 id="4、-PropertySource"><a href="#4、-PropertySource" class="headerlink" title="4、@PropertySource"></a>4、@PropertySource</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>用于加载<code>xxx.properties</code>文件中的配置信息到内存中。</li>
<li>例如我们配置数据源时，就可以把连接数据库的信息写到<code>properties</code>配置文件中，就可以使用此注解指定<code>properties</code>配置文件的位置。</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>vlaue[]</code>：用于指定<code>properties</code>文件位置。如果配置文件在类路径下，需要写上：<strong>classpath：</strong>。</p>
</li>
<li><p><strong>示例代码</strong>：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.config;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接数据库的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span>	<span class="comment">// 指定配置文件的位置，并加载到容器中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>	<span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个DataSource，并存入spring容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">            ds.setDriverClass(driver);</span><br><span class="line">            ds.setJdbcUrl(url);</span><br><span class="line">            ds.setUser(username);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个QueryRunner对象，并存入spring容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queryRunner&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> QueryRunner <span class="title function_">createQueryRunner</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(dataSource);</span><br><span class="line">        <span class="keyword">return</span> queryRunner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*——————————————————————————————————————————————————————————————————————————————————————————*/</span></span><br><span class="line"></span><br><span class="line">jdbc.properties文件：</span><br><span class="line">    jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">    jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/db5</span></span><br><span class="line">    jdbc.username=root</span><br><span class="line">    jdbc.password=root</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  注意：此时，我们已经有了2个配置类：<code>SpringConfiguration.java</code>和<code>JdbcConfig.java</code>，但是它们之间还没有关系。如何建立它们之间的关系呢？</p>
</blockquote>
<ul>
<li>答：<code>@Import</code></li>
</ul>
<hr>
<h4 id="5、-Import"><a href="#5、-Import" class="headerlink" title="5、@Import"></a>5、@Import</h4><ol>
<li><p><strong>作用范围</strong>：类上</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>用于导入其它配置类。【一个项目中可以有多个配置类】</li>
<li>如果不使用<code>@Import</code>注解，则所有配置类都必须通过添加 <code>@Configuration</code> 来表明自己是一个配置类。</li>
<li>如果使用<code>@Import</code>注解在主配置类中引入其它配置类时，子配置类中的<code>@Configuration</code>注解可以省略。当然，写上也没任何问题。</li>
</ul>
</li>
<li><p><strong>属性</strong>：<code>value[]</code>：用于指定子配置类的 Class 类对象。</p>
</li>
<li><p>示例代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring配置类，相当于bean.xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;cn.xsyu&quot;)</span></span><br><span class="line"><span class="meta">@Import(value = &#123;JdbcConfig.class&#125;)</span>		<span class="comment">// 导入`JdbcConfig`子配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>存在的问题</strong>：</p>
<ul>
<li>我们已经把要配置的都配置好了，但是有新的问题产生了，由于没有配置文件了，如何获取Spring容器呢？</li>
</ul>
</li>
</ol>
<h4 id="6、获取容器（注解）"><a href="#6、获取容器（注解）" class="headerlink" title="6、获取容器（注解）"></a>6、获取容器（注解）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);	<span class="comment">// 读取配置类就相当于读取配置文件</span></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h1><blockquote>
<p>  <strong>存在的问题</strong></p>
</blockquote>
<ul>
<li><p>在测试类中，每个测试方法都有以下2行代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取spring容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);</span><br><span class="line"><span class="comment">// 获取service层对象</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) ac.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>这2行代码的作用是获取spring核心容器，如果不写的话，直接会出现空指针异常，所以又不能轻易删掉。</p>
</li>
</ul>
<blockquote>
<p>  <strong>解决思路</strong></p>
</blockquote>
<ul>
<li>针对上述问题，我们需要的是<strong>程序能自动帮助我们读取配置文件/配置类，并创建Spring容器</strong>。一旦程序能自动为我们创建 Spring 容器，我们就无需手动创建了，问题也自然就解决了。</li>
</ul>
<h2 id="1-junit单元测试的原理"><a href="#1-junit单元测试的原理" class="headerlink" title="1    junit单元测试的原理"></a>1    junit单元测试的原理</h2><ol>
<li>所有程序的入口：<ul>
<li><code>main</code>方法</li>
</ul>
</li>
<li>junit单元测试中，没有<code>main方法</code>也能执行的原理：<ul>
<li>junit单元测试集成了一个<code>main方法</code></li>
<li>该集成方法会判断当前测试类中哪些方法有<code>@Test</code>注解</li>
<li>junit就会让有<code>@Test</code>注解的方法执行。</li>
</ul>
</li>
<li>junit不会关注我们是否使用了<code>spring</code>框架。<ul>
<li>也就是说，在执行测试方法时，junit根本不知道我们是否使用了spring框架。</li>
<li>所以也就不会为我们读取配置文件/配置类，创建spring容器。</li>
</ul>
</li>
<li>由以上3点可知：<ul>
<li>当测试方法执行时，就算添加<code>@Autowired</code>注解，由于没有spring核心容器，也无法实现注入。</li>
</ul>
</li>
<li>解决方案：<ul>
<li>但是junit给我们提供了一个注解，让我们可以替换掉它的运行器。</li>
<li>只要把junit的运行器替换成可以自动读取配置文件，创建spring容器的运行器，就可以解决上述问题了。</li>
<li>Spring框架正好提供了一个运行器，可以<strong>自动</strong>读取配置文件/配置类来创建spring容器。我们只需要告诉它配置文件在哪里就行了。</li>
</ul>
</li>
</ol>
<h2 id="2-配置步骤"><a href="#2-配置步骤" class="headerlink" title="2    配置步骤"></a>2    配置步骤</h2><blockquote>
<p>  Spring整合Junit的配置：</p>
</blockquote>
<ol>
<li><p>导入spring整合Junit的jar(坐标)；</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>使用Junit提供的一个注解把替换原有运行器。</p>
<ul>
<li><code>@Runwith</code></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br></pre></td></tr></table></figure>

</li>
<li><p>告知Spring的运行器，spring的核心容器是基于XML还是注解的，并且说明位置。</p>
<ul>
<li><p><code>@ContextConfiguration</code></p>
<p>  属性：</p>
<ul>
<li><code>locations</code>：指定xml文件的位置。加上<code>classpath关键字</code>，表示在类路径下。</li>
<li><code>classes</code>：指定注解类所在的位置。</li>
</ul>
</li>
<li><p>示例代码</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="comment">// 或 @ContextConfiguration(locations = &#123;&quot;classpath:bean.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
<li><p>使用<code>@Autowired</code>和<code>@Qualifier</code>注解给测试类中的变量注入数据。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;    </span><br><span class="line">    <span class="comment">// 数据注入    </span></span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> UserService service;        </span><br><span class="line">    <span class="meta">@Test</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;        </span><br><span class="line">        <span class="comment">// 调用service层的方法        </span></span><br><span class="line">        List&lt;User&gt; users = service.findAll();        </span><br><span class="line">        <span class="comment">// 获取返回结果        </span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>当我们使用<code>spring 5.X</code>版本时，要求<code>junit</code>的jar必须是<code>12++</code></p>
</li>
</ol>
<hr>
<h1 id="Refresh-源码分析"><a href="#Refresh-源码分析" class="headerlink" title="Refresh 源码分析"></a>Refresh 源码分析</h1><p>refresh 的 12 个步骤</p>
<p><strong>一、准备工作</strong></p>
<ol>
<li> prepareRefresh——做好准备工作</li>
</ol>
<p><strong>二、创建和准备 BeanFactory（基础容器）</strong></p>
<ol start="2">
<li> obtainFreshBeanFactory——创建或获取空的 BeanFactory</li>
<li> prepareBeanFactory——准备 BeanFactory</li>
<li> postProcessBeanFactory——子类扩展 BeanFactory</li>
<li> invokeBeanFactoryPostProcessors——后处理器扩展 BeanFactory</li>
<li> registerBeanPostProcessors——准备 Bean 的后处理器</li>
</ol>
<p><strong>三、创建和准备 ApplicationContext（增强容器）</strong></p>
<ol start="7">
<li> initMessageSource——为 ApplicationContext提供国际化功能</li>
<li> initApplicationEventMulticaster——为ApplicationContext 提供事件发布器</li>
<li> onRefresh——留给子类扩展</li>
<li> registerListeners——为 ApplicationContext 准备监听器</li>
<li> <strong>finishBeanFactoryInitialization</strong>——初始化单例 Bean，执行 Bean 后处理器扩展</li>
<li> finishRefresh——准备生命周期管理器，发布 ContextRefreshed 事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1、prepareRefresh"><a href="#1、prepareRefresh" class="headerlink" title="1、prepareRefresh"></a>1、prepareRefresh</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002093938014.png" alt="image-20211002093938014"></p>
<blockquote>
<p>  <strong>prepareRefresh 方法的作用</strong></p>
</blockquote>
<ol>
<li> 创建（初始化）一个容器，这个容器刚被创建出来的时候是一个空的容器；</li>
<li> 创建（初始化）一个 Environment 对象加入到容器中。</li>
</ol>
<blockquote>
<p>  <strong>Environment 对象的作用</strong></p>
</blockquote>
<p>Environment 实例对象主要负责管理各种键值信息。主要包括：</p>
<ol>
<li> 系统属性的键值对形式（systemProperties）</li>
<li> 系统环境变量的键值对形式（systemEnvironment）</li>
<li>自定义的键值对属性（PropertySource）<ul>
<li>  一般是配置文件中的键值对属性。最常见的就是 SpringBoot 中 <code>application.properties</code> 配置文件，该配置文件中的所有配置信息都是由这个 environment 对象加载并保存的，然后再将这个 environment 实例对象加入到 ApplicationContext 中，容器就间接的知道了配置信息。</li>
</ul>
</li>
</ol>
<blockquote>
<p>  <strong>Environment 使用场景</strong></p>
</blockquote>
<ul>
<li>  Environment 的作用之一就是在 @Value 注解中，根据对应的键注入值，这个值就是从 Environment 中获取的。</li>
</ul>
<hr>
<h2 id="2、obtainFreshBeanFactory"><a href="#2、obtainFreshBeanFactory" class="headerlink" title="2、obtainFreshBeanFactory"></a>2、obtainFreshBeanFactory</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211001211518869.png" alt="image-20211001211518869"></p>
<blockquote>
<p>  <strong>obtainFreshBeanFactory 方法的作用：</strong></p>
</blockquote>
<ul>
<li>  创建（或获取）最新的 BeanFactory 对象。</li>
<li>  虽然 ApplicationContext 在结构上属于 BeanFactory 的子类，但实际上 ApplicationContext 类中包含了一个 BeanFactory ，因为在 ApplicationContext 中，有一些基础功能它并没有自己去实现，而是通过去复用 BeanFactory 内部现成的功能实现的。</li>
</ul>
<blockquote>
<p>  <strong>BeanDefinition</strong></p>
</blockquote>
<ul>
<li>  BeanDefinition 保存了具体对象的键值信息，单例还是多例、等等</li>
<li>  <strong>BeanDefinition 的来源：</strong>BeanDefinition 的来源有多种多样，可以通过 xml 获得、通过配置类获得、通过组件扫描获得、也可以通过编程添加。</li>
</ul>
<blockquote>
<p>  <strong>总结：</strong></p>
</blockquote>
<ul>
<li>  BeanFactory 的作用是负责 Bean 的创建、依赖注入和初始化；</li>
<li>  而 BeanDefinition 作为 Bean 的设计蓝图，则规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等；</li>
</ul>
<blockquote>
<p>  <strong>测试：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; 一开始&quot;</span>);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();  <span class="comment">// BeanFactory 的一个实现类</span></span><br><span class="line">        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames));</span><br><span class="line">        <span class="comment">// 刚创建好的 beanFactory 对象，内部是没有任何 BeanDefinition 信息的</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; （1）从 xml 中获取&quot;</span>);</span><br><span class="line">        <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">        reader.loadBeanDefinitions(<span class="string">&quot;myBean.xml&quot;</span>);   <span class="comment">// 从 xml 文件中获取 BeanDefinition 信息</span></span><br><span class="line">        String[] beanDefinitionNames1 = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames1));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; （2）从配置类中获取&quot;</span>);</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;myConfig&quot;</span>, BeanDefinitionBuilder.genericBeanDefinition(MyConfig.class).getBeanDefinition());  <span class="comment">// 将配置类加入到容器中</span></span><br><span class="line">        <span class="comment">// 通过后处理器，将配置类中还存在的其它对象也加入到容器中</span></span><br><span class="line">        <span class="type">ConfigurationClassPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassPostProcessor</span>();</span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(beanFactory);</span><br><span class="line">        String[] beanDefinitionNames2 = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&gt; （3）扫描获取（包扫描）&quot;</span>);</span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(beanFactory);</span><br><span class="line">        scanner.scan(<span class="string">&quot;cn.xsyu&quot;</span>);    <span class="comment">// 指定要扫描的包</span></span><br><span class="line">        String[] beanDefinitionNames3 = beanFactory.getBeanDefinitionNames();</span><br><span class="line">        System.out.println(Arrays.toString(beanDefinitionNames3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3、prepareBeanFactory"><a href="#3、prepareBeanFactory" class="headerlink" title="3、prepareBeanFactory"></a>3、prepareBeanFactory</h2><blockquote>
<p>  <strong>prepareBeanFactory 方法的作用</strong></p>
</blockquote>
<ol>
<li> 完善 BeanFactory ==&gt; 继续初始化 BeanFactory 中的成员变量</li>
<li> 解析 SpEL</li>
<li> 执行类型转换</li>
<li> 特殊 bean 的注入</li>
<li> 两个内置的 BeanPostProcessor 的作用</li>
</ol>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211001214801077.png" alt="image-20211001214801077"></p>
<ul>
<li>  上图中 BeanFactory 内部的变量，由白色变为绿色部分就是在 prepareBeanFactory 方法中进行变量初始化的。</li>
<li>  beanExpressResolver：解析 SpEL 表达式的</li>
<li>  propertyEditorRegistars：注册类型转换器（在值注入的时候可能会发生类型转换，比如 String 类型转为 Integer 类型等等）</li>
<li>  resolvableDependencies：管理特殊 bean 的一个 Map 结构，在 Spring 中，大部分的 bean 对象都被单例池（singletonObjects）所管理，但是还有一部分特殊对象，比如 BeanFactory 自身、或者 ApplicationContext 等等，这些对象并没有保存在单例池中，但是我们从使用者的角度来看，依然能够调用到它们，这是因为这些特殊对象被保存在 resolvableDependencies 对象池中</li>
<li>  beanPostProcessors：主要用于对 bean 创建时能够使用一些扩展功能。</li>
</ul>
<h2 id="4、postProcessBeanFactory"><a href="#4、postProcessBeanFactory" class="headerlink" title="4、postProcessBeanFactory"></a>4、postProcessBeanFactory</h2><blockquote>
<p>  <strong>postProcessBeanFactory 方法的作用</strong></p>
</blockquote>
<ul>
<li>  这一步是空实现，留给子类扩展</li>
<li>  掌握对应的设计模式：模板方法设计模式——主要的脉络都由父类规定死了，但是有一些可以扩展的方法留空了，留给子类去扩展。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  总结：</p>
</blockquote>
<p>一般 Web 环境下的 ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory。</p>
<hr>
<h2 id="5、invokeBeanFactoryPostProcessors"><a href="#5、invokeBeanFactoryPostProcessors" class="headerlink" title="5、invokeBeanFactoryPostProcessors"></a>5、invokeBeanFactoryPostProcessors</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211001221038451.png" alt="image-20211001221038451"></p>
<blockquote>
<p>  <strong>invokeBeanFactoryPostProcessors 方法的作用</strong></p>
</blockquote>
<p>beanFactory 有两个扩展点，</p>
<ul>
<li>  第一个扩展点就是在第 4 步提到的 postProcessBeanFactory ，在父类中没有具体的方法实现，交由子类进行扩展；</li>
<li>  第二个扩展点就是在第 5 步由 Bean 工厂的后处理器来进行扩展，主要用来补充或修改 BeanDefinition</li>
</ul>
<blockquote>
<p>  <strong>常见的 beanFactory 后处理器</strong></p>
</blockquote>
<ul>
<li>  ConfigurationClassPostProcessor：解析 @Configuration、@Bean、@Import、@PropertySource 等修饰的对象，并加载其 BeanDefinition 到 ApplicationContext 中</li>
</ul>
<blockquote>
<p>  <strong>总结：</strong></p>
</blockquote>
<ul>
<li>  beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition</li>
</ul>
<h2 id="6、registerBeanPostProcessors"><a href="#6、registerBeanPostProcessors" class="headerlink" title="6、registerBeanPostProcessors"></a>6、registerBeanPostProcessors</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002153102533.png" alt="image-20211002153102533"></p>
<ol>
<li> bean 的后处理器（第5步的是BeanFactory的后处理器）</li>
<li> 常见的 bean 后处理器</li>
</ol>
<p>在 BeanDefinitionMap 中查看是否有自定义的类实现了 BeanPostProcessors 接口，如果实现了就把这个自定义的类作为一个 bean 的后处理器注册到容器中，具体就是 beanPostProcessors 集合中去。</p>
<blockquote>
<p>  总结：</p>
</blockquote>
<ul>
<li>  bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段</li>
<li>常见的 bean 的后处理器<ul>
<li>  AutowiredAnnotationBeanPostProcessor，功能：解析 @Autowired，@Value 注解</li>
<li>  CommonAnnotationBeanPostProcessor，功能：解析 @Resource，@PostConstruct，@PreDestory 注解</li>
<li>  AnnotationAwareAspectJAutoProxyCreator，功能：为符合切点的目标 bean 自动创建代理</li>
</ul>
</li>
</ul>
<h2 id="7、initMessageSource"><a href="#7、initMessageSource" class="headerlink" title="7、initMessageSource"></a>7、initMessageSource</h2><p>从第 7 开始，回到 ApplicationContext 。</p>
<p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002153624068.png" alt="image-20211002153624068"></p>
<ol>
<li> 新加入一个 MessageSource 对象，用于提供国际化功能。</li>
</ol>
<p>MessageSource 从哪里来？</p>
<ul>
<li>  在容器中 BeanDefinitionMap 中查找是否存在一个 messageSource 的 bean（实现了 MessageSource 接口的对象），如果没有，则提供空的 MessageSource 的实现（空实现就是不支持国际化）。</li>
</ul>
<h2 id="8、initApplicationEventMulticaster"><a href="#8、initApplicationEventMulticaster" class="headerlink" title="8、initApplicationEventMulticaster"></a>8、initApplicationEventMulticaster</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002153714170.png" alt="image-20211002153714170"></p>
<blockquote>
<p>  作用</p>
</blockquote>
<ul>
<li>  初始化一个事件广播器</li>
<li>  广播器的作用就是发送事件给监听器，将发生的事件发送给各个监听器对象</li>
<li>  监听器的作用是监听广播器发送的事件</li>
</ul>
<blockquote>
<p>  广播器从哪里来</p>
</blockquote>
<ul>
<li>  先去 BeanDefinitionMap 中找，如果能找到，则使用自定义的事件广播器</li>
<li>  如果没有提供，则使用默认的事件广播器</li>
<li>  广播器内部有一个集合，这个集合中维护了所有的监听器</li>
<li>  可以从容器中找名为 applicationEventMulticaster 的 bea 作为事件广播器，若没有，则会新建默认的事件广播器</li>
<li>  可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件</li>
</ul>
<blockquote>
<p>  如何发布事件</p>
</blockquote>
<h2 id="9、onRefresh"><a href="#9、onRefresh" class="headerlink" title="9、onRefresh"></a>9、onRefresh</h2><ul>
<li>  这一步是空实现，留给子类扩展</li>
<li>  掌握对应的设计模式——模板方法设计模式</li>
</ul>
<ul>
<li>  SpringBoot 中的子类可以在这里准备 WebServer，即内嵌 web 容器</li>
</ul>
<h2 id="10、registerListeners"><a href="#10、registerListeners" class="headerlink" title="10、registerListeners"></a>10、registerListeners</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002154659370.png" alt="image-20211002154659370"></p>
<ul>
<li>  注册监听器对象</li>
<li>  用来接收事件</li>
</ul>
<blockquote>
<p>  监听器从何而来</p>
</blockquote>
<ol>
<li> 通过编程事先添加</li>
<li> BeanDefinitionMap 中存在实现了 ApplicationListener 的接口，</li>
<li> 还有一部分来自于 @EventListenr 注解的解析</li>
</ol>
<p>会把容器中的监听器都找到，添加到对应的广播器的集合中去，当发生事件后，广播器就会发送消息给监听器</p>
<ul>
<li>  如何接收事件</li>
</ul>
<p>实现 ApplicationListener 接口，必须重写其中的 onApplicationEvent(E e) 方法，方法参数 E 就是监听的对象，当对象发生改变时，就会触发该方法，可以在该方法中编写具体的业务处理逻辑。</p>
<h2 id="11、finishBeanFactoryInitialization"><a href="#11、finishBeanFactoryInitialization" class="headerlink" title="11、finishBeanFactoryInitialization"></a>11、finishBeanFactoryInitialization</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002155343583.png" alt="image-20211002155343583"></p>
<ol>
<li> conversionService：用来做类型转换，作为对 propertyEditorRegister 的补充，都是类型转换，但是这个功能更加强大</li>
<li> embeddedValueResolvers：解析 <code>$&#123;&#125;</code>，对 Environment 进行再一次的封装，底层调用的还是 Environment 中的方法来完成对 <code>$&#123;&#125;</code> 的解析，只不过它是属于 BeanFactory 的成员方法。</li>
<li> singletonObjects：找到所有的非延迟创建的单例对象，创建对象并保存到单例池中</li>
</ol>
<blockquote>
<p>  总结</p>
</blockquote>
<ul>
<li>  conversionService 也是一套类型转换机制，作为对 PropertyEditor 的补充</li>
<li>  内嵌值解析器用来解析 @Value 中的 ${} ，借用的是 Environment 中的功能</li>
<li>  单例池用来缓存所有的单例对象，对象的创建都分为三个阶段，每一阶段都有不同的 bean 后处理器参与进来，进行功能上的扩展。</li>
</ul>
<h2 id="12、finishRefresh"><a href="#12、finishRefresh" class="headerlink" title="12、finishRefresh"></a>12、finishRefresh</h2><p><img src="/2021/08/07/Spring%E2%80%94%E2%80%94IoC/image-20211002160408973.png" alt="image-20211002160408973"></p>
<ol>
<li> 创建 lifecycleProcessor，生命周期处理器。</li>
<li> 发布 ContextRefreshed 事件，表示整个容器创建已经完成</li>
</ol>
<blockquote>
<p>  从哪来？</p>
</blockquote>
<ol>
<li> 先去 BeanDefinitionMap 中找，没有则创建一个默认的</li>
</ol>
<blockquote>
<p>  总结</p>
</blockquote>
<ol>
<li> 用来控制容器内，需要生命周期管理的 bean</li>
<li> 如果容器中有名为 lifecycleProcessor 的 bean 就用它，如果没有就创建默认的生命周期管理器。</li>
<li> 调用 applicationContext 的 start 方法，就可以触发所有实现了 LifeCycle 接口的 bean 的 start。（总控）</li>
<li> 调用 applicationContext 的 stop 方法，就可以触发所有实现了 LifeCycle 接口的 bean 的 stop。（总控）</li>
</ol>
<hr>
<h1 id="Spring-bean-的生命周期"><a href="#Spring-bean-的生命周期" class="headerlink" title="Spring bean 的生命周期"></a>Spring bean 的生命周期</h1><ul>
<li>  阶段1：别名解析，查询缓存</li>
<li>  阶段2：检查父工厂</li>
<li>  阶段3：检查 DependsOn</li>
<li>阶段4：按 Scope 创建 bean<ul>
<li>  创建 singleton</li>
<li>  创建 prototype</li>
<li>  创建其它 scope</li>
</ul>
</li>
<li>阶段5：创建 bean<ul>
<li>  创建 bean 实例</li>
<li>  依赖注入</li>
<li>  初始化</li>
<li>  登记可销毁 bean</li>
</ul>
</li>
<li>  阶段6：类型转换</li>
<li>  阶段7：销毁 bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doGetBean 是 bean 对象生命周期的起点</span></span><br><span class="line"><span class="comment">// AbstractBeanFactory#doGetBean</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br></pre></td></tr></table></figure>

<p>为什么 doGetBean 是 bean 对象生命周期的起点？</p>
<ul>
<li>  因为 Spring 容器中的 bean 都是一些懒加载的对象，只要在第一次获取这个对象的时候，才会触发该 bean 的创建过程，所以起点方法名叫做 doGetBean</li>
</ul>
<h2 id="阶段1：别名解析，查询缓存"><a href="#阶段1：别名解析，查询缓存" class="headerlink" title="阶段1：别名解析，查询缓存"></a>阶段1：别名解析，查询缓存</h2><ol>
<li><p><strong>别名解析</strong></p>
<ul>
<li>  在 Spring 中，一个 bean 可以有多个别名，而在创建对象的时候希望通过不同的别名能够找到同一个 bean 对象。所以首先就需要把别名解析为真实名称（全限定类名），然后再进行后续处理。</li>
</ul>
</li>
<li><p><strong>查询缓存</strong></p>
<ul>
<li>  根据全限定类名从缓存中查看是否已经有创建好的实例对象</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singletonObjects 是一级缓存，存放单例成品对象</span><br><span class="line">earlySingletonObjects 是二级缓存，存放单例工程的产品，可称为提前单例对象</span><br><span class="line">singleFactories 是三级缓存，存放单例工厂。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  二级和三级缓存主要为了解决循环依赖</p>
</blockquote>
<hr>
<h2 id="阶段2：处理父子容器"><a href="#阶段2：处理父子容器" class="headerlink" title="阶段2：处理父子容器"></a>阶段2：处理父子容器</h2><ul>
<li>  在阶段 1 中我们了解到，在获取对象时，首先从缓存中查找，如果缓存中存在，就直接从缓存中获取。那如果缓存中不存在就会直接创建 bean 对象吗？也不是！</li>
<li>  如果容器还有父容器，那么会先去父容器中查找，在父容器中如果能直接匹配到 bean 对象，创建对象的流程也会直接结束。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>  父、子容器中的 bean 名称可以重复</li>
<li>  优先查找子容器的 bean，找到了直接返回，找不到再继续到父容器中去查找。</li>
</ul>
<hr>
<h2 id="阶段3：dependsOn"><a href="#阶段3：dependsOn" class="headerlink" title="阶段3：dependsOn"></a>阶段3：dependsOn</h2><ul>
<li>  大部分 bean 之间是有依赖关系的，比如 A 依赖了 B，B 依赖了 C，那么在创建 A 对象的时候，必须保证先将 B 和 C 创建出来。</li>
<li>  但是有一些 bean 之间是没有依赖关系的，但是我们又想要控制这些 bean 的创建顺序，那么就需要用到 dependsOn。比如 A、B 两个对象间没有依赖关系，但是又希望 B 先于 A 创建，那么我们就需要设置 A dependsOn B，这样就能保证 B 一定先于 A 创建。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>  dependsOn 用于控制那些没有显式依赖的 bean 对象间的创建顺序</li>
</ul>
<h2 id="阶段4：按-Scope-创建-bean"><a href="#阶段4：按-Scope-创建-bean" class="headerlink" title="阶段4：按 Scope 创建 bean"></a>阶段4：按 Scope 创建 bean</h2><ul>
<li>  创建 singleton</li>
<li>  创建 prototype</li>
<li>  创建其它 scope</li>
</ul>
<h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSingletonScope</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    applicationContext.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">    applicationContext.registerBean(CommonAnnotationBeanPostProcessor.class);   <span class="comment">// 注册一个后处理器</span></span><br><span class="line">    applicationContext.refresh();   <span class="comment">// refresh方法在第11步底层就是调用了 getBean 方法 ==&gt; getBean 会调用 init 方法</span></span><br><span class="line">    applicationContext.close();     <span class="comment">// 当容器销毁的时候，就会调用 destroy 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrototypeScope</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    applicationContext.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class, bd -&gt; bd.setScope(<span class="string">&quot;prototype&quot;</span>));  <span class="comment">// 指定创建的对象为多例</span></span><br><span class="line">    applicationContext.registerBean(CommonAnnotationBeanPostProcessor.class);   <span class="comment">// 注册一个后处理器</span></span><br><span class="line">    applicationContext.refresh();   <span class="comment">// refresh方法在第11步底层就是调用了 getBean 方法 ==&gt; getBean 会调用 init 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 多例 bean 从首次 getBean 时才被创建，到调用 BeanFactory 的 destroyBean 方法销毁。（即如果只是单纯的refresh不会创建多例对象）*/</span></span><br><span class="line">    <span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> applicationContext.getBean(Bean2.class);</span><br><span class="line">    <span class="comment">/* 销毁方法也需要我们手动调用 */</span></span><br><span class="line">    applicationContext.getDefaultListableBeanFactory().destroyBean(bean2);</span><br><span class="line"></span><br><span class="line">    applicationContext.close();     <span class="comment">// 当容器销毁的时候，就会调用 destroy 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<ul>
<li>  scope 理解为从 xxx 范围内找这个 bean 更加贴切</li>
<li>  singleton 表示从单例池范围内获取 bean，如果没有，则创建并放入单例池。</li>
<li>  prototype 表示从不缓存 bean，每次都创建新的</li>
<li>  request 表示从 request 对象范围内获取 bean，如果没有，则创建并放入 request 中。</li>
</ul>
<h2 id="阶段5：创建-bean"><a href="#阶段5：创建-bean" class="headerlink" title="阶段5：创建 bean"></a>阶段5：创建 bean</h2><ul>
<li>  创建 bean 实例</li>
<li>  依赖注入</li>
<li>  初始化</li>
<li>  登记可销毁 bean</li>
</ul>
<p>146</p>
<h2 id="阶段6：类型转换"><a href="#阶段6：类型转换" class="headerlink" title="阶段6：类型转换"></a>阶段6：类型转换</h2><h2 id="阶段7：销毁-bean"><a href="#阶段7：销毁-bean" class="headerlink" title="阶段7：销毁 bean"></a>阶段7：销毁 bean</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
