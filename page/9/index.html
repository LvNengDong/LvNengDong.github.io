<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/06/MySQL%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/06/MySQL%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">MySQL事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-10-06 12:48:49 / Modified: 14:21:01" itemprop="dateCreated datePublished" datetime="2021-10-06T12:48:49+08:00">2021-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1    什么是事务"></a>1    什么是事务</h1><p>事务是<strong>一组 SQL 语句组成的逻辑处理单元</strong>，事务具有 ACID 四个属性。</p>
<table>
<thead>
<tr>
<th align="center">事务特性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">原子性（Atomicity）</td>
<td align="center">每个事务都是一个不可再分的整体，事务中的SQL语句要么全部成功，要么全部失败</td>
</tr>
<tr>
<td align="center">一致性（Consistency）</td>
<td align="center">SQL语句执行前后数据库的状态保持一致。</td>
</tr>
<tr>
<td align="center">隔离性（Isolation）</td>
<td align="center">事务之间不应该互相影响。</td>
</tr>
<tr>
<td align="center">持久性（Durability）</td>
<td align="center">一旦事务执行成功，对数据库的修改是永久的。</td>
</tr>
</tbody></table>
<h1 id="2-MySQL-中事务提交的方式"><a href="#2-MySQL-中事务提交的方式" class="headerlink" title="2    MySQL 中事务提交的方式"></a>2    MySQL 中事务提交的方式</h1><ol>
<li> 手动提交事务</li>
<li> 自动提交事务</li>
</ol>
<h2 id="2-1-手动提交事务"><a href="#2-1-手动提交事务" class="headerlink" title="2.1    手动提交事务"></a>2.1    手动提交事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1、开启事务：</span><br><span class="line">start transaction</span><br><span class="line"># 2、提交事务：</span><br><span class="line">commit</span><br><span class="line"># 3、回滚事务：</span><br><span class="line">rollback</span><br></pre></td></tr></table></figure>





<h2 id="2-2-自动提交事务（默认）"><a href="#2-2-自动提交事务（默认）" class="headerlink" title="2.2    自动提交事务（默认）"></a>2.2    自动提交事务（默认）</h2><p>MySQL 默认每一条 DML（增删改）语句都是一个单独的事务，即每条语句执行前都会自动开启一个事务，语句执行完毕自动提交事务。</p>
<p><img src="/2021/10/06/MySQL%E4%BA%8B%E5%8A%A1/image-20201008173026672.png" alt="image-20201008173026672"></p>
<h3 id="2-2-1-取消自动提交事务"><a href="#2-2-1-取消自动提交事务" class="headerlink" title="2.2.1    取消自动提交事务"></a>2.2.1    取消自动提交事务</h3><ol>
<li><p>查看 MySQL是否开启自动提交事务</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select @@autocommit;</span><br><span class="line">-- @@ 表示全局变量</span><br><span class="line">-- 查询得到的结果为0或1，1表示已开启自动提交，0表示已关闭自动提交</span><br></pre></td></tr></table></figure></li>
<li><p>取消事务的自动提交</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @@autocommit=0;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="3-事务的实现原理"><a href="#3-事务的实现原理" class="headerlink" title="3    事务的实现原理"></a>3    事务的实现原理</h1><ul>
<li>  MySQL 的事务是基于<strong>重做日志文件（redo log）</strong>  和<strong>回滚日志（undo log）</strong>实现的。</li>
</ul>
<h2 id="3-1-undo-log"><a href="#3-1-undo-log" class="headerlink" title="3.1    undo log"></a>3.1    undo log</h2><ul>
<li>  <code>undo log</code> 用来回滚数据库状态到某个版本。</li>
<li>  <code>undo log</code> 指事务开始之前，在操作任何数据之前，首先将当前状态下的数据库数据进行一次备份。</li>
<li>  当事务执行失败需要回滚时，根据  <code>undo log</code> 日志文件进行数据恢复。</li>
</ul>
<p><img src="/2021/10/06/MySQL%E4%BA%8B%E5%8A%A1/image-20211006133130410.png" alt="image-20211006133130410"></p>
<h2 id="3-2-redo-log"><a href="#3-2-redo-log" class="headerlink" title="3.2    redo log"></a>3.2    redo log</h2><ul>
<li>  当对数据库中的数据进行修改时（数据存在磁盘中），需要把数据从磁盘中读取到内存中的缓冲池（BufferPool）中，然后在 BufferPool 中进行修改。</li>
<li>  那么这个时候 BufferPool 中的数据与磁盘中的数据就是不一致的，称 BufferPool 中的数据为“脏数据”。</li>
<li>  如果这个时候发生 DB 宕机，那么这些内存中的数据就会丢失，如果这时候能有一个文件，把 BufferPool 中对数据的修改记录保存到本地磁盘中，当 DB 发生意外宕机时，可以在重启后根据这个日志文件的记录进行数据恢复，这个文件就是 <strong>redo log</strong>。</li>
</ul>
<ul>
<li>  <code>redo log</code> 日志文件记录了事务中对任何数据执行写的操作，当事务执行成功时，日志文件会被提交到数据库服务器中去执行，其它任何情况都会清空事务日志（<code>rollback</code>）。</li>
<li>  <code>redo log</code> 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</li>
</ul>
<p><img src="/2021/10/06/MySQL%E4%BA%8B%E5%8A%A1/image-20211006133111921.png" alt="image-20211006133111921"></p>
<hr>
<h1 id="4-回滚点"><a href="#4-回滚点" class="headerlink" title="4    回滚点"></a>4    回滚点</h1><h2 id="4-1-什么是回滚点"><a href="#4-1-什么是回滚点" class="headerlink" title="4.1    什么是回滚点"></a>4.1    什么是回滚点</h2><p>在某些成功的操作完成之后，后续操作有可能成功也有可能失败，但是不管成功还是失败，前面的操作都已经成功了，可以在当前成功的位置设置一个回滚点。可以供后续失败操作回滚到该位置，而不是回滚全部操作，这个点称为回滚点。</p>
<p><strong>设置回滚点可以让SQL语句在执行失败的时候回退到回滚点，而不是回退到事务开启的时候</strong>。</p>
<h2 id="4-2-回滚点的操作语句"><a href="#4-2-回滚点的操作语句" class="headerlink" title="4.2    回滚点的操作语句"></a>4.2    回滚点的操作语句</h2><ul>
<li>  设置回滚点：<code>savepoint 名字</code></li>
<li>  回到回滚点：<code>rollback to 名字</code></li>
</ul>
<h1 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5    事务的隔离级别"></a>5    事务的隔离级别</h1><h2 id="5-1-并发访问引发的问题"><a href="#5-1-并发访问引发的问题" class="headerlink" title="5.1    并发访问引发的问题"></a>5.1    并发访问引发的问题</h2><p>多个用户同时访问同一数据时，可能会引发如下问题：</p>
<table>
<thead>
<tr>
<th align="center">并发访问引发的问题</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>脏读</strong></td>
<td align="left">一个事务读取到了另一个事务中尚未提交的数据。</td>
</tr>
<tr>
<td align="center"><strong>不可重复读</strong></td>
<td align="left">一个事务中两次读取的数据<strong>内容</strong>不一致。[这是<code>update</code>时引发的问题]【行层面】</td>
</tr>
<tr>
<td align="center"><strong>幻读</strong></td>
<td align="left">一个事务中两次读取的数据的<strong>数量</strong>不一致。[这是<code>insert</code>或<code>delete</code>时引发的问题]【表层面】</td>
</tr>
</tbody></table>
<ol>
<li>解决脏读的办法？<ul>
<li>  将全局事务隔离级别提升到<code>read uncomitted</code>以上。</li>
</ul>
</li>
<li>解决不可重复读问题的办法？<ul>
<li>  将全局事务隔离级别提升到<code>repeatable read</code>以上</li>
</ul>
</li>
<li>解决幻读问题的办法？<ul>
<li>  设置全局事务隔离级别为最高<code>serializable</code>。</li>
<li>  使用<code>serializable</code>隔离级别，一个事务没有执行完，其它事务的SQL语句就执行不了，可以挡住幻读，</li>
</ul>
</li>
</ol>
<h3 id="5-1-1-不可重复读-vs-幻读"><a href="#5-1-1-不可重复读-vs-幻读" class="headerlink" title="5.1.1    不可重复读 vs. 幻读"></a>5.1.1    不可重复读 vs. 幻读</h3><ol>
<li> <code>不可重复读</code>：在同样的条件下，你已经读取过的数据，再次读取时发现值不一样了。</li>
<li> <code>幻读</code>：比如，在一张表中，事务A第一次读取时读到了3条记录，然后事务B对该表中的记录进行了删除或增加。此时事务A使用相同的条件读取表时读到了5条记录，这叫做幻读。</li>
</ol>
<h2 id="5-2-MySQL的4种隔离级别"><a href="#5-2-MySQL的4种隔离级别" class="headerlink" title="5.2    MySQL的4种隔离级别"></a>5.2    MySQL的4种隔离级别</h2><ul>
<li>  ✔表示会出现这种问题，✖表示不会出现这种问题。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">名字</th>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
<th align="center">数据库默认隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">读未提交</td>
<td align="center"><code>read uncommitted</code></td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">读已提交</td>
<td align="center"><code>read committed</code></td>
<td align="center">✖</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">Oracle和SqlServer</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">可重复读</td>
<td align="center"><code>repeatable read</code></td>
<td align="center">✖</td>
<td align="center">✖</td>
<td align="center">✔</td>
<td align="center">MySql</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">串行化</td>
<td align="center"><code>serializable</code></td>
<td align="center">✖</td>
<td align="center">✖</td>
<td align="center">✖</td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>  隔离级别越高，安全性越高，性能越差。</li>
</ul>
<h2 id="5-3-MySql事务隔离级别相关的命令"><a href="#5-3-MySql事务隔离级别相关的命令" class="headerlink" title="5.3    MySql事务隔离级别相关的命令"></a>5.3    MySql事务隔离级别相关的命令</h2><ul>
<li><p>查询全局事务隔离级别</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure></li>
<li><p>设置全局事务隔离级别；（每次设置后需要退出 MySQL 再重新登录才能看到隔离级别的变化）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set global Transaction isolation level 级别字符串;</span><br><span class="line">-- 隔离级别：</span><br><span class="line">    -- read uncommitted</span><br><span class="line">    -- read committed</span><br><span class="line">    -- repeatable read</span><br><span class="line">    -- serializable</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式——观察者模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-27 15:01:13" itemprop="dateCreated datePublished" datetime="2021-09-27T15:01:13+08:00">2021-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-30 15:55:52" itemprop="dateModified" datetime="2021-10-30T15:55:52+08:00">2021-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  <strong>观察者模式；Observer Pattern</strong></p>
</blockquote>
<p><strong>概念</strong>：定义对象间的一种一对多依赖关系，使得每次当一个对象发生状态改变时，其所有<strong>依赖</strong>的对象都能得到通知并执行状态改变后的逻辑。</p>
<h1 id="观察者模式案例"><a href="#观察者模式案例" class="headerlink" title="观察者模式案例"></a>观察者模式案例</h1><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p><strong>天气预报项目需求：</strong></p>
<ol>
<li> 气象站实时将测量到的温度、天气、空气质量等数据以公告的形式发布出去，比如发布给第三方，如Sina、Baidu、Tencent等，对应的第三方在自己的平台上展示。</li>
<li> 需要设计开放型的 API，使得第三方平台能接入气象站获取数据。</li>
<li> 当气象站测量到的数据发生更新时，要能实时的通知给第三方。</li>
</ol>
<hr>
<h1 id="方案（观察者模式）"><a href="#方案（观察者模式）" class="headerlink" title="方案（观察者模式）"></a>方案（观察者模式）</h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>气象站发布数据，并将最新的数据同步到订阅了气象服务的多个第三方平台上，主要有两种解决思路：</p>
<ol>
<li><strong>push</strong>：<ul>
<li>  由气象站发起，当天气数据发生变换时将最新数据推送给所有订阅了天气服务的第三方平台。</li>
<li>  气象站使用一个 List 集合管理所有订阅天气服务的第三方平台，每当天气数据发生变化时，就遍历这个 List 将最新的数据推送给 List 中的每个第三方平台。</li>
</ul>
</li>
<li><strong>pull</strong>：<ul>
<li>  由第三方平台发起，每个第三方平台设置自己的定时器，定时拉取气象局提供的最新数据。</li>
</ul>
</li>
</ol>
<h2 id="推送思路的设计："><a href="#推送思路的设计：" class="headerlink" title="推送思路的设计："></a>推送思路的设计：</h2><ul>
<li>  <strong>核心接口1：Subject接口</strong>，该接口最少需要声明 ①用户（观察者）注册、②注销 ③以及当气象站数据发生变化时通知所有用户 三个核心功能，具体的实现逻辑由其子类实现。</li>
<li>  <strong>核心类1：</strong>该接口通过上述分析，我们可以初步设计一个 WeatherData 类来保存气象站测到的实时数据，该类需要实现 Subject 接口，并对外提供公共的 getXxx() 方法，第三方平台可以通过这些方法来获取相关天气信息。当气象台的数据发生变化时，气象站就会调用 <strong>setData()</strong> 方法去更新数据，并在该方法中继续调用 <strong>notifyAllObserver()</strong> 方法将最新的数据推送给所有订阅天气服务的观察者。</li>
<li>  <strong>核心接口2：Observer接口</strong>，该接口中定义一个 <strong>update()</strong> 方法，Subject 对象推送最新数据时会触发该方法，对第三方平台的数据进行更新，具体逻辑由其子类实现。</li>
<li>  <strong>核心类2：</strong>Sina、Tencent、Baidu 等第三方平台类，这些类必须实现 Observer 接口，在类中一般会有一个 <code>upodate()</code> 方法用于接收最新的实时数据，和一个 <code>show()</code> 方法用于数据的展示。</li>
</ul>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/2021/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20211030114431359.png" alt="image-20211030114431359"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@startuml</span></span><br><span class="line"><span class="string">&#x27;https://plantuml.com/class-diagram</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Subject ..&gt; Observer</span></span><br><span class="line"><span class="string">Observer --o WeatherData</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">interface Subject</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    void registerObserver(Observer o)</span></span><br><span class="line"><span class="string">    void removeObserver()</span></span><br><span class="line"><span class="string">    void notifyAllObserver()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class WeatherData implements Subject</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    List&lt;Observer&gt; observerList</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Observer</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    void update()</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Sina implements Observer</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Tencent implements Observer</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Baidu implements Observer</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@enduml</span></span><br></pre></td></tr></table></figure>







<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul>
<li>  Subject 接口</li>
<li>  WeatherData 类</li>
<li>  Observer 接口</li>
<li>  Sina/Tencent/Baidu 类</li>
</ul>
<h3 id="Subject-接口"><a href="#Subject-接口" class="headerlink" title="Subject 接口"></a>Subject 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/29 21:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * “一对多” 中的 “一”</span></span><br><span class="line"><span class="comment"> * 主要包括以下几种功能：</span></span><br><span class="line"><span class="comment"> *  1、注册观察者（新增）</span></span><br><span class="line"><span class="comment"> *  2、注册观察者（新增）</span></span><br><span class="line"><span class="comment"> *  3、“一”中的数据发生变化时向所有注册过的用户发送通知</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者（新增）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除某个观察者（删除）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心对象中的数据发生变化时向通知所有注册过的观察者</span></span><br><span class="line"><span class="comment">     *  Tip：根据不同的需求，</span></span><br><span class="line"><span class="comment">     *      ①可以是让观察者来拉取数据，</span></span><br><span class="line"><span class="comment">     *      ②也可以是实施推送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="WeatherData-类"><a href="#WeatherData-类" class="headerlink" title="WeatherData 类"></a>WeatherData 类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/29 21:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 保存气象台测量的实时天气数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String temperature; <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> String weather; <span class="comment">// 天气（晴/阴/雨）</span></span><br><span class="line">    <span class="keyword">private</span> String airQuality;  <span class="comment">// 空气质量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于维护观察者列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者 Observer（新增）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (observerList.contains(observer)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该观察者已存在&quot;</span>);</span><br><span class="line">        observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除某个观察者Observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!observerList.contains(observer)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该观察者不是一个合法的观察者&quot;</span>);</span><br><span class="line">        observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有订阅服务的观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observerList) &#123;</span><br><span class="line">            observer.update(<span class="built_in">this</span>.temperature, <span class="built_in">this</span>.weather, <span class="built_in">this</span>.airQuality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实时更新数据，并将实时数据推送给所有订阅了天气服务的第三方平台</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weather</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> airQuality</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(String temperature, String weather, String airQuality)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实时更新数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将实时数据通知到所有订阅天气服务的第三方平台</span></span><br><span class="line">        <span class="built_in">this</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Observer&gt; <span class="title function_">getObserverList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> observerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObserverList</span><span class="params">(List&lt;Observer&gt; observerList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observerList = observerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemperature</span><span class="params">(String temperature)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWeather</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weather;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeather</span><span class="params">(String weather)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAirQuality</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> airQuality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAirQuality</span><span class="params">(String airQuality)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Observer-接口"><a href="#Observer-接口" class="headerlink" title="Observer 接口"></a>Observer 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/29 21:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有观察者的父接口（所有观察者都必须实现该接口）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String temperature, String weather, String airQuality)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Sina-Tencent-Baidu-类"><a href="#Sina-Tencent-Baidu-类" class="headerlink" title="Sina/Tencent/Baidu 类"></a>Sina/Tencent/Baidu 类</h3><p><strong>Sina</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/30 11:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sina</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String temperature;</span><br><span class="line">    <span class="keyword">private</span> String weather;</span><br><span class="line">    <span class="keyword">private</span> String airQuality;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法由气象站来调用，当气象站天气数据发生变化时，就会调用该方法推送最新的数据给第三方平台</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weather</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> airQuality</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String temperature, String weather, String airQuality)</span> &#123;</span><br><span class="line">        <span class="comment">// 同步气象站发布的实时天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据展示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新浪天气（温度）&quot;</span> + <span class="built_in">this</span>.temperature);</span><br><span class="line">        System.out.println(<span class="string">&quot;新浪天气（天气）&quot;</span> + <span class="built_in">this</span>.weather);</span><br><span class="line">        System.out.println(<span class="string">&quot;新浪天气（空气质量）&quot;</span> + <span class="built_in">this</span>.airQuality);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Tencent</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/30 11:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tencent</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String temperature;</span><br><span class="line">    <span class="keyword">private</span> String weather;</span><br><span class="line">    <span class="keyword">private</span> String airQuality;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法由气象站来调用，当气象站天气数据发生变化时，就会调用该方法推送最新的数据给第三方平台</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weather</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> airQuality</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String temperature, String weather, String airQuality)</span> &#123;</span><br><span class="line">        <span class="comment">// 同步气象站发布的实时天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据展示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;腾讯天气（温度）&quot;</span> + <span class="built_in">this</span>.temperature);</span><br><span class="line">        System.out.println(<span class="string">&quot;腾讯天气（天气）&quot;</span> + <span class="built_in">this</span>.weather);</span><br><span class="line">        System.out.println(<span class="string">&quot;腾讯天气（空气质量）&quot;</span> + <span class="built_in">this</span>.airQuality);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Baidu</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/30 11:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Baidu</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String temperature;</span><br><span class="line">    <span class="keyword">private</span> String weather;</span><br><span class="line">    <span class="keyword">private</span> String airQuality;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法由气象站来调用，当气象站天气数据发生变化时，就会调用该方法推送最新的数据给第三方平台</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weather</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> airQuality</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String temperature, String weather, String airQuality)</span> &#123;</span><br><span class="line">        <span class="comment">// 同步气象站发布的实时天气数据</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.weather = weather;</span><br><span class="line">        <span class="built_in">this</span>.airQuality = airQuality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据展示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;百度天气（温度）&quot;</span> + <span class="built_in">this</span>.temperature);</span><br><span class="line">        System.out.println(<span class="string">&quot;百度天气（天气）&quot;</span> + <span class="built_in">this</span>.weather);</span><br><span class="line">        System.out.println(<span class="string">&quot;百度天气（空气质量）&quot;</span> + <span class="built_in">this</span>.airQuality);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.observer.simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/30 11:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三方平台订阅气象台的天气服务</span></span><br><span class="line">        <span class="type">Sina</span> <span class="variable">sina</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sina</span>();</span><br><span class="line">        <span class="type">Tencent</span> <span class="variable">tencent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tencent</span>();</span><br><span class="line">        <span class="type">Baidu</span> <span class="variable">baidu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Baidu</span>();</span><br><span class="line">        weatherData.registerObserver(sina);</span><br><span class="line">        weatherData.registerObserver(tencent);</span><br><span class="line">        weatherData.registerObserver(baidu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Subject 实时更新数据</span></span><br><span class="line">        <span class="comment">// setData方法底层会自动同步最新数据给所有订阅了天气服务的第三方平台</span></span><br><span class="line">        weatherData.setData(<span class="string">&quot;25℃&quot;</span>, <span class="string">&quot;晴&quot;</span>, <span class="string">&quot;良&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【测试】第三方平台展示数据测试</span></span><br><span class="line">        sina.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        tencent.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        baidu.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试结果展示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    新浪天气（温度）25℃</span></span><br><span class="line"><span class="comment">    新浪天气（天气）晴</span></span><br><span class="line"><span class="comment">    新浪天气（空气质量）良</span></span><br><span class="line"><span class="comment">    ===================</span></span><br><span class="line"><span class="comment">    腾讯天气（温度）25℃</span></span><br><span class="line"><span class="comment">    腾讯天气（天气）晴</span></span><br><span class="line"><span class="comment">    腾讯天气（空气质量）良</span></span><br><span class="line"><span class="comment">    ===================</span></span><br><span class="line"><span class="comment">    百度天气（温度）25℃</span></span><br><span class="line"><span class="comment">    百度天气（天气）晴</span></span><br><span class="line"><span class="comment">    百度天气（空气质量）良</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/22/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/22/HashMap/" class="post-title-link" itemprop="url">HashMap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-22 18:00:49" itemprop="dateCreated datePublished" datetime="2021-09-22T18:00:49+08:00">2021-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-26 15:59:41" itemprop="dateModified" datetime="2021-10-26T15:59:41+08:00">2021-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">集合</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>前置知识</strong></p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/08/17/%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算基础</a></li>
</ul>
<hr>
<h1 id="HashMap-特点"><a href="#HashMap-特点" class="headerlink" title="HashMap 特点"></a>HashMap 特点</h1><p><strong>特点</strong></p>
<ol>
<li> 存取无序的；</li>
<li> 线程不安全；</li>
<li> key，value 都可以为 null</li>
</ol>
<p><strong>数据结构</strong></p>
<ul>
<li>  JDK8 之前，HashMap 是由 <strong>数组+链表</strong> 组成的，数组是 HashMap 的主体，链表则是为了解决哈希冲突而存在的。</li>
<li>  从 JDK8 开始，解决哈希冲突的策略由<strong>链表</strong>变为了<strong>链表+红黑树</strong>，当<strong>链表长度大于阈值（默认为8）并且当前数组长度大于64</strong>时，此时哈希桶上的所有数据改为用红黑树存储。</li>
</ul>
<blockquote>
<p>  补充：当链表长度长度大于阈值但是数组长度小于 64 时，此时并不会将链表变为红黑树，而是选择对数组进行扩容。</p>
</blockquote>
<ul>
<li>  当数组长度比较小时，在发生 Hash 冲突后应尽量避免使用红黑树结构，在这种情况下将链表变为红黑树结构，反而会降低效率，因为红黑树需要通过变色、左旋、右旋等操作来保持黑节点平衡。同时，当数组长度小于 64 时，搜索时间相对要快一些。当链表长度大于阈值并且数组长度大于 64 时，链表转换为红黑树，查找效率更高一些。</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote>
<ol>
<li> HashMap 底层数据结构为什么从链表转换为红黑树？</li>
</ol>
</blockquote>
<p>JDK8 之前 HashMap 的底层实现是 <code>数组+链表</code>，当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下就会有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 **O(n)**。</p>
<p>针对这种情况，JDK8 中引入了 红黑树来优化这个问题（红黑树中查找的时间复杂度为 **O(logn)**）。并且只有当链表长度达到 8 并且数组长度大于 64 时，才转换为红黑树。而当链表长度很小的时候，即使遍历整个链表速度也非常快，只有当链表长度大于一定阈值后，遍历查询的性能才会发生下降，这时候才需要通过将链表转换为红黑树来提高查询效率。</p>
<blockquote>
<ol start="2">
<li> 为什么链表转换为红黑树的阈值是8？</li>
</ol>
</blockquote>
<h1 id="HashMap-存储过程"><a href="#HashMap-存储过程" class="headerlink" title="HashMap 存储过程"></a>HashMap 存储过程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/13 19:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;海绵宝宝&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        map.put(<span class="string">&quot;派大星&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;蟹老板&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        map.put(<span class="string">&quot;章鱼哥&quot;</span>, <span class="number">35</span>);</span><br><span class="line">        map.put(<span class="string">&quot;海绵宝宝&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建 HashMap 对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>  执行 <code>new HashMap&lt;&gt;()</code> 语句，在 JDK8 之前是在底层创建了一个长度为 16 的一维数组 <strong>Entry[] table</strong>；</li>
<li>  但是从 JDK8 开始，并没有在执行 <code>new HashMap&lt;&gt;()</code> 语句时就创建数组对象，而是直接引用了一个类初始化阶段就已经创建好的空的 HashMap 对象，直到首次调用 <strong>put()</strong> 方法时，才会在底层创建长度为 16 的 <strong>Node[] table</strong> 数组对象。</li>
</ul>
</li>
<li><p>添加元素</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;海绵宝宝&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  向 <strong>table</strong> 数组中存储数据 <code>(&quot;海绵宝宝&quot;, 6)</code>，首先会调用 <code>String#hashCode()</code> 方法计算出 “海绵宝宝” 的 hashCode 值，此 hashCode 值经过某种算法计算后，得到该 Node 对象在 table 数组中存放的位置（即桶位置），如果此位置上数据为空，直接插入 Node 对象到数组中，添加元素成功。假设此时计算得到的桶位置下标为2。</li>
</ul>
</li>
<li><p>继续添加元素</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;派大星&quot;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  继续向 <strong>table</strong> 数组中添加数据 <code>map.put(&quot;派大星&quot;, 8)</code>，如果根据 “派大星” 的 hashCode 和当前数组长度计算出的桶位置也为 2，那么此时会继续比较 “海绵宝宝” 和 “派大星” 的 hashCode，如果不相等，会在该桶位置上新建一个链表节点来存储 Node 对象 <code>(&quot;派大星&quot;, 8)</code>。</li>
</ul>
</li>
<li><p>覆盖元素</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;海绵宝宝&quot;</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>假设向 <strong>table</strong> 数组中存储数据 <code>(&quot;海绵宝宝&quot;, 8)</code>，根据 key 的 hashCode 和当前数组长度计算出的桶位置是 2，但是此时数组中下标 2 的位置上已经有了数据，接下来会比较后添加元素的 hashCode 和已存在元素的 hashCode 是否相等，如果相同，使用  <code>equals()</code> 方法继续比较后添加元素 key 与已存在元素的 key 是否相同。如果 <code>equals()</code> 方法返回 false，证明新添加的元素在 HashMap 中不存在，则向链表（或红黑树）中添加元素；如果 <code>equals()</code> 方法返回 true，则证明新添加的元素在 HashMap 中已存在，用后添加元素的 value 值覆盖已存在元素的 value 值。</li>
</ul>
</li>
</ol>
<p><img src="/2021/09/22/HashMap/image-20211025234552648.png" alt="image-20211025234552648"></p>
<p><strong>说明：</strong></p>
<ul>
<li>  size 表示 HashMap 中 Node 对象实时数量，如果添加元素后 Node 对象的个数大于 threshold，也会触发数组的扩容机制。</li>
<li>**threshold(临界值) = capacity(容量) × loadFactory(加载因子) **。这个值是当前已占用数组长度的最大值。size 超过这个值就会触发扩容（resize）机制，扩容后数组的长度变为原来的两倍。<ul>
<li>  HashMap 并不追求把整个 table 数组完全填满之后才进行扩容，因为这样可能会导致链表（或红黑树）上的 Node 对象很多，一般情况下只要数组中的元素个数大于 threshold，就可以认为数组中的使用率已经很高了，可以进行扩容了。如果一味地追求数组填满之后再进行扩容，可能存在剩下一到两个空位置始终没有元素填充进来，反而会有大量元素挂在了链表（或红黑树）后面，导致链表（或红黑树）中的节点变得非常多，反而会影响插叙效率。</li>
</ul>
</li>
</ul>
<h2 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote>
<ol>
<li> <strong>在 JDK8 中如何根据 hashCode 计算出 Node 要保存的桶位置（下标）？除了这个还有哪些实现方式？</strong></li>
</ol>
</blockquote>
<p>对 <code>Node&lt;K, V&gt;</code> 对象的 key 的 hashCode 做哈希操作：①无符号右移16位  ②异或运算</p>
<ul>
<li>  优点：效率高</li>
</ul>
<p><strong>其它实现方式：</strong></p>
<p>平方取中法、除留余数法、伪随机数法</p>
<p>其余三种方式效率较低，在 Java 中位运算的效率较高。</p>
<blockquote>
<ol start="2">
<li> 当两个对象的 hashCode 相等时会怎么样？</li>
</ol>
</blockquote>
<p>当两个对象的 hashCode 相等时，根据该 hashCode 计算出的哈希值也必然相同，那么显然会发生哈希碰撞；发生了哈希碰撞之后首先会比较两个 key 对象的 hashCode 是否相等，在本题中是显然的；当 hashCode 相等后，接着使用 <code>equals()</code> 方法比较两个 key 对象是否相等，若不相等则将新的 Node 对象添加到链表（或红黑树）上，若相等则用新的 Node 节点中的 value 去覆盖旧的 Node 节点中的 value 值。</p>
<ul>
<li>  在将 Node 添加到链表中时，如果满足条件还会发生链表到红黑树的转换。</li>
</ul>
<hr>
<h1 id="HashMap-源码"><a href="#HashMap-源码" class="headerlink" title="HashMap 源码"></a>HashMap 源码</h1><h2 id="HashMap-类中的成员"><a href="#HashMap-类中的成员" class="headerlink" title="HashMap 类中的成员"></a>HashMap 类中的成员</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ol>
<li><p>序列化版本号</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组的初始化容量（必须是 2 的 n 次幂）</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量是16（1&amp;lt;&amp;lt;4 == 16）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure></li>
<li><p>table 数组的最大容量</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>默认的负载因子，默认值是 0.75</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>链表转换为红黑树的门槛</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>当链表的值小于6则会从红黑树转回链表</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>桶中链表结构转化为红黑树对应的数组长度最小的值</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>table 用来初始化(必须是二的n次幂)(重点)</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li>
<li><p>用来存放缓存</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放具体元素的集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

</li>
<li><p>HashMap中存放元素的个数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放元素的个数，注意这个不等于数组的长度。size为HashMap中K-V的实时数量，不是数组table的长度。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

</li>
<li><p>用来记录HashMap的修改次数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br></pre></td></tr></table></figure>

</li>
<li><p>用来调整大小下一个容量的值计算方式为(容量*负载因子)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>哈希表的加载因子(重点)</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Q-amp-A-2"><a href="#Q-amp-A-2" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><blockquote>
<p>  <strong>Q1：HashMap 中 table 数组的初始容量为什么必须是 2 的 n 次幂？</strong></p>
<p>  <strong>Q2：如果输入值不是 2 的幂比如 10 会怎么样？</strong></p>
</blockquote>
<p><strong>A1：</strong></p>
<ul>
<li>  在向 HashMap 中添加一个元素的时候，需要根据 <code>Node&lt;K, V&gt;</code> 中 key 的 hashCode 计算一个 hash 值，来确定 Node 对象在数组中的具体位置。HashMap 为了存取高效，需要尽量减少哈希冲突，也就是要把数据尽量分配均匀，每个哈希桶上的元素数量要大致相同，这个实现依赖于具体的 Hash 算法。</li>
<li>  这个算法实际上就是取模，<code>hashCode%length</code>，只不过计算机中位运算的效率要远大于取余运算，所以在源码中做了一些优化，用位运算代替取余运算，而实际上 <code>hashCode%length</code> 可以等于 **hashCode&amp;(length-1)**，而等于的充要条件就是数组长度 length 必须是 2 的 n 次幂。</li>
</ul>
<p><strong>小结：</strong></p>
<ul>
<li>  我们在根据 key 的哈希值确定桶位置时，如果数组长度 length 为 2 的 n 次幂，可以保证数据较为均匀的插入，如果 length 不是 2 的 n 次幂，可能数组的一些位置永远不会插入数据，造成数据空间的浪费和加大哈希冲突的概率。</li>
<li>  另一方面，一般我们可能会想到通过取余操作 % 来确定位置，这样虽然也可以，只不过性能不如与（&amp;）运算。而且当 n = 2^n 时，<code>hashCode&amp;(length-1) == hashCode%length</code>。</li>
<li>  因此，HashMap 中 table 数组容量为 2 的 n 次幂的原因就是为了使数据能均匀分布，减少哈希碰撞。因为哈希碰撞发生的次数越多，代表数组中一个桶位置的元素数量越多，这样会减低 HashMap 的性能。</li>
</ul>
<p><strong>Q2：</strong></p>
<ul>
<li><p>  如果创建 HashMap 时，手动指定 table 数组的长度为 10，而不是 <code>2^n</code>，HashMap 会通过位移运算和或运算得到一个大于给定长度的最小的 <code>2^n</code> 的值。比如给定数组长度为 10，就会得到大于 10 的最小 <code>2^n</code> 的值 16，也就是说此时创建的 table 数组的长度是 16。</p>
</li>
<li><p>源码分析：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建长度为 10 的 HashMap</span></span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 跳转到：HashMap的单参构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);	<span class="comment">// DEFAULT_LOAD_FACTOR 是默认加载因子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 跳转到：HashMap的双参构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// 若给定初始化容量小于0直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 若给定容量大于MAXIMUM_CAPACITY按MAXIMUM_CAPACITY处理</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 加载因子校验</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);	<span class="comment">// 计算table数组的容量，并赋值给threshold</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 跳转到：tableSizeFor 方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的初始值计算出数组容量，数组容量必然是2^n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>说明：</strong>根据源码可以看到，当在实例化 HashMap 时，如果给定了 initialCapacity（假设是10），最终会调用 <strong>tableSizeFor(int cap)</strong> 方法来计算 table 数组的真实容量，最终得到的结果是一个大于 10 的最小的 <code>2^n</code> 的值，在这里也就是 16。下面来分析这个算法：</p>
<ol>
<li><p>首先，对 cap 进行 -1 操作，<code>int n = cap - 1</code></p>
<blockquote>
<p>  为什么要对 cap 进行 -1 操作？</p>
</blockquote>
<p> 这是为了防止，cap 已经是 <code>2^n</code>。如果 cap 已经是 <code>2^n</code>，理论上此时数组的容量就应该是 cap，但是如果没有对 cap 进行 -1 操作，直接使用无符号右移运算，则最终得到的 cap 的容量是 <code>cap*2</code>，显然是不符合要求的；而如果执行了 -1 操作，那么最终得到的容量就是 cap，符合要求。</p>
</li>
<li><p> 如果 n 经过 cap-1 后结果是 0，则经过几次无符号右移后最终结果仍是 0，最后返回的 capacity 是 1。</p>
</li>
<li><p>当 cap = 10时，n=9</p>
<ul>
<li><p>第一次右移</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>	<span class="comment">// ①先进行右移运算 ②再进行或运算</span></span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001001</span>	 	<span class="comment">// 9</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000100</span>		<span class="comment">// 无符号右移一位 ==&gt; 4</span></span><br><span class="line">------------------------------------------	</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>		<span class="comment">// 进行或运算 9|4 ==&gt; 13</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>第二次右移：n=13</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>	</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span>	 	<span class="comment">// 13</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000011</span>		<span class="comment">// 无符号右移2位 ==&gt; 3</span></span><br><span class="line">------------------------------------------	</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span>		<span class="comment">// 进行或运算 13|3 ==&gt; 15</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>第三次右移：n=15</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;	<span class="comment">// n=15</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span>		<span class="comment">// 15</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>		<span class="comment">// 无符号右移4位 ==&gt; 0</span></span><br><span class="line">------------------------------------------	</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001111</span>		<span class="comment">// 进行或运算 15|3 ==&gt; 15</span></span><br></pre></td></tr></table></figure></li>
<li><p>第四次右移、第五次右移</p>
<p>  当 n 被扩展到 <code>2^n-1</code> 时，再进行右移运算也不会改变 n 的值，最终返回 capacity 容量时，用 n+1 就能得到 <code>2^n</code>。</p>
<p>  <img src="/2021/09/22/HashMap/image-20211026102557636.png" alt="image-20211026102557636"></p>
</li>
</ul>
</li>
<li><p>注意：得到的这个 capacity 最终被赋值给了 threshold</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<blockquote>
<p>  <strong>Q3：为什么 Map 桶中节点个数超过8才转为红黑树？</strong></p>
</blockquote>
<ol>
<li><p> <strong>从空间上考虑</strong>。因为树的节点大约是链表节点的两倍，所以我们只有在哈希桶中包含足够的节点时才会使用树节点。</p>
</li>
<li><p>并且当 hashCode 的离散性很好的时候，红黑树模型使用到的概率非常小，因为数据均匀分布在每个 Bucket 中，很少有 Bucket 中链表的长度会达到阈值。但是在随机 hashCode 的情况下，离散型就可能会变差，然而 JDK 又不能阻止用户实现这种不好的哈希算法，因此就可能导致不均匀的数据分布。不过理想情况下随机 hashCode 算法下的所有 Bucket 中的节点分布频率都会遵循泊松分布，我们可以看到，一个Bucket 中链表长度达到 8 个元素的概率为 0.00000006，几乎是不可能事件，所以，之所以选择 8 是由概率学决定的</p>
<blockquote>
<p>  泊松分布</p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: 0.60653066</span><br><span class="line">1: 0.30326533</span><br><span class="line">2: 0.07581633</span><br><span class="line">3: 0.01263606</span><br><span class="line">4: 0.00157952</span><br><span class="line">5: 0.00015795</span><br><span class="line">6: 0.00001316</span><br><span class="line">7: 0.00000094</span><br><span class="line">8: 0.00000006</span><br></pre></td></tr></table></figure>

</li>
<li></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 数组的默认容量 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 数组的最大容量 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 加载因子*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** HashMap 中的数组 */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">     * for keySet() and values().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** HashMap 中节点元素的个数*/</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 阈值 */</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用：用传入的值对 HashMap 中的值进行赋值操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity	数组容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor	加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【校验】</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity); <span class="comment">// 数组容量小于 0 抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY; <span class="comment">// 数组容量大于 MAXIMUM_CAPACITY 也抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) <span class="comment">// 要求加载因子必须小于0 或者必须是数字</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/17/LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/17/LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/" class="post-title-link" itemprop="url">LeetCode_198_打家劫舍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-17 11:52:24 / Modified: 12:39:29" itemprop="dateCreated datePublished" datetime="2021-09-17T11:52:24+08:00">2021-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h4><p>  难度中等1650</p>
</li>
</ul>
<ul>
<li><p>  LeetCode链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></p>
</li>
<li><p>  LeetCode链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></p>
</li>
<li><p>LeetCode链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></p>
</li>
</ul>
<h2 id="198-打家劫舍-1"><a href="#198-打家劫舍-1" class="headerlink" title="198    打家劫舍"></a>198    打家劫舍</h2><blockquote>
<p>  <strong>题解</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/17 11:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 198. 打家劫舍</span></span><br><span class="line"><span class="comment"> *  输入：[1,2,3,1]</span></span><br><span class="line"><span class="comment"> *  输出：4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution198</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution198</span> <span class="variable">solution198</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution198</span>();</span><br><span class="line"><span class="comment">//        int[] nums = &#123;1, 2, 3, 1&#125;;</span></span><br><span class="line"><span class="comment">//        int[] nums = &#123;2,7,9,3,1&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rob</span> <span class="operator">=</span> solution198.rob(nums);</span><br><span class="line">        System.out.println(rob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == nums || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能闯入相邻的房屋</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]); <span class="comment">// 这行代码用到了nums[1]，所以在这之前必须保证nums数组中至少要有两个元素，否则会下标越界</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dp[i] 等于 Max(dp[i-1]， dp[i-2]+nums[i])</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213    打家劫舍 II"></a>213    打家劫舍 II</h2><blockquote>
<p>  <strong>题解</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/17 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 213. 打家劫舍 II</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution213</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution213</span> <span class="variable">solution213</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution213</span>();</span><br><span class="line"><span class="comment">//        int[] nums = &#123;2, 3, 2&#125;;</span></span><br><span class="line"><span class="comment">//        int[] nums = &#123;1,2,3,1&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rob</span> <span class="operator">=</span> solution213.rob(nums);</span><br><span class="line">        System.out.println(rob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本思路与 【198打家劫舍】 一致，只是相邻的条件发生了改变：</span></span><br><span class="line"><span class="comment">     *  在 1代版本中，是一个普通数组，</span></span><br><span class="line"><span class="comment">     *  而在 2 代版本中，变成了一个环形数组，即 第一个与最后一个是相邻的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以我们需要增加判断条件:</span></span><br><span class="line"><span class="comment">     *   环状排列意味着：第一个房子和最后一个房子只能选择一个偷窃，因此我们可以把环状排列的房间简化成两个单排列房间的子问题</span></span><br><span class="line"><span class="comment">     *   1、在不偷窃第一个房子的情况下能够获得的最大金额</span></span><br><span class="line"><span class="comment">     *   2、在不偷窃最后一个房子的情况下能够获得的最大金额</span></span><br><span class="line"><span class="comment">     *   3、比较得到两个金额中较大的金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == nums || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规情况</span></span><br><span class="line">        <span class="type">int</span>[] ignoreFirst = Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length);</span><br><span class="line">        <span class="type">int</span>[] ignoreLast = Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 不偷第一个房子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> subRob(ignoreFirst);</span><br><span class="line">        <span class="comment">// 不偷最后一个房子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> subRob(ignoreLast);</span><br><span class="line">        <span class="keyword">return</span> m&gt;n?m:n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subRob</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == nums || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规情况</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337    打家劫舍 III"></a>337    打家劫舍 III</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/17/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/17/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/" class="post-title-link" itemprop="url">LeetCode_42_接雨水</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-17 11:24:58 / Modified: 11:35:48" itemprop="dateCreated datePublished" datetime="2021-09-17T11:24:58+08:00">2021-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>  题目链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></li>
<li>  大佬视频讲解地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HE411Z7By">https://www.bilibili.com/video/BV1HE411Z7By</a></li>
</ul>
<blockquote>
<p>  <strong>题解</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/17 10:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 42. 接雨水</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution42</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution42</span> <span class="variable">solution42</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution42</span>();</span><br><span class="line"><span class="comment">//        int[] height = &#123;0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] height = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> solution42.trap(height);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 接雨水问题 类似于 木桶效应问题</span></span><br><span class="line"><span class="comment">        * 但是 “木桶效应” 只有一个桶，但是接雨水问题在大部分的情况下都有大于两个桶，即：以最高点为分界线，向左是一个桶，向右也是一个桶</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路：</span></span><br><span class="line"><span class="comment">         *  ① 找出最高点</span></span><br><span class="line"><span class="comment">         *  ② 分别从左右两边往最高点遍历，如果下一个数比当前数小，说明可以接到雨水。</span></span><br><span class="line"><span class="comment">         *  【因为最高点一定是最高的，而下一个数比当前数小则说明存在一个边界值可以作为木桶的另一个边界】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;   <span class="comment">// 最高点值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// 最高点下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前遇到的短板的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前遇到的短板的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、先找到最高点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = height[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理左半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left+<span class="number">1</span> &lt; maxIndex; left++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt; leftMax) leftMax = height[left];</span><br><span class="line">            <span class="comment">// 如果下一个数比当前数小，说明可以接到雨水，接到雨水的量由木桶效应的短板决定</span></span><br><span class="line">            <span class="keyword">if</span> (height[left+<span class="number">1</span>] &lt; leftMax)</span><br><span class="line">            &#123;</span><br><span class="line">                result = result + (leftMax-height[left+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果下一个数大于等于当前数，说明接不到雨水，指针向前走</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理右半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length-<span class="number">1</span>; right-<span class="number">1</span> &gt; maxIndex; right--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt; rightMax) rightMax = height[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果下一个数比当前数小，说明可以接到雨水，接到雨水的量由木桶效应的短板决定</span></span><br><span class="line">            <span class="keyword">if</span> (height[right-<span class="number">1</span>] &lt; rightMax)</span><br><span class="line">            &#123;</span><br><span class="line">                result = result + (rightMax-height[right-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果下一个数大于等于当前数，说明接不到雨水，指针向前走</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/14/synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/14/synchronized/" class="post-title-link" itemprop="url">synchronized</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-14 10:24:47 / Modified: 14:19:29" itemprop="dateCreated datePublished" datetime="2021-09-14T10:24:47+08:00">2021-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-synchronized-的底层实现原理"><a href="#1-synchronized-的底层实现原理" class="headerlink" title="1    synchronized 的底层实现原理"></a>1    synchronized 的底层实现原理</h1><blockquote>
<p>  monitor；监听器</p>
</blockquote>
<p><strong>synchronized 同步代码块</strong></p>
<ul>
<li>  synchronized <strong>同步代码块</strong>是通过 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令来实现的，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指向同步代码块的结束位置。</li>
<li>  当某个线程执行 monitorenter 指令时，线程就会去尝试获取锁对象对象头中的监听器 monitor 的持有权。（monitor 监听器存在于每个 Java 对象的对象头中，这也是为什么Java中任意对象可以作为锁的原因）</li>
<li>  监听器 monitor 其内部包含一个计数器，当计数器为 0 则可以成功获取，获取后将锁计数器 +1，相应的在执行 monitorexit 指令后，将锁计数器值 -1，表明锁被释放。</li>
<li>  如果线程获取对象锁失败，那么当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</li>
</ul>
<p><strong>synchronized 同步方法</strong></p>
<ul>
<li>  synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取而代之的是 <strong>ACC_SYNCHRONIZED</strong> 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来判断一个方法是否声明为同步方法，从而执行相应的同步调用。</li>
</ul>
<h1 id="2-synchronized-锁升级"><a href="#2-synchronized-锁升级" class="headerlink" title="2    synchronized 锁升级"></a>2    synchronized 锁升级</h1><blockquote>
<p>  <strong>无锁 | 偏向锁 | 轻量级锁 | 重量级锁</strong></p>
</blockquote>
<ul>
<li>  通过 synchronized 关键字加的锁会随着线程争用数量的变化锁状态也发生变化，其锁升级的过程为：<code>无锁 --&gt; 偏向锁 --&gt; 轻量级锁 --&gt; 重量级锁</code>。</li>
<li>  <strong>锁的升级的目的</strong>：为了提升性能、减少 synchronized 获得锁和释放锁所带来的消耗，在 Java6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。引入了 4 种<strong>锁状态</strong>：</li>
<li>  <strong>锁状态是一把锁在不同时刻的状态，本质上锁对象还是这个锁对象，只不过锁对象的状态发生了变换。</strong></li>
</ul>
<p><img src="/2021/09/14/synchronized/20190415101813830.png" alt="20190415101813830"></p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><ul>
<li>  无锁状态是锁对象初始化后的第一个状态，表示当前锁对象没有被任何线程持有过。</li>
<li>  无锁状态就是将锁对象对象头中 MarkWord 的标志位设置为 <strong>001</strong>。</li>
</ul>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><ul>
<li><p>  <strong>功能：减少同一线程获取锁的代价。</strong></p>
</li>
<li><p>  <strong>概念</strong>：偏向锁(Biased Locking) 是指它会偏向于第一个访问锁的线程。如果在运行过程中，只有一个线程来获取这个锁对象，不存在多线程竞争的情况，那么此时的锁对象是一个偏向锁对象。</p>
</li>
<li><p>  <strong>核心思想</strong>：如果一个线程获得了锁，那么锁就进入<strong>可偏向状态</strong>，当该线程再次请求获取锁时，只需要检查：① 锁对象的对象头中的 MarkWord 锁标志位是偏向锁，② 并且锁对象的对象头中的 MarkWord 中的 ThreadID 等于当前线程 ID 即可。这样就省去了大量有关锁申请的操作。</p>
</li>
<li><p><strong>解释说明：</strong></p>
<ol>
<li><p>偏向锁的实现是通过控制对象象对象头中的 <strong>Mark Word</strong> 中的标志位来实现的。在 MarkWord 中，有两个重要的参数：</p>
<p> ① 锁标志位</p>
<p> ② 偏向锁线程 ID</p>
</li>
<li><p> 如果一个锁对象第一次被线程 A 访问（线程 A 的线程 ID 是 <code>xxx001</code>），那么这个锁对象的 MarkWord 中就会记录锁标志位为 <strong>101</strong>，表示当前锁状态为可偏向，并且记录线程A 的线程 ID 到 MarkWord 中。</p>
</li>
<li><p> 线程 A 释放锁之后，若线程 A 想要再次获取这个锁对象，假设在线程 A 释放锁的这段时间内没有其它线程获取过这个锁对象，那么锁对象 MarkWord 中的锁标志位还是 101（可偏向），记录的线程 ID 还是 <code>xxx001</code>（线程A的线程ID）。此时，线程 A 获取锁对象的过程非常简单，① 先比较锁标志位是否为 101，② 如果是的话，再比较锁对象MarkWord 中记录的线程ID 是否与当前线程ID 相同，若相同则直接获取锁对象。</p>
</li>
<li><p> 如果在线程 A 释放锁之后，另外有一个线程 B 尝试获取锁对象，①首先比较锁标志位为101，②接着会比较锁对象中储存的线程ID是否为当前线程，发现不是（锁对象中存储的线程ID应该是线程A的线程ID），这时候锁的偏向状态就会被破坏，从而升级到轻量级锁。</p>
</li>
</ol>
</li>
</ul>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><ul>
<li>  轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。</li>
<li>  <strong>轻量级锁的下限</strong>：只要存在第二个线程申请锁，哪怕这个线程没有和之前持有锁的线程产生竞争关系，属于一前一后地交替执行，这时候锁状态也会从偏向锁升级到轻量级锁。</li>
<li>  <strong>轻量级锁的上限</strong>：如果存在第二个线程申请锁，并且这个线程和第一个线程产生了竞争关系，如果在自旋次数的指定范围内能够获取到锁，那么此时锁对象的状态仍然是轻量级锁，只有当自旋的次数超出了指定范围之后，轻量级锁才会升级到重量级锁。</li>
<li>  轻量级锁状态下，认为虽然虽然竞争是存在的，但是理想情况下竞争的程度很低，通过 <strong>自旋方式</strong> 等待上一个线程释放锁。</li>
<li>借用上面的例子就是：<ol>
<li> 线程 A 先持有锁对象，将锁对象打上了自己的标记，但是线程 A 又释放了锁对象，这时线程 B 尝试占有锁对象，由于线程 A 此时并没有占有锁对象，所以线程 B 是可以抢到锁对象的，但是即便线程 B 抢到了锁对象，锁对象的状态也会从偏向锁升级到轻量级锁。</li>
<li> 同样，线程A先持有锁对象，此时线程B同时也在尝试获取锁对象，发现锁对象被持有，就先通过自旋的方式等待，如果在很短的时间内，线程A释放了锁对象，线程B成功获取到了锁对象，那么此时锁对象的状态仍然会是轻量级锁。如果线程B自旋的时间超过了一定范围仍没有获取到锁对象，那么锁对象的状态就会升级到重量级锁。</li>
</ol>
</li>
</ul>
<h3 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h3><ul>
<li>  轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</li>
<li>  <strong>自旋锁</strong>：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，就可以通过让线程执行循环来等待锁的释放，而不让出 CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，这时才会将线程在操作系统层面挂起，这就是自旋锁的优化方式。</li>
<li>  但是它也存在<strong>缺点</strong>：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。</li>
<li>  <strong>自适应自旋锁</strong>：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</li>
</ul>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><ul>
<li>  重量级锁可以由轻量级锁升级而来。</li>
<li>  重量级锁的<strong>核心思想</strong>是：当<strong>同一时间</strong>有多个线程竞争锁时，并且未持有锁的线程的最大自旋次数超过指定范围后，锁就会被升级成重量级锁，此时申请锁带来的开销也就变大。</li>
<li>  重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。</li>
</ul>
<h2 id="为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？"><a href="#为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？" class="headerlink" title="为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？"></a>为什么要引入偏向锁和轻量级锁？为什么重量级锁开销大？</h2><ul>
<li>  重量级锁底层依赖于系统的同步函数来实现，这些底层的同步函数操作会涉及到：操作系统用户态和内核态的切换、进程的上下文切换，而这些操作都是比较耗时的，因此重量级锁操作的开销比较大。</li>
<li>  然而在很多情况下，可能获取锁时只有一个线程，或者是多个线程交替获取锁，在这种情况下，使用重量级锁就不划算了，因此引入了偏向锁和轻量级锁来降低没有并发竞争时的锁开销。</li>
</ul>
<p>​        </p>
<h1 id="3-JVM-对-synchronized的优化有哪些？"><a href="#3-JVM-对-synchronized的优化有哪些？" class="headerlink" title="3    JVM 对 synchronized的优化有哪些？"></a>3    JVM 对 synchronized的优化有哪些？</h1><blockquote>
<ol>
<li> <strong>锁升级</strong>（见上一章）</li>
<li> <strong>锁粗化</strong></li>
<li> <strong>锁消除</strong></li>
<li> <strong>自旋锁与自适应自旋锁</strong>（见上一章）</li>
</ol>
</blockquote>
<ul>
<li>  <strong>锁升级、锁粗化 和 锁消除</strong> 都是由 JVM 虚拟机在底层帮我们优化的。</li>
</ul>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p><strong>锁粗化</strong> 就是将多个同步块的数量减少，并将单个同步块的作用范围扩大，本质上就是将多次上锁、解锁的请求合并为一次同步请求。</p>
<blockquote>
<ol>
<li> 举个例子，一个循环体中有一个代码同步块，每次循环都会执行加锁解锁操作。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(LOCK)&#123;</span><br><span class="line">        <span class="comment">// do some things</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li> 经过<code>锁粗化</code>后就变成下面这个样子了：</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">synchronized</span>(LOCK)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// do some things</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p><strong>锁消除</strong> 是指虚拟机编译器如果在运行时检测到了多个线程间的共享数据不会产生竞争关系，就会将加在共享数据上的锁进行消除。</p>
<blockquote>
<p>  举个例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    stringBuffer.append(s1);</span><br><span class="line">    stringBuffer.append(s2);</span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>test()</code> 主要用于是将字符串 s1 和字符串 s2 拼接起来。</li>
<li>  方法中的三个变量 <code>s1、s2、stringBuffer</code> 都是局部变量，保存在栈上。栈是线程私有的，所以就算有多个线程访问 <code>test()</code> 方法也是线程安全的。</li>
<li>  我们都知道 StringBuffer 是线程安全的，<code>append()</code> 方法是同步方法（被 synchronized 修饰），但是 <code>test()</code> 方法本来就是线程安全的，为了提升效率，虚拟机就会帮我们消除 <code>append()</code> 方法上的同步锁，这个过程就被称为<strong>锁消除</strong>。</li>
</ul>
<hr>
<h1 id="4-synchronized-锁降级"><a href="#4-synchronized-锁降级" class="headerlink" title="4    synchronized 锁降级"></a>4    synchronized 锁降级</h1><ul>
<li>  synchronized 锁是允许降级的。</li>
<li><strong>触发时机</strong>：在全局安全点（safepoint）中，执行清理任务的时候会触发尝试降级锁。当锁降级时，主要进行了以下操作：<ol>
<li> 恢复锁对象的 markword 对象头；</li>
<li> 重置 ObjectMonitor，然后将该 ObjectMonitor 放入全局空闲列表，等待后续使用。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="5-synchronized的用法有哪些"><a href="#5-synchronized的用法有哪些" class="headerlink" title="5    synchronized的用法有哪些?"></a>5    synchronized的用法有哪些?</h1><ul>
<li>  修饰普通方法：作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</li>
<li>  修饰静态方法:作用于当前类，进入同步代码前要获得当前类对象的锁,synchronized 关键字加到</li>
<li>  修饰代码块:指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>  static 静态方法和 <code>synchronized(xxx.class)</code> 代码块上都是是给 Class 类上锁</li>
<li>  如果一个线程A调用一个实例对象的非静态的 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的是当前对象的对象锁。</li>
<li>  尽量不要使用 <code>synchronized(String s)</code> ，因为 JVM 中，字符串常量池具有缓冲功能。</li>
</ul>
<hr>
<h1 id="6-synchronized的作用有哪些？"><a href="#6-synchronized的作用有哪些？" class="headerlink" title="6    synchronized的作用有哪些？"></a>6    synchronized的作用有哪些？</h1><ol>
<li><strong>原子性</strong>：确保多个线程互斥的访问同步代码；</li>
<li><strong>可见性</strong>：保证共享变量的修改能够及时可见，其实是通过 JMM 中的 “<strong>对一个变量 unlock 操作之前，必须要同步到主内存中；如果对一个变量进行 lock 操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中 load 操作或 assign 操作初始化变量值</strong>” 来保证的；</li>
<li><strong>有序性</strong>：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的 lock 操作”。</li>
</ol>
<h1 id="7-synchronized-的非公平体现在哪些地方？"><a href="#7-synchronized-的非公平体现在哪些地方？" class="headerlink" title="7    synchronized 的非公平体现在哪些地方？"></a>7    synchronized 的非公平体现在哪些地方？</h1><p>当持有锁的线程释放锁时，该线程会执行以下两个重要操作：</p>
<ol>
<li><p>先将锁的持有者 owner 属性赋值为 null</p>
</li>
<li><p>唤醒等待队列中的一个线程：</p>
</li>
</ol>
<p>  ① 在线程 A 和线程 B 之间，如果有其他线程刚好在尝试获取锁（例如自旋），则可以马上获取到锁。</p>
<p>  ② 随机唤醒。当线程尝试获取锁失败，进入阻塞时，加入队列的顺序，和最终被唤醒的顺序是不一致的，也就是说你先进入队列，不代表你就会先被唤醒。</p>
<hr>
<h1 id="8-synchronized-和-ReentrantLock-区别是什么？"><a href="#8-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="8    synchronized 和 ReentrantLock 区别是什么？"></a>8    synchronized 和 ReentrantLock 区别是什么？</h1><blockquote>
<ol>
<li> <strong>两者都是可重入锁</strong></li>
</ol>
</blockquote>
<p>可重入锁指的是在一个线程中可以多次获取同一把锁，比如：一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁，两者都是同一个线程每进入一次，锁的计数器都自增1，在释放锁的时候需要等到锁的计数器下降为 0 时才能释放锁。</p>
<blockquote>
<ol start="2">
<li> <strong>synchronized 是在 JVM 层面实现的，而 ReentrantLock 是在 API 层面实现的</strong></li>
</ol>
</blockquote>
<ul>
<li>  synchronized 是在 JVM 层面实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的</li>
<li>  ReentrantLock 是在 API 层面实现的，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong></li>
</ol>
</blockquote>
<p>相比 synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：</p>
<ol>
<li> <strong>等待可中断</strong>；通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，从等待队列中出队（AQS 中的 waitStatus 状态码发生改变），改为处理其他事情。</li>
<li> <strong>可实现公平锁</strong>；ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。</li>
<li> <strong>可实现定点通知</strong>：ReentrantLock 类线程对象可以注册在指定的 Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 <code>notify()/notifyAll()</code> 方法进行通知时，被通知的线程是由 JVM 随机选择的，而使用 ReentrantLock 类结 Condition 实例可以实现“定点通知”。</li>
</ol>
<blockquote>
<ol start="4">
<li> <strong>使用选择</strong></li>
</ol>
</blockquote>
<ul>
<li>  除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。</li>
<li>  synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</li>
</ul>
<hr>
<h1 id="9-synchronized-和-Lock-有什么区别？"><a href="#9-synchronized-和-Lock-有什么区别？" class="headerlink" title="9    synchronized 和 Lock 有什么区别？"></a>9    synchronized 和 Lock 有什么区别？</h1><ul>
<li>  synchronized 可以给 <strong>方法和代码块</strong> 加锁；而 lock 只能给<strong>代码块</strong>加锁。</li>
<li>  synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock() 去释放锁就会造成死锁。</li>
<li>  通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ul>
<hr>
<h1 id="10-synchronized-和-volatile-的区别是什么？"><a href="#10-synchronized-和-volatile-的区别是什么？" class="headerlink" title="10    synchronized 和 volatile 的区别是什么？"></a>10    synchronized 和 volatile 的区别是什么？</h1><ol>
<li> volatile 本质是在告诉 JVM 当前变量在工作内存中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li> volatile 仅能使用在变量级别；synchronized 则可以使用在变量和方法级别的</li>
<li> volatile 仅能实现变量的修改可见性，不能保证原子性；而synchronized 则可以 保证变量的修改可见性和原子性</li>
<li> volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li> volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/06/AQS/" class="post-title-link" itemprop="url">AQS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-06 17:27:18" itemprop="dateCreated datePublished" datetime="2021-09-06T17:27:18+08:00">2021-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-08 22:02:01" itemprop="dateModified" datetime="2021-10-08T22:02:01+08:00">2021-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<ul>
<li>  AQS简介</li>
<li>  AQS数据结构</li>
<li>  资源共享模式</li>
<li>  AQS 源码分析</li>
<li>  释放资源</li>
</ul>
</blockquote>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><blockquote>
<ol>
<li> 公平锁和非公平锁</li>
<li> 可重入锁</li>
<li> LockSupport</li>
<li> 自旋锁</li>
<li> 数据结构链表</li>
<li> 设计模式——模板设计模式</li>
</ol>
</blockquote>
<hr>
<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="1-为什么学"><a href="#1-为什么学" class="headerlink" title="1    为什么学"></a>1    为什么学</h2><h3 id="1-1-重要性"><a href="#1-1-重要性" class="headerlink" title="1.1    重要性"></a>1.1    重要性</h3><ul>
<li>  JUC 底层原理就是 AQS，就相当于 JVM 之于 Java。</li>
<li>  AQS 是 JUC 内容中最重要的基石</li>
</ul>
<blockquote>
<p>  <strong>为什么需要 AQS ？</strong></p>
</blockquote>
<p>在不同的多线程场景中，往往需要使用不同的同步器（锁），如果为每一个同步器都实现一遍所有功能的话，虽然可以但并不方便，因为有一部分功能是所有子类同步器都需要实现的公共功能。而 AQS 就是这样一个抽象类，它里面包含了部分抽象方法，这些抽象方法的具体实现交给了子类（模板方法设计模式），还有一部分非抽象方法，这些方法是所有子类同步器都需要使用到的方法，并且无序子类重写。AQS 大大地减少了重复代码量，降低了代码耦合程度。</p>
<blockquote>
<p>  <strong>AQS 为什么是 JUC 内容中最重要的基石？</strong></p>
</blockquote>
<p>JUC 中和 AQS 有关的类：</p>
<ul>
<li>  Semaphore 信号量</li>
<li>  CyclicBarrier</li>
<li>  ReentrantLock</li>
<li>  CountDownLatch</li>
<li>  ReentrantReadWriteLock</li>
</ul>
<p>以上列举的几种类，虽然是不同的 API，但其内部都有一些共同的操作，例如加锁、释放锁。如果为每个 API 都重写一份功能实现的话，虽然可以，但并不划算。而 AQS 就是这样一个 API ，它把同步器（包括锁）中需要实现的功能抽取出来，在  AQS 中进行声明和简单逻辑的实现。这样子类同步器只需要实现 AQS 类，并实现 AQS 类中部分未实现的方法，就可以轻易的实现自定义的同步器。</p>
<ol>
<li> <strong>ReentrantLock</strong></li>
</ol>
<p><img src="/2021/09/06/AQS/image-20210716222211925.png" alt="image-20210716222211925"></p>
<ol start="2">
<li> <strong>CountDownLatch</strong></li>
</ol>
<p><img src="/2021/09/06/AQS/image-20210716222347766.png" alt="image-20210716222347766"></p>
<ol start="3">
<li> <strong>ReentrantReadWriteLock</strong></li>
</ol>
<p><img src="/2021/09/06/AQS/image-20210716222507442.png" alt="image-20210716222507442"></p>
<ol start="4">
<li> <strong>Semaphore</strong></li>
</ol>
<p><img src="/2021/09/06/AQS/image-20210716222601965.png" alt="image-20210716222601965"></p>
<h3 id="1-2-必要性"><a href="#1-2-必要性" class="headerlink" title="1.2    必要性"></a>1.2    必要性</h3><ul>
<li>  多线程环境下，为保证线程安访问共享资源时就会加锁，加锁就会导致抢不到锁的其它线程阻塞，如果有多个线程被阻塞后就需要对这些线程进行排队，实现排队必然需要队列（抢不到锁的线程被阻塞后就得去排队）。</li>
<li>  抢到锁的线程直接访问临界资源执行业务逻辑，抢不到锁的线程必然涉及一种排队等候机制。抢占锁失败的线程继续等待，但等候的线程仍保留获取锁的可能性。【在锁被前一个持有锁的线程释放后等待队列中的线程就有可能获取到锁】</li>
<li>  如果锁被占用，就需要一定的阻塞等待和唤醒机制来保证锁分配。这个机制主要是通过 CLH（CLH 是三个科学家的首字母缩写）队列的变体实现的，将暂时获取不到锁（被阻塞）的线程加入到等待队列中，这个队列就是 AQS 的抽象表现。它被阻塞的线程封装成一个个节点（Node）加入等待队列中，通过 CAS、自旋以及 <code>LockSupport#part()</code> 等方式，维护 state 变量的状态，使并发达到同步的控制效果。</li>
<li>  <strong>AQS 管理的是没有抢到锁的、将要被加入到阻塞队列的线程。</strong></li>
</ul>
<hr>
<h2 id="2-是什么"><a href="#2-是什么" class="headerlink" title="2    是什么"></a>2    是什么</h2><blockquote>
<p>  <strong>AQS；AbstractQueuedSynchronizer；抽象队列同步器</strong></p>
</blockquote>
<ul>
<li>  <strong>抽象</strong>：抽象类，只进行方法的声明和部分通用方法的实现，其余细节都交给子类去实现；</li>
<li>  <strong>队列</strong>：使用先进先出（FIFO）队列存储数据；</li>
<li>  <strong>同步</strong>：实现了同步的功能。</li>
</ul>
<h2 id="3-有什么用"><a href="#3-有什么用" class="headerlink" title="3    有什么用"></a>3    有什么用</h2><ul>
<li>  <strong>AQS 是用来构建锁或者其它同步器的基础框架</strong>。</li>
<li>  使用 AQS 能简单且高效地构造出应用广泛的同步器，比如我们学过的 ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 实现的。</li>
<li>  当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器，只要在子类中实现它的几个 <code>protected</code> 方法就可以了。</li>
</ul>
<blockquote>
<p>  <strong>锁和同步器的关系：</strong></p>
</blockquote>
<ul>
<li><p>  锁：面向锁的<strong>使用者</strong>。定义了程序员和锁交互的 API，隐藏了实现细节。</p>
</li>
<li><p>  同步器：面向锁的<strong>实现者</strong>，即怎样实现一个锁。提出了统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。</p>
</li>
</ul>
<hr>
<h2 id="4-AQS-数据结构"><a href="#4-AQS-数据结构" class="headerlink" title="4    AQS 数据结构"></a>4    AQS 数据结构</h2><ul>
<li><p>  AQS 内部通过一个 FIFO <strong>双端队列</strong>来完成资源获取线程的排队工作，</p>
</li>
<li><p>使用 <strong>volatile int state</strong> 变量作为资源的标识。同时定义了几个获取和改变 <code>state</code> 的 <code>protectd</code> 方法，子方法可以通过重写这些方法来实现自己的逻辑。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState()</span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure></li>
<li><p>  这 3 个方法均是原子操作，其中 <code>compareAndSetState</code> 的实现依赖于 Unsafe 的 <code>compareAndSwapInt()</code> 方法。</p>
</li>
<li><p>  AQS 类本身实现的是⼀些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针 <code>head</code> 和 <code>tail</code> 用于标识队列的头部和尾部。其数据结构如图：</p>
</li>
</ul>
<p><img src="/2021/09/06/AQS/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="AQS数据结构"></p>
<ul>
<li>  但它并不是直接储存线程，而是存储与线程绑定的 Node 节点。</li>
</ul>
<blockquote>
<p>  <strong>小总结：</strong></p>
</blockquote>
<ul>
<li>  AQS 就是一个双向队列 + 一个 int 类型的变量 state</li>
<li>  <strong>AQS = 双向队列 + state</strong> </li>
</ul>
<hr>
<h3 id="4-1-AQS内部体系架构"><a href="#4-1-AQS内部体系架构" class="headerlink" title="4.1    AQS内部体系架构"></a>4.1    AQS内部体系架构</h3><p><img src="/2021/09/06/AQS/AbstractQueuedSynchronizer.png" alt="AbstractQueuedSynchronizer"></p>
<ul>
<li>  AQS 有两个内部类：<strong>ConditionObject</strong> 和 <strong>Node</strong></li>
<li>  Sync 实现了 AQS，NofairSync 和 FairSync 实现了 Sync，所以说它们两个也实现了 AQS</li>
<li>  Sync、NofairSync 和 FairSync 都是 ReentrantLock 的内部类，也即 Lock 的内部类</li>
</ul>
<hr>
<h2 id="5-AQS-成员变量"><a href="#5-AQS-成员变量" class="headerlink" title="5    AQS 成员变量"></a>5    AQS 成员变量</h2><h3 id="5-1-AQS-成员变量"><a href="#5-1-AQS-成员变量" class="headerlink" title="5.1    AQS 成员变量"></a>5.1    AQS 成员变量</h3><p><img src="/2021/09/06/AQS/image-20210717091946871.png" alt="image-20210717091946871"></p>
<ol>
<li><p>静态内部类 <strong>Node</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span>;	<span class="comment">// Node 节点是对线程的抽象，与线程绑定</span></span><br></pre></td></tr></table></figure></li>
<li><p>同步状态码 <strong>state</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;	<span class="comment">// 同步状态码，有3种状态。0 表示无人占用，1 表示有线程正在占用，大于 1 表示可重入锁。</span></span><br></pre></td></tr></table></figure></li>
<li><p>等待队列的头结点 <strong>head</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;	<span class="comment">// 等待队列中的头结点</span></span><br></pre></td></tr></table></figure></li>
<li><p>等待队列的尾节点 <strong>tail</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;	<span class="comment">// 等待队列中的尾节点</span></span><br></pre></td></tr></table></figure></li>
<li><p>AQS 的父类 AbstractOwnableSynchronizer 中的成员变量 <strong>exclusiveOwnerThread</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;	<span class="comment">// 独占线程的线程ID</span></span><br></pre></td></tr></table></figure></li>
<li><p> 静态内部类 ConditionObject</p>
</li>
<li><p> 其它</p>
</li>
</ol>
<hr>
<h3 id="5-2-静态内部类Node"><a href="#5-2-静态内部类Node" class="headerlink" title="5.2    静态内部类Node"></a>5.2    静态内部类Node</h3><h4 id="1、资源共享模式"><a href="#1、资源共享模式" class="headerlink" title="1、资源共享模式"></a>1、资源共享模式</h4><p>资源共享的两种模式：</p>
<ul>
<li>  独占模式（Exclusive）：单个线程独占资源，一次只能被一个线程获取。如 <code>ReentrantLock</code>。</li>
<li>  共享模式（Share）：资源可同时可以被多个线程获取，具体的资源个数可以通过参数指定。如 <code>Semaphore/CountDownLatch</code>。</li>
</ul>
<p>两种不同的共享模式分别用于实现不同的同步器（锁），即独占锁或者共享锁。</p>
<p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如 ReadWriteLock 。</p>
<p>AQS 中关于这两种资源共享模式的定义源码（均在内部类Node中）。</p>
<h4 id="2、AQS-Node-类源码"><a href="#2、AQS-Node-类源码" class="headerlink" title="2、AQS$Node 类源码"></a>2、AQS$Node 类源码</h4><h5 id="Node-类成员变量"><a href="#Node-类成员变量" class="headerlink" title="Node 类成员变量"></a>Node 类成员变量</h5><ol>
<li> 前驱节点 <strong>prev</strong></li>
<li> 后继节点 <strong>next</strong></li>
<li> 当前节点的等待状态 <strong>waitStatus</strong></li>
<li> 结点对应的线程 thread</li>
<li> 等待队列里下一个等待条件的结点 nextWaiter</li>
<li> 其它</li>
</ol>
<h5 id="Node-类小结"><a href="#Node-类小结" class="headerlink" title="Node 类小结"></a>Node 类小结</h5><ul>
<li>  <strong>Node = waitStatus + 前后指针</strong></li>
</ul>
<h5 id="AQS-Node-类源码："><a href="#AQS-Node-类源码：" class="headerlink" title="AQS$Node 类源码："></a>AQS$Node 类源码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">       <span class="comment">// 标记一个（线程）节点在共享模式下等待（节点与线程绑定）</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">       <span class="comment">// 标记一个（线程）节点在独占模式下等待（节点与线程绑定）</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">/* 小总结：</span></span><br><span class="line"><span class="comment">		1、只有进入等待队列的线程，才会给其分配一个节点与线程绑定。</span></span><br><span class="line"><span class="comment">		2、换言之就是，如果一个线程抢占到了资源，就无需再给这个线程绑定节点对象了</span></span><br><span class="line"><span class="comment">        */</span>		</span><br><span class="line"></span><br><span class="line">       <span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消，即从等待队列中移除</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">      	<span class="comment">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// waitStatus的值，表示该结点（对应的线程）在等待某⼀条件，当 Condition 条件满足时会被唤醒</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">   	<span class="comment">// waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点(共享模式下，同步获取状态将会无条件的传播下去)</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">       <span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1。初始值是0，</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">		</span><br><span class="line">       <span class="keyword">volatile</span> Node prev;	<span class="comment">// 前置节点</span></span><br><span class="line">       <span class="keyword">volatile</span> Node next;	<span class="comment">// 后继节点</span></span><br><span class="line">       <span class="keyword">volatile</span> Thread thread;	<span class="comment">// 结点对应的线程</span></span><br><span class="line">       Node nextWaiter; <span class="comment">// 等待队列⾥下一个等待条件的结点</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断共享模式的方法</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">return</span> <span class="variable">nextWaiter</span> <span class="operator">=</span>= SHARED;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 返回 node 节点的前驱节点，或抛出 NullPointerException</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev; <span class="comment">// 让节点p指向当前线程绑定的节点的前驱结点</span></span><br><span class="line">           <span class="comment">// 如果这个前驱节点为空，抛出异常；如果前驱节点不为空，返回这个前驱节点即可</span></span><br><span class="line">           <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">           <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">           <span class="built_in">this</span>.thread = thread;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">           <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">           <span class="built_in">this</span>.thread = thread;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：通过 Node 我们可以实现两个队列：</p>
<ul>
<li>  一是通过 <code>prev</code> 和 <code>next</code> 实现 CLH 队列（阻塞线程的等待队列，双向队列）；</li>
<li>  二是 <code>nextWaiter</code> 实现 Condition 条件上的等待线程队列（单向队列），这个 Condition 主要用在 ReentrantLock 类中。</li>
</ul>
<blockquote>
<p>  <strong>AQS 中的 addWaiter() 私有方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用了Node类的 Node(Thread thread, Node mode) 构造函数</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="6-AQS-主要方法的源码解析"><a href="#6-AQS-主要方法的源码解析" class="headerlink" title="6    AQS 主要方法的源码解析"></a>6    AQS 主要方法的源码解析</h2><p>AQS 的设计是基于<strong>模板方法模式</strong>的，它有一些方法是必须要子类去实现的，主要包括：</p>
<ul>
<li>  **isHeldExclusively()**：该线程是否正在独占资源。只有用到 condition 时才需要去实现它。</li>
<li>  **tryAcquire(int)**：独占方式。尝试获取资源，成功则返回 true，失败则返回 false 。</li>
<li>  **tryRelease(int)**：独占方式。尝试释放资源，成功则返回 true，失败则返回 false 。</li>
<li>  **tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>  **tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。</li>
</ul>
<p>这些方法虽然都是 protected 方法，但是它们并没有在AQS具体实现，而是直接抛出异常（这里采用了模板设计模式，只要子类不实现这个方法，直接抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 AQS 实现了⼀系列主要的逻辑。下⾯我们从源码来分析⼀下<strong>获取和释放资源的主要逻辑</strong>：</p>
<h3 id="6-1-获取资源"><a href="#6-1-获取资源" class="headerlink" title="6.1    获取资源"></a>6.1    获取资源</h3><p>获取资源的入口是 <strong>acquire(int arg)</strong> 方法。arg 是要获取的资源的个数，在独占模式下始终为 1。这个方法的逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li> 首先调用 <strong>tryAcquire(arg)</strong> 尝试去获取资源。【这个方法要由子类提供具体的实现】</li>
</ol>
</blockquote>
<ul>
<li>  如果尝试获取资源成功，<code>tryAcquire(arg)</code> 方法返回值 true，取反后是 false，直接退出当前方法，转去执行获取锁成功后的代码逻辑，也就不会再将当前线程封装成 Node 节点并加入等待队列了。</li>
<li>  如果获取资源失败，<code>tryAcquire(arg)</code> 方法返回值 false，取反后是 true，继续执行 <code>&amp;&amp;</code> 符号后面的方法。即通过 <strong>addWaiter(Node.EXCLUSIVE)</strong> 方法把这个线程封装成 Node 节点并插入到等待队列中。其中传入的参数代表要插入的 Node 是独占式的。这个方法的具体实现如下：</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>addWaiter(Node.EXCLUSIVE)</strong> 方法源码</li>
</ol>
</blockquote>
<ul>
<li>  方法介绍：将未获取到资源的线程封装到一个 Node 节点中，并追加到等待队列尾部。</li>
<li>  方法参数：接收一个指定模式（mode）的节点。（独占式 &amp; 共享式）</li>
<li>  返回值：返回值是追加到尾部的那个节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为当前线程新建一个Node节点并与线程绑定（独占式/共享式）</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	也就是说，如果线程获取资源成功，就不会被加入等待队列，自然也不会生成线程对应的Node节点。</span></span><br><span class="line"><span class="comment">    	换言之，只有线程获取资源不成功时，才会为当前线程新建一个对应模式的Node节点（这个节点绑</span></span><br><span class="line"><span class="comment">    	定一个线程），并将节点加入等待队列</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	将Node节点插入等待队列中，成为新的尾节点</span></span><br><span class="line"><span class="comment">    		1.让node节点的前驱节点指向旧的尾节点</span></span><br><span class="line"><span class="comment">    		2.更新旧的尾节点，让其指向当前节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail; <span class="comment">// 让当前node节点的前驱节点指向队尾节点。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	1、如果当前等待队列为空，则尾节点一定为 null，则 pred 指向 null，不进入if判断的代码块内</span></span><br><span class="line"><span class="comment">    	2、如果当前等待队列不为空，则尾节点一定不为null，则 pred 也不为 null，进入if判断的代码块内执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred; <span class="comment">// 让当前node节点的前驱节点指向当前队列的尾节点</span></span><br><span class="line">        <span class="comment">// 修改结果回写的时候要进行CAS比较，防止队列的尾节点被其它线程提前修改。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">            <span class="comment">// 如果CAS比较成功，让尾节点的next指针指向当前节点，尾插结束，返回被新插入的节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待队列为空或者上述CAS失败，继续使用CAS循环插入【因为上述的CAS只比较了一次，enq则是一个循环的CAS插入过程】</span></span><br><span class="line">    enq(node);	</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li> <strong>enq(node)</strong> 方法源码</li>
</ol>
</blockquote>
<ul>
<li>  方法介绍：使用循环 CAS 的方式将等待线程的节点对象插入等待队列</li>
<li>  循环 CAS 就叫做 <strong>自旋</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;	<span class="comment">// 拿到当前等待队列的尾节点</span></span><br><span class="line">        <span class="comment">// 如果尾节点为空（即队列为空），就新建一个空的头结点，并把当先线程绑定的node节点通过CAS的方式追加到新的头结点之后</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果尾节点不为空，就通过CAS的方式把当前线程节点node插入等待队列尾部</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) </span><br><span class="line">            &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li> <strong>小总结</strong></li>
</ol>
</blockquote>
<p>上面的两个函数⽐较好理解，就是在队列的尾部插入新的 Node 节点，但是需要注意的是由于 AQS 中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这⾥是通过 CAS 自旋的方式保证了操作的线程安全性。</p>
<p>OK，现在回到最开始的 <code>aquire(int arg)</code> 方法。现在通过 <code>addWaiter </code>方法，已经把⼀个 Node 放到等待队列尾部了。而处于等待队列中的结点是从头结点⼀个⼀个按顺序去获取资源的。具体的实现我们来看看 <strong>acquireQueued</strong> 方法</p>
<blockquote>
<ol start="5">
<li> **acquireQueued(final Node node, int arg) **方法源码</li>
</ol>
</blockquote>
<ul>
<li>  方法介绍：</li>
<li>方法参数：<ul>
<li>  node 节点是最新插入等待队列的节点，即等待队列中的最后一个节点。</li>
<li>  arg 是要获取的资源的个数，在独占模式下始终为 1。</li>
</ul>
</li>
<li>  返回值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); <span class="comment">// 获取node节点的前驱节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果node的前驱结点p是head，表示node是第⼆个结点，就可以尝试去获取资源了【因为第一个节点是无数据的节点，只标志队列的开始】</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) </span><br><span class="line">            &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="6-2-释放资源"><a href="#6-2-释放资源" class="headerlink" title="6.2    释放资源"></a>6.2    释放资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="AQS-原理概述（以-ReentrantLock-为例）"><a href="#AQS-原理概述（以-ReentrantLock-为例）" class="headerlink" title="AQS 原理概述（以 ReentrantLock 为例）"></a>AQS 原理概述（以 ReentrantLock 为例）</h1><h2 id="ReentrantLock-和-AQS-的关系"><a href="#ReentrantLock-和-AQS-的关系" class="headerlink" title="ReentrantLock 和 AQS 的关系"></a>ReentrantLock 和 AQS 的关系</h2><p><img src="/2021/09/06/AQS/ReentrantLock_AQS_01.png" alt="ReentrantLock_AQS_01"></p>
<p>ReentrantLock 类有一个内部类 Sync 继承了 AbstractQueuedSynchronizer 抽象类，说白了就是 ReentrantLock 中包含了一个 AQS 对象，AQS 对象是 ReentrantLock 实现加锁和释放锁的关键性核心组件。</p>
<h2 id="ReentrantLock-加锁和释放锁的底层原理"><a href="#ReentrantLock-加锁和释放锁的底层原理" class="headerlink" title="ReentrantLock 加锁和释放锁的底层原理"></a>ReentrantLock 加锁和释放锁的底层原理</h2><blockquote>
<ol>
<li> <strong>线程 T1 加锁</strong></li>
</ol>
</blockquote>
<p>如果现在有一个线程尝试调用 <code>ReentrantLock</code> 的 <code>lock()</code> 方法进行加锁，会发生什么事情呢？</p>
<p>很简单。这个 AQS 对象内部有一个核心变量 <code>private volatile int state</code>，代表了加锁的状态。初始状态下，<code>state == 0</code>，另外，这个 AQS 内部还有一个关键变量，用来记录当前加锁的是哪个线程，初始化状态下，这个变量是 null。</p>
<p><img src="/2021/09/06/AQS/ReentrantLock_AQS_01_1.png" alt="ReentrantLock_AQS_01_1"></p>
<p>接着线程 T1 调用 ReentrantLock#lock() 方法尝试进行加锁，这个加锁的过程，就是用 CAS 操作将 state 值从 0 变成 1。</p>
<p>如果 T1 之前没有其它线程加锁锁，那么 <code>state==0</code> 恒成立。此时线程 T1 就可以加锁成功。</p>
<p>一旦线程 T1 加锁成功后，就可以设置当前加锁线程是自己。如下图所示，就是线程 T1 加锁的过程。</p>
<p><img src="/2021/09/06/AQS/ReentrantLock_AQS_02.png" alt="ReentrantLock_AQS_02"></p>
<p>说白了，AQS 其实就是 JUC 包中的一个核心组件，里面有 <strong>state 变量</strong>、<strong>加锁线程变量</strong>等核心的东西，维护了加锁的状态。</p>
<p>而<strong>ReentrantLock 只是一个外层的 API，内核中的锁机制实现都是依赖于 AQS 组件的。</strong></p>
<p>ReentrantLock 顾名思义是一个可重入锁，即可以使用一个 ReentrantLock 对象执行多次 <code>lock()</code> 和 <code>unlock()</code> 方法。</p>
<p>那么 AQS 是如何实现可重入加锁的呢？线程 T1 每调用一次 <code>lock()</code> 方法，如果 CAS 比较发现 state != 0，接着会再判断当前加锁线程是不是自己，如果是就把 state 的值累加 1，其余不变。同理，调用 <code>unlock()</code> 释放锁的时候就是把 state 值累减 1。</p>
<blockquote>
<ol start="2">
<li> <strong>线程 T2 加锁</strong></li>
</ol>
</blockquote>
<p>如果线程 T1 加锁之后，线程 T2 想要争夺锁会怎么样？（<strong>互斥锁</strong>）</p>
<ol>
<li> 线程 T2 尝试获取锁，调用 <code>lock()</code> 方法，首先会去检查 <code>ReentrantLock.AQS.state</code> 变量是否为 0，发现不为 0，说明有线程正在使用锁，CAS 校验失败；</li>
<li> 接着线程 T2 会继续查看当前加锁的线程是不是自己，“<strong>加锁线程</strong>”这个变量明确记录了是线程 T1 占用了这个锁，所以此时线程 T2 会加锁失败。</li>
</ol>
<p><img src="/2021/09/06/AQS/ReentrantLock_AQS_03.png" alt="ReentrantLock_AQS_03"></p>
<blockquote>
<ol start="3">
<li> <strong>加锁失败</strong></li>
</ol>
</blockquote>
<p>接着，线程 T2 会将自己放入 AQS 的同步等待队列中，因为自己尝试加锁失败了，此时就要将自己放入等待队列中，直到线程 T1 释放锁之后，自己就可以重新尝试加锁了。</p>
<p>所以 AQS 内部还有一个同步等待队列，专门存放那些加锁失败的线程。</p>
<p><img src="/2021/09/06/AQS/ReentrantLock_AQS_03_02.png" alt="ReentrantLock_AQS_03_02"></p>
<blockquote>
<ol start="4">
<li> <strong>释放锁</strong></li>
</ol>
</blockquote>
<p>接着，线程 T1 在执行完自己的业务逻辑代码之后，就会释放锁。释放锁的过程非常简单，就是将 AQS 内的 state 变量的值递减 1，如果 state 为 0，则彻底释放锁，会将“加锁线程”变量的值也设置为 null。</p>
<blockquote>
<ol start="5">
<li> <strong>释放锁之后</strong></li>
</ol>
</blockquote>
<p>接下来，会从等待队列的队头唤醒线程 T2 重新尝试加锁。</p>
<p>线程 T2 重新尝试加锁，还是使用 CAS 操作将 state 从 0 变成 1，此时就会加锁成功，并将 state 设置为 1，同时把 “<strong>加锁线程”</strong> 设置为线程 T2 自己，同时线程 T2 从同步等待队列中出队。 </p>
<hr>
<h1 id="从-ReentrantLock-开始解读-AQS"><a href="#从-ReentrantLock-开始解读-AQS" class="headerlink" title="从 ReentrantLock 开始解读 AQS"></a>从 ReentrantLock 开始解读 AQS</h1><p>Lock 接口的实现类（如 ReentrantLock ），基本都是通过【聚合】了一个【队列同步器】的子类（sync ）完成线程访问控制的。</p>
<p><img src="/2021/09/06/AQS/ReentrantLock.png" alt="ReentrantLock"></p>
<p>ReentrantLock 类：</p>
<ol>
<li> 实现了 Lock 接口</li>
<li>包含一个内部抽象类 Sync<ul>
<li>  Sync 实现了 AbstractQueuedSynchronizer 接口</li>
<li>  Sync 包含两个实现类 FairSync 和 NonfairSync </li>
</ul>
</li>
</ol>
<p>对比公平锁和非公平锁的 tryAcquire() 方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少一个判断 hasQueuedPredecessors()。该方法中判断了是否需要排队，导致公平锁和非公平锁的差异如下：</p>
<p>公平锁：公平锁讲究先来后到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入到等待队列之中。</p>
<p>非公平锁：不管是否有等待队列，如果可以获取锁，就马上占有锁对象。也就是说等待队列中的第一个线程在 unpark() 之后还是需要 竞争锁（存在线程竞争锁的情况）</p>
<p><strong>整个 ReentrantLock 加锁（非公平）的过程可以分为三个阶段：</strong></p>
<ol>
<li> <strong>尝试加锁</strong>，加锁成功则正常调用资源</li>
<li> <strong>加锁失败，线程进入AQS队列</strong></li>
<li> <strong>线程进入队列后，进入阻塞状态</strong></li>
</ol>
<blockquote>
<p>  lock()</p>
<p>  acquire()</p>
<p>  tryAcquire(arg)</p>
<p>  addWaiter(Node.EXCLUSIVE)：将线程节点加入等待队列</p>
<p>  acquireQueued(addWaiter(Node.EXCLUSIVE)， arg)</p>
</blockquote>
<p>acquire(1) 表示占用 1 个</p>
<blockquote>
<ol>
<li> <strong>ReentrantLock 底层源码01</strong></li>
</ol>
</blockquote>
<p><img src="/2021/09/06/AQS/ReentrantLock%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%8101.png" alt="ReentrantLock底层源码01"></p>
<blockquote>
<ol start="2">
<li> <strong>公平锁和非公平锁的 tryAcquire() 方法</strong></li>
</ol>
</blockquote>
<p><img src="/2021/09/06/AQS/fair_nonfair$tryAcquire.png" alt="fair_nonfair$tryAcquire"></p>
<ul>
<li>  hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 reentrantLock.lock() 方法</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层调用的是 sync.lock(); 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sync 是 AQS 的一个静态抽象子类，包含两个实现类 FairSync 和 NonfairSync。</span></span><br><span class="line"><span class="comment">// 在 sync 中，lock 方法被声明为一个抽象方法，具体的方法实现包含在子类 FairSync 和 NonfairSync 中，我们以 ReentrantLock 默认的非公平锁 NonfairSync 为例。NonfairSync#lock 方法为：</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))	</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分支1：CAS 比较  state 的值是否为 0，如果为 0 则更新为 1，并设置锁的占用线程为当前线程。【锁对象空闲时】</span></span><br><span class="line"><span class="comment">// 分支2：在非公平锁中，即使发现锁对象被占用，也会调用 acquire(1) 方法尝试抢占锁。【锁对象已被占用】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来我们来看一下 acquire() 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;	</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;	</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tryAcquire(1) 方法：返回 true 表示加锁成功，返回 false 表示加锁失败。如果加锁成功，取反后为 false ，则不执行 &amp;&amp; 后面的方法。如果加锁失败，取反后为 true，则还需判断 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 方法的执行结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// addWaiter(Node.EXCLUSIVE) 方法</span></span><br><span class="line"><span class="comment">// acquireQueued(__, 1)) 方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>s</p>
<p><strong>tryAcquire()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryAcquire() 方法是一个顶级方法，具体的实现在其实现类中，我们选择了 NonfairSync#tryAcquire 方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;	 	<span class="comment">// tryAcquire(1)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonfairSync#tryAcquire</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;	<span class="comment">// tryAcquire(1)</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);		<span class="comment">// nonfairTryAcquire(1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回 true 表示加锁成功，false 表示加锁失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync#nonfairTryAcquire()</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分支1：如果 state==0（代表当前锁无线程占用），就更新 state 为 1，并设置锁对象的占用线程为为当前线程，返回 true；</span></span><br><span class="line"><span class="comment">// 分支2：state!=0，但是当前线程与锁对象绑定的线程相同（可重入锁），就将 state 累加 1，返回 true；</span></span><br><span class="line"><span class="comment">// 分支3：state!=0 &amp;&amp; 加锁线程！=当前线程，则说明加锁失败，返回 false</span></span><br></pre></td></tr></table></figure>



<p><strong>addWaiter(Node.EXCLUSIVE)</strong>  加强</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、将线程封装成 node 节点</span></span><br><span class="line"><span class="comment">// 2、Node 的</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;	<span class="comment">// 失败的标志位</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">//是否被打断的标志位。被打断与失败刚好是相反的。如果被打断一定失败</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果失败的标志位为 true，该线程就取消排队</span></span><br><span class="line">        <span class="keyword">if</span> (failed)	</span><br><span class="line">        &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>  调用 unpark 后线程才真正进入阻塞状态，之前虽然被连接到了等待队列中，但是仍然会总是尝试去 CAS 比较锁是否空闲，仍然想要去抢夺锁</li>
<li>  而调用 unpark 后，就不会再主动去监测锁是否空闲了，只有当持有锁的线程调用 unpark 方法唤醒后线程才会继续执行。</li>
<li>  【阻塞】</li>
</ul>
<h1 id="2021-10-08附加"><a href="#2021-10-08附加" class="headerlink" title="2021.10.08附加"></a>2021.10.08附加</h1><ol>
<li> AQS类内部</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">并查集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-30 09:55:15 / Modified: 16:19:23" itemprop="dateCreated datePublished" datetime="2021-08-30T09:55:15+08:00">2021-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  参考地址：力扣大佬</p>
<p>  链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/">https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/</a></p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>  并查集是一种数据结构</li>
<li>  并查集这三个字，一个字代表一个意思。</li>
<li>  <strong>并（Union）</strong>，代表合并</li>
<li>  <strong>查（Find）</strong>，代表查找</li>
<li>  <strong>集（Set）</strong>，代表这是一个以字典为基础的数据结构，它的基本功能是合并集合中的元素，查找集合中的元素</li>
<li>  并查集的典型应用是有关<strong>连通分量</strong>的问题</li>
</ul>
<hr>
<h2 id="并查集实现"><a href="#并查集实现" class="headerlink" title="并查集实现"></a>并查集实现</h2><blockquote>
<ol>
<li> <strong>数据结构</strong></li>
</ol>
</blockquote>
<ul>
<li>  并查集跟树有些类似，只不过它跟树是相反的。在树这个数据结构里面，每个节点会记录它的子节点。在并查集里，每个节点会记录它的父节点。</li>
<li>  通常用 Map 来实现这个结构，Map 的 K 表示当前节点，V 表示当前节点的父节点</li>
</ul>
<p><img src="/2021/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/1609980000-ofFjdW-%E5%B9%BB%E7%81%AF%E7%89%871.JPG" alt="幻灯片1.JPG"></p>
<p>可以看到，如果节点是相互连通的（从一个节点可以到达另一个节点），那么他们在同一棵树里，或者说在同一个集合里，或者说他们的<strong>祖先是相同的</strong>。</p>
<blockquote>
<ol start="2">
<li> <strong>初始化节点</strong></li>
</ol>
</blockquote>
<p>初始化时每个节点的父节点都为空，也就是说每个节点最初都是一个独立的子集</p>
<blockquote>
<ol start="3">
<li> <strong>合并两个节点</strong></li>
</ol>
</blockquote>
<ul>
<li>  如果发现两个节点是连通的（一般通过题目中给定的条件来判断两个节点是否连通），就把它们合并。</li>
<li>  合并就是设置两个节点的祖宗相同，可以把 A 节点的祖宗设置为 A、B 共同的祖宗或者把 B 节点的祖宗设置为 A、B 共同的祖宗。</li>
</ul>
<blockquote>
<ol start="4">
<li> <strong>判断两节点是否连通</strong></li>
</ol>
</blockquote>
<ul>
<li>  就是判断两个节点的祖先是否相同，相同处于同一连通分量中</li>
</ul>
<blockquote>
<ol start="5">
<li> <strong>查找祖宗（通用方法）</strong></li>
</ol>
</blockquote>
<ul>
<li>  如果该节点的父节点不为空，就一直迭代向上查找，直到找到某个节点的父节点为空</li>
</ul>
<h2 id="并查集基本模板代码-Java"><a href="#并查集基本模板代码-Java" class="headerlink" title="并查集基本模板代码(Java)"></a>并查集基本模板代码(Java)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.unionFind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/30 9:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并查集模板类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// K 表示当前节点，V表示当前节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、【初始化节点】当新加入一个节点时节点的父节点为空，即每个节点初始都是一个独立的子集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> newNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(newNode))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(newNode, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、【合并两个节点】如果两个节点是连通的，就把它们合并到一个子集中。</span></span><br><span class="line">    <span class="comment">// ==&gt; 就是设置祖先相同，可以把 A 子树的祖先作为两个节点共同的祖先，也可以把B子树作为两个节点共同的祖先</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB)	<span class="comment">// 只有当不在同一个连通分量中时才需要设置到一块去，如果已经在了就无需重复设置</span></span><br><span class="line">        &#123;</span><br><span class="line">            map.put(rootB, rootA);  <span class="comment">// 将 rootA 作为合并后的新的祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、【判断两个节点是否连通】就是判断两个节点是否有同一个祖先，如果有，则证明连通；否则不连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line">        <span class="keyword">return</span> rootA==rootB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、【查找祖先】通用功能，如果父节点不为空，就一直迭代向上查找，直到找到父节点为空的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (map.get(root) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 map.get(node) == null 时，返回 node 即可</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h2><h3 id="LeetCode547：省份数量"><a href="#LeetCode547：省份数量" class="headerlink" title="LeetCode547：省份数量"></a>LeetCode547：省份数量</h3><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="comment">// 共有 n 个城市，依次初始化，每次初始化新的城市就判断是否与已添加的城市相连，如果相连就将它们连接起来，最后统计一共有多少个连通分量</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;isConnected.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将 i 添加到 uf 中</span></span><br><span class="line">            uf.add(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果两个城市相连，就将它们并入一个连通分量</span></span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uf.merge(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 UnionFind 中增加一个方法用于统计连通分量</span></span><br><span class="line">        <span class="keyword">return</span> uf.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// K 表示当前节点，V表示当前节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连通分量个数。每新增一个节点连通分量个数就加一，每合并一次节点连通分量个数就减一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="built_in">this</span>.num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、【初始化节点】当新加入一个节点时节点的父节点为空，即每个节点初始都是一个独立的子集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> newNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(newNode))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(newNode, <span class="literal">null</span>);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、【合并两个节点】如果两个节点是连通的，就把它们合并到一个子集中。</span></span><br><span class="line">    <span class="comment">// ==&gt; 就是设置祖先相同，可以把 A 子树的祖先作为两个节点共同的祖先，也可以把B子树作为两个节点共同的祖先</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 当两个节点连通，且这两个节点不在同一个连通分量中时，才进行合并</span></span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(rootB, rootA);  <span class="comment">// 将 rootA 作为合并后的新的祖先</span></span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、【判断两个节点是否连通】就是判断两个节点是否有同一个祖先，如果有，则证明连通；否则不连通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line">        <span class="keyword">return</span> rootA==rootB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、【查找祖先】通用功能，如果父节点不为空，就一直迭代向上查找，直到找到父节点为空的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (map.get(root) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 map.get(node) == null 时，返回 node 即可</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="LeetCode200：岛屿数量"><a href="#LeetCode200：岛屿数量" class="headerlink" title="LeetCode200：岛屿数量"></a>LeetCode200：岛屿数量</h3><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xsyu.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/30 12:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求岛屿的数量，可以转换为求连通分量的数量。可以考虑用并查集来求解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution200_02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] grid = <span class="keyword">new</span> <span class="title class_">char</span>[][]&#123;</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution200_02</span> <span class="variable">solution200</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution200_02</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> solution200.numIslands(grid);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*【特殊情况】*/</span></span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*【一般情况】</span></span><br><span class="line"><span class="comment">        *   1、从头到尾遍历：遇到“0”跳过，遇到 &quot;1&quot; 就并入集合。</span></span><br><span class="line"><span class="comment">        *   2、最终看有几个连通分量</span></span><br><span class="line"><span class="comment">        *   */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【首先把矩阵中所有陆地的数量统计出来，加入到集合中】</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uf.add(i*cols+j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line"><span class="comment">//                    uf.add(i*cols+j);</span></span><br><span class="line">                    <span class="comment">// 查看上下左右是否可以并入并查集</span></span><br><span class="line">                    <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage((i-<span class="number">1</span>)*cols+j, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i+<span class="number">1</span> &lt; rows &amp;&amp; grid[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage((i+<span class="number">1</span>)*cols+j, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage(i*cols+j-<span class="number">1</span>, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j+<span class="number">1</span> &lt; cols &amp;&amp; grid[i][j+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.merage(i*cols+j+<span class="number">1</span>, i*cols+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> num;   <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新加入的节点设置其父节点为 null</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(node))</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(node, <span class="literal">null</span>);</span><br><span class="line">            num++;  <span class="comment">// 连通分量+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点合并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merage</span><span class="params">(<span class="type">int</span> nodeA, <span class="type">int</span> nodeB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果两个节点之间是连通的，就将其合并，合并后连通分量的数目-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> find(nodeA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> find(nodeB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当两个节点连通，且这两个节点不在同一个连通分量中时，才进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(rootA != rootB)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(rootA, rootB);</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点的祖宗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span>(map.get(root) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/28/%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/28/%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="post-title-link" itemprop="url">回溯法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-28 16:13:17" itemprop="dateCreated datePublished" datetime="2021-08-28T16:13:17+08:00">2021-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-01 22:02:24" itemprop="dateModified" datetime="2021-10-01T22:02:24+08:00">2021-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  力扣大佬解释链接：</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></p>
<blockquote>
<p>  <strong>核心要义：</strong></p>
</blockquote>
<p><strong>集合的大小构成了树的宽度，递归的深度构成了树的深度。</strong></p>
<blockquote>
<p>  <strong>回溯法模板</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、方法名 || 返回值 || 参数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、终止条件</span></span><br><span class="line"><span class="keyword">if</span>(终止条件)</span><br><span class="line">&#123;</span><br><span class="line">    结果收集;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、回溯搜索 + 遍历【集合的大小构成了树的宽度，递归的深度构成了树的深度】</span></span><br><span class="line"><span class="keyword">for</span>(本层集合中的元素)</span><br><span class="line">&#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径, 选择列表);	<span class="comment">// 递归</span></span><br><span class="line">    回溯;	<span class="comment">// 撤销处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="回溯法常见题型"><a href="#回溯法常见题型" class="headerlink" title="回溯法常见题型"></a>回溯法常见题型</h1><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><ul>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></li>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></li>
</ul>
<blockquote>
<ol start="40">
<li> <strong>组合总和</strong></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个数字只能使用一次</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先对数组进行排序，便于之后剪枝</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[len];  <span class="comment">// 用于标志数组中的元素是否使用过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        backtracking(startIndex, candidates, target, len, flag, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> len, <span class="type">boolean</span>[] flag, <span class="type">int</span> sum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 收集</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单层逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果是排序后的数组，那么相同的元素一定紧挨在一起，所以说如果第i个元素与第i-1个元素相等，那么它们得到的组合一定是重复的，这时候就可以跳过这个重复的元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>] &amp;&amp; flag[i-<span class="number">1</span>] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 path、sum、flag</span></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            backtracking(i+<span class="number">1</span>, candidates, target, len, flag, sum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组合总和中的去重问题：</strong></p>
<ul>
<li>  首先，要明确去重的概念，<strong>去重就是使用过的元素不能重复选取</strong>。</li>
<li>  组合问题可以抽象为树形结构，那么在“使用过”这个问题上，是可以抽象成两个维度的，<strong>一个维度是在同一树层上使用过，另一个维度是在同一树枝上使用过</strong>。</li>
<li>  在本题中，我们可以看到，元素在同一个组合内是可以重复的，但是最终结果内的任意两个组合是不能重复的。所以本题中的去重可以理解为：在同一树层间去重。【对同一树层去重的话，先要对数组中的元素进行排序】</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/26/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/26/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">约瑟夫环问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-26 17:13:36" itemprop="dateCreated datePublished" datetime="2021-08-26T17:13:36+08:00">2021-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-24 18:47:10" itemprop="dateModified" datetime="2021-09-24T18:47:10+08:00">2021-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>  约瑟夫环问题</p>
</blockquote>
<blockquote>
<p>  <strong>LeetCode地址</strong></p>
</blockquote>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></li>
</ul>
<h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><blockquote>
<p>  <strong>分析</strong></p>
</blockquote>
<ol>
<li> 模拟：建立一个数组，里面存放的就是每个人的编号，一步一步模拟出队的过程，当出队了 n-1 次之后，数组中最后剩下的数字就是要求得的数字。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数组长度都设置为0，表示对应编号的人没有出局</span><br><span class="line">int n， int m	// 表示总共有n 人，数到m时出局</span><br><span class="line">int count	计数器</span><br><span class="line">int i = 0; 表示当前报数开始的编号（初始为0）</span><br><span class="line"></span><br><span class="line">// 只有当出局的人数小于 n 时循环才有必要继续</span><br><span class="line">while(count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="循环链表实现"><a href="#循环链表实现" class="headerlink" title="循环链表实现"></a>循环链表实现</h2><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
