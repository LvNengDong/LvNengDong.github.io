<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/22/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/22/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/22/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/28/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/28/Linux/" class="post-title-link" itemprop="url">Linux</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-28 11:46:51" itemprop="dateCreated datePublished" datetime="2020-10-28T11:46:51+08:00">2020-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-06 17:54:11" itemprop="dateModified" datetime="2022-06-06T17:54:11+08:00">2022-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<ol>
<li>Linux的远程访问原理</li>
<li>Linux目录结构</li>
<li>Linux命令-文件列表-目录切换-目录的创建和删除</li>
<li>Linux命令-文件查看-文件拷贝,删除</li>
<li>Linux命令-压缩解压缩-文件查找</li>
<li>Linux命令-vim编辑器</li>
<li>Linux命令-定向输出-管道</li>
<li>Linux命令-权限控制</li>
<li>Linux命令-IP修改-域名映射</li>
</ol>
</blockquote>
<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h2><ul>
<li>  内核版本</li>
<li>  发行版本</li>
</ul>
<blockquote>
<p>  什么是 Linux 的“发行版”？</p>
</blockquote>
<p>因为 Linux 是开源（开放源代码）的，因此很多厂商都会根据自己的需求对 Linux 系统进行定制化开发，基于此衍生出了多种 Linux 系统的发行版。</p>
<blockquote>
<p>  目前国内主流的 Linux 发行版系统有哪些？</p>
</blockquote>
<ul>
<li>  RedHat</li>
<li>  Fedora</li>
<li>  CentOS</li>
<li>  Debian</li>
<li>  Ubuntu</li>
</ul>
<h2 id="终端的使用"><a href="#终端的使用" class="headerlink" title="终端的使用"></a>终端的使用</h2><ul>
<li>终端<ul>
<li>  图形终端</li>
<li>  命令行终端</li>
<li>  远程终端（SSH、VNC）</li>
</ul>
</li>
</ul>
<h1 id="Linux的远程访问"><a href="#Linux的远程访问" class="headerlink" title="Linux的远程访问"></a>Linux的远程访问</h1><p><img src="/2020/10/28/Linux/Linux%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE.png"></p>
<ol>
<li>Linux 服务器放在机房，可以被很多人访问。</li>
<li>这些访问大都不是直接访问，而是在个人 PC 上进行远程访问</li>
<li>CRT就是一款用于在个人PC上访问Linux服务器的软件。</li>
<li>在PC端使用CRT命令窗口来操作远程Linux服务器。</li>
</ol>
<h2 id="1-1-CRT初始化界面"><a href="#1-1-CRT初始化界面" class="headerlink" title="1.1    CRT初始化界面"></a>1.1    CRT初始化界面</h2><p><img src="/2020/10/28/Linux/image-20200812232446845.png" alt="image-20200812232446845"></p>
<ol>
<li><code>root</code>表示：以超级管理员身份登录并进行操作。</li>
<li><code>lnd</code>表示：当前登录的主机名称是<code>lnd</code>。</li>
<li><code>~</code>表示：家目录。<ul>
<li>如果是以root管理员身份登录的，那么<code>~</code>就表示<code>/root</code>目录。</li>
<li>如果是以普通用户的身份登录的，那么<code>~</code>就表示<code>/home</code>目录。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="文件和目录结构"><a href="#文件和目录结构" class="headerlink" title="文件和目录结构"></a>文件和目录结构</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/11/20/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/">超链接</a></p>
<hr>
<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p><a href>超链接</a></p>
<hr>
<h1 id="网络配置和系统管理操作"><a href="#网络配置和系统管理操作" class="headerlink" title="网络配置和系统管理操作"></a>网络配置和系统管理操作</h1><p><a href>超链接</a></p>
<hr>
<h1 id="Vi-amp-Vim-编辑器"><a href="#Vi-amp-Vim-编辑器" class="headerlink" title="Vi &amp; Vim 编辑器"></a>Vi &amp; Vim 编辑器</h1><p><a href>超链接</a></p>
<hr>
<h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><p><a href>超链接</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/14/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/14/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">MyBatis面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-10-14 21:51:25 / Modified: 21:53:36" itemprop="dateCreated datePublished" datetime="2020-10-14T21:51:25+08:00">2020-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p><strong><code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>的区别是什么？</strong></p>
<p><code>#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符串替换。</p>
<ul>
<li>Mybatis 在处理<code>#&#123;&#125;</code>时，会将sql中的<code>#&#123;&#125;</code>替换为<code>?</code>号，调用<code>PreparedStatement</code> 的<code>set()</code>方法来赋值；</li>
<li>Mybatis 在处理<code>$&#123;&#125;</code>时，就是直接把<code>$&#123;&#125;</code>替换成变量的值，也就是说有可能在这一步进行SQL注入。</li>
<li>使用<code>#&#123;&#125;</code>可以有效的防止SQL 注入，提高系统安全性。</li>
</ul>
</li>
<li><p><strong>通常一个Xml 映射文件，都会写一个Dao 接口与之对应，请问，这个Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</strong></p>
<p>​    Dao接口的全限定类名，就是映射文件中<code>MappedStatement</code>的<code>namespace</code>的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的<code>id</code>值，接口方法内的参数，就是传递给sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，<code>接口全限名+方法名</code>拼接字符串作为key 值，可唯一定位一个<code>MappedStatement</code>。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到<code>namespace </code>为<code>com.mybatis3.mappers.StudentDao</code> 下面<code>id = findStudentById</code> 的<code>MappedStatement</code>。在Mybatis 中，每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。<br>​    <em>Dao 接口里的方法，是不能重载的，因为每一个<code>全限名+方法名</code>的拼接字符串需要映射一个唯一的<code>MappedStatement</code>。</em><br>​    Dao 接口的工作原理是JDK 动态代理，Mybatis 运行时会使用JDK 动态代理为Dao接口生成代理proxy 对象， 代理对象proxy 会拦截接口方法， 转而执行MappedStatement 所代表的sql，然后将sql 执行结果返回。</p>
</li>
<li><p><strong>Mybatis 是如何进行分页的？分页插件的原理是什么？</strong></p>
<p>​    Mybatis 使用<code>RowBounds</code> 对象进行分页，它是针对<code>ResultSet</code> 结果集执行的内存分页，而非物理分页，可以在sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。分页插件的基本原理是使用Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect 方言，添加对应的物理分<br>页语句和物理分页参数。</p>
</li>
<li><p><strong>Mybatis 是如何将sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</strong></p>
<ul>
<li><p>在Java中完成：</p>
<ol>
<li>使用<code>&lt;resultType&gt;</code>标签，前提是JavaBean类中的属性和数据库中表的列名一致。</li>
<li>使用<code>&lt;resultMap&gt;</code>标签，逐一定义数据库中表的列名和JavaBean类中的属性名之间的映射关系。</li>
</ol>
</li>
<li><p>在数据库中完成：</p>
<p>​    使用SQL的别名功能，将列名的别名改为为JavaBean对象的属性名，比如在数据库中设置<code>T_NAME AS NAME</code>，JavaBean对象属性名一般是<code>name</code>，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名。</p>
</li>
</ul>
<p>​    有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
</li>
<li><p><strong>Xml 映射文件中，除了常见的<code>select|insert|update|delete</code>标签之外，还有哪些标签？</strong></p>
<p>​    还有很多其他的标签， 加上动态sql 的9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等。</p>
</li>
<li><p><strong>简述Mybatis 的插件运行原理，以及如何编写一个插件？</strong></p>
<p>​    Mybatis 仅可以编写针对<code>ParameterHandler 、ResultSetHandler 、StatementHandler、Executor</code> 这4 种接口的插件，Mybatis 使用JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4 种接口对象<br>的方法时，就会进入拦截方法，具体就是<code>InvocationHandler</code> 的<code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis 的<code>Interceptor接口</code>并复写<code>intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</p>
</li>
<li><p><strong>一级、二级缓存</strong></p>
<ul>
<li>一级缓存: 基于PerpetualCache 的HashMap 本地缓存， 其存储作用域为Session，当Session flush 或close 之后，该Session 中的所有Cache 就将清空。</li>
<li>二级缓存与一级缓存其机制相同，默认也是采用<code>PerpetualCache</code>，HashMap 存储， 不同在于其存储作用域为Mapper(Namespace)， 并且可自定义存储源， 如Ehcache。要开启二级缓存，你需要在你的SQL 映射文件中添加一行：<code>&lt;cache/&gt;</code>。</li>
<li>对于缓存数据更新机制， 当某一个作用域( 一级缓存Session/ 二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有select 中的缓存将被clear。</li>
</ul>
</li>
<li><p><strong>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</strong></p>
<p>​    Mybatis 仅支持<code>association</code>关联对象和<code>collection</code>关联集合对象的延迟加载，<code>association</code> 指的就是一对一，<code>collection</code> 指的就是一对多查询。在Mybatis 配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true|false</code>。<br>​    它的原理是，使用CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B 对象的sql，把B 查询上来，然后调<br>用a.setB(b)，于是a 的对象b 属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
</li>
<li><p><strong>Mybatis 映射文件中，如果A 标签通过<code>include</code>引用了B 标签的内容，请问，B 标签能否定义在A 标签的后面，还是说必须定义在A 标签的前面？</strong></p>
<p>​    虽然Mybatis 解析Xml 映射文件是按照顺序解析的，但是，被引用的B 标签依然<strong>可以定义在任何地方</strong>，Mybatis 都可以正确识别。<br>​    原理是，Mybatis 解析A 标签，发现A 标签引用了B 标签，但是B 标签尚未解析到，尚不存在，此时，Mybatis 会将A 标签标记为未解析状态，然后继续解析余下的标签（包含B 标签），待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
</li>
<li><p><strong>简述Mybatis 的Xml 映射文件和Mybatis 内部数据结构之间的映射关系？</strong></p>
<p>​    Mybatis 将所有Xml 配置信息都封装到All-In-One 重量级对象Configuration 内部。在Xml 映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为ParameterMap 对象，其每个子元素会被解析为ParameterMapping 对象。<code>&lt;resultMap&gt;</code>标签会被解析<code>ResultMap</code> 对象，其每个子元素会被解析为ResultMapping 对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为MappedStatement 对象，标签内的sql 会被解析为BoundSql 对象。</p>
</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/13/IO%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">IO流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-13 09:45:28" itemprop="dateCreated datePublished" datetime="2020-10-13T09:45:28+08:00">2020-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-22 13:12:27" itemprop="dateModified" datetime="2022-06-22T13:12:27+08:00">2022-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1 是什么"></a>1 是什么</h2><ul>
<li><code>java.io.File</code></li>
<li><strong>File 类的每个实例对象，代表一个文件或一个目录。</strong></li>
<li>File 类中涉及到的关于文件或目录的创建、删除、重命名、修改时间、文件大小等方法，<strong>并未涉及到写入或读取文件内容的操作</strong>。如果需要读取或写入文件内容，必须使用IO流来完成。【总之就是文件和文件夹的除了读写之外的其它相关方法】</li>
<li>File 类的对象常会作为参数传递到流的构造器中，指明读取或写入的”目的地”。</li>
<li>我们能利用 File 类实现的操作跟我们平时使用可视化界面操作文件/文件夹的操作大致上是相同的，只不过是使用代码实现而已。所以可以理解为：<strong>File 类就是利用代码操作文件/文件夹</strong>。</li>
</ul>
<blockquote>
<p>  <strong>类结构</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span> </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Comparable&lt;File&gt;	<span class="comment">// 可序列化；可比较</span></span><br></pre></td></tr></table></figure>





<h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2 构造方法"></a>2 构造方法</h2><blockquote>
<p>  <strong>常用构造方法</strong></p>
</blockquote>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507091527611-1627738403443.png" alt="image-20210507091527611"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>File(File parent, String child)</code></td>
<td align="left">根据 parent 抽象路径名和 child 路径名字符串创建一个新 <code>File</code> 实例。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>File(String parent, String child)</code></td>
<td align="left">根据 parent 路径名字符串和 child 路径名字符串创建一个新 <code>File</code> 实例</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>File(String pathname)</code></td>
<td align="left">通过将给定路径名字符串转换为抽象路径名来创建一个新 <code>File</code> 实例。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>File(URL uri)</code></td>
<td align="left">通过将给定的 <code>file: URI</code> 转换为一个抽象路径名来创建一个新的 <code>File</code> 实例</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname2</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, child);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>File 类没有无参构造方法(因为有重载的构造方法，JVM 就不再提供无参构造器了)。也就是说<strong>创建 File 实例必须指定文件/目录要保存的位置</strong>。</li>
<li>File 实例可以是一个文件或一个目录。</li>
<li><strong>创建File实例并不等价于创建了文件/目录。</strong> 创建 File 实例只是在内存中开辟了一块空间保存这个实例对象，并不会在硬盘上创建一个真实的文件或文件夹，只有进一步调用这个实例对象的 <code>mkdir()</code>、<code>mkdirs()</code> 或 <code>createNewFile()</code> 方法时才会在硬盘上创建出真正的文件/目录。</li>
</ul>
<blockquote>
<p>  <strong>路径：</strong></p>
</blockquote>
<ul>
<li>  相对路径：相较于某个路径下的路径。</li>
<li>  绝对路径：包含盘符在内的文件或文件目录的路径。</li>
</ul>
<p><strong>说明：</strong></p>
<p>在 IDEA中：</p>
<ul>
<li>  如果使用 JUnit 中的单元测试方法测试，相对路径即为当前 Module 下。</li>
<li>  如果使用 main() 测试，相对路径即为当前的Project下。</li>
</ul>
<p><strong>路径分隔符：</strong></p>
<ul>
<li>  Windows 和 DOS 系统默认使用 <code>\</code> 来表示；</li>
<li>  UNIX 和 URL 使用 <code>/</code> 来表示。</li>
</ul>
<h2 id="3-常用成员方法"><a href="#3-常用成员方法" class="headerlink" title="3 常用成员方法"></a>3 常用成员方法</h2><blockquote>
<p>  <strong>获取功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>getAbsolutePath()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取绝对路径</td>
</tr>
<tr>
<td align="left"><code>getPath()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取路径（获取的路径与创建File对象时传入的路径一致，即创建时传入相对路径此时就获取相对路径）</td>
</tr>
<tr>
<td align="left"><code>getName()</code></td>
<td align="left"><code>String</code></td>
<td align="left">返回此文件或目录名称</td>
</tr>
<tr>
<td align="left"><code>length()</code></td>
<td align="left"><code>long</code></td>
<td align="left">获取文件的长度(字节)；<strong>不能获取目录的长度</strong></td>
</tr>
<tr>
<td align="left"><code>getParent()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取上层目录，若无则返回null。</td>
</tr>
<tr>
<td align="left"><code>lastModified()</code></td>
<td align="left"><code>long</code></td>
<td align="left">获取最后一次修改时间（毫秒值）</td>
</tr>
<tr>
<td align="left"><strong>目录的遍历</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>list()</code></td>
<td align="left"><code>String[]</code></td>
<td align="left">获取指定目录下的所有文件或目录的<strong>名称数组</strong></td>
</tr>
<tr>
<td align="left"><code>listFiles()</code></td>
<td align="left"><code>File[]</code></td>
<td align="left">获取指定目录下的所有文件或目录的<strong>File数组</strong></td>
</tr>
</tbody></table>
<ul>
<li>调用<code>list</code>或<code>listFiles</code>方法遍历File对象，此时File对象必须是<strong>目录</strong>，且<strong>真实存在</strong>，否则会返回空指针异常，无法进行遍历。</li>
</ul>
<blockquote>
<p>  <strong>判断功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exists()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否存在</td>
</tr>
<tr>
<td align="center"><code>isDirectory()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否为目录。</td>
</tr>
<tr>
<td align="center"><code>isFile()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否为文件</td>
</tr>
<tr>
<td align="center"><code>canRead()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否可读</td>
</tr>
<tr>
<td align="center"><code>canWrite</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否可写</td>
</tr>
<tr>
<td align="center"><code>isHidden</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否隐藏</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>创建功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>createNewFile()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">当文件不存在时创建<strong>文件</strong>。</td>
</tr>
<tr>
<td align="center"><code>mkdir()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">创建<strong>目录</strong>。如果目录存在，不创建；如果上层目录不存在也不创建。</td>
</tr>
<tr>
<td align="center"><code>mkdirs()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">创建目录，包括任何必需但不存在的父目录。</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>注意</strong>：如果你创建的目录或文件没有写盘符路径，那么默认在项目路径下。</li>
</ul>
<blockquote>
<p><strong>mkdir()</strong> 、<strong>mkdirs()</strong> 和 <strong>createNewFile()</strong> 的区别</p>
</blockquote>
<ul>
<li><code>mkdir() / mkdirs()</code> 方法用于创建目录，<code>createNewFile()</code> 方法用于创建文件。</li>
<li>也就是说，在使用<code>mkdir() / mkdirs()</code> 方法时，即使开发人员指定名称为 <code>aaa.txt</code> ，它也不会创建出一个 <code>aaa.txt</code> 文件，而只是会创建出一个名为 <code>aaa.txt</code> 的目录。</li>
<li><code>mkdirs()</code> 方法可用于一次性创建多级目录，而 <code>mkdir()</code> 方法每次只能创建单层目录。</li>
<li>比如，要求的创建一个文件，这个文件保存在一个多层目录下，且这个多层目录中间的部分目录不存在，则创建文件和目录的方法都不会执行成功。不同的是 <strong><code>mkdir()</code> 方法即使执行不成功也不会报错，而 <code>createNewFile()</code> 方法会直接报错</strong>。报错信息如下：</li>
</ul>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507094900445.png"></p>
<blockquote>
<p>  <strong>删除功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>delete()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">删除文件或目录。删除时目录必须为空才能被删除</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>注意：</strong>Java 中的删除不走回收站。</li>
</ul>
<blockquote>
<p>  <strong>重命名功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>renameTo(File dest)</code></td>
<td align="center"><code>boolea</code></td>
<td align="center">文件重命名</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4 代码演示"></a>4 代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*  构造方法1   */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA&quot;</span>);</span><br><span class="line">        <span class="comment">/*  构造方法2   */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file01, <span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        <span class="comment">/*  构造方法3   */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多级目录</span></span><br><span class="line">        file02.mkdirs();</span><br><span class="line">        <span class="comment">// 创建文件（创建文件前必须先创建好文件保存的目录）</span></span><br><span class="line">        file03.createNewFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  1、获取 文件/目录 的绝对路径 */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">absoluteFile</span> <span class="operator">=</span> file03.getAbsoluteFile();</span><br><span class="line">        System.out.println(absoluteFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2、获取 文件/目录 的路径</span></span><br><span class="line"><span class="comment">        （如果创建File对象时使用的是相对路径就得到相对路径，使用的是的绝对路径就得到绝对路径） */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> file03.getPath();</span><br><span class="line">        System.out.println(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  3、获取 文件名/目录名    */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file03.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  4、获取 文件/目录 的字节长度（目录的长度为0）*/</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> file03.length();</span><br><span class="line">        System.out.println(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  5、返回该file对象目录中的所有子文件或目录的 String[] 格式 */</span></span><br><span class="line">        String[] list = file01.list();</span><br><span class="line">        Arrays.toString(list)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  6、返回该file对象目录中的所有子文件或目录的 File[] 格式  */</span></span><br><span class="line">        File[] listFiles = file01.listFiles();</span><br><span class="line">        System.out.println(listFiles);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  返回结果：</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *      G:\AAA\BBB\1.txt</span></span><br><span class="line"><span class="comment">     *      G:\AAA\BBB\1.txt</span></span><br><span class="line"><span class="comment">     *      1.txt</span></span><br><span class="line"><span class="comment">     *      0</span></span><br><span class="line"><span class="comment">     *      BBB</span></span><br><span class="line"><span class="comment">     *      [Ljava.io.File;@4c3e4790</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Path类（JDK7-）"><a href="#Path类（JDK7-）" class="headerlink" title="Path类（JDK7+）"></a>Path类（JDK7+）</h1><blockquote>
<p><strong>Path 的说明：</strong></p>
</blockquote>
<p>Path 用于替换原来的 File 类。所以说在大多数情况下，Path 和 File 的用法都是非常相似的。</p>
<blockquote>
<p><strong>如何实例化：</strong></p>
</blockquote>
<p>通过 Path 的工具类 Paths 提供的静态 get() 方法来获取 Path 实例对象。[工厂模式]</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static Path get(String first, String... more)</code></td>
<td>将多个字符串连接成文件路径</td>
</tr>
<tr>
<td><code>public static Path get(URI uri)</code></td>
<td>返回uri对应的path路径</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>常用方法：</strong></p>
</blockquote>
<p><img src="file://E:/blog/source/_posts/IO%E7%B3%BB%E7%BB%9F/image-20220622124503038.png?lastModify=1655874635" alt="image-20220622124503038"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean startsWith(String other);</code></td>
<td>判断是否以 other 路径开始</td>
</tr>
<tr>
<td><code>boolean endsWith(Path other);</code></td>
<td>判断是否以 other 路径结束</td>
</tr>
<tr>
<td><code>boolean isAbsolute();</code></td>
<td>判断是否是绝对路径</td>
</tr>
<tr>
<td><code>Path getParent();</code></td>
<td>返回的Path对象包含整个路径，但不包含Path对象指定的文件路径</td>
</tr>
<tr>
<td><code>Path getRoot();</code></td>
<td>返回调用对象的路径</td>
</tr>
<tr>
<td><code>Path getFileName();</code></td>
<td>返回与调用对象关联的文件名</td>
</tr>
<tr>
<td><code>int getNameCount();</code></td>
<td>返回Path根目录后面的元素数量(文件和文件夹的个数)</td>
</tr>
<tr>
<td><code>Path getName(int index);</code></td>
<td>返回指定索引位置index的路径名称</td>
</tr>
<tr>
<td><code>Path toAbsolutePath();</code></td>
<td>返回调用对象的绝对路径。</td>
</tr>
<tr>
<td><code>Path resolve(Path other);</code></td>
<td>合并两个路径，返回合并后的路径对应的Path对象</td>
</tr>
<tr>
<td><code>File toFile();</code></td>
<td>把Path对象转为File对象</td>
</tr>
</tbody></table>
<hr>
<h1 id="Files工具类（JDK7-）"><a href="#Files工具类（JDK7-）" class="headerlink" title="Files工具类（JDK7+）"></a>Files工具类（JDK7+）</h1><blockquote>
<p><strong>作用：</strong></p>
</blockquote>
<ul>
<li>操作文件或文件目录的工具类</li>
</ul>
<blockquote>
<p><strong>常用方法：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Path copy(Path source, Path target, CopyOption... options)</code></td>
<td>文件的复制</td>
</tr>
<tr>
<td><code>Path createDirectory(Path dir, FileAttribute&lt;?&gt;... attrs)</code></td>
<td>创建单级目录</td>
</tr>
<tr>
<td><code>Path createDirectories(Path dir, FileAttribute&lt;?&gt;... attrs)</code></td>
<td>创建多级目录</td>
</tr>
<tr>
<td><code>Path createFile(Path path, FileAttribute&lt;?&gt;... attrs)</code></td>
<td>创建一个文件</td>
</tr>
<tr>
<td><code>void delete(Path path)</code></td>
<td>删除一个文件/目录</td>
</tr>
<tr>
<td><code>deleteIfExists(Path path)</code></td>
<td></td>
</tr>
<tr>
<td><code>Path move(Path source, Path target, CopyOption... options)</code></td>
<td>移动文件/目录</td>
</tr>
<tr>
<td><code>long size(Path path)</code></td>
<td>返回path指定文件的大小</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>用于判断的方法</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean exists(Path path, LinkOption... options)</code></td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td><code>boolean isDirectory(Path path, LinkOption... options)</code></td>
<td>判断是否为目录</td>
</tr>
<tr>
<td><code>boolean isRegularFile(Path path, LinkOption... options)</code></td>
<td>判断是否为文件</td>
</tr>
<tr>
<td><code>boolean isHidden(Path path)</code></td>
<td>判断是否为隐藏文件</td>
</tr>
<tr>
<td><code>boolean isReadable(Path path)</code></td>
<td>判断文件是否可读</td>
</tr>
<tr>
<td><code>boolean isWritable(Path path)</code></td>
<td>判断文件是否可写</td>
</tr>
<tr>
<td><code>boolean notExists(Path path, LinkOption... options)</code></td>
<td>判断文件是否不存在</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>用于操作内容的方法</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SeekableByteChannel newByteChannel(Path path, OpenOption... options)</code></td>
<td>获取与指定文件的Channel通道，options指定打开方式</td>
</tr>
<tr>
<td><code>DirectoryStream&lt;Path&gt; newDirectoryStream(Path dir)</code></td>
<td>打开dir指定的目录</td>
</tr>
<tr>
<td><code>InputStream newInputStream(Path path, OpenOption... options)</code></td>
<td>获取InputStream对象</td>
</tr>
<tr>
<td><code>OutputStream newOutputStream(Path path, OpenOption... options)</code></td>
<td>获取OutputStream对象</td>
</tr>
</tbody></table>
<hr>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1. 是什么？"></a>1. 是什么？</h2><ul>
<li><strong>IO 流就是数据的流动。</strong></li>
<li>我们把数据的传输，看做是一种数据的流动，按照流动的方向，以<strong>内存为基准</strong>，可分为输入流和输出流。即流向内存为输入流，流出内存为输出流。</li>
<li>输入也叫做<strong>读取数据</strong>，输出也叫做<strong>写出数据</strong>。</li>
</ul>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/IO.png" alt="IO"></p>
<h2 id="2-IO的分类"><a href="#2-IO的分类" class="headerlink" title="2. IO的分类"></a>2. IO的分类</h2><ol>
<li> 按数据流向分类：<strong>输入流</strong>、<strong>输出流</strong></li>
<li> 按操作数据的单位分类：<strong>字节流</strong>、<strong>字符流</strong></li>
</ol>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/IO%E5%88%86%E7%B1%BB.png"></p>
<hr>
<h2 id="3-流的体系结构"><a href="#3-流的体系结构" class="headerlink" title="3. 流的体系结构"></a>3. 流的体系结构</h2><blockquote>
<p>  <strong>顶级父类</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center"><code>InputStream</code></td>
<td align="center"><code>OutputStream</code></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center"><code>Reader</code></td>
<td align="center"><code>Writer</code></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>体系结构</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td><strong>抽象基类</strong></td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td><strong>访问文件</strong></td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td><strong>缓冲流</strong></td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td><strong>访问数组</strong></td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td><strong>访问管道</strong></td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td><strong>访问字符串</strong></td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td><strong>转换流</strong></td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td><strong>对象流</strong></td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>打印流</strong></td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td><strong>推回输入流</strong></td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td><strong>特殊流</strong></td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>常用结构</strong></p>
<ul>
<li>顶级父类：<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code></li>
<li>文件流：<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>、<code>FileWriter</code></li>
<li>缓冲流：<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code></li>
<li>转换流：InputStreamReader  OutputStreamWriter</li>
<li>对象流：ObjectInputStream  ObjectOutputStream</li>
</ul>
<hr>
<h2 id="4-输入-输出的标准化过程"><a href="#4-输入-输出的标准化过程" class="headerlink" title="4. 输入/输出的标准化过程"></a>4. 输入/输出的标准化过程</h2><h3 id="输入过程"><a href="#输入过程" class="headerlink" title="输入过程"></a>输入过程</h3><ol>
<li><p> 创建 File 类对象，指明读取的数据的来源（要求此文件一定要存在）；</p>
</li>
<li><p> 创建相应的输入流，将 File 类的对象作为参数，传入流的构造器中</p>
</li>
<li><p> 具体的读入过程；</p>
</li>
<li><p> 关闭流资源。</p>
</li>
</ol>
<p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理。</p>
<h3 id="输出过程"><a href="#输出过程" class="headerlink" title="输出过程"></a>输出过程</h3><ol>
<li><p> 创建 File 类对象，指明写出的数据的位置（不要求此文件一定要存在，如不存在在写出前会自动创建）；</p>
</li>
<li><p> 创建相应的输出流，将 File 类的对象作为参数传入流的构造器中；</p>
</li>
<li><p> 具体的写出过程；</p>
</li>
<li><p> 关闭流资源。</p>
</li>
</ol>
<p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>  <strong>流的关闭原则：</strong></p>
</blockquote>
<ul>
<li>  <strong>先开后关，后开先关。</strong></li>
<li>  <strong>先关闭外层的流，再关闭内层的流。</strong></li>
<li>  说明：关闭外层流的同时，内层流也会自动的进行关闭。</li>
</ul>
<hr>
<h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="1-一切皆为字节流"><a href="#1-一切皆为字节流" class="headerlink" title="1. 一切皆为字节流"></a>1. 一切皆为字节流</h2><ul>
<li>  所有文件（文本、图片、视频等）底层都是以二进制形式保存在计算机中的，可以看做一个个的字节，传输时同样如此。</li>
<li>  所以，字节流可以传输任意文件数据。    </li>
<li>  在操作流时，我们要时刻明确，无论使用什么样的流对象，底层传输的始终是二进制数据。</li>
</ul>
<h2 id="2-OutputStream"><a href="#2-OutputStream" class="headerlink" title="2. OutputStream"></a>2. OutputStream</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul>
<li><code>java.io.OutputStream</code>是<strong>抽象类</strong>，表示所有字节输出流类的超类。</li>
<li> 作用：将指定的字节信息写出到目的地。</li>
<li> 类中声明了所有字节输出流子类要实现的公共方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.io.OutputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	OutputStream  	*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	FileOutputStream	*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><ul>
<li>OutputStream 是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>OutputStream 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="2-3-成员方法"><a href="#2-3-成员方法" class="headerlink" title="2.3 成员方法"></a>2.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507104001127.png" alt="image-20210507104001127"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="left">关闭输出流，释放系统资源。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>flush()</code></td>
<td align="center"><code>void</code></td>
<td align="left">刷新此输出流并强制任何缓冲的输出字节流被写出。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>write(byte[] b)</code></td>
<td align="center"><code>void</code></td>
<td align="left">将字节数组b的内容写出到指定的文件中</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>write(byte[] b, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">将字节数组b中的指定内容写出到指定的文件中</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>write()[abstract]</code></td>
<td align="center"><code>void</code></td>
<td align="left">将该字节输出流写出到目的地。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：当完成流的操作时，必须调用<code>close()</code>方法，释放系统资源。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	源码中的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    write(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">               ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">        write(b[off + i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-InputStream"><a href="#3-InputStream" class="headerlink" title="3. InputStream"></a>3. InputStream</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.io.InputStream</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>java.io.InputStream</code>是抽象类，是所有字节输入流的类的超类。</li>
<li>作用：读取字节信息到内存中。</li>
<li>类中声明了所有字节输入流子类要实现的公共方法。</li>
<li>当完成了流的操作时，必须调用<code>close()</code>方法，释放系统资源。</li>
</ul>
<h3 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h3><ul>
<li>InputStream 是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>InputStream 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="3-3-成员方法"><a href="#3-3-成员方法" class="headerlink" title="3.3 成员方法"></a>3.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507135331635.png" alt="image-20210507135331635"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="left">关闭流，释放相关资源</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>read()[abstract]</code></td>
<td align="center"><code>int</code></td>
<td align="left">从输入流中读取数据的下一个字节</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>read(byte[] b)</code></td>
<td align="center"><code>int</code></td>
<td align="left">从输入流中读取一些字节数，并把它们存储到字节数组b中</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>read(byte b[], int off, int len)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h2 id="1-Reader"><a href="#1-Reader" class="headerlink" title="1. Reader"></a>1. Reader</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Readable</span>, Closeable</span><br></pre></td></tr></table></figure>

<ol>
<li> <code>java.io.Reader</code>是抽象类，是所有字符输入流类的超类。可以读取字符信息到内存中。</li>
<li> 类中定义了所有字符输入流子类要实现的公共方法。</li>
<li> <strong>字符流只能操作文本文件，不能操作图片、视频等非文本文件。</strong></li>
</ol>
<blockquote>
<p>  <strong>字节流操作文本文件可能存在的问题及解决方案：</strong></p>
</blockquote>
<p>当使用字节流读取文本文件时，在遇到中文字符时，可能不会显示完整的字符。因为一个中文字符根据不同的编码规则可能占 2~3 个字节不等，而字节流读取是以单个字节为单位的，会出现一种情况就是：一个中文字符占了 3 个字节，使用字节流读取时会把这 3 个字节分开来展示，这样就会出现乱码。</p>
<p>所以 Java 提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h3 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><ul>
<li>Reader 是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>Reader 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="1-3-成员方法"><a href="#1-3-成员方法" class="headerlink" title="1.3 成员方法"></a>1.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141214703.png" alt="image-20210507141214703"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>read()</code></td>
<td align="center"><code>int</code></td>
<td align="center">从输入流中读取一个<strong>字符</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>read(char[] cbuf)</code></td>
<td align="center"><code>int</code></td>
<td align="center">从输入流中读取一些字符，并将它们存储到字符数组<code>cbuf</code>中。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-Writer"><a href="#2-Writer" class="headerlink" title="2. Writer"></a>2. Writer</h2><h3 id="2-1-概述-1"><a href="#2-1-概述-1" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Writer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable, Flushable</span><br></pre></td></tr></table></figure>

<ol>
<li> <code>java.io.Writer</code>是抽象类，是所有写出字符流类的超类。负责将指定的字符信息写出到目的地。</li>
<li> 类中定义了所有字符输出流子类要实现的公共方法。</li>
</ol>
<h3 id="2-2-构造方法-1"><a href="#2-2-构造方法-1" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><ul>
<li>  Writer 类是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>  Writer 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="2-3-成员方法-1"><a href="#2-3-成员方法-1" class="headerlink" title="2.3 成员方法"></a>2.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141914198.png" alt="image-20210507141914198"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>write(int c)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入单个字符</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>write(char[] cbuf)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符数组</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>write(char[] cbuf, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符数组的某一部分</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>write(String str)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符串</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>write(String str, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符串的某一部分</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><code>flush()</code></td>
<td align="center"><code>void</code></td>
<td align="left">刷新该流的缓冲</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="left">关闭此流，关闭前先刷新一次</td>
</tr>
</tbody></table>
<hr>
<h1 id="文件流-FileStream"><a href="#文件流-FileStream" class="headerlink" title="文件流(FileStream)"></a>文件流(FileStream)</h1><blockquote>
<p><strong>总纲：</strong></p>
<ul>
<li>凡是数据传输，必然涉及到两个端点（一个出发点 <code>src</code>，一个目的地 <code>dest</code>），一个管道（用于传输数据）。</li>
<li>File 是出发点/目的地，流(Stream) 是管道。</li>
</ul>
</blockquote>
<h2 id="1-FileOutputStream"><a href="#1-FileOutputStream" class="headerlink" title="1. FileOutputStream"></a>1. FileOutputStream</h2><h3 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><blockquote>
<p>  <strong>作用：</strong></p>
</blockquote>
<p><code>FileOutputStream</code> 是文件输出流类，用于<strong>将内存中的数据写出到磁盘中的文件上</strong>。</p>
<blockquote>
<p>  <strong>体系结构：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="1-2-构造方法-1"><a href="#1-2-构造方法-1" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507113455730.png" alt="image-20210507113455730"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>FileOutputStream(File file)</code></td>
<td align="left">创建文件输出流对象，并指定写出到哪个文件中。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>FileOutputStream(String name)</code></td>
<td align="left">创建文件输出流对象，并指定写出到哪个文件中。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>FileOutputStream(File file, boolean append)</code></td>
<td align="left">数据是否可追加续写</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>FileOutputStream(String name, boolean append)</code></td>
<td align="left">数据是否可追加续写</td>
</tr>
</tbody></table>
<p><strong>总结：</strong>在创建字节输出流对象 <code>FileOutputStream</code> 时，必须指定该流对象写出数据的目的地（可以是一个 File 对象，也可以是一个 String 类型的路径）。 <strong>在该路径下，如果没有这个文件，会自动创建该文件</strong>。</p>
<hr>
<h3 id="1-3-成员方法-1"><a href="#1-3-成员方法-1" class="headerlink" title="1.3 成员方法"></a>1.3 成员方法</h3><p><strong>作用：</strong>将字节数据写出到磁盘的文件上</p>
<ul>
<li>  根据编码表把待输出的数据转换成字节数据，再使用<code>write()</code>方法写出到指定文件中。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>write(int b)</code></td>
<td align="center"><code>void</code></td>
<td align="left">通过编码表将<code>int</code>类型的数据转换为字节数据<br>并写出到指定文件中，每次写出一个字节数据。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>write(byte[] b)</code></td>
<td align="center"><code>void</code></td>
<td align="left">将整个<code>byte</code>数组中的字节数据写出到指定文件中。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>write(byte[] b, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写出<code>byte</code>数组中指定范围的子数组</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*  1、创建一个 File 对象，当做字节输出流写出数据的目的地  */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        file.createNewFile(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2、创建字节输出流对象，并指定输出的目的地 */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        fos.write(<span class="number">97</span>);	<span class="comment">// 十进制的整型数据会被转换为byte类型数据写出到指定文件中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  3、关闭字节输出流对象 */</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  输出结果为：</li>
</ul>
<img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507134152996.png" alt="image-20210507134152996">



<blockquote>
<p>  <strong>写出换行</strong></p>
</blockquote>
<ul>
<li>Windows 中，换行符号是 <code>/r/n</code>；<ul>
<li>  分析：<code>/r</code> 是回车符，回到一行的开头（<strong>return</strong>）；<code>/n</code> 是换行符，进入下一行（<strong>newline</strong>）</li>
</ul>
</li>
<li>  Unix 中，换行符是 <code>/n</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*  1、创建一个 File 对象，当做字节输出流写出数据的目的地  */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        file.createNewFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2、创建字节输出流对象，并指定输出的目的地 */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        <span class="type">byte</span>[] br = <span class="string">&quot;\r\n&quot;</span>.getBytes();  <span class="comment">// 换行符的byte类型表示</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> aByte : bytes) &#123;</span><br><span class="line">            fos.write(aByte);</span><br><span class="line">            fos.write(br);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  3、关闭字节输出流对象 */</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507134827165.png" alt="image-20210507134827165">







<hr>
<h2 id="2-FileInputStream"><a href="#2-FileInputStream" class="headerlink" title="2. FileInputStream"></a>2. FileInputStream</h2><h3 id="2-1-概述-2"><a href="#2-1-概述-2" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><blockquote>
<p>  <strong>作用：</strong></p>
</blockquote>
<ul>
<li>  FileInputStream 是文件输入流，用于从文件中读取数据写到内存中。</li>
</ul>
<blockquote>
<p>  <strong>体系结构：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-构造方法-2"><a href="#2-2-构造方法-2" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507135646091.png" alt="image-20210507135646091"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>FileInputStream(File file)</code></td>
<td align="left">通过建立与实际文件的连接来创建一个 FileInputStream 对象</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>FileInputStream(String name)</code></td>
<td align="left">通过建立与实际文件的连接来创建一个 FileInputStream 对象</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>  当你<strong>创建 <code>FileInputStream</code> 流对象时，必须传入一个文件路径。</strong></li>
<li>  该路径下，如果没有该文件，会抛出 <code>FileNotFoundException</code> 异常。</li>
</ul>
<h3 id="2-3-成员方法-2"><a href="#2-3-成员方法-2" class="headerlink" title="2.3 成员方法"></a>2.3 成员方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>read()</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次从文件中读取一个字节的数据，并自动提升为<code>int</code>类型，<strong>读取到文件末尾，返回-1</strong></td>
</tr>
<tr>
<td align="left"><code>read(byte[] b)</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次从文件中读取<code>b.length</code>个字节的数据到数组 b 中，并返回读取到的有效字节<strong>个数</strong>，<br><strong>读取到末尾时，返回-1</strong></td>
</tr>
</tbody></table>
<h3 id="2-4-代码演示"><a href="#2-4-代码演示" class="headerlink" title="2.4 代码演示"></a>2.4 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*  1、创建字节输入流对象 */</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2.1、读取文件内容    */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();  <span class="comment">// read() 方法每次只能读取一个字节的数据，读取到文件末尾，返回-1</span></span><br><span class="line">        System.out.println(read);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2.2、读取多个字节数据(一个一个读)    */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (fis.read() != -<span class="number">1</span>)&#123;</span><br><span class="line">            result.add(fis.read());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  3、关闭字节输入流   */</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-练习：图片复制"><a href="#3-练习：图片复制" class="headerlink" title="3. 练习：图片复制"></a>3. 练习：图片复制</h2><blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<ul>
<li>step1：通过 InputStream 流将源图片的字节码数据读到内存中；</li>
<li>setp2：通过 OutputStream 流将内存中的图片数据写到目的文件中。</li>
</ul>
<blockquote>
<p>  <strong>代码实现：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建 File 对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;demo.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;demo_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.建流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);	<span class="comment">// 最后一次读取到的数据长度可能小于5</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="4-FileReader"><a href="#4-FileReader" class="headerlink" title="4. FileReader"></a>4. FileReader</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote>
<p>  <strong>体系结构</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |- java.io.Reader</span><br><span class="line">      |- java.io.InputStreamReader</span><br><span class="line">          |- java.io.FileReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span></span><br></pre></td></tr></table></figure>

<p>创建 FileReader 实例对象时使用系统默认的字符编码和默认字节缓冲区。</p>
<ul>
<li>字符编码：字节与字符的对应规则。Windows 系统的中文编码默认是GBK编码表；IDEA中默认<code>UTF-8</code>。</li>
<li>字节缓冲区：一个字节数组，用来临时存储字节数据。</li>
</ul>
<h3 id="4-2-构造方法"><a href="#4-2-构造方法" class="headerlink" title="4.2 构造方法"></a>4.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141402352.png" alt="image-20210507141402352"></p>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FileReader(File file)</code></td>
</tr>
<tr>
<td align="left"><code>FileReader(String fileName)</code></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>  当你创建一个<code>FileReader</code>流对象时，必须传入一个文件路径。</li>
</ul>
<hr>
<h3 id="4-3-成员方法"><a href="#4-3-成员方法" class="headerlink" title="4.3 成员方法"></a>4.3 成员方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>read()</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次读取<strong>一个字符</strong>的数据，提升为 <code>int</code> 型，读到文件末尾返回-1</td>
</tr>
<tr>
<td align="left"><code>read(char[] cbuf)</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次读取<code>cbuf.length</code>个字符到数组中，返回读取到的字符个数，读取到末尾时返回-1.</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-4-代码演示"><a href="#4-4-代码演示" class="headerlink" title="4.4 代码演示"></a>4.4 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</span></span><br><span class="line"><span class="comment">	2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">	3. 读的文件一定要存在，否则就会报 FileNotFoundException。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.File类的实例化</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.读入的操作</span></span><br><span class="line">        <span class="comment">// read(char[] cbuf)：返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">            <span class="comment">// 错误的写法，最后一次读到的数据可能小于 cbuf.length</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; cbuf.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正确的写法</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                System.out.print(cbuf[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">// 错误的写法,对应着方式一的错误的写法</span></span><br><span class="line"><span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line">            <span class="comment">//正确的写法</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.资源的关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="5-FileWriter"><a href="#5-FileWriter" class="headerlink" title="5. FileWriter"></a>5. FileWriter</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><blockquote>
<p>  <strong>作用</strong></p>
</blockquote>
<p><code>java.io.FileWriter</code> 是从内存中写出字符数据到文件中的类，构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>  <strong>体系结构</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |- java.io.Writer</span><br><span class="line">      |- java.io.OutputStreamWriter  </span><br><span class="line">          |- java.io.FileWriter</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-2-构造方法"><a href="#5-2-构造方法" class="headerlink" title="5.2 构造方法"></a>5.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141942042.png" alt="image-20210507141942042"></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FileWriter(File file)</code></td>
</tr>
<tr>
<td align="left"><code>FileWriter(String fileName)</code></td>
</tr>
<tr>
<td align="left"><code>FileWriter(File file, boolean append)</code></td>
</tr>
<tr>
<td align="left"><code>FileWriter(String fileName, boolean append)</code></td>
</tr>
</tbody></table>
<h3 id="5-3-成员方法"><a href="#5-3-成员方法" class="headerlink" title="5.3 成员方法"></a>5.3 成员方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>写出数据</strong></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>write(int b)</code></td>
<td align="center"></td>
<td align="left">每次写一个字符大小的数据</td>
</tr>
<tr>
<td align="left"><code>write(char[] cbuf)</code></td>
<td align="center"></td>
<td align="left">每次最多可以写出<code>cbuf.length</code>个字符的数据</td>
</tr>
<tr>
<td align="left"><code>write(char[] cbuf, int off, int len)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>write(String str)</code></td>
<td align="center"></td>
<td align="left">底层会先将 String 转换为 char[] 数组，再写出</td>
</tr>
<tr>
<td align="left"><code>write(String str, int off, int len)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>关闭和刷新</strong></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>flush()</code></td>
<td align="center"></td>
<td align="left">将缓冲区中的数据强制刷写到文件中</td>
</tr>
<tr>
<td align="left"><code>close()</code></td>
<td align="center"></td>
<td align="left">先刷新缓冲区，然后通知系统释放资源</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>关闭和刷新</strong></p>
</blockquote>
<p>因为 <strong><code>FileWriter</code>类内置缓冲区</strong>的原因，写出数据时首先会被写出到缓冲区中，如果不进行刷新的话，是无法写入到文件中的。</p>
<ul>
<li><code>flush()</code>：将缓冲区中的数据强制刷写到文件中；</li>
<li><code>close()</code>：先刷新缓冲区，然后通知系统释放资源。</li>
</ul>
<hr>
<h3 id="5-4-代码演示"><a href="#5-4-代码演示" class="headerlink" title="5.4 代码演示"></a>5.4 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从内存中写出数据到硬盘的文件里。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	1. 输出操作，目的地的File可以不存在。并不会报异常</span></span><br><span class="line"><span class="comment">	2. </span></span><br><span class="line"><span class="comment">	File对应的文件如果不存在，FileWriter 在写出数据时，会自动创建此文件。</span></span><br><span class="line"><span class="comment">	File对应的硬盘中的文件如果存在：</span></span><br><span class="line"><span class="comment">		如果输出流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原文件的覆盖</span></span><br><span class="line"><span class="comment">		如果输出流使用的构造器是：FileWriter(file,true):不会对原文件覆盖，而是在原文件基础上追加内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="6-练习：文本文件复制"><a href="#6-练习：文本文件复制" class="headerlink" title="6. 练习：文本文件复制"></a>6. 练习：文本文件复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能使用字符流来处理图片等字节数据</span></span><br><span class="line"><span class="comment">//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span></span><br><span class="line"><span class="comment">//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.数据的读入和写出操作</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 每次写出len个字符</span></span><br><span class="line">            fw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.关闭流资源</span></span><br><span class="line">        <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                if(fw != null)</span></span><br><span class="line"><span class="comment">//                    fw.close();</span></span><br><span class="line"><span class="comment">//            &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;finally&#123;</span></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    if(fr != null)</span></span><br><span class="line"><span class="comment">//                        fr.close();</span></span><br><span class="line"><span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>  对于文本文件(<code>.txt</code>、<code>.java</code>、<code>.c</code>、<code>.cpp</code> 等)，使用字符流处理</li>
<li>  对于非文本文件(<code>.jpg</code> 、<code>.mp3</code>、<code>.mp4</code>、<code>.avi</code>、<code>.doc</code>、<code>.ppt </code>等)，使用字节流处理</li>
</ul>
<hr>
<h1 id="缓冲流-BufferStream"><a href="#缓冲流-BufferStream" class="headerlink" title="缓冲流(BufferStream)"></a>缓冲流(BufferStream)</h1><blockquote>
<p><strong>缓冲流涉及到的类</strong></p>
</blockquote>
<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
<blockquote>
<p><strong>作用</strong></p>
</blockquote>
<ul>
<li>  提高流的读取、写入的速度；</li>
<li>  提高读写速度的<strong>原因</strong>：内部提供了一个缓冲区。默认情况下是 <strong>8kb</strong>。</li>
</ul>
<img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210801152442138.png" alt="image-20210801152442138" style="zoom: 67%;">

<p><strong>Tip：</strong>不光是 BufferedInputStream，包括 BufferedOutputStream、BufferedWriter、BufferedReader 在内的所有缓冲流类的默认缓冲区大小都是 <code>8192 Byte</code>。</p>
<blockquote>
<p><strong>使用 BufferedInputStream 和 BufferedOutputStream 处理非文本文件（字节流）</strong></p>
</blockquote>
<p>需求：实现文件复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.造流</span></span><br><span class="line">        <span class="comment">// 2.1 造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">// 2.2 造缓冲流【缓冲流是对文件流的又一层包装，这里采用了装饰器模式】</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.复制的细节：读取、写入</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">//字节</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.资源关闭</span></span><br><span class="line">        <span class="comment">// 要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span></span><br><span class="line">        <span class="comment">//        fos.close();</span></span><br><span class="line">        <span class="comment">//        fis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用BufferedReader和BufferedWriter 处理文本文件(字符流)</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建文件和相应的流</span></span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读写操作</span></span><br><span class="line">        <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line"><span class="comment">//            char[] cbuf = new char[1024]; //字符</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line"><span class="comment">//    //            bw.flush();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 方法一：</span></span><br><span class="line"><span class="comment">//                bw.write(data + &quot;\n&quot;); // data中不包含换行符</span></span><br><span class="line">            <span class="comment">// 方法二：</span></span><br><span class="line">            bw.write(data);		<span class="comment">// data中不包含换行符</span></span><br><span class="line">            bw.newLine();	<span class="comment">// 提供换行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="转换流-TransferStream"><a href="#转换流-TransferStream" class="headerlink" title="转换流(TransferStream)"></a>转换流(TransferStream)</h1><p>转换流的作用就是提供<strong>字节流与字符流之间的转换功能</strong>。</p>
<blockquote>
<p><strong>转换流涉及到的类：</strong></p>
</blockquote>
<ul>
<li>  OutputStreamWriter</li>
<li>  InputStreamReader</li>
</ul>
<p><strong>这两个转换流都属于字符流！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> </span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>InputStreamReader：</strong></p>
</blockquote>
<ul>
<li>  顾名思义，就是 InputStream To Reader；</li>
<li>  <strong>作用：</strong>将一个字节的输入流转换为字符的输入流</li>
<li>  <strong>解码：</strong><code>字节、字节数组 ---&gt; 字符数组、字符串</code></li>
<li>  字节流是我们不能识别的，字符流是我们很容易识别的。将不认识的转为认识的叫<strong>解码</strong>，将认识的转为不认识的叫<strong>编码</strong>。</li>
</ul>
<blockquote>
<p>  <strong>OutputStreamWriter：</strong></p>
</blockquote>
<ul>
<li>  <strong>作用：</strong>是从字符流到字节流的桥梁，作用是将一个字符的输出流转换为字节的输出流</li>
<li>  <strong>编码：</strong><code>字符数组、字符串 ---&gt; 字节、字节数组</code></li>
</ul>
<blockquote>
<p>  <strong>作用：</strong></p>
</blockquote>
<p>提供字节流与字符流之间的转换。</p>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210801154712518.png" alt="image-20210801154712518"></p>
<blockquote>
<p>  <strong>说明：</strong></p>
</blockquote>
<ul>
<li>  编码方式决定了解码的方式。</li>
<li>  文件编码的方式（比如：GBK），决定了解析时使用的字符集（也只能是GBK）。</li>
</ul>
<blockquote>
<p>  <strong>Demo1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取到内存中的 fis 保存了字节流数据</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用系统默认的字符集（GBK）解码</span></span><br><span class="line"><span class="comment">//        InputStreamReader isr = new InputStreamReader(fis);	</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);	<span class="comment">// 使用指定字符集解码</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        System.out.print(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Demo2</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1.造文件、造流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.读写过程</span></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.关闭资源</span></span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="对象流-ObjectStream"><a href="#对象流-ObjectStream" class="headerlink" title="对象流(ObjectStream)"></a>对象流(ObjectStream)</h1><blockquote>
<p><strong>对象流涉及的类</strong></p>
</blockquote>
<ul>
<li>ObjectInputStream<ul>
<li>  <strong>序列化：</strong>内存中的 Java 对象 <code>--&gt;</code> 磁盘上的文件 / 通过网络传输出去</li>
</ul>
</li>
<li>ObjectOutputStream<ul>
<li>  <strong>反序列化：</strong>磁盘上的文件/通过网络接收的文件 <code>--&gt;</code> 内存中的对象</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>对象的序列化/反序列化机制</strong></p>
</blockquote>
<ul>
<li>  对象序列化机制允许把内存中的 Java 对象转换成平台无关的二进制流，从而把这种二进制流持久地保存在磁盘（文件）上，或通过网络将这种二进制流传输到另一个网络节点。</li>
<li>  当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。【反序列化】</li>
</ul>
<blockquote>
<p><strong>实现序列化的对象需要满足的条件</strong></p>
</blockquote>
<ul>
<li>需要实现接口 Serializable；</li>
<li>当前类提供一个全局常量：serialVersionUID；</li>
<li><strong>除了当前类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。</strong><ul>
<li>默认情况下，基本数据类型都是可序列化的。</li>
<li>如果属性中包含了另外的类，则要求也必须是可序列化的。</li>
</ul>
</li>
</ul>
<p><strong>补充：</strong><code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> <strong>不能序列化 static 和 transient 修饰的成员变量</strong>。</p>
<blockquote>
<p>  <strong>序列化代码实现：</strong></p>
<ul>
<li>将内存中的 Java 对象保存到磁盘中或通过网络传输出去。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出 String 对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出自定义对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王路飞&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;黄猿&quot;</span>, <span class="number">48</span>, <span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>反序列化代码实现：</strong></p>
<ul>
<li>将磁盘文件中的对象还原为内存中的一个Java对象</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="随机存取文件流-RandomAccessFile"><a href="#随机存取文件流-RandomAccessFile" class="headerlink" title="随机存取文件流(RandomAccessFile)"></a>随机存取文件流(RandomAccessFile)</h1><blockquote>
<p>  <strong>随机存取文件流：RandomAccessFile</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFile</span> <span class="keyword">implements</span> <span class="title class_">DataOutput</span>, DataInput, Closeable &#123;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>使用说明：</strong></p>
</blockquote>
<ul>
<li><code>RandomAccessFile</code> 直接继承于 <code>java.lang.Object</code> 类，实现了 <code>DataInput</code> 和 <code>DataOutput</code> 接口；</li>
<li><code>RandomAccessFile</code> <strong>既可以作为一个输入流，又可以作为一个输出流</strong>；<ul>
<li>所以，在大多数情况下，RandomAccessFile 和 InputStream/OutputStream 的用法是类似的。</li>
</ul>
</li>
<li><code>RandomAccessFile</code> 作为输出流时，如果写出到的文件不存在，则在执行过程中自动创建。</li>
<li>如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</li>
<li>可以通过相关的操作，使用 <code>RandomAccessFile</code> 的 API 实现 “<strong>插入</strong>”数据的效果。<code>seek(int pos)</code></li>
</ul>
<blockquote>
<p>  <strong>Demo1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;	</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         </span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf2.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Demo2：使用RandomAccessFile实现数据的插入效果</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);	<span class="comment">// &quot;rw&quot; 是一种模式，表示读写</span></span><br><span class="line"></span><br><span class="line">    raf1.seek(<span class="number">3</span>);	<span class="comment">// 将指针调到角标为3的位置</span></span><br><span class="line">    <span class="comment">// 保存指针3后面的所数据到StringBuilder中</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调回指针，写入“xyz”</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 StringBuilder 中的数据写入到文件中</span></span><br><span class="line">    raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">    raf1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="其它流"><a href="#其它流" class="headerlink" title="其它流"></a>其它流</h1><h2 id="1-标准的输入输出流"><a href="#1-标准的输入输出流" class="headerlink" title="1 标准的输入输出流"></a>1 标准的输入输出流</h2><blockquote>
<p>  <strong>System.in</strong></p>
</blockquote>
<p>标准的输入流，默认从键盘输入（从键盘输入的数据传输到内存中）</p>
<blockquote>
<p>  <strong>System.out</strong></p>
</blockquote>
<p>标准的输出流，默认从控制台输出（内存中的数据输出到控制台上显示）</p>
<blockquote>
<p>  <strong>修改默认的输入和输出行为：</strong></p>
</blockquote>
<p>通过 System 类的 <code>setIn(InputStream is) / setOut(PrintStream ps)</code>方式重新指定输入流和输出流的行为。</p>
<h2 id="2-打印流"><a href="#2-打印流" class="headerlink" title="2 打印流"></a>2 打印流</h2><ul>
<li>  <strong>PrintStream</strong></li>
<li>  <strong>PrintWriter</strong></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>  提供了一系列重载的 <code>print()</code> 和 <code>println()</code> 方法，用于多种数据类型的输出。</li>
<li>  <code>System.out</code> 返回的是 PrintStream 的实例</li>
</ul>
<h2 id="3-数据流"><a href="#3-数据流" class="headerlink" title="3 数据流"></a>3 数据流</h2><ul>
<li>  <strong>DataInputStream</strong></li>
<li>  <strong>DataOutputStream</strong></li>
</ul>
<p><strong>作用：</strong>用于读取或写出基本数据类型的变量或字符串。</p>
<blockquote>
<p>  <strong>Demo1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	练习：将内存中的字符串、基本数据类型的变量写出到(文件)中。</span></span><br><span class="line"><span class="comment">	注意：处理异常的话，仍然应该使用try-catch-finally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    dos.writeUTF(<span class="string">&quot;圣诞树&quot;</span>);</span><br><span class="line">    dos.flush();	<span class="comment">// 刷新操作，将内存中的数据写入文件</span></span><br><span class="line">    dos.writeInt(<span class="number">23</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Demo2</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment">	注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">    System.out.println(<span class="string">&quot;isMale = &quot;</span> + isMale);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.Dictionary&lt;K,V&gt;</span><br><span class="line">    继承者 java.util.Hashtable&lt;Object,Object&gt;		<span class="comment">// !!!</span></span><br><span class="line">    	继承者 java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Properties</code> 类表示一个持久的<strong>属性集</strong>。</li>
<li>它使用<strong>键值对</strong>结构存储数据，每个键及其对应的值都是一个字符串。</li>
<li><strong>总结：</strong>Properties 可以当做一个 HashMap 来使用，只不过其内部定义了一些特有的方法要比 HashMap 操作更丰富。</li>
</ol>
<h2 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2 构造方法"></a>2 构造方法</h2><table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Properties()</code></td>
<td align="left">创建一个空的属性列表</td>
</tr>
<tr>
<td align="left"><code>Properties(Properties default)</code></td>
<td align="left">创建一个带有指定默认值的空属性列表</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">(Properties defaults)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaults = defaults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3 成员方法"></a>3 成员方法</h2><table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>setProperties(String key, String value)</code></td>
<td align="center"><code>Object</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>getProperties(String key)</code></td>
<td align="center"><code>String</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>stringPropertyNames()</code></td>
<td align="center"><code>Set&lt;String&gt;</code></td>
<td align="left">获取所有键的名称的集合</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>load(InputStream inStream)</code></td>
<td align="center"><code>void</code></td>
<td align="left">从字节输入流中获取键值对</td>
</tr>
</tbody></table>
<h3 id="3-1-与流相关的方法"><a href="#3-1-与流相关的方法" class="headerlink" title="3.1 与流相关的方法"></a>3.1 与流相关的方法</h3><blockquote>
<p>  <strong>public void load(InputStream inputStream)</strong></p>
</blockquote>
<ul>
<li>  字节流中的数据都是从外部存储设备读取到内存中的，而 <code>Properties</code> 类又可以读取 <code>InputStream</code> 中的数据，这样 <code>Properties</code> 就可以间接的加载外部存储设备中的文本数据了。</li>
<li>  但是 <strong>Properties 类只能加载文本数据格式为键值对的形式</strong>，常见的有 <code>.properties</code>或<code>.yml</code> 文件。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-10 21:35:12" itemprop="dateCreated datePublished" datetime="2020-10-10T21:35:12+08:00">2020-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-27 21:08:59" itemprop="dateModified" datetime="2021-09-27T21:08:59+08:00">2021-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-程序-amp-线程-amp-进程-amp-并发-amp-并行"><a href="#1-程序-amp-线程-amp-进程-amp-并发-amp-并行" class="headerlink" title="1    程序 &amp; 线程 &amp; 进程 &amp; 并发 &amp; 并行"></a>1    程序 &amp; 线程 &amp; 进程 &amp; 并发 &amp; 并行</h1><h2 id="1-1-进程、线程产生的背景"><a href="#1-1-进程、线程产生的背景" class="headerlink" title="1.1    进程、线程产生的背景"></a>1.1    进程、线程产生的背景</h2><blockquote>
<ol>
<li> <strong>单指令操作系统</strong></li>
</ol>
</blockquote>
<p>最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在输入的时候，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。</p>
<blockquote>
<ol start="2">
<li> <strong>批处理（指令）操作系统</strong></li>
</ol>
</blockquote>
<p>后来有了批处理操作系统，把一系列需要操作的指令写下来，形成一个清单，一次性交给计算机。用户将多条需要执行的指令写在磁带上，然后交由计算机去读取并逐个执行这些指令，并将输出结果写在另一个磁带上。</p>
<p>批处理操作系统由于可一次不间断地执行多条指令，解决了用户输入速度对执行效率的桎梏，在一定程度上提高了计算机的效率，但是由于批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一条指令在运行，后⾯的指令需要等待前面的指令执行完成后才能开始执行，而前面的指令操作可能会由于 I/O 操作、网络等原因阻塞，所以批处理操作效率也不高。</p>
<p><strong>Tip：</strong></p>
<ul>
<li>  I/O 操作（或网络操作）导致阻塞：当执行某一条指令（比如指令A）时，这条指令要求去访问磁盘上的（或网络中的）资源，那么 CPU 就会去获取磁盘（或网络）中的资源，由于只有一个 CPU，当 I/O（或者网络）操作被阻塞时，CPU 就会一直死等从磁盘（或网络）中获取资源完成，所以就不会去执行指令A之后的指令，所以指令A之后的指令就全部被阻塞了。</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>进程的提出</strong></li>
</ol>
</blockquote>
<ul>
<li>  人们对于计算机的性能要求越来越高，而<strong>批处理操作系统的瓶颈在于内存中只能同时运行一个程序</strong>，那么内存中能不能存在多个程序呢？</li>
<li>  于是，科学家们提出了进程的概念。</li>
<li>  <strong>进程就是正在运行着的程序</strong>，多个进程可“同时”运行，各个进程之间互不⼲扰。</li>
<li>  此时，CPU 采用时间片轮转的方式运行进程：CPU 为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并将 CPU 分配给另一个进程（这个过程叫做<strong>上下文切换</strong>）。<strong>如果进程在时间片结束前阻塞或结束，则CPU 立即进行切换，不用等待时间片用完。</strong></li>
<li>  当进程暂停时，它会保存当前进程的状态，在下一次切换回来时根据之前保存的状态进行恢复，接着继续行。</li>
<li>  使用 <code>进程 + CPU时间片</code> 轮转方式的操作系统，在宏观上看起来同一时间段执行多个任务，换句话说，进程让操作系统的并发成为了可能。虽然并发从宏观上看有多个任务在执行，但在事实上，对于单核CPU来说，任意具体时刻都只有一个任务在占用 CPU 资源。</li>
</ul>
<blockquote>
<p>  <strong>程序：</strong></p>
</blockquote>
<p>程序是指用某种编程语言（Java / Python等）编写，能够完成一定任务或者功能的代码集合，是指令和数据的有序集合，是一段静态代码。</p>
<blockquote>
<ol start="4">
<li> <strong>对操作系统的要求进一步提高</strong></li>
</ol>
</blockquote>
<p>虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，<strong>人们并不满足一个进程在一段时间只能做一件事情</strong>，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。</p>
<p>比如杀毒软件在检测用户电脑时，如果在某一项检测中卡住了，那么后面的检测项也无法进行下去。或者说当你使用杀毒软件中的扫描病毒功能时，在扫描病毒结束之前，无法使用杀毒软件中清理垃圾的功能，这显然无法满足人们的要求。</p>
<blockquote>
<ol start="5">
<li> <strong>线程的提出</strong></li>
</ol>
</blockquote>
<p>为了让同一线程的子任务可以同时执行，于是人们⼜提出了线程的概念，让<strong>一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p>
<p>在有了线程之后，当用户使用扫描病毒功能时，就让扫描病毒这个线程去执行。同时，如果用户又想使用清理垃圾功能，那么可以先<br>暂停扫描病毒线程，先响应用户的清理垃圾的操作，让清理垃圾这个线程去执行。响应完后再切换回来，接着执行扫描病毒线程。</p>
<hr>
<h2 id="1-2-进程和线程的区别"><a href="#1-2-进程和线程的区别" class="headerlink" title="1.2    进程和线程的区别"></a>1.2    进程和线程的区别</h2><blockquote>
<ol>
<li> <strong>进程</strong></li>
</ol>
</blockquote>
<ul>
<li>运行中的应用程序，每个进程都有一个独立的内存空间；</li>
<li>系统运行一个程序即是一个进程从创建、运行、到消亡的过程。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>线程</strong></li>
</ol>
</blockquote>
<ul>
<li>线程是进程中的一个执行单元，负责当前线程任务（进程中的子任务）的执行；</li>
<li>一个进程中至少有一个线程；</li>
<li>一个进程中是可以有多个线程的，这样的程序被称为多线程程序。</li>
</ul>
<p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.png"></p>
<p>一个程序从创建到死亡的过程就是一个进程的生命周期，所以说进程就是运行中的程序。</p>
<p>那么线程又是什么呢？在上图的谷歌浏览器中，我们看一看到运行这一进程我们使用了4个线程，这4个线程或者是并行或者是并发运行，可以充分利用计算机的性能。再举一个简单的例子就是IDM下载器，我们使用了多线程下载来提高下载速度，每个线程只负责一部分的下载任务。多线程是可选的，因为我们执行一个进程最少情况下一个线程也能完成，但是为了提高效率、防止阻塞等原因，我们往往使用多线程来完成。</p>
<p>其实，<strong>多线程程序并不能够提高程序的运行速度，但能够提高程序运行效率，让 CPU 的利用率更高，最常见的就是当某个线程发生 IO 或网络操作时切换到其它线程去利用 CPU 而不是让 CPU 处于空闲等待状态</strong>。</p>
<blockquote>
<ol start="3">
<li> <strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></li>
</ol>
</blockquote>
<p>多进程方式确实可以实现并发，在某些场景下也确实是使用多进程来实现并发的，但使用多线程主要有以下几个好处：</p>
<ol>
<li> 进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，如果我们需要使用共享资源，这些资源在线程间的通信比较容易实现。</li>
<li> 进程是重量级的，而线程是轻量级的。故多线程的创建、销毁开销、上下文切换开销要小于多进程。</li>
</ol>
<blockquote>
<ol start="3">
<li> <strong>进程和线程的区别：</strong></li>
</ol>
</blockquote>
<p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。<strong>它们两个本质的区别是是否单独占有内存空间及其它系统资源（比如I/O）</strong>：</p>
<ul>
<li>  单个进程占有独立的内存空间，所以<strong>进程间存在内存隔离</strong>，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程的内存空间和资源，数据共享简单，但是同步复杂。</li>
<li>  由于进程占有独立的内存空间，一个进程出现问题不会影响其他进程，可靠性高；而一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li>
<li>  进程占有单独的内存空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要进行对分配资源的回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li>
<li>  另一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即 CPU 分配时间的单位 。</strong></li>
</ul>
<hr>
<h2 id="1-3-上下文切换"><a href="#1-3-上下文切换" class="headerlink" title="1.3    上下文切换"></a>1.3    上下文切换</h2><blockquote>
<p>  <strong>概念：</strong></p>
</blockquote>
<p><strong>上下文切换是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。</strong>上下文是指某一时间点 CPU 寄存器和程序计数器<br>的内容。</p>
<blockquote>
<p>  寄存器是 CPU 内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。</p>
<p>  <strong>程序计数器是一个专用的寄存器</strong>，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。</p>
<p>  举例说明：线程 A -&gt; B</p>
<ol>
<li> 先挂起线程 A，将其在 CPU 中的状态保存在内存中。（就是保存当前线程A执行到了哪一条指令了）</li>
<li> 在内存中检索下一个线程 B 的上下文并将其在 CPU 的寄存器中恢复，执行 B 线程。</li>
<li> 当 B 执行完，根据程序计数器中指向的位置恢复线程 A。</li>
</ol>
</blockquote>
<p>CPU 通过为每个线程分配时间片来实现多线程机制。CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p>
<p>但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以继续从上次任务断开的地方继续执行这个任务。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换会消耗⼤量的 CPU 时间，故线程也不是越多越好。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ol>
<li><strong>分时调度</strong>：所有线程轮流使用 CPU ，平均分配每个线程占用 CPU 的时间。</li>
<li><strong>抢占式调度</strong>：优先让优先级高的线程使用 CPU。如果线程的优先级相同，那么会随机选择一个使用CPU。</li>
</ol>
<hr>
<h2 id="1-4-并发-amp-并行"><a href="#1-4-并发-amp-并行" class="headerlink" title="1.4    并发 &amp; 并行"></a>1.4    并发 &amp; 并行</h2><blockquote>
<p>  <strong>并发：</strong></p>
</blockquote>
<ul>
<li>  指两个或多个事件在<strong>同一个时间段</strong>内发生。</li>
<li>  一个 CPU（采用时间片）同时执行多个任务。</li>
</ul>
<blockquote>
<p>  <strong>并行</strong></p>
</blockquote>
<ul>
<li>  指两个或多个事件在<strong>同一时刻</strong>发生。（同时发生）</li>
<li>  即多个 CPU 同时执行多个任务。</li>
</ul>
<hr>
<h1 id="2-Java中创建线程的4种方法"><a href="#2-Java中创建线程的4种方法" class="headerlink" title="2    Java中创建线程的4种方法"></a>2    Java中创建线程的4种方法</h1><blockquote>
<ol>
<li> <strong>继承 Thread 类</strong></li>
<li> <strong>实现 Runnable 接口</strong></li>
<li> <strong>实现 Callable 接口</strong></li>
<li> <strong>线程池</strong></li>
</ol>
</blockquote>
<h2 id="2-1-Thread-类"><a href="#2-1-Thread-类" class="headerlink" title="2.1    Thread 类"></a>2.1    Thread 类</h2><blockquote>
<p>  <strong>步骤：</strong></p>
</blockquote>
<ol>
<li> 创建一个继承于 Thread 类的子类；</li>
<li> 重写 Thread 类中的 <code>run()</code> 方法，在方法中声明此线程要执行的任务；</li>
<li> 创建 Thread 类的子类的对象；</li>
<li> 调用子类对象的 <code>start()</code> 方法。</li>
</ol>
<blockquote>
<p>   <strong>代码实现</strong></p>
</blockquote>
<ol>
<li> 定义 Thread 类的子类 MyThread</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1正在执行任务A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ol>
<li>我们启动一个新线程，必须调用 <code>start()</code>，不能通过调用 <code>run()</code> 的方式启动线程。<ul>
<li>  <strong>我们在程序中调用了 <code>start()</code> 方法后，虚拟机会先为我们创建一个新的线程，然后等到这个线程第一次得到时间片时再调用 <code>run()</code> 方法。</strong></li>
<li>  注意不可多次调用 <code>start()</code> 方法。在第一次调用 <code>start()</code> 方法后，再次调用 <code>start()</code> 方法会<strong>抛出异常</strong>。</li>
</ul>
</li>
<li> 如果再启动一个线程，必须重新创建一个 Thread 子类的对象，调用此对象的 <code>start()</code></li>
</ol>
<hr>
<h2 id="2-2-Runnable-接口"><a href="#2-2-Runnable-接口" class="headerlink" title="2.2    Runnable 接口"></a>2.2    Runnable 接口</h2><blockquote>
<p>  <strong>实现步骤：</strong></p>
</blockquote>
<ol>
<li>定义 Runnable 接口的实现类，重写接口中的 <code>run()</code> 方法，在方法中声明此线程要执行的任务；</li>
<li>创建实现类的实例对象，并将此对象传递到 Thread 类的构造器中，创建 Thread 类实例对象；</li>
<li>通过 Thread 类的实例对象的<code>start()</code>方法启动线程。</li>
</ol>
<blockquote>
<p>  <strong>代码实现</strong></p>
</blockquote>
<ol>
<li> 定义 Runnable 接口的实现类 RunnableImpl</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行体，子线程1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.开启子线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Runnable 接口(JDK 1.8 +)</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Runnable 是一个函数式接口，这意味着我们可以使用 Java8 的函数式编程来简化代码。</p>
<hr>
<h2 id="2-3-Thread-vs-Runnable"><a href="#2-3-Thread-vs-Runnable" class="headerlink" title="2.3    Thread vs. Runnable"></a>2.3    Thread vs. Runnable</h2><blockquote>
<p>  <strong>联系：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>所以本质上，Thread 类中的 run() 也是从 Runnable 接口中继承过来然后重写的。而我们通过继承 Thread 类创建线程对象时又重写了 Thread 类中的 run() 方法</strong></li>
</ul>
<blockquote>
<p>  <strong>相同点：</strong></p>
</blockquote>
<ul>
<li>  两种方式都需要重写 <code>run()</code>，将新线程要执行的任务声明在 <code>run()</code> 中。</li>
<li>  实际上所有的多线程代码都是通过 <code>Thread</code> 类的 <code>start()</code> 方法来运行的。因此，不管是通过继承 <code>Thread</code> 类还是实现 <code>Runnable</code> 接口来实现多线程，最终都要通过<code>Thread</code>类的实例对象来开启线程的。</li>
</ul>
<blockquote>
<p>  <strong>使用：</strong></p>
</blockquote>
<ul>
<li>  开发时，在这两者之中，优先选择实现 Runnable 接口的方式；</li>
<li>  实际开发中，用的最多的还是通过线程池创建线程的方式。而且使用的线程池也不是 JDK 提供的线程的线程池，一般都是使用自定义的线程池。【阿里巴巴开发手册】</li>
</ul>
<blockquote>
<p>  <strong>继承 Thread 类的线程存在的缺陷（实现 Runnable 的线程的优势）：</strong></p>
</blockquote>
<ol>
<li> <strong>类单继承的局限性</strong>：由于单继承的局限性，如果一个类继承了<code>Thread</code>，就不能再继承其它父类了；换句话说，如果一个类已经继承了其它父类，就不能再通过继承 Thread 来实现多线程了，这时候就只能通过实现接口的方式来实现多线程。</li>
<li> <strong>Runnable 接口降低了线程对象和线程任务的耦合性，任务可被多个线程共享</strong>：实现 <code>Runnable</code> 接口的方式，任务和线程独立，任务可被多个线程共享。如果通过继承 Thread 的方式，线程和任务是绑定的，如果某个任务需要被多个线程执行的话就要声明多次。</li>
<li> <strong>线程池只能放入 Runnable 或 Callable 类型的线程，不能直接放入继承 Thread 类型的线程</strong>。</li>
<li> <strong>Runnable 接口更轻量级</strong>，如果使用线程时不需要使用 Thread 类中的诸多方法，显然使用 Runnable 接口更为轻量。</li>
</ol>
<hr>
<h2 id="2-4-Callable-接口"><a href="#2-4-Callable-接口" class="headerlink" title="2.4    Callable 接口"></a>2.4    Callable 接口</h2><ul>
<li>  <code>Callable</code> 与 <code>Runnable</code> 类似，同样是只有一个抽象方法的函数式接口。</li>
<li>  不同的是， <code>Callable</code> 提供的方法是有返回值的，而且支持泛型。</li>
</ul>
<blockquote>
<p>  <strong>Callable 接口源码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>Callable</code> 一般是配合线程池工具 <strong>ExecutorService</strong> 来使用的。</li>
<li>  <code>ExecutorService</code> 可以使用 <code>submit()</code> 方法来执行 Callable 接口中的 <code>call()</code> 方法。【不可以使用 <code>execute()</code> 执行 Callable 类型的任务】</li>
<li>  它会返回一个 <strong>Future</strong> ，我们后续的程序可以通过这个 Future 的 <code>get()</code> 方法得到结果。</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⾃定义 Callable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟计算需要5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="comment">// 使用线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        System.out.println(result.get());	<span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 注意：调⽤get方法会阻塞当前线程，直到得到结果。【线程资源用于死等返回结果，而不会去处理下一行的代码逻辑】</span></span><br><span class="line">        <span class="comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阻塞结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="3-Thread-类"><a href="#3-Thread-类" class="headerlink" title="3    Thread 类"></a>3    Thread 类</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1    概述"></a>3.1    概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span> </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java 使用<code>java.lang.Thread</code> 类代表线程。</li>
<li>所有的线程对象必须是 Thread 类或其子类的实例对象。</li>
<li>每个线程的作用是完成一个<strong>任务</strong>。Java使用<strong>线程执行体</strong>来代表这个任务。</li>
</ul>
<h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2    方法"></a>3.2    方法</h2><h3 id="3-2-1-构造方法（部分）"><a href="#3-2-1-构造方法（部分）" class="headerlink" title="3.2.1    构造方法（部分）"></a>3.2.1    构造方法（部分）</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Thread()</code></td>
<td align="left">创建一个默认名字的新的线程对象</td>
</tr>
<tr>
<td align="left"><code>Thread(String name)</code></td>
<td align="left">分配一个指定名字的新的线程对象</td>
</tr>
<tr>
<td align="left"><code>Thread(Runnable target)</code></td>
<td align="left">分配一个带有指定目标的新的线程对象</td>
</tr>
<tr>
<td align="left"><code>Thread(Runnable target, String name)</code></td>
<td align="left">分配一个带有指定目标的新的线程对象并指定线程名字</td>
</tr>
</tbody></table>
<ul>
<li><code>Runnable target</code> 是一个接口类型，该参数实际使用时接收的是 Runnable 接口的实现类。</li>
<li><code>Runnable</code> 接口的实现类对象中包含了<code>run()</code> 方法作为线程执行体，而实际的线程对象依然是<code>Thread</code>实例，只是该<code>Thread</code>线程负责执行<code>target</code>对象(即<code>Runnable</code>接口的实现类)中的<code>run()</code>方法。</li>
</ul>
<hr>
<h3 id="3-2-2-常用方法"><a href="#3-2-2-常用方法" class="headerlink" title="3.2.2    常用方法"></a>3.2.2    常用方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>thread.getName()</code></td>
<td align="center"><code>String</code></td>
<td align="left">获取当前线程的名称</td>
</tr>
<tr>
<td align="left"><code>thread.start()</code></td>
<td align="center"><code>void</code></td>
<td align="left">创建一个新的线程，并在轮询到CPU资源后开始执行线程指定的任务</td>
</tr>
<tr>
<td align="left"><code>run()</code></td>
<td align="center"><code>void</code></td>
<td align="left">此线程要执行的任务代码</td>
</tr>
<tr>
<td align="left"><code>Thread.sleep(long millis)</code></td>
<td align="center"><code>void</code></td>
<td align="left">静态方法，使当前正在执行的线程暂停x毫秒</td>
</tr>
<tr>
<td align="left"><code>Thread.currentThread()</code></td>
<td align="center"><code>Thread</code></td>
<td align="left">静态方法，返回当前正在执行的线程对象的引用</td>
</tr>
<tr>
<td align="left"><code>Thread.yield()</code></td>
<td align="center"><code>void</code></td>
<td align="left"><code>static native</code>，当前线程愿意让出对当前处理器的占用</td>
</tr>
<tr>
<td align="left"><code>thread.join()</code></td>
<td align="center"><code>void</code></td>
<td align="left">当前线程等待另一个线程执行完毕之后再执行</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>yield</strong></p>
</blockquote>
<p>yield 在英语里有放弃的意思，同样，这里的 <code>yield()</code> 指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了 <code>yield()</code> 方法，程序在调度的时候，也还有可能继续运行这个线程的；</p>
<blockquote>
<p>  <strong>join</strong></p>
</blockquote>
<p><code>join()</code> 方法是通过一个 thread 对象实例来调用的，作用是让外部线程进入“等待”状态，直到调用 <code>join</code> 方法的线程执行完成后，再继续执行外部线程。内部是通过 Object 类的 <code>wait()</code> 方法实现的。</p>
<p>🌰：比如，在 main 线程中创建并启动了子线程 threadA，如果 threadA 中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。如果 main 线程想等到子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到 <code>join()</code> 方法了。<code>join()</code> 方法会暂停当前正在执行的线程（即 main 线程），直到 threadA 线程执行结束之后再继续执行 main 线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/27 12:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务耗时3s</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行成功&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        threadA.start();</span><br><span class="line">        </span><br><span class="line">        threadA.join(); <span class="comment">// 让threadA线程得以执行，但是不让外部的 main 线程执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阻塞结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>sleep 和 wait 方法的区别：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">sleep</th>
<th align="left">wait</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">Thread 对象中的方法</td>
<td align="left">Object 对象中的方法</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>sleep</code> 释放 CPU 资源，但是不释放锁</td>
<td align="left"><code>wait</code> 释放 CPU 资源，同时释放锁</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">不需要被唤醒（休眠之后退出阻塞）</td>
<td align="left">需要被唤醒（不指定时间时需要被唤醒）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>sleep</code> 可以在任意位置</td>
<td align="left"><code>wait</code> 必须放在同步块或同步方法中</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>sleep</code> 必须指定时间</td>
<td align="left"><code>wait</code> 可以指定时间，也可以不指定</td>
</tr>
</tbody></table>
<ul>
<li>  由于 <code>sleep</code> 方法不释放锁，所以当线程醒来之后直接进入 Runnable 状态，当轮询到 CPU 资源后直接可以执行；而 <code>wait</code> 方法释放锁对象，当线程醒来后处于 Blocked 状态，只有再次获得锁之后才会进入 Runnable 状态。</li>
</ul>
<hr>
<h2 id="3-3-Thread-类构造方法源码分析"><a href="#3-3-Thread-类构造方法源码分析" class="headerlink" title="3.3    Thread 类构造方法源码分析"></a>3.3    Thread 类构造方法源码分析</h2><ul>
<li>  Thread 类是 Runnable 接口的一个实现类。</li>
<li>  查看 Thread 类的构造方法，发现 Thread 类的多个重载方法底层都是通过调用了一个私有的 <strong>init</strong> 方法来实现初始化的。 </li>
<li>  init 方法也是一个重载方法，其中参数最多的一个如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段1：init 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                  <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> inheritThreadLocals)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段2：Thread类的构造函数调⽤init⽅法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">    init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段3：使用在init⽅法里初始化AccessControlContext类型的私有属性</span></span><br><span class="line"><span class="built_in">this</span>.inheritedAccessControlContext = acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段4：两个对用于支持ThreadLocal的私有属性</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>init 方法中的参数详解：</strong></p>
<ul>
<li><p>  <strong>ThreadGroup g</strong>：线程组，指定这个线程是在哪个线程组下；</p>
</li>
<li><p>  <strong>Runnable target</strong>：指定要执行的任务；</p>
</li>
<li><p>  <strong>String name</strong>：线程的名字，多个线程的名字是可以重复的。如果不指定名字，默认会自动生成一个名字，见片段2；</p>
</li>
<li><p><strong>AccessControlContext acc</strong>：见片段3，用于初始化私有变量 <code>inheritedAccessControlContext</code>。</p>
<blockquote>
<p>  它是一个私有变量，但是在 Thread 类里只有 <code>init</code> 方法会对它进行初始化，在 exit 方法中把它设为 null 。一般不会使用到它。</p>
</blockquote>
</li>
<li><p>  <strong>inheritThreadLocals：</strong>可继承的 ThreadLocal ，见片段4， Thread 类里面有两个私有属性来⽀持 ThreadLocal 。</p>
</li>
</ul>
</blockquote>
<hr>
<h1 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4    线程状态"></a>4    线程状态</h1><h2 id="4-1-操作系统中的线程五态"><a href="#4-1-操作系统中的线程五态" class="headerlink" title="4.1    操作系统中的线程五态"></a>4.1    操作系统中的线程五态</h2><p>在现代操作系统中，<strong>线程被视为轻量级的进程，所以操作系统线程的状态和操作系统进程的状态是一致的</strong>。</p>
<p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/7462071-955b1ef86b257315.png" alt="img"></p>
<p>操作系统线程主要有以下三个状态：</p>
<ul>
<li>  **就绪状态(ready)**：线程正在等待 CPU，获得 CPU 之后可进入 running 状态。</li>
<li>  **执行状态(running)**：线程正在使用 CPU。</li>
<li>  **等待状态(waiting)**：线程被等待事件的调用或者正在等待其他资源（如 I/O）。</li>
</ul>
<hr>
<h2 id="4-2-Java-中的线程六态"><a href="#4-2-Java-中的线程六态" class="headerlink" title="4.2    Java 中的线程六态"></a>4.2    Java 中的线程六态</h2><p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB.png"></p>
<blockquote>
<p>  <strong>Thread.State 源码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="left">线程状态</th>
<th align="left">发生的条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>New</code></td>
<td align="left">线程刚被创建，但是<strong>还没有调用<code>start()</code>方法</strong>。</td>
</tr>
<tr>
<td align="left"><code>Runnable</code></td>
<td align="left">线程可以在 Java 虚拟机中运行，但不一定正在运行，什么时候运行取决于底层的操作系统。</td>
</tr>
<tr>
<td align="left"><code>Blocked</code></td>
<td align="left">当一个线程试图获取一个锁对象，而该锁对象被其它线程持有，则该线程进入<code>Blocked</code>状态，当该线程持有锁时，该线程将变成<code>Runnable</code>状态。</td>
</tr>
<tr>
<td align="left"><code>Waiting</code></td>
<td align="left">一个线程在等待另一个线程执行唤醒动作时，该线程进入<code>Waiting</code>状态。进入这个状态时不能自动唤醒的，必须等待另一个线程调用<code>notify</code>或<code>notifyAll</code>方法才能唤醒。</td>
</tr>
<tr>
<td align="left"><code>TimedWaiting</code></td>
<td align="left">有几个方法有超时参数，调用它们将进入<code>TimedWaiting</code>状态，这一状态将一直保持到超时期满或者接收到唤醒通知。    常用的带有超时参数的方法有**<code>Thread.sleep()</code>、<code>Object.wait()</code>**</td>
</tr>
<tr>
<td align="left"><code>Teminated</code></td>
<td align="left">因<code>run()</code>方法的正常退出而死亡，或者因为没有捕获的异常终止了<code>run()</code>方法而死亡。</td>
</tr>
</tbody></table>
<ul>
<li>  阻塞是不持有锁资源，但可能占用 CPU 资源，比如一个线程一直在以自旋的方式尝试获取锁对象，这时它自身是没有锁对象的，但是使用了CPU资源，这就是一种阻塞的状态。并且阻塞状态到 Runnable 状态是不需要被唤醒的。</li>
<li>  等待则是既不持有锁资源，也不占用 CPU 资源。在 Java 中，等待则是长时间阻塞后的最终结果。比如：当一个线程自旋次数达到一定的阈值后，为了避免线程继续自旋浪费 CPU 资源，就会让线程进入 Waiting 状态，不再使用 CPU 资源。</li>
</ul>
<hr>
<h2 id="4-3-NEW"><a href="#4-3-NEW" class="headerlink" title="4.3    NEW"></a>4.3    NEW</h2><p>处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的 <code>start()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testStateNew</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;&#125;);</span><br><span class="line">    System.out.println(thread.getState()); <span class="comment">// NEW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，只是创建了线程而并没有调用 <code>start()</code> 方法，此时线程处于 NEW 状态。</p>
<h2 id="4-4-RUNNABLE"><a href="#4-4-RUNNABLE" class="headerlink" title="4.4    RUNNABLE"></a>4.4    RUNNABLE</h2><ul>
<li><code>Runnable</code> 是一种可运行的状态。表示线程可以在 Java 虚拟机中运行，但不一定正在运行。处于 RUNNABLE 状态的线程可能在 Java 虚拟机中运行，也有可能在等待 CPU 资源。</li>
<li>多线程的多个线程在没有进行到争夺同一锁对象之前都是<code>Runnable</code>状态，但是一旦涉及到争夺锁对象，就会分为<code>Runnable</code>和<code>Blocked</code>两种状态。</li>
</ul>
<blockquote>
<p>  <strong>Java 中线程的 RUNNABLE 状态：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread 源码里对 RUNNABLE 状态的定义：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Thread state for a runnable thread. A thread in the runnable</span></span><br><span class="line"><span class="comment">* state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">* be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">* such as processor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">翻译：处于Runnable状态下的线程可能正在Java虚拟机中执行，也有可能正在等待来自于操作系统的其它资源，比如处理器。</span><br></pre></td></tr></table></figure>

<p>显然，<strong>Java 线程的 RUNNABLE 状态其实是包括了传统操作系统线程的 ready 和 running 两个状态的</strong>。</p>
<h2 id="4-5-BLOCKED"><a href="#4-5-BLOCKED" class="headerlink" title="4.5    BLOCKED"></a>4.5    BLOCKED</h2><ul>
<li>阻塞状态。<ul>
<li>  处于 BLOCKED 状态的线程正等待锁的释放以进入同步区。</li>
<li>  处于 BLOCKED 状态的线程依然占用 CPU 资源。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>Blocked 线程状态图</strong></p>
</blockquote>
<ul>
<li>  当多个线程协作时，比如线程 A 和线程 B 争夺同一锁对象，如果线程 A 先获取到锁对象，那么线程 A 就进入到<code>Runnable</code>状态，而线程 B 进入到<code>Blocked</code><strong>锁阻塞</strong>状态，注意仅仅是锁阻塞，在自旋状态下线程B还会不停地尝试获取锁对象，直到进入 Waiting 状态后才释放对 CPU 的占用。</li>
</ul>
<p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012170616241.png" alt="image-20201012170616241"></p>
<h2 id="4-6-WAITING"><a href="#4-6-WAITING" class="headerlink" title="4.6    WAITING"></a>4.6    WAITING</h2><ul>
<li>等待状态。<ul>
<li>  处于等待状态的线程变成 RUNNABLE 状态需要通过其它线程唤醒[，而处于 BLOCKED 状态的线程变成 RUNNABLE 状态时不需要通过其它线程唤醒。]</li>
<li>  处于等待状态的线程既不占用 CPU 资源，也不持有锁对象。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>Waiting线程状态图</strong></p>
</blockquote>
<ul>
<li>当多个线程协作时，如果线程 A 在 <code>running</code> 状态下调用了 <strong>Object#wait()</strong> 方法，那么线程 A 就进入了<code>Waiting</code>状态，<strong>同时失去了锁对象（Tip：Thread#sleep() 方法不会释放锁对象）</strong>。<ul>
<li>  如果处于阻塞状态下的线程，在自旋次数达到了一个阈值之后，也会通过 <strong>LockSupport#lock()</strong> 方法进入阻塞状态。</li>
</ul>
</li>
<li>  如果此时线程 B 获取到了同一锁对象，并在 <code>running</code> 状态下调用了 <code>notify()</code> 方法，那么就会将<code>Waiting</code>状态的线程 A 唤醒。<strong>注意仅仅只是唤醒，如果线程 A 被唤醒后获取到了锁对象，那么就进入<code>Runnable</code>状态，如果没有获取到锁对象，则进入<code>Blocked</code>状态。</strong></li>
</ul>
<img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012171420707.png" alt="image-20201012171420707" style="zoom:80%;">



<h3 id="调用以下-3-个方法会使线程进入等待状态："><a href="#调用以下-3-个方法会使线程进入等待状态：" class="headerlink" title="调用以下 3 个方法会使线程进入等待状态："></a>调用以下 3 个方法会使线程进入等待状态：</h3><ul>
<li>  **Object.wait()**：使当前线程立即进入等待状态，直到另一个线程唤醒它；</li>
<li>  **Thread.join()**：是当前线程进入等待状态，直到调用 join 方法的线程中的任务执行完毕，底层调用的是 Object 实例的 wait 方法；</li>
<li>  **LockSupport.park()**：除非获得调用许可，否则禁用当前线程进行线程调度。</li>
</ul>
<blockquote>
<p>  <strong>Object.wait()</strong></p>
</blockquote>
<ul>
<li>  调用 <code>wait()</code> 方法前线程必须持有对象的锁。</li>
<li>  线程调用 <code>wait()</code> 方法时，会释放当前的锁，直到有其他线程调用 <code>notify()/notifyAll()</code> 方法唤醒等待锁的线程。</li>
<li>  <strong>需要注意的是，其他线程调用 <code>notify()</code> 方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用 <code>wait()</code> 方法的线程。</strong></li>
<li>  <strong>同样，调用 <code>notifyAll()</code> 方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</strong></li>
</ul>
<blockquote>
<p>  <strong>Thread.join()</strong></p>
</blockquote>
<ul>
<li>  调用 <code>join()</code> 方法不会立即释放锁，会一直等待当前线程执行完毕（转换为 TERMINATED 状态）。</li>
<li>  举例说明：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockedTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        testMethod();</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        testMethod();</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.start();</span><br><span class="line">    a.join();</span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">&quot;:&quot;</span> + a.getState()); </span><br><span class="line">    System.out.println(b.getName() + <span class="string">&quot;:&quot;</span> + b.getState()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法争夺锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  要是没有调用 <code>join()</code> 方法，main 线程不管 a 线程是否执行完毕都会继续往下走。</li>
<li>  a 线程启动之后马上调用了 <code>join()</code> 方法，这时 main 线程就会等到 a 线程执行完毕才能继续向下执行，所以这里 a 线程打印的状态固定是TERMIATED。</li>
<li>  至于 b 线程的状态，有可能打印 RUNNABLE（尚未进入同步方法），也有可能打印 TIMED_WAITING（进入了同步方法）。</li>
</ul>
<hr>
<h2 id="4-7-TIMED-WAITING"><a href="#4-7-TIMED-WAITING" class="headerlink" title="4.7    TIMED_WAITING"></a>4.7    TIMED_WAITING</h2><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<ul>
<li>进入<code>TimedWaiting</code>状态的一种方法是调用<code>Thread.sleep()</code>方法，单线程也可以调用。</li>
<li>为了让其它线程也有机会执行，可以将<code>Thread.sleep()</code>的调用放入线程执行体<code>run()</code>之内，这样才能保证该线程执行过程中会睡眠。[睡眠是在线程已经执行了一部分的情况下进入的，我们一般会把<code>sleep()</code>方法写在线程执行体的前面几行代码中，使当前线程进入睡眠]</li>
<li><code>sleep()</code>中指定的时间是线程不会运行的最短时间。因为 <code>sleep()</code> 方法在休眠时不会释放锁对象，所以该线程睡眠时间到期后没有重新争夺锁的过程，而是会直接进入<code>Runnable</code>状态。</li>
</ul>
<blockquote>
<p>  <strong>TimeWaiting 线程状态图</strong></p>
</blockquote>
<img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012165955497.png" alt="image-20201012165955497" style="zoom:80%;">



<h3 id="调用如下方法会使线程进入超时等待状态："><a href="#调用如下方法会使线程进入超时等待状态：" class="headerlink" title="调用如下方法会使线程进入超时等待状态："></a>调用如下方法会使线程进入超时等待状态：</h3><blockquote>
<ul>
<li>  <strong>Thread.sleep(long millis)</strong></li>
<li>  <strong>Object.wait(long timeout)</strong></li>
<li>  <strong>Thread.join(long millis)</strong></li>
<li>  <strong>LockSupport.parkNanos(long nanos)</strong></li>
<li>  <strong>LockSupport.parkUntil(long deadline)</strong></li>
</ul>
</blockquote>
<blockquote>
<p>  <strong>Thread.sleep(long millis)</strong></p>
</blockquote>
<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入 RUNNABLE 状态。</p>
<blockquote>
<p>  <strong>Object.wait(long timeout)</strong></p>
</blockquote>
<p>线程休眠指定时间，等待期间可以通过 <code>notify()/notifyAll()</code> 唤醒，被唤醒后重新拥有争夺锁的资格。</p>
<blockquote>
<p>  <strong>Thread.join(long millis)</strong></p>
</blockquote>
<p>使当前线程执行指定时间，如果 millis 为 0，则会一直执行。</p>
<ul>
<li>  修改一下刚才的示例:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockedTest</span><span class="params">()</span> &#123;</span><br><span class="line">    ······</span><br><span class="line">    a.start();</span><br><span class="line">    a.join(<span class="number">1000L</span>);</span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">&quot;:&quot;</span> + a.getState()); <span class="comment">// 输出 TIEMD_WAITING</span></span><br><span class="line">    System.out.println(b.getName() + <span class="string">&quot;:&quot;</span> + b.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  这里调用 <code>a.join(1000L)</code>，因为是指定了具体 a 线程执行的时间的，并且执行时间是小于 a 线程 sleep 的时间，所以 a 线程状态输出为 TIMED_WAITING。</li>
<li>  b 线程状态仍然不固定（RUNNABLE或BLOCKED）。</li>
</ul>
<hr>
<h2 id="4-8-TERMINATED"><a href="#4-8-TERMINATED" class="headerlink" title="4.8    TERMINATED"></a>4.8    TERMINATED</h2><p>终⽌状态。此时线程已执行完毕。</p>
<hr>
<h2 id="4-9-线程中断"><a href="#4-9-线程中断" class="headerlink" title="4.9    线程中断"></a>4.9    线程中断</h2><ul>
<li>  在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。</li>
<li>  目前在 Java 中还没有安全直接的方法来停止线程，但是 Java 提供了线程中断机制来处理需要中断线程的情况。</li>
<li>  线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。</li>
</ul>
<blockquote>
<p>  Thread 类中提供了几个关于线程中断的方法：</p>
</blockquote>
<ul>
<li>  **Thread.interrupt()**：中断线程。这里的中断线程并不会立即停止线程，⽽是设置线程的中断状态为 true（默认是flase）；</li>
<li>  **Thread.interrupted()**：测试当前线程是否被中断。线程的中断状态受这个方法的影响，调用一次会使线程中断状态设置为 true，连续调用两次会使得这个线程的中断状态重新转为 false；</li>
<li>  **Thread.isInterrupted()**：测试当前线程是否被中断。与上面放法不同的是调用这个方法并不会影响线程的中断状态。</li>
</ul>
<blockquote>
<p>  <strong>Tip：</strong></p>
</blockquote>
<p>在线程中断机制中，当其他线程通知需要被中断的线程后，线程中断的状态被设置为 true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己决定，可以在合适的实际处理中断请求，也可以完全不处理继续执行下去。</p>
<hr>
<h1 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5    线程安全"></a>5    线程安全</h1><h2 id="5-1-线程安全"><a href="#5-1-线程安全" class="headerlink" title="5.1    线程安全"></a>5.1    线程安全</h2><ul>
<li>  如果有多个线程在同时运行，而且这些线程可能会同时运行某段代码。<strong>如果多线程程序每次运行这段代码的结果和单线程运行的结果是一样的，而且其他变量的值也和预期的是一样的，就说线程是安全的。</strong></li>
<li>  <strong>线程安全问题都是由全局变量和静态变量引起的</strong>。    <em>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的</em>。    若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li>
</ul>
<h2 id="5-2-案例演示"><a href="#5-2-案例演示" class="headerlink" title="5.2    案例演示"></a>5.2    案例演示</h2><blockquote>
<p>  电影院卖票，假设共有100张票，多个窗口同时卖票。</p>
</blockquote>
<ol>
<li><p><code>Runnable</code>的实现类<code>RunnableImpl</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 模拟出票时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> tickets--;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;正在卖：&quot;</span>+now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>测试类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.总共有100张票</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.三个窗口同时卖票</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">win1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">win2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">win3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        win1.start();</span><br><span class="line">        win2.start();</span><br><span class="line">        win3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Thread[窗口1,5,main]正在卖：100</span></span><br><span class="line"><span class="comment">    Thread[窗口2,5,main]正在卖：99</span></span><br><span class="line"><span class="comment">    Thread[窗口3,5,main]正在卖：99</span></span><br><span class="line"><span class="comment">    Thread[窗口1,5,main]正在卖：98</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">    线程不安全</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-3-线程同步"><a href="#5-3-线程同步" class="headerlink" title="5.3    线程同步"></a>5.3    线程同步</h2><ul>
<li><p>  当我们使用多个线程访问同一资源，且存在多个线程对资源有写的操作时，就可能会出现线程安全问题。</p>
</li>
<li><p>要解决上述多线程的并发访问一个资源的安全性问题：也就是解决重复票与不存在票的问题，Java提供了<strong>同步机制（synchronize）</strong>来解决。</p>
<blockquote>
<ol>
<li> 窗口1线程执行卖票操作的时候，窗口2和窗口3线程只能在外面等着。 </li>
<li> 窗口1操作结束，窗口1、窗口2、和窗口3才有机会进入代码去执行卖票操作。</li>
<li> 也就是说某个线程在修改共享资源的时候，其它线程不能修改该资源，等待修改完毕资源同步之后，才能去抢夺 CPU 资源，完成对应的操作，保证了数据的同步性。解决了线程的不安全问题。</li>
</ol>
</blockquote>
</li>
<li><p>如何完成同步操作？3种方式</p>
<ol>
<li> <strong>同步代码块</strong></li>
<li> <strong>同步方法</strong></li>
<li> <strong>锁机制</strong></li>
</ol>
</li>
</ul>
<h2 id="5-3-同步代码块"><a href="#5-3-同步代码块" class="headerlink" title="5.3    同步代码块"></a>5.3    同步代码块</h2><ul>
<li><p>  <strong>同步代码块</strong>：<code>synchronized</code>关键字可以用于<code>run()</code>方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p>
</li>
<li><p>格式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    需要同步操作的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>同步锁</strong>：同步锁对象只是一个概念，可以想象为在对象上标记了一把锁。</p>
<ol>
<li> 锁对象，可以是任意类型。</li>
<li> 多个线程对象，要使用同一把锁<code>（--&gt;&gt;单例）可以是static或final修饰的对象</code>。</li>
<li> 在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其它线程只能在外面等着。<code>（--&gt;&gt;BLOCKED）</code></li>
</ol>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int tickets = 100;</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">            while (tickets&gt;0)&#123;</span><br><span class="line">                // 模拟出票时间</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    tickets--;</span><br><span class="line">                    System.out.println(Thread.currentThread()+&quot;正在卖：&quot;+tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    使用了同步代码块后，上述的线程安全问题就解决了。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>





<h2 id="5-4-同步方法"><a href="#5-4-同步方法" class="headerlink" title="5.4    同步方法"></a>5.4    同步方法</h2><ul>
<li><p>  同步方法：使用<code>synchronized</code>修饰的方法，就叫做同步方法，保证A线程执行该方法的时候，其它线程只能在方法外等着。</p>
</li>
<li><p>格式：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method()&#123;</span><br><span class="line">    // 可能会产生线程安全的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int tickets = 100;</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            sellTickets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     public synchronized void sellTickets()&#123;</span><br><span class="line">            if (tickets&gt;0)&#123;</span><br><span class="line">                // 模拟出票时间</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    tickets--;</span><br><span class="line">                    System.out.println(Thread.currentThread()+&quot;正在卖：&quot;+tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <em>同步方法中，隐藏了同步锁对象。如果同步方法是一个非静态方法，那么它的同步锁对象就是<code>this</code>对象；若果同步方法是静态方法，同步锁对象就是当前方法所在类的字节码对象。</em></p>
<h3 id="4-2-3、Lock锁（同步锁）"><a href="#4-2-3、Lock锁（同步锁）" class="headerlink" title="4.2.3、Lock锁（同步锁）"></a>4.2.3、Lock锁（同步锁）</h3><h4 id="Lock类介绍"><a href="#Lock类介绍" class="headerlink" title="Lock类介绍"></a>Lock类介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.Lock;</span><br><span class="line">public interface Lock;</span><br><span class="line">// 常用的实现类</span><br><span class="line">ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock </span><br></pre></td></tr></table></figure>

<p>​    <code>Lock接口</code>提供了比使用 <code>synchronized</code> 方法和代码块更广泛的锁定操作，同步代码块/同步方法具有的功能<code>Lock</code>都由，而且更加强大，更体现面向对象。</p>
<h4 id="Lock接口中常用的方法"><a href="#Lock接口中常用的方法" class="headerlink" title="Lock接口中常用的方法"></a>Lock接口中常用的方法</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public void lock()</code></td>
<td align="center">加同步锁</td>
</tr>
<tr>
<td align="center"><code>public void unlock()</code></td>
<td align="center">释放同步锁</td>
</tr>
</tbody></table>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 模拟出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    tickets--;</span><br><span class="line">                    System.out.println(Thread.currentThread()+<span class="string">&quot;正在卖：&quot;</span>+tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="6-线程间通信（等待-唤醒机制）"><a href="#6-线程间通信（等待-唤醒机制）" class="headerlink" title="6    线程间通信（等待/唤醒机制）"></a>6    线程间通信（等待/唤醒机制）</h1><h2 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1    概念"></a>6.1    概念</h2><blockquote>
<p>  <strong>什么是线程同步？</strong></p>
</blockquote>
<p>线程同步是线程之间按照<strong>一定的顺序</strong>执行。</p>
<blockquote>
<p>  <strong>为什么要处理线程间通信？</strong></p>
</blockquote>
<p>多个线程并发执行时，默认情况下 CPU 是随机切换线程的。当我们需要多个线程来共同完成一件任务，并且<strong>希望这些线程能有规律的执行</strong>，那么多个线程之间就需要进行通信来协调任务，以此来帮助我们达到多线程共同操作一份数据。</p>
<ul>
<li>  比如，线程A是生产包子的线程，线程B是消耗包子的线程，那么我们希望线程A每生产100个包子就通知线程B开始吃包子，线程B吃完包子后就通知线程A再开始生产包子，这时我们就必须通过线程通信来达到这一目的。    对于线程A，设置一个阀值，当包子数量达到阀值后线程A进入睡眠状态；此时线程B开始吃包子，当包子数量为0时线程B进入睡眠状态，并唤醒线程A让线程A继续生产包子。</li>
<li>  再比如，线程 A 和 B 的任务都是打印 1~100 之间的整数，但是要求线程 A 全部打印完毕后线程 B 才能开始打印，这也需要线程间通信来进行协调。</li>
</ul>
<blockquote>
<p>  <strong>如何保证线程间通信能有效利用资源？</strong></p>
</blockquote>
<ul>
<li>  多个线程在处理同一资源，并且任务不相同时，需要通过线程通信来帮助解决多个线程操作同一变量可能引发的冲突。</li>
<li>  如果是简单的基于“锁”的方式，在线程 A 持有锁对象，线程 B 进入阻塞而没有进入休眠，会不断地尝试去获取锁，这很消耗服务器资源；</li>
<li>  所以，我们一般采用的手段是——<strong>等待/唤醒机制</strong>。</li>
</ul>
<hr>
<h2 id="6-2-wait-notify-机制"><a href="#6-2-wait-notify-机制" class="headerlink" title="6.2    wait/notify 机制"></a>6.2    wait/notify 机制</h2><p>Java 多线程的 <strong>等待/通知机制</strong> 是基于 Object 类的 <code>wait()</code> 方法和 <code>notify()</code>、<code>notifyAll()</code> 方法来实现的。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Object#wait()</strong></td>
<td align="left">让当前线程进入等待队列中，<strong>并释放当前持有的锁对象</strong></td>
</tr>
<tr>
<td align="left"><strong>Object#notify()</strong></td>
<td align="left">随机唤醒等待队列中的一个线程，让其重新进入到调度队列中</td>
</tr>
<tr>
<td align="left"><strong>Object#notifyAll()</strong></td>
<td align="left">唤醒等待队列中的全部线程</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>调用wait()和notify()方法需要注意的细节</strong></p>
</blockquote>
<ol>
<li><code>wait()</code>和<code>notify()</code>方法必须要由同一个对象（即锁对象）调用。只有锁对象的<code>notify()</code>方法才能唤醒由该锁对象调用<code>wait()</code>方法后挂起的线程。</li>
<li><code>wait()</code>和<code>notify()</code>方法是属于<code>Object</code>类的方法。因此，锁对象可以是任意对象。</li>
<li><code>wait()</code>和<code>notify()</code>方法必须要在同步代码块或同步函数中使用。因为，必须通过锁对象调用这2个方法。</li>
</ol>
<h2 id="6-3-代码演示"><a href="#6-3-代码演示" class="headerlink" title="6.3    代码演示"></a>6.3    代码演示</h2><ul>
<li><p>  假如线程A现在持有了一个锁 lock 并开始执行，它可以使用 <code>lock.wait()</code> 让自己进入等待状态。这个时候， lock 这个锁是被释放了的。</p>
</li>
<li><p>这时，线程B获得了 lock 这个锁并开始执行，它可以在某一时刻，使用 <code>lock.notify()</code> ，通知之前持有 lock 锁并进入等待状态的线程A，说“线程A你不用等了，可以往下执行了”。</p>
<blockquote>
<p>  <strong>需要注意的是，这个时候线程B并没有释放锁 lock ，除非线程B这个时候使用 <code>lock.wait()</code> 释放锁，或者线程B执行结束自行释放锁，线程A才能得到 lock 锁。</strong></p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitAndNotify</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadA: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadB: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadA</span>()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadB</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">ThreadA: <span class="number">0</span></span><br><span class="line">ThreadB: <span class="number">0</span></span><br><span class="line">ThreadA: <span class="number">1</span></span><br><span class="line">ThreadB: <span class="number">1</span></span><br><span class="line">ThreadA: <span class="number">2</span></span><br><span class="line">ThreadB: <span class="number">2</span></span><br><span class="line">ThreadA: <span class="number">3</span></span><br><span class="line">ThreadB: <span class="number">3</span></span><br><span class="line">ThreadA: <span class="number">4</span></span><br><span class="line">ThreadB: <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>​    </p>
<hr>
<h1 id="7-Java内存模型（JMM）"><a href="#7-Java内存模型（JMM）" class="headerlink" title="7    Java内存模型（JMM）"></a>7    Java内存模型（JMM）</h1><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/08/JMM/">超链接：JMM</a></li>
</ul>
<hr>
<h1 id="8-线程池"><a href="#8-线程池" class="headerlink" title="8    线程池"></a>8    线程池</h1><p><a href>超链接</a></p>
<h2 id="7-1、概念"><a href="#7-1、概念" class="headerlink" title="7.1、概念"></a>7.1、概念</h2><ul>
<li><strong>线程池：</strong>一个可以容纳多个线程对象的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程对象而消耗过多的资源。</li>
</ul>
<h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ol>
<li><p>降低资源消耗。</p>
<p>​    减少了创建和销毁线程的次数，每个线程都可以被反复利用。</p>
</li>
<li><p>提高响应速度。</p>
<p>​    当任务到达时，任务可以不需要等待线程的创建就能立即执行。[直接从线程池中调用线程对象]</p>
</li>
<li><p>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线程的数据，防止因为消耗过多的内存而导致服务器奔溃。(每个线程大约需要1MB的内存，线程开的越多，消耗的内存也就越大，最后死机)</p>
<p><em>线程池会事先设置好该池内会有多少个线程，假设某一时刻线程池中的线程全部处于运行状态，这时如果还有新的任务需要申请新的线程，该任务不会创建新的线程，而是进入等待状态，直到线程池中的某个线程处于空闲状态，再调用该线程去执行任务。</em></p>
</li>
</ol>
<h2 id="7-2、线程池的使用"><a href="#7-2、线程池的使用" class="headerlink" title="7.2、线程池的使用"></a>7.2、线程池的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executor;	<span class="comment">// 线程池的顶级接口</span></span><br><span class="line">java.util.concurrent.ExecutorService；	<span class="comment">// 真正的线程池接口</span></span><br><span class="line">java.util.concurrent.Executors	<span class="comment">// 线程工厂类，提供了一些静态方法用于生成常用的线程池</span></span><br></pre></td></tr></table></figure>

<p>Java中线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而是一个线程池执行工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，因此官方提供了一个工具类<code>java.util.concurrent.Executors</code>线程工厂类，里面提供了一些静态工厂，生成一些常用的线程池。</p>
<ul>
<li><p><strong>Executors类中创建线程池的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个可重用的固定线程数的线程池对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>线程池对象ExecutorService中的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取线程池中某一个线程对象，并执行</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task)</span><br><span class="line">    <span class="comment">// Future接口：用来记录线程任务执行完毕后产生的结果。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用线程池对象的步骤"><a href="#使用线程池对象的步骤" class="headerlink" title="使用线程池对象的步骤"></a>使用线程池对象的步骤</h3><ol>
<li>创建线程池对象；</li>
<li>创建Runnable接口的子类对象。(task)</li>
<li>提交Runnable接口子类对象。</li>
<li>关闭线程池。(一般不做)</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/09/MySql%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">MySQL基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-09 20:32:50" itemprop="dateCreated datePublished" datetime="2020-10-09T20:32:50+08:00">2020-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-06 13:48:51" itemprop="dateModified" datetime="2021-10-06T13:48:51+08:00">2021-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80.png"></p>
<h1 id="1、数据库介绍"><a href="#1、数据库介绍" class="headerlink" title="1、数据库介绍"></a>1、数据库介绍</h1><h2 id="1-1、是什么"><a href="#1-1、是什么" class="headerlink" title="1.1、是什么"></a>1.1、是什么</h2><ul>
<li>  数据库 == <strong>存储数据的仓库</strong>，</li>
<li>  数据库本质上是一个<strong>文件</strong>，我们可以称之为文件系统，与普通的文件相比多了便于管理的特点。</li>
</ul>
<h3 id="1-1-1、常见数据的存储方式"><a href="#1-1-1、常见数据的存储方式" class="headerlink" title="1.1.1、常见数据的存储方式"></a>1.1.1、常见数据的存储方式</h3><table>
<thead>
<tr>
<th align="left">存储位置</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存</td>
<td align="left">存取速度快</td>
<td align="left">不能永久保存，数据是临时状态</td>
<td align="left">Java中创建的对象</td>
</tr>
<tr>
<td align="left">文件</td>
<td align="left">数据可以永久保存</td>
<td align="left">数据操作不方便，查询数据时不方便</td>
<td align="left">通过Java的IO流，把临时数据保存到文件中</td>
</tr>
<tr>
<td align="left">数据库<br>(文件的一种)</td>
<td align="left">1、数据可以永久保存<br>2、查询速度快<br>3、对数据的管理方便</td>
<td align="left">占用资源，需要购买</td>
<td align="left">MySQL</td>
</tr>
</tbody></table>
<h2 id="1-2、数据库的好处"><a href="#1-2、数据库的好处" class="headerlink" title="1.2、数据库的好处"></a>1.2、数据库的好处</h2><ol>
<li> 可以持久化数据到本地</li>
<li> 结构化查询</li>
</ol>
<h2 id="1-3、数据库管理系统"><a href="#1-3、数据库管理系统" class="headerlink" title="1.3、数据库管理系统"></a>1.3、数据库管理系统</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>  数据库管理系统(DBMS)是管理和操作数据库的<strong>软件</strong>。</li>
<li>  数据库管理系统可由 <strong>DOS窗口</strong> 或 <strong>SQLyog</strong> 等软件充当。</li>
</ul>
<h3 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h3><ul>
<li>  用户通过DBMS <strong>访问数据库中的数据</strong>。</li>
</ul>
<h2 id="1-3、DBMS、DB-和表的关系"><a href="#1-3、DBMS、DB-和表的关系" class="headerlink" title="1.3、DBMS、DB 和表的关系"></a>1.3、DBMS、DB 和表的关系</h2><p>​        数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库，每个数据库中又会创建多个表，以保存程序中的实体类数据。</p>
<blockquote>
<p>  数据库管理系统、数据库和表的关系如图所示：</p>
</blockquote>
<p><img src="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/image-20201008221624101.png" alt="image-20201008221624101"></p>
<hr>
<h1 id="2、SQL-概述"><a href="#2、SQL-概述" class="headerlink" title="2、SQL 概述"></a>2、SQL 概述</h1><h2 id="2-1、是什么"><a href="#2-1、是什么" class="headerlink" title="2.1、是什么"></a>2.1、是什么</h2><blockquote>
<p>  <strong>SQL；Structured Query Language；结构化查询语言；</strong></p>
</blockquote>
<ul>
<li>  顾名思义，<strong>最主要的功能是查询</strong>。</li>
<li>  SQL 是一种<strong>所有关系型数据库通用的查询规范</strong>。可以作用在不同的数据库中，当然不同数据库的 SQL 也有一些细小的区别区别。打个比方就是 SQL 就是普通话，而不同的数据库实现（如MySQL、Oracle等）可以实现自己的方言。</li>
</ul>
<h2 id="2-2、SQL-分类"><a href="#2-2、SQL-分类" class="headerlink" title="2.2、SQL 分类"></a>2.2、SQL 分类</h2><p>虽然 SQL 最主要的功能是查询，但也实现了基本的增删改的功能。按照功能可将 SQL 划分为以下 4 类：</p>
<blockquote>
<ul>
<li><strong>DDL（Data Definition Language）：建库、建表</strong></li>
<li><strong>DML（Data Manipulation Language）：对表中的记录进行CRUD</strong></li>
<li><strong>DQL</strong></li>
<li><strong>DCL：授权、收权</strong></li>
</ul>
</blockquote>
<h2 id="2-3、MySQL"><a href="#2-3、MySQL" class="headerlink" title="2.3、MySQL"></a>2.3、MySQL</h2><p>MySQL 是 SQL 的一个具体落地产品。</p>
<blockquote>
<p>  <strong>MySQL的 启动 &amp; 登录 &amp; 退出：</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 MySQL 服务</span></span><br><span class="line">net start mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭 MySQL 服务</span></span><br><span class="line">net stop mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">方式1【本地登录】</span></span><br><span class="line">	mysql -u用户名 -p密码	</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">方式2</span></span><br><span class="line">	mysql -hip地址 -u用户名 -p密码	</span><br><span class="line">	mysql -h127.0.0.1 -uroot -proot</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">方式3</span></span><br><span class="line">	mysql --h=ip地址 --user=用户名 --password=密码	</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出</span></span><br><span class="line">quit 或 exit</span><br></pre></td></tr></table></figure>



<h3 id="MySql数据类型"><a href="#MySql数据类型" class="headerlink" title="MySql数据类型"></a>MySql数据类型</h3><table>
<thead>
<tr>
<th align="center">大类</th>
<th align="center">小类</th>
<th align="center">类型说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><code>tinyInt</code></td>
<td align="center">微整型，<code>1Byte</code>，<code>8bit</code></td>
</tr>
<tr>
<td align="center"><strong>整数类型</strong></td>
<td align="center"><code>smallInt</code></td>
<td align="center">微整型，<code>2Byte</code>，<code>16bit</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>mediumint</code></td>
<td align="center">微整型，<code>3Byte</code>，<code>24bit</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>int</code></td>
<td align="center">整型，<code>4Byte</code>，<code>32bit</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>小数类型</strong></td>
<td align="center"><code>float</code></td>
<td align="center">单精度浮点数，<code>4Byte</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>double</code></td>
<td align="center">双精度浮点数，<code>8Byte</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>time</code></td>
<td align="center">时间类型，<code>HH:MM:SS</code></td>
</tr>
<tr>
<td align="center"><strong>日期类型</strong></td>
<td align="center"><code>date</code></td>
<td align="center">日期类型，<code>YYYY-MM-DD</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>datetime</code></td>
<td align="center">同时可以表示日期和时间类型，<code>YYYY-MM-DD HH:MM:SS</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>字符串</strong></td>
<td align="center"><code>char(x)</code></td>
<td align="center">固定长度的字符串，无论使用几个字符都占满全部</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>varchar(x)</code></td>
<td align="center">可变长度的字符串，使用几个字符就占用几个</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>大二进制</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>大文本</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<hr>
<h1 id="3、DDL"><a href="#3、DDL" class="headerlink" title="3、DDL"></a>3、DDL</h1><blockquote>
<p><strong>DDL；Data Definition Language；数据定义语言；</strong></p>
</blockquote>
<ul>
<li>  主要用于：<strong>建库、建表</strong></li>
</ul>
<p><strong>如何理解？</strong></p>
<p>数据定义语言，可以理解为给数据分类，定义数据的类型，即哪些数据属于 A 类，哪些数据属于 B 类。</p>
<p>建库、建表就是给数据分类的过程。也就是定义数据类型的过程。库是大类型，表是小类型。比如有一批数据需要处理，我们可以先定义一批数据库，比如腾讯公司的数据放在数据库 A，阿里的数据放在数据库 B；建表则是子类型，如在腾讯的数据中包含了员工数据和部门数据，我们可以将员工数据保存在 emp 表中，将部门数据保存在 dep 表中。通过 【<strong>库 + 表</strong>】 的分类方式我们可以将全部的数据划分为不同的类型。</p>
<h2 id="3-1、数据库操作"><a href="#3-1、数据库操作" class="headerlink" title="3.1、数据库操作"></a>3.1、数据库操作</h2><h3 id="1、创建数据库-create"><a href="#1、创建数据库-create" class="headerlink" title="1、创建数据库[create]"></a>1、创建数据库[create]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 创建数据库</span><br><span class="line">create database db1;</span><br><span class="line"></span><br><span class="line">-- 2. 当数据库不存在时，再创建数据库</span><br><span class="line">create database if not exists db1;</span><br><span class="line"></span><br><span class="line">-- 3. 创建数据库并指定字符集</span><br><span class="line">create database db1 [default] character set utf8;		-- `utf-8` 在这里写为 `utf8`</span><br></pre></td></tr></table></figure>

<h3 id="2、查看数据库-show"><a href="#2、查看数据库-show" class="headerlink" title="2、查看数据库[show]"></a>2、查看数据库[show]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 1、查看所有的数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">-- 2、查看某个数据库的创建语句</span><br><span class="line">show create database db1;</span><br></pre></td></tr></table></figure>

<h3 id="3、修改数据库-alter"><a href="#3、修改数据库-alter" class="headerlink" title="3、修改数据库[alter]"></a>3、修改数据库[alter]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 修改数据库默认字符集</span><br><span class="line">Alter database db1 Default Character set gbk;</span><br></pre></td></tr></table></figure>

<h3 id="4、删除数据库-drop"><a href="#4、删除数据库-drop" class="headerlink" title="4、删除数据库[drop]"></a>4、删除数据库[drop]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop database db1;</span><br><span class="line">drop database if exists db1;</span><br></pre></td></tr></table></figure>

<h3 id="5、使用数据库"><a href="#5、使用数据库" class="headerlink" title="5、使用数据库"></a>5、使用数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用/切换数据库</span><br><span class="line">use db1;</span><br><span class="line"></span><br><span class="line">-- 查看正在使用的数据库</span><br><span class="line">select database();</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="3-2、表操作"><a href="#3-2、表操作" class="headerlink" title="3.2、表操作"></a>3.2、表操作</h2><h3 id="1、建表-create"><a href="#1、建表-create" class="headerlink" title="1、建表[create]"></a>1、建表[create]</h3><ol>
<li><p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">-- 字段1	 字段类型1，</span><br><span class="line">    id			int(8),</span><br><span class="line">    name		varchar(20),</span><br><span class="line">    birthday	date</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>创建表的同时指定</p>
<ul>
<li>存储引擎，缺省值是 InnoDB；</li>
<li>字符集（优先级大于对整个数据库全局设置字符集）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">-- 字段1	 字段类型1，</span><br><span class="line">    id			int(8),</span><br><span class="line">    name		varchar(20),</span><br><span class="line">    birthday	date</span><br><span class="line">)engine=InnoDB [Default] CharSet=utf8;</span><br></pre></td></tr></table></figure>

<p><strong>Tip：建表时如果想要同时指定存储引擎，则指定存储引擎的设置信息一定要放在最前面指定，否则会报错。</strong></p>
</li>
<li><p>快速创建相同结构相同的表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table new_user like user;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2、查看表-show-DESC"><a href="#2、查看表-show-DESC" class="headerlink" title="2、查看表[show/DESC]"></a>2、查看表[show/DESC]</h3><ol>
<li><p>查看当前数据库下的所有表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure></li>
<li><p>查看某个具体表的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC user；</span><br></pre></td></tr></table></figure></li>
<li><p>查看创建某个具体表的SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table user;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3、删除表-drop"><a href="#3、删除表-drop" class="headerlink" title="3、删除表[drop]"></a>3、删除表[drop]</h3><ol>
<li><p>直接删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table user;</span><br></pre></td></tr></table></figure></li>
<li><p>判断是否存在，存在则删除表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists user;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4、修改表结构"><a href="#4、修改表结构" class="headerlink" title="4、修改表结构"></a>4、修改表结构</h3><ol>
<li><p>修改表名<code>[alter table ...rename to...]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 方式1：</span><br><span class="line">alter table 表名 rename to 新表名;</span><br><span class="line">alter table users rename to user;</span><br><span class="line"></span><br><span class="line">-- 方式2：</span><br><span class="line">rename table 表名 to 新表名;</span><br><span class="line">RENAME TABLE users TO USER;</span><br></pre></td></tr></table></figure></li>
<li><p>修改字符集<code>[alter table... character set...]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aLter table 表名 character set 字符集;</span><br><span class="line">alter table user character set utf8;</span><br></pre></td></tr></table></figure></li>
<li><p>新增一列<code>[alter table...add...]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 列名 类型;</span><br><span class="line">ALTER TABLE user ADD hobby VARCHAR(32);</span><br></pre></td></tr></table></figure></li>
<li><p>修改列类型<code>[alter table...modify...]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 MODIFY 列名 新的类型;</span><br><span class="line">ALTER TABLE user MODIFY hobby INT(3);</span><br></pre></td></tr></table></figure></li>
<li><p>修改列名<code>[alter table... change...]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change 列名 新列名 类型;</span><br><span class="line">ALTER TABLE user CHANGE hobby newhobby VARCHAR(23);</span><br></pre></td></tr></table></figure></li>
<li><p>删除列<code>[alter table...drop...]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 列名;</span><br><span class="line">ALTER TABLE user DROP newhobby;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="4、DML"><a href="#4、DML" class="headerlink" title="4、DML"></a>4、DML</h1><blockquote>
<p><strong>DML；Data Manipulation Language；数组操作语言</strong></p>
</blockquote>
<p>操作的数据是表中的记录，主要用于<strong>对表中的记录进行增删改</strong>操作</p>
<h2 id="4-1、增"><a href="#4-1、增" class="headerlink" title="4.1、增"></a>4.1、增</h2><h3 id="1、插入记录"><a href="#1、插入记录" class="headerlink" title="1、插入记录"></a>1、插入记录</h3><p><img src="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">insert [into] 表名 </span><br><span class="line">[(字段名)] </span><br><span class="line">values</span><br><span class="line">(字段值)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO USER			-- 插入哪个表</span><br><span class="line">(username, passsword)		 -- 插入哪些字段</span><br><span class="line">VALUES						-- 表示插入数据</span><br><span class="line">(&quot;李四&quot;,&quot;8546&quot;)				-- 具体数据</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>insert的注意事项:</strong></p>
</blockquote>
<ol>
<li> 没有添加数据的字段会使用<code>NULL</code>填充。</li>
<li> 字符和<strong>日期型</strong>数据应该包含在引号中。</li>
</ol>
<h3 id="2、蠕虫复制"><a href="#2、蠕虫复制" class="headerlink" title="2、蠕虫复制"></a>2、蠕虫复制</h3><p>​        将一张表中的数据复制到另一张表中。<strong>蠕虫复制</strong>只复制表数据，而不复制表结构，所以使用前必须保证向新表中插入数据时数据类型不会冲突。【最简单的方式可以使用<code>create table... like...</code>快速创建一张结构相同的表】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 1、将表user1中的所有数据复制到user2中</span><br><span class="line">insert into user2 select * from user1</span><br><span class="line"></span><br><span class="line">-- 2、将表user1中的部分列数据复制到user2中</span><br><span class="line">insert into user2(username, password) select username, password from user1</span><br></pre></td></tr></table></figure>





<h2 id="4-2、删"><a href="#4-2、删" class="headerlink" title="4.2、删"></a>4.2、删</h2><h3 id="1、删除表记录"><a href="#1、删除表记录" class="headerlink" title="1、删除表记录"></a>1、删除表记录</h3><ol>
<li><p>删除表中的所有记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from user; </span><br></pre></td></tr></table></figure></li>
<li><p>删除表中的指定记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from user where 条件表达式;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用<code>truncate</code>删除表中的记录</strong></p>
<ul>
<li>相当于删除表的结构，再重建一张表【只能在删除所有数据时使用】</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table user;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-3、改"><a href="#4-3、改" class="headerlink" title="4.3、改"></a>4.3、改</h2><h3 id="1、更新表记录"><a href="#1、更新表记录" class="headerlink" title="1、更新表记录"></a>1、更新表记录</h3><ol>
<li><p>更新某列上所有行的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update user</span><br><span class="line">set username=&quot;擎天柱&quot;; </span><br></pre></td></tr></table></figure></li>
<li><p>更新某列上的部分行的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update user </span><br><span class="line">set username=&quot;擎天柱&quot; </span><br><span class="line">[where 条件表达式]</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="5、DQL"><a href="#5、DQL" class="headerlink" title="5、DQL"></a>5、DQL</h1><blockquote>
<p><strong>DQL；Data QueryLanguage；</strong></p>
</blockquote>
<ul>
<li>  主要用于查询表中的记录。</li>
<li>  查询结果是一个虚拟表</li>
</ul>
<h2 id="5-1、简单查询"><a href="#5-1、简单查询" class="headerlink" title="5.1、简单查询"></a>5.1、简单查询</h2><p><img src="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2.png"></p>
<ol>
<li><p>查询表中所有记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br></pre></td></tr></table></figure></li>
<li><p>查询所有记录的某几列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age from user;</span><br></pre></td></tr></table></figure></li>
<li><p>清除重复值查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct * from user;</span><br></pre></td></tr></table></figure></li>
<li><p>查询结果参与运算</p>
<ul>
<li>某列数据和固定值运算</li>
<li>某列数据和其他列数据进行运算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 列名1 + 固定值 from 表名;</span><br><span class="line">select math + 5 form student; </span><br><span class="line"></span><br><span class="line"># ---------------------------------------</span><br><span class="line"></span><br><span class="line">select 列名1 + 列名2 from 表名;</span><br><span class="line">select *, (math+age) as 总成绩 form student; </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参与运算的元素必须是数值类型</strong></li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-2、条件查询"><a href="#5-2、条件查询" class="headerlink" title="5.2、条件查询"></a>5.2、条件查询</h2><h3 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 字段名</span><br><span class="line">from 表名</span><br><span class="line">where 条件;</span><br></pre></td></tr></table></figure>

<h3 id="2、运算符"><a href="#2、运算符" class="headerlink" title="2、运算符"></a>2、运算符</h3><h4 id="2-1、比较运算符"><a href="#2-1、比较运算符" class="headerlink" title="2.1、比较运算符"></a>2.1、比较运算符</h4><table>
<thead>
<tr>
<th align="center">比较运算符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&gt;、&gt;=、&lt;、&lt;=、=、&lt;&gt;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>between...and</code></td>
<td align="center">前后都是闭区间</td>
</tr>
<tr>
<td align="center"><code>in(集合)</code></td>
<td align="center">集合中的数据使用逗号分隔</td>
</tr>
<tr>
<td align="center"><code>like &#39;%李%&#39;</code></td>
<td align="center">模糊查询</td>
</tr>
<tr>
<td align="center"><code>is null</code></td>
<td align="center">不能写成<code>=NULL</code></td>
</tr>
</tbody></table>
<h5 id="2-1-1、通配符"><a href="#2-1-1、通配符" class="headerlink" title="2.1.1、通配符"></a>2.1.1、通配符</h5><table>
<thead>
<tr>
<th align="center">通配符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>%</code></td>
<td align="center">匹配任意多个字符串</td>
</tr>
<tr>
<td align="center"><code>_</code></td>
<td align="center">匹配一个字符串</td>
</tr>
</tbody></table>
<h4 id="2-2、逻辑运算符"><a href="#2-2、逻辑运算符" class="headerlink" title="2.2、逻辑运算符"></a>2.2、逻辑运算符</h4><table>
<thead>
<tr>
<th align="center">逻辑运算符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>and</code></td>
<td align="center">与</td>
</tr>
<tr>
<td align="center"><code>or</code></td>
<td align="center">或</td>
</tr>
<tr>
<td align="center"><code>not</code></td>
<td align="center">非</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-3、排序查询"><a href="#5-3、排序查询" class="headerlink" title="5.3、排序查询"></a>5.3、排序查询</h2><blockquote>
<ul>
<li><strong>单列排序</strong>：只按某一个字段进行排序。</li>
<li><strong>组合排序</strong>：同时对多个字段进行排序，如果第1个字段相等，则按第2个字段排序，以此类推。</li>
</ul>
</blockquote>
<p><img src="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 排序[DESC/ASC]</span><br><span class="line">select 字段名</span><br><span class="line">from 表名</span><br><span class="line">where 条件</span><br><span class="line">order by 字段名 DESC					-- 单列排序</span><br><span class="line">order by age DESC, grade ASC		   -- 组合排序[在age降序的基础上，对于年龄相同的再按grade升序]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>排序只影响数据的展示顺序，而不会影响数据库中数据的保存顺序。</p>
</blockquote>
<hr>
<h2 id="5-4、聚合函数"><a href="#5-4、聚合函数" class="headerlink" title="5.4、聚合函数"></a>5.4、聚合函数</h2><ul>
<li>  之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断。    而使用聚合函数查询则是<strong>纵向查询</strong>，它是对一列的值进行计算，然后返回一个结果值。</li>
<li>  聚合函数是对横向查询结果值的统计，首先必须要经过横向查询这一步骤，只是没有在最后展示出来，展示出来的是聚合后的结果。</li>
</ul>
<p><img src="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/5%E4%B8%AA%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0.png"></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 聚合函数(列名) form 表名;</span><br><span class="line">select count(*) from user;</span><br><span class="line">select max(age) from user;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>聚合函数注意事项</strong>：</p>
</blockquote>
<p><strong>聚合函数会自动忽略 <code>NULL</code> 值对应的记录</strong></p>
<p>聚合函数不会统计<code>NULL</code>对应的记录，建议统计时尽量不要选择有可能为<code>NULL</code>的字段。</p>
<p>如果要求需要把 <code>NULL</code> 也统计进去的话，可以使用<code>ifnull()</code>函数将 <code>NULL</code> 值转换为一个自定义值，这样统计个数时就不会遗漏。</p>
<ul>
<li><p><code>IFNULL()</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(列名, 自定义值)	-- 如果列名不为NULL，返回原值；如果为NULL，返回自定义的值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询id字段，如果为null，则使用0代替</span><br><span class="line">select ifnull(id, 0) form user;</span><br></pre></td></tr></table></figure></li>
<li><p><code>聚合函数 + ifnull()函数</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(ifnull(id, 0)) form user;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="5-5、分组"><a href="#5-5、分组" class="headerlink" title="5.5、分组"></a>5.5、分组</h2><ul>
<li>  <strong>group by</strong> 的真正执行顺序在 WHERE 之后，一般情况下是对经过 WHRER 筛选后的中间表继续进行分组，同类型的数据作为一组。</li>
<li>  一般当我们使用某个字段对数据进行分组后，在查询的时候最好将这个字段查询出来，否则看不到查询的数据是属于哪一组的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 分组</span><br><span class="line">select 字段名</span><br><span class="line">from 表名</span><br><span class="line">group by 分组字段</span><br><span class="line">[having 条件]</span><br></pre></td></tr></table></figure>



<h3 id="1、having-和-where的区别"><a href="#1、having-和-where的区别" class="headerlink" title="1、having 和 where的区别"></a>1、having 和 where的区别</h3><table>
<thead>
<tr>
<th align="center">where</th>
<th align="center">having</th>
</tr>
</thead>
<tbody><tr>
<td align="center">在分组之前执行</td>
<td align="center">在分组之后执行</td>
</tr>
<tr>
<td align="center"><em><code>where</code>后面不可以使用聚合函数</em></td>
<td align="center"><em><code>having</code>后面可以使用聚合函数</em></td>
</tr>
</tbody></table>
<hr>
<h2 id="5-6、分页"><a href="#5-6、分页" class="headerlink" title="5.6、分页"></a>5.6、分页</h2><h3 id="1、语法-1"><a href="#1、语法-1" class="headerlink" title="1、语法"></a>1、语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">limit [offset,] length;</span><br><span class="line">-- offset：起始行数，从0开始。如果省略，缺省值就是0。</span><br><span class="line">-- length：返回的行数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询user表中的数据，从第3条开始显示，显示6条</span><br><span class="line">select * from user </span><br><span class="line">limit 2,6</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="6、DCL"><a href="#6、DCL" class="headerlink" title="6、DCL"></a>6、DCL</h1><blockquote>
<p>DCL；Data Control Language；</p>
</blockquote>
<ul>
<li>  DCL 主要用于 <strong>授权（grant）、收权（revoke）</strong>。</li>
</ul>
<p>我们在自己的电脑上安装的数据库使用的都是root超级管理员用户，拥有全部的权限。    </p>
<p>在实际公司中，一个数据库服务器上一般同时运行着很多个项目的数据库，一般的编程人员是不可能拥有超级管理员权限的，所以我们应该根据不同的项目创建不同的用户，分配不同的权限来管理和维护数据库。</p>
<hr>
<h1 id="7、数据库表的约束"><a href="#7、数据库表的约束" class="headerlink" title="7、数据库表的约束"></a>7、数据库表的约束</h1><blockquote>
<p>对表中的数据进行限定，保证数据的正确性、有效性和完整性。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">约束名</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主键</td>
<td align="center"><code>primary key</code></td>
</tr>
<tr>
<td align="center">唯一</td>
<td align="center"><code>unique</code></td>
</tr>
<tr>
<td align="center">非空</td>
<td align="center"><code>not null</code></td>
</tr>
<tr>
<td align="center">外键</td>
<td align="center"><code>foreign key</code></td>
</tr>
<tr>
<td align="center">检查约束</td>
<td align="center"><code>check[MySQL不支持]</code></td>
</tr>
</tbody></table>
<h2 id="7-1、主键约束"><a href="#7-1、主键约束" class="headerlink" title="7.1、主键约束"></a>7.1、主键约束</h2><blockquote>
<p>用来唯一标识数据库中的每一条记录。</p>
</blockquote>
<ul>
<li>通常不用业务字段作为主键，而是单独给每张表设计一个<code>id</code>字段作为主键。[主键是给数据库和程序使用的，不是展示给用户看的，所以主键有没有含义没关系，只要<strong>唯一、非空</strong>即可]</li>
</ul>
<h3 id="1、创建表的时候添加主键"><a href="#1、创建表的时候添加主键" class="headerlink" title="1、创建表的时候添加主键"></a>1、创建表的时候添加主键</h3><ol>
<li><p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 primary key</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int(8) primary key,	</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2、已有表中添加主键"><a href="#2、已有表中添加主键" class="headerlink" title="2、已有表中添加主键"></a>2、已有表中添加主键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add primary key(字段名);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table users add primary key(id);</span><br></pre></td></tr></table></figure>

<h3 id="3、删除主键"><a href="#3、删除主键" class="headerlink" title="3、删除主键"></a>3、删除主键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop primary key(字段名);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table users drop primary key;</span><br></pre></td></tr></table></figure>

<h3 id="4、主键自增"><a href="#4、主键自增" class="headerlink" title="4、主键自增"></a>4、主键自增</h3><blockquote>
<p><code>auto_increment</code>    表示主键自增（字段类型必须是整数类型）</p>
</blockquote>
<ol>
<li><p>创建表时指定起始值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 修改自增长的默认起始值[默认起始值是1]</span><br><span class="line">create table 表名(</span><br><span class="line">	列名 int primary key auto_increment	</span><br><span class="line">)auto_increment=起始值;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int primary key auto_increment	</span><br><span class="line">)auto_increment=3;</span><br></pre></td></tr></table></figure></li>
<li><p>建表完成后修改自增长起始值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 auto_increment=起始值;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user auto_increment=3;</span><br></pre></td></tr></table></figure></li>
<li><p><code>delete</code> 和 <code>truncate</code> 对自增长的影响：</p>
<ul>
<li><code>delete</code>：删除所有记录后，自增长没有影响，从上次记录出继续增长；</li>
<li><code>truncate</code>：删除后，自增重新从 0 开始。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="7-2、唯一约束"><a href="#7-2、唯一约束" class="headerlink" title="7.2、唯一约束"></a>7.2、唯一约束</h2><h3 id="1、语法-2"><a href="#1、语法-2" class="headerlink" title="1、语法"></a>1、语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 unique</span><br></pre></td></tr></table></figure>

<h3 id="2、某一列中存在多个NULL符合唯一约束吗？"><a href="#2、某一列中存在多个NULL符合唯一约束吗？" class="headerlink" title="2、某一列中存在多个NULL符合唯一约束吗？"></a>2、某一列中存在多个NULL符合唯一约束吗？</h3><ul>
<li>符合，<code>NULL</code>没有数据，不存在重复的问题。</li>
</ul>
<hr>
<h2 id="7-3、非空约束"><a href="#7-3、非空约束" class="headerlink" title="7.3、非空约束"></a>7.3、非空约束</h2><blockquote>
<p>某一列不能为<code>NULL</code></p>
</blockquote>
<h3 id="1、语法-3"><a href="#1、语法-3" class="headerlink" title="1、语法"></a>1、语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 NOT NULL</span><br></pre></td></tr></table></figure>

<h3 id="2、默认值"><a href="#2、默认值" class="headerlink" title="2、默认值"></a>2、默认值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 Default 默认值</span><br></pre></td></tr></table></figure>

<h3 id="3、如果一个字段设置了非空和唯一约束，该字段和主键的区别？"><a href="#3、如果一个字段设置了非空和唯一约束，该字段和主键的区别？" class="headerlink" title="3、如果一个字段设置了非空和唯一约束，该字段和主键的区别？"></a>3、如果一个字段设置了非空和唯一约束，该字段和主键的区别？</h3><ol>
<li>一个表中只能有一个主键，而可以同时有多个具有非空且唯一约束的字段(列)。【虽然主键只能有一个，但是主键可以是单个字段(列)，也可以是多个字段(列)（复合主键）】</li>
<li>自增长只能用在主键上。</li>
</ol>
<hr>
<h2 id="7-4、外键约束"><a href="#7-4、外键约束" class="headerlink" title="7.4、外键约束"></a>7.4、外键约束</h2><h3 id="1、单表保存数据的缺点"><a href="#1、单表保存数据的缺点" class="headerlink" title="1、单表保存数据的缺点"></a>1、单表保存数据的缺点</h3><ol>
<li>数据冗余。</li>
<li>增删改存在问题。</li>
</ol>
<h3 id="2、什么是外键约束"><a href="#2、什么是外键约束" class="headerlink" title="2、什么是外键约束"></a>2、什么是外键约束</h3><ol>
<li>什么是外键<ul>
<li>在从表中与主表主键对应的那一列。</li>
</ul>
</li>
<li><strong>主表</strong><ul>
<li><strong>一方</strong>，用来限制从表。</li>
</ul>
</li>
<li><strong>从表</strong><ul>
<li><strong>多方</strong>：使用主表的数据，被主表限制。【外键位于从表中】</li>
</ul>
</li>
</ol>
<h3 id="3、外键约束的语法"><a href="#3、外键约束的语法" class="headerlink" title="3、外键约束的语法"></a>3、外键约束的语法</h3><ol>
<li><p>新建表时增加外键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 外键约束与其它类型约束在格式上不同的地方在于：其它约束可以直接跟在字段类型后面，</span><br><span class="line"># 而外键约束需要另起一行专门书写，与字段之间用逗号`,`分开。</span><br><span class="line">[constraint] [外键约束名称] foreign key(外键字段名) references 主表名(主键字段名);</span><br></pre></td></tr></table></figure></li>
<li><p>已有表中增加外键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 从表名 add [constraint] [外键约束名称] foreign key(外键字段名) references 主表名(主键字段名);</span><br></pre></td></tr></table></figure></li>
<li><p>删除外键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 从表名 drop foreign key [外键约束名称];</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4、外键的级联操作"><a href="#4、外键的级联操作" class="headerlink" title="4、外键的级联操作"></a>4、外键的级联操作</h3><h4 id="4-1、是什么？"><a href="#4-1、是什么？" class="headerlink" title="4.1、是什么？"></a>4.1、是什么？</h4><ul>
<li>  <strong>在修改和删除主表的主键时，同时更新或删除从表的外键值</strong>，称为级联操作。</li>
</ul>
<h4 id="4-2、级联操作语法"><a href="#4-2、级联操作语法" class="headerlink" title="4.2、级联操作语法"></a>4.2、级联操作语法</h4><ul>
<li><strong>只能在创建表的时候创建级联关系，创建表完成之后不能再修改级联关系了</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">级联操作</th>
<th align="center">语法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">级联更新</td>
<td align="center"><code>on update cascade</code></td>
<td align="center">更新主表中的主键，从表中的外键列也自动同步更新</td>
</tr>
<tr>
<td align="center">级联删除</td>
<td align="center"><code>on delete cascade</code></td>
<td align="center">删除主表中的主键，从表中的外键列也自动同步更新</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    dep_id int,		-- 外键列</span><br><span class="line">    foreign key (dep_id) references department(id) on update casade on delete casade</span><br><span class="line">)</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="8、表与表之间的关系"><a href="#8、表与表之间的关系" class="headerlink" title="8、表与表之间的关系"></a>8、表与表之间的关系</h1><p><img src="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/%E8%A1%A8%E4%B8%8E%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p>
<hr>
<h1 id="9、数据库设计"><a href="#9、数据库设计" class="headerlink" title="9、数据库设计"></a>9、数据库设计</h1><h2 id="9-1、数据库范化"><a href="#9-1、数据库范化" class="headerlink" title="9.1、数据库范化"></a>9.1、数据库范化</h2><h3 id="1、是什么？"><a href="#1、是什么？" class="headerlink" title="1、是什么？"></a>1、是什么？</h3><ul>
<li>  顾名思义，数据库范化就是数据库规范化。    </li>
<li>  好的数据库设计对数据库的存储性能和后期程序的开发都会产生重要的影响，建立科学的，规范的数据库就需要满足一些规范来优化数据的存储和设计，这些规范就称为范式。</li>
<li>  总结：<strong>范式就是设计一个好的、规范的数据库需要满足的规范</strong>。</li>
</ul>
<h2 id="9-2、数据库范式"><a href="#9-2、数据库范式" class="headerlink" title="9.2、数据库范式"></a>9.2、数据库范式</h2><p>目前关系型数据库共有6种范式：</p>
<blockquote>
<ul>
<li>  第一范式（1NF）</li>
<li>  第二范式（2NF）</li>
<li>  第三范式（3NF）</li>
<li>  第四范式（4NF）</li>
<li>  第五范式（5NF，又称为完美范式）</li>
<li>  巴斯-科德范式（BCNF）</li>
</ul>
</blockquote>
<ul>
<li>  一般来说，数据库设计满足第三范式（3NF）就可以了。</li>
<li>  高等级的范式必然满足低等级范式的需求。</li>
<li>  范式的等级越高，数据库越完美，但速度越慢。（满足的要求多必然是要以运行速度作为代价的）</li>
</ul>
<blockquote>
<p>  <strong>三大范式小结</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">范式</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>1NF</em></td>
<td align="left">原子性：表中每列不可再拆分</td>
</tr>
<tr>
<td align="center"><em>2NF</em></td>
<td align="left">消除局部依赖[，一张表只描述一件事情]</td>
</tr>
<tr>
<td align="center"><em>3NF</em></td>
<td align="left">消除传递依赖[，表中的每一列都直接依赖于主键，而不是通过其它列间接依赖于主键]</td>
</tr>
</tbody></table>
<hr>
<h2 id="9-3-三大范式"><a href="#9-3-三大范式" class="headerlink" title="9.3    三大范式"></a>9.3    三大范式</h2><blockquote>
<p>  <strong>数据库表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
<th align="center">系名</th>
<th align="center">系主任</th>
<th align="center">课程名称</th>
<th align="center">分数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">黄猿</td>
<td align="center">经济系</td>
<td align="center">卡普</td>
<td align="center">高等数学</td>
<td align="center">95</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">黄猿</td>
<td align="center">经济系</td>
<td align="center">卡普</td>
<td align="center">大学英语</td>
<td align="center">87</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">黄猿</td>
<td align="center">经济系</td>
<td align="center">卡普</td>
<td align="center">计算机基础</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">王路飞</td>
<td align="center">体育系</td>
<td align="center">三木</td>
<td align="center">人体构造学</td>
<td align="center">77</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">王路飞</td>
<td align="center">体育系</td>
<td align="center">三木</td>
<td align="center">大学英语</td>
<td align="center">87</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">王路飞</td>
<td align="center">体育系</td>
<td align="center">三木</td>
<td align="center">实践课</td>
<td align="center">79</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">王篮球</td>
<td align="center">体育系</td>
<td align="center">三木</td>
<td align="center">人体构造学</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">王篮球</td>
<td align="center">体育系</td>
<td align="center">三木</td>
<td align="center">大学英语</td>
<td align="center">86</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">王篮球</td>
<td align="center">体育系</td>
<td align="center">三木</td>
<td align="center">实践课</td>
<td align="center">74</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><del>计算机系</del></td>
<td align="center"><del>柯南</del></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>当前数据库表的设计存在的问题：</p>
<ol>
<li><p> 存在非常严重的数据冗余：姓名、系名、系主任；</p>
</li>
<li><p> 数据添加存在问题：假设新开设系和系主任时，由于没有学生，数据不合法</p>
</li>
<li><p>数据删除存在问题：假设某一个系的所有同学都毕业了，在将这些同学的数据删除时，会将系的数据一起删除。</p>
<p> 假设体育系的所有同学（这里只有两个）全都毕业了，在删除王路飞和王篮球的个人信息后，发现表中关于体育系的全部信息也被一起删除了，这是不合理的。</p>
</li>
</ol>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><blockquote>
<p>  <strong>函数依赖</strong></p>
</blockquote>
<ul>
<li>  如果通过 A 属性（属性组）的值，可以确定唯一的 B 属性的值，则称 B 依赖于 A。</li>
<li>  表示为：<code>A --&gt; B</code></li>
<li>  例如：<code>学号 --&gt; 姓名</code>    <code>（学号，课程名称） --&gt; 分数</code></li>
</ul>
<blockquote>
<p>  <strong>完全函数依赖</strong></p>
</blockquote>
<ul>
<li>  如果通过 A 属性组中所有的值，才可以确定唯一的 B 属性的值，则称 B 完全依赖于 A。</li>
<li>  表示为：<code>(A1 &amp; A2 &amp; ...) --&gt; B</code></li>
<li>  例如：<code>（学号 &amp; 课程名称） --&gt; 分数</code></li>
</ul>
<blockquote>
<p>  <strong>部分函数依赖</strong></p>
</blockquote>
<ul>
<li>  如果通过 A 属性组中的部分值，就可以确定唯一的 B 属性的值，则称 B 部分依赖于 A。</li>
<li>  表示为：<code>(A1, A2, A3) --&gt; B ，但是 (A1, A2) --&gt; B</code> </li>
<li>  例如：<code>（学号, 课程名称） --&gt; 姓名</code> ，但是仅仅只有学号也能唯一确定姓名，课程名称是可有可无的条件。</li>
</ul>
<blockquote>
<p>  <strong>传递函数依赖</strong></p>
</blockquote>
<ul>
<li>  如果通过 A 属性（属性组）的值，可以确定唯一 B 属性（属性组）的值，再通过 B 属性（属性组）的值可以确定唯一 C 属性的值，则称 C 属性（属性组）的值，则称 C 传递依赖于 A。</li>
<li>  表示为：<code>A --&gt; B, B --&gt; C  ==&gt; C 传递依赖于 A </code></li>
<li>  例如：<code>学号 --&gt; 系名，系名 --&gt; 系主任</code></li>
</ul>
<blockquote>
<p>  <strong>码</strong></p>
</blockquote>
<ul>
<li>  在一张表中，如果一个属性（属性组），被其它所有属性完全依赖，则称这个属性（属性组）为该表的码。</li>
<li>  例如：该表中的码为：<code>（学号+课程名称）</code></li>
<li>  <strong>主属性</strong>：码属性组中的所有属性。</li>
<li>  <strong>非主属性</strong>：码属性（组）之外的属性。</li>
</ul>
<h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><ul>
<li>  <strong>第一范式（1NF）</strong>：数据库表中的每一列都是不可分割的原子数据项。</li>
<li>  <strong>第二范式（2NF）</strong>：在 1NF 的基础上，非码属性必须完全依赖于码。[消除局部依赖]</li>
<li>  <strong>第三范式（3NF）</strong>：在 2NF 的基础上，任何非主属性不依赖于其它非主属性。[消除传递依赖]</li>
</ul>
<blockquote>
<p>  <strong>第二范式</strong></p>
</blockquote>
<p>在上文的数据库表中，存在局部依赖，所以将数据库表拆分成两张表：</p>
<ul>
<li>  <strong>成绩表</strong>[分数完全依赖于 （学号+课程名称）]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">课程名称</th>
<th align="center">分数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">高等数学</td>
<td align="center">95</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">大学英语</td>
<td align="center">87</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">计算机基础</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">人体构造学</td>
<td align="center">77</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">大学英语</td>
<td align="center">87</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">实践课</td>
<td align="center">79</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">人体构造学</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">大学英语</td>
<td align="center">86</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">实践课</td>
<td align="center">74</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>学生表</strong>[（姓名，系名，系主任）完全依赖于学号]</li>
</ul>
<table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
<th align="center">系名</th>
<th align="center">系主任</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">黄猿</td>
<td align="center">经济系</td>
<td align="center">卡普</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">王路飞</td>
<td align="center">体育系</td>
<td align="center">三木</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">王篮球</td>
<td align="center">体育系</td>
<td align="center">三木</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><del>计算机系</del></td>
<td align="center"><del>柯南</del></td>
</tr>
</tbody></table>
<p><strong>2NF 解决的问题：</strong></p>
<ol>
<li> <del>存在非常严重的数据冗余：姓名、系名、系主任</del>；</li>
<li> 数据添加存在问题：假设新开设系和系主任时，由于没有学生，数据不合法</li>
<li> 数据删除存在问题：假设某一个系的所有同学都毕业了，在将这些同学的数据删除时，会将系的数据一起删除。</li>
</ol>
<blockquote>
<p>  <strong>第三范式</strong></p>
</blockquote>
<p>第二范式解决不了的问题，可以交给第三范式来解决，在上文的学生表中还存在传递依赖：<code>学号 --&gt; 系名, 系名 --&gt; 系主任</code>，即系主任传递依赖于学号。所以可以将学生表再进行拆分：</p>
<ul>
<li>  学生表</li>
</ul>
<table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
<th align="center">系名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">黄猿</td>
<td align="center">经济系</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">王路飞</td>
<td align="center">体育系</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">王篮球</td>
<td align="center">体育系</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>系表</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">系名</th>
<th align="center">系主任</th>
</tr>
</thead>
<tbody><tr>
<td align="center">经济系</td>
<td align="center">卡普</td>
</tr>
<tr>
<td align="center">体育系</td>
<td align="center">三木</td>
</tr>
<tr>
<td align="center">计算机系</td>
<td align="center">柯南</td>
</tr>
</tbody></table>
<p><strong>3NF 解决的问题：</strong></p>
<ol>
<li> <del>数据添加存在问题：假设新开设系和系主任时，由于没有学生，数据不合法</del></li>
<li> <del>数据删除存在问题：假设某一个系的所有同学都毕业了，在将这些同学的数据删除时，会将系的数据一起删除。</del></li>
</ol>
<hr>
<h1 id="10、多表查询"><a href="#10、多表查询" class="headerlink" title="10、多表查询"></a>10、多表查询</h1><h2 id="10-1、多表查询分类"><a href="#10-1、多表查询分类" class="headerlink" title="10.1、多表查询分类"></a>10.1、多表查询分类</h2><p><img src="/2020/10/09/MySql%E5%9F%BA%E7%A1%80/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%88%86%E7%B1%BB.png"></p>
<h2 id="10-2、笛卡尔积"><a href="#10-2、笛卡尔积" class="headerlink" title="10.2、笛卡尔积"></a>10.2、笛卡尔积</h2><h3 id="1、是什么"><a href="#1、是什么" class="headerlink" title="1、是什么"></a>1、是什么</h3><h3 id="2、为什么要消除笛卡尔积"><a href="#2、为什么要消除笛卡尔积" class="headerlink" title="2、为什么要消除笛卡尔积"></a>2、为什么要消除笛卡尔积</h3><ul>
<li>我们发现由并不是所有由笛卡尔积连接起来的数据组合都是有用的，所以需要通过设置条件过滤掉没有用的数据。</li>
</ul>
<h3 id="3、如何消除笛卡尔积？"><a href="#3、如何消除笛卡尔积？" class="headerlink" title="3、如何消除笛卡尔积？"></a>3、如何消除笛卡尔积？</h3><ul>
<li>使用<strong>内连接</strong>连接两张关系表。</li>
</ul>
<hr>
<h2 id="10-3、内连接"><a href="#10-3、内连接" class="headerlink" title="10.3、内连接"></a>10.3、内连接</h2><h3 id="1、隐式内连接"><a href="#1、隐式内连接" class="headerlink" title="1、隐式内连接"></a>1、隐式内连接</h3><ul>
<li>  不使用 <strong>join</strong> 关键字，而是使用 <strong>where</strong> 关键字连接两张表。</li>
</ul>
<h3 id="2、显式内连接"><a href="#2、显式内连接" class="headerlink" title="2、显式内连接"></a>2、显式内连接</h3><ul>
<li>  使用<code>[inner] join... on</code>语句连接2张关系表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表1 [inner] join 表2 on 条件</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="10-3、外连接"><a href="#10-3、外连接" class="headerlink" title="10.3、外连接"></a>10.3、外连接</h2><h3 id="1、左外连接"><a href="#1、左外连接" class="headerlink" title="1、左外连接"></a>1、左外连接</h3><blockquote>
<p>使用<code>left [outer] join... on</code>连接2张表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表1 left [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure>



<h3 id="2、右外连接"><a href="#2、右外连接" class="headerlink" title="2、右外连接"></a>2、右外连接</h3><blockquote>
<p>使用<code>right [outer] join... on</code>连接2张表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表1 right [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure>



<h3 id="3、全外连接"><a href="#3、全外连接" class="headerlink" title="3、全外连接"></a>3、全外连接</h3><hr>
<h1 id="11、子查询"><a href="#11、子查询" class="headerlink" title="11、子查询"></a>11、子查询</h1><h2 id="11-1、是什么"><a href="#11-1、是什么" class="headerlink" title="11.1、是什么"></a>11.1、是什么</h2><blockquote>
<ol>
<li>一个查询语句的结果作为另一个查询的条件；</li>
<li>有查询的嵌套，内部的查询称为子查询；</li>
<li>子查询的结果需要使用小括号括起来。</li>
</ol>
</blockquote>
<h2 id="11-1、子查询的3种情况"><a href="#11-1、子查询的3种情况" class="headerlink" title="11.1、子查询的3种情况"></a>11.1、子查询的3种情况</h2><h3 id="1、子查询的结果是单行单列"><a href="#1、子查询的结果是单行单列" class="headerlink" title="1、子查询的结果是单行单列"></a>1、子查询的结果是单行单列</h3><blockquote>
<p>子查询的结果是单行单列。肯定是在<code>where</code>后面作为条件，父查询一般使用比较运算符，如：<code>&gt;、&lt;、=、&lt;&gt;</code>等。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from 表1 </span><br><span class="line">where 字段=(子查询)</span><br></pre></td></tr></table></figure>



<h3 id="2、子查询的结果是多行单列"><a href="#2、子查询的结果是多行单列" class="headerlink" title="2、子查询的结果是多行单列"></a>2、子查询的结果是多行单列</h3><blockquote>
<p>子查询的结果是多行单列。</p>
<p>可以跟在<code>from</code>后面作为表；</p>
<p>也可以跟在<code>where</code>后面作为条件，父查询使用<code>IN</code>运算符。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from (子查询) 表别名</span><br><span class="line">where 字段 like %李%;</span><br><span class="line"></span><br><span class="line">-- ---------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">select * from 表1 </span><br><span class="line">where 字段 in (子查询);</span><br></pre></td></tr></table></figure>





<h3 id="3、子查询的结果是多列"><a href="#3、子查询的结果是多列" class="headerlink" title="3、子查询的结果是多列"></a>3、子查询的结果是多列</h3><blockquote>
<p>子查询的结果只要是多列，肯定在<code>from</code>后面作为表。</p>
</blockquote>
<p><strong>Tip：子查询作为表时必须为这张表取一个别名，否则这张表没有名称则无法访问表中的数据。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from (子查询) 表别名</span><br><span class="line">where 条件;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="12、事务"><a href="#12、事务" class="headerlink" title="12、事务"></a>12、事务</h1><p><a href>超链接</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/07/SpringCloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/07/SpringCloud/" class="post-title-link" itemprop="url">SpringCould</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-07 22:09:31" itemprop="dateCreated datePublished" datetime="2020-10-07T22:09:31+08:00">2020-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-03 22:31:09" itemprop="dateModified" datetime="2021-09-03T22:31:09+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringCould/" itemprop="url" rel="index"><span itemprop="name">SpringCould</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1、系统架构演变"><a href="#1、系统架构演变" class="headerlink" title="1、系统架构演变"></a>1、系统架构演变</h1><p>随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构。</p>
<p><img src="/2020/10/07/SpringCloud/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98.png"></p>
<p>​    </p>
<h2 id="1-1-集中式架构"><a href="#1-1-集中式架构" class="headerlink" title="1.1. 集中式架构"></a>1.1. 集中式架构</h2><p>当网站流量很小时，只需一个应用，就可以将所有功能都部署在一起，减少了部署节点和成本。</p>
<p><em>此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。</em></p>
<p> <img src="/2020/10/07/SpringCloud/1525529091749.png" alt="1525529091749"></p>
<blockquote>
<p>存在的问题：</p>
<ul>
<li>代码耦合度高，开发维护困难</li>
<li>无法针对不同模块进行针对性优化</li>
<li>无法水平扩展</li>
<li>单点容错率低，并发能力差[单点容错率低：应用程序部署在一个服务器上，一旦该服务器出现故障，那么该程序就直接挂了]</li>
</ul>
</blockquote>
<hr>
<h2 id="1-2-垂直拆分"><a href="#1-2-垂直拆分" class="headerlink" title="1.2.垂直拆分"></a>1.2.垂直拆分</h2><p>当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：</p>
<p> <img src="/2020/10/07/SpringCloud/1525529671801.png" alt="1525529671801"></p>
<blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>不同业务功能部署在不同的服务器上，系统拆分实现了流量分担，解决了并发问题</li>
<li>可以对不同模块进行针对性优化</li>
<li>方便水平扩展，负载均衡，容错率提高</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><em>系统间相互独立，会有很多重复开发工作，影响开发效率</em></li>
</ul>
</blockquote>
<hr>
<h2 id="1-3-分布式服务"><a href="#1-3-分布式服务" class="headerlink" title="1.3.分布式服务"></a>1.3.分布式服务</h2><p>当垂直应用越来越多，应用之间交互不可避免，将<strong>通用业务</strong>抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p>
<p>此时，用于提高业务复用及整合的分布式调用是关键。</p>
<p> <img src="/2020/10/07/SpringCloud/1525530657919.png" alt="1525530657919"></p>
<blockquote>
<p>优点：</p>
<ul>
<li>将基础服务进行了抽取，供系统中的其它模块调用，提高了代码复用和开发效率</li>
</ul>
<p>缺点：</p>
<ul>
<li><em>系统间耦合度变高，调用关系错综复杂，难以维护</em></li>
</ul>
</blockquote>
<h2 id="1-4-服务治理（SOA）"><a href="#1-4-服务治理（SOA）" class="headerlink" title="1.4.服务治理（SOA）"></a>1.4.服务治理（SOA）</h2><blockquote>
<p><strong><code>SOA(Service-Oriented Architecture)：面向服务的架构</code></strong> </p>
</blockquote>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 <strong>资源调度和治理中心(SOA)</strong> 是关键。</p>
<p><img src="/2020/10/07/SpringCloud/1525530804753.png" alt="1525530804753"></p>
<blockquote>
<p><strong>Before：</strong></p>
<ul>
<li>服务越来越多，需要管理每个服务的地址</li>
<li>调用关系错综复杂，难以理清依赖关系</li>
<li>服务过多，服务状态难以管理，无法根据服务情况动态管理</li>
</ul>
<p><strong>After：</strong></p>
<ul>
<li>服务注册中心，实现了服务自动注册和发现，无需人为记录服务地址</li>
<li>服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系</li>
<li>动态监控服务状态监控报告，人为控制服务状态</li>
</ul>
<p>缺点：</p>
<ul>
<li>服务间会有依赖关系，一旦某个环节出错会影响较大</li>
<li>服务关系复杂，运维、测试部署困难，不符合DevOps思想</li>
</ul>
</blockquote>
<h2 id="1-5-微服务"><a href="#1-5-微服务" class="headerlink" title="1.5.微服务"></a>1.5.微服务</h2><p>前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别：</p>
<p><img src="/2020/10/07/SpringCloud/1525532344817.png" alt="1525532344817"></p>
<blockquote>
<p>微服务的特点：</p>
<ul>
<li><strong>单一职责</strong>：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li>
<li><strong>面向服务</strong>：面向服务是说每个服务都对外暴露服务接口。并不关心接口调用方的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。</li>
<li><strong>自治</strong>：自治是说服务间互相独立，互不干扰<ul>
<li>团队独立：每个服务都是一个独立的开发团队，人数不能过多。</li>
<li>技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉</li>
<li>前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口</li>
<li>数据库分离：每个服务都使用自己的数据源</li>
<li>部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>微服务结构图</strong>：</p>
<p><img src="/2020/10/07/SpringCloud/1526860071166.png" alt="1526860071166"></p>
<p><strong>微服务 vs. SOA</strong></p>
<ol>
<li>微服务比SOA更细粒度。</li>
<li>每个微服务都是一个独立的服务，而每个SOA并不一定是独立的服务。</li>
</ol>
<hr>
<h1 id="2、远程调用方式"><a href="#2、远程调用方式" class="headerlink" title="2、远程调用方式"></a>2、远程调用方式</h1><p>无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？</p>
<blockquote>
<p>常见的远程调用方式有以下几种：</p>
<ol>
<li><code>RPC(Remote Produce Call)</code>：<strong>远程过程调用</strong><ul>
<li>类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型</li>
</ul>
</li>
<li><code>Http</code>：<ul>
<li>http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。</li>
<li>现在热门的Rest风格，就可以通过http协议来实现。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="2-1、RPC"><a href="#2-1、RPC" class="headerlink" title="2.1、RPC"></a>2.1、RPC</h2><p>RPC是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。</p>
<blockquote>
<p>通过上面的概念，我们可以知道，实现RPC主要是做到两点： </p>
<ul>
<li><strong>实现远程调用其他计算机的服务</strong>[远程调用]<ul>
<li>要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求数据传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点：<ul>
<li>1）采用何种网络通讯协议？<ul>
<li>现在比较流行的RPC框架，都会采用TCP作为底层传输协议</li>
</ul>
</li>
<li>2）数据传输的格式怎样？<ul>
<li>两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网络中传输需要进行序列化，所以还需要约定统一的序列化的方式。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>像调用本地服务一样调用远程服务</strong> [过程调用]<ul>
<li>如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>RPC调用流程图</strong>：</p>
<p><img src="/2020/10/07/SpringCloud/1525568965976.png" alt="1525568965976"></p>
<h2 id="2-2、HTTP"><a href="#2-2、HTTP" class="headerlink" title="2.2、HTTP"></a>2.2、HTTP</h2><p>HTTP协议(超文本传输协议)是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。</p>
<blockquote>
<ul>
<li>RPC协议并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。</li>
<li>HTTP协议中还定义了资源定位的路径，RPC中并不需要</li>
<li>RPC需要满足像调用本地服务一样调用远程服务，也就是说会在API层面对调用过程进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。  <strong>[Http请求没有对调用过程进行封装，也就是说，本来由浏览器进行的对Http请求和响应的封装现在要我们自己在Java代码中实现]</strong><ul>
<li>优点：RPC方式更加透明，对用户更方便。HTTP方式更灵活，没有规定API和语言，跨语言、跨平台</li>
<li>缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。</li>
</ul>
</li>
</ul>
</blockquote>
<p>例如我们通过浏览器访问网站，就是通过HTTP协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。</p>
<p><img src="/2020/10/07/SpringCloud/1525569352313.png" alt="1525569352313"></p>
<h2 id="2-3、如何选择？"><a href="#2-3、如何选择？" class="headerlink" title="2.3、如何选择？"></a>2.3、如何选择？</h2><p>既然两种方式都可以实现远程调用，我们该如何选择呢？</p>
<ul>
<li>速度来看，RPC要比HTTP更快，虽然底层都是TCP，但是HTTP协议的信息往往比较臃肿，不过可以采用gzip压缩。</li>
<li>难度来看，RPC实现较为复杂，HTTP相对比较简单</li>
<li>灵活性来看，HTTP更胜一筹，因为它不关心实现细节，跨平台、跨语言。</li>
</ul>
<p>因此，两者都有不同的使用场景：</p>
<ul>
<li>如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。</li>
<li>如果需要更加灵活，跨语言、跨平台，显然http更合适</li>
</ul>
<p>那么我们该怎么选择呢？</p>
<p>微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。</p>
<hr>
<h1 id="3、HTTP客户端工具"><a href="#3、HTTP客户端工具" class="headerlink" title="3、HTTP客户端工具"></a>3、HTTP客户端工具</h1><blockquote>
<p>因为Spring Cloud 使用HTTP作为远程调用协议，那我们就必须自己来实现对请求和响应的处理。</p>
<p>但是开源世界已经有很多的HTTP客户端工具，已经帮我们封装好了这些功能，对外提供简单的接口。</p>
<p>常见的HTTP客户端工具有：</p>
<ul>
<li><code>HttpClient</code></li>
<li><code>OKHttp</code></li>
<li><code>URLConnection</code></li>
</ul>
<p>所以说这些HTTP客户端的作用就类似于客户端上的浏览器，发起请求和处理响应。</p>
</blockquote>
<h2 id="3-1、HttpClient"><a href="#3-1、HttpClient" class="headerlink" title="3.1、HttpClient"></a>3.1、HttpClient</h2><blockquote>
<p>HttpClient是Apache公司的产品，是HTTP Components下的一个组件。</p>
<p><a target="_blank" rel="noopener" href="http://hc.apache.org/index.html">官网地址：http://hc.apache.org/index.html</a></p>
</blockquote>
<p>特点：</p>
<ul>
<li>基于标准、纯净的Java语言。实现了Http1.0和Http1.1</li>
<li>以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）</li>
<li>支持HTTPS协议。</li>
<li>通过HTTP代理建立透明的连接。</li>
<li>自动处理Set-Cookie中的Cookie。</li>
</ul>
<hr>
<h3 id="3-1-1、使用"><a href="#3-1-1、使用" class="headerlink" title="3.1.1、使用"></a>3.1.1、使用</h3><ol>
<li><p>导入依赖；</p>
</li>
<li><p>发起GET请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">HttpGet</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="built_in">this</span>.httpClient.execute(request, <span class="keyword">new</span> <span class="title class_">BasicResponseHandler</span>());</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发起Post请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPost</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">HttpPost</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://www.oschina.net/&quot;</span>);</span><br><span class="line">    request.setHeader(<span class="string">&quot;User-Agent&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="built_in">this</span>.httpClient.execute(request, <span class="keyword">new</span> <span class="title class_">BasicResponseHandler</span>());</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-1-2、Json转换工具"><a href="#3-1-2、Json转换工具" class="headerlink" title="3.1.2、Json转换工具"></a>3.1.2、Json转换工具</h3><ul>
<li><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/11/25/json%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CJava%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/">传送门：json字符串和Java对象之间的相互转换</a></li>
</ul>
<blockquote>
<p>通过HTTP协议进行远程调用时传递的消息格式都是字符串格式，所以在Java程序中我们需要手动进行<strong>序列化/反序列化</strong>，我们可以使用<code>JacksonJson工具</code>来实现。    </p>
</blockquote>
<p>访问本地服务器上的项目：<code>http://localhost/hello</code>，返回结果一个User对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetPojo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">HttpGet</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://localhost/hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="built_in">this</span>.httpClient.execute(request, <span class="keyword">new</span> <span class="title class_">BasicResponseHandler</span>());</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们实际得到的是一个json字符串，如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。</p>
<hr>
<h2 id="3-2、Spring的RestTemplate"><a href="#3-2、Spring的RestTemplate" class="headerlink" title="3.2、Spring的RestTemplate"></a>3.2、Spring的RestTemplate</h2><blockquote>
<p>Spring提供了一个RestTemplate模板工具类，在HTTP客户端工具的基础上再做了一次封装，简化了开发。比如：</p>
<ul>
<li>实现了对象与json的自动序列化和反序列化。</li>
</ul>
<p>RestTemplate是一个接口，并没有限定HTTP工具类的种类，而是在上层进行了抽象，目前常用的3种都有支持：</p>
<ul>
<li><code>HttpClient</code></li>
<li><code>OkHttpJDK</code></li>
<li><code>原生的URLConnection（默认的）</code></li>
</ul>
</blockquote>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><p>首先在项目的Spring容器中注册一个<code>RestTemplate</code>对象，可以在启动类位置注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(HttpDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认的RestTemplate，底层是JDK的URLConnection实现方式。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在测试类中直接<code>@Autowired</code>注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = HttpDemoApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">httpGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 请求目标URL，并将返回的JSON字符串反序列化到User对象中</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.restTemplate.getForObject(<span class="string">&quot;http://localhost/hello&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过<code>RestTemplate对象</code>的<code>getForObject()方法</code>，传递URL地址及响应结果实体类的字节码，<code>RestTemplate</code>会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="4、SpringCloud"><a href="#4、SpringCloud" class="headerlink" title="4、SpringCloud"></a>4、SpringCloud</h1><blockquote>
<p>微服务是一种架构方式，并不是具体的技术架构。</p>
<p>微服务的实现方式很多，Spring Cloud只是其中一种实现方式。</p>
</blockquote>
<h2 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h2><blockquote>
<p>SpringCloud是Spring旗下的项目之一。Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：<strong>配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态</strong>等等功能。其主要涉及的组件包括：</p>
<ul>
<li>Eureka：注册中心</li>
<li>Zuul：服务网关</li>
<li>Ribbon：负载均衡</li>
<li>Feign：服务调用</li>
<li>Hystix：熔断器</li>
<li>……</li>
</ul>
</blockquote>
<p>以上只是其中一部分，架构图：</p>
<p><img src="/2020/10/07/SpringCloud/1525575656796.png" alt="1525575656796"></p>
<h2 id="4-2、版本"><a href="#4-2、版本" class="headerlink" title="4.2、版本"></a>4.2、版本</h2><blockquote>
<p>SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成。</p>
</blockquote>
<h1 id="5、微服务入门"><a href="#5、微服务入门" class="headerlink" title="5、微服务入门"></a>5、微服务入门</h1><h2 id="5-1-服务提供者"><a href="#5-1-服务提供者" class="headerlink" title="5.1.服务提供者"></a>5.1.服务提供者</h2><p>我们新建一个项目，对外提供查询用户的服务。</p>
<h3 id="5-1-1-Spring脚手架创建工程"><a href="#5-1-1-Spring脚手架创建工程" class="headerlink" title="5.1.1.Spring脚手架创建工程"></a>5.1.1.Spring脚手架创建工程</h3><p>借助于Spring提供的快速搭建工具：</p>
<p><img src="/2020/10/07/SpringCloud/1525576816916.png" alt="1525576816916"></p>
<p>填写项目信息：</p>
<p> <img src="/2020/10/07/SpringCloud/1525576909381.png" alt="1525576909381"></p>
<p>添加web依赖：</p>
<p><img src="/2020/10/07/SpringCloud/1525576950842.png" alt="1525576950842"></p>
<p>添加mybatis依赖：</p>
<p><img src="/2020/10/07/SpringCloud/1525576999052.png" alt="1525576999052"></p>
<p>填写项目位置：</p>
<p><img src="/2020/10/07/SpringCloud/1525577029150.png" alt="1525577029150"></p>
<p>生成的项目结构：</p>
<p> <img src="/2020/10/07/SpringCloud/1525577106711.png" alt="1525577106711"></p>
<p>依赖也已经全部自动引入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>user-service-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，因为要使用通用mapper，所以我们需要手动加一条依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="5-1-2-编写代码"><a href="#5-1-2-编写代码" class="headerlink" title="5.1.2.编写代码"></a>5.1.2.编写代码</h3><p>添加一个对外查询的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userService.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapper:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">tk</span>.mybatis.mapper.common.Mapper&lt;User&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性别，1男性，2女性</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出生日期</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updated;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备注</span></span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 。。。省略getters和setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>属性文件,这里我们采用了<code>yml</code>语法，而不是<code>properties</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mydb01</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.leyou.userservice.pojo</span></span><br></pre></td></tr></table></figure>



<p>项目结构：</p>
<p> <img src="/2020/10/07/SpringCloud/1525577911331.png" alt="1525577911331"></p>
<h3 id="5-1-3-启动并测试："><a href="#5-1-3-启动并测试：" class="headerlink" title="5.1.3.启动并测试："></a>5.1.3.启动并测试：</h3><p>启动项目，访问接口：<code>http://localhost:8081/user/7</code></p>
<p> <img src="/2020/10/07/SpringCloud/1525593139364.png" alt="1525593139364"></p>
<h2 id="5-2-服务调用者"><a href="#5-2-服务调用者" class="headerlink" title="5.2.服务调用者"></a>5.2.服务调用者</h2><h3 id="5-2-1-创建工程"><a href="#5-2-1-创建工程" class="headerlink" title="5.2.1.创建工程"></a>5.2.1.创建工程</h3><p>与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。</p>
<p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-consumer-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>user-consumer-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 添加OkHttp支持 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-编写代码"><a href="#5-2-2-编写代码" class="headerlink" title="5.2.2.编写代码"></a>5.2.2.编写代码</h3><p>首先在启动类中注册<code>RestTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConsumerDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这次我们使用了OkHttp客户端,只需要注入工厂即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(<span class="keyword">new</span> <span class="title class_">OkHttp3ClientHttpRequestFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserConsumerDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryUserById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/user/&quot;</span> + id;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.restTemplate.getForObject(response, User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后编写user-service，循环查询UserDAO信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">querUserByIds</span><span class="params">(List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Long id : ids) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userDao.queryUserById(id);</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;consume&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">consume</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userService.queryUserByIds(ids);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-3-启动测试："><a href="#5-2-3-启动测试：" class="headerlink" title="5.2.3.启动测试："></a>5.2.3.启动测试：</h3><p>因为我们没有配置端口，那么默认就是8080，我们访问：<code>http://localhost:8080/consume?ids=6,7,8</code></p>
<p> <img src="/2020/10/07/SpringCloud/1525594222408.png" alt="1525594222408"></p>
<p>一个简单的远程服务调用案例就实现了。</p>
<h2 id="5-3-有没有问题？"><a href="#5-3-有没有问题？" class="headerlink" title="5.3.有没有问题？"></a>5.3.有没有问题？</h2><p>简单回顾一下，刚才我们写了什么：</p>
<ul>
<li>use-service-demo：一个提供根据id查询用户的微服务</li>
<li>consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo</li>
</ul>
<p>流程如下：</p>
<p><img src="/2020/10/07/SpringCloud/1525595012668.png" alt="1525595012668"></p>
<blockquote>
<p>  存在什么问题？</p>
</blockquote>
<ul>
<li>在consumer中，我们把url地址硬编码到了代码中，不方便后期维护</li>
<li>consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效</li>
<li>consumer不清楚user-service的状态，服务宕机也不知道</li>
<li>user-service只有1台服务，容易出现单点故障问题</li>
<li>即便user-service形成集群，consumer还需自己实现负载均衡</li>
</ul>
<blockquote>
<p>  其实上面说的问题，概括一下就是分布式服务必然要面临的问题：</p>
</blockquote>
<ul>
<li><strong>服务管理</strong><ul>
<li><strong>如何自动注册和发现</strong></li>
<li><strong>如何实现状态监管</strong></li>
<li><strong>如何实现动态路由</strong></li>
</ul>
</li>
<li><strong>服务如何实现负载均衡</strong></li>
<li><strong>服务如何解决熔断问题</strong></li>
<li><strong>服务如何实现统一配置</strong></li>
</ul>
<p>以上的问题，我们都将在SpringCloud中得到答案。</p>
<hr>
<h1 id="6、Eureka注册中心"><a href="#6、Eureka注册中心" class="headerlink" title="6、Eureka注册中心"></a>6、Eureka注册中心</h1><h2 id="Eureka原理"><a href="#Eureka原理" class="headerlink" title="Eureka原理"></a>Eureka原理</h2><ul>
<li><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/11/07/Eureka/">Eureka详解</a></li>
</ul>
<hr>
<h2 id="Eureka实践"><a href="#Eureka实践" class="headerlink" title="Eureka实践"></a>Eureka实践</h2><h3 id="编写EurekaServer"><a href="#编写EurekaServer" class="headerlink" title="编写EurekaServer"></a>编写EurekaServer</h3><p>接下来我们创建一个项目，启动一个EurekaServer：</p>
<p><img src="/2020/10/07/SpringCloud/1525598231170.png" alt="1525598231170"></p>
<p>选择依赖：</p>
<p><img src="/2020/10/07/SpringCloud/1525598312368.png" alt="1525598312368"></p>
<p>完整的Pom文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>eureka-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringCloud版本 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RC1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Eureka服务端 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 声明这个应用是一个EurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(EurekaDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 是否注册自己的信息到EurekaServer，默认是true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 是否拉取其它服务的信息，默认是true</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动服务，并访问：<code>http://127.0.0.1:10086/eureka</code></p>
<p><img src="/2020/10/07/SpringCloud/1525604959508.png" alt="1525604959508"></p>
<p><img src="/2020/10/07/SpringCloud/1525605081129.png" alt="1525605081129"></p>
<h3 id="将user-service注册到Eureka"><a href="#将user-service注册到Eureka" class="headerlink" title="将user-service注册到Eureka"></a>将user-service注册到Eureka</h3><p>注册服务到<code>EurekaServer</code>，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。</p>
<blockquote>
<p>我们在user-service-demo中添加Eureka客户端依赖：</p>
</blockquote>
<p>先添加SpringCloud依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringCloud的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring的仓库地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后是Eureka客户端：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>在启动类上开启Eureka客户端功能</p>
</blockquote>
<p>通过添加<code>@EnableDiscoveryClient</code>来开启Eureka客户端功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启EurekaClient功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceDemoApplication</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(UserServiceDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>编写配置</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mydb01</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.leyou.userservice.pojo</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 当调用getHostname获取实例的hostname时，返回ip而不是host名称</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 指定自己的ip信息，不指定的话会自己寻找</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。</li>
<li>不用指定register-with-eureka和fetch-registry，因为默认是true</li>
</ul>
<blockquote>
<p>重启项目，访问<code>Eureka监控页面</code>查看</p>
</blockquote>
<p><img src="/2020/10/07/SpringCloud/1525609225152.png" alt="1525609225152"></p>
<p>我们发现user-service服务已经注册成功了</p>
<h3 id="消费者从Eureka获取服务"><a href="#消费者从Eureka获取服务" class="headerlink" title="消费者从Eureka获取服务"></a>消费者从Eureka获取服务</h3><p>接下来我们修改consumer-demo，尝试从EurekaServer获取服务。</p>
<p>方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！</p>
<p>1）添加依赖：</p>
<p>先添加SpringCloud依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringCloud的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring的仓库地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后是Eureka客户端：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2）在启动类开启Eureka客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启Eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConsumerDemoApplication</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(<span class="keyword">new</span> <span class="title class_">OkHttp3ClientHttpRequestFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserConsumerDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3）修改配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consumer</span> <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 当其它服务获取地址时提供ip而不是hostname</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 指定自己的ip信息，不指定的话会自己寻找</span></span><br></pre></td></tr></table></figure>

<p>4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;	<span class="comment">// Eureka客户端对象，可以获取到服务实例信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUserByIds</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// String baseUrl = &quot;http://localhost:8081/user/&quot;;</span></span><br><span class="line">        <span class="comment">// 根据服务名称，获取服务实例</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;user-service&quot;</span>);</span><br><span class="line">        <span class="comment">// 本例中只有一个UserService,因此我们直接get(0)获取</span></span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取ip和端口信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://&quot;</span>+instance.getHost() + <span class="string">&quot;:&quot;</span> + instance.getPort()+<span class="string">&quot;/user/&quot;</span>;</span><br><span class="line">        ids.forEach(id -&gt; &#123;</span><br><span class="line">            <span class="comment">// 我们测试多次查询，</span></span><br><span class="line">            users.add(<span class="built_in">this</span>.restTemplate.getForObject(baseUrl + id, User.class));</span><br><span class="line">            <span class="comment">// 每次间隔500毫秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>访问成功</li>
</ol>
<hr>
<h3 id="高可用的Eureka-Server"><a href="#高可用的Eureka-Server" class="headerlink" title="高可用的Eureka Server"></a>高可用的Eureka Server</h3><p>在上面的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。</p>
<p>我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087</p>
<p>1）我们修改原来的EurekaServer配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10087/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：</p>
<ul>
<li>删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。</li>
<li>把service-url的值改成了另外一台EurekaServer的地址，而不是自己</li>
</ul>
<p>2）另外一台配置恰好相反：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10087</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器：</p>
<p> <img src="/2020/10/07/SpringCloud/1525615070033.png" alt="1525615070033"></p>
<p> <img src="/2020/10/07/SpringCloud/1525615095693.png" alt="1525615095693"></p>
<p><img src="/2020/10/07/SpringCloud/1525615026937.png" alt="1525615026937"></p>
<p>然后启动即可。</p>
<p>3）启动测试：</p>
<p><img src="/2020/10/07/SpringCloud/1525615165157.png" alt="1525615165157"></p>
<p>4）客户端注册服务到集群</p>
<p>因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址,多个地址以&#x27;,&#x27;隔开</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="7、负载均衡Robbin"><a href="#7、负载均衡Robbin" class="headerlink" title="7、负载均衡Robbin"></a>7、负载均衡Robbin</h1><p>在微服务开发中，为了避免单点故障或解决网络拥塞，会为每种服务都建立一个集群（集群中包含2~3个服务器），此时<code>服务调用者</code>再从<code>注册中心</code>拉取服务列表，每种服务对应的服务器地址就会有多个，那么<code>服务调用者</code>究竟应该访问哪一个服务器呢？</p>
<p>一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。</p>
<p>不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。</p>
<blockquote>
<p>Ribbon是Netflix发布的<strong>一个</strong>负载均衡器。</p>
<p>它可以帮助控制HTTP和TCP客户端的行为。[在这里是帮助客户端选择要访问的服务器]</p>
<p>Ribbon从<code>EurekaServer</code>得到<code>服务提供者</code>的地址列表后，就可以根据某种负载均衡算法，自动地帮助<code>服务调用者</code>去请求<code>服务提供者</code> 。</p>
<p>Ribbon默认为我们提供了很多负载均衡的算法，例如轮询、随机等。当然，我们也可以自定义负载均衡算法。</p>
</blockquote>
<h2 id="2-1、Ribbon的代码实现"><a href="#2-1、Ribbon的代码实现" class="headerlink" title="2.1、Ribbon的代码实现"></a>2.1、Ribbon的代码实现</h2><h3 id="1、启动两个服务实例"><a href="#1、启动两个服务实例" class="headerlink" title="1、启动两个服务实例"></a>1、启动两个服务实例</h3><p>首先我们启动两个user-service实例，一个8081，一个8082。</p>
<p> <img src="/2020/10/07/SpringCloud/1525619515586.png" alt="1525619515586"></p>
<p>Eureka监控面板：</p>
<p><img src="/2020/10/07/SpringCloud/1525619546904.png" alt="1525619546904"></p>
<h3 id="2、开启负载均衡"><a href="#2、开启负载均衡" class="headerlink" title="2、开启负载均衡"></a>2、开启负载均衡</h3><p>因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码：</p>
<p>在RestTemplate的配置方法上添加<code>@LoadBalanced</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(<span class="keyword">new</span> <span class="title class_">OkHttp3ClientHttpRequestFactory</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、通过服务名称调用服务提供者"><a href="#3、通过服务名称调用服务提供者" class="headerlink" title="3、通过服务名称调用服务提供者"></a>3、通过服务名称调用服务提供者</h3><p>修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUserByIds</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 地址直接写服务名称即可</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://user-service/user/&quot;</span>;</span><br><span class="line">        ids.forEach(id -&gt; &#123;</span><br><span class="line">            <span class="comment">// 我们测试多次查询，</span></span><br><span class="line">            users.add(<span class="built_in">this</span>.restTemplate.getForObject(baseUrl + id, User.class));</span><br><span class="line">            <span class="comment">// 每次间隔500毫秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p>
<p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>【源码部分】</p>
</blockquote>
<p>访问页面，查看结果：</p>
<p> <img src="/2020/10/07/SpringCloud/1525620305704.png" alt="1525620305704"></p>
<h2 id="2-2-修改负载均衡策略"><a href="#2-2-修改负载均衡策略" class="headerlink" title="2.2    修改负载均衡策略"></a>2.2    修改负载均衡策略</h2><blockquote>
<p>Ribbon默认的负载均衡策略是简单的轮询，SpringBoot也帮我们提供了修改负载均衡规则的配置入口。</p>
</blockquote>
<ul>
<li><p>格式：</p>
<p><code>&#123;服务名称&#125;.ribbon.NFLoadBalancerRuleClassName=Xxx</code></p>
<p>Xxx就是负载均衡规则的实现类。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user-service:</span>	<span class="comment"># 服务ID</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">  	<span class="attr">NFLoadBlancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span>	<span class="comment"># 随机算法</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="2-2-重试机制"><a href="#2-2-重试机制" class="headerlink" title="2.2    重试机制"></a>2.2    重试机制</h2><blockquote>
<ul>
<li>重试机制的前提是<code>服务提供者</code>必须是一个<strong>集群</strong>，且一定要<strong>通过服务提供者的服务名称（而不是IP地址 ）访问</strong>（即实现了负载均衡）</li>
</ul>
</blockquote>
<p>Eureka为了实现更高的服务可用性，牺牲了一定的一致性，<u>极端情况下它宁愿接收故障实例也不愿丢掉健康实例</u>，正如我们上面所说的自我保护机制。</p>
<p>但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。</p>
<p>我们现在关闭一个user-service实例：</p>
<p> <img src="/2020/10/07/SpringCloud/1525653565855.png" alt="1525653565855"></p>
<p>因为失效剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示：</p>
<p><img src="/2020/10/07/SpringCloud/1525653715488.png" alt="1525653715488"></p>
<p>但是此时，8081服务其实是正常的。</p>
<p>因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。</p>
<p>只需要简单配置即可实现Ribbon的重试：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">loadbalancer:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Spring Cloud的重试功能</span></span><br><span class="line"><span class="attr">user-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># Ribbon的连接超时时间</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">1000</span> <span class="comment"># Ribbon的数据读取超时时间</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作都进行重试</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment"># 切换实例的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 对当前实例的重试次数</span></span><br></pre></td></tr></table></figure>

<p>根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于<code>MaxAutoRetriesNextServer</code>参数的值</p>
<p>引入spring-retry依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！</p>
<hr>
<h1 id="8、Hystrix"><a href="#8、Hystrix" class="headerlink" title="8、Hystrix"></a>8、Hystrix</h1><h2 id="8-1、Hystrix原理"><a href="#8-1、Hystrix原理" class="headerlink" title="8.1、Hystrix原理"></a>8.1、Hystrix原理</h2><ul>
<li><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/11/07/Hystrix/">Hystrix详解</a></li>
</ul>
<h2 id="8-2、Hystrix实践"><a href="#8-2、Hystrix实践" class="headerlink" title="8.2、Hystrix实践"></a>8.2、Hystrix实践</h2><h3 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h3><blockquote>
<p>首先在user-consumer中引入Hystix依赖：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2、开启熔断"><a href="#2、开启熔断" class="headerlink" title="2、开启熔断"></a>2、开启熔断</h3><h3 id="3、改造消费者"><a href="#3、改造消费者" class="headerlink" title="3、改造消费者"></a>3、改造消费者</h3><blockquote>
<p>我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(UserDao.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;queryUserByIdFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryUserById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://user-service/user/&quot;</span> + id;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.restTemplate.getForObject(url, User.class);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 记录访问用时：</span></span><br><span class="line">        logger.info(<span class="string">&quot;访问用时：&#123;&#125;&quot;</span>, end - begin);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryUserByIdFallback</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(<span class="string">&quot;用户信息查询出现异常！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@HystrixCommand(fallbackMethod=&quot;queryUserByIdFallback&quot;)</code>：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</li>
<li>为了方便查看熔断的触发时机，我们记录请求访问时间。</li>
</ul>
<p>在原来的业务逻辑中调用这个DAO：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUserByIds</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ids.forEach(id -&gt; &#123;</span><br><span class="line">            <span class="comment">// 我们测试多次查询，</span></span><br><span class="line">            users.add(<span class="built_in">this</span>.userDao.queryUserById(id));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、改造服务提供者"><a href="#4、改造服务提供者" class="headerlink" title="4、改造服务提供者"></a>4、改造服务提供者</h3><p>改造服务提供者，随机休眠一段时间，以触发熔断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒</span></span><br><span class="line">        Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">2000</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、启动测试"><a href="#5、启动测试" class="headerlink" title="5、启动测试"></a>5、启动测试</h3><p>然后运行并查看日志：</p>
<p>id为9、10、11的访问时间分别是：</p>
<p> <img src="/2020/10/07/SpringCloud/1525661641660.png" alt="1525661641660"></p>
<p>id为12的访问时间：</p>
<p> <img src="/2020/10/07/SpringCloud/1525661669136.png" alt="1525661669136"></p>
<p>因此，只有12是正常访问，其它都会触发熔断，我们来查看结果：</p>
<p><img src="/2020/10/07/SpringCloud/1525661720656.png" alt="1525661720656"></p>
<h3 id="6、优化"><a href="#6、优化" class="headerlink" title="6、优化"></a>6、优化</h3><p>虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？</p>
<p>其实这里是因为我们的Ribbon超时时间设置的是1000ms:</p>
<p>​    <img src="/2020/10/07/SpringCloud/1525666632542.png" alt="1525666632542"></p>
<p>而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。</p>
<p>所以，Ribbon的超时时间一定要小于Hystix的超时时间。</p>
<p>我们可以通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>来设置Hystrix超时时间。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">  	<span class="attr">default:</span></span><br><span class="line">        <span class="attr">execution:</span></span><br><span class="line">          <span class="attr">isolation:</span></span><br><span class="line">            <span class="attr">thread:</span></span><br><span class="line">              <span class="attr">timeoutInMillisecond:</span> <span class="number">6000</span> <span class="comment"># 设置hystrix的超时时间为6000ms</span></span><br></pre></td></tr></table></figure>







<h2 id="8-3-Hystrix与RIbbon重试机制的冲突"><a href="#8-3-Hystrix与RIbbon重试机制的冲突" class="headerlink" title="8.3    Hystrix与RIbbon重试机制的冲突"></a>8.3    Hystrix与RIbbon重试机制的冲突</h2><ul>
<li><p>Ribbon的重试机制是建立在集群的基础上，当集群中的某个服务请求超时后就去请求该机群中的另一个服务。一般情况下我们都会设置一个超时时间作为切换服务的标准。    </p>
</li>
<li><p><strong>冲突</strong>：当Ribbon的重试机制 和 Hystrix 在一个服务中同时生效时，如果Hystrix设置的短路时间小于Ribbon的重试时间，这时候就无法触发服务重试了，而是会直接触发熔断。</p>
</li>
<li><p>所以，<strong>Ribbon的超时时间一定要小于Hystrix的超时时间</strong>。我们可以通过<code>hystrix.command.default.isolation.thread.timeoutInMilliseconds</code>来设置Hystrix的超时时间。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span> </span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">  	<span class="attr">default:</span> </span><br><span class="line">  	  <span class="attr">isolation:</span></span><br><span class="line">  	    <span class="attr">thread:</span></span><br><span class="line">  	      <span class="attr">timeoutInMilliseconds:</span> <span class="number">6000</span>	<span class="comment"># 设置Hystrix的超时时间为6000ms</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="9、Feign"><a href="#9、Feign" class="headerlink" title="9、Feign"></a>9、Feign</h1><h2 id="9-1、Feign介绍"><a href="#9-1、Feign介绍" class="headerlink" title="9.1、Feign介绍"></a>9.1、Feign介绍</h2><blockquote>
<ul>
<li><p>feign  /feɪn/  假装；装作；捏造；想象</p>
<blockquote>
<p>为什么叫伪装？</p>
<p>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样，你不用再自己拼接URL，拼接参数等，一切都交给Feign去做。</p>
</blockquote>
</li>
<li><p>Feign是Netflix开发的声明式、模板化的HTTP<strong>客户端</strong>。Feign可以帮助我们更加快捷、优雅的调用HTTP API。</p>
</li>
<li><p>在SpringCould中，使用Feign非常简单：创建一个接口，并在接口上添加一些注解，代码就完成了。Feign支持多种注解，例如Feign子代的注解或者JAX-RS注解等。</p>
</li>
<li><p>SpringCould对Feign进行了增强，使Feign支持了SpringMVC注解，并整合了Ribbon和Eureka，从而让Feign的使用更加方便。 </p>
</li>
</ul>
</blockquote>
<h2 id="9-2、Feign实践"><a href="#9-2、Feign实践" class="headerlink" title="9.2、Feign实践"></a>9.2、Feign实践</h2><h3 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、Feign的客户端"><a href="#2、Feign的客户端" class="headerlink" title="2、Feign的客户端"></a>2、Feign的客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;user-service&quot;)</span> <span class="comment">// 注解中的服务名是Feign客户端要访问的服务提供者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFeignClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Feign的客户端是一个<strong>接口</strong>，Feign会通过动态代理，帮我们生成实现类。这和MyBatis的mapper很像。</li>
<li><code>@FeignClient</code>，声明这是一个Feign客户端，通过<code>value</code>属性指定<code>服务提供者实例的名称</code>。</li>
<li>接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果。</li>
</ul>
</blockquote>
<p>改造原来的调用逻辑，不再使用<code>UserDao</code>，而是使用<code>UserFeignClient接口</code>去访问<code>服务提供方</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserFeignClient userFeignClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUserByIds</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ids.forEach(id -&gt; &#123;</span><br><span class="line">            <span class="comment">// 我们测试多次查询，</span></span><br><span class="line">            users.add(<span class="built_in">this</span>.userFeignClient.queryUserById(id));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、开启Feign功能"><a href="#3、开启Feign功能" class="headerlink" title="3、开启Feign功能"></a>3、开启Feign功能</h3><p>我们在启动类上，添加注解，开启Feign功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">// 开启Feign功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConsumerDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserConsumerDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你会发现RestTemplate的注册被删除了。因为Feign中集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了。</p>
</blockquote>
<h3 id="4、启动测试："><a href="#4、启动测试：" class="headerlink" title="4、启动测试："></a>4、启动测试：</h3><p>访问接口，获取结果。</p>
<hr>
<h2 id="9-3、负载均衡"><a href="#9-3、负载均衡" class="headerlink" title="9.3、负载均衡"></a>9.3、负载均衡</h2><p>Feign中已经集成了Ribbon依赖和自动配置，因此我们不需要额外引入依赖，也不需要再注册<code>RestTemplate</code>对象。</p>
<p>如果想要修改Ribbon的配置信息，可以通过<code>ribbon.xx</code>来进行全局配置。也可以通过<code>服务名.ribbon.xx</code>来对指定服务配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># 连接超时时间(ms)</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">1000</span> <span class="comment"># 通信超时时间(ms)</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作重试</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment"># 同一服务不同实例的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 同一实例的重试次数</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="9-4、Hystix支持"><a href="#9-4、Hystix支持" class="headerlink" title="9.4、Hystix支持"></a>9.4、Hystix支持</h2><p>Feign中也集成了Hystix，只不过默认情况下是关闭的，我们需要通过配置参数信息手动开启。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Feign的熔断功能</span></span><br></pre></td></tr></table></figure>



<h3 id="Feign中的FallBack配置"><a href="#Feign中的FallBack配置" class="headerlink" title="Feign中的FallBack配置"></a>Feign中的FallBack配置</h3><p>但是，Feign中的Fallback配置不像Ribbon中那样简单了。</p>
<ol>
<li>首先，我们要定义一个类，实现刚才编写的<code>UserFeignClient</code>，作为<code>fallback</code>的处理类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFeignClientFallback</span> <span class="keyword">implements</span> <span class="title class_">UserFeignClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(<span class="string">&quot;用户查询出现异常！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后在<code>UserFeignClient</code>中，指定刚才编写的实现类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;user-service&quot;, fallback = UserFeignClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFeignClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>重启测试：</p>
<p>关闭user-service服务，然后在页面访问：</p>
</li>
</ol>
<p><img src="/2020/10/07/SpringCloud/1525673049875.png" alt="1525673049875"></p>
<hr>
<h2 id="9-5、请求压缩"><a href="#9-5、请求压缩" class="headerlink" title="9.5、请求压缩"></a>9.5、请求压缩</h2><blockquote>
<p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启响应压缩</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/html,application/xml,application/json</span> <span class="comment"># 设置压缩的数据类型</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">2048</span> <span class="comment"># 设置触发压缩的大小下限</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tip：上面的数据类型、压缩大小下限均为默认值。</p>
</blockquote>
<hr>
<h2 id="9-6、日志级别"><a href="#9-6、日志级别" class="headerlink" title="9.6、日志级别"></a>9.6、日志级别</h2><blockquote>
<p>在SpringCould中，通过<code>logging.level.xx=debug</code>来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p>
</blockquote>
<ol>
<li>设置com.leyou包下的日志级别都为debug</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.leyou:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写配置类，定义日志级别</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里指定的Level级别是FULL，Feign支持4种级别：</p>
</blockquote>
<p>​    <img src="/2020/10/07/SpringCloud/1525674373507.png" alt="1525674373507"></p>
<blockquote>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
</blockquote>
<ol start="3">
<li>在FeignClient中指定配置类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;user-service&quot;, fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFeignClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重启项目，即可看到每次访问的日志：</li>
</ol>
<p><img src="/2020/10/07/SpringCloud/1525674544569.png" alt="1525674544569"></p>
<hr>
<h1 id="10、服务网关"><a href="#10、服务网关" class="headerlink" title="10、服务网关"></a>10、服务网关</h1><h2 id="Zuul原理"><a href="#Zuul原理" class="headerlink" title="Zuul原理"></a>Zuul原理</h2><ul>
<li><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/11/07/Zuul/">Zull网关详解</a></li>
</ul>
<h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><ul>
<li><p>映射规则</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 当前服务的端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">api-gateway</span> <span class="comment"># 当前服务名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  	<span class="attr">user-service:</span>	<span class="comment"># 自定义路由规则的ID</span></span><br><span class="line">  	<span class="attr">path:</span> <span class="string">/user-service/**</span> 	<span class="comment"># 定义访问路径</span></span><br><span class="line">  	<span class="attr">url:</span> <span class="string">http://127.0.0.1:8081</span>	<span class="comment"># 访问路径映射到的实际url地址</span></span><br></pre></td></tr></table></figure>

<p>我们将符合<code>path</code>规则的一切请求，都代理到<code>url</code>参数指定的地址。</p>
<p>本例中，我们将<code>/user-service/**</code>开头的请求，代理到<code>http://127.0.0.1:8081</code>。</p>
<p>此时：<code>http://localhost:10010/user-service/user/1</code> 等价于 <code>http://127.0.0.1:8081/user/1</code></p>
</li>
</ul>
<h3 id="面向服务的路由"><a href="#面向服务的路由" class="headerlink" title="面向服务的路由"></a>面向服务的路由</h3><blockquote>
<p><strong>缺点</strong>：</p>
<ul>
<li>在刚才的路由规则中，我们把访问路径对应的地址写死了！如果某个服务是采用集群实现的（有多个实例），这样做就不能充分利用集群的优势，显然是不合理的。</li>
</ul>
<p><strong>改进</strong>：</p>
<ul>
<li>我们应该根据服务的名称，去Eureka注册中心查找服务对应的所有实例列表，然后进行动态路由才对。</li>
</ul>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加Eureka配置，拉取服务列表</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">	<span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s</span></span><br><span class="line">  	<span class="attr">service-url:</span></span><br><span class="line">	  <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">	<span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改路由映射规则，通过服务名称获取路由地址</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  	<span class="attr">user-service:</span>	<span class="comment"># 自定义路由规则的ID</span></span><br><span class="line">  	  <span class="attr">path:</span>	<span class="string">/user-service/**</span>	<span class="comment"># 访问路径</span></span><br><span class="line">  	  <span class="attr">serviceId:</span> <span class="string">user-service</span>	<span class="comment"># 指定服务名称</span></span><br></pre></td></tr></table></figure>

<h4 id="1、简化的路由配置"><a href="#1、简化的路由配置" class="headerlink" title="1、简化的路由配置"></a>1、简化的路由配置</h4><ol>
<li><p>在上面的配置中，我们的规则是这样的：</p>
<ul>
<li><code>zuul.routes.&lt;routes&gt;.path=/xxx/**</code>：来指定访问路径。<code>&lt;routes&gt;</code>是自定义的路由规则的ID。</li>
<li><code>zuul.routes.&lt;routes&gt;.serviceId=/user-service</code>：来指定服务名。</li>
</ul>
</li>
<li><p>而大多数情况下，我们的<code>&lt;routes&gt;</code>路由规则ID往往和服务名会定义成一样的，因此Zuul就提供了一种简化的配置语法：</p>
<ul>
<li><code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  	<span class="attr">user-service:</span> <span class="string">/user-service/**</span>	<span class="comment"># 服务名称&amp;访问路径[省去了对路由规则ID的配置]	</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2、默认的路由规则"><a href="#2、默认的路由规则" class="headerlink" title="2、默认的路由规则"></a>2、默认的路由规则</h4><p>在使用Zuul的过程中，上述的规则已经大大简化了配置。但是当服务较多时，配置仍是比较繁琐的，因此Zuul就指定了默认的路由规则：</p>
<blockquote>
<p>默认情况下，一切服务的访问路径就是服务名本身。</p>
<ul>
<li>例如服务名为：<code>user-service</code>，则默认的访问路径就是：<code>/user-service/**</code></li>
</ul>
<p>也就是说，上面的映射规则我们完全不配置也是OK的。</p>
</blockquote>
<h4 id="3、路由前缀"><a href="#3、路由前缀" class="headerlink" title="3、路由前缀"></a>3、路由前缀</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/api</span>	<span class="comment"># 添加路由前缀（访问路径前缀）</span></span><br><span class="line">  <span class="attr">routes:</span> </span><br><span class="line">  	<span class="attr">user-service:</span>	<span class="comment"># 路由规则ID</span></span><br><span class="line">  	  <span class="attr">path:</span> <span class="string">/user-service/**</span></span><br><span class="line">  	  <span class="attr">serviceId:</span> <span class="string">user-service</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以<code>/api</code>开头</li>
</ul>
<hr>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul>
<li>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个工作往往是通过Zuul提供的过滤器来实现的。</li>
</ul>
<h2 id="负载均衡-amp-熔断"><a href="#负载均衡-amp-熔断" class="headerlink" title="负载均衡  &amp;  熔断"></a>负载均衡  &amp;  熔断</h2><ul>
<li>Zuul中默认已经集成了Ribbon负载均衡和Hystrix熔断机制。但所有的超时策略走的都是默认值，比如熔断超时时间只有1s，很容易就触发了，因此建议手动配置。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">retryable:</span> <span class="literal">true</span>	<span class="comment"># 开启重试机制</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># 连接超时时间(ms)</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">2000</span> <span class="comment"># 通信超时时间(ms)</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作重试</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">2</span> <span class="comment"># 同一服务不同实例的重试次数</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 同一实例的重试次数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">	<span class="attr">default:</span></span><br><span class="line">	  <span class="attr">execution:</span></span><br><span class="line">		<span class="attr">isolation:</span></span><br><span class="line">		  <span class="attr">thread:</span></span><br><span class="line">			<span class="attr">timeoutInMillisecond:</span> <span class="number">6000</span> <span class="comment"># 熔断超时时长：6000ms</span></span><br></pre></td></tr></table></figure>









<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;port&#125;</span> <span class="comment">#服务端口</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">itcast-microservice-eureka</span> <span class="comment">#指定服务名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">true</span> <span class="comment">#是否将自己注册到Eureka服务中，本身就是所有无需注册</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span> <span class="comment">#是否从Eureka中获取注册信息</span></span><br><span class="line">    <span class="attr">serviceUrl:</span> <span class="comment">#Eureka客户端与Eureka服务端进行交互的地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;eureka.server&#125;</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span>  <span class="literal">true</span>  <span class="comment">#将自己的ip地址注册到Eureka服务中</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="comment">#指定实例id</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment">#禁用自我保护模式</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">60000</span> <span class="comment">#清理间隔（单位毫秒，默认是60*1000）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#security:</span></span><br><span class="line"><span class="comment">#  basic:</span></span><br><span class="line"><span class="comment">#    enable: true #开启基于HTTP basic的认证</span></span><br><span class="line"><span class="comment">#  user: #配置用户的账号信息</span></span><br><span class="line"><span class="comment">#    name: itcast</span></span><br><span class="line"><span class="comment">#    password: itcast123</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br><span class="line"><span class="comment">#    org.springframework.web: DEBUG</span></span><br><span class="line">  <span class="attr">file:</span> <span class="string">/log/log/my_eureka.log</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">console:</span> <span class="string">&quot;%d&#123;yyyy/MM/dd-HH:mm:ss&#125; [%thread] %-5level %logger- %msg%n&quot;</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&quot;%d&#123;yyyy/MM/dd-HH:mm&#125; [%thread] %-5level %logger- %msg%n&quot;</span></span><br><span class="line"><span class="comment">#logging.level.root=WARN</span></span><br><span class="line"><span class="comment">#logging.level.org.springframework.web=DEBUG</span></span><br><span class="line"><span class="comment">#logging.file=/log/log/my.log</span></span><br><span class="line"><span class="comment">#logging.pattern.console=%d&#123;yyyy/MM/dd-HH:mm:ss&#125; [%thread] %-5level %logger- %msg%n</span></span><br><span class="line"><span class="comment">#logging.pattern.file=%d&#123;yyyy/MM/dd-HH:mm&#125; [%thread] %-5level %logger- %msg%n</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + alt + B			查看实现类</span><br></pre></td></tr></table></figure>



<h2 id="Zuul实践"><a href="#Zuul实践" class="headerlink" title="Zuul实践"></a>Zuul实践</h2><h3 id="1、新建工程"><a href="#1、新建工程" class="headerlink" title="1、新建工程"></a>1、新建工程</h3><p><img src="/2020/10/07/SpringCloud/1525675928548.png" alt="1525675928548"></p>
<p>添加Zuul依赖：</p>
<p><img src="/2020/10/07/SpringCloud/1525675991833.png" alt="1525675991833"></p>
<h3 id="2、编写启动类"><a href="#2、编写启动类" class="headerlink" title="2、编写启动类"></a>2、编写启动类</h3><p>通过<code>@EnableZuulProxy </code>注解开启Zuul的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启Zuul的网关功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(ZuulDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、编写配置"><a href="#3、编写配置" class="headerlink" title="3、编写配置"></a>3、编写配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> 	<span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span> <span class="comment">#指定服务实例ID</span></span><br></pre></td></tr></table></figure>

<h3 id="4、编写路由规则"><a href="#4、编写路由规则" class="headerlink" title="4、编写路由规则"></a>4、编写路由规则</h3><p>我们需要用Zuul来代理<code>user-service</code>服务，先看一下控制面板中的服务状态：</p>
<p><img src="/2020/10/07/SpringCloud/1525676797879.png" alt="1525676797879"></p>
<blockquote>
<ul>
<li>IP：127.0.0.1</li>
<li>端口号：8081</li>
</ul>
</blockquote>
<p>映射规则：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">user-service:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/user-service/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://127.0.0.1:8081</span> <span class="comment"># 映射路径对应的实际url地址</span></span><br></pre></td></tr></table></figure>

<p>我们将符合<code>path</code> 规则的一切请求，都代理到 <code>url</code>参数指定的地址</p>
<p>本例中，我们将 <code>/user-service/**</code>开头的请求，代理到<code>http://127.0.0.1:8081</code></p>
<h3 id="3-3-5-启动测试"><a href="#3-3-5-启动测试" class="headerlink" title="3.3.5.启动测试"></a>3.3.5.启动测试</h3><p>访问的路径中需要加上配置规则的映射路径，我们访问：<code>http://127.0.0.1:8081/user-service/user/10</code></p>
<p>​    <img src="/2020/10/07/SpringCloud/1525677046705.png" alt="1525677046705"></p>
<h2 id="3-4-面向服务的路由"><a href="#3-4-面向服务的路由" class="headerlink" title="3.4.面向服务的路由"></a>3.4.面向服务的路由</h2><p>在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。</p>
<p>我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！</p>
<h3 id="3-4-1-添加Eureka客户端依赖"><a href="#3-4-1-添加Eureka客户端依赖" class="headerlink" title="3.4.1.添加Eureka客户端依赖"></a>3.4.1.添加Eureka客户端依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-2-开启Eureka客户端发现功能"><a href="#3-4-2-开启Eureka客户端发现功能" class="headerlink" title="3.4.2.开启Eureka客户端发现功能"></a>3.4.2.开启Eureka客户端发现功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启Zuul的网关功能</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuulDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(ZuulDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-添加Eureka配置，获取服务信息"><a href="#3-4-3-添加Eureka配置，获取服务信息" class="headerlink" title="3.4.3.添加Eureka配置，获取服务信息"></a>3.4.3.添加Eureka配置，获取服务信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-修改映射配置，通过服务名称获取"><a href="#3-4-4-修改映射配置，通过服务名称获取" class="headerlink" title="3.4.4.修改映射配置，通过服务名称获取"></a>3.4.4.修改映射配置，通过服务名称获取</h3><p>因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">user-service:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/user-service/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">user-service</span> <span class="comment"># 指定服务名称</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-5-启动测试"><a href="#3-4-5-启动测试" class="headerlink" title="3.4.5.启动测试"></a>3.4.5.启动测试</h3><p>再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：</p>
<p>​    <img src="/2020/10/07/SpringCloud/1525677821212.png" alt="1525677821212"></p>
<p>日志中可以看到使用了负载均衡器：</p>
<p><img src="/2020/10/07/SpringCloud/1525677891119.png" alt="1525677891119"></p>
<h2 id="3-5-简化的路由配置"><a href="#3-5-简化的路由配置" class="headerlink" title="3.5.简化的路由配置"></a>3.5.简化的路由配置</h2><p>在刚才的配置中，我们的规则是这样的：</p>
<ul>
<li><code>zuul.routes.&lt;route&gt;.path=/xxx/**</code>： 来指定映射路径。<code>&lt;route&gt;</code>是自定义的路由名</li>
<li><code>zuul.routes.&lt;route&gt;.serviceId=/user-service</code>：来指定服务名。</li>
</ul>
<p>而大多数情况下，我们的<code>&lt;route&gt;</code>路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></p>
<p>比方说上面我们关于user-service的配置可以简化为一条：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">user-service:</span> <span class="string">/user-service/**</span> <span class="comment"># 这里是映射路径</span></span><br></pre></td></tr></table></figure>

<p>省去了对服务名称的配置。</p>
<h2 id="3-6-默认的路由规则"><a href="#3-6-默认的路由规则" class="headerlink" title="3.6.默认的路由规则"></a>3.6.默认的路由规则</h2><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：</p>
<ul>
<li>默认情况下，一切服务的映射路径就是服务名本身。<ul>
<li>例如服务名为：<code>user-service</code>，则默认的映射路径就是：<code>/user-service/**</code></li>
</ul>
</li>
</ul>
<p>也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。</p>
<h2 id="3-7-路由前缀"><a href="#3-7-路由前缀" class="headerlink" title="3.7.路由前缀"></a>3.7.路由前缀</h2><p>配置示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/api</span> <span class="comment"># 添加路由前缀</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">      <span class="attr">user-service:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/user-service/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">user-service</span> <span class="comment"># 指定服务名称</span></span><br></pre></td></tr></table></figure>

<p>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。</p>
<p>路径<code>/api/user-service/user/1</code>将会被代理到<code>/user-service/user/1</code></p>
<h2 id="3-8-过滤器"><a href="#3-8-过滤器" class="headerlink" title="3.8.过滤器"></a>3.8.过滤器</h2><p>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。</p>
<h3 id="3-8-1-ZuulFilter"><a href="#3-8-1-ZuulFilter" class="headerlink" title="3.8.1.ZuulFilter"></a>3.8.1.ZuulFilter</h3><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ZuulFilter <span class="keyword">implements</span> <span class="title class_">IZuulFilter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span>;<span class="comment">// 来自IZuulFilter</span></span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException;<span class="comment">// IZuulFilter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li>
<li><code>run</code>：过滤器的具体业务逻辑。</li>
<li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul>
<li><code>pre</code>：请求在被路由之前执行</li>
<li><code>routing</code>：在路由请求时调用</li>
<li><code>post</code>：在routing和errror过滤器之后调用</li>
<li><code>error</code>：处理请求时发生错误调用</li>
</ul>
</li>
<li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li>
</ul>
<h3 id="3-8-2-过滤器执行生命周期："><a href="#3-8-2-过滤器执行生命周期：" class="headerlink" title="3.8.2.过滤器执行生命周期："></a>3.8.2.过滤器执行生命周期：</h3><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。</p>
<p>​    <img src="/2020/10/07/SpringCloud/1525681866862.png" alt="1525681866862"></p>
<ul>
<li>正常流程：<ul>
<li>请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</li>
</ul>
</li>
<li>异常流程：<ul>
<li>整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</li>
<li>如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。</li>
<li>如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。</li>
</ul>
</li>
</ul>
<p>所有内置过滤器列表：</p>
<p>​    <img src="/2020/10/07/SpringCloud/1525682427811.png" alt="1525682427811"></p>
<h3 id="3-8-3-使用场景"><a href="#3-8-3-使用场景" class="headerlink" title="3.8.3.使用场景"></a>3.8.3.使用场景</h3><p>场景非常多：</p>
<ul>
<li>请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了</li>
<li>异常处理：一般会在error类型和post类型过滤器中结合来处理。</li>
<li>服务调用时长统计：pre和post结合使用。</li>
</ul>
<h2 id="3-9-自定义过滤器"><a href="#3-9-自定义过滤器" class="headerlink" title="3.9.自定义过滤器"></a>3.9.自定义过滤器</h2><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p>
<h3 id="3-9-1-定义过滤器类"><a href="#3-9-1-定义过滤器类" class="headerlink" title="3.9.1.定义过滤器类"></a>3.9.1.定义过滤器类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 登录校验，肯定是在前置拦截</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 顺序设置为1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回true，代表过滤器生效。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">        <span class="comment">// 登录校验逻辑。</span></span><br><span class="line">        <span class="comment">// 1）获取Zuul提供的请求上下文对象</span></span><br><span class="line">        <span class="type">RequestContext</span> <span class="variable">ctx</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">// 2) 从上下文中获取request对象</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> ctx.getRequest();</span><br><span class="line">        <span class="comment">// 3) 从请求中获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;access-token&quot;</span>);</span><br><span class="line">        <span class="comment">// 4) 判断</span></span><br><span class="line">        <span class="keyword">if</span>(token == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(token.trim()))&#123;</span><br><span class="line">            <span class="comment">// 没有token，登录校验失败，拦截</span></span><br><span class="line">            ctx.setSendZuulResponse(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 返回401状态码。也可以考虑重定向到登录页。</span></span><br><span class="line">            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验通过，可以考虑把用户信息放入上下文，继续向后执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-9-2-测试"><a href="#3-9-2-测试" class="headerlink" title="3.9.2.测试"></a>3.9.2.测试</h3><p>没有token参数时，访问失败：</p>
<p>​    <img src="/2020/10/07/SpringCloud/1525683285697.png" alt="1525683285697"></p>
<p>添加token参数后：</p>
<p>​    <img src="/2020/10/07/SpringCloud/1525683354113.png" alt="1525683354113"></p>
<h2 id="3-10-负载均衡和熔断"><a href="#3-10-负载均衡和熔断" class="headerlink" title="3.10.负载均衡和熔断"></a>3.10.负载均衡和熔断</h2><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">retryable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># 连接超时时间(ms)</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">2000</span> <span class="comment"># 通信超时时间(ms)</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作重试</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">2</span> <span class="comment"># 同一服务不同实例的重试次数</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 同一实例的重试次数</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">  	<span class="attr">default:</span></span><br><span class="line">        <span class="attr">execution:</span></span><br><span class="line">          <span class="attr">isolation:</span></span><br><span class="line">            <span class="attr">thread:</span></span><br><span class="line">              <span class="attr">timeoutInMillisecond:</span> <span class="number">6000</span> <span class="comment"># 熔断超时时长：6000ms</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/" class="post-title-link" itemprop="url">Java面试题精选</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-01 10:15:19" itemprop="dateCreated datePublished" datetime="2020-10-01T10:15:19+08:00">2020-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2020-12-03 11:35:44" itemprop="dateModified" datetime="2020-12-03T11:35:44+08:00">2020-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1、JavaSE"><a href="#1、JavaSE" class="headerlink" title="1、JavaSE"></a>1、JavaSE</h1><hr>
<h2 id="Java中创建对象的5种方式"><a href="#Java中创建对象的5种方式" class="headerlink" title="Java中创建对象的5种方式"></a>Java中创建对象的5种方式</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">创建方式</th>
<th align="center">是否调用构造函数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">使用<code>new</code>关键字</td>
<td align="center">是</td>
<td></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">使用Class类的<code>newInstance()</code>方法</td>
<td align="center">是</td>
<td></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">使用Constructor类的<code>newInstance()</code></td>
<td align="center">是</td>
<td></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">使用<code>clone()</code>方法</td>
<td align="center">否</td>
<td></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">使用反序列化</td>
<td align="center">否</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>第2种和第3种方式都利用了反射机制。</p>
</blockquote>
<h2 id="Java当中的四种引用"><a href="#Java当中的四种引用" class="headerlink" title="Java当中的四种引用"></a>Java当中的四种引用</h2><ul>
<li><p><code>强引用&gt; 软引用&gt; 弱引用&gt; 虚引用</code>。    不同的引用类型主要体现在<strong>GC</strong>上。</p>
<ol>
<li><p>强引用：</p>
<p>​    如果一个对象具有强引用，他就不会被垃圾回收器回收，即使当前内存空间不足，JVM也不会回收它，而是抛出<code>OutOfMemoryError</code>错误，使程序因出现异常而终止。    </p>
<p>​    如果想中断强引用和某个对象之间的关联，可以显式的将引用值赋为<code>null</code>，这样一来的话，JVM就会在合适的时间回收该对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;	<span class="comment">// 强引用[，不可变对象]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;		<span class="comment">// 取消强引用 </span></span><br></pre></td></tr></table></figure></li>
<li><p>软引用：</p>
<p>​    在使用软引用时，如果内存空间足够，软引用就能继续被使用，而不会被垃圾回收器回收。只有内存不足时，软应用才会被垃圾回收器回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SoftReference</span> <span class="variable">softName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="string">&quot;张三&quot;</span>)；</span><br></pre></td></tr></table></figure></li>
<li><p>弱引用</p>
<p>​    具有弱引用的对象的拥有的生命周期更短暂。    因为当JVM进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。    不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WeakReference</span> <span class="variable">weakName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>虚引用</p>
<p>​    顾名思义，就是形同虚设。如果一个对象仅持有虚引用，那么它相当于没有引用，任何时候都可能被垃圾回收器回收。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="为什么要有不同的引用类型？"><a href="#为什么要有不同的引用类型？" class="headerlink" title="为什么要有不同的引用类型？"></a>为什么要有不同的引用类型？</h2><p>​    在C语言中，我们可以完全手动控制内存的申请和释放。    而在Java中有时候我们需要适当的控制对象的回收时机，因此就诞生了不同的引用类型。可以说不同的引用类型实际上是对GC机制的一种衍生。</p>
<p>​    有以下几个场景可以充分的说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 利用软引用和弱引用解决OOM（Out Of Memory）问题：</span><br><span class="line">    用一个HashMap来保存图片的路径和相应的图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 通过软引用实现Java对象的高速缓存：</span><br><span class="line">    比如我们创建了一个Person的类，如果每次查询一个人的信息时都需要重新构建一个实例，哪怕是几秒钟之前刚刚查询过的，这将引起大量Person对象的消耗，并且由于这些对象生命周期较短，会引起多次GC影响性能。此时，通过软引用和HashMap的结合可以构建高速缓存，提高性能。【？？？】</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Java中-和equals-的区别？equals-和hashCode的区别？"><a href="#Java中-和equals-的区别？equals-和hashCode的区别？" class="headerlink" title="Java中==和equals()的区别？equals()和hashCode的区别？"></a>Java中<code>==</code>和<code>equals()</code>的区别？<code>equals()</code>和<code>hashCode</code>的区别？</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、=="></a>1、==</h3><ol>
<li><p><code>==</code>比较的是两个对象的内存地址。    但是我们又常常碰到这样一个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(x==y);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(s1==s2);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(s1==s3);     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>既然<code>==</code>比较的是地址，那么<code>int、String</code>等数据类型的地址是怎样的呢？</p>
<p>​    对于基本数据类型（<code>byte、char、short、int、long、float、double、boolean</code>）来说，它们是作为常量在方法区中的常量池中以HashSet策略存储起来的。在常量池中，一个常量只会对应一个地址，因此不管再多的<code>123、&quot;123&quot;</code>这样的数据都保存在某一个地址中，即它们的引用指向的是内存中的同一块地址，因此基本类型和String类型的常量是可以通过<code>==</code>来直接比较其是否相等的。</p>
</li>
<li><p>另外，对于基本数据的包装类型（除了Float和Double），其它6种都是实现了常量池的，因此对于这些数据类型而言，我们<strong>一般</strong>以可以直接通过<code>==</code>来判断是否相等。</p>
</li>
<li><p>特殊情况如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.println(i1==i2);     <span class="comment">// true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i3==i4);     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>​    因为Integer在常量池中的存储范围是<code>[-128, 127]</code>，127在范围内，因此是直接存储在常量池中的，而128不在范围内，所以会在堆内存中创建一个新的对象来保存这个值，所以<code>i3、i4</code>分别指向了两个不同的内存地址，所以导致了不相等。</p>
</li>
</ul>
</li>
</ol>
<h3 id="2、equals"><a href="#2、equals" class="headerlink" title="2、equals()"></a>2、equals()</h3><ul>
<li><code>equals()</code>是超类<code>Object</code>类中的方法，用于比较两个对象是否相等。<ol>
<li>默认按两个对象的地址比较，此时和<code>==</code>的结果一样。</li>
<li>如果需要按对象的内容比较，需要重写<code>equals()</code>方法。</li>
</ol>
</li>
</ul>
<h3 id="3、hashCode"><a href="#3、hashCode" class="headerlink" title="3、hashCode"></a>3、hashCode</h3><ol>
<li><p>哈希表：</p>
<p>​    Hash表是一种数据结构，在JDK1.8之前，Hash表底层采用<code>数组+链表</code>实现，即使用链表处理冲突，同一Hash值的对象都存储在一个链表里。    但是当位于一个桶中的元素较多，即Hash值相等的元素较多时，通过key值依次查找的效率较低。    而在JDK1.8中，Hash表存储采用了<code>数组+链表+红黑树</code>实现，当链表长度超过阀值（默认为8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p><img src="/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/image-20200927103816987.png"></p>
<p><img src="/2020/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/image-20200927104116199.png"></p>
</li>
<li><p><code>hashCode()</code>是<code>Object</code>类的一个方法，返回一个<code>int</code>类型的整数，从方法名上就可以看出，其作用就是生成一个Hash码（散列码）。    所有的Hash函数都有如下一个基本特性：</p>
<ul>
<li>如果<code>a=b</code>，则<code>h(a)=h(b)</code>；</li>
<li>如果<code>a!=b</code>，则<code>h(a)</code>与<code>h(b)</code>可能得到相同的hash值。</li>
</ul>
</li>
<li><p>HashCode的作用：</p>
<p>​    要想明白HashCode的作用，必须先知道Java中的集合。    总的来说，Java中的集合（Collection）分为两类，一类是List，另一类是Set。List集合中的元素时有序的，可以重复。<strong>Set</strong>集合中元素是无序的，不可以重复。</p>
<p>​    那么两个元素是否重复应该根据什么依据来判断呢？    显然我们可以使用<code>Object.equals()</code>方法。但是，如果每增加一个元素就检查一次，如果集合中现在已经有1000个元素，那么第1001个元素加入的时候，它就要调用1000次<code>equals()</code>方法，这显然效率非常低。于是，Java采取了Hash表的原理。</p>
<p>​    此时，当集合要添加新元素时，首先调用这个元素的<code>HashCode()</code>方法，就能一下子定位到它本应该存放的位置上。如果这个位置上没有元素，他就可以直接存储在这个位置上。    如果这个位置上已经有元素了，就调用该元素的<code>equals()</code>方法与新元素进行比较，相同的话就不存储新元素，不相同的话就存储在该位置的链表(或红黑树)上。这样一来实际调用<code>equals()</code>方法的次数就大大降低了。</p>
</li>
</ol>
<h2 id="可以在hashCode中使用随机数字吗？"><a href="#可以在hashCode中使用随机数字吗？" class="headerlink" title="可以在hashCode中使用随机数字吗？"></a>可以在hashCode中使用随机数字吗？</h2><ul>
<li>不行，为了保证同一对象的hashCode值必须相同。</li>
</ul>
<h2 id="3-0-1-0-3返回值是什么？"><a href="#3-0-1-0-3返回值是什么？" class="headerlink" title="3*0.1==0.3返回值是什么？"></a>3*0.1==0.3返回值是什么？</h2><ul>
<li>false，因为有些浮点数不能完全精确的表示出来。</li>
</ul>
<h2 id="符号的扩展"><a href="#符号的扩展" class="headerlink" title="+=符号的扩展"></a>+=符号的扩展</h2><p>​    <code>+=</code>操作符会进行隐式的自动类型转换。    如<code>a+=b</code>会先计算出<code>a+b</code>的结果，再将得到的结果强转为与<code>a</code>相同的类型并赋值给<code>a</code>，而<code>a=a+b</code>则不会进行自动类型转换。如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    s+=<span class="number">1</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	s+=1逻辑上看作是s=s+1，计算结果被提升为int类型，再想short类型赋值时发生错误，因为不能将取值范围大的类型赋值给取值范围小的类型。	</span></span><br><span class="line"><span class="comment">	但是，s=s+1实际上进行2次运算，而s+=1只进行1此运算，并带有强制转换的特点，也就是说s+=1等价于s=(short)(s+1)，因此程序可以正常运行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="常量和变量的运算"><a href="#常量和变量的运算" class="headerlink" title="常量和变量的运算"></a>常量和变量的运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">byte</span> b1=<span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> b2=<span class="number">2</span>;</span><br><span class="line">    <span class="type">byte</span> b3=<span class="number">1</span> + <span class="number">2</span>;		<span class="comment">// ok</span></span><br><span class="line">    <span class="type">byte</span> b4=b1 + b2;	<span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>b3=1 + 2</code>，1和2是常量，为固定不变的数据，在编译的时候，已经确定了<code>1+2</code>的结果并没有超过<code>byte</code>类型的取值范围，可以赋值给变量<code>b3</code>，因此<code>b3=1 + 2</code>是正确的。</li>
<li><code>b3=b2 + b3</code>，<code>b2</code>和<code>b3</code>是变量，变量的值是可能变化的，在编译的时候，编译器不能确定<code>b2+b3</code>的结果是什么，因此会将结果以<code>int</code>类型进行处理，所以<code>int</code>类型不能赋值给<code>byte</code>l类型，因此编译失败。</li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>​    Java程序要求参与计算的数据的类型必须一致，如果数据类型不一致将发生数据类型的转换。</p>
<h3 id="1、自动转换"><a href="#1、自动转换" class="headerlink" title="1、自动转换"></a>1、自动转换</h3><ul>
<li><p>自动转换：将取值范围小的类型自动提升为取值范围大的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// byte x = b + i; // 报错</span></span><br><span class="line">    <span class="comment">//int类型和byte类型运算，首先会将byte类型转换为int类型数据，所以结果是int类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b + i;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2、强制转换"><a href="#2、强制转换" class="headerlink" title="2、强制转换"></a>2、强制转换</h3><ul>
<li>强制类型转换：将取值范围的类型强制转换为取值范围小的类型。<ol>
<li>浮点数转换为整数，直接取消小数点，可能造成数据损失精确度。</li>
<li><code>int</code>强制转换成<code>short</code>，砍掉2个字节，可能造成数据丢失。</li>
</ol>
</li>
</ul>
<h2 id="数据类型相关"><a href="#数据类型相关" class="headerlink" title="数据类型相关"></a>数据类型相关</h2><h3 id="1、64位的JVM中，int类型的长度是多少？"><a href="#1、64位的JVM中，int类型的长度是多少？" class="headerlink" title="1、64位的JVM中，int类型的长度是多少？"></a>1、64位的JVM中，int类型的长度是多少？</h3><ul>
<li>Java中，<code>int</code>类型变量的长度是一个固定值，与平台无关，都是32位。    也就是说，在32为和64位的Java虚拟机中，<code>int</code>类型的长度是相同的。</li>
</ul>
<h3 id="2、int和Integer的区别"><a href="#2、int和Integer的区别" class="headerlink" title="2、int和Integer的区别"></a>2、int和Integer的区别</h3><ul>
<li><code>Integer</code>是<code>int</code>的包装类型，在拆箱和装箱过程中，二者自动转换。<code>int</code>是基本类型，直接存数值，而<code>Integer</code>是对象，用一个引用指向这个对象。</li>
</ul>
<h3 id="3、int和Integer谁占用的内存更多？"><a href="#3、int和Integer谁占用的内存更多？" class="headerlink" title="3、int和Integer谁占用的内存更多？"></a>3、int和Integer谁占用的内存更多？</h3><ul>
<li><code>int</code>占用4个字节，存放在栈里面；而<code>Integer</code>占用16个字节存放在堆中。</li>
</ul>
<h3 id="4、String、StringBuffer和StringBuilder的区别"><a href="#4、String、StringBuffer和StringBuilder的区别" class="headerlink" title="4、String、StringBuffer和StringBuilder的区别"></a>4、String、StringBuffer和StringBuilder的区别</h3><ul>
<li><p><code>String</code>是字符串常量，<code>final</code>修饰；</p>
<p>​    <code>String</code>和<code>StringBuffer</code>主要区别是性能，<code>String</code>是不可变对象，每次对<code>String</code>类型进行操作就相当于产生了一个新的<code>String</code>对象，然后指向新的<code>String</code>对象。所以尽量不要对<code>String</code>进行大量的拼接操作，否则会产生很多临时对象，导致<code>GC</code>开始工作，影响系统性能。</p>
</li>
<li><p><code>StringBuffer</code>是字符串变量（线程安全）；</p>
<p>​    <code>StringBuffer</code>是对对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用<code>StringBuffer</code>。</p>
<p>​    注意：<code>JVM</code>会对<code>String</code>拼接做一定的优化，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;This is a&quot;</span> + <span class="string">&quot;simple&quot;</span> + <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="comment">// 会被JVM直接优化成：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;This is a simple test&quot;</span>;</span><br><span class="line"><span class="comment">// 此时就不存在拼接过程</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>StringBuilder</code>是字符串变量（线程不安全）。</p>
<p>​    <code>StringBuffer</code>是线程安全的可变字符串，其内部实现是可变数组。<code>StringBuilder</code>是<code>JDK1.5</code>新增的，其功能和<code>StringBuffer</code>相似，但是非线程安全。因此，在没有多线程问题的前提下，使用<code>StringBuilder</code>会取得更好的性能。</p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 线程安全和线程不安全：</span></span><br><span class="line"><span class="bullet">1.</span> 线程安全</span><br><span class="line"><span class="code">	线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时进行保护，其它线程不能访问直到该线程读取完，其它线程才可以使用。不会出现数据不一致或者数据污染。</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">2. 线程不安全</span></span><br><span class="line"><span class="code">	线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据，造成所得到的数据时脏数据。</span></span><br></pre></td></tr></table></figure>





<h3 id="5、什么是编译期常量？使用它有什么风险？"><a href="#5、什么是编译期常量？使用它有什么风险？" class="headerlink" title="5、什么是编译期常量？使用它有什么风险？"></a>5、什么是编译期常量？使用它有什么风险？</h3><ol>
<li><p>编译期常量 vs. 运行时常量</p>
<p>​    在Java程序中，常量用关键字**<code>static final</code>**修饰，常量又分为：<code>1.编译期常量</code>；<code>2.运行期常量</code>。</p>
<ul>
<li><p>编译期常量的特点就是：它的值在编译期就可以确定。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">99</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>对于运行时常量，它的值虽然在运行时初始化后不再发生变化，但它的初始值必须等到运行时才能确定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> rand.nextInt(<span class="number">20</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	虽然ii的值在程序初始化后就不会再发生变化，但是编译器无法在编译时确定它的值。[编译期只是做了一个翻译的工作，即将程序员编写的代码转化成机器能够识别的二进制代码]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>编译期常量不依赖类，不会引起类的初始化；而运行期常量依赖类，会引起类的初始化。</strong></p>
</li>
<li><p>公共静态不可变变量<code>[public] static final</code>也就是我们常说的编译器常量。</p>
</li>
</ul>
</li>
<li><p>编译期常量使用的风险</p>
<p>​    由于在编译时，常量会被替换为字面量，这是<code>JVM</code>提高运行效率优化代码的一种方式。但有时也会带来一定的麻烦。</p>
<p>​    如果我们的项目过大，项目整个编译一次特别耗费时间，那么我们有可能只编译代码修改的部分，此时如果我们一旦修改了常量A，且没有重新编译所有引用A常量的部分，那么未编译的部分代码仍会继续使用A的旧值，将会导致程序出错。</p>
</li>
</ol>
<h2 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h2><h3 id="1、你知道哪些垃圾回收算法"><a href="#1、你知道哪些垃圾回收算法" class="headerlink" title="1、你知道哪些垃圾回收算法"></a>1、你知道哪些垃圾回收算法</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 标记-清除</span><br><span class="line"><span class="bullet">2.</span> 标记-复制</span><br><span class="line"><span class="bullet">3.</span> 标记-整理</span><br><span class="line"><span class="bullet">4.</span> 分代回收</span><br></pre></td></tr></table></figure>





<h1 id="2、JavaWeb"><a href="#2、JavaWeb" class="headerlink" title="2、JavaWeb"></a>2、JavaWeb</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/20/SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/20/SpringBoot/" class="post-title-link" itemprop="url">SpringBoot</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-09-20 10:11:15" itemprop="dateCreated datePublished" datetime="2020-09-20T10:11:15+08:00">2020-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-29 10:14:35" itemprop="dateModified" datetime="2022-04-29T10:14:35+08:00">2022-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/2020/09/20/SpringBoot/SpringBoot.png"></p>
<h1 id="1、SpringBoot简介"><a href="#1、SpringBoot简介" class="headerlink" title="1、SpringBoot简介"></a>1、SpringBoot简介</h1><h2 id="1-1、为什么要学习SpringBoot"><a href="#1-1、为什么要学习SpringBoot" class="headerlink" title="1.1、为什么要学习SpringBoot"></a>1.1、为什么要学习SpringBoot</h2><p>因为 Spring 框架存在一些缺点，而 SpringBoot 框架在一定程度上很好的解决了这些缺点，所以我们需要学习 SpringBoot。</p>
<h3 id="1-1-1、Spring的缺点"><a href="#1-1-1、Spring的缺点" class="headerlink" title="1.1.1、Spring的缺点"></a>1.1.1、Spring的缺点</h3><ul>
<li><strong>配置复杂</strong>。虽然使用 Spring 开发的业务代码是轻量级的，但它的配置代码却是重量级的。Spring 中配置代码的发展可分为3个阶段：<ul>
<li>  （1）XML配置</li>
<li>  （2）注解配置</li>
<li>  （3）基于Java类的配置</li>
</ul>
</li>
<li><strong>依赖管理复杂</strong>。在搭建 Spring项目时，需要分析：<ul>
<li>  （1）要导入哪些库的坐标，以及与直接导入的库有依赖关系的库的坐标。</li>
<li>  （2）库与库之间的版本是否会产生冲突。</li>
</ul>
</li>
</ul>
<h3 id="1-1-2、SpringBoot-解决-Spring-的缺点"><a href="#1-1-2、SpringBoot-解决-Spring-的缺点" class="headerlink" title="1.1.2、SpringBoot 解决 Spring 的缺点"></a>1.1.2、SpringBoot 解决 Spring 的缺点</h3><p>SpringBoot 可以在很大程度上解决 Spring 的这2个缺点！</p>
<p>Spring Boot 推崇的<strong>约定大于配置</strong>的方式可以让我们很快地配置一个可以运行的程序。</p>
<ul>
<li>  SpringBoot 提供了约定俗成的配置文件信息，当然根据需求也可以覆盖默认配置信息。</li>
<li>  SpringBoot 框架实现了对绝大多数框架的依赖管理和依赖版本管理。</li>
</ul>
<h2 id="1-2、什么是SpringBoot"><a href="#1-2、什么是SpringBoot" class="headerlink" title="1.2、什么是SpringBoot"></a>1.2、什么是SpringBoot</h2><p>SpringBoot 是 Spring 项目的一个子工程，支持用一些固定的方式来构建生产级别的 Spring 应用。SpringBoot 推崇的<strong>约定大于配置</strong>的方式可以让你能够尽可能快速创建一个可以运行的程序。</p>
<p>其实人们把 SpringBoot 称为搭建程序的<code>脚手架</code>。其最主要作用就是帮我们<strong>快速的构建生产级别的Spring项目，并且尽可能的减少一切 XML 配置，做到开箱即用，迅速上手，让我们关注与业务而非配置</strong>。</p>
<p>SpringBoot 简化了基于 Spring 的应用开发，只需要“run”就能启动一个独立的、生产级别的 Spring 应用。SpringBoot 为 Spring 平台及大多数第三方库提供开箱即用的设置（<strong>提供默认设置</strong>）。多数 Spring Boot 应用只需要很少的 Spring 配置。</p>
<h2 id="1-3、SpringBoot的核心功能"><a href="#1-3、SpringBoot的核心功能" class="headerlink" title="1.3、SpringBoot的核心功能"></a>1.3、SpringBoot的核心功能</h2><ul>
<li>  <strong>起步依赖</strong></li>
<li>  <strong>自动配置</strong></li>
</ul>
<h3 id="1-3-1、起步依赖"><a href="#1-3-1、起步依赖" class="headerlink" title="1.3.1、起步依赖"></a>1.3.1、起步依赖</h3><p>起步依赖就是将某种场景需要使用到的依赖打包在一起，使用一个坐标，导入这一个坐标就相当于引入了一系列依赖。</p>
<p>比如，在 Web 场景中，我们可能要使用到 Servlet、jsp、SpringMVC 等等依赖，而 SpringBoot 就会把我们可能用到的依赖的坐标整合起来，并管理依赖的版本问题，只对外提供一个新的依赖坐标 <code>spring-boot-starter-web</code>。这样我们在使用时只需要导入 <code>spring-boot-starter-web</code> 依赖即可，而且无需管理版本问题。</p>
<h3 id="1-3-2、自动配置"><a href="#1-3-2、自动配置" class="headerlink" title="1.3.2、自动配置"></a>1.3.2、自动配置</h3><ul>
<li>  见下文</li>
</ul>
<hr>
<h1 id="2、SpringBoot快速入门"><a href="#2、SpringBoot快速入门" class="headerlink" title="2、SpringBoot快速入门"></a>2、SpringBoot快速入门</h1><h2 id="2-1-使用-Maven-创建-SpringBoot-项目"><a href="#2-1-使用-Maven-创建-SpringBoot-项目" class="headerlink" title="2.1 使用 Maven 创建 SpringBoot 项目"></a>2.1 使用 Maven 创建 SpringBoot 项目</h2><ol>
<li><p> 创建一个普通的 Maven 工程</p>
</li>
<li><p>在<code>pom.xml</code>文件中添加依赖。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!--JDK版本管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!--SpringBoot中所有依赖的版本管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!--Web启动器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写一个启动类。SpringBoot 项目通过 main 函数启动，我们需要创建一个<strong>启动类</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写一个Controller</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, spring boot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动测试。接下来，我们运行main函数，查看控制台，我们可以看到监听的端口信息：</p>
<ul>
<li>  服务器默认提供的访问端口号是8080；</li>
<li>  前端控制器拦截的路径是：<code>/</code>；</li>
<li>  <code>/hello</code>访问路径映射到了<code>HelloController</code>中的<code>hello()</code>方法。</li>
</ul>
</li>
</ol>
<p><img src="/2020/09/20/SpringBoot/1525487705460.png" alt="1525487705460"></p>
<ol start="6">
<li> 在浏览器中访问。</li>
</ol>
<p><img src="/2020/09/20/SpringBoot/1525487820824.png" alt="1525487820824"></p>
<ol start="7">
<li><p>简化部署。将源代码编译成一个可执行的jar包。</p>
<ul>
<li>  通常而言，Web 项目都会被打成一个 war 包，运行这个 war 包需要 TomCat 服务器。而导入了 <code>spring-boot-maven-plugin</code> 的插件，则可以将应用打成一个jar包，这样无需安装在目标服务器中安装TomCat该Web项目也可以正常运行。</li>
<li>  该插件的原理就是：集成了一个默认的 TomCat，将可执行文件 war 和 TomCat 一起打成一个 jar 包。</li>
</ul>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；无需在目标服务器中安装TomCat等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 将这个应用打成 jar 包，使用 <code>java -jar</code> 命令运行 jar 包。</p>
<ul>
<li><p>（1）打包</p>
<p>  <img src="/2020/09/20/SpringBoot/image-20210103112702556.png" alt="image-20210103112702556"></p>
</li>
<li><p>（2）jar包所在的目录</p>
<p>  <img src="/2020/09/20/SpringBoot/image-20210103112807935.png" alt="image-20210103112807935"></p>
</li>
<li><p>（3）在 jar 包所在目录下，使用 <code>java-jar</code> 的命令运行jar包</p>
<p>  <img src="/2020/09/20/SpringBoot/image-20210103113115811.png" alt="image-20210103113115811"></p>
</li>
<li><p>  （4）通过浏览器访问。</p>
</li>
</ul>
</li>
</ol>
<ol start="8">
<li> SpringBoot 在执行完打包命令后得到一个jar包，可以看到这个jar包也是一个压缩文件，在其<code>BOOT-INF/lib</code>目录下，我们可以看到已经导入了依赖和嵌入式的 TomCat，所以我们的目标环境就可以无需自己安装 TomCat 服务器也可正常运行。</li>
</ol>
<p><img src="/2020/09/20/SpringBoot/image-20210103113305223.png" alt="image-20210103113305223"></p>
<hr>
<h2 id="2-2-快速入门分析"><a href="#2-2-快速入门分析" class="headerlink" title="2.2 快速入门分析"></a>2.2 快速入门分析</h2><h3 id="2-2-1-POM文件"><a href="#2-2-1-POM文件" class="headerlink" title="2.2.1 POM文件"></a>2.2.1 POM文件</h3><h4 id="1、JDK版本管理"><a href="#1、JDK版本管理" class="headerlink" title="1、JDK版本管理"></a>1、JDK版本管理</h4><p>当前项目使用的 MAVEN 版本是 <code>apache-maven-3.5.2</code>，该版本默认使用 JDK1.5 对源码进行编译。</p>
<p>而项目开发使用的是 JDK 版本是 1.8，因此我们需要修改 Maven 编译时的 JDK 版本为 1.8。</p>
<ul>
<li>  <strong>全局修改</strong>：修改 Maven 的配置文件 <code>setting.xml</code>，一次修改，永久生效。</li>
</ul>
<p>做法：在<code>setting.xml</code>配置文件中的<code>&lt;profiles&gt;</code>标签下添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>  <strong>局部修改</strong>：针对具体的某个Maven项目的设置。每创建一个新项目都要重新设置。</li>
</ul>
<p>做法：在当前 Maven 工程的<code>pom.xml</code>文件中添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h4 id="2、SpringBoot的版本管理器（父项目）"><a href="#2、SpringBoot的版本管理器（父项目）" class="headerlink" title="2、SpringBoot的版本管理器（父项目）"></a>2、SpringBoot的版本管理器（父项目）</h4><ul>
<li>  <code>spring-boot-starter-parent</code>：只管理版本信息，并没有导入真正的jar包。</li>
</ul>
<p>所有的 SpringBoot 项目都会依赖一个名为<code>spring-boot-starter-parent</code>的启动器，这个启动器里面已经对常用的各种依赖（并非全部）的版本进行了管理，我们的项目只需以这个项目为父工程，就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可。</p>
<p>以后我们导入依赖默认不需要写版本（没有在<code>spring-boot-dependencies</code>项目中声明的依赖自然还需要手动声明版本号）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringBoot依赖一个父启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">&lt;!--SpringBoot的父启动器继续依赖一个父项目--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">&lt;!--该项目（SpringBoot的爷爷项目）用来管理SpringBoot应用里面的所有依赖版本。只是用来管理版本，并没有导入具体的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.0<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitronix.version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">bitronix.version</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="3、场景启动器"><a href="#3、场景启动器" class="headerlink" title="3、场景启动器"></a>3、场景启动器</h4><ul>
<li>  <code>spring-boot-starter-xxx</code>：SpringBoot 的场景启动器，真正导入 jar 包。</li>
</ul>
<p>SpringBoot 已经帮我们将开发中常见的场景所需的依赖抽取出来，制作成一个个的 <strong>starter（启动器）</strong>，只需要在项目里引入这些 starter，相关场景所有的直接/间接依赖就都会导入进来。我们需要使用什么功能就导入什么场景的启动器。</p>
<p>比如要创建一个 Web 项目，只需导入 SpringBoot 提供的 Web 启动器，该启动器会自动帮我们导入 Web 功能正常运行所依赖的所有依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的爷爷工程已经对版本进行了管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个时候，我们会发现项目中多出了大量的依赖：</p>
<ul>
<li>  这些都是 SpringBoot 根据 <code>spring-boot-starter-web</code> 这个依赖自动引入的，而且所有的版本都已经管理好，不会出现依赖冲突。</li>
<li>  SpringBoot 集成了大部分主流的框架并且制作了启动器，部分没有收录的框架如 MyBatis 则是自己实现了 SpringBoot 的启动器。</li>
</ul>
<p> <img src="/2020/09/20/SpringBoot/1525486980765.png" alt="1525486980765"></p>
<hr>
<h3 id="2-2-2-启动类-自动配置原理分析"><a href="#2-2-2-启动类-自动配置原理分析" class="headerlink" title="2.2.2 启动类 (自动配置原理分析)"></a>2.2.2 启动类 (自动配置原理分析)</h3><p><img src="/2020/09/20/SpringBoot/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.png"></p>
<p>在 SpringBoot 的启动类中有2个特殊的地方：</p>
<ul>
<li>  <strong>@SpringBootApplication</strong>：该注解标注在某个类上就说明这个类是 SpringBoot 项目的启动类，SpringBoot 应该运行这个类的 main 方法来启动 SpringBoot 应用。</li>
<li>  <strong>SpringApplication.run(Xxx.class, args)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> ，用来声明该应用是一个 SpringBoot 应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span>	<span class="comment">// 1️⃣</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动SpringBoot应用</span></span><br><span class="line">        SpringApplication.run(Application.class, args);	<span class="comment">// 2️⃣</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="1、-SpringBootApplication"><a href="#1、-SpringBootApplication" class="headerlink" title="1、@SpringBootApplication"></a>1、@SpringBootApplication</h4><p>查看源码：</p>
<p><img src="/2020/09/20/SpringBoot/1525488226710.png" alt="1525488226710"></p>
<blockquote>
<p>  <strong>@SpringBootConfiguration</strong></p>
</blockquote>
<p><code>@SpringBootConfiguration</code> 就是 <code>@Configuration</code>，表示该类是一个配置类，只不过在 SpringBoot 项目中为了更加语义化将其命名为 <code>@SpringBootConfiguration</code>。</p>
<ul>
<li>  查看源码：</li>
</ul>
<p><img src="/2020/09/20/SpringBoot/1525488518514.png" alt="1525488518514"></p>
<p>我们可以到，在这个注解中又有一个<code>@Configuration</code>注解。这个注解的作用就是声明当前类是一个配置类，项目启动时会将该类注册到容器中，并自动加载配置类中的配置信息。</p>
<p>配置类 <code>&lt;==&gt;</code> 配置文件，配置类也是容器中的一个组件，所以<code>@Configuration</code>注解的源码中也有<code>@Component</code>注解，即只使用<code>@Configuration</code>注解后也会被扫描添加到容器中。</p>
<img src="/2020/09/20/SpringBoot/image-20210909103358197.png" alt="image-20210909103358197" style="zoom:67%;">



<hr>
<blockquote>
<p>  <strong>@EnableAutoConfiguration</strong></p>
</blockquote>
<p><code>@EnableAutoConfiguration</code> 的作用就是开启 SpringBoot 的自动配置功能，就是根据项目中引入的依赖来生成对应的默认配置。</p>
<ul>
<li><p>自动配置的原理就是：SpringBoot 根据项目添加的依赖，提供这些依赖的约定成俗的默认配置。比如我们引入了<code>spring-boot-starter-web</code>起步依赖，这个起步依赖中又包含了<code>tomcat</code>、<code>SpringMVC</code>和<code>Servlet</code>等依赖，此时 SpringBoot 自动配置就会提供<code>tomcat</code>、<code>SpringMVC</code>和<code>Servlet</code>等组件的默认配置信息。</p>
</li>
<li><p>总结：SpringBoot 内部对大量的第三方库或 Spring 内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。</p>
</li>
<li><p>所以，我们使用 SpringBoot 构建一个项目，只需要引入所需框架的依赖，配置就可以交给 SpringBoot 处理了。如果你不希望使用SpringBoot 的默认配置，它也提供了自定义配置的入口。</p>
</li>
</ul>
<blockquote>
<p>  <strong>@ComponentScan</strong></p>
</blockquote>
<ul>
<li>  查看源码：</li>
</ul>
<p> <img src="/2020/09/20/SpringBoot/1525498265579.png" alt="1525498265579"></p>
<ul>
<li>  配置组件扫描的指令。提供了类似与<code>&lt;context:component-scan&gt;</code>标签相似的作用。</li>
<li>  通过<code>basePackageClasses</code>或者<code>basePackages</code>属性来指定要扫描的包。如果没有指定这些属性，默认从使用该注解的类所在的包开始，扫描当前包及其子包。</li>
<li>  <code>@ComponentScan注解</code>是<code>@SpringBootApplication注解</code>的子注解，而<code>@SpringBootApplication注解</code>作用在启动类上，因此<strong>扫描的包是启动类所在包及其子包</strong>。因此，一般启动类会放在一个比较靠前的包目录中。</li>
</ul>
<hr>
<h2 id="2-3-使用Spring-Initializer快速创建-SpringBoot-项目"><a href="#2-3-使用Spring-Initializer快速创建-SpringBoot-项目" class="headerlink" title="2.3    使用Spring Initializer快速创建 SpringBoot 项目"></a>2.3    使用Spring Initializer快速创建 SpringBoot 项目</h2><blockquote>
<p>  默认 SpringBoot 项目的目录结构：</p>
</blockquote>
<ul>
<li>  启动类（主程序）已经生成好了，我们只需要实现自己的业务逻辑</li>
<li><code>resources</code>文件夹中的目录结构：<ul>
<li>  <code>static</code>：保存所有的静态资源；</li>
<li>  <code>templates</code>：保存所有的模板页面；（SpringBoot 默认jar包使用嵌入式的TomCat，默认不支持JSP页面），可以使用的模板引擎（freemarker、thymeleaf）；</li>
<li>  <code>application.properties</code>：应用配置文件。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="3、SpringBoot原理分析"><a href="#3、SpringBoot原理分析" class="headerlink" title="3、SpringBoot原理分析"></a>3、SpringBoot原理分析</h1><p>SpringBoot 为我们提供了默认配置，而默认配置生效的条件一般有两个：</p>
<ul>
<li>你引入了相关依赖</li>
<li>你自己没有配置</li>
</ul>
<blockquote>
<ol>
<li> <strong>启动依赖</strong></li>
</ol>
</blockquote>
<ul>
<li>  所以，我们如果不想手动配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了 <code>spring-bbot-starter-parent</code>，就会自动管理依赖及版本了。</li>
<li>  因此，使用SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>全局配置</strong></li>
</ol>
</blockquote>
<ul>
<li>  另外，SpringBoot 提供了默认配置，而默认配置可以通过改写 <code>application.properties</code> 配置文件来进行覆盖。</li>
<li>  因此，使用SpringBoot的第二件事情，就是通过<code>application.properties</code>来覆盖默认配置，所以我们需要知道 SpringBoot 配置属性的 key。</li>
<li>  SpringBoot 默认会从类路径下的加载 <code>application.properties</code> 或者 <code>application.yml</code> 文件。</li>
</ul>
<hr>
<h1 id="4、Java配置"><a href="#4、Java配置" class="headerlink" title="4、Java配置"></a>4、Java配置</h1><ul>
<li>  在 SpringBoot 中，我们可以不编写任何配置文件，就能实现一个 SpringMVC 的项目了。</li>
<li>  但是如果没有任何的 XML，那么我们如果要配置一个 Bean 该怎么办？</li>
<li>  比如我们要配置一个数据库连接池对象，在 Spring 中我们可以使用 XML 配置文件配置对象信息，在项目启动时将对应的 Class 对象加载到容器中。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  那么在 SpringBoot 中是如何实现对象注入容器的呢？我们可以使用Java配置。</li>
</ul>
<h2 id="4-1、使用Java配置"><a href="#4-1、使用Java配置" class="headerlink" title="4.1、使用Java配置"></a>4.1、使用Java配置</h2><p>Java 配置就是：通过使用 Java 类和一些注解，代替配置文件保存配置信息。比较常用的注解有：</p>
<ul>
<li><code>@Configuration</code>：作用在类上，声明该类是一个配置类，用于代替 XML 配置文件；</li>
<li><code>@Bean</code>：作用在方法上，将方法的返回值添加到 Spring 容器中，用于代替<code>&lt;bean&gt;</code>标签；</li>
<li><code>@value</code>：作用在属性上，属性注入；</li>
<li><code>@PropertySource</code>：作用在类上，用来指定外部属性文件中的路径。</li>
</ul>
<h3 id="例子：用Java配置实现数据库连接池的配置："><a href="#例子：用Java配置实现数据库连接池的配置：" class="headerlink" title="例子：用Java配置实现数据库连接池的配置："></a>例子：用Java配置实现数据库连接池的配置：</h3><ol>
<li>首先引入Druid连接池依赖：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个jdbc.properties文件，编写jdbc属性：</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/leyou</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写配置类代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span></span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<ul>
<li><code>@Configuration</code>：声明<code>JdbcConfig类</code>是一个配置类</li>
<li><code>@PropertySource</code>：指定属性文件的路径是:<code>classpath:jdbc.properties</code></li>
<li>通过<code>@Value</code>为属性注入值</li>
<li>通过<code>@Bean</code>注解将 <code>dataSource()</code>方法的返回值加入 Spring 容器中。</li>
<li>然后我们就可以在任意位置通过<code>@Autowired</code>注入DataSource了。</li>
</ul>
<ol start="4">
<li>编写测试类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, spring boot!&quot;</span> + dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后Debug运行并查看：</p>
<p><img src="/2020/09/20/SpringBoot/1525492528558.png" alt="1525492528558"></p>
<p>属性注入成功了！</p>
<hr>
<h2 id="4-2、SpringBoot的属性注入"><a href="#4-2、SpringBoot的属性注入" class="headerlink" title="4.2、SpringBoot的属性注入"></a>4.2、SpringBoot的属性注入</h2><ul>
<li>  在上面的案例中，我们使用了 Java 类的配置方式。不过属性注入使用的是 <code>@Value</code> 注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型和 String 类型变量。[<code>@Value</code>注解是Spring中通用的注解]</li>
<li>  <strong>在SpringBoot中，提供了一种新的属性注入方式，支持各种 Java 基本数据类型及复杂类型的注入。</strong></li>
<li><code>@ConfigurationProperties(prefix = &quot;xxx&quot;)--&gt;&gt; @EnableConfigurationProperties(xxx.class)</code><ol>
<li>将基本属性注入到一个类A中；</li>
<li>将类A通过反射注入到类B中。</li>
</ol>
</li>
</ul>
<blockquote>
<ol>
<li> 我们定义一个<code>JdbcProperties类</code>，用来进行属性注入：</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jdbc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="comment">// getters 和 setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>@ConfigurationProperties</strong> 注解默认读取的是类路径下的 <code>application.yml</code> 配置文件，<code>prefix=&quot;jdbc&quot;</code>，通过注解的属性<code>prefix</code>限定读取的数据，在这里是读取属性文件中，前缀为 jdbc 的值。</p>
</li>
<li><p>要求类中定义的各个属性名称必须与<code>application.yml</code>属性文件中的<code>jdbc.</code>后面部分一致</p>
</li>
<li><p>需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把<code>jdbc.properties</code>名称改为<code>application.properties</code>，这是SpringBoot默认读取的属性文件名：</p>
</li>
</ul>
<p><img src="/2020/09/20/SpringBoot/1525496325572.png" alt="1525496325572"></p>
<blockquote>
<ol start="2">
<li> 在<code>JdbcConfig类</code>中使用<code>JdbcProperties对象</code>：</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JdbcProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(JdbcProperties jdbc)</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(jdbc.getUrl());</span><br><span class="line">        dataSource.setDriverClassName(jdbc.getDriverClassName());</span><br><span class="line">        dataSource.setUsername(jdbc.getUsername());</span><br><span class="line">        dataSource.setPassword(jdbc.getPassword());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>**@EnableConfigurationProperties(JdbcProperties.class)**：表明该类要使用 <code>JdbcProperties</code>类的实例对象。</li>
<li>通过反射的方式动态的生成<code>JdbcProperties</code>对象，可以在该类的方法中直接使用：</li>
</ol>
<blockquote>
<ol start="3">
<li> 测试结果：</li>
</ol>
</blockquote>
<p><img src="/2020/09/20/SpringBoot/1525492528558.png" alt="1525492528558"></p>
<hr>
<h2 id="4-3、更简单的注入"><a href="#4-3、更简单的注入" class="headerlink" title="4.3、更简单的注入"></a>4.3、更简单的注入</h2><ul>
<li>  事实上，如果一段属性（配置信息）只被一个Bean需要，我们无需将先其注入到一个类（<code>JdbcProperties</code>）中。而是直接在需要的地方使用<code>@ConfigurationProperties注解</code>声明即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;jdbc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  我们直接把<code>@ConfigurationProperties(prefix = &quot;jdbc&quot;)</code>声明在需要使用该段属性的<code>@Bean</code>的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。</li>
<li>  使用的前提是：<strong>该类必须有对应属性的set方法！</strong></li>
</ul>
<hr>
<h1 id="5、SpringBoot整合SpringMVC"><a href="#5、SpringBoot整合SpringMVC" class="headerlink" title="5、SpringBoot整合SpringMVC"></a>5、SpringBoot整合SpringMVC</h1><h2 id="5-1、添加起步依赖"><a href="#5-1、添加起步依赖" class="headerlink" title="5.1、添加起步依赖"></a>5.1、添加起步依赖</h2><p>直接引入<code>spring-boot-starter-web</code>启动依赖即可。</p>
<h2 id="5-2、自定义配置信息"><a href="#5-2、自定义配置信息" class="headerlink" title="5.2、自定义配置信息"></a>5.2、自定义配置信息</h2><blockquote>
<ol>
<li> <strong>修改端口号</strong></li>
</ol>
</blockquote>
<ul>
<li>  查看SpringBoot的全局属性可知，端口通过以下方式配置：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 映射端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>



<blockquote>
<ol start="2">
<li> <strong>访问静态资源</strong></li>
</ol>
</blockquote>
<p>默认的静态资源路径为：</p>
<ul>
<li>classpath:/META-INF/resources/</li>
<li>classpath:/resources/</li>
<li>classpath:/static/</li>
<li>classpath:/public</li>
</ul>
<p>只要静态资源放在这些目录中任何一个，SpringMVC 都会帮我们处理。我们习惯会把静态资源放在<code>classpath:/static/</code>目录下。</p>
<p> <img src="/2020/09/20/SpringBoot/1525512196866.png" alt="1525512196866"></p>
<blockquote>
<ol start="3">
<li> <strong>添加拦截器</strong></li>
</ol>
</blockquote>
<ul>
<li><p>如果你想要保持 SpringBoot 的一些默认 MVC 特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器、视图控制器、类型转换器 等等），你应该：</p>
<ol>
<li>让一个类实现<code>WebMvcConfigurer</code>，</li>
<li>并且添加<code>@Configuration</code>注解，但是<strong>千万不要</strong>加<code>@EnableWebMvc</code>注解。</li>
</ol>
<p>  如果你想要自定义<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ExceptionResolver</code>等组件，你可以创建一个<code>WebMvcRegistrationsAdapter</code>实例 来提供以上组件。</p>
</li>
<li><p>如果你想要完全自定义 SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加<code>@Configuration</code>注解和<code>@EnableWebMvc</code>注解</p>
</li>
<li><p>总结：通过实现<code>WebMvcConfigurer</code>类并添加<code>@Configuration</code>注解来实现自定义部分 SpringMVC 配置。</p>
</li>
</ul>
<blockquote>
<ol>
<li> 首先我们定义一个拦截器：</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(LoginInterceptor.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;preHandle method is now running!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;postHandle method is now running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;afterCompletion method is now running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<ol start="2">
<li> 然后，我们定义配置类，注册拦截器：</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过<span class="doctag">@Bean</span>注解，将我们定义的拦截器注册到Spring容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LoginInterceptor <span class="title function_">loginInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写接口中的addInterceptors方法，添加自定义拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径</span></span><br><span class="line">        registry.addInterceptor(<span class="built_in">this</span>.loginInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构如下：</p>
<p> <img src="/2020/09/20/SpringBoot/1525513555179.png" alt="1525513555179"></p>
<p>接下来运行并查看日志：</p>
<p>你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。</p>
<p>SpringBoot通过<code>logging.level.*=debug</code>来配置日志级别，*填写包名</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置com.leyou包的日志级别为debug</span></span><br><span class="line"><span class="attr">logging.level.com.leyou</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>再次运行查看：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">01</span><span class="variable">.811</span> DEBUG <span class="number">4548</span> --- [p-nio-<span class="number">80</span>-exec-<span class="number">1</span>] com<span class="variable">.leyou</span><span class="variable">.interceptor</span><span class="variable">.LoginInterceptor</span>   : preHandle method is now running!</span><br><span class="line"><span class="number">2018</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">01</span><span class="variable">.854</span> DEBUG <span class="number">4548</span> --- [p-nio-<span class="number">80</span>-exec-<span class="number">1</span>] com<span class="variable">.leyou</span><span class="variable">.interceptor</span><span class="variable">.LoginInterceptor</span>   : postHandle method is now running!</span><br><span class="line"><span class="number">2018</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">01</span><span class="variable">.854</span> DEBUG <span class="number">4548</span> --- [p-nio-<span class="number">80</span>-exec-<span class="number">1</span>] com<span class="variable">.leyou</span><span class="variable">.interceptor</span><span class="variable">.LoginInterceptor</span>   : afterCompletion method is now running!</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="6、SpringBoot整合JDBC和事务"><a href="#6、SpringBoot整合JDBC和事务" class="headerlink" title="6、SpringBoot整合JDBC和事务"></a>6、SpringBoot整合JDBC和事务</h1><p>Spring 中的 JDBC 连接和事务是配置中的重要一环，在 SpringBoot 中该如何处理呢？</p>
<ul>
<li>  答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  至于事务，SpringBoot 中通过注解来控制。就是我们熟知的 <code>@Transactional</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">queryById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="7、SpringBoot整合连接池"><a href="#7、SpringBoot整合连接池" class="headerlink" title="7、SpringBoot整合连接池"></a>7、SpringBoot整合连接池</h1><h2 id="7-1、默认DataBase"><a href="#7-1、默认DataBase" class="headerlink" title="7.1、默认DataBase"></a>7.1、默认DataBase</h2><p>事实上，在引入JDBC启动器的时候，SpringBoot已经自动帮我们引入了一个数据库连接池。因此，我们只需要指定连接池参数即可：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接四大参数</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/heima</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"># 可省略，SpringBoot自动推断</span></span><br><span class="line"><span class="attr">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span>=<span class="string">60000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>



<h2 id="7-2、手动引入DataBase"><a href="#7-2、手动引入DataBase" class="headerlink" title="7.2、手动引入DataBase"></a>7.2、手动引入DataBase</h2><p>当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>配置接信息。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化连接数</span></span><br><span class="line"><span class="attr">spring.datasource.druid.initial-size</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#最小空闲连接</span></span><br><span class="line"><span class="attr">spring.datasource.druid.min-idle</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#最大活动连接</span></span><br><span class="line"><span class="attr">spring.datasource.druid.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#获取连接时测试是否可用</span></span><br><span class="line"><span class="attr">spring.datasource.druid.test-on-borrow</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#监控页面启动</span></span><br><span class="line"><span class="attr">spring.datasource.druid.stat-view-servlet.allow</span>=<span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="8、SpringBoot整合MyBatis"><a href="#8、SpringBoot整合MyBatis" class="headerlink" title="8、SpringBoot整合MyBatis"></a>8、SpringBoot整合MyBatis</h1><h2 id="8-1、MyBatis"><a href="#8-1、MyBatis" class="headerlink" title="8.1、MyBatis"></a>8.1、MyBatis</h2><blockquote>
<p>SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis自己实现了：</p>
</blockquote>
<ol>
<li>添加MyBatis起步依赖</li>
<li>添加数据库驱动坐标</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mysql --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加数据库连接信息</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mybatis 别名扫描</span></span><br><span class="line"><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.heima.pojo</span></span><br><span class="line"><span class="comment"># mapper.xml文件位置,如果没有映射文件，请注释掉</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:mappers/*.xml</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tip：这里面没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加<code>@Mapper</code>注解，才能被识别。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="8-2、SpringBoot整合通用Mapper"><a href="#8-2、SpringBoot整合通用Mapper" class="headerlink" title="8.2、SpringBoot整合通用Mapper"></a>8.2、SpringBoot整合通用Mapper</h2><blockquote>
<p>超链接：<a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2020/09/07/%E9%80%9A%E7%94%A8Mapper%E7%9A%84%E8%AF%A6%E8%A7%A3/">通用Mapper详解</a></p>
</blockquote>
<hr>
<h1 id="9、SpringBoot整合Junit"><a href="#9、SpringBoot整合Junit" class="headerlink" title="9、SpringBoot整合Junit"></a>9、SpringBoot整合Junit</h1><ol>
<li><p>添加<code>Junit</code>起步依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = MySpringBootApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span>()&#123;</span><br><span class="line">    <span class="comment">// 测试逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>@RunWith()</code>的作用是替换单元测试模块为SpringBoot的单元测试模块</li>
<li><code>@SpringBootTest()</code>的属性指定的启动类的字节码对象。</li>
</ul>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/" class="post-title-link" itemprop="url">通过虚拟机安装CentOS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-09-17 23:03:08" itemprop="dateCreated datePublished" datetime="2020-09-17T23:03:08+08:00">2020-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-11-20 17:30:14" itemprop="dateModified" datetime="2021-11-20T17:30:14+08:00">2021-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h1><p>两个概念： 物理机和虚拟机。</p>
<p>创建虚拟机需要一台<strong>支持虚拟化</strong>的物理机和虚拟化软件（如VMWare）。需要先当前物理机开启虚拟化支持。</p>
<p>步骤大体分两步，第一步使用虚拟化软件（VMWara）虚拟出一台虚拟机，然后再为这台虚拟机安装操作系统！</p>
<h2 id="查看虚拟化支持"><a href="#查看虚拟化支持" class="headerlink" title="查看虚拟化支持"></a>查看虚拟化支持</h2><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20211119221353669.png" alt="image-20211119221353669" style="zoom: 50%;">





<h1 id="1-安装-VMvare-虚拟化软件"><a href="#1-安装-VMvare-虚拟化软件" class="headerlink" title="1    安装 VMvare 虚拟化软件"></a>1    安装 VMvare 虚拟化软件</h1><h2 id="1-1-什么是虚拟软件"><a href="#1-1-什么是虚拟软件" class="headerlink" title="1.1    什么是虚拟软件"></a>1.1    什么是虚拟软件</h2><p>虚拟化软件是一个可以使你在一台机器上同时运行两个或更多的 Windows、LINUX 等系统。它可以模拟一个标准PC环境。这个环境和真实的计算机一样，都有芯片组、CPU、内存、显卡、声卡、网卡、软驱、硬盘、光驱、串口、并口、USB控制器等。</p>
<h2 id="1-2-常用的虚拟原件"><a href="#1-2-常用的虚拟原件" class="headerlink" title="1.2    常用的虚拟原件"></a>1.2    常用的虚拟原件</h2><ul>
<li><code>VMware workstation</code></li>
<li><code>VirtualBox</code></li>
</ul>
<h2 id="1-3-VMware-workstation安装"><a href="#1-3-VMware-workstation安装" class="headerlink" title="1.3    VMware workstation安装"></a>1.3    VMware workstation安装</h2><ol start="2">
<li><p>点击next进行安装</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps1.jpg" alt="img"></p>
</li>
<li><p> 选择安装方式</p>
</li>
</ol>
<p>   <img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps2.jpg" alt="img"></p>
<ul>
<li>Typical：典型安装</li>
<li>Custom：自定义安装</li>
</ul>
<ol start="4">
<li><p>选择程序安装位置</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps3.jpg" alt="img"></p>
<p>点击 change 选择程序安装位置，然后点击 next</p>
</li>
<li><p>选择是否自动检测更新</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps4.jpg" alt="img"></p>
</li>
<li><p>创建快捷方式，选择后点击 next。</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps5.jpg" alt="img"></p>
</li>
<li><p>配置完成，开始安装程序</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps6.jpg" alt="img"></p>
</li>
<li><p>开始安装虚拟原件</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps7.jpg" alt="img"></p>
</li>
<li><p>完成。</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps8.jpg" alt="img"></p>
</li>
</ol>
<hr>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps9.jpg" alt="img"></p>
<p>虚拟软件安装完成后会在 <code>控制面板\网络和Internet\网络连接</code> 下多出来两个虚拟网卡<code>VMware Network Adapter VMnet1</code>和<code>VMware Network Adapter VMnet8</code>，需要将这两个网卡禁用。</p>
<ul>
<li><p>选中VMnet1和VMnet8，右键点击禁用</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps10.jpg" alt="img"> </p>
</li>
</ul>
<hr>
<h1 id="2-安装-CentOS"><a href="#2-安装-CentOS" class="headerlink" title="2    安装 CentOS"></a>2    安装 CentOS</h1><ul>
<li>环境：Windows7 , VMware Workstation10, CentOS6.4</li>
<li>为什么选择 CentOS ?<ol>
<li>主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS</li>
<li>免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本</li>
<li>更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-1-安装步骤"><a href="#2-1-安装步骤" class="headerlink" title="2.1 安装步骤"></a>2.1 安装步骤</h2><ol>
<li><p>打开 <code>VMware Workstation</code>。</p>
</li>
<li><p><code>文件 → 新建虚拟机</code> 或 直接点击 <code>创建新的虚拟机</code>图标。</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps1-1600356028741.jpg" alt="img"></p>
</li>
<li><p>选择 <code>典型（推荐）→ 下一步 </code></p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps2-1600356057469.jpg" alt="img"></p>
</li>
<li><p>稍后安装操作系统</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps3-1600356078993.jpg" alt="img"></p>
</li>
<li><p>选择操作系统和版本</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps4-1600356106544.jpg" alt="img"></p>
</li>
<li><p>输入虚拟机名称和安装路径</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps5-1600356118626.jpg" alt="img"></p>
</li>
<li><p>设置磁盘大小</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps6-1600356132029.jpg" alt="img"></p>
</li>
<li><p>自定义硬件</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps7-1600356150025.jpg" alt="img"></p>
</li>
<li><p>选择CentOS安装镜像文件</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps8-1600356164481.jpg" alt="img"></p>
</li>
<li><p>点击完成</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps9-1600356185973.jpg" alt="img"></p>
</li>
<li><p>启动虚拟机</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps10-1600356210771.jpg" alt="img"></p>
</li>
<li><p>选择第一项，安装全新操作系统或升级现有操作系统</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps11.jpg" alt="img"></p>
</li>
<li><p>Tab键进行选择，选择Skip，退出检测</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps12.jpg" alt="img"></p>
</li>
<li><p>点击Next</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps13.jpg" alt="img"></p>
</li>
<li><p>选择语言，这里选择的是中文简体</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps14.jpg" alt="img"></p>
</li>
<li><p>选择键盘样式</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps15.jpg" alt="img"></p>
</li>
<li><p>选择存储设备</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps16.jpg" alt="img"></p>
<p>如果以前安装过虚拟机，会出现这个警告，选择是，忽略所有数据</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps17.jpg" alt="img"></p>
</li>
<li><p>输入主机名</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps18.jpg" alt="img"></p>
</li>
<li><p>配置网络</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps19.jpg" alt="img"></p>
</li>
<li><p>设置时区，勾选使用UTC时间</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps20.jpg" alt="img"></p>
</li>
<li><p>输入根用户（root）的密码</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps21.jpg" alt="img"></p>
<p>如果密码过于简单会出现提示，点击无论如何都使用</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps22.jpg" alt="img"></p>
</li>
<li><p>根据此Linux具体功能，选择不同的方式</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps23.jpg" alt="img"></p>
</li>
<li><p>选择现在自定义，自定义安装需要的软件，如桌面配置[这一步可以根据需求选择是否跳过]</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps24.jpg" alt="img"></p>
<p>可以根据具体的情况来配置，如可安Eclipse</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps25.jpg" alt="img"></p>
<p>还可以安装Java平台、Perl支持等</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps26.jpg" alt="img"></p>
<p>选择语言支持</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps27.jpg" alt="img"></p>
</li>
<li><p>点击下一步，开始安装</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps28.jpg" alt="img"></p>
</li>
<li><p>安装完成后，点击重新导引</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps29.jpg" alt="img"></p>
</li>
<li><p>点击前进按钮</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps30.jpg" alt="img"></p>
</li>
<li><p>点击是，同意许可，再点击前进按钮</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps31.jpg" alt="img"></p>
</li>
<li><p>创建用户</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps32.jpg" alt="img"></p>
</li>
<li><p>设置日期和时间，如果可以上网，勾选在网上同步日期和时间</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/wps33.jpg" alt="img"></p>
<p>最后点击前进，完成安装！</p>
</li>
</ol>
<h1 id="3、基本操作"><a href="#3、基本操作" class="headerlink" title="3、基本操作"></a>3、基本操作</h1><ul>
<li><p>快捷键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt      切换Windows桌面和虚拟机桌面</span><br></pre></td></tr></table></figure></li>
<li><p>本机Linux账户密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">管理员用户：</span><br><span class="line">    username： root</span><br><span class="line">    password： itcast</span><br><span class="line">普通用户：</span><br><span class="line">    username： itcast</span><br><span class="line">    password： itcast</span><br></pre></td></tr></table></figure></li>
<li><p>本机中Linux系统的安装位置：<code>D:\CentOS\Linux.vmx.lck</code></p>
</li>
<li><p><code>ifcofig</code>：Linux中查看本机的IP地址。本机中Linux虚拟机的地址<code>192.168.64.128</code></p>
</li>
<li><p>CRT窗口中的复制粘贴：选中内容后点击右键即可完成复制粘贴</p>
</li>
</ul>
<hr>
<h1 id="VirtualBox安装CentOS7"><a href="#VirtualBox安装CentOS7" class="headerlink" title="VirtualBox安装CentOS7"></a>VirtualBox安装CentOS7</h1><h2 id="1、VirtualBox安装CentOS7"><a href="#1、VirtualBox安装CentOS7" class="headerlink" title="1、VirtualBox安装CentOS7"></a>1、VirtualBox安装CentOS7</h2><ol>
<li><p>下载安装VirtualBox。官网：<a target="_blank" rel="noopener" href="https://www.virtualbox.org/">https://www.virtualbox.org</a></p>
</li>
<li><p>打开VirtualBox –&gt; 新建；</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20210127103545039.png" alt="image-20210127103545039"></p>
<blockquote>
<p>因为Centos其实是RedHat的克隆版，所以版本类型选择RedHat（64-bit）</p>
</blockquote>
</li>
<li><p>下一步，选择默认配置就好</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20210127103717711.png" alt="image-20210127103717711"></p>
</li>
<li><p>下一步，</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20210127103754923.png" alt="image-20210127103754923"></p>
</li>
<li><p>创建；</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20210127104004000.png" alt="image-20210127104004000"></p>
<blockquote>
<p>在选择磁盘文件类型的时候主要考虑该Centos 7是否要被其他虚拟化软件(如vmware)使用</p>
<ul>
<li>VDI：被VirtualBox使用</li>
<li>VHD：被Microsoft Virtual PC使用</li>
<li>VMDK：被Vmware使用</li>
</ul>
</blockquote>
</li>
<li><p>这里选择VDI类型，点击下一步</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20210127104135785.png" alt="image-20210127104135785"></p>
</li>
<li><p>选择动态分配，下一步</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20210127104316650.png" alt="image-20210127104316650"></p>
</li>
<li><p>点击创建，完成对虚拟机的创建</p>
</li>
</ol>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20210127104421814.png" alt="image-20210127104421814"></p>
<h2 id="2、将CentOS7-iso文件与该虚拟机关联起来"><a href="#2、将CentOS7-iso文件与该虚拟机关联起来" class="headerlink" title="2、将CentOS7.iso文件与该虚拟机关联起来"></a>2、将CentOS7.iso文件与该虚拟机关联起来</h2><ol>
<li><p>点击设置 -&gt; 存储–&gt; 选择虚拟盘</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20210127104828201.png" alt="image-20210127104828201"></p>
</li>
<li><p>系统–&gt;主板，将光驱启动设置为第一项，点击 OK</p>
<p><img src="/2020/09/17/%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS/image-20210127105012031.png" alt="image-20210127105012031"></p>
</li>
<li><p>点击启动，开始安装过程</p>
</li>
<li><p>选择Install Centos Linux 7</p>
</li>
<li><p>参考如下博客</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/alsodzy/p/9811175.html">https://www.cnblogs.com/alsodzy/p/9811175.html</a></p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper/" class="post-title-link" itemprop="url">如何使用分页插件PageHelper</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-09-16 14:33:23" itemprop="dateCreated datePublished" datetime="2020-09-16T14:33:23+08:00">2020-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-04-11 23:31:04" itemprop="dateModified" datetime="2021-04-11T23:31:04+08:00">2021-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-PageHelper简介"><a href="#1-PageHelper简介" class="headerlink" title="1    PageHelper简介"></a>1    PageHelper简介</h1><p>​    <code>PageHelper</code>是<code>GitHub</code>上开源的<code>MyBatis</code>的分页插件，使用起来非常简单、方便，并且支持任何复杂的单表、多表分页。</p>
<p>​    <code>GitHub</code>地址：<a target="_blank" rel="noopener" href="https://pagehelper.github.io/">https://pagehelper.github.io/</a></p>
<h1 id="2-引入分页插件"><a href="#2-引入分页插件" class="headerlink" title="2    引入分页插件"></a>2    引入分页插件</h1><p>​    引入分页插件有下面2种方式，推荐使用Maven方式。</p>
<h2 id="2-1-引入Jar包"><a href="#2-1-引入Jar包" class="headerlink" title="2.1    引入Jar包"></a>2.1    引入Jar包</h2><ol>
<li>从中央仓库或阿里云仓库下载最新版本的jar包；</li>
<li>由于使用了SQL解析工具，还需要下载<code>jsqlparser.jar</code>。</li>
</ol>
<h2 id="1-2-使用Maven"><a href="#1-2-使用Maven" class="headerlink" title="1.2    使用Maven"></a>1.2    使用Maven</h2><ul>
<li><p>在<code>pom.xml</code>中添加如下依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-配置拦截器插件"><a href="#3-配置拦截器插件" class="headerlink" title="3    配置拦截器插件"></a>3    配置拦截器插件</h1><ul>
<li>特别注意，新版拦截器是 <code>com.github.pagehelper.PageInterceptor</code>。 <code>com.github.pagehelper.PageHelper</code> 现在是一个特殊的 <code>dialect</code> 实现类，是分页插件的默认实现类，提供了和以前相同的用法。</li>
</ul>
<h2 id="3-1-在MyBatis的XML文件中配置拦截器插件"><a href="#3-1-在MyBatis的XML文件中配置拦截器插件" class="headerlink" title="3.1    在MyBatis的XML文件中配置拦截器插件"></a>3.1    在MyBatis的XML文件中配置拦截器插件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:</span></span><br><span class="line"><span class="comment">    properties?, settings?,</span></span><br><span class="line"><span class="comment">    typeAliases?, typeHandlers?,</span></span><br><span class="line"><span class="comment">    objectFactory?,objectWrapperFactory?,</span></span><br><span class="line"><span class="comment">    plugins?,</span></span><br><span class="line"><span class="comment">    environments?, databaseIdProvider?, mappers?</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;param1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-在Spring配置文件中配置拦截器插件"><a href="#3-2-在Spring配置文件中配置拦截器插件" class="headerlink" title="3.2    在Spring配置文件中配置拦截器插件"></a>3.2    在Spring配置文件中配置拦截器插件</h2><ul>
<li><p>使用Spring的属性配置方式，可以使用<code>plugins</code>属性像下面这样配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注意其他配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--使用下面的方式配置参数，一行配置一个 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            params=value1</span><br><span class="line">          <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-分页插件参数介绍"><a href="#4-分页插件参数介绍" class="headerlink" title="4    分页插件参数介绍"></a>4    分页插件参数介绍</h1><p>分页插件提供了多个可选参数，这些参数使用时，按照上面两种配置方式种的示例配置接口。</p>
<p>分页插件的可选配置参数如下：</p>
<ul>
<li><p><code>dialect</code>：默认情况下会使用PageHelper定义的方式进行分页，如果想要实现自己的分页逻辑，可以实现<code>Dialect（com.github.pagehelper.Dialect）</code>接口，然后配置该属性为实现类的全限定类名。</p>
<hr>
</li>
</ul>
<p><strong>下面几个参数都是针对默认dialect情况下的参数。使用自定义dialect实现时，下面的参数没有任何作用。</strong></p>
<ol>
<li><p><code>helperDialect</code></p>
<p>​    分页插件会自动检测当前数据库链接，自动选择合适的分页方式。你可以配置<code>helpDialect</code>属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby</span><br></pre></td></tr></table></figure>

<p>​    你也可以实现<code>AbstractHelperDialect</code>，然后配置该属性为实现类的全限定类名即可使用自定义的实现方法。</p>
</li>
<li><p><code>offsetAsPageNum</code></p>
<p>​    默认值为<code>false</code></p>
</li>
<li><p>``</p>
</li>
<li><p>``</p>
</li>
<li><p>``</p>
</li>
<li><p>``</p>
</li>
<li><p>``</p>
</li>
<li><p>``</p>
</li>
<li><p>``</p>
</li>
<li><p>``</p>
</li>
</ol>
<h1 id="5-MyBatis集成PageHelper"><a href="#5-MyBatis集成PageHelper" class="headerlink" title="5    MyBatis集成PageHelper"></a>5    MyBatis集成PageHelper</h1><h1 id="6-Spring集成PageHelper"><a href="#6-Spring集成PageHelper" class="headerlink" title="6    Spring集成PageHelper"></a>6    Spring集成PageHelper</h1><h1 id="7-SpringBoot集成PageHelper"><a href="#7-SpringBoot集成PageHelper" class="headerlink" title="7    SpringBoot集成PageHelper"></a>7    SpringBoot集成PageHelper</h1><h2 id="7-1-导入依赖"><a href="#7-1-导入依赖" class="headerlink" title="7.1    导入依赖"></a>7.1    导入依赖</h2><p>在pom文件中导入两个jar：</p>
<ol>
<li>SpringBoot对MyBatis的支持jar；</li>
<li>SpringBoot对pagehelper的支持jar；</li>
</ol>
<h2 id="7-2-配置PageHelper方言"><a href="#7-2-配置PageHelper方言" class="headerlink" title="7.2    配置PageHelper方言"></a>7.2    配置PageHelper方言</h2><p>在项目配置文件<code>application.yml</code>文件中配置<code>pagehelper</code>方言为<code>mysql</code>（如果你使用的数据库是<code>MYSQL</code>）</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pagehelper:</span></span><br><span class="line">  <span class="attr">helperDialect:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure>



<h2 id="7-3-编写业务逻辑代码"><a href="#7-3-编写业务逻辑代码" class="headerlink" title="7.3    编写业务逻辑代码"></a>7.3    编写业务逻辑代码</h2><p>使用<code>pagehelper</code>非常简单，只需要在你想要分页的查询逻辑<strong>前</strong>加一行代码即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize)</span><br><span class="line">    pageNum：页数（第几页）</span><br><span class="line">	pageSize：每页的数据行数</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源代码：</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始分页</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageNum  页码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 每页显示数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Page&lt;E&gt; <span class="title function_">startPage</span><span class="params">(<span class="type">int</span> pageNum, <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startPage(pageNum, pageSize, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-4-PageInfo类"><a href="#7-4-PageInfo类" class="headerlink" title="7.4    PageInfo类"></a>7.4    PageInfo类</h2><p><code>PageInfo</code>是<code>PageHelper</code>已经封装好的一个类，里面有一些我们做分页表时常用的属性。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> pageNum;	<span class="comment">//当前页为第几页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> pageSize;	<span class="comment">//每页的数据行数</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> startRow;	<span class="comment">//当前页面第一个元素在数据库中的行号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> endRow;		<span class="comment">//当前页面最后一个元素在数据库中的行号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;	<span class="comment">//当前页的数量</span></span><br><span class="line"><span class="comment">//由于startRow和endRow不常用，这里说个具体的用法</span></span><br><span class="line"><span class="comment">//可以在页面中&quot;显示startRow到endRow 共size条数据&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> total;		<span class="comment">//总记录数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> pages;		<span class="comment">//总页数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;T&gt; list;		<span class="comment">//结果集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> prePage;	<span class="comment">//前一页页码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> nextPage;	<span class="comment">//下一页页码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> isFirstPage;	<span class="comment">//是否为第一页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> isLastPage;		<span class="comment">//是否为最后一页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> hasPreviousPage;	<span class="comment">//是否有前一页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> hasNextPage;	<span class="comment">//是否有下一页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> navigatePages;		<span class="comment">//导航页码数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] navigatepageNums;		<span class="comment">//所有导航页号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> navigateFirstPage;		<span class="comment">//导航条上的第一页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> navigateLastPage;		<span class="comment">//导航条上的最后一页</span></span><br></pre></td></tr></table></figure>



<h2 id="7-7-7"><a href="#7-7-7" class="headerlink" title="7.7.7"></a>7.7.7</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
