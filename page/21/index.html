<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/21/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/21/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/21/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">232</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/11/JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/11/JavaScript/" class="post-title-link" itemprop="url">JavaScript</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-11 11:37:09" itemprop="dateCreated datePublished" datetime="2020-11-11T11:37:09+08:00">2020-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-03-15 23:06:08" itemprop="dateModified" datetime="2021-03-15T23:06:08+08:00">2021-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/2020/11/11/JavaScript/JavaScript.png"></p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><blockquote>
<p>JavaScript是一门客户端脚本语言。</p>
<ul>
<li><strong>运行在客户端浏览器</strong>中的。每一个浏览器都有JavaScript的解析引擎</li>
<li>脚本语言：不需要编译，直接就可以被浏览器解析执行了</li>
</ul>
</blockquote>
<p>功能：</p>
<blockquote>
<p>是对HTML的增强，可以用来控制html元素，让页面有一些动态的效果，增强用户的体验。</p>
</blockquote>
<p>ECMAScript：客户端脚本语言的标准</p>
<blockquote>
<ul>
<li>JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)</li>
</ul>
</blockquote>
<p>JS特点：</p>
<blockquote>
<ol>
<li><strong>交互性</strong>：它可以完成信息的动态交互。</li>
<li><strong>安全性</strong>：不允许直接访问硬盘。</li>
<li><strong>跨平台性</strong>：只要是可以解释JS的浏览器都可以执行，与平台无关。</li>
</ol>
</blockquote>
<hr>
<h1 id="Js-与-HTML-结合的方式"><a href="#Js-与-HTML-结合的方式" class="headerlink" title="Js 与 HTML 结合的方式"></a>Js 与 HTML 结合的方式</h1><h2 id="内部Js"><a href="#内部Js" class="headerlink" title="内部Js"></a>内部Js</h2><blockquote>
<p>在<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>标签中，使用<code>&lt;script&gt;</code>标签来包裹JavaScript代码。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;hello js&quot;</span>)	   </span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="外部Js"><a href="#外部Js" class="headerlink" title="外部Js"></a>外部Js</h2><blockquote>
<p>在<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>标签中，使用<code>&lt;script src=&quot;&quot;&gt;</code>引入外部的<code>.js</code>文件。</p>
</blockquote>
<ol>
<li><p>定义<code>demo.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;hello js 外部js&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>引入外部的<code>demo.js</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>Tip：</p>
<ul>
<li><code>&lt;script&gt;</code>标签可以用来定义JS代码，也可以用来引入JS文件。但是，两个功能只能二选一使用，不能同时使用两个功能。</li>
<li><strong><code>&lt;script&gt;</code>可以定义在html页面的任何地方，但是定义的位置会影响执行顺序。</strong></li>
<li><code>&lt;script&gt;</code>标签可以定义多个。</li>
</ul>
</blockquote>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><blockquote>
<ul>
<li>单行注释：// </li>
<li>多行注释：/**/</li>
</ul>
</blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><img src="/2020/11/11/JavaScript/JS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">基本数据类型</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>number</code></td>
<td align="center">整数/小数/NaN(not a number 一个不是数字的数字类型)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>string</code></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>boolean</code></td>
<td align="center">布尔类型</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>undefined</code></td>
<td align="center">所有JS变量未赋初始值的时候，默认值都是undefined</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>null</code></td>
<td align="center">空值</td>
</tr>
</tbody></table>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><blockquote>
<p>Java语言是强类型语言，而JavaScript是弱类型语言。</p>
<ul>
<li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li>
<li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</li>
</ul>
</blockquote>
<h2 id="Js中变量的定义格式"><a href="#Js中变量的定义格式" class="headerlink" title="Js中变量的定义格式"></a>Js中变量的定义格式</h2><blockquote>
<p>变量的定义使用<code>var</code>关键字或<code>let</code>关键字 。</p>
<ul>
<li><code>var</code>：定义的变量是局部变量</li>
<li><code>let</code>：定义的变量是全局变量(不建议)</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> 变量名;	</span><br><span class="line"><span class="number">2.</span> <span class="keyword">var</span> 变量名 = 值;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">let</span> 变量名;</span><br><span class="line"><span class="number">4.</span> <span class="keyword">let</span> 变量名 = 值;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>typeof</code>运算符：获取变量的类型。</p>
<ul>
<li><code>null</code> 类型运算后得到的是类型是 <code>object</code></li>
<li>Js中的语句以<code>;</code>结尾，如果一行只有一条语句则<code> ;</code>可以省略 (不建议)</li>
</ul>
</blockquote>
<hr>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h2><blockquote>
<p>只有一个参数的运算符</p>
</blockquote>
<p><strong>分类</strong></p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>++/--</code></td>
<td align="center">自增/自减</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>+/-</code></td>
<td align="center">正号/负号（不是加和减）</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul>
<li>参考Java的赋值运算符</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><ul>
<li>参考Java的算术运算符</li>
</ul>
<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><blockquote>
<p>在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。</p>
</blockquote>
<p>其他类型 <code>--&gt;&gt;</code> number：</p>
<ul>
<li><p>String转number：</p>
<blockquote>
<p>如果字面值是数字，直接按照字面值转换。</p>
<p>如果字面值不是数字，则转为NaN（不是数字的数字）</p>
</blockquote>
</li>
<li><p>Boolean类型转Number</p>
<blockquote>
<p>true转为1，false转为0</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><blockquote>
<p><code>&gt; &lt; &gt;= &lt;= == ===(全等于)</code></p>
</blockquote>
<p><strong>比较方式</strong>：</p>
<blockquote>
<ol>
<li>若待比较的两个变量数据类型相同，则可以直接比较。<ul>
<li>数值类型直接比较大小；</li>
<li>字符串类型则会按照字典顺序比较。按位逐一比较，直到得出大小为止。</li>
</ul>
</li>
<li><strong>若待比较的两个变量数据类型不同，则需要先进行类型转换，再比较</strong>。</li>
</ol>
</blockquote>
<p><strong>全等于</strong>：</p>
<blockquote>
<p><strong><code>===</code> 全等于</strong>：在比较之前，先判断类型，如果类型不一样，则直接返回false</p>
</blockquote>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul>
<li><code>&amp;&amp;</code>    与</li>
<li><code>||</code>    或</li>
<li><code>!</code>    非</li>
</ul>
<blockquote>
<p>Tip：<strong>在JS中，所有的变量，都可以作为一个boolean类型变量使用。</strong></p>
<p>其他类型转boolean：</p>
<ul>
<li><code>number</code>：<code>0</code>或<code>NaN</code>为假，其他为真<ul>
<li><code>string</code>：除了<code>空字符串(&quot;&quot;)</code>，其他都是true</li>
</ul>
</li>
<li><code>null</code>和<code>undefined</code>：都是false</li>
</ul>
<ol start="4">
<li><code>对象</code>：所有对象都为true</li>
</ol>
</blockquote>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><ul>
<li>参考Java的三元运算符</li>
</ul>
<hr>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="默认顺序执行"><a href="#默认顺序执行" class="headerlink" title="默认顺序执行"></a>默认顺序执行</h2><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><ol>
<li><code>if...else...</code></li>
<li><code>switch</code><ul>
<li>在Java中，<code>switch()</code>方法中参数可以接受的数据类型：<code>byte int short char,枚举(1.5) ,String(1.7)</code></li>
<li>在JS中，<code>switch()</code>方法中的参数可以是<strong>任意的基本数据类型</strong></li>
</ul>
</li>
</ol>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ol>
<li><code>while</code></li>
<li><code>do...while</code></li>
<li><code>for</code></li>
</ol>
<hr>
<h1 id="数组（对象）：Array"><a href="#数组（对象）：Array" class="headerlink" title="数组（对象）：Array"></a>数组（对象）：Array</h1><h2 id="定义（3种方式）"><a href="#定义（3种方式）" class="headerlink" title="定义（3种方式）"></a>定义（3种方式）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="title class_">Array</span>(数组长度);</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="title class_">Array</span>(元素列表);</span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [元素列表];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例子*/</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [];	<span class="comment">// 定义空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>, <span class="literal">true</span>];		<span class="comment">// 定义数组的同时赋值元素</span></span><br></pre></td></tr></table></figure>



<h2 id="数组对象中的属性"><a href="#数组对象中的属性" class="headerlink" title="数组对象中的属性"></a>数组对象中的属性</h2><ul>
<li><code>length</code>：数组对象中有一个<code>length</code>属性，该方法返回当前数组中元素的个数。</li>
</ul>
<h2 id="数组对象中的方法"><a href="#数组对象中的方法" class="headerlink" title="数组对象中的方法"></a>数组对象中的方法</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">方法</th>
<th align="center">说明</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>join(参数)</code></td>
<td align="center">将数组中的元素按照指定的分隔符拼接为字符串。</td>
<td align="center">String</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>push()</code></td>
<td align="center">向数组的末尾添加一个或更多元素，并返回新的长度。</td>
<td align="center">number</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="数组对象的特点"><a href="#数组对象的特点" class="headerlink" title="数组对象的特点"></a>数组对象的特点</h2><blockquote>
<ul>
<li>JS中，数组的<strong>元素类型是可变</strong>的。</li>
<li>JS中，数组<strong>长度可变</strong>的。</li>
</ul>
</blockquote>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><blockquote>
<p>格式：与Java相同</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>, <span class="literal">true</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.查找</span></span><br><span class="line"><span class="keyword">var</span> x = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.修改</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.增加</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">&quot;你好&quot;</span>;	<span class="comment">// 或者</span></span><br><span class="line">arr[arr.<span class="property">length</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<hr>
<h1 id="方法（对象）：function"><a href="#方法（对象）：function" class="headerlink" title="方法（对象）：function"></a>方法（对象）：function</h1><blockquote>
<p>在JS中，函数/方法是一个对象。</p>
</blockquote>
<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><ul>
<li>方式1：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 方法名(参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式2：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 方法名 = <span class="keyword">function</span>(<span class="params">形参列表</span>)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><ul>
<li>直接通过： <code>函数名(实参列表)</code>  调用。</li>
</ul>
<h2 id="方法的属性"><a href="#方法的属性" class="headerlink" title="方法的属性"></a>方法的属性</h2><ul>
<li><code>length</code>：方法是一个对象，该对象有一个<code>length</code>属性，表示当前方法中形参列表中参数的个数。</li>
</ul>
<h2 id="Tip："><a href="#Tip：" class="headerlink" title="Tip："></a>Tip：</h2><blockquote>
<ul>
<li>方法是一个对象。</li>
<li>在JS中，形参的数据类型不用写，返回值类型也不用写。[弱类型语言]</li>
<li>在Java中允许方法重载，但是在JS中方法的重载会直接覆盖上一次的定义。</li>
<li>在JS中，方法的调用只与方法的名称有关，与参数列表无关。</li>
<li>在方法声明中有一个隐藏的内置对象（数组）<code>arguments</code>，封装了所有的实际参数。</li>
</ul>
</blockquote>
<hr>
<h1 id="日期（对象）：Date"><a href="#日期（对象）：Date" class="headerlink" title="日期（对象）：Date"></a>日期（对象）：Date</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure>

<h2 id="对象中的方法"><a href="#对象中的方法" class="headerlink" title="对象中的方法"></a>对象中的方法</h2><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>toLocaleString()</code></td>
<td align="center">返回当前date对象对应时间的本地字符串格式</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>getTime()</code></td>
<td align="center">返回当前date对象对应时间的毫秒值（始于1970年1月1日0时0分0秒）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="数学对象：Math"><a href="#数学对象：Math" class="headerlink" title="数学对象：Math"></a>数学对象：Math</h1><blockquote>
<p>Math对象不用创建，可以直接使用，类似于Java中的静态类。</p>
</blockquote>
<h2 id="对象中的属性"><a href="#对象中的属性" class="headerlink" title="对象中的属性"></a>对象中的属性</h2><ul>
<li><code>PI</code>：就是<code>π</code>值。</li>
</ul>
<h2 id="对象中的方法-1"><a href="#对象中的方法-1" class="headerlink" title="对象中的方法"></a>对象中的方法</h2><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>random()</code></td>
<td align="center">返回 [0 ，1） 之间的随机数。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>ceil(a)</code></td>
<td align="center">对<code>a</code>向上取整</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>floor(a)</code></td>
<td align="center">对<code>a</code>向下取整</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>round(a)</code></td>
<td align="center">四舍五入</td>
</tr>
</tbody></table>
<h1 id="正则表达式对象：RegExp"><a href="#正则表达式对象：RegExp" class="headerlink" title="正则表达式对象：RegExp"></a>正则表达式对象：RegExp</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><a href>传送门</a></p>
<blockquote>
<p><strong>正则表达式</strong>：定义字符串的组成规则</p>
</blockquote>
<ol>
<li><p>单个字符:[]</p>
<blockquote>
<p>如： [a] [ab] [a-zA-Z0-9_]</p>
<pre><code>* 特殊符号代表特殊含义的单个字符:
 \d:单个数字字符 [0-9]
 \w:单个单词字符[a-zA-Z0-9_]
</code></pre>
</blockquote>
</li>
<li><p>量词符号：</p>
<blockquote>
<ol>
<li><p>?：表示出现0次或1次<br> *：表示出现0次或多次<br> +：出现1次或多次<br> {m,n}:表示 m&lt;= 数量 &lt;= n</p>
<p>​    m如果缺省： {,n}:最多n次</p>
<p>​    n如果缺省：{m,} 最少m次</p>
</li>
</ol>
</blockquote>
</li>
<li><p>开始结束符号</p>
<blockquote>
<ul>
<li>^:开始</li>
<li>$:结束</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h2><h3 id="创建（2种方式）"><a href="#创建（2种方式）" class="headerlink" title="创建（2种方式）"></a>创建（2种方式）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;正则表达式&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>;</span><br></pre></td></tr></table></figure>



<h3 id="对象中的方法-2"><a href="#对象中的方法-2" class="headerlink" title="对象中的方法"></a>对象中的方法</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>test(参数)</code></td>
<td align="center">验证指定的字符串是否符合正则定义的规范</td>
</tr>
</tbody></table>
<h1 id="全局对象：Global"><a href="#全局对象：Global" class="headerlink" title="全局对象：Global"></a>全局对象：Global</h1><blockquote>
<p>全局对象Global中封装的方法不需要对象就可以直接调用。  </p>
<p>调用方式：<code>方法名()</code></p>
</blockquote>
<h2 id="对象中的方法-3"><a href="#对象中的方法-3" class="headerlink" title="对象中的方法"></a>对象中的方法</h2><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>encodeURL(参数)</code></td>
<td align="center">将指定数据按URL编码</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>decodeURL(参数)</code></td>
<td align="center">将指定数据按URL解码</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>encodeURLComponent(参数)</code></td>
<td align="center">url编码,编码的字符更多</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>decodeURLComponent(参数)</code></td>
<td align="center">url解码</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>parseInt(参数)</code></td>
<td align="center">将字符串转为数字</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><code>isNaN(参数)</code></td>
<td align="center">判断一个值是否是NaN</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>eval(参数)</code></td>
<td align="center">将JavaScript字符串作为脚本代码来执行</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>NaN六亲不认，连自己都不能识别，所以NaN参与的<code>==</code>比较全部为false。想要判断某一数据是否为NaN，只能通过<code>isNaN()</code>方法</li>
<li><code>parseInt(参数)</code>方法会逐一判字符串中的每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number。</li>
</ul>
</blockquote>
<h1 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol>
<li>方式1：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个空对象实例</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.绑定属性值</span></span><br><span class="line">变量名.属性 = 值;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义对象中的方法</span></span><br><span class="line">变量名.函数名 = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方式2：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = &#123;</span><br><span class="line">    属性名<span class="number">1</span>:值<span class="number">1</span>,</span><br><span class="line">    ...... ,</span><br><span class="line">    函数名:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 变量名.属性;</span><br><span class="line"><span class="number">2.</span> 变量名.方法名();</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><blockquote>
<p><strong>BOM</strong>：<code>Browser Object Model</code>，浏览器对象模型，就是将浏览器的各个组成部分封装成对象</p>
</blockquote>
<p><strong>BOM的组成部分</strong></p>
<ul>
<li><code>Window</code>：窗口对象</li>
<li><code>Navigator</code>：浏览器对象</li>
<li><code>Screen</code>：显示器屏幕对象</li>
<li><code>History</code>：历史记录对象</li>
<li><code>Location</code>：地址栏对象</li>
</ul>
<h2 id="Window：窗口对象"><a href="#Window：窗口对象" class="headerlink" title="Window：窗口对象"></a>Window：窗口对象</h2><h3 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h3><blockquote>
<ul>
<li>Window对象可以不需要创建直接使用。格式：<code>window.方法名()</code>或<code>window.属性</code></li>
<li>window引用可以省略。格式：<code>方法名()</code>或<code>属性</code></li>
</ul>
</blockquote>
<h3 id="2、对象中的方法"><a href="#2、对象中的方法" class="headerlink" title="2、对象中的方法"></a>2、对象中的方法</h3><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">方法</th>
<th align="center">说明</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">与弹出框有关的方法</td>
<td align="center"><code>alert()</code></td>
<td align="center">弹出一个带有一段消息和一个确认按钮的警告框。</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>confirm()</code></td>
<td align="center">弹出一个带有一段消息以及<strong>确认按钮和取消按钮</strong>的对话框。</td>
<td align="center">如果用户点击确认按钮，返回true，反之则返回false</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>prompt()</code></td>
<td align="center">弹出一个提示用户输入的对话框</td>
<td align="center">返回值是用户输入的值</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">与打开关闭有关的方法</td>
<td align="center"><code>close()</code></td>
<td align="center">关闭当前浏览器窗口</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>open()</code></td>
<td align="center">打开一个新的浏览器窗口</td>
<td align="center">返回值是新的Window对象</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">与定时器有关的方法</td>
<td align="center"><code>setTimeout(x, y)</code></td>
<td align="center">在指定的毫秒数后调用函数或计算表达式。x是待调用的函数，y是时间</td>
<td align="center">返回值是一个唯一标识，用于取消定时器</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>clearTimeout()</code></td>
<td align="center">取消由<code>setTimeout()</code>方法设置的定时器</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>setInterval()</code></td>
<td align="center">按照指定的周期（以毫秒计）来调用函数或计算表达式。</td>
<td align="center">返回值是一个唯一标识，用于取消定时器</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>clearInterval()</code></td>
<td align="center">取消由<code>setInterval()</code>设置的 定时器。</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="3、对象的属性"><a href="#3、对象的属性" class="headerlink" title="3、对象的属性"></a>3、对象的属性</h3><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><code>history</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>location</code></td>
</tr>
<tr>
<td align="center">1、获取其它BOM对象</td>
<td align="center"><code>Navigator</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>Screen</code></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2、获取DOM对象</td>
<td align="center"><code>document</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="Location：地址栏对象"><a href="#Location：地址栏对象" class="headerlink" title="Location：地址栏对象"></a>Location：地址栏对象</h2><ol>
<li><p>创建</p>
<blockquote>
<ul>
<li><code>window.location</code></li>
<li><code>location</code></li>
</ul>
</blockquote>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>reload()</code></td>
<td align="center">重新加载当前文档。刷新</td>
</tr>
</tbody></table>
</li>
<li><p>属性</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>href</code></td>
<td align="center">设置或返回完整的URL。该属性在<code>=</code>左边时是设置URL，在<code>=</code>右边时是返回URL</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h2 id="History：历史记录对象"><a href="#History：历史记录对象" class="headerlink" title="History：历史记录对象"></a>History：历史记录对象</h2><ol>
<li><p>创建</p>
<blockquote>
<ul>
<li><code>window.history</code></li>
<li><code>history</code></li>
</ul>
</blockquote>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">方法</th>
<th align="center">说明</th>
<th align="center">参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>back()</code></td>
<td align="center">加载history列表中的上一个URL</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>forward()</code></td>
<td align="center">加载history列表中的下一个URL</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>go(参数)</code></td>
<td align="center">加载history列表中的某个具体页面</td>
<td align="center">正数：前进几个历史记录<br>负数：后退几个历史记录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>属性</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>length</code></td>
<td align="center">返回当前窗口历史列表中的 URL 数量</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><blockquote>
<p><strong>DOM</strong>：Document Object Model，文档对象模型</p>
<p>将标记语言文档的各个组成部分，封装成对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</p>
<p>就是把文档中的<strong>标签</strong>、<strong>属性</strong>、<strong>文本</strong>等转化成对象来管理。</p>
</blockquote>
<p>W3C DOM 标准被分为 3 个不同的部分：</p>
<blockquote>
<ol>
<li><strong>核心DOM</strong>：面向所有结构化文档的标准模型。包括：<ul>
<li><code>Document</code>：文档对象</li>
<li><code>Element</code>：元素对象</li>
<li><code>Attribute</code>：属性对象</li>
<li><code>Text</code>：文本对象</li>
<li><code>Comment</code>：注释对象</li>
<li><code>Node</code>：节点对象，其他5个的父对象</li>
</ul>
</li>
<li><strong>XML DOM</strong>：针对 XML 文档的标准模型</li>
<li><strong>HTML DOM</strong>：针对 HTML 文档的标准模型</li>
</ol>
</blockquote>
<h2 id="核心DOM模型"><a href="#核心DOM模型" class="headerlink" title="核心DOM模型"></a>核心DOM模型</h2><h3 id="Document：文档对象"><a href="#Document：文档对象" class="headerlink" title="Document：文档对象"></a>Document：文档对象</h3><blockquote>
<ol>
<li>Document对象管理HTML文档中的全部内容。</li>
<li>Document对象是一种树结构的文档，有层级关系。</li>
<li>Document对象可以把所有的标签都<strong>对象化</strong>。</li>
<li>我们可以通过Document对象<strong>访问所有</strong>的标签对象。</li>
</ol>
</blockquote>
<p><img src="/2020/11/11/JavaScript/DOM%E6%96%87%E6%A1%A3%E6%A0%91%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></p>
<ol>
<li><p>创建：可以使用window对象来获取，或直接获取</p>
<blockquote>
<ul>
<li><code>window.document</code></li>
<li><code>document</code></li>
</ul>
</blockquote>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><code>getElementById()</code></td>
<td align="center">根据id属性值获取元素对象。id属性值一般唯一</td>
</tr>
<tr>
<td align="center">获取Element对象</td>
<td align="center"><code>getElementsByTagName()</code></td>
<td align="center">根据元素名称获取元素对象们。返回值是一个数组</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>getElementsByClassName()</code></td>
<td align="center">根据Class属性值获取元素对象们。返回值是一个数组</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>getElementsByName()</code></td>
<td align="center">根据name属性值获取元素对象们。返回值是一个数组</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>createAttribute(name)</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">创建其他DOM对象</td>
<td align="center"><code>createComment()</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>createElement()</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>createTextNode()</code></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Tip</strong>：以上三个查询方法，一定要在页面加载完成之后执行，才能查询到标签对象。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="Element：元素对象"><a href="#Element：元素对象" class="headerlink" title="Element：元素对象"></a>Element：元素对象</h3><ol>
<li><p>创建/获取：通过document来创建/获取</p>
<blockquote>
<ul>
<li><code>document.createElement()</code></li>
<li><code>document.getElementByXxx()</code></li>
</ul>
</blockquote>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>removeAttribute()</code></td>
<td align="center">删除属性</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>setAttribute()</code></td>
<td align="center">设置属性</td>
</tr>
</tbody></table>
</li>
<li><p>属性</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><code>innerHTML</code></td>
<td align="center">使用<code>innerHTML</code>属性获取/修改标签中的内容</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="Node：节点对象"><a href="#Node：节点对象" class="headerlink" title="Node：节点对象"></a>Node：节点对象</h3><blockquote>
<p>其他5个DOM对象的父对象，即：所有的DOM对象都可以被认为是一个节点对象。</p>
<p>所以，其它5个DOM对象都继承了Node对象中公开的方法。</p>
</blockquote>
<ol>
<li><p>方法</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>appendChild()</code></td>
<td align="center">向当前节点的子节点列表的结尾添加新的子节点</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>removeChild()</code></td>
<td align="center">删除（并返回）当前节点的指定子节点</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>replaceChild()</code></td>
<td align="center">用新节点替换一个子节点</td>
</tr>
</tbody></table>
</li>
<li><p>属性</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>parentNode</code></td>
<td align="center">返回当前节点的父节点</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h1 id="JS中的事件"><a href="#JS中的事件" class="headerlink" title="JS中的事件"></a>JS中的事件</h1><blockquote>
<p><strong>事件</strong>：某些组件被监听到执行了某些操作后，触发某些代码的执行。</p>
</blockquote>
<h2 id="事件的注册（绑定）"><a href="#事件的注册（绑定）" class="headerlink" title="事件的注册（绑定）"></a>事件的注册（绑定）</h2><blockquote>
<p><strong>事件的绑定</strong>：其实就是告诉浏览器，触发事件后要执行哪些代码。</p>
</blockquote>
<h3 id="静态注册事件"><a href="#静态注册事件" class="headerlink" title="静态注册事件"></a>静态注册事件</h3><blockquote>
<p>通过HTML标签的事件属性直接绑定事件响应后的代码，这种方式我们叫做静态注册。</p>
</blockquote>
<h3 id="动态注册事件"><a href="#动态注册事件" class="headerlink" title="动态注册事件"></a>动态注册事件</h3><blockquote>
<p>通过JS代码得到标签的DOM对象，再通过**<code>DOM对象.事件名 = function()&#123;&#125;</code>**这种形式赋予事件响应后的代码。叫做动态注册。</p>
</blockquote>
<p><strong>动态注册的基本步骤</strong>：</p>
<ol>
<li>获取标签对象。</li>
<li><code>标签对象.事件名=function()&#123;&#125;</code></li>
</ol>
<h2 id="8-2-常见的事件"><a href="#8-2-常见的事件" class="headerlink" title="8.2    常见的事件"></a>8.2    常见的事件</h2><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">事件</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">加载事件</td>
<td align="center"><code>onload</code></td>
<td align="center">加载完成事件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">点击事件</td>
<td align="center"><code>onclick</code></td>
<td align="center">单击事件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>ondblclick</code></td>
<td align="center">双击事件</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">焦点事件</td>
<td align="center"><code>onblur</code></td>
<td align="center">失去焦点事件。常用于输入框失去焦点后验证其输入内容是否合法</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>onfocus</code></td>
<td align="center">元素获得焦点</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">鼠标事件</td>
<td align="center"><code>onmousedown</code></td>
<td align="center">鼠标按钮被按下</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>onmouseup</code></td>
<td align="center">鼠标按键被松开</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>onmousemove</code></td>
<td align="center">鼠标被移动</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>onmouseover</code></td>
<td align="center">鼠标移到某元素之上</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>onmouseout</code></td>
<td align="center">鼠标从某元素移开</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">键盘事件</td>
<td align="center"><code>onkeydown</code></td>
<td align="center">某个键盘按键被按下</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>onkeyup</code></td>
<td align="center">某个键盘按键被松开</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>onkeypress</code></td>
<td align="center">某个键盘按键被按下并松开</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">表单事件</td>
<td align="center"><code>onsubmit</code></td>
<td align="center">表单提交按钮被点击</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>onreset</code></td>
<td align="center">重置按钮被点击</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">改变</td>
<td align="center"><code>onchange</code></td>
<td align="center">域的内容被改变</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">选择</td>
<td align="center"><code>onselect</code></td>
<td align="center">文本被选中</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/11/HTML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/11/HTML/" class="post-title-link" itemprop="url">HTML</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-11 11:36:34" itemprop="dateCreated datePublished" datetime="2020-11-11T11:36:34+08:00">2020-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-03-12 21:55:43" itemprop="dateModified" datetime="2021-03-12T21:55:43+08:00">2021-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/2020/11/11/HTML/HTML.png"></p>
<h1 id="HTML-概述"><a href="#HTML-概述" class="headerlink" title="HTML 概述"></a>HTML 概述</h1><blockquote>
<ul>
<li><p>HTML 是最基础的网页开发语言</p>
</li>
<li><p>Hyper Text Markup Language：超文本标记语言</p>
<blockquote>
<ul>
<li><p><strong>超文本</strong>：超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本</p>
</li>
<li><p><strong>标记语言</strong>：</p>
<ul>
<li><p>由标签构成的语言。&lt;标签名称&gt; 如 html，xml</p>
</li>
<li><p>标记语言不是编程语言。</p>
<blockquote>
<ul>
<li>没有逻辑性</li>
<li>按顺序从上到下执行</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li><p>html文档后缀名 .html 或者 .htm</p>
</li>
<li><p>标签分为：</p>
</li>
</ol>
<ul>
<li><p><strong>围堵标签</strong>：有开始标签和结束标签。如<code> &lt;html&gt; &lt;/html&gt;</code></p>
</li>
<li><p><strong>自闭合标签</strong>：开始标签和结束标签在一起。如<code> &lt;br/&gt;</code></p>
</li>
</ul>
<ol start="3">
<li>标签之间可以互相嵌套。</li>
<li>在<strong>开始标签中</strong>可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</li>
<li>html的标签不区分大小写，但是建议使用小写。</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><p>标签拥有自己的属性，分为：</p>
<ul>
<li><strong>基本属性</strong>：可以修改简单的样式效果</li>
<li><strong>事件属性</strong>：可以直接设置事件响应后的代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">bgcolor</span>=<span class="string">&quot;red&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;你好&#x27;)&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>属性必须有值，属性值必须加引号</p>
</li>
</ol>
</blockquote>
<hr>
<h1 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h1><h2 id="1、文件标签"><a href="#1、文件标签" class="headerlink" title="1、文件标签"></a>1、文件标签</h2><blockquote>
<p>构成html最基本的标签</p>
</blockquote>
<ul>
<li><p><code>html</code>：html文档的根标签【超级祖宗】</p>
</li>
<li><p><code>head</code>：头标签</p>
<blockquote>
<ul>
<li>用于指定html文档的一些属性。</li>
<li>引入外部的资源</li>
</ul>
</blockquote>
</li>
<li><p><code>title</code>：标题标签</p>
</li>
<li><p><code>body</code>：体标签</p>
</li>
<li><p><code>&lt;!DOCTYPE html&gt;</code>：定义文档类型，html5中定义该文档是html文档</p>
</li>
</ul>
<h2 id="2、文本标签"><a href="#2、文本标签" class="headerlink" title="2、文本标签"></a>2、文本标签</h2><blockquote>
<p>和文本有关的标签</p>
</blockquote>
<ul>
<li><p><code>&lt;!-- 注释 --&gt;</code>：注释</p>
</li>
<li><p><code>&lt;h1&gt;标题&lt;h1&gt;</code>：标题标签</p>
<blockquote>
<p>h1~h6:字体大小逐渐递减</p>
</blockquote>
</li>
<li><p><code>&lt;p&gt;</code>：段落标签</p>
</li>
<li><p><code>&lt;br&gt;</code>：换行标签</p>
</li>
<li><p><code>&lt;hr&gt;</code>：水平线</p>
<blockquote>
<p>属性：</p>
<ul>
<li><p>color：颜色</p>
</li>
<li><p>width：线长</p>
</li>
<li><p>size：线高</p>
</li>
<li><p>align：对齐方式</p>
<blockquote>
<ul>
<li>center：居中</li>
<li>left：左对齐</li>
<li>right：右对齐</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;font&gt;</code>：字体标签</p>
<blockquote>
<p>属性：</p>
<ul>
<li>size：字号</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;b&gt;</code>：字体加粗</p>
</li>
<li><p><code>&lt;i&gt;</code>：字体斜体</p>
</li>
<li><p><code>&lt;center&gt;</code>:文本居中</p>
<blockquote>
<p>属性：</p>
<ul>
<li>color：颜色</li>
<li>size：大小</li>
<li>face：字体</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="常见的属性对应的值"><a href="#常见的属性对应的值" class="headerlink" title="常见的属性对应的值"></a>常见的属性对应的值</h3><ul>
<li><p>color：</p>
<blockquote>
<ol>
<li>用英文单词表示：red,green,blue</li>
<li>RGB(x，y，z)，值的范围：0~255  如  RGB(0,0,255)</li>
<li>#XXYYZZ，值的范围：00~FF之间。如： #FF00FF</li>
</ol>
</blockquote>
</li>
<li><p>width：</p>
<blockquote>
<ol>
<li>数值，如width=’20’ ,数值的单位，默认是 px(像素)</li>
<li>数值%：如width=“20%”，相对于父元素所占的比例</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="3、图片标签"><a href="#3、图片标签" class="headerlink" title="3、图片标签"></a>3、图片标签</h2><ul>
<li><p><code>&lt;img&gt;</code>：展示图片</p>
<blockquote>
<p>属性：</p>
<ul>
<li>键：src，指定图片的位置</li>
<li>值：相对路径/绝对路径</li>
</ul>
</blockquote>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot; &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、列表标签："><a href="#4、列表标签：" class="headerlink" title="4、列表标签："></a>4、列表标签：</h2><ul>
<li>有序列表：<code>&lt;ol&gt;&lt;li&gt;</code></li>
<li>无序列表：<code>&lt;ul&gt;&lt;li&gt;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--有序列表 &lt;ol&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--无序列表 &lt;ul&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="5、链接标签："><a href="#5、链接标签：" class="headerlink" title="5、链接标签："></a>5、链接标签：</h2><ul>
<li><p><code>&lt;a&gt;</code>：超链接</p>
<blockquote>
<p>属性：</p>
<ul>
<li><p>href：指定访问资源的URL</p>
</li>
<li><p>target：指定打开资源的方式</p>
<blockquote>
<ul>
<li>_self：默认值，在当前页面打开</li>
<li>_blank：在空白页面打开</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="6、div"><a href="#6、div" class="headerlink" title="6、div"></a>6、div</h2><ul>
<li><code>&lt;div&gt;</code>：块级标签。<strong>每个div都从新一行开始</strong></li>
</ul>
<h2 id="7、span："><a href="#7、span：" class="headerlink" title="7、span："></a>7、span：</h2><ul>
<li><p><code>&lt;span&gt;</code>：<strong>行内标签</strong>/内联标签。</p>
<blockquote>
<ul>
<li>与上文内容直接连接，不换行。</li>
<li>每个<code>&lt;span&gt;</code>标签内的文本信息在一行中展示。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="8、语义化标签"><a href="#8、语义化标签" class="headerlink" title="8、语义化标签"></a>8、语义化标签</h2><blockquote>
<p>html5中为了提高程序的可读性，提供了一些标签。</p>
</blockquote>
<ul>
<li><code>&lt;header&gt;</code>：页眉</li>
<li><code>&lt;footer&gt;</code>：页脚</li>
</ul>
<h2 id="9、表格标签："><a href="#9、表格标签：" class="headerlink" title="9、表格标签："></a>9、表格标签：</h2><ul>
<li><p><code>&lt;table&gt;</code>：定义表格</p>
<blockquote>
<p>属性：</p>
<ul>
<li>width：宽度</li>
<li>border：边框</li>
<li>cellpadding：定义内容和单元格的距离</li>
<li>cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、</li>
<li>bgcolor：背景色</li>
<li>align：对齐方式</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>&lt;tr&gt;</code>：定义行</p>
<blockquote>
<ul>
<li>bgcolor：背景色</li>
<li>align：对齐方式</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;td&gt;</code>：定义单元格</p>
<blockquote>
<ul>
<li>colspan：合并列</li>
<li>rowspan：合并行</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;th&gt;</code>：定义表头单元格</p>
</li>
<li><p><code>&lt;caption&gt;</code>：表格标题</p>
</li>
<li><p><code>&lt;thead&gt;</code>：表示表格的头部分</p>
</li>
<li><p><code>&lt;tbody&gt;</code>：表示表格的体部分</p>
</li>
<li><p><code>&lt;tfoot&gt;</code>：表示表格的脚部分</p>
</li>
</ul>
<h2 id="10、表单标签"><a href="#10、表单标签" class="headerlink" title="10、表单标签"></a>10、表单标签</h2><blockquote>
<p>表单：用于采集用户输入的数据，和服务器进行交互。</p>
</blockquote>
<ul>
<li><p><code>&lt;form&gt;</code>：用于定义表单。可以定义一个范围，范围代表采集用户数据的范围</p>
<blockquote>
<p>属性：</p>
<ul>
<li>action：指定提交数据的URL</li>
<li>method：指定提交方式。GET/POST/…</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="表单项标签"><a href="#表单项标签" class="headerlink" title="表单项标签"></a>表单项标签</h3><ul>
<li><p>表单项标签：</p>
<ul>
<li><p><code>&lt;input&gt;</code>：</p>
<blockquote>
<p>属性：</p>
<ul>
<li><p>type</p>
<blockquote>
<ul>
<li><p>text：文本输入框，默认值</p>
<blockquote>
<p>placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息    </p>
</blockquote>
</li>
<li><p>password：密码输入框</p>
</li>
<li><p>radio:单选框</p>
<blockquote>
<ol>
<li>要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。</li>
<li>一般会给每一个单选框提供value属性，绑定其被选中后提交的值</li>
<li>checked属性，可以指定默认值</li>
</ol>
</blockquote>
</li>
<li><p>checkbox：复选框</p>
<blockquote>
<ol>
<li>一般会给复选框中的每一个单选框提供value属性，指定其被选中后提交的值</li>
<li>checked属性，可以指定默认值</li>
</ol>
</blockquote>
</li>
<li><p>file：文件选择框</p>
</li>
<li><p>hidden：隐藏域，用于提交一些信息。</p>
</li>
</ul>
<ul>
<li><p>按钮：</p>
<blockquote>
<ul>
<li><p>submit：提交按钮。可以提交表单</p>
</li>
<li><p>button：普通按钮</p>
</li>
<li><p>image：图片提交按钮</p>
<blockquote>
<p>src属性指定图片的路径</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;label&gt;</code>：指定输入项的文字描述信息</p>
<blockquote>
<p>label的for属性一般会和 input 的 id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点。</p>
</blockquote>
</li>
<li><p><code>&lt;select&gt;</code>： 下拉列表</p>
</li>
<li><p>子元素：<code>&lt;option&gt;</code>，指定列表项</p>
<blockquote>
<ul>
<li><code>&lt;select&gt;</code>标签只能定义一个选择列表，并不能定义选择列表内的值。</li>
<li>如果想定义选择列表中的选项，需要使用<code>&lt;option&gt;</code>标签</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;textarea&gt;</code>：文本域</p>
<blockquote>
<ul>
<li>rows：指定文本域的行数。 </li>
<li>cols：指定文本域的列数，每一行有多少个字符。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/07/Zuul/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/07/Zuul/" class="post-title-link" itemprop="url">Zuul</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-07 22:09:31" itemprop="dateCreated datePublished" datetime="2020-11-07T22:09:31+08:00">2020-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-03 16:51:46" itemprop="dateModified" datetime="2021-09-03T16:51:46+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringCould/" itemprop="url" rel="index"><span itemprop="name">SpringCould</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，即<strong>网关（GateWay）</strong>。</p>
<p>顾名思义，网关（GateWay）就是一个网络连接到另一个网络的“关口”。        通常我们讲的网关就是路由器的IP地址。</p>
<blockquote>
<ul>
<li>  <strong>网关(Gateway)</strong> 又称网间连接器、协议转换器。            </li>
<li>  网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。                 </li>
<li>  网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</li>
</ul>
</blockquote>
<h2 id="SpringCould中的网关"><a href="#SpringCould中的网关" class="headerlink" title="SpringCould中的网关"></a>SpringCould中的网关</h2><p>在不使用Zuul网关的情况下，使用Spring Cloud实现的微服务的架构大致如下：</p>
<p><img src="/2020/11/07/Zuul/1525674644660.png" alt="1525674644660"></p>
<blockquote>
<ul>
<li>我们通过Eureka实现了<strong>服务注册中心</strong>以及<strong>服务注册</strong>与<strong>发现</strong>；</li>
<li>通过Ribbon或Feign实现<strong>服务的消费</strong>以及<strong>负载均衡</strong>；</li>
<li>通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。</li>
<li>为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</li>
</ul>
</blockquote>
<p>在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务集群，通过负载均衡公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？</p>
<blockquote>
<p>  <strong>Before：</strong></p>
</blockquote>
<p>先来说说这样架构需要做的一些事儿以及存在的不足：</p>
<ul>
<li>  为了保证对外服务的安全性，我们需要对访问者的权限进行控制，并且对于服务的权限控制机制将会贯穿整个开放服务的业务逻辑，</li>
<li>  无法直接复用既有接口：当我们需要把一个已经存在的内部服务变为对外服务时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，而不能直接复用原有的接口。</li>
</ul>
<blockquote>
<p>  <strong>After：</strong></p>
</blockquote>
<p>面对类似上面的问题，我们要如何解决呢？答案是：服务网关！</p>
<ul>
<li>  为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器——<strong>服务网关</strong>。</li>
<li>  服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了<code>权限控制</code>等功能。</li>
<li>  Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</li>
</ul>
<hr>
<h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>Zuul是Netflix开源的微服务网关，它可以和Eureka、Ribbon、Hystrix等组件配合使用。Zuul的核心是一系列的<strong>过滤器</strong>，这些过滤器可以完成以下功能：</p>
<blockquote>
<p><strong>身份认证与安全</strong>：</p>
<ul>
<li>识别每个资源的验证要求，并拒绝那些与要求不符的请求。</li>
</ul>
<p><strong>审查与监控</strong>：</p>
<ul>
<li>在边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。</li>
</ul>
<p><strong>动态路由</strong>：</p>
<ul>
<li>动态地将请求路由到不同的后端集群。</li>
</ul>
<p><strong>压力测试</strong>：</p>
<ul>
<li>逐渐增加指向集群的流量，以了解性能。</li>
</ul>
<p><strong>负载分配</strong>：</p>
<ul>
<li>为每一种负载类型分配对应的容量，并弃用超出限定值的请求。</li>
</ul>
<p><strong>静态响应处理</strong>：</p>
<ul>
<li>在边缘位置直接建立部分响应，从而避免其转发到内部集群。</li>
</ul>
<p><strong>多区域弹性</strong>：</p>
<ul>
<li>跨越AWS Region进行请求路由，旨在实现ELB（Elastic Load Balancing）使用的多样化，以及让系统的边缘更贴近系统的使用者。</li>
</ul>
</blockquote>
<h2 id="SpringCould中的Zuul"><a href="#SpringCould中的Zuul" class="headerlink" title="SpringCould中的Zuul"></a>SpringCould中的Zuul</h2><p>SpringCould对Zuul进行了整合与增强。目前，Zuul使用的默认HTTP客户端是<code>ApacheHTTPClient</code>，也可以使用<code>RestClient</code>或者<code>okhttp3.OkHttpClient</code>。可以通过设置文件修改HTTP客户端。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon.restclient.enabled</span>=<span class="string">true;</span></span><br><span class="line"><span class="attr">ribbon.okhttp.enabled</span>=<span class="string">true;</span></span><br></pre></td></tr></table></figure>





<h2 id="Zuul加入后的架构"><a href="#Zuul加入后的架构" class="headerlink" title="Zuul加入后的架构"></a>Zuul加入后的架构</h2><p><img src="/2020/11/07/Zuul/1525675648881.png" alt="1525675648881"></p>
<ul>
<li><strong>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关</strong>，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</li>
</ul>
<hr>
<h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><ul>
<li><p>映射规则</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 当前服务的端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">api-gateway</span> <span class="comment"># 当前服务实例名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  	<span class="attr">user-service:</span>	<span class="comment"># 这里是自定义的路由ID</span></span><br><span class="line">  	<span class="attr">path:</span> <span class="string">/user-service/**</span> 	<span class="comment"># 定义访问路径</span></span><br><span class="line">  	<span class="attr">url:</span> <span class="string">http://127.0.0.1:8081</span>	<span class="comment"># 访问路径映射到的实际url地址</span></span><br></pre></td></tr></table></figure>

<p>我们将符合<code>path</code>规则的一切请求，都代理到<code>url</code>参数指定的地址。</p>
<p>本例中，我们将<code>/user-service/**</code>开头的请求，代理到<code>http://127.0.0.1:8081</code>。</p>
<p>此时：<code>http://localhost:10010/user-service/user/1</code> 等价于 <code>http://127.0.0.1:8081/user/1</code></p>
</li>
</ul>
<h3 id="5-1-2-面向服务的路由"><a href="#5-1-2-面向服务的路由" class="headerlink" title="5.1.2    面向服务的路由"></a>5.1.2    面向服务的路由</h3><ul>
<li>在刚才的路由规则中，我们把路径对应的服务地址写死了！如果一个服务有多个实例的话，这样做显然是不合理的。</li>
<li>我们应该根据服务的名称，去Eureka注册中心查找服务对应的所有实例列表，然后进行动态路由才对。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加Eureka配置，拉取服务列表</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">	<span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s</span></span><br><span class="line">  	<span class="attr">service-url:</span></span><br><span class="line">	  <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">	<span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment"># 修改路由映射规则，通过服务名称获取路由地址</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  	<span class="attr">user-service:</span>	<span class="comment"># 路由ID，随意写</span></span><br><span class="line">  	  <span class="attr">path:</span>	<span class="string">/user-service/**</span>	<span class="comment"># 映射路径</span></span><br><span class="line">  	  <span class="attr">serviceId:</span> <span class="string">user-service</span>	<span class="comment"># 指定服务名称</span></span><br></pre></td></tr></table></figure>

<h4 id="1、简化的路由配置"><a href="#1、简化的路由配置" class="headerlink" title="1、简化的路由配置"></a>1、简化的路由配置</h4><ol>
<li><p>在上面的配置中，我们的规则是这样的：</p>
<ul>
<li><code>zuul.routes.&lt;routes&gt;.path=/xxx/**</code>：来指定映射路径。<code>&lt;routes&gt;</code>是自定义的路由名。</li>
<li><code>zuul.routes.&lt;routes&gt;.serviceId=/user-service</code>：来指定服务名。</li>
</ul>
</li>
<li><p>而大多数情况下，我们的<code>&lt;routes&gt;</code>路由名往往和服务名会定义成一样的，因此Zuul就提供了一种简化的配置语法：</p>
<ul>
<li><code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  	<span class="attr">user-service:</span> <span class="string">/user-service/**</span>	<span class="comment"># 服务名称&amp;映射路径[省去了对服务名称的配置]	</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2、默认的路由规则"><a href="#2、默认的路由规则" class="headerlink" title="2、默认的路由规则"></a>2、默认的路由规则</h4><ul>
<li>在使用Zuul的过程中，上述的规则已经大大简化了配置。但是当服务较多时，配置仍是比较繁琐的，因此Zuul就指定了默认的路由规则：<ul>
<li>默认情况下，一切服务的映射路径就是服务名本身。<ul>
<li>例如服务名为：<code>user-service</code>，则默认的映射路径就是：<code>/user-service/**</code></li>
</ul>
</li>
</ul>
</li>
<li>也就是说，上面的映射规则我们完全不配置也是OK的。</li>
</ul>
<h4 id="4、路由前缀"><a href="#4、路由前缀" class="headerlink" title="4、路由前缀"></a>4、路由前缀</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/api</span>	<span class="comment"># 添加路由前缀</span></span><br><span class="line">  <span class="attr">routes:</span> </span><br><span class="line">  	<span class="attr">user-service:</span>	<span class="comment"># 路由ID</span></span><br><span class="line">  	  <span class="attr">path:</span> <span class="string">/user-service/**</span></span><br><span class="line">  	  <span class="attr">serviceId:</span> <span class="string">user-service</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以<code>/api</code>开头</li>
</ul>
<h2 id="5-2-过滤器"><a href="#5-2-过滤器" class="headerlink" title="5.2    过滤器"></a>5.2    过滤器</h2><ul>
<li>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个工作往往是通过Zuul提供的过滤器来实现的。</li>
</ul>
<h2 id="5-3-负载均衡-amp-熔断"><a href="#5-3-负载均衡-amp-熔断" class="headerlink" title="5.3    负载均衡  &amp;  熔断"></a>5.3    负载均衡  &amp;  熔断</h2><ul>
<li>Zuul中默认已经集成了Ribbon负载均衡和Hystrix熔断机制。但所有的超时策略走的都是默认值，比如熔断超时时间只有1s，很容易就触发了，因此建议手动配置。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">retryable:</span> <span class="literal">true</span>	<span class="comment"># 开启重试机制</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># 连接超时时间(ms)</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">2000</span> <span class="comment"># 通信超时时间(ms)</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作重试</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">2</span> <span class="comment"># 同一服务不同实例的重试次数</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 同一实例的重试次数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">	<span class="attr">default:</span></span><br><span class="line">	  <span class="attr">execution:</span></span><br><span class="line">		<span class="attr">isolation:</span></span><br><span class="line">		  <span class="attr">thread:</span></span><br><span class="line">			<span class="attr">timeoutInMillisecond:</span> <span class="number">6000</span> <span class="comment"># 熔断超时时长：6000ms</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/07/Eureka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/07/Eureka/" class="post-title-link" itemprop="url">Eureka</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-07 21:52:34" itemprop="dateCreated datePublished" datetime="2020-11-07T21:52:34+08:00">2020-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-03 12:39:25" itemprop="dateModified" datetime="2021-09-03T12:39:25+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringCould/" itemprop="url" rel="index"><span itemprop="name">SpringCould</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><blockquote>
<ul>
<li>  Eureka只是注册中心的一种；</li>
<li>  目前常用的还有 Nacos</li>
</ul>
</blockquote>
<h2 id="为什么要使用注册中心（Eureka能做什么）？"><a href="#为什么要使用注册中心（Eureka能做什么）？" class="headerlink" title="为什么要使用注册中心（Eureka能做什么）？"></a>为什么要使用注册中心（Eureka能做什么）？</h2><blockquote>
<p>  <strong>Before</strong></p>
</blockquote>
<ul>
<li>在微服务架构中，<code>服务提供者</code> 对外提供服务，需要对外暴露自己的地址。</li>
<li><code>服务调用者</code>需要记录<code>服务提供者</code>的地址来进行数据交互，将来地址出现变更，还需要及时更新。</li>
<li>这在服务数量较少的时候并不觉得有什么，如果一个项目中包含几十上百个微服务，此时如果还人为管理地址，将会非常麻烦。</li>
</ul>
<blockquote>
<p>  <strong>After</strong></p>
</blockquote>
<ul>
<li><code>Eureka</code>负责管理、记录<code>服务提供者</code>的信息。</li>
<li><code>服务调用者</code>无需自己寻找服务，而是把自己的需求告诉<code>Eureka</code>，然后<code>Eureka</code>会把符合需求的服务的 IP 地址告诉<code>服务调用者</code>。</li>
<li><code>服务提供者</code>与<code>Eureka</code>之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。</li>
<li>这就实现了服务的自动注册、发现、状态监控。</li>
</ul>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<ul>
<li>  注册中心就相当于一个总控，一个“中间人”，维护一张服务列表。没有注册中心之前，<code>服务提供者</code> 和 <code>服务调用者</code> 之间是直接联系的，所以 <code>服务调用者</code> 必须知道 <code>服务提供者</code> 的IP地址，当需要调用很多个服务的时候，记录 <code>服务提供者</code> 的 IP 地址本身就是一项非常复杂的工作。而有了总控（注册中心）后，<code>服务调用者</code> 只需要记住一个 IP 地址，即“总控”的 IP 地址，并定期的从“总控”拉取最新的服务列表，然后 <code>服务调用者</code> 就可以从服务列表中选择合适的 IP 地址去调用 <code>服务提供者</code> 进行业务请求了。</li>
</ul>
<hr>
<h2 id="Eureka架构"><a href="#Eureka架构" class="headerlink" title="Eureka架构"></a>Eureka架构</h2><p><img src="/2020/11/07/Eureka/Eureka%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.png"></p>
<blockquote>
<p>Eureka架构中的三个核心角色</p>
<ul>
<li><p><strong>EurekaServer：服务注册中心</strong></p>
<p>服务注册中心可以是单点的，也可以是一个集群，对外暴露自己的地址。</p>
</li>
<li><p><strong>服务提供者</strong></p>
<p>启动后向<code>EurekaServer</code>注册自己的信息（包括地址、提供什么服务等），这些信息保存在<code>EurekaServer</code>的服务列表中。</p>
</li>
<li><p><strong>服务调用者</strong></p>
<p><code>服务调用者</code>从<code>EurekaServer</code>拉取服务列表，从中获得每个<code>服务提供者</code>的信息。就可以知道要去哪里调用<code>服务提供者</code>，并且定义定期从<code>EurekaServer</code>中更新服务列表。</p>
</li>
<li><p><strong>心跳（续约）</strong></p>
<p><code>服务提供者</code>定期通过HTTP方式向<code>EurekaServer</code>刷新自己的状态。</p>
</li>
</ul>
</blockquote>
<h2 id="Eureka组件"><a href="#Eureka组件" class="headerlink" title="Eureka组件"></a>Eureka组件</h2><h3 id="Eureka-Server：服务注册中心"><a href="#Eureka-Server：服务注册中心" class="headerlink" title="Eureka Server：服务注册中心"></a>Eureka Server：服务注册中心</h3><blockquote>
<ul>
<li>Eureka的服务端应用，提供服务注册（针对服务提供者）和发现（针对服务调用者）功能。</li>
<li>EurekaServer可以是一个集群，形成高可用的Eureka中心。</li>
</ul>
</blockquote>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li><strong>服务同步</strong>（EurekaServer）</li>
</ul>
<blockquote>
<p>为了避免单点故障，我们一般会搭建一个Eureka集群，让多个EurekaServer之间也会互相注册为服务，当<code>服务提供者</code>注册到EurekaServer集群中的某个节点时，该节点会把服务器的信息同步给集群中的每个节点，从而实现<strong>数据同步</strong>。此时，无论客户端访问到EurekaServer集群中的哪一个节点，都可以获取到完整的服务列表信息。</p>
</blockquote>
<ul>
<li><strong>失效剔除</strong>（EurekaServer）</li>
</ul>
<blockquote>
<p>有些时候，我们的<code>服务提供者</code>并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。</p>
<p>可以通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒，生产环境不要修改。</p>
<p>这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当减小。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">  	<span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">60</span><span class="string">*1000</span>	<span class="comment"># 失效剔除时间</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>自我保护</strong>（EurekaServer）</li>
</ul>
<p>我们关停一个服务，就会在Eureka面板看到一条警告：这是触发了Eureka的自我保护机制。</p>
<p><img src="/2020/11/07/Eureka/1525618396076.png"></p>
<blockquote>
<p>当一个<code>服务提供者</code>未按时心跳续约时，Eureka会统计该服务实例最近15分钟心跳失败的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败的比例很有可能超标，但此时直接把服务剔除并不妥当，因为服务可能没有宕机。Eureka就把当前实例的注册信心保护起来，不予剔除。生产环境下这很有用，保证了大多数服务依然可用。</p>
<p>但是这给我们的开发带来了麻烦，因此开发阶段我们都会关闭自我保护模式：</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">  	<span class="attr">enable-self-preservation:</span> <span class="literal">false</span>	<span class="comment"># 关闭自我保护模式（缺省为true）</span></span><br></pre></td></tr></table></figure>





<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><blockquote>
<ul>
<li><p>提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供Rest风格服务（接口）即可。</p>
</li>
<li><p>服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。</p>
</li>
</ul>
</blockquote>
<h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><ul>
<li><p><strong>服务注册</strong>（服务提供者）</p>
<blockquote>
<p><code>服务提供者</code>在启动时，会检测配置属性中的：<code>eureka.client.register-with-eureka=true</code>参数是否为true（默认为true）。如果值为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息。EurekaServer会把这些信息保存到一个双层的Map结构中，第一层Map的key就是服务名称，第二层Map的key是服务的实例ID。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>服务续约</strong>（服务提供者）</p>
<blockquote>
<p>在注册完成以后，<code>服务提供者</code>与<code>Eureka</code>之间会维持一个”心跳”（定时向EurekaServer发送Rest请求），告诉EurekaServer：“我还活着”。我们将这个过程称为<strong>服务续约（renew）</strong>。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span> </span><br><span class="line">  	<span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span>	<span class="comment"># 服务失效时间，默认为90s</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span>	<span class="comment"># 服务续约时间，默认为30s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。</p>
<p>但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">10</span> <span class="comment"># 10秒即过期</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 5秒一次心跳</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>实例ID</strong></p>
<p>先来看一下服务状态信息：</p>
<p>在Eureka监控页面，查看服务注册信息：</p>
<p><img src="/2020/11/07/Eureka/1525617060656.png" alt="1525617060656"></p>
<p>在status一列中，显示以下信息：</p>
<ul>
<li>UP(1)：代表现在是启动了1个服务器实例，没有形成集群</li>
<li>DESKTOP-2MVEC12:user-service:8081：是实例的名称（instance-id），<ul>
<li>默认格式是：<code>$&#123;hostname&#125; + $&#123;spring.application.name&#125; + $&#123;server.port&#125;</code></li>
<li>instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。</li>
</ul>
</li>
</ul>
<p>我们可以通过instance-id属性来修改它的构成：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启服务再试试看：</p>
<p><img src="/2020/11/07/Eureka/1525617542081.png" alt="1525617542081"></p>
</li>
</ul>
<h3 id="服务调用者"><a href="#服务调用者" class="headerlink" title="服务调用者"></a>服务调用者</h3><blockquote>
<p><code>服务调用者</code>从<code>服务注册中心</code>获取服务列表，从而得知每个 <code>服务提供者</code> 的信息，知道去哪里调用服务方。</p>
</blockquote>
<h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><ul>
<li><strong>获取服务列表</strong>（服务消费者）</li>
</ul>
<blockquote>
<p>当<code>服务消费者</code>启动时，会检测<code>eureka.client.fetch-registry=true</code>参数的值，如果为true（默认为true），则会从EurekaServer中拉取服务列表缓存在本地，并且每隔 30s 会重新获取最新的数据。我们可以通过下面的参数来进行修改：</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">  	<span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span>		<span class="comment"># 默认值是30s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>生产环境中，我们不需要修改这个值。</p>
<p>但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。</p>
</blockquote>
<hr>
<h2 id="Eureka中常见的配置信息"><a href="#Eureka中常见的配置信息" class="headerlink" title="Eureka中常见的配置信息"></a>Eureka中常见的配置信息</h2><h3 id="Eureka服务端"><a href="#Eureka服务端" class="headerlink" title="Eureka服务端"></a>Eureka服务端</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 当前服务的端口号</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 当前服务的名称（ID），会在Eureka中显示</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">	<span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 是否注册自己的信息到EurekaServer，默认是true</span></span><br><span class="line">	<span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 是否拉取其它服务的信息，默认是true</span></span><br><span class="line">	<span class="attr">service-url:</span> <span class="comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。</span></span><br><span class="line">	  <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>

<h3 id="Eureka客户端"><a href="#Eureka客户端" class="headerlink" title="Eureka客户端"></a>Eureka客户端</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span>	<span class="comment"># 当前服务器的端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">	<span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mydb01</span></span><br><span class="line">	<span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">	<span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">	<span class="attr">hikari:</span></span><br><span class="line">	  <span class="attr">maximum-pool-size:</span> <span class="number">20</span>		<span class="comment"># 最大连接池数量</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 应用名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.leyou.userservice.pojo</span>	<span class="comment"># mybatis实体类包扫描并起别名[用于封装查询到的数据]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">	<span class="attr">service-url:</span> <span class="comment"># EurekaServer服务器的地址，多个地址以 [，] 隔开</span></span><br><span class="line">	  <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">	<span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 当调用getHostname获取实例的hostname时，返回ip而不是host名称</span></span><br><span class="line">	<span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>   <span class="comment"># 指定自己的ip信息，不指定的话会自己寻找</span></span><br><span class="line">	<span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span>	<span class="comment"># 默认值，服务失效时间</span></span><br><span class="line">	<span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span>	<span class="comment"># 默认值，服务续约间隔时间</span></span><br><span class="line">	<span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> 	<span class="comment"># 默认值，注册列表拉取时间间隔</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">	<span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 自我保护（缺省为打开）</span></span><br><span class="line">	<span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 失效剔除（缺省为60*1000ms）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不用指定<code>register-with-eureka</code>和<code>fetch-registry</code>，因为默认是true。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/07/Hystrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/07/Hystrix/" class="post-title-link" itemprop="url">Hystrix</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-07 18:35:19" itemprop="dateCreated datePublished" datetime="2020-11-07T18:35:19+08:00">2020-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-03 15:29:32" itemprop="dateModified" datetime="2021-09-03T15:29:32+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringCould/" itemprop="url" rel="index"><span itemprop="name">SpringCould</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">Hystrix官方文档</a></li>
</ul>
<h1 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h1><p>分布式系统环境下，<strong>服务间的依赖</strong>非常常见，一个服务调用通常依赖多个基础服务。</p>
<p>如下图，当库存服务不可用时，商品服务的请求库存服务的线程就会被阻塞，当有大批量请求调用库存服务时，这些所有的请求就都会被阻塞，最终可能导致整个商品服务的资源被耗尽（主要是线程池资源，虽然库存服务不可用，但是每个商品服务的请求还会占用一个线程，并且因为不会获取到响应，也就不会归还线程，这样当线程池资源耗尽时商品服务就会被阻塞），无法继续对外提供服务。并且这种不可用可能沿请求调用链向上传递，这种现象称为<strong>雪崩效应</strong>。</p>
<p><img src="/2020/11/07/Hystrix/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94.png"></p>
<h2 id="雪崩效应的常见场景"><a href="#雪崩效应的常见场景" class="headerlink" title="雪崩效应的常见场景"></a>雪崩效应的常见场景</h2><blockquote>
<ul>
<li>硬件故障</li>
<li>流量激增</li>
<li>缓存穿透</li>
<li>程序BUG</li>
<li>同步等待</li>
</ul>
</blockquote>
<h2 id="雪崩效应的应对策略"><a href="#雪崩效应的应对策略" class="headerlink" title="雪崩效应的应对策略"></a>雪崩效应的应对策略</h2><p>针对造成雪崩效应的不同场景，可以使用不同的应对策略，没有一种通用所有场景的策略。</p>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<ul>
<li>  <strong>如果一个应用不能对（服务间的）依赖故障进行隔离，那该应用本身就处在被拖垮的风险中。</strong>            </li>
<li>  因此，为了构建稳定、可靠的分布式系统，我们的服务应当具有自我保护能力，当依赖的服务不可用时，当前服务启动自我保护功能，从而避免发生雪崩效应。</li>
</ul>
<hr>
<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>Hystrix，中文含义是豪猪。因其背上长满棘刺，从而有了自我保护能力。            SpringCould中的Hystrix是Netflix一款开源的容错框架，同样具有自我保护能力。</p>
<p>Hystrix的设计目标：</p>
<blockquote>
<ul>
<li>对来自依赖的延迟和故障进行防护和控制（这些依赖通常是通过网络访问的）</li>
<li>阻止故障的连锁反应</li>
<li>快速失败并迅速恢复</li>
<li>回退并优雅降级</li>
<li>提供实时的监控与示警</li>
</ul>
</blockquote>
<p>Hystrix遵循的设计原则：</p>
<blockquote>
<ul>
<li>防止任何单独的依赖耗尽资源（主要是线程资源）</li>
<li>过载立即切断并快速失败，防止排队</li>
<li>尽可能提供回退以保护用户免受故障</li>
<li>使用隔离技术来限制一个依赖的影响</li>
<li>通过近实时的指标、监控和示警，确保故障被及时发现</li>
<li>通过动态修改配置属性，确保故障及时恢复</li>
<li>防止整个依赖客户端执行失败，而不仅仅是网络通信</li>
</ul>
</blockquote>
<p>Hystrix如何实现这些设计目标？</p>
<blockquote>
<ul>
<li>使用命令模式将所有对外部服务（或依赖关系）的调用包装在<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象中，并将该对象放在单独的线程中执行；[没看懂…]</li>
<li>每个依赖关系都维护着一个线程池，线程池被耗尽则拒绝请求（而不是让请求排队）</li>
<li>记录请求成功、失败、超时和线程拒绝</li>
<li>服务错误百分比超过了阈值，熔断器开关自动打开，一段时间内停止对该服务的所有请求</li>
<li>请求失败、被拒绝、超时或熔断时执行降级逻辑</li>
<li>近实时的监控指标和配置的修改</li>
</ul>
</blockquote>
<h1 id="Hystrix处理流程"><a href="#Hystrix处理流程" class="headerlink" title="Hystrix处理流程"></a>Hystrix处理流程</h1><p><img src="/2020/11/07/Hystrix/hystrix%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<p>Hystrix的整个工作流程如下：</p>
<blockquote>
<ol>
<li>构造一个<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象，用于封装请求，并在构造方法中配置请求被执行需要的参数；</li>
<li>执行命令，Hystrix提供了4种执行命令的方法，后面详述；</li>
<li>判断是否要使用缓存响应请求，若启动了缓存且缓存可用，则直接使用缓存响应请求。[Hystrix支持请求缓存，但需要用户自定义启动]</li>
<li>判断熔断器是否打开，如果打开，则跳到第8步；</li>
<li>判断线程池/队列/信号量是否已满，已满则跳到第8步；</li>
<li>执行<code>HystrixCommand.run()</code>或<code>HystrixObservableCommand.construct()</code>，如果执行失败或超时，跳到第8步，否则跳到第9步；</li>
<li>统计熔断器监控指标；</li>
<li>执行FallBack备用逻辑；</li>
<li>返回请求响应。</li>
</ol>
<p>从流程图上可知，第5步线程池/队列/信号量已满时，还会执行第7步逻辑，更新熔断器的统计信息，而第6步无论成功与否，都会执行第7步逻辑，更新熔断器统计信息。</p>
</blockquote>
<h1 id="Hystrix容错"><a href="#Hystrix容错" class="headerlink" title="Hystrix容错"></a>Hystrix容错</h1><p>Hystrix的容错主要是通过添加允许延迟和容错方法，帮助控制这些分布式服务之间的交互。            还通过隔离服务之间的访问点，阻止它们之间的级联故障以及回退选项来实现这一点，从而提高系统的整体弹性。            Hystrix主要提供了以下几种容错方法：</p>
<ul>
<li>资源隔离</li>
<li>熔断</li>
<li>降级</li>
</ul>
<p>下面我们详细了解一下这几种容错机制。</p>
<hr>
<h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><blockquote>
<p>资源隔离主要指对线程的隔离。Hystrix提供了2种线程隔离方式：线程池和信号量</p>
</blockquote>
<h3 id="线程隔离——线程池"><a href="#线程隔离——线程池" class="headerlink" title="线程隔离——线程池"></a>线程隔离——线程池</h3><h3 id="线程隔离——信号量"><a href="#线程隔离——信号量" class="headerlink" title="线程隔离——信号量"></a>线程隔离——信号量</h3><hr>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><h3 id="熔断器简介"><a href="#熔断器简介" class="headerlink" title="熔断器简介"></a>熔断器简介</h3><p>在现实生活中，家用电路中都会安装一个保险盒，当负载过载时，保险盒中的保险丝就会自动熔断，保护下游部件不被烧毁。            Hystrix中的熔断器（Circuit Breaker）也是起类似作用。Hystrix在运行过程中回向每个CommandKey对应的熔断器报告成功、失败、超时和拒绝的状态，熔断器维护并统计这些数据，并根据这些信息来决策熔断器是否打开。如果打开，则熔断后续请求，快速返回。            隔一段时间后熔断器尝试半开，放一部分流量请求进来，相当于对依赖服务做一次健康检查，如果请求成功熔断器关闭。</p>
<h3 id="熔断器配置"><a href="#熔断器配置" class="headerlink" title="熔断器配置"></a>熔断器配置</h3><p>熔断器主要包括以下6个参数：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>circuitBreaker.enabled</code></td>
<td align="center">是否启用熔断器，默认true</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>circuitBreaker.forceOpen</code></td>
<td align="center">强制打开熔断器，默认false</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>circuitBreaker.forceClosed</code></td>
<td align="center">强制关闭熔断器，默认false</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>circuitBreaker.errorThresholdPercentage</code></td>
<td align="center">错误率阈值，默认值是50%</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>circuitBreaker.requestVolumeThreshold</code></td>
<td align="center">统计请求的最小数量，默认值是20</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><code>circuitBreaker.sleepWindowMillseconds</code></td>
<td align="center">半开状态试探睡眠时间，默认值5000ms</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li><code>circuitBreaker.errorThresholdPercentage</code>是错误率的阈值，例如一段时间内有100个请求，其中有54个超时或异常，那么这段时间内的错误率就是54%，大于阈值50%，这种情况下就会触发熔断器打开。</li>
<li><code>circuitBreaker.requestVolumeThreshold</code>的含义是：一段时间内至少有20个请求才能进行<code>errorThresholdPercentage</code>计算，如果一段时间内只有19个请求，并且这些请求全都失败了，错误率是100%，但是熔断器仍不会打开，因为总请求数不满20。</li>
<li><code>circuitBreaker.sleepWindowMillseconds</code>的含义是：当熔断器开启5000s之后，会尝试放一部分流量过去进行试探，确定依赖服务是否恢复。</li>
</ul>
</blockquote>
<h3 id="熔断器工作原理"><a href="#熔断器工作原理" class="headerlink" title="熔断器工作原理"></a>熔断器工作原理</h3><p><img src="/2020/11/07/Hystrix/%E7%86%94%E6%96%AD%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<p>熔断器的工作流程如下：</p>
<blockquote>
<ol>
<li>调用<code>allowRequest()</code>判断是否允许将请求提交到线程池：<ul>
<li>如果熔断器强制打开，不允许放行，返回；</li>
<li>如果熔断器强制关闭，允许放行。此外不需要再关注熔断器的实际状态，也就是说熔断器仍会维护统计数据和开关状态，但是不生效。</li>
</ul>
</li>
<li>调用<code>isOpen()</code>判断熔断器开关是否打开：<ul>
<li>1）如果熔断器打开，进入第3步，否则继续；</li>
<li>2）如果一个周期内总的请求数小于<code>circuitBreaker.requestVolumeThreshold</code>的值，允许请求放行，否则进入3)；</li>
<li>3）如果一个周期内错误率小于<code>circuitBreaker.errorThresholdPercentage</code>的值，允许请求放行。否则，打开熔断器开关，进入第3步。</li>
</ul>
</li>
<li>调用<code>allowSingleTest()</code>判断是否允许单个请求通行，检查依赖服务是否恢复。<ul>
<li>1）如果熔断器打开，且距离熔断器打开的时间或上一次试探请求放行的时间超过<code>circuitBreaker.sleepWindowMillseconds</code>，熔断器进入半开状态，允许放行一个试探请求；否则，不允许放行。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="回退降级"><a href="#回退降级" class="headerlink" title="回退降级"></a>回退降级</h2><p>降级，通常是指服务高峰期，为了保证核心服务的正常运行，需要停掉一些不太重要的业务，或者某些服务不可用时，执行备用逻辑从故障服务中快速失败或快速返回，以保障主体业务不受影响。            Hystrix提供的降级服务主要是为了容错，保证当前服务不受依赖服务故障的影响，从而提高服务的健壮性。            要支持回退或降级处理，可以重写<code>HystrixCommand</code>中的<code>getFallBack()</code>方法或<code>HystrixObservableCommand</code>中的<code>resumeWithFallBack()</code>方法。</p>
<p>Hystrix会在以下几种情况下执行降级逻辑：</p>
<blockquote>
<ul>
<li>执行<code>construct()</code>或<code>run()</code>抛出异常</li>
<li>熔断器打开导致命令断路</li>
<li>命令的线程池或信号量的容量超额，命令被拒绝</li>
<li>命令执行超时</li>
</ul>
</blockquote>
<ol>
<li>正常工作的情况下，客户端请求调用服务API接口：</li>
</ol>
<p><img src="/2020/11/07/Hystrix/1525658906255.png" alt="1525658906255"></p>
<ol start="2">
<li>当有服务出现异常时，直接进行失败回滚，服务降级处理：</li>
</ol>
<p><img src="/2020/11/07/Hystrix/1525658983518.png" alt="1525658983518"></p>
<blockquote>
<p>当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。</p>
<p>这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。</p>
<p>系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。</p>
</blockquote>
<h3 id="降级回退方式"><a href="#降级回退方式" class="headerlink" title="降级回退方式"></a>降级回退方式</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">HTTP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-03 21:56:34" itemprop="dateCreated datePublished" datetime="2020-11-03T21:56:34+08:00">2020-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-13 09:15:03" itemprop="dateModified" datetime="2021-10-13T09:15:03+08:00">2021-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h1><blockquote>
<p>  什么是协议？</p>
</blockquote>
<p>协议是指双方或多方相互约定好，大家都需要遵循的规则。</p>
<blockquote>
<p>  HTTP：<code>Hyper Text Transfer Protocol</code>     超文本传输协议</p>
</blockquote>
<p>所谓 HTTP 协议，就是指：两台或多台计算机通信时，传输数据时需要遵守的规则。</p>
<p>HTTP协议中的数据又叫做报文。</p>
<blockquote>
<p>  HTTP协议的特点：</p>
</blockquote>
<ol>
<li>HTTP 协议是基于 TCP/IP 的高级协议</li>
<li>默认端口号：80</li>
<li>基于<strong>请求/响应模型</strong>：一次请求对应一次响应。<ul>
<li>客户端浏览器访问服务器端的网页，假设一个页面上有很多内容，如图片、CSS 样式、HTML静态资源、JS样式等。这些内容不是一次请求就全部响应加载出来的，而是多次请求多次响应的过程。</li>
</ul>
</li>
<li>无状态的：<ul>
<li>每次请求之间相互独立，不能交互数据。</li>
</ul>
</li>
</ol>
<blockquote>
<p>  HTTP 协议的历史版本</p>
</blockquote>
<ul>
<li>HTTP 1.0 ：每次请求都会建立新的连接。(这里的连接指的是 TCP 连接，因为 HTTP 底层是 TCP 协议)<ul>
<li>  每次请求得到响应，获取资源后，都会将连接释放，下次请求会建立新的连接，周而复始。</li>
</ul>
</li>
<li>HTTP 1.1 ：复用连接<ul>
<li>  第一次请求得到响应后，在计时器未超时之前，保持与该网页服务器的连接，继续访问无需重新建立连接。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2、请求"><a href="#2、请求" class="headerlink" title="2、请求"></a>2、请求</h1><p>客户端给服务器发送数据叫请求。服务器给客户端回传数据叫做响应。</p>
<p>HTTP有 9 种请求方式，常用的有2种：</p>
<table>
<thead>
<tr>
<th align="center">请求方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>GET</strong></td>
<td>查</td>
</tr>
<tr>
<td align="center"><strong>POST</strong></td>
<td>改</td>
</tr>
<tr>
<td align="center"><strong>PUT</strong></td>
<td>增</td>
</tr>
<tr>
<td align="center"><strong>DELETE</strong></td>
<td>删</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td></td>
</tr>
<tr>
<td align="center">PATCH</td>
<td></td>
</tr>
<tr>
<td align="center">OPTIONS</td>
<td></td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td></td>
</tr>
<tr>
<td align="center">TRACE</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>GET</strong>：</p>
</blockquote>
<ol>
<li>请求参数在请求行中，位置在 URL 之后【请求参数是请求消息的一部分，比如登录界面的账号、密码信息等】</li>
<li>请求参数是有长度限制的【因为把请求参数都算作 URL 长度】</li>
<li>安全性较差。</li>
</ol>
<blockquote>
<p>  <strong>POST</strong>：</p>
</blockquote>
<ol>
<li>请求参数被封装在请求体中。</li>
<li>请求参数没有长度限制。</li>
<li>相对安全。</li>
</ol>
<p><strong>GET 和 POST 请求的区别：</strong></p>
<ul>
<li><p>使用上的区别</p>
<ol>
<li> GET 请求使用 URL 或 Cookie 传参，而 POST 一般将请求数据放在请求体中（当然也可以放在 cookie 中）。</li>
<li> GET 请求将请求参数放在请求行中，而请求行是有长度限制的，所以说请求参数也是有长度限制的，而 POST 请求将请求数据放在请求体中，容量非常大。</li>
<li> POST 比 GET 安全，因为数据在地址栏上不可见。</li>
</ol>
</li>
<li><p>本质区别：</p>
<ol>
<li> GET 和 POST 最大的区别在于 GET 请求是<strong>幂等性</strong>的，而 POST 请求不是。</li>
</ol>
<blockquote>
<p>  幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的效果。即一个方法重复执行多次，产生的效果是一样的。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="2-1、GET请求格式"><a href="#2-1、GET请求格式" class="headerlink" title="2.1、GET请求格式"></a>2.1、GET请求格式</h2><ol>
<li><p>请求行</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET	/demo.html HTTP/1.1</span><br><span class="line">	- GET：请求方式</span><br><span class="line">	- demo.html：请求路径[+?+请求参数]	// 与POST请求不同，请求参数直接拼接在请求路径上</span><br><span class="line">	- HTTP/1.1：协议/版本号</span><br></pre></td></tr></table></figure></li>
<li><p>请求头</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：[key:value]</span><br><span class="line">	不同的键值对，表示不同的含义</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<p><img src="/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/image-20200519085300180-1597652154013.png" alt="image-20200519085300180"></p>
</li>
</ol>
<h2 id="2-2、POST请求格式"><a href="#2-2、POST请求格式" class="headerlink" title="2.2、POST请求格式"></a>2.2、POST请求格式</h2><ol>
<li><p><strong>请求行</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST/demo.html HTTP/1.1</span><br><span class="line">	- POST：请求方式</span><br><span class="line">	- demo.html：请求路径</span><br><span class="line">	- HTTP/1.1：协议/版本号</span><br></pre></td></tr></table></figure></li>
<li><p><strong>请求头</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：[key:value]</span><br><span class="line">	不同的键值对，表示不同的含义</span><br></pre></td></tr></table></figure></li>
<li><p>请求空行</p>
<ul>
<li>功能：用于分隔POST请求的请求头和请求体。</li>
</ul>
</li>
<li><p>请求体（正文）</p>
<ul>
<li>功能：用于封装请求参数，里面保存着发送给服务器的数据</li>
</ul>
</li>
<li><p>示例</p>
<p><img src="/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/image-20200519091906540-1597652154013.png" alt="image-20200519091906540"></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost/login.html</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"># 请求空行</span><br><span class="line"># 请求体</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-3、常用的请求头说明"><a href="#2-3、常用的请求头说明" class="headerlink" title="2.3、常用的请求头说明"></a>2.3、常用的请求头说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.Host: &quot;发起请求的浏览器所在的主机的IP地址&quot;</span><br><span class="line">    </span><br><span class="line">2.User-Agent：&quot;发起请求的浏览器的版本信息[包括浏览器的名称、版本等]&quot;</span><br><span class="line">    -- 在服务器端获取该信息，可以针对不同的浏览器的进行不同的适配处理</span><br><span class="line">    </span><br><span class="line">3.Accept: &quot;告诉服务器可以接收的返回值的数据类型有哪些&quot;</span><br><span class="line">    </span><br><span class="line">4.Accept-Language: &quot;告诉服务器可以接收的语言类型有哪些&quot;</span><br><span class="line"></span><br><span class="line">5.Accept-Encoding: &quot;告诉服务器可以解析哪些压缩/编码格式&quot;</span><br><span class="line">    </span><br><span class="line">6.Referer：&quot;告诉服务器，当前请求从哪里来？[请求发起时，浏览器地址栏中的地址]&quot;</span><br><span class="line">    -- 作用：1、防盗链		2、统计工作</span><br><span class="line">    </span><br><span class="line">7.Connection: keep-alive 	-- 告诉服务器：当前的状态是每次响应后保持连接状态</span><br><span class="line">  </span><br><span class="line">8.Upgrade-Insecure-Requests: 1		-- 升级相关</span><br><span class="line"></span><br><span class="line">9.Content-Type：&quot;表示发送的数据类型（MIME类型）&quot;</span><br><span class="line">    -- application/x-www-form-urlencoded</span><br><span class="line">    	# 表示以键值对的格式发送请求数据（数据封装在请求体中）。如：name1=value1&amp;name2=value2，然后对其进行url编码</span><br><span class="line">    	# url编码是把非英文的内容转换为：%xx%xxx 的格式</span><br><span class="line">    -- multipart/form-data</span><br><span class="line">    	# 表示以多段的形式提交数据给服务器（以流的形式提交，用于上传）</span><br><span class="line">    </span><br><span class="line">10.Content-Length：&quot;表示发送的数据的长度&quot;</span><br><span class="line">    </span><br><span class="line">11.Cache-Control：&quot;表示如何控制缓存&quot; </span><br><span class="line">	-- no-cache 不缓存</span><br></pre></td></tr></table></figure>







<h2 id="2-4、常见的GET-POST请求方式？"><a href="#2-4、常见的GET-POST请求方式？" class="headerlink" title="2.4、常见的GET/POST请求方式？"></a>2.4、常见的GET/POST请求方式？</h2><blockquote>
<p>GET请求：</p>
<ol>
<li><code>&lt;form&gt;</code>标签中 method=get</li>
<li><code>&lt;a&gt;</code>标签</li>
<li><code>&lt;link&gt;</code>标签引入CSS</li>
<li><code>&lt;Script&gt;</code>标签引入JS文件</li>
<li><code>&lt;img&gt;</code>标签引入图片</li>
<li><code>iframe</code>引入HTML页面</li>
<li>在浏览器地址栏中输入地址后敲回车</li>
</ol>
<p>POST请求：</p>
<ol>
<li><code>&lt;form&gt;</code>标签中 method=post</li>
</ol>
</blockquote>
<hr>
<h1 id="3、响应"><a href="#3、响应" class="headerlink" title="3、响应"></a>3、响应</h1><h2 id="3-1、HTTP-协议响应消息的格式"><a href="#3-1、HTTP-协议响应消息的格式" class="headerlink" title="3.1、HTTP 协议响应消息的格式"></a>3.1、HTTP 协议响应消息的格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>响应行</span><br><span class="line">    （<span class="number">1</span>）响应的协议/版本号	<span class="comment">// HTTP/1.1</span></span><br><span class="line">    （<span class="number">2</span>）响应状态码		<span class="comment">// 200(成功)</span></span><br><span class="line">    （<span class="number">3</span>）响应状态描述符		<span class="comment">// OK</span></span><br><span class="line"><span class="number">2.</span>响应头</span><br><span class="line">    [key：value]		<span class="comment">// 不同的响应头，有不同的含义</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>响应空行</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>响应体		<span class="comment">// 就是回传给客户端的数据</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/image-20200519100620160-1597652154014.png" alt="image-20200519100620160"></p>
<h2 id="3-2、常见的响应状态码"><a href="#3-2、常见的响应状态码" class="headerlink" title="3.2、常见的响应状态码"></a>3.2、常见的响应状态码</h2><p><strong>状态码分类（5大类）：</strong></p>
<blockquote>
<p><strong>1xx：</strong></p>
</blockquote>
<ul>
<li>服务器接收到了客户端的请求，但是没有接收完整，等待一段时间之后，发送1xx状态码给客户端。</li>
<li>客户端发送的请求数据不完整或者在传输过程中部分数据丢失，导致服务器一直处于等待请求数据的状态。直到等待的时间大于超时时间后，就会给向客户端响应 1xx 状态码表示请求数据不完整。</li>
</ul>
<blockquote>
<p><strong>2xx：</strong></p>
</blockquote>
<ul>
<li>客户端请求消息和服务器端响应消息都成功时返回2xx状态码表示成功。</li>
</ul>
<blockquote>
<p><strong>3xx</strong></p>
</blockquote>
<ul>
<li>重定向：<ul>
<li>301（永久重定向）：请求的网页已经永久移动到了新位置，当返回 301 状态码时请求者应该将请求 URL 改为新的 URL。</li>
<li>302（临时重定向）：服务器目前从新的网页响应请求，但是请求者接下来的请求应该继续使用原 URL。</li>
</ul>
</li>
<li>304（访问缓存）</li>
</ul>
<blockquote>
<p><strong>4xx</strong></p>
</blockquote>
<ul>
<li>客户端请求发生了错误</li>
<li>400：客户端请求语法错误</li>
<li>403：服务器收到请求，但拒绝提供服务。</li>
<li>404：（未找到）服务器找不到请求的资源</li>
<li>405：客户端发送请求的方式与服务器规定的请求方式不一致！    如：在服务器中规定某个请求的请求方式是 POST 请求，而客户端却已 GET 的方式提交请求，这时就会出现405错误。</li>
</ul>
<blockquote>
<p><strong>5xx</strong></p>
</blockquote>
<ul>
<li>服务器内部错误</li>
</ul>
<h3 id="301-和-302-的区别"><a href="#301-和-302-的区别" class="headerlink" title="301 和 302 的区别"></a>301 和 302 的区别</h3><hr>
<h2 id="3-3、常见的响应头"><a href="#3-3、常见的响应头" class="headerlink" title="3.3、常见的响应头"></a>3.3、常见的响应头</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.Content-Type: &quot;服务器告诉客户端本次响应体的响应数据类型（MIME类型）&quot;</span><br><span class="line"></span><br><span class="line">2.Content-Length: &quot;服务器告诉客户端本次响应体的长度&quot;</span><br><span class="line"></span><br><span class="line">3.Content-disposition: &quot;服务器告诉客户端以什么格式打开响应体数据&quot;</span><br><span class="line">  -- props:</span><br><span class="line">  -- 	1. in-line	：默认值，在当前页面打开</span><br><span class="line">  -- 	2. attachment；filename=xxx	：以附件形式打开响应体。【文件下载】</span><br></pre></td></tr></table></figure>





<h2 id="3-4、响应体"><a href="#3-4、响应体" class="headerlink" title="3.4、响应体"></a>3.4、响应体</h2><ul>
<li><p>传输的数据【最终被浏览器解析展示在页面上】</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    	hello , response</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="4、HTTP-长连接和短连接"><a href="#4、HTTP-长连接和短连接" class="headerlink" title="4、HTTP 长连接和短连接"></a>4、HTTP 长连接和短连接</h1><p><strong>短连接</strong></p>
<ul>
<li>  在 <code>HTTP/1.0</code> 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 请求，就建立一次 TCP 连接，任务结束就释放连接。</li>
<li>  如果客户端浏览器访问的某个页面中包含有其它 Web 资源，如 JavaScript 文件、图像文件、CSS文件等，当浏览器每遇到这样一个Web 资源，就会新发起一个 HTTP 请求，新建一个 TCP 连接。</li>
</ul>
<p><strong>长连接</strong></p>
<ul>
<li>  从 <code>HTTP/1.1</code> 起，默认使用长连接，用以保持连接特性。</li>
<li>  使用长连接的 HTTP 协议，会在响应头有加入一行代码：<strong>Connection:keep-alive</strong></li>
<li>  在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</li>
<li>  实现长连接要客户端和服务端都支持长连接。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>  HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</li>
</ul>
<hr>
<h1 id="5、HTTP1-0-和-HTTP1-1-的区别"><a href="#5、HTTP1-0-和-HTTP1-1-的区别" class="headerlink" title="5、HTTP1.0 和 HTTP1.1 的区别"></a>5、HTTP1.0 和 HTTP1.1 的区别</h1><ol>
<li> <strong>支持长连接</strong></li>
</ol>
<p><code>HTTP/1.1</code> 支持长连接（Persistent Connection），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<p><code>HTTP/1.1</code> 中默认开启长连接 <code>Connection: keep-alive</code>，一定程度上弥补了 <code>HTTP/1.0</code> 每次请求都要创建连接的缺点。</p>
<ol start="2">
<li> <strong>错误通知的管理</strong></li>
</ol>
<p>在 <code>HTTP/1.1</code> 中新增了 24 个错误状态响应码。如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<ol start="3">
<li> <strong>Host 头处理</strong></li>
</ol>
<p>在 <code>HTTP/1.0</code> 中认为每台服务器都绑定一个唯一的 IP 地址，因此请求消息中的 URL 并没有传递主机名（<strong>hostname</strong>）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。所以 <code>HTTP/1.1</code> 的请求消息和响应消息都支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</p>
<hr>
<h1 id="6、MINE-类型数据"><a href="#6、MINE-类型数据" class="headerlink" title="6、MINE 类型数据"></a>6、MINE 类型数据</h1><blockquote>
<p>通过上面的学习，我们会发现无论是在请求头中还是响应头中都有一个 <strong>Content-Type</strong> 属性，这个属性在开发中非常有用。比较常见的文件上传就是利用这个属性来实现的。[文件下载则通过响应头中的另一个属性 <strong>Content-disposition</strong> 来实现。]</p>
</blockquote>
<blockquote>
<p>请求头/响应头都是通过键值对来保存数据的，<code>Content-Type</code> 作为一个键值对的 Key ，而它对应的 Value 就是我们下面要讲的 MIME 类型数据！！！</p>
</blockquote>
<h2 id="MIME类型说明"><a href="#MIME类型说明" class="headerlink" title="MIME类型说明"></a>MIME类型说明</h2><blockquote>
<p>MIME：</p>
</blockquote>
<p>Multipurpose Internet Mail Extensions</p>
<blockquote>
<p>概念：</p>
</blockquote>
<p>MIME 是<strong>描述消息内容类型的因特网标准</strong>。MIME 消息类型包含文本、图像、音频、视频以及其他应用程序专用的数据。</p>
<blockquote>
<p>格式：</p>
</blockquote>
<p>MIME类型的格式：<strong>大类型/小类型</strong>，并与某一种文件扩展名相对应。</p>
<blockquote>
<p>常见的MIME类型：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">文件</th>
<th align="center">文件后缀名</th>
<th align="center">MIME类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">超文本标记语言</td>
<td align="center">.html || .htm</td>
<td align="center">text/html</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">普通文本</td>
<td align="center">.txt</td>
<td align="center">text/plain</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">RTF文本（类似于Word文档）</td>
<td align="center">.rtf</td>
<td align="center">application/rtf</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">GIF图形</td>
<td align="center">.gif</td>
<td align="center">image/img</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">JPEG图形</td>
<td align="center">.jpeg || .jpg</td>
<td align="center">image/jpeg</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">au声音文件</td>
<td align="center">.au</td>
<td align="center">auto/basic</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">MIDI音乐文件</td>
<td align="center">.mid || .midi</td>
<td align="center">audio/midi || audio/x-midi</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">RealAudio音乐文件</td>
<td align="center">.ra || .ram</td>
<td align="center">video/mpeg</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">MPEG文件</td>
<td align="center">.mpg || .mpeg</td>
<td align="center">video/mpeg</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">AVI文件</td>
<td align="center">.avi</td>
<td align="center">video/x-msvideo</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">GZIP文件</td>
<td align="center">.gz</td>
<td align="center">application/x-gzip</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">TAR文件</td>
<td align="center">.tar</td>
<td align="center">application/x-tar</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-29 10:21:52" itemprop="dateCreated datePublished" datetime="2020-10-29T10:21:52+08:00">2020-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-02 10:18:44" itemprop="dateModified" datetime="2021-09-02T10:18:44+08:00">2021-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h2><blockquote>
<p>将<code>多个计算机系统</code>通过<code>通信设备</code>连接起来，由<code>软件</code>实现<code>资源共享和信息传递</code>的系统。</p>
</blockquote>
<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><blockquote>
<p><strong>硬件 + 软件 + 协议</strong></p>
</blockquote>
<ol>
<li>硬件：<ul>
<li>主机</li>
<li>通信链路（双绞线、光纤等）</li>
<li>交换设备（路由器、交换机等）</li>
<li>……</li>
</ul>
</li>
<li>软件：实现资源共享的软件。</li>
<li>协议：规定了通过网络传输数据时需要遵循的规范。<ul>
<li>是两个(或多个)<strong>对等实体</strong>间通信的规则的集合，不对等的实体间是没有协议的。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><blockquote>
<p><strong>数据通信 + 资源共享 + 分布式处理 + 提高可靠性 + 负载均衡</strong></p>
</blockquote>
<ol>
<li>数据通信</li>
<li>资源共享</li>
<li>分布式处理：<ul>
<li>当计算机网络中的某个计算机负荷过重时，可以将其处理的任务分配给其它计算机系统，从而提高整个系统的利用率。</li>
</ul>
</li>
<li>提高可靠性：<ul>
<li>整个计算机网络系统就是一个大的集群，计算机网络中的各台计算机可以互为替代机。</li>
</ul>
</li>
<li>负载均衡<ul>
<li>将工作任务均衡的分配给计算机网络中的各台计算机。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><blockquote>
<ol>
<li><strong>WAN + MAN + LAN + PAN</strong></li>
<li><strong>广播式网络 + 点对点网络</strong></li>
<li><strong>有线网络 + 无线网络</strong></li>
</ol>
</blockquote>
<h3 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h3><ol>
<li>广域网（WAN）</li>
<li>城域网（MAN）</li>
<li>局域网（LAN）</li>
<li>个人区域网（PAN）</li>
</ol>
<h3 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h3><ol>
<li>广播式网络</li>
<li>点对点网络</li>
</ol>
<h3 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h3><ol>
<li>有线网络</li>
<li>无线网络</li>
</ol>
<h2 id="协议数据单元-PDU"><a href="#协议数据单元-PDU" class="headerlink" title="协议数据单元(PDU)"></a>协议数据单元(PDU)</h2><ul>
<li><code>PDU（Protocol Data Unit）</code>：协议数据单元</li>
<li><code>PCI（Protocol Control Information）</code>：协议控制信息</li>
<li><code>SDU（Service Data Unit）</code>：服务数据单元</li>
</ul>
<blockquote>
<p>对等层之间传递数据的单位称为该层的 PDU。</p>
</blockquote>
<p>在实际的网络中，每层的PDU都有一个别名，分别是：</p>
<table>
<thead>
<tr>
<th align="center">层</th>
<th align="center">PDU的别名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物理层</td>
<td align="center">比特</td>
</tr>
<tr>
<td align="center">数据链路层</td>
<td align="center">帧</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">分组(/IP数据报)</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">报文段(TCP)/用户数据报(UDP)</td>
</tr>
</tbody></table>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><blockquote>
<p><code>服务</code>是垂直的，是指：<strong>下层为<u>紧邻的</u>上层提供的功能调用。</strong></p>
</blockquote>
<h3 id="服务原语"><a href="#服务原语" class="headerlink" title="服务原语"></a>服务原语</h3><p>上层要使用下层所提供的服务，必须和下层进行交互，这些交互的命令在OSI中被称为<strong>服务原语</strong>。OSI将服务原语划分为4类：</p>
<blockquote>
<ol>
<li><code>请求(Request)</code>：服务用户–&gt;&gt;服务提供者，请求完成某项工作。</li>
<li><code>指示(Indication)</code>：服务提供者–&gt;&gt;服务用户，指示用户做某事。</li>
<li><code>响应(Response)</code>：服务用户–&gt;&gt;服务提供者，作为对<code>指示</code>的响应。</li>
<li><code>证实(Conformation)</code>：服务提供者–&gt;&gt;服务用户，作为对<code>请求</code>的证实。</li>
</ol>
</blockquote>
<h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><blockquote>
<ol>
<li><strong>面向连接服务&amp;无连接服务</strong></li>
<li><strong>可靠服务&amp;不可靠服务</strong></li>
<li><strong>有应答服务&amp;无应答服务</strong></li>
</ol>
</blockquote>
<h4 id="1、面向连接服务-amp-无连接服务"><a href="#1、面向连接服务-amp-无连接服务" class="headerlink" title="1、面向连接服务&amp;无连接服务"></a>1、面向连接服务&amp;无连接服务</h4><blockquote>
<ul>
<li>面向连接服务：<code>建立连接 --&gt;&gt;数据传输 --&gt;&gt; 连接释放 </code></li>
<li>无连接服务：尽最大努力交付，是不可靠的服务</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th align="center">面向连接服务</th>
<th align="center">无连接服务</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1. 通信前是否建立连接</td>
<td align="center">是</td>
<td align="center">否</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 通信前是否分配相应的资源（如内存空间）</td>
<td align="center">是</td>
<td align="center">否</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. 传输结束后是否释放连接</td>
<td align="center">是</td>
<td align="center">否</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4. 常见的例子</td>
<td align="center">TCP</td>
<td align="center">IP/UDP</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2、可靠服务-amp-不可靠服务"><a href="#2、可靠服务-amp-不可靠服务" class="headerlink" title="2、可靠服务&amp;不可靠服务"></a>2、可靠服务&amp;不可靠服务</h4><blockquote>
<ul>
<li><p>可靠服务：网络具有纠错、检错、应答机制，能保证数据正确、可靠的传送到目的地。</p>
</li>
<li><p>不可靠服务：网络只是尽量正确、可靠的传送，但不能保证数据正确、完整地传送到目的地。</p>
<p>对于不可靠服务，其数据的正确性只能靠用户来保障。</p>
</li>
</ul>
</blockquote>
<h4 id="3、有应答服务-amp-无应答服务"><a href="#3、有应答服务-amp-无应答服务" class="headerlink" title="3、有应答服务&amp;无应答服务"></a>3、有应答服务&amp;无应答服务</h4><blockquote>
<ul>
<li>有应答服务：接收方在收到数据后向发送方给出相应的应答。</li>
<li>无应答服务：接收方收到数据后不自动给出应答。若需要应答，则交给高层实现。</li>
</ul>
</blockquote>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h2><blockquote>
<p>提供<code>点到点(不同IP地址之间)</code>的通信</p>
<ol>
<li>为网络层提供服务。</li>
<li><strong>成帧</strong>：将网络层传下来的 IP 数据报封装成帧。(为上层提供服务)</li>
<li><strong>差错控制</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>链路管理</strong></li>
</ol>
</blockquote>
<h3 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h3><blockquote>
<p>对网络层而言，数据链路层的功能就是将源机器中来自网络层的数据传送到目标机器的网络层中去。</p>
</blockquote>
<p>数据链路层为网络层提供的服务有：</p>
<ol>
<li>无确认的无连接服务</li>
<li>有确认的无连接服务</li>
<li>有确认的面向连接服务</li>
</ol>
<h3 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h3><blockquote>
<p>数据链路层连接的建立、维持和释放过程就称为<code>链路管理</code>。</p>
</blockquote>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><blockquote>
<p>差错控制是通信的2个节点之间约定好的特定的检错规则。如奇偶校验码，接收方根据约定好的规则去检测接收到的数据是否正确。如果出了差错，能纠错就纠错，不能纠错就丢弃，确保向上层提交的数据都是无误的。</p>
</blockquote>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><blockquote>
<p>在2个节点之间传送数据时，由于2个节点的性能不同，可能节点A的发送速度远大于B节点的接收速度，如果不加以控制，那么节点B就会丢弃很多来不及接收的数据。流量控制就是想办法协调2个节点的速度，使A节点的发送速度与B节点的接收速度达到一个平衡状态。</p>
</blockquote>
<h4 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h4><h5 id="1、停止-等待协议"><a href="#1、停止-等待协议" class="headerlink" title="1、停止-等待协议"></a>1、停止-等待协议</h5><h5 id="2、后退N帧协议"><a href="#2、后退N帧协议" class="headerlink" title="2、后退N帧协议"></a>2、后退N帧协议</h5><h5 id="3、选择重传协议"><a href="#3、选择重传协议" class="headerlink" title="3、选择重传协议"></a>3、选择重传协议</h5><hr>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><ul>
<li>  网络层传输的 PDU 叫做<strong>分组（或 IP 数据报）</strong>。</li>
<li>  网络层的主要任务是将网络层的数据报从源端传递到目的端，为网络上的不同主机提供通信服务。</li>
<li>  分层结构中下层服务对于上层是“不可见”的，所以网络层的功能是描述两个对等层之间的，不考虑物理层和数据链路层。</li>
</ul>
<h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><blockquote>
<ol>
<li>为传输层提供服务</li>
<li>数据通信</li>
<li><strong>异构网络互联</strong></li>
<li><strong>路由与转发</strong></li>
<li><strong>拥塞控制</strong></li>
<li>流量控制</li>
<li>差错控制</li>
<li>…</li>
</ol>
</blockquote>
<h3 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h3><blockquote>
<p>  <strong>什么叫异构网络互联？</strong></p>
</blockquote>
<ul>
<li>  我们通常使用的互联网，它就是一个由无数个异构网络互联形成的大型计算机网络。</li>
<li>  所谓的<strong>计算机网络</strong>，通俗来讲就是一个网络连接了多台计算机，这多台计算机之间可以通过网络进行通信、数据共享等功能。</li>
<li>  而<strong>异构网络</strong>的意思就是：计算机网络是一个概念，其具体的落地实现可以有多种，使用不同的寻址方案、不同的网络接入机制、不同的差错处理机制、不同的路由选择机制等实现的计算机网络是不同的，它们互相之间就是异构网络。</li>
<li>  每种异构网络都有其擅长的应用场景，没有一种统一的网络能适应所有用户的需求。<strong>异构网络互联</strong>就是让这些异构的网络之间实现相互通信。</li>
<li>  举个例子就是：某公司内部有自己的内网，而它同时又想可以连接到公网（外网）上去，这就涉及到了异构网络的互联。</li>
<li>  <strong>定义</strong>：所谓<code>网络的互联</code>就是指：将2个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备（即中间设备）连接起来，以构成更大的网络系统。中间设备又称为<strong>中间系统</strong>或中继系统。</li>
</ul>
<blockquote>
<p>  <strong>什么是中继系统？</strong></p>
</blockquote>
<ul>
<li>中继系统就是两个（或多个）异构网络之间进行通信的转发器。即一个网络内所有计算机发出的消息的都会先发送到中继系统，再由中继系统传递给别的网络；同理，接收消息时也是先由中继系统接收，再转发中该网络内某个具体的计算机上。</li>
</ul>
<blockquote>
<p>  <strong>中继系统分类：</strong></p>
</blockquote>
<p>根据中继系统所在的层次，有以下4种不同的中继系统：</p>
<ol>
<li>物理层中的中继系统：<strong>中继器、集线器</strong></li>
<li>数据链路层中的中继系统：<strong>网桥、交换机</strong></li>
<li>网络层中的中继系统：<strong>路由器</strong></li>
<li>网络层以上的中继系统：<strong>网关</strong></li>
</ol>
<p><strong>例子</strong>：要实现网络的互联，每层的中继系统都必不可少。比如，我们在计算机 A 的浏览器上通过 <strong>网关</strong> 访问了 X 资源，首先要把我们的请求信息由上到下一层层封装，最后封装为比特流，通过电信号的形式一层层的传递给存放 A 资源的计算机 B，计算机 B 再把接收到的比特流逐级解封装为请求信息，作出响应。这一过程中，我们在每一层都可能使用了中继系统。</p>
<hr>
<h3 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h3><p>在上面的学习中，我们知道了<strong>路由器是多个计算机网络相互联系的中继系统</strong>。那么路由器做了哪些事情呢？</p>
<p>路由器主要完成 2 个功能：</p>
<blockquote>
<ol>
<li>路由选择：</li>
<li>分组转发：路由器根据转发表将用户的IP数据报从合适的端口转发出去。</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li> <strong>什么是路由选择？</strong></li>
</ol>
</blockquote>
<ul>
<li>  路由选择就是选择路径。每个路由器都维护了一张路由表，这张路由表记录了该路由器可以到达的其它所有的路由器。</li>
<li>  比如计算机 A 在网 1 内，计算机 B 在网 9 中，从网 1 到 网 9 有多条路径可以到达，如何选择路径就是路由选择。</li>
<li>  路由选择是由路由选择算法决定的。</li>
<li>  路由转发是从一个路由器转发到另一个路由器，而不是从一个路由器下的计算机到另一路由器下的计算机。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>什么是分组转发？</strong></li>
</ol>
</blockquote>
<ul>
<li>  分组转发也是使用路由表进行转发，只不过路由选择重点在于选择，分组转发重点在于数据传输。也就是根据选择好的路径进行数据传输。</li>
<li>  <strong>路由器仅根据目的主机所在的网络号来转发分组（IP数据报）</strong>，从而减少了路由表所占的存储空间。（即路由表中记录的是网络号）</li>
<li>  意思就是：一个网络内一般会有很多台计算机，但是这些计算机都同属于一个网络号。</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><blockquote>
<p>  <strong>什么是网络拥塞？</strong></p>
</blockquote>
<p>网络中的数据传输一般要经过多个路由器，如果某个路由器接收的数据量远大于该节点的最大接收范围，接收数据的能力而言），那么就说网络处于<strong>拥塞状态</strong>。</p>
<blockquote>
<p>  <strong>什么是拥塞控制？</strong></p>
</blockquote>
<ul>
<li>  拥塞控制就是确保子网络只承载其能承受的最大数据流量。</li>
</ul>
<blockquote>
<p>  <strong>拥塞控制的方法？</strong></p>
</blockquote>
<ul>
<li>  <strong>开环控制</strong>：事先考虑好所有的情况，运行时不再更改。</li>
<li>  <strong>闭环控制</strong>：运行时监控，哪里出现拥塞就进行分流。</li>
</ul>
<blockquote>
<p>  分类IP地址</p>
</blockquote>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101552003.png" alt="image-20210820101552003"></p>
<hr>
<h2 id="网络层常见的协议"><a href="#网络层常见的协议" class="headerlink" title="网络层常见的协议"></a>网络层常见的协议</h2><blockquote>
<ol>
<li>IP</li>
<li>ICMP</li>
<li>IGMP</li>
</ol>
</blockquote>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><blockquote>
<p>版本为4的IP协议</p>
</blockquote>
<h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><h4 id="IP数据报的分片"><a href="#IP数据报的分片" class="headerlink" title="IP数据报的分片"></a>IP数据报的分片</h4><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><blockquote>
<ul>
<li><p>连接在Internet中的每一台主机（或路由器）都分配一个<code>32位</code>的全球唯一的标识符，即IP地址。</p>
</li>
<li><p>IP地址可分为5类：ABCDE</p>
</li>
<li><p><code>IP地址 = &#123;&lt;网络号&gt;, &lt;主机号&gt;&#125;</code></p>
<p>其中，网络号标志主机(或路由器)连接到的网络，一个网络号在因特网范围内必须是唯一的；</p>
<p>主机号标志该主机(或路由器)，一个主机号在网络号所指明的网络范围内是唯一的。</p>
</li>
</ul>
</blockquote>
<ol>
<li>IP地址分为5类，这5类分别对应着5种网络号的开头</li>
</ol>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">网络号中对应的标示</th>
<th align="center">网络号在IP地址中占的位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">10</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">110</td>
<td align="center">24</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">1110</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">1111</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>在各类IP地址中，有一些IP地址表示特殊用途，不可以当做某台主机的的IP地址。</p>
<blockquote>
<ul>
<li>主机号全为0表示本网络本身</li>
<li>主机号全为1表示本网络的广播地址</li>
<li>127.0.0.0表示主机本身</li>
<li>32为全为0表示本网络上的本主机。</li>
<li>32位全为1表示整个网络的广播地址。</li>
</ul>
</blockquote>
</li>
<li></li>
</ol>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><hr>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><blockquote>
<ol>
<li>传输层为运行在不同主机上的进程之间提供了<strong>逻辑通信</strong>（即端到端的通信）。</li>
<li>流量控制</li>
<li>差错控制</li>
<li>服务治理</li>
<li>数据传输管理</li>
</ol>
</blockquote>
<blockquote>
<p>  <strong>核心功能</strong></p>
</blockquote>
<ul>
<li>  传输层提供<strong>进程间的逻辑通信</strong>；网络层提供主机间的逻辑通信。</li>
<li>  传输层实现进程间的逻辑通信依赖的是<strong>套接字</strong>，在网络通信中，主机 A 发送给主机 B 的报文段包含目的端口号和源端口号，目的端口号用于找到主机 B 的进程，源端口号则用于主机 B 返回响应消息。</li>
</ul>
<blockquote>
<p>  <strong>传输协议（TCP / UDP）</strong></p>
</blockquote>
<ul>
<li>  传输层提供两种不同的传输协议，即 ①面向连接的 TCP；  ②无连接的 UDP</li>
<li>  <strong>网络层的 IP 协议是不可靠的。</strong></li>
<li>  当传输层采用<strong>面向连接</strong>的 TCP 协议时，尽管下面的网络层是不可靠的，但是由于 TCP 具有可靠性，所以建立的逻辑信道就相当于是一条<strong>全双工</strong>的可靠信道；而当传输层采用无连接的 UDP 时，建立的逻辑信道仍然是一条不可靠信道。</li>
</ul>
<blockquote>
<p>  <strong>面向连接 vs. 无连接</strong></p>
</blockquote>
<ul>
<li><strong>面向连接</strong>就是，通信的双方在：<ol>
<li> 正式通信前，要先建立连接，</li>
<li> 通信过程中，要一直监控连接的情况；</li>
<li> 通信结束后，要释放连接。</li>
</ol>
</li>
<li>  <strong>无连接</strong>是：通信的双方无需提前建立连接，需通信的时候，直接将“数据”发送到网络上，尽可能地往目的地输送，但不保证一定成功。</li>
</ul>
<blockquote>
<p>  <strong>单工、全双工、半双工</strong></p>
</blockquote>
<ul>
<li>  <strong>单工：</strong>一条信道，只有一个方向通信。即 A 可以给 B 发，但 B 不能给 A 发。如果 A 想发给 B，则需要新建一条 B 到 A 的信道。</li>
<li>  <strong>半双工：</strong>两条信道，A 可以给 B 发，B 也可以给 A 发，但 A 给 B 发和 B 给 A 发不能同时进行。即 A 不能同时接收和发送，B 也一样。</li>
<li>  <strong>全双工：</strong>两条信道，A 和 B 都可以同时接收和发送。</li>
</ul>
<blockquote>
<p>  <strong>端口的作用：</strong></p>
</blockquote>
<ul>
<li>  <strong>端口就是应用层和传输层之间进行数据传输的通道</strong>。</li>
<li>  应用层的各种应用进程需要通过端口才能将其数据向下交付给传输层；以及传输层可以将其报文段中的数据通过端口向上交付给应用层的进程。</li>
</ul>
<blockquote>
<p>  <strong>端口号</strong></p>
</blockquote>
<ul>
<li>  端口号用于在一台计算机上唯一标识一个端口。</li>
</ul>
<blockquote>
<p>  <strong>套接字（Socket）</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">套接字 = （主机IP地址，端口号）</span><br></pre></td></tr></table></figure>

<ul>
<li>  套接字唯一地标识了一个主机和其上的一个应用（进程）。</li>
<li>  叫进程更为合适一点，因为客户机上一些应用使用的端口号是动态的，只有在运行时作为一个进程才能知道。</li>
</ul>
<hr>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote>
<p>  <strong>UDP 优点</strong></p>
</blockquote>
<ol>
<li> UDP 是无连接的，即不会引入建立连接的时延；</li>
<li> 不需要维护连接状态，即不需要消耗资源去跟踪连接状态的相关参数，消耗的系统资源更少，即同样的软、硬件条件下能支持更多的服务。</li>
<li> 分组首部开销小。TCP 首部需要 20Byte，而 UDP 仅需 8Byte。（TCP由于要建立、维护、释放连接，所以首部需要的信息多一点）</li>
<li> UDP 没有拥塞控制，允许丢弃部分数据，对于要求控制发送时间的应用友好。即允许发送失败，但不允许发送超时的应用。</li>
</ol>
<blockquote>
<p>  <strong>UDP 首部格式</strong></p>
</blockquote>
<ul>
<li>  <strong>目的端口号</strong></li>
<li>  <strong>源端口号</strong>：在需要对方回信时使用，不需要时全选 0 即可。</li>
<li>  <strong>长度</strong>：UDP 数据报的包括（首部长度+数据长度）。最短为 8Byte，即只有首部无数据。</li>
<li><strong>校验和</strong>：<ul>
<li>  接收方使用，用于检验 UDP 数据在传输中是否出错了，<strong>有错就丢弃</strong>。</li>
<li>  该字段是可选的，如果源主机不想计算校验和，直接令该字段全为 0  即可。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20171019224629112" alt="img"></p>
<ul>
<li>  如果接收方传输层的 UDP 发现报文中的端口号不存在，就丢弃该报文。</li>
<li>  UDP 首部 8Byte 是四部分平均分配的，每一部分占 2Byte。</li>
<li>  UDP 校验和可以校验数据报的首部部分和数据部分，发送方 UDP 将校验和保存在 UDP 首部中，接收方 UDP 通过破解校验和得到的结果，确定发送的消息是否正确，如果正确就接收，不正确就丢弃。</li>
</ul>
<hr>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h3><ul>
<li>  TCP 传送的数据单元叫做<strong>TCP报文段</strong>。</li>
<li>  <code>TCP报文段 = TCP 首部 + TCP 数据部分</code></li>
<li>  <strong>TCP 首部长度是可变的，至少占 20Byte ，最多占 60Byte</strong>。允许扩充，每次扩充必须是 4Byte 的整数倍，即 <code>(4*N) Byte</code>。</li>
<li>  整个 TCP 报文段作为 IP 数据报的的数据部分封装在 IP 数据报中。</li>
</ul>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20181130165347546.png" alt="img" style="zoom:150%;">



<blockquote>
<p>  <strong>TCP 首部各成员的含义：</strong></p>
</blockquote>
<ol>
<li><p> <strong>源端口号</strong></p>
</li>
<li><p> <strong>目的端口号</strong></p>
</li>
<li><p><strong>序号</strong>：TCP 传输的是字节流（即一个一个字节的集合），即一个 TCP 报文段包含几百几千个 Byte，TCP 会为每个 Byte 都建立一个编号，而<strong>序号</strong>指的就是当前报文段所发送的字节流数据中第一个字节的序号。</p>
<p> 例如：一个报文段的序号值为 301，携带的数据共有 100Byte，这就表明当前报文段数据的最后一个字节的序号是 400，故希望下一个报文段的数据序号应该从 401 开始。</p>
</li>
<li><p><strong>数据偏移</strong>：数据偏移指的就是首部长度。因为 TCP 首部是变长的，所以要使用数据偏移记录 TCP 报文段的首部长度。</p>
<p> <code>数据偏移 = | TCP报文段的起始位置 - TCP报文段数据部分的起始位置 |</code></p>
</li>
<li><p> <strong>保留字段</strong>：保留为今后使用</p>
</li>
<li><p> <strong>URG（紧急位）</strong>：Urgency，当某一报文段中包含紧急数据时可以声明为紧急报文段，其对应的优先级会被提高。URG 需要和<strong>紧急指针</strong>配套使用，<code>URG=1</code> 表示紧急指针字段有效。</p>
</li>
<li><p> <strong>紧急指针</strong>：紧急指针指出在本报文段中紧急数据共有多个字节。紧急数据需放在数据部分的最前面，数据从第一个字节开始到紧急指针所指的字节就是紧急数据。</p>
</li>
<li><p> <strong>确认号</strong>：是接收方的 TCP 期望收到的下一个报文段的第一个字节的序号。若确认号为 N，则表明接收方前 N-1 个字节全部正确接收到了。确认号需要和<strong>确认位（ACK）</strong>配合使用【确认号是接收方在响应信息的确认报文段中使用的】</p>
</li>
<li><p><strong>ACK（确认位）</strong>：只有当 ACK=1 时确认号字段才有效；当 ACK=0 时，确认号无效。</p>
<p> TCP 规定，在建立连接之后所有传送的报文段都必须把 ACK 置为 1。</p>
</li>
<li><p> <strong>PSH（推送位）</strong>：相当于强制刷新到上层协议的内存中。一般情况下，接收方接收到的数据会先保存在缓存中，等缓存填满之后再向上交付，但是收到 <strong>PSH=1</strong> 的报文段后，不管缓存是否填满，会立即执行一个数据的向上交付。</p>
</li>
<li><p> <strong>RST（复位位）</strong>：Reset，当 <strong>RST=1</strong> 时，表名 TCP 连接中出现了严重错误，必须释放连接，重新建立建立。</p>
</li>
<li><p><strong>SYN（同步位）</strong>：<strong>SYN=1</strong> 表示这是一个<strong>连接请求</strong>或<strong>连接接收</strong>报文。</p>
<ul>
<li>  当 <strong>SYN=1，ACK=0</strong> 时，表明这是一个连接请求报文；[TCP 规定连接建立后，确认位 ACK=1 恒成立，但是第一次请求建立连接时连接还尚未建立，所以 ACK=0 。]</li>
<li>  若对方同意建立，则在响应报文中使用 <strong>SYN=1，ACK=1</strong> ，此时连接已经建立了。</li>
</ul>
</li>
<li><p> <strong>FIN（终止位）</strong>：<strong>FIN=1</strong> 表示此报文段的发送方数据已经发送完毕，并要求释放连接。</p>
</li>
<li><p> <strong>窗口</strong>：指出了<strong>当前</strong>还允许对方发送的最大数据量。这个值在不断地变化，接收方的缓存空间是有限的，假设接收方缓存大小为 1000Byte，当已经使用了 300Byte 后，这时候窗口的大小就是 700Byte，即当前允许对方发送的最大数据量。</p>
</li>
<li><p> <strong>校验和</strong>：用于校验 TCP 报文段首部和数据两部分。</p>
</li>
<li><p> <strong>选项</strong>：长度可变，TCP 最初只规定了一种选项。即最大报文长度。</p>
</li>
<li><p> <strong>填充</strong>：为了使整个首部的长度是 4Byte 的整数倍。</p>
</li>
</ol>
<hr>
<h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><p>每一条 TCP 连接有两个端点，分别是两个套接字。</p>
<p>TCP连接的建立要经过3个步骤，通常称为“三次握手”。</p>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20180714120413411" alt="img"></p>
<blockquote>
<p>  <strong>step1：</strong></p>
</blockquote>
<ul>
<li>  客户机的 TCP 首先向服务器的 TCP 发送一个连接请求报文段。</li>
<li>  这个特殊的报文段中不包含应用层数据，但其首部的 SYN 标志位被置为 1，ACK 仍为 0（因为 ACK=1 标识着确认号有效，但是第一次请求建立连接时并没有确认号，所以确认位置为 0 即可）</li>
<li>  另外，客户机会随机选择一个起始序号 seq=x (连接请求报文中不携带数据，但是会消耗掉一个序号)。</li>
</ul>
<blockquote>
<p>  <strong>step2：</strong></p>
</blockquote>
<ul>
<li>  服务器的 TCP 接收到连接请求报文段后，<strong>如果同意建立连接</strong>，就向客户机发回确认报文段，<strong>并为该 TCP 连接分配 TCP 缓存和变量</strong>。</li>
<li>  如果服务器同意建立，此时对于服务器而言，连接就已经建立了，处于<strong>“半连接状态”</strong>。</li>
<li>  在确认报文段中，<strong>SYN=1，ACK=1</strong>，确认号字段的值为 <code>x+1</code>，并且服务器会随机选择一个起始序号 <code>seq=y</code>。确认报文段同样不携带数据，但也要消耗掉一个序号。（因为服务器要发送确认号给客户端，所以确认位 SYN 必须为 1）</li>
</ul>
<blockquote>
<p>  <strong>step3：</strong></p>
</blockquote>
<ul>
<li>  当客户机收到确认报文段后，还要向服务器给出确认报文段，并且也要<strong>给该连接分配缓存和变量</strong>。</li>
<li>  这个报文段的<strong>确认位 ACK=1，序号 seq=x+1，确认号 ack=y+1</strong>。</li>
<li>  <strong>该报文段可以携带数据，如果不携带数据则不消耗序列号。</strong></li>
</ul>
<p>在成功进行了以上三步后，TCP 连接就建立了，接下来就可以传递应用层数据了。</p>
<p>TCP 提供的是全双工通信，因此通信双方的应用层任何时候都能发送数据。</p>
<p>由于服务器端的资源是在第二次握手时分配的，而客户端的资源是在第三次握手时才分配的。所以客户端可以利用这一特性在发送大量的请求去攻击服务器，这叫做 <strong>SYN洪泛攻击</strong>。</p>
<blockquote>
<p>  <strong>SYN 洪泛攻击</strong></p>
</blockquote>
<p>SYN 洪泛攻击发生在传输层的 TCP 协议建立连接的“三次握手”中。</p>
<ol>
<li> 攻击者发送 TCP SYN ，SYN 是TCP 三次握手中的第一个数据包。当服务器返回 ACK 后，该攻击者就不对其再进行确认，那么这个 TCP 就处于挂起状态，也就是所谓的半连接状态。</li>
<li> 服务器收不到确认的话，还会重复发送 ACK 给攻击者，这样会更加浪费服务器的资源。</li>
<li> 攻击者对服务器发送大量的这种 TCP 连接，，由于每一个都无法完成三次握手，所以在服务器上，这些 TCP 会因为挂起状态而消耗 CPU 内存，最终导致服务器宕机。</li>
</ol>
<hr>
<h3 id="TCP连接的释放"><a href="#TCP连接的释放" class="headerlink" title="TCP连接的释放"></a>TCP连接的释放</h3><p>参与 TCP 连接的<strong>两个进程中的任何一个都能终止该连接</strong>，TCP连接的释放过程通常称为“四次挥手”。</p>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20180714120426323" alt="img"></p>
<blockquote>
<p>  <strong>step1：</strong></p>
</blockquote>
<ul>
<li>  客户机如果打算关闭连接，就向服务器 TCP 发送一个释放连接报文段，并停止再发送数据，主动关闭 TCP 连接。</li>
<li>  该报文段的 <strong>FIN=1</strong>，序列号 <strong>seq=u</strong>（它等于前面已经传送过的数据的最后一个字节的序号+1）。FIN 报文段即使不携带数据，也要消耗掉一个序列号。</li>
<li>  这个 FIN 报文段是客户机发送给服务器的倒数第二个报文段。</li>
</ul>
<blockquote>
<p>  <strong>step2：</strong></p>
</blockquote>
<ul>
<li>  服务器收到连接释放报文段后发出确认。确认号是 <strong>ack=u+1</strong>，而这个报文段自己的序列号 <strong>seq=v</strong>（即前面已经传送过的数据的最后一个字节的序列号+1）。</li>
<li>  此时，从客户端向服务器端已经不能发送含有数据的报文段了，但是还有最后一个不含数据的确认消息报文段还是要发送的。</li>
<li>  但是服务器如果还有数据的话，客户端仍要接收。但是此时服务器发送的含有数据部分的报文段，客户机不再对其响应，直到遇到 FIN 报文段。</li>
</ul>
<blockquote>
<p>  <strong>step3：</strong></p>
</blockquote>
<ul>
<li>  若服务器已经没有要向客户机发送的数据，就发送 FIN 报文段通知 TCP 释放连接，发出 <strong>FIN=1</strong> 的连接释放报文段。</li>
</ul>
<blockquote>
<p>  <strong>step4：</strong></p>
</blockquote>
<ul>
<li>  客户机收到连接释放报文段后，向服务器发出确认报文段。</li>
<li>  这个确认报文段是客户机发送给服务器的最后一个报文段。</li>
<li>  在确认报文段中，确认位 ACK=1，确认号 ack=w+1，序列号 seq=u+1。</li>
<li>  此时 TCP 连接还尚未释放掉，必须经过时间等待计时器设置的时间 2MSL 后，才会真正地断开 TCP 连接。</li>
</ul>
<hr>
<h1 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h1><blockquote>
<p>会话层利用传输层提供的端到端的服务，并对该服务进行增强。</p>
</blockquote>
<h1 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h1><blockquote>
<p><code>表示层</code>主要用于处理2个系统中交换信息的表示方式。</p>
</blockquote>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><blockquote>
<p>面向用户，是用户与计算机网络的界面</p>
</blockquote>
<h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><ul>
<li>  <strong>C/S</strong>：一台服务器（集群），多台用户机</li>
<li>  <strong>P2P</strong>：每台计算机，既可以是服务器，也可以是用户</li>
</ul>
<blockquote>
<p>  <strong>P2P模型</strong></p>
</blockquote>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101819591.png" alt="image-20210820101819591" style="zoom:50%;">



<blockquote>
</blockquote>
<h2 id="DNS-系统"><a href="#DNS-系统" class="headerlink" title="DNS 系统"></a>DNS 系统</h2><blockquote>
<p>  DNS（Domain Name System）；域名系统</p>
</blockquote>
<ul>
<li>  作用：将域名映射为 IP 地址</li>
<li>  架构：C/S</li>
<li>  底层协议：UDP</li>
<li>  使用端口号：53</li>
</ul>
<h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101741899.png" alt="image-20210820101741899" style="zoom:50%;">



<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><ul>
<li>  域名服务器是一个联机的的分布式数据库系统。也就是说分布式数据库中保存了所有域名到 IP 地址的映射，如果能在这个分布式数据库找到域名对应的 IP 地址，在联网的情况下就可以进行访问，如果找不到，就会访问失败。</li>
</ul>
<blockquote>
<p>  <strong>本地域名服务器</strong></p>
</blockquote>
<ul>
<li>  本地域名服务器就是一台运行着的计算机，当一台主机发出 DNS 解析请求时，这个请求首先会发送给该主机的本地域名服务器，在本地域名服务器中找不到时才会继续发送给根域名服务器。</li>
<li>  本地域名服务器中保存了根域名服务器的 IP 地址。</li>
<li>  本地域名服务器可以在 Windows 的系统配置中手动填写，也可以由计算机根据当前连接自动获取。</li>
</ul>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820104859100.png" alt="image-20210820104859100" style="zoom: 67%;">



<blockquote>
<p>  <strong>根域名服务器</strong></p>
</blockquote>
<ul>
<li>  根域名服务器用来管辖顶级域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的 IP 地址。</li>
<li>  当在本地域名服务器中找不到客户计算机发送的域名解析请求时，首先会求助于根域名服务器。</li>
<li>  因特网上有 13 个根域名服务器（每个都以集群的形式存在）。</li>
</ul>
<blockquote>
<p>  <strong>顶级域名服务器</strong></p>
</blockquote>
<ul>
<li>  顶级域名服务器用来管理在该顶级域名服务器下注册的所有二级域名。如 <code>.com</code> 下的所有二级域名。</li>
<li>当收到 DNS 解析请求时，给出相应的回答：<ul>
<li>  可能是最后的结果；如 <code>baidu.com</code></li>
<li>  也可能是下一步要查找的服务器的 IP 地址。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>权限域名服务器</strong></p>
</blockquote>
<ul>
<li>  即管理二级、三级、四级域名的服务器</li>
</ul>
<hr>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><blockquote>
<p>  <strong>域名解析包括：</strong></p>
</blockquote>
<ul>
<li>  反向解析：将 IP 地址映射成域名；</li>
<li>  正向解析：将域名映射成 IP 地址。</li>
</ul>
<blockquote>
<p>  <strong>域名解析有两种方式：</strong></p>
</blockquote>
<ul>
<li>  递归查询</li>
<li>  递归 + 迭代（结合）：常用</li>
</ul>
<blockquote>
<p>  <strong>纯递归查询的缺点</strong>：</p>
</blockquote>
<p>对根域名服务器造成的负载过大。显然本地域名服务器的数量远大于根域名服务器的数量，当有大量的本地域名服务器向根域名服务器发送了大量域名解析请求后，由于全世界范围内根域名服务器只有 13 个集群，很有可能承担不了如此大的流量冲击。</p>
<blockquote>
<p>  <strong>递归+迭代的域名解析流程</strong></p>
</blockquote>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820102550685.png" alt="image-20210820102550685"></p>
<ol>
<li> 主机向本地域名服务器的查询采用的是递归。即主机发出要解析的域名给本地域名服务器，本地域名解析完后后再交付给主机。中间的其它过程主机不管。</li>
<li> 本地域名服务器向根域名服务器 / 顶级域名服务器 / 权限域名服务器 的查询采用的是迭代查询。即本地域名服务器先向根域名服务器查询域名的映射，若没找到的话，根域名服务器会返回一个顶级域名服务器的地址，本地域名服务器就会再向顶级域名服务器发送 DNS 解析请求。</li>
<li> 以此类推。</li>
</ol>
<h3 id="DNS域名解析流程小结"><a href="#DNS域名解析流程小结" class="headerlink" title="DNS域名解析流程小结"></a>DNS域名解析流程小结</h3><p>假设某客户机通过浏览器请求访问 <code>map.baidu.com</code>，域名解析的过程如下： </p>
<ol>
<li> 首先，客户机会在本机的 <strong>host</strong> 文件中查找是否存在  <code>map.baidu.com</code> 映射的 IP 地址。（当然一般情况下是没有的，本机的 <code>host</code> 文件默认只保存了 <strong>localhost</strong> 的 IP 映射，当然也可以自己添加其它的）</li>
<li> 如果本机找不到域名的映射，就会发送 DNS 请求报文到本地域名服务器。</li>
<li> 本地域名服务器收到请求后，查询本地缓存中是否存在域名映射的 IP 地址，若没有，则以 DNS 客户的身份向根域名服务器发出解析请求；</li>
<li> 根域名服务器收到请求后，判断该域名属于 <code>.com</code> 域，将对应的顶级域名服务器 <code>dns.com</code> 的 IP 地址返回给本地域名服务器；</li>
<li> 本地域名服务器向顶级域名服务器 <code>dns.com</code> 发出域名解析请求；</li>
<li> 顶级域名服务器 <code>dns.com</code> 收到请求后，判断该域名属于 <code>baidu.com</code> 域，故将对应的授权域名服务器 <code>dns.baidu.com</code> 的 IP 地址返回给本地域名服务器。</li>
<li> 本地域名服务器向授权域名服务器 <code>dns.baidu.com</code> 发出域名解析请求；</li>
<li> 授权域名服务器 <code>dns.baidu.com</code> 收到请求后，将查询结果 <code>map.baidu.com</code> 的 IP 地址返回给本地域名服务器；</li>
<li> 本地域名服务器将查询结果保存到本地缓存，同时返回给客户机。</li>
</ol>
<p>为提高 DNS 的查询效率，在域名服务器中广泛地使用了告诉缓存。不仅仅是本地域名服务器、包括权限域名服务器、顶级域名服务器等都使用了高速缓存。减少了因特网上 DNS 查询报文的数量。</p>
<hr>
<blockquote>
<p>  TCP连接释放</p>
</blockquote>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820102127185.png" alt="image-20210820102127185"></p>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820102054682.png" alt="image-20210820102054682"></p>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101950283.png" alt="image-20210820101950283"></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101643523.png" alt="image-20210820101643523"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/28/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/28/Linux/" class="post-title-link" itemprop="url">Linux</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-28 11:46:51" itemprop="dateCreated datePublished" datetime="2020-10-28T11:46:51+08:00">2020-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-06 17:54:11" itemprop="dateModified" datetime="2022-06-06T17:54:11+08:00">2022-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<ol>
<li>Linux的远程访问原理</li>
<li>Linux目录结构</li>
<li>Linux命令-文件列表-目录切换-目录的创建和删除</li>
<li>Linux命令-文件查看-文件拷贝,删除</li>
<li>Linux命令-压缩解压缩-文件查找</li>
<li>Linux命令-vim编辑器</li>
<li>Linux命令-定向输出-管道</li>
<li>Linux命令-权限控制</li>
<li>Linux命令-IP修改-域名映射</li>
</ol>
</blockquote>
<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h2><ul>
<li>  内核版本</li>
<li>  发行版本</li>
</ul>
<blockquote>
<p>  什么是 Linux 的“发行版”？</p>
</blockquote>
<p>因为 Linux 是开源（开放源代码）的，因此很多厂商都会根据自己的需求对 Linux 系统进行定制化开发，基于此衍生出了多种 Linux 系统的发行版。</p>
<blockquote>
<p>  目前国内主流的 Linux 发行版系统有哪些？</p>
</blockquote>
<ul>
<li>  RedHat</li>
<li>  Fedora</li>
<li>  CentOS</li>
<li>  Debian</li>
<li>  Ubuntu</li>
</ul>
<h2 id="终端的使用"><a href="#终端的使用" class="headerlink" title="终端的使用"></a>终端的使用</h2><ul>
<li>终端<ul>
<li>  图形终端</li>
<li>  命令行终端</li>
<li>  远程终端（SSH、VNC）</li>
</ul>
</li>
</ul>
<h1 id="Linux的远程访问"><a href="#Linux的远程访问" class="headerlink" title="Linux的远程访问"></a>Linux的远程访问</h1><p><img src="/2020/10/28/Linux/Linux%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE.png"></p>
<ol>
<li>Linux 服务器放在机房，可以被很多人访问。</li>
<li>这些访问大都不是直接访问，而是在个人 PC 上进行远程访问</li>
<li>CRT就是一款用于在个人PC上访问Linux服务器的软件。</li>
<li>在PC端使用CRT命令窗口来操作远程Linux服务器。</li>
</ol>
<h2 id="1-1-CRT初始化界面"><a href="#1-1-CRT初始化界面" class="headerlink" title="1.1    CRT初始化界面"></a>1.1    CRT初始化界面</h2><p><img src="/2020/10/28/Linux/image-20200812232446845.png" alt="image-20200812232446845"></p>
<ol>
<li><code>root</code>表示：以超级管理员身份登录并进行操作。</li>
<li><code>lnd</code>表示：当前登录的主机名称是<code>lnd</code>。</li>
<li><code>~</code>表示：家目录。<ul>
<li>如果是以root管理员身份登录的，那么<code>~</code>就表示<code>/root</code>目录。</li>
<li>如果是以普通用户的身份登录的，那么<code>~</code>就表示<code>/home</code>目录。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="文件和目录结构"><a href="#文件和目录结构" class="headerlink" title="文件和目录结构"></a>文件和目录结构</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/11/20/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/">超链接</a></p>
<hr>
<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p><a href>超链接</a></p>
<hr>
<h1 id="网络配置和系统管理操作"><a href="#网络配置和系统管理操作" class="headerlink" title="网络配置和系统管理操作"></a>网络配置和系统管理操作</h1><p><a href>超链接</a></p>
<hr>
<h1 id="Vi-amp-Vim-编辑器"><a href="#Vi-amp-Vim-编辑器" class="headerlink" title="Vi &amp; Vim 编辑器"></a>Vi &amp; Vim 编辑器</h1><p><a href>超链接</a></p>
<hr>
<h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><p><a href>超链接</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/14/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/14/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">MyBatis面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-10-14 21:51:25 / Modified: 21:53:36" itemprop="dateCreated datePublished" datetime="2020-10-14T21:51:25+08:00">2020-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p><strong><code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>的区别是什么？</strong></p>
<p><code>#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符串替换。</p>
<ul>
<li>Mybatis 在处理<code>#&#123;&#125;</code>时，会将sql中的<code>#&#123;&#125;</code>替换为<code>?</code>号，调用<code>PreparedStatement</code> 的<code>set()</code>方法来赋值；</li>
<li>Mybatis 在处理<code>$&#123;&#125;</code>时，就是直接把<code>$&#123;&#125;</code>替换成变量的值，也就是说有可能在这一步进行SQL注入。</li>
<li>使用<code>#&#123;&#125;</code>可以有效的防止SQL 注入，提高系统安全性。</li>
</ul>
</li>
<li><p><strong>通常一个Xml 映射文件，都会写一个Dao 接口与之对应，请问，这个Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</strong></p>
<p>​    Dao接口的全限定类名，就是映射文件中<code>MappedStatement</code>的<code>namespace</code>的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的<code>id</code>值，接口方法内的参数，就是传递给sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，<code>接口全限名+方法名</code>拼接字符串作为key 值，可唯一定位一个<code>MappedStatement</code>。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到<code>namespace </code>为<code>com.mybatis3.mappers.StudentDao</code> 下面<code>id = findStudentById</code> 的<code>MappedStatement</code>。在Mybatis 中，每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。<br>​    <em>Dao 接口里的方法，是不能重载的，因为每一个<code>全限名+方法名</code>的拼接字符串需要映射一个唯一的<code>MappedStatement</code>。</em><br>​    Dao 接口的工作原理是JDK 动态代理，Mybatis 运行时会使用JDK 动态代理为Dao接口生成代理proxy 对象， 代理对象proxy 会拦截接口方法， 转而执行MappedStatement 所代表的sql，然后将sql 执行结果返回。</p>
</li>
<li><p><strong>Mybatis 是如何进行分页的？分页插件的原理是什么？</strong></p>
<p>​    Mybatis 使用<code>RowBounds</code> 对象进行分页，它是针对<code>ResultSet</code> 结果集执行的内存分页，而非物理分页，可以在sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。分页插件的基本原理是使用Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect 方言，添加对应的物理分<br>页语句和物理分页参数。</p>
</li>
<li><p><strong>Mybatis 是如何将sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</strong></p>
<ul>
<li><p>在Java中完成：</p>
<ol>
<li>使用<code>&lt;resultType&gt;</code>标签，前提是JavaBean类中的属性和数据库中表的列名一致。</li>
<li>使用<code>&lt;resultMap&gt;</code>标签，逐一定义数据库中表的列名和JavaBean类中的属性名之间的映射关系。</li>
</ol>
</li>
<li><p>在数据库中完成：</p>
<p>​    使用SQL的别名功能，将列名的别名改为为JavaBean对象的属性名，比如在数据库中设置<code>T_NAME AS NAME</code>，JavaBean对象属性名一般是<code>name</code>，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名。</p>
</li>
</ul>
<p>​    有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
</li>
<li><p><strong>Xml 映射文件中，除了常见的<code>select|insert|update|delete</code>标签之外，还有哪些标签？</strong></p>
<p>​    还有很多其他的标签， 加上动态sql 的9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等。</p>
</li>
<li><p><strong>简述Mybatis 的插件运行原理，以及如何编写一个插件？</strong></p>
<p>​    Mybatis 仅可以编写针对<code>ParameterHandler 、ResultSetHandler 、StatementHandler、Executor</code> 这4 种接口的插件，Mybatis 使用JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4 种接口对象<br>的方法时，就会进入拦截方法，具体就是<code>InvocationHandler</code> 的<code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis 的<code>Interceptor接口</code>并复写<code>intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</p>
</li>
<li><p><strong>一级、二级缓存</strong></p>
<ul>
<li>一级缓存: 基于PerpetualCache 的HashMap 本地缓存， 其存储作用域为Session，当Session flush 或close 之后，该Session 中的所有Cache 就将清空。</li>
<li>二级缓存与一级缓存其机制相同，默认也是采用<code>PerpetualCache</code>，HashMap 存储， 不同在于其存储作用域为Mapper(Namespace)， 并且可自定义存储源， 如Ehcache。要开启二级缓存，你需要在你的SQL 映射文件中添加一行：<code>&lt;cache/&gt;</code>。</li>
<li>对于缓存数据更新机制， 当某一个作用域( 一级缓存Session/ 二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有select 中的缓存将被clear。</li>
</ul>
</li>
<li><p><strong>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</strong></p>
<p>​    Mybatis 仅支持<code>association</code>关联对象和<code>collection</code>关联集合对象的延迟加载，<code>association</code> 指的就是一对一，<code>collection</code> 指的就是一对多查询。在Mybatis 配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true|false</code>。<br>​    它的原理是，使用CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B 对象的sql，把B 查询上来，然后调<br>用a.setB(b)，于是a 的对象b 属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
</li>
<li><p><strong>Mybatis 映射文件中，如果A 标签通过<code>include</code>引用了B 标签的内容，请问，B 标签能否定义在A 标签的后面，还是说必须定义在A 标签的前面？</strong></p>
<p>​    虽然Mybatis 解析Xml 映射文件是按照顺序解析的，但是，被引用的B 标签依然<strong>可以定义在任何地方</strong>，Mybatis 都可以正确识别。<br>​    原理是，Mybatis 解析A 标签，发现A 标签引用了B 标签，但是B 标签尚未解析到，尚不存在，此时，Mybatis 会将A 标签标记为未解析状态，然后继续解析余下的标签（包含B 标签），待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
</li>
<li><p><strong>简述Mybatis 的Xml 映射文件和Mybatis 内部数据结构之间的映射关系？</strong></p>
<p>​    Mybatis 将所有Xml 配置信息都封装到All-In-One 重量级对象Configuration 内部。在Xml 映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为ParameterMap 对象，其每个子元素会被解析为ParameterMapping 对象。<code>&lt;resultMap&gt;</code>标签会被解析<code>ResultMap</code> 对象，其每个子元素会被解析为ResultMapping 对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为MappedStatement 对象，标签内的sql 会被解析为BoundSql 对象。</p>
</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/13/IO%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">IO流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-13 09:45:28" itemprop="dateCreated datePublished" datetime="2020-10-13T09:45:28+08:00">2020-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-22 13:12:27" itemprop="dateModified" datetime="2022-06-22T13:12:27+08:00">2022-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1 是什么"></a>1 是什么</h2><ul>
<li><code>java.io.File</code></li>
<li><strong>File 类的每个实例对象，代表一个文件或一个目录。</strong></li>
<li>File 类中涉及到的关于文件或目录的创建、删除、重命名、修改时间、文件大小等方法，<strong>并未涉及到写入或读取文件内容的操作</strong>。如果需要读取或写入文件内容，必须使用IO流来完成。【总之就是文件和文件夹的除了读写之外的其它相关方法】</li>
<li>File 类的对象常会作为参数传递到流的构造器中，指明读取或写入的”目的地”。</li>
<li>我们能利用 File 类实现的操作跟我们平时使用可视化界面操作文件/文件夹的操作大致上是相同的，只不过是使用代码实现而已。所以可以理解为：<strong>File 类就是利用代码操作文件/文件夹</strong>。</li>
</ul>
<blockquote>
<p>  <strong>类结构</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span> </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Comparable&lt;File&gt;	<span class="comment">// 可序列化；可比较</span></span><br></pre></td></tr></table></figure>





<h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2 构造方法"></a>2 构造方法</h2><blockquote>
<p>  <strong>常用构造方法</strong></p>
</blockquote>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507091527611-1627738403443.png" alt="image-20210507091527611"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>File(File parent, String child)</code></td>
<td align="left">根据 parent 抽象路径名和 child 路径名字符串创建一个新 <code>File</code> 实例。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>File(String parent, String child)</code></td>
<td align="left">根据 parent 路径名字符串和 child 路径名字符串创建一个新 <code>File</code> 实例</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>File(String pathname)</code></td>
<td align="left">通过将给定路径名字符串转换为抽象路径名来创建一个新 <code>File</code> 实例。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>File(URL uri)</code></td>
<td align="left">通过将给定的 <code>file: URI</code> 转换为一个抽象路径名来创建一个新的 <code>File</code> 实例</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname2</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, child);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>File 类没有无参构造方法(因为有重载的构造方法，JVM 就不再提供无参构造器了)。也就是说<strong>创建 File 实例必须指定文件/目录要保存的位置</strong>。</li>
<li>File 实例可以是一个文件或一个目录。</li>
<li><strong>创建File实例并不等价于创建了文件/目录。</strong> 创建 File 实例只是在内存中开辟了一块空间保存这个实例对象，并不会在硬盘上创建一个真实的文件或文件夹，只有进一步调用这个实例对象的 <code>mkdir()</code>、<code>mkdirs()</code> 或 <code>createNewFile()</code> 方法时才会在硬盘上创建出真正的文件/目录。</li>
</ul>
<blockquote>
<p>  <strong>路径：</strong></p>
</blockquote>
<ul>
<li>  相对路径：相较于某个路径下的路径。</li>
<li>  绝对路径：包含盘符在内的文件或文件目录的路径。</li>
</ul>
<p><strong>说明：</strong></p>
<p>在 IDEA中：</p>
<ul>
<li>  如果使用 JUnit 中的单元测试方法测试，相对路径即为当前 Module 下。</li>
<li>  如果使用 main() 测试，相对路径即为当前的Project下。</li>
</ul>
<p><strong>路径分隔符：</strong></p>
<ul>
<li>  Windows 和 DOS 系统默认使用 <code>\</code> 来表示；</li>
<li>  UNIX 和 URL 使用 <code>/</code> 来表示。</li>
</ul>
<h2 id="3-常用成员方法"><a href="#3-常用成员方法" class="headerlink" title="3 常用成员方法"></a>3 常用成员方法</h2><blockquote>
<p>  <strong>获取功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>getAbsolutePath()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取绝对路径</td>
</tr>
<tr>
<td align="left"><code>getPath()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取路径（获取的路径与创建File对象时传入的路径一致，即创建时传入相对路径此时就获取相对路径）</td>
</tr>
<tr>
<td align="left"><code>getName()</code></td>
<td align="left"><code>String</code></td>
<td align="left">返回此文件或目录名称</td>
</tr>
<tr>
<td align="left"><code>length()</code></td>
<td align="left"><code>long</code></td>
<td align="left">获取文件的长度(字节)；<strong>不能获取目录的长度</strong></td>
</tr>
<tr>
<td align="left"><code>getParent()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取上层目录，若无则返回null。</td>
</tr>
<tr>
<td align="left"><code>lastModified()</code></td>
<td align="left"><code>long</code></td>
<td align="left">获取最后一次修改时间（毫秒值）</td>
</tr>
<tr>
<td align="left"><strong>目录的遍历</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>list()</code></td>
<td align="left"><code>String[]</code></td>
<td align="left">获取指定目录下的所有文件或目录的<strong>名称数组</strong></td>
</tr>
<tr>
<td align="left"><code>listFiles()</code></td>
<td align="left"><code>File[]</code></td>
<td align="left">获取指定目录下的所有文件或目录的<strong>File数组</strong></td>
</tr>
</tbody></table>
<ul>
<li>调用<code>list</code>或<code>listFiles</code>方法遍历File对象，此时File对象必须是<strong>目录</strong>，且<strong>真实存在</strong>，否则会返回空指针异常，无法进行遍历。</li>
</ul>
<blockquote>
<p>  <strong>判断功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exists()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否存在</td>
</tr>
<tr>
<td align="center"><code>isDirectory()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否为目录。</td>
</tr>
<tr>
<td align="center"><code>isFile()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否为文件</td>
</tr>
<tr>
<td align="center"><code>canRead()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否可读</td>
</tr>
<tr>
<td align="center"><code>canWrite</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否可写</td>
</tr>
<tr>
<td align="center"><code>isHidden</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否隐藏</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>创建功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>createNewFile()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">当文件不存在时创建<strong>文件</strong>。</td>
</tr>
<tr>
<td align="center"><code>mkdir()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">创建<strong>目录</strong>。如果目录存在，不创建；如果上层目录不存在也不创建。</td>
</tr>
<tr>
<td align="center"><code>mkdirs()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">创建目录，包括任何必需但不存在的父目录。</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>注意</strong>：如果你创建的目录或文件没有写盘符路径，那么默认在项目路径下。</li>
</ul>
<blockquote>
<p><strong>mkdir()</strong> 、<strong>mkdirs()</strong> 和 <strong>createNewFile()</strong> 的区别</p>
</blockquote>
<ul>
<li><code>mkdir() / mkdirs()</code> 方法用于创建目录，<code>createNewFile()</code> 方法用于创建文件。</li>
<li>也就是说，在使用<code>mkdir() / mkdirs()</code> 方法时，即使开发人员指定名称为 <code>aaa.txt</code> ，它也不会创建出一个 <code>aaa.txt</code> 文件，而只是会创建出一个名为 <code>aaa.txt</code> 的目录。</li>
<li><code>mkdirs()</code> 方法可用于一次性创建多级目录，而 <code>mkdir()</code> 方法每次只能创建单层目录。</li>
<li>比如，要求的创建一个文件，这个文件保存在一个多层目录下，且这个多层目录中间的部分目录不存在，则创建文件和目录的方法都不会执行成功。不同的是 <strong><code>mkdir()</code> 方法即使执行不成功也不会报错，而 <code>createNewFile()</code> 方法会直接报错</strong>。报错信息如下：</li>
</ul>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507094900445.png"></p>
<blockquote>
<p>  <strong>删除功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>delete()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">删除文件或目录。删除时目录必须为空才能被删除</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>注意：</strong>Java 中的删除不走回收站。</li>
</ul>
<blockquote>
<p>  <strong>重命名功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>renameTo(File dest)</code></td>
<td align="center"><code>boolea</code></td>
<td align="center">文件重命名</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4 代码演示"></a>4 代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*  构造方法1   */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA&quot;</span>);</span><br><span class="line">        <span class="comment">/*  构造方法2   */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file01, <span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        <span class="comment">/*  构造方法3   */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多级目录</span></span><br><span class="line">        file02.mkdirs();</span><br><span class="line">        <span class="comment">// 创建文件（创建文件前必须先创建好文件保存的目录）</span></span><br><span class="line">        file03.createNewFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  1、获取 文件/目录 的绝对路径 */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">absoluteFile</span> <span class="operator">=</span> file03.getAbsoluteFile();</span><br><span class="line">        System.out.println(absoluteFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2、获取 文件/目录 的路径</span></span><br><span class="line"><span class="comment">        （如果创建File对象时使用的是相对路径就得到相对路径，使用的是的绝对路径就得到绝对路径） */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> file03.getPath();</span><br><span class="line">        System.out.println(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  3、获取 文件名/目录名    */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file03.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  4、获取 文件/目录 的字节长度（目录的长度为0）*/</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> file03.length();</span><br><span class="line">        System.out.println(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  5、返回该file对象目录中的所有子文件或目录的 String[] 格式 */</span></span><br><span class="line">        String[] list = file01.list();</span><br><span class="line">        Arrays.toString(list)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  6、返回该file对象目录中的所有子文件或目录的 File[] 格式  */</span></span><br><span class="line">        File[] listFiles = file01.listFiles();</span><br><span class="line">        System.out.println(listFiles);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  返回结果：</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *      G:\AAA\BBB\1.txt</span></span><br><span class="line"><span class="comment">     *      G:\AAA\BBB\1.txt</span></span><br><span class="line"><span class="comment">     *      1.txt</span></span><br><span class="line"><span class="comment">     *      0</span></span><br><span class="line"><span class="comment">     *      BBB</span></span><br><span class="line"><span class="comment">     *      [Ljava.io.File;@4c3e4790</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Path类（JDK7-）"><a href="#Path类（JDK7-）" class="headerlink" title="Path类（JDK7+）"></a>Path类（JDK7+）</h1><blockquote>
<p><strong>Path 的说明：</strong></p>
</blockquote>
<p>Path 用于替换原来的 File 类。所以说在大多数情况下，Path 和 File 的用法都是非常相似的。</p>
<blockquote>
<p><strong>如何实例化：</strong></p>
</blockquote>
<p>通过 Path 的工具类 Paths 提供的静态 get() 方法来获取 Path 实例对象。[工厂模式]</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static Path get(String first, String... more)</code></td>
<td>将多个字符串连接成文件路径</td>
</tr>
<tr>
<td><code>public static Path get(URI uri)</code></td>
<td>返回uri对应的path路径</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>常用方法：</strong></p>
</blockquote>
<p><img src="file://E:/blog/source/_posts/IO%E7%B3%BB%E7%BB%9F/image-20220622124503038.png?lastModify=1655874635" alt="image-20220622124503038"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean startsWith(String other);</code></td>
<td>判断是否以 other 路径开始</td>
</tr>
<tr>
<td><code>boolean endsWith(Path other);</code></td>
<td>判断是否以 other 路径结束</td>
</tr>
<tr>
<td><code>boolean isAbsolute();</code></td>
<td>判断是否是绝对路径</td>
</tr>
<tr>
<td><code>Path getParent();</code></td>
<td>返回的Path对象包含整个路径，但不包含Path对象指定的文件路径</td>
</tr>
<tr>
<td><code>Path getRoot();</code></td>
<td>返回调用对象的路径</td>
</tr>
<tr>
<td><code>Path getFileName();</code></td>
<td>返回与调用对象关联的文件名</td>
</tr>
<tr>
<td><code>int getNameCount();</code></td>
<td>返回Path根目录后面的元素数量(文件和文件夹的个数)</td>
</tr>
<tr>
<td><code>Path getName(int index);</code></td>
<td>返回指定索引位置index的路径名称</td>
</tr>
<tr>
<td><code>Path toAbsolutePath();</code></td>
<td>返回调用对象的绝对路径。</td>
</tr>
<tr>
<td><code>Path resolve(Path other);</code></td>
<td>合并两个路径，返回合并后的路径对应的Path对象</td>
</tr>
<tr>
<td><code>File toFile();</code></td>
<td>把Path对象转为File对象</td>
</tr>
</tbody></table>
<hr>
<h1 id="Files工具类（JDK7-）"><a href="#Files工具类（JDK7-）" class="headerlink" title="Files工具类（JDK7+）"></a>Files工具类（JDK7+）</h1><blockquote>
<p><strong>作用：</strong></p>
</blockquote>
<ul>
<li>操作文件或文件目录的工具类</li>
</ul>
<blockquote>
<p><strong>常用方法：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Path copy(Path source, Path target, CopyOption... options)</code></td>
<td>文件的复制</td>
</tr>
<tr>
<td><code>Path createDirectory(Path dir, FileAttribute&lt;?&gt;... attrs)</code></td>
<td>创建单级目录</td>
</tr>
<tr>
<td><code>Path createDirectories(Path dir, FileAttribute&lt;?&gt;... attrs)</code></td>
<td>创建多级目录</td>
</tr>
<tr>
<td><code>Path createFile(Path path, FileAttribute&lt;?&gt;... attrs)</code></td>
<td>创建一个文件</td>
</tr>
<tr>
<td><code>void delete(Path path)</code></td>
<td>删除一个文件/目录</td>
</tr>
<tr>
<td><code>deleteIfExists(Path path)</code></td>
<td></td>
</tr>
<tr>
<td><code>Path move(Path source, Path target, CopyOption... options)</code></td>
<td>移动文件/目录</td>
</tr>
<tr>
<td><code>long size(Path path)</code></td>
<td>返回path指定文件的大小</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>用于判断的方法</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean exists(Path path, LinkOption... options)</code></td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td><code>boolean isDirectory(Path path, LinkOption... options)</code></td>
<td>判断是否为目录</td>
</tr>
<tr>
<td><code>boolean isRegularFile(Path path, LinkOption... options)</code></td>
<td>判断是否为文件</td>
</tr>
<tr>
<td><code>boolean isHidden(Path path)</code></td>
<td>判断是否为隐藏文件</td>
</tr>
<tr>
<td><code>boolean isReadable(Path path)</code></td>
<td>判断文件是否可读</td>
</tr>
<tr>
<td><code>boolean isWritable(Path path)</code></td>
<td>判断文件是否可写</td>
</tr>
<tr>
<td><code>boolean notExists(Path path, LinkOption... options)</code></td>
<td>判断文件是否不存在</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>用于操作内容的方法</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SeekableByteChannel newByteChannel(Path path, OpenOption... options)</code></td>
<td>获取与指定文件的Channel通道，options指定打开方式</td>
</tr>
<tr>
<td><code>DirectoryStream&lt;Path&gt; newDirectoryStream(Path dir)</code></td>
<td>打开dir指定的目录</td>
</tr>
<tr>
<td><code>InputStream newInputStream(Path path, OpenOption... options)</code></td>
<td>获取InputStream对象</td>
</tr>
<tr>
<td><code>OutputStream newOutputStream(Path path, OpenOption... options)</code></td>
<td>获取OutputStream对象</td>
</tr>
</tbody></table>
<hr>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1. 是什么？"></a>1. 是什么？</h2><ul>
<li><strong>IO 流就是数据的流动。</strong></li>
<li>我们把数据的传输，看做是一种数据的流动，按照流动的方向，以<strong>内存为基准</strong>，可分为输入流和输出流。即流向内存为输入流，流出内存为输出流。</li>
<li>输入也叫做<strong>读取数据</strong>，输出也叫做<strong>写出数据</strong>。</li>
</ul>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/IO.png" alt="IO"></p>
<h2 id="2-IO的分类"><a href="#2-IO的分类" class="headerlink" title="2. IO的分类"></a>2. IO的分类</h2><ol>
<li> 按数据流向分类：<strong>输入流</strong>、<strong>输出流</strong></li>
<li> 按操作数据的单位分类：<strong>字节流</strong>、<strong>字符流</strong></li>
</ol>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/IO%E5%88%86%E7%B1%BB.png"></p>
<hr>
<h2 id="3-流的体系结构"><a href="#3-流的体系结构" class="headerlink" title="3. 流的体系结构"></a>3. 流的体系结构</h2><blockquote>
<p>  <strong>顶级父类</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center"><code>InputStream</code></td>
<td align="center"><code>OutputStream</code></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center"><code>Reader</code></td>
<td align="center"><code>Writer</code></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>体系结构</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td><strong>抽象基类</strong></td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td><strong>访问文件</strong></td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td><strong>缓冲流</strong></td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td><strong>访问数组</strong></td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td><strong>访问管道</strong></td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td><strong>访问字符串</strong></td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td><strong>转换流</strong></td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td><strong>对象流</strong></td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>打印流</strong></td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td><strong>推回输入流</strong></td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td><strong>特殊流</strong></td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>常用结构</strong></p>
<ul>
<li>顶级父类：<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code></li>
<li>文件流：<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>、<code>FileWriter</code></li>
<li>缓冲流：<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code></li>
<li>转换流：InputStreamReader  OutputStreamWriter</li>
<li>对象流：ObjectInputStream  ObjectOutputStream</li>
</ul>
<hr>
<h2 id="4-输入-输出的标准化过程"><a href="#4-输入-输出的标准化过程" class="headerlink" title="4. 输入/输出的标准化过程"></a>4. 输入/输出的标准化过程</h2><h3 id="输入过程"><a href="#输入过程" class="headerlink" title="输入过程"></a>输入过程</h3><ol>
<li><p> 创建 File 类对象，指明读取的数据的来源（要求此文件一定要存在）；</p>
</li>
<li><p> 创建相应的输入流，将 File 类的对象作为参数，传入流的构造器中</p>
</li>
<li><p> 具体的读入过程；</p>
</li>
<li><p> 关闭流资源。</p>
</li>
</ol>
<p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理。</p>
<h3 id="输出过程"><a href="#输出过程" class="headerlink" title="输出过程"></a>输出过程</h3><ol>
<li><p> 创建 File 类对象，指明写出的数据的位置（不要求此文件一定要存在，如不存在在写出前会自动创建）；</p>
</li>
<li><p> 创建相应的输出流，将 File 类的对象作为参数传入流的构造器中；</p>
</li>
<li><p> 具体的写出过程；</p>
</li>
<li><p> 关闭流资源。</p>
</li>
</ol>
<p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>  <strong>流的关闭原则：</strong></p>
</blockquote>
<ul>
<li>  <strong>先开后关，后开先关。</strong></li>
<li>  <strong>先关闭外层的流，再关闭内层的流。</strong></li>
<li>  说明：关闭外层流的同时，内层流也会自动的进行关闭。</li>
</ul>
<hr>
<h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="1-一切皆为字节流"><a href="#1-一切皆为字节流" class="headerlink" title="1. 一切皆为字节流"></a>1. 一切皆为字节流</h2><ul>
<li>  所有文件（文本、图片、视频等）底层都是以二进制形式保存在计算机中的，可以看做一个个的字节，传输时同样如此。</li>
<li>  所以，字节流可以传输任意文件数据。    </li>
<li>  在操作流时，我们要时刻明确，无论使用什么样的流对象，底层传输的始终是二进制数据。</li>
</ul>
<h2 id="2-OutputStream"><a href="#2-OutputStream" class="headerlink" title="2. OutputStream"></a>2. OutputStream</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul>
<li><code>java.io.OutputStream</code>是<strong>抽象类</strong>，表示所有字节输出流类的超类。</li>
<li> 作用：将指定的字节信息写出到目的地。</li>
<li> 类中声明了所有字节输出流子类要实现的公共方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.io.OutputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	OutputStream  	*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	FileOutputStream	*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><ul>
<li>OutputStream 是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>OutputStream 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="2-3-成员方法"><a href="#2-3-成员方法" class="headerlink" title="2.3 成员方法"></a>2.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507104001127.png" alt="image-20210507104001127"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="left">关闭输出流，释放系统资源。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>flush()</code></td>
<td align="center"><code>void</code></td>
<td align="left">刷新此输出流并强制任何缓冲的输出字节流被写出。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>write(byte[] b)</code></td>
<td align="center"><code>void</code></td>
<td align="left">将字节数组b的内容写出到指定的文件中</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>write(byte[] b, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">将字节数组b中的指定内容写出到指定的文件中</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>write()[abstract]</code></td>
<td align="center"><code>void</code></td>
<td align="left">将该字节输出流写出到目的地。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：当完成流的操作时，必须调用<code>close()</code>方法，释放系统资源。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	源码中的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    write(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">               ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">        write(b[off + i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-InputStream"><a href="#3-InputStream" class="headerlink" title="3. InputStream"></a>3. InputStream</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.io.InputStream</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>java.io.InputStream</code>是抽象类，是所有字节输入流的类的超类。</li>
<li>作用：读取字节信息到内存中。</li>
<li>类中声明了所有字节输入流子类要实现的公共方法。</li>
<li>当完成了流的操作时，必须调用<code>close()</code>方法，释放系统资源。</li>
</ul>
<h3 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h3><ul>
<li>InputStream 是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>InputStream 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="3-3-成员方法"><a href="#3-3-成员方法" class="headerlink" title="3.3 成员方法"></a>3.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507135331635.png" alt="image-20210507135331635"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="left">关闭流，释放相关资源</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>read()[abstract]</code></td>
<td align="center"><code>int</code></td>
<td align="left">从输入流中读取数据的下一个字节</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>read(byte[] b)</code></td>
<td align="center"><code>int</code></td>
<td align="left">从输入流中读取一些字节数，并把它们存储到字节数组b中</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>read(byte b[], int off, int len)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h2 id="1-Reader"><a href="#1-Reader" class="headerlink" title="1. Reader"></a>1. Reader</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Readable</span>, Closeable</span><br></pre></td></tr></table></figure>

<ol>
<li> <code>java.io.Reader</code>是抽象类，是所有字符输入流类的超类。可以读取字符信息到内存中。</li>
<li> 类中定义了所有字符输入流子类要实现的公共方法。</li>
<li> <strong>字符流只能操作文本文件，不能操作图片、视频等非文本文件。</strong></li>
</ol>
<blockquote>
<p>  <strong>字节流操作文本文件可能存在的问题及解决方案：</strong></p>
</blockquote>
<p>当使用字节流读取文本文件时，在遇到中文字符时，可能不会显示完整的字符。因为一个中文字符根据不同的编码规则可能占 2~3 个字节不等，而字节流读取是以单个字节为单位的，会出现一种情况就是：一个中文字符占了 3 个字节，使用字节流读取时会把这 3 个字节分开来展示，这样就会出现乱码。</p>
<p>所以 Java 提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h3 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><ul>
<li>Reader 是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>Reader 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="1-3-成员方法"><a href="#1-3-成员方法" class="headerlink" title="1.3 成员方法"></a>1.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141214703.png" alt="image-20210507141214703"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>read()</code></td>
<td align="center"><code>int</code></td>
<td align="center">从输入流中读取一个<strong>字符</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>read(char[] cbuf)</code></td>
<td align="center"><code>int</code></td>
<td align="center">从输入流中读取一些字符，并将它们存储到字符数组<code>cbuf</code>中。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-Writer"><a href="#2-Writer" class="headerlink" title="2. Writer"></a>2. Writer</h2><h3 id="2-1-概述-1"><a href="#2-1-概述-1" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Writer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable, Flushable</span><br></pre></td></tr></table></figure>

<ol>
<li> <code>java.io.Writer</code>是抽象类，是所有写出字符流类的超类。负责将指定的字符信息写出到目的地。</li>
<li> 类中定义了所有字符输出流子类要实现的公共方法。</li>
</ol>
<h3 id="2-2-构造方法-1"><a href="#2-2-构造方法-1" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><ul>
<li>  Writer 类是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>  Writer 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="2-3-成员方法-1"><a href="#2-3-成员方法-1" class="headerlink" title="2.3 成员方法"></a>2.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141914198.png" alt="image-20210507141914198"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>write(int c)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入单个字符</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>write(char[] cbuf)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符数组</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>write(char[] cbuf, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符数组的某一部分</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>write(String str)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符串</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>write(String str, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符串的某一部分</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><code>flush()</code></td>
<td align="center"><code>void</code></td>
<td align="left">刷新该流的缓冲</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="left">关闭此流，关闭前先刷新一次</td>
</tr>
</tbody></table>
<hr>
<h1 id="文件流-FileStream"><a href="#文件流-FileStream" class="headerlink" title="文件流(FileStream)"></a>文件流(FileStream)</h1><blockquote>
<p><strong>总纲：</strong></p>
<ul>
<li>凡是数据传输，必然涉及到两个端点（一个出发点 <code>src</code>，一个目的地 <code>dest</code>），一个管道（用于传输数据）。</li>
<li>File 是出发点/目的地，流(Stream) 是管道。</li>
</ul>
</blockquote>
<h2 id="1-FileOutputStream"><a href="#1-FileOutputStream" class="headerlink" title="1. FileOutputStream"></a>1. FileOutputStream</h2><h3 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><blockquote>
<p>  <strong>作用：</strong></p>
</blockquote>
<p><code>FileOutputStream</code> 是文件输出流类，用于<strong>将内存中的数据写出到磁盘中的文件上</strong>。</p>
<blockquote>
<p>  <strong>体系结构：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="1-2-构造方法-1"><a href="#1-2-构造方法-1" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507113455730.png" alt="image-20210507113455730"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>FileOutputStream(File file)</code></td>
<td align="left">创建文件输出流对象，并指定写出到哪个文件中。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>FileOutputStream(String name)</code></td>
<td align="left">创建文件输出流对象，并指定写出到哪个文件中。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>FileOutputStream(File file, boolean append)</code></td>
<td align="left">数据是否可追加续写</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>FileOutputStream(String name, boolean append)</code></td>
<td align="left">数据是否可追加续写</td>
</tr>
</tbody></table>
<p><strong>总结：</strong>在创建字节输出流对象 <code>FileOutputStream</code> 时，必须指定该流对象写出数据的目的地（可以是一个 File 对象，也可以是一个 String 类型的路径）。 <strong>在该路径下，如果没有这个文件，会自动创建该文件</strong>。</p>
<hr>
<h3 id="1-3-成员方法-1"><a href="#1-3-成员方法-1" class="headerlink" title="1.3 成员方法"></a>1.3 成员方法</h3><p><strong>作用：</strong>将字节数据写出到磁盘的文件上</p>
<ul>
<li>  根据编码表把待输出的数据转换成字节数据，再使用<code>write()</code>方法写出到指定文件中。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>write(int b)</code></td>
<td align="center"><code>void</code></td>
<td align="left">通过编码表将<code>int</code>类型的数据转换为字节数据<br>并写出到指定文件中，每次写出一个字节数据。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>write(byte[] b)</code></td>
<td align="center"><code>void</code></td>
<td align="left">将整个<code>byte</code>数组中的字节数据写出到指定文件中。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>write(byte[] b, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写出<code>byte</code>数组中指定范围的子数组</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*  1、创建一个 File 对象，当做字节输出流写出数据的目的地  */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        file.createNewFile(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2、创建字节输出流对象，并指定输出的目的地 */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        fos.write(<span class="number">97</span>);	<span class="comment">// 十进制的整型数据会被转换为byte类型数据写出到指定文件中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  3、关闭字节输出流对象 */</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  输出结果为：</li>
</ul>
<img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507134152996.png" alt="image-20210507134152996">



<blockquote>
<p>  <strong>写出换行</strong></p>
</blockquote>
<ul>
<li>Windows 中，换行符号是 <code>/r/n</code>；<ul>
<li>  分析：<code>/r</code> 是回车符，回到一行的开头（<strong>return</strong>）；<code>/n</code> 是换行符，进入下一行（<strong>newline</strong>）</li>
</ul>
</li>
<li>  Unix 中，换行符是 <code>/n</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*  1、创建一个 File 对象，当做字节输出流写出数据的目的地  */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        file.createNewFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2、创建字节输出流对象，并指定输出的目的地 */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        <span class="type">byte</span>[] br = <span class="string">&quot;\r\n&quot;</span>.getBytes();  <span class="comment">// 换行符的byte类型表示</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> aByte : bytes) &#123;</span><br><span class="line">            fos.write(aByte);</span><br><span class="line">            fos.write(br);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  3、关闭字节输出流对象 */</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507134827165.png" alt="image-20210507134827165">







<hr>
<h2 id="2-FileInputStream"><a href="#2-FileInputStream" class="headerlink" title="2. FileInputStream"></a>2. FileInputStream</h2><h3 id="2-1-概述-2"><a href="#2-1-概述-2" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><blockquote>
<p>  <strong>作用：</strong></p>
</blockquote>
<ul>
<li>  FileInputStream 是文件输入流，用于从文件中读取数据写到内存中。</li>
</ul>
<blockquote>
<p>  <strong>体系结构：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-构造方法-2"><a href="#2-2-构造方法-2" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507135646091.png" alt="image-20210507135646091"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>FileInputStream(File file)</code></td>
<td align="left">通过建立与实际文件的连接来创建一个 FileInputStream 对象</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>FileInputStream(String name)</code></td>
<td align="left">通过建立与实际文件的连接来创建一个 FileInputStream 对象</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>  当你<strong>创建 <code>FileInputStream</code> 流对象时，必须传入一个文件路径。</strong></li>
<li>  该路径下，如果没有该文件，会抛出 <code>FileNotFoundException</code> 异常。</li>
</ul>
<h3 id="2-3-成员方法-2"><a href="#2-3-成员方法-2" class="headerlink" title="2.3 成员方法"></a>2.3 成员方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>read()</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次从文件中读取一个字节的数据，并自动提升为<code>int</code>类型，<strong>读取到文件末尾，返回-1</strong></td>
</tr>
<tr>
<td align="left"><code>read(byte[] b)</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次从文件中读取<code>b.length</code>个字节的数据到数组 b 中，并返回读取到的有效字节<strong>个数</strong>，<br><strong>读取到末尾时，返回-1</strong></td>
</tr>
</tbody></table>
<h3 id="2-4-代码演示"><a href="#2-4-代码演示" class="headerlink" title="2.4 代码演示"></a>2.4 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*  1、创建字节输入流对象 */</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2.1、读取文件内容    */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();  <span class="comment">// read() 方法每次只能读取一个字节的数据，读取到文件末尾，返回-1</span></span><br><span class="line">        System.out.println(read);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2.2、读取多个字节数据(一个一个读)    */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (fis.read() != -<span class="number">1</span>)&#123;</span><br><span class="line">            result.add(fis.read());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  3、关闭字节输入流   */</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-练习：图片复制"><a href="#3-练习：图片复制" class="headerlink" title="3. 练习：图片复制"></a>3. 练习：图片复制</h2><blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<ul>
<li>step1：通过 InputStream 流将源图片的字节码数据读到内存中；</li>
<li>setp2：通过 OutputStream 流将内存中的图片数据写到目的文件中。</li>
</ul>
<blockquote>
<p>  <strong>代码实现：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建 File 对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;demo.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;demo_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.建流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);	<span class="comment">// 最后一次读取到的数据长度可能小于5</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="4-FileReader"><a href="#4-FileReader" class="headerlink" title="4. FileReader"></a>4. FileReader</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote>
<p>  <strong>体系结构</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |- java.io.Reader</span><br><span class="line">      |- java.io.InputStreamReader</span><br><span class="line">          |- java.io.FileReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span></span><br></pre></td></tr></table></figure>

<p>创建 FileReader 实例对象时使用系统默认的字符编码和默认字节缓冲区。</p>
<ul>
<li>字符编码：字节与字符的对应规则。Windows 系统的中文编码默认是GBK编码表；IDEA中默认<code>UTF-8</code>。</li>
<li>字节缓冲区：一个字节数组，用来临时存储字节数据。</li>
</ul>
<h3 id="4-2-构造方法"><a href="#4-2-构造方法" class="headerlink" title="4.2 构造方法"></a>4.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141402352.png" alt="image-20210507141402352"></p>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FileReader(File file)</code></td>
</tr>
<tr>
<td align="left"><code>FileReader(String fileName)</code></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>  当你创建一个<code>FileReader</code>流对象时，必须传入一个文件路径。</li>
</ul>
<hr>
<h3 id="4-3-成员方法"><a href="#4-3-成员方法" class="headerlink" title="4.3 成员方法"></a>4.3 成员方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>read()</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次读取<strong>一个字符</strong>的数据，提升为 <code>int</code> 型，读到文件末尾返回-1</td>
</tr>
<tr>
<td align="left"><code>read(char[] cbuf)</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次读取<code>cbuf.length</code>个字符到数组中，返回读取到的字符个数，读取到末尾时返回-1.</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-4-代码演示"><a href="#4-4-代码演示" class="headerlink" title="4.4 代码演示"></a>4.4 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</span></span><br><span class="line"><span class="comment">	2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">	3. 读的文件一定要存在，否则就会报 FileNotFoundException。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.File类的实例化</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.读入的操作</span></span><br><span class="line">        <span class="comment">// read(char[] cbuf)：返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">            <span class="comment">// 错误的写法，最后一次读到的数据可能小于 cbuf.length</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; cbuf.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正确的写法</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                System.out.print(cbuf[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">// 错误的写法,对应着方式一的错误的写法</span></span><br><span class="line"><span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line">            <span class="comment">//正确的写法</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.资源的关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="5-FileWriter"><a href="#5-FileWriter" class="headerlink" title="5. FileWriter"></a>5. FileWriter</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><blockquote>
<p>  <strong>作用</strong></p>
</blockquote>
<p><code>java.io.FileWriter</code> 是从内存中写出字符数据到文件中的类，构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>  <strong>体系结构</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |- java.io.Writer</span><br><span class="line">      |- java.io.OutputStreamWriter  </span><br><span class="line">          |- java.io.FileWriter</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-2-构造方法"><a href="#5-2-构造方法" class="headerlink" title="5.2 构造方法"></a>5.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141942042.png" alt="image-20210507141942042"></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FileWriter(File file)</code></td>
</tr>
<tr>
<td align="left"><code>FileWriter(String fileName)</code></td>
</tr>
<tr>
<td align="left"><code>FileWriter(File file, boolean append)</code></td>
</tr>
<tr>
<td align="left"><code>FileWriter(String fileName, boolean append)</code></td>
</tr>
</tbody></table>
<h3 id="5-3-成员方法"><a href="#5-3-成员方法" class="headerlink" title="5.3 成员方法"></a>5.3 成员方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>写出数据</strong></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>write(int b)</code></td>
<td align="center"></td>
<td align="left">每次写一个字符大小的数据</td>
</tr>
<tr>
<td align="left"><code>write(char[] cbuf)</code></td>
<td align="center"></td>
<td align="left">每次最多可以写出<code>cbuf.length</code>个字符的数据</td>
</tr>
<tr>
<td align="left"><code>write(char[] cbuf, int off, int len)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>write(String str)</code></td>
<td align="center"></td>
<td align="left">底层会先将 String 转换为 char[] 数组，再写出</td>
</tr>
<tr>
<td align="left"><code>write(String str, int off, int len)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>关闭和刷新</strong></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>flush()</code></td>
<td align="center"></td>
<td align="left">将缓冲区中的数据强制刷写到文件中</td>
</tr>
<tr>
<td align="left"><code>close()</code></td>
<td align="center"></td>
<td align="left">先刷新缓冲区，然后通知系统释放资源</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>关闭和刷新</strong></p>
</blockquote>
<p>因为 <strong><code>FileWriter</code>类内置缓冲区</strong>的原因，写出数据时首先会被写出到缓冲区中，如果不进行刷新的话，是无法写入到文件中的。</p>
<ul>
<li><code>flush()</code>：将缓冲区中的数据强制刷写到文件中；</li>
<li><code>close()</code>：先刷新缓冲区，然后通知系统释放资源。</li>
</ul>
<hr>
<h3 id="5-4-代码演示"><a href="#5-4-代码演示" class="headerlink" title="5.4 代码演示"></a>5.4 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从内存中写出数据到硬盘的文件里。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	1. 输出操作，目的地的File可以不存在。并不会报异常</span></span><br><span class="line"><span class="comment">	2. </span></span><br><span class="line"><span class="comment">	File对应的文件如果不存在，FileWriter 在写出数据时，会自动创建此文件。</span></span><br><span class="line"><span class="comment">	File对应的硬盘中的文件如果存在：</span></span><br><span class="line"><span class="comment">		如果输出流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原文件的覆盖</span></span><br><span class="line"><span class="comment">		如果输出流使用的构造器是：FileWriter(file,true):不会对原文件覆盖，而是在原文件基础上追加内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="6-练习：文本文件复制"><a href="#6-练习：文本文件复制" class="headerlink" title="6. 练习：文本文件复制"></a>6. 练习：文本文件复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能使用字符流来处理图片等字节数据</span></span><br><span class="line"><span class="comment">//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span></span><br><span class="line"><span class="comment">//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.数据的读入和写出操作</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 每次写出len个字符</span></span><br><span class="line">            fw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.关闭流资源</span></span><br><span class="line">        <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                if(fw != null)</span></span><br><span class="line"><span class="comment">//                    fw.close();</span></span><br><span class="line"><span class="comment">//            &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;finally&#123;</span></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    if(fr != null)</span></span><br><span class="line"><span class="comment">//                        fr.close();</span></span><br><span class="line"><span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>  对于文本文件(<code>.txt</code>、<code>.java</code>、<code>.c</code>、<code>.cpp</code> 等)，使用字符流处理</li>
<li>  对于非文本文件(<code>.jpg</code> 、<code>.mp3</code>、<code>.mp4</code>、<code>.avi</code>、<code>.doc</code>、<code>.ppt </code>等)，使用字节流处理</li>
</ul>
<hr>
<h1 id="缓冲流-BufferStream"><a href="#缓冲流-BufferStream" class="headerlink" title="缓冲流(BufferStream)"></a>缓冲流(BufferStream)</h1><blockquote>
<p><strong>缓冲流涉及到的类</strong></p>
</blockquote>
<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
<blockquote>
<p><strong>作用</strong></p>
</blockquote>
<ul>
<li>  提高流的读取、写入的速度；</li>
<li>  提高读写速度的<strong>原因</strong>：内部提供了一个缓冲区。默认情况下是 <strong>8kb</strong>。</li>
</ul>
<img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210801152442138.png" alt="image-20210801152442138" style="zoom: 67%;">

<p><strong>Tip：</strong>不光是 BufferedInputStream，包括 BufferedOutputStream、BufferedWriter、BufferedReader 在内的所有缓冲流类的默认缓冲区大小都是 <code>8192 Byte</code>。</p>
<blockquote>
<p><strong>使用 BufferedInputStream 和 BufferedOutputStream 处理非文本文件（字节流）</strong></p>
</blockquote>
<p>需求：实现文件复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.造流</span></span><br><span class="line">        <span class="comment">// 2.1 造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">// 2.2 造缓冲流【缓冲流是对文件流的又一层包装，这里采用了装饰器模式】</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.复制的细节：读取、写入</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">//字节</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.资源关闭</span></span><br><span class="line">        <span class="comment">// 要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span></span><br><span class="line">        <span class="comment">//        fos.close();</span></span><br><span class="line">        <span class="comment">//        fis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用BufferedReader和BufferedWriter 处理文本文件(字符流)</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建文件和相应的流</span></span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读写操作</span></span><br><span class="line">        <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line"><span class="comment">//            char[] cbuf = new char[1024]; //字符</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line"><span class="comment">//    //            bw.flush();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 方法一：</span></span><br><span class="line"><span class="comment">//                bw.write(data + &quot;\n&quot;); // data中不包含换行符</span></span><br><span class="line">            <span class="comment">// 方法二：</span></span><br><span class="line">            bw.write(data);		<span class="comment">// data中不包含换行符</span></span><br><span class="line">            bw.newLine();	<span class="comment">// 提供换行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="转换流-TransferStream"><a href="#转换流-TransferStream" class="headerlink" title="转换流(TransferStream)"></a>转换流(TransferStream)</h1><p>转换流的作用就是提供<strong>字节流与字符流之间的转换功能</strong>。</p>
<blockquote>
<p><strong>转换流涉及到的类：</strong></p>
</blockquote>
<ul>
<li>  OutputStreamWriter</li>
<li>  InputStreamReader</li>
</ul>
<p><strong>这两个转换流都属于字符流！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> </span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>InputStreamReader：</strong></p>
</blockquote>
<ul>
<li>  顾名思义，就是 InputStream To Reader；</li>
<li>  <strong>作用：</strong>将一个字节的输入流转换为字符的输入流</li>
<li>  <strong>解码：</strong><code>字节、字节数组 ---&gt; 字符数组、字符串</code></li>
<li>  字节流是我们不能识别的，字符流是我们很容易识别的。将不认识的转为认识的叫<strong>解码</strong>，将认识的转为不认识的叫<strong>编码</strong>。</li>
</ul>
<blockquote>
<p>  <strong>OutputStreamWriter：</strong></p>
</blockquote>
<ul>
<li>  <strong>作用：</strong>是从字符流到字节流的桥梁，作用是将一个字符的输出流转换为字节的输出流</li>
<li>  <strong>编码：</strong><code>字符数组、字符串 ---&gt; 字节、字节数组</code></li>
</ul>
<blockquote>
<p>  <strong>作用：</strong></p>
</blockquote>
<p>提供字节流与字符流之间的转换。</p>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210801154712518.png" alt="image-20210801154712518"></p>
<blockquote>
<p>  <strong>说明：</strong></p>
</blockquote>
<ul>
<li>  编码方式决定了解码的方式。</li>
<li>  文件编码的方式（比如：GBK），决定了解析时使用的字符集（也只能是GBK）。</li>
</ul>
<blockquote>
<p>  <strong>Demo1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取到内存中的 fis 保存了字节流数据</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用系统默认的字符集（GBK）解码</span></span><br><span class="line"><span class="comment">//        InputStreamReader isr = new InputStreamReader(fis);	</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);	<span class="comment">// 使用指定字符集解码</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        System.out.print(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Demo2</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1.造文件、造流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.读写过程</span></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.关闭资源</span></span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="对象流-ObjectStream"><a href="#对象流-ObjectStream" class="headerlink" title="对象流(ObjectStream)"></a>对象流(ObjectStream)</h1><blockquote>
<p><strong>对象流涉及的类</strong></p>
</blockquote>
<ul>
<li>ObjectInputStream<ul>
<li>  <strong>序列化：</strong>内存中的 Java 对象 <code>--&gt;</code> 磁盘上的文件 / 通过网络传输出去</li>
</ul>
</li>
<li>ObjectOutputStream<ul>
<li>  <strong>反序列化：</strong>磁盘上的文件/通过网络接收的文件 <code>--&gt;</code> 内存中的对象</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>对象的序列化/反序列化机制</strong></p>
</blockquote>
<ul>
<li>  对象序列化机制允许把内存中的 Java 对象转换成平台无关的二进制流，从而把这种二进制流持久地保存在磁盘（文件）上，或通过网络将这种二进制流传输到另一个网络节点。</li>
<li>  当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。【反序列化】</li>
</ul>
<blockquote>
<p><strong>实现序列化的对象需要满足的条件</strong></p>
</blockquote>
<ul>
<li>需要实现接口 Serializable；</li>
<li>当前类提供一个全局常量：serialVersionUID；</li>
<li><strong>除了当前类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。</strong><ul>
<li>默认情况下，基本数据类型都是可序列化的。</li>
<li>如果属性中包含了另外的类，则要求也必须是可序列化的。</li>
</ul>
</li>
</ul>
<p><strong>补充：</strong><code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> <strong>不能序列化 static 和 transient 修饰的成员变量</strong>。</p>
<blockquote>
<p>  <strong>序列化代码实现：</strong></p>
<ul>
<li>将内存中的 Java 对象保存到磁盘中或通过网络传输出去。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出 String 对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出自定义对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王路飞&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;黄猿&quot;</span>, <span class="number">48</span>, <span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>反序列化代码实现：</strong></p>
<ul>
<li>将磁盘文件中的对象还原为内存中的一个Java对象</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="随机存取文件流-RandomAccessFile"><a href="#随机存取文件流-RandomAccessFile" class="headerlink" title="随机存取文件流(RandomAccessFile)"></a>随机存取文件流(RandomAccessFile)</h1><blockquote>
<p>  <strong>随机存取文件流：RandomAccessFile</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFile</span> <span class="keyword">implements</span> <span class="title class_">DataOutput</span>, DataInput, Closeable &#123;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>使用说明：</strong></p>
</blockquote>
<ul>
<li><code>RandomAccessFile</code> 直接继承于 <code>java.lang.Object</code> 类，实现了 <code>DataInput</code> 和 <code>DataOutput</code> 接口；</li>
<li><code>RandomAccessFile</code> <strong>既可以作为一个输入流，又可以作为一个输出流</strong>；<ul>
<li>所以，在大多数情况下，RandomAccessFile 和 InputStream/OutputStream 的用法是类似的。</li>
</ul>
</li>
<li><code>RandomAccessFile</code> 作为输出流时，如果写出到的文件不存在，则在执行过程中自动创建。</li>
<li>如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</li>
<li>可以通过相关的操作，使用 <code>RandomAccessFile</code> 的 API 实现 “<strong>插入</strong>”数据的效果。<code>seek(int pos)</code></li>
</ul>
<blockquote>
<p>  <strong>Demo1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;	</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         </span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf2.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Demo2：使用RandomAccessFile实现数据的插入效果</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);	<span class="comment">// &quot;rw&quot; 是一种模式，表示读写</span></span><br><span class="line"></span><br><span class="line">    raf1.seek(<span class="number">3</span>);	<span class="comment">// 将指针调到角标为3的位置</span></span><br><span class="line">    <span class="comment">// 保存指针3后面的所数据到StringBuilder中</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调回指针，写入“xyz”</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 StringBuilder 中的数据写入到文件中</span></span><br><span class="line">    raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">    raf1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="其它流"><a href="#其它流" class="headerlink" title="其它流"></a>其它流</h1><h2 id="1-标准的输入输出流"><a href="#1-标准的输入输出流" class="headerlink" title="1 标准的输入输出流"></a>1 标准的输入输出流</h2><blockquote>
<p>  <strong>System.in</strong></p>
</blockquote>
<p>标准的输入流，默认从键盘输入（从键盘输入的数据传输到内存中）</p>
<blockquote>
<p>  <strong>System.out</strong></p>
</blockquote>
<p>标准的输出流，默认从控制台输出（内存中的数据输出到控制台上显示）</p>
<blockquote>
<p>  <strong>修改默认的输入和输出行为：</strong></p>
</blockquote>
<p>通过 System 类的 <code>setIn(InputStream is) / setOut(PrintStream ps)</code>方式重新指定输入流和输出流的行为。</p>
<h2 id="2-打印流"><a href="#2-打印流" class="headerlink" title="2 打印流"></a>2 打印流</h2><ul>
<li>  <strong>PrintStream</strong></li>
<li>  <strong>PrintWriter</strong></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>  提供了一系列重载的 <code>print()</code> 和 <code>println()</code> 方法，用于多种数据类型的输出。</li>
<li>  <code>System.out</code> 返回的是 PrintStream 的实例</li>
</ul>
<h2 id="3-数据流"><a href="#3-数据流" class="headerlink" title="3 数据流"></a>3 数据流</h2><ul>
<li>  <strong>DataInputStream</strong></li>
<li>  <strong>DataOutputStream</strong></li>
</ul>
<p><strong>作用：</strong>用于读取或写出基本数据类型的变量或字符串。</p>
<blockquote>
<p>  <strong>Demo1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	练习：将内存中的字符串、基本数据类型的变量写出到(文件)中。</span></span><br><span class="line"><span class="comment">	注意：处理异常的话，仍然应该使用try-catch-finally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    dos.writeUTF(<span class="string">&quot;圣诞树&quot;</span>);</span><br><span class="line">    dos.flush();	<span class="comment">// 刷新操作，将内存中的数据写入文件</span></span><br><span class="line">    dos.writeInt(<span class="number">23</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Demo2</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment">	注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">    System.out.println(<span class="string">&quot;isMale = &quot;</span> + isMale);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.Dictionary&lt;K,V&gt;</span><br><span class="line">    继承者 java.util.Hashtable&lt;Object,Object&gt;		<span class="comment">// !!!</span></span><br><span class="line">    	继承者 java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Properties</code> 类表示一个持久的<strong>属性集</strong>。</li>
<li>它使用<strong>键值对</strong>结构存储数据，每个键及其对应的值都是一个字符串。</li>
<li><strong>总结：</strong>Properties 可以当做一个 HashMap 来使用，只不过其内部定义了一些特有的方法要比 HashMap 操作更丰富。</li>
</ol>
<h2 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2 构造方法"></a>2 构造方法</h2><table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Properties()</code></td>
<td align="left">创建一个空的属性列表</td>
</tr>
<tr>
<td align="left"><code>Properties(Properties default)</code></td>
<td align="left">创建一个带有指定默认值的空属性列表</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">(Properties defaults)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaults = defaults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3 成员方法"></a>3 成员方法</h2><table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>setProperties(String key, String value)</code></td>
<td align="center"><code>Object</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>getProperties(String key)</code></td>
<td align="center"><code>String</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>stringPropertyNames()</code></td>
<td align="center"><code>Set&lt;String&gt;</code></td>
<td align="left">获取所有键的名称的集合</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>load(InputStream inStream)</code></td>
<td align="center"><code>void</code></td>
<td align="left">从字节输入流中获取键值对</td>
</tr>
</tbody></table>
<h3 id="3-1-与流相关的方法"><a href="#3-1-与流相关的方法" class="headerlink" title="3.1 与流相关的方法"></a>3.1 与流相关的方法</h3><blockquote>
<p>  <strong>public void load(InputStream inputStream)</strong></p>
</blockquote>
<ul>
<li>  字节流中的数据都是从外部存储设备读取到内存中的，而 <code>Properties</code> 类又可以读取 <code>InputStream</code> 中的数据，这样 <code>Properties</code> 就可以间接的加载外部存储设备中的文本数据了。</li>
<li>  但是 <strong>Properties 类只能加载文本数据格式为键值对的形式</strong>，常见的有 <code>.properties</code>或<code>.yml</code> 文件。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
