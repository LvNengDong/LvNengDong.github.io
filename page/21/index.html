<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/21/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/21/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/21/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">231</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/11/HTML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/11/HTML/" class="post-title-link" itemprop="url">HTML</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-11 11:36:34" itemprop="dateCreated datePublished" datetime="2020-11-11T11:36:34+08:00">2020-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-03-12 21:55:43" itemprop="dateModified" datetime="2021-03-12T21:55:43+08:00">2021-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/2020/11/11/HTML/HTML.png"></p>
<h1 id="HTML-概述"><a href="#HTML-概述" class="headerlink" title="HTML 概述"></a>HTML 概述</h1><blockquote>
<ul>
<li><p>HTML 是最基础的网页开发语言</p>
</li>
<li><p>Hyper Text Markup Language：超文本标记语言</p>
<blockquote>
<ul>
<li><p><strong>超文本</strong>：超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本</p>
</li>
<li><p><strong>标记语言</strong>：</p>
<ul>
<li><p>由标签构成的语言。&lt;标签名称&gt; 如 html，xml</p>
</li>
<li><p>标记语言不是编程语言。</p>
<blockquote>
<ul>
<li>没有逻辑性</li>
<li>按顺序从上到下执行</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li><p>html文档后缀名 .html 或者 .htm</p>
</li>
<li><p>标签分为：</p>
</li>
</ol>
<ul>
<li><p><strong>围堵标签</strong>：有开始标签和结束标签。如<code> &lt;html&gt; &lt;/html&gt;</code></p>
</li>
<li><p><strong>自闭合标签</strong>：开始标签和结束标签在一起。如<code> &lt;br/&gt;</code></p>
</li>
</ul>
<ol start="3">
<li>标签之间可以互相嵌套。</li>
<li>在<strong>开始标签中</strong>可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</li>
<li>html的标签不区分大小写，但是建议使用小写。</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><p>标签拥有自己的属性，分为：</p>
<ul>
<li><strong>基本属性</strong>：可以修改简单的样式效果</li>
<li><strong>事件属性</strong>：可以直接设置事件响应后的代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">bgcolor</span>=<span class="string">&quot;red&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;你好&#x27;)&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>属性必须有值，属性值必须加引号</p>
</li>
</ol>
</blockquote>
<hr>
<h1 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h1><h2 id="1、文件标签"><a href="#1、文件标签" class="headerlink" title="1、文件标签"></a>1、文件标签</h2><blockquote>
<p>构成html最基本的标签</p>
</blockquote>
<ul>
<li><p><code>html</code>：html文档的根标签【超级祖宗】</p>
</li>
<li><p><code>head</code>：头标签</p>
<blockquote>
<ul>
<li>用于指定html文档的一些属性。</li>
<li>引入外部的资源</li>
</ul>
</blockquote>
</li>
<li><p><code>title</code>：标题标签</p>
</li>
<li><p><code>body</code>：体标签</p>
</li>
<li><p><code>&lt;!DOCTYPE html&gt;</code>：定义文档类型，html5中定义该文档是html文档</p>
</li>
</ul>
<h2 id="2、文本标签"><a href="#2、文本标签" class="headerlink" title="2、文本标签"></a>2、文本标签</h2><blockquote>
<p>和文本有关的标签</p>
</blockquote>
<ul>
<li><p><code>&lt;!-- 注释 --&gt;</code>：注释</p>
</li>
<li><p><code>&lt;h1&gt;标题&lt;h1&gt;</code>：标题标签</p>
<blockquote>
<p>h1~h6:字体大小逐渐递减</p>
</blockquote>
</li>
<li><p><code>&lt;p&gt;</code>：段落标签</p>
</li>
<li><p><code>&lt;br&gt;</code>：换行标签</p>
</li>
<li><p><code>&lt;hr&gt;</code>：水平线</p>
<blockquote>
<p>属性：</p>
<ul>
<li><p>color：颜色</p>
</li>
<li><p>width：线长</p>
</li>
<li><p>size：线高</p>
</li>
<li><p>align：对齐方式</p>
<blockquote>
<ul>
<li>center：居中</li>
<li>left：左对齐</li>
<li>right：右对齐</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;font&gt;</code>：字体标签</p>
<blockquote>
<p>属性：</p>
<ul>
<li>size：字号</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;b&gt;</code>：字体加粗</p>
</li>
<li><p><code>&lt;i&gt;</code>：字体斜体</p>
</li>
<li><p><code>&lt;center&gt;</code>:文本居中</p>
<blockquote>
<p>属性：</p>
<ul>
<li>color：颜色</li>
<li>size：大小</li>
<li>face：字体</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="常见的属性对应的值"><a href="#常见的属性对应的值" class="headerlink" title="常见的属性对应的值"></a>常见的属性对应的值</h3><ul>
<li><p>color：</p>
<blockquote>
<ol>
<li>用英文单词表示：red,green,blue</li>
<li>RGB(x，y，z)，值的范围：0~255  如  RGB(0,0,255)</li>
<li>#XXYYZZ，值的范围：00~FF之间。如： #FF00FF</li>
</ol>
</blockquote>
</li>
<li><p>width：</p>
<blockquote>
<ol>
<li>数值，如width=’20’ ,数值的单位，默认是 px(像素)</li>
<li>数值%：如width=“20%”，相对于父元素所占的比例</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="3、图片标签"><a href="#3、图片标签" class="headerlink" title="3、图片标签"></a>3、图片标签</h2><ul>
<li><p><code>&lt;img&gt;</code>：展示图片</p>
<blockquote>
<p>属性：</p>
<ul>
<li>键：src，指定图片的位置</li>
<li>值：相对路径/绝对路径</li>
</ul>
</blockquote>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot; &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、列表标签："><a href="#4、列表标签：" class="headerlink" title="4、列表标签："></a>4、列表标签：</h2><ul>
<li>有序列表：<code>&lt;ol&gt;&lt;li&gt;</code></li>
<li>无序列表：<code>&lt;ul&gt;&lt;li&gt;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--有序列表 &lt;ol&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--无序列表 &lt;ul&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="5、链接标签："><a href="#5、链接标签：" class="headerlink" title="5、链接标签："></a>5、链接标签：</h2><ul>
<li><p><code>&lt;a&gt;</code>：超链接</p>
<blockquote>
<p>属性：</p>
<ul>
<li><p>href：指定访问资源的URL</p>
</li>
<li><p>target：指定打开资源的方式</p>
<blockquote>
<ul>
<li>_self：默认值，在当前页面打开</li>
<li>_blank：在空白页面打开</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="6、div"><a href="#6、div" class="headerlink" title="6、div"></a>6、div</h2><ul>
<li><code>&lt;div&gt;</code>：块级标签。<strong>每个div都从新一行开始</strong></li>
</ul>
<h2 id="7、span："><a href="#7、span：" class="headerlink" title="7、span："></a>7、span：</h2><ul>
<li><p><code>&lt;span&gt;</code>：<strong>行内标签</strong>/内联标签。</p>
<blockquote>
<ul>
<li>与上文内容直接连接，不换行。</li>
<li>每个<code>&lt;span&gt;</code>标签内的文本信息在一行中展示。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="8、语义化标签"><a href="#8、语义化标签" class="headerlink" title="8、语义化标签"></a>8、语义化标签</h2><blockquote>
<p>html5中为了提高程序的可读性，提供了一些标签。</p>
</blockquote>
<ul>
<li><code>&lt;header&gt;</code>：页眉</li>
<li><code>&lt;footer&gt;</code>：页脚</li>
</ul>
<h2 id="9、表格标签："><a href="#9、表格标签：" class="headerlink" title="9、表格标签："></a>9、表格标签：</h2><ul>
<li><p><code>&lt;table&gt;</code>：定义表格</p>
<blockquote>
<p>属性：</p>
<ul>
<li>width：宽度</li>
<li>border：边框</li>
<li>cellpadding：定义内容和单元格的距离</li>
<li>cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、</li>
<li>bgcolor：背景色</li>
<li>align：对齐方式</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>&lt;tr&gt;</code>：定义行</p>
<blockquote>
<ul>
<li>bgcolor：背景色</li>
<li>align：对齐方式</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;td&gt;</code>：定义单元格</p>
<blockquote>
<ul>
<li>colspan：合并列</li>
<li>rowspan：合并行</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;th&gt;</code>：定义表头单元格</p>
</li>
<li><p><code>&lt;caption&gt;</code>：表格标题</p>
</li>
<li><p><code>&lt;thead&gt;</code>：表示表格的头部分</p>
</li>
<li><p><code>&lt;tbody&gt;</code>：表示表格的体部分</p>
</li>
<li><p><code>&lt;tfoot&gt;</code>：表示表格的脚部分</p>
</li>
</ul>
<h2 id="10、表单标签"><a href="#10、表单标签" class="headerlink" title="10、表单标签"></a>10、表单标签</h2><blockquote>
<p>表单：用于采集用户输入的数据，和服务器进行交互。</p>
</blockquote>
<ul>
<li><p><code>&lt;form&gt;</code>：用于定义表单。可以定义一个范围，范围代表采集用户数据的范围</p>
<blockquote>
<p>属性：</p>
<ul>
<li>action：指定提交数据的URL</li>
<li>method：指定提交方式。GET/POST/…</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="表单项标签"><a href="#表单项标签" class="headerlink" title="表单项标签"></a>表单项标签</h3><ul>
<li><p>表单项标签：</p>
<ul>
<li><p><code>&lt;input&gt;</code>：</p>
<blockquote>
<p>属性：</p>
<ul>
<li><p>type</p>
<blockquote>
<ul>
<li><p>text：文本输入框，默认值</p>
<blockquote>
<p>placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息    </p>
</blockquote>
</li>
<li><p>password：密码输入框</p>
</li>
<li><p>radio:单选框</p>
<blockquote>
<ol>
<li>要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。</li>
<li>一般会给每一个单选框提供value属性，绑定其被选中后提交的值</li>
<li>checked属性，可以指定默认值</li>
</ol>
</blockquote>
</li>
<li><p>checkbox：复选框</p>
<blockquote>
<ol>
<li>一般会给复选框中的每一个单选框提供value属性，指定其被选中后提交的值</li>
<li>checked属性，可以指定默认值</li>
</ol>
</blockquote>
</li>
<li><p>file：文件选择框</p>
</li>
<li><p>hidden：隐藏域，用于提交一些信息。</p>
</li>
</ul>
<ul>
<li><p>按钮：</p>
<blockquote>
<ul>
<li><p>submit：提交按钮。可以提交表单</p>
</li>
<li><p>button：普通按钮</p>
</li>
<li><p>image：图片提交按钮</p>
<blockquote>
<p>src属性指定图片的路径</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;label&gt;</code>：指定输入项的文字描述信息</p>
<blockquote>
<p>label的for属性一般会和 input 的 id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点。</p>
</blockquote>
</li>
<li><p><code>&lt;select&gt;</code>： 下拉列表</p>
</li>
<li><p>子元素：<code>&lt;option&gt;</code>，指定列表项</p>
<blockquote>
<ul>
<li><code>&lt;select&gt;</code>标签只能定义一个选择列表，并不能定义选择列表内的值。</li>
<li>如果想定义选择列表中的选项，需要使用<code>&lt;option&gt;</code>标签</li>
</ul>
</blockquote>
</li>
<li><p><code>&lt;textarea&gt;</code>：文本域</p>
<blockquote>
<ul>
<li>rows：指定文本域的行数。 </li>
<li>cols：指定文本域的列数，每一行有多少个字符。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/07/Zuul/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/07/Zuul/" class="post-title-link" itemprop="url">Zuul</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-07 22:09:31" itemprop="dateCreated datePublished" datetime="2020-11-07T22:09:31+08:00">2020-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-03 16:51:46" itemprop="dateModified" datetime="2021-09-03T16:51:46+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringCould/" itemprop="url" rel="index"><span itemprop="name">SpringCould</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，即<strong>网关（GateWay）</strong>。</p>
<p>顾名思义，网关（GateWay）就是一个网络连接到另一个网络的“关口”。        通常我们讲的网关就是路由器的IP地址。</p>
<blockquote>
<ul>
<li>  <strong>网关(Gateway)</strong> 又称网间连接器、协议转换器。            </li>
<li>  网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。                 </li>
<li>  网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</li>
</ul>
</blockquote>
<h2 id="SpringCould中的网关"><a href="#SpringCould中的网关" class="headerlink" title="SpringCould中的网关"></a>SpringCould中的网关</h2><p>在不使用Zuul网关的情况下，使用Spring Cloud实现的微服务的架构大致如下：</p>
<p><img src="/2020/11/07/Zuul/1525674644660.png" alt="1525674644660"></p>
<blockquote>
<ul>
<li>我们通过Eureka实现了<strong>服务注册中心</strong>以及<strong>服务注册</strong>与<strong>发现</strong>；</li>
<li>通过Ribbon或Feign实现<strong>服务的消费</strong>以及<strong>负载均衡</strong>；</li>
<li>通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。</li>
<li>为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</li>
</ul>
</blockquote>
<p>在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务集群，通过负载均衡公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？</p>
<blockquote>
<p>  <strong>Before：</strong></p>
</blockquote>
<p>先来说说这样架构需要做的一些事儿以及存在的不足：</p>
<ul>
<li>  为了保证对外服务的安全性，我们需要对访问者的权限进行控制，并且对于服务的权限控制机制将会贯穿整个开放服务的业务逻辑，</li>
<li>  无法直接复用既有接口：当我们需要把一个已经存在的内部服务变为对外服务时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，而不能直接复用原有的接口。</li>
</ul>
<blockquote>
<p>  <strong>After：</strong></p>
</blockquote>
<p>面对类似上面的问题，我们要如何解决呢？答案是：服务网关！</p>
<ul>
<li>  为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器——<strong>服务网关</strong>。</li>
<li>  服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了<code>权限控制</code>等功能。</li>
<li>  Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</li>
</ul>
<hr>
<h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>Zuul是Netflix开源的微服务网关，它可以和Eureka、Ribbon、Hystrix等组件配合使用。Zuul的核心是一系列的<strong>过滤器</strong>，这些过滤器可以完成以下功能：</p>
<blockquote>
<p><strong>身份认证与安全</strong>：</p>
<ul>
<li>识别每个资源的验证要求，并拒绝那些与要求不符的请求。</li>
</ul>
<p><strong>审查与监控</strong>：</p>
<ul>
<li>在边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。</li>
</ul>
<p><strong>动态路由</strong>：</p>
<ul>
<li>动态地将请求路由到不同的后端集群。</li>
</ul>
<p><strong>压力测试</strong>：</p>
<ul>
<li>逐渐增加指向集群的流量，以了解性能。</li>
</ul>
<p><strong>负载分配</strong>：</p>
<ul>
<li>为每一种负载类型分配对应的容量，并弃用超出限定值的请求。</li>
</ul>
<p><strong>静态响应处理</strong>：</p>
<ul>
<li>在边缘位置直接建立部分响应，从而避免其转发到内部集群。</li>
</ul>
<p><strong>多区域弹性</strong>：</p>
<ul>
<li>跨越AWS Region进行请求路由，旨在实现ELB（Elastic Load Balancing）使用的多样化，以及让系统的边缘更贴近系统的使用者。</li>
</ul>
</blockquote>
<h2 id="SpringCould中的Zuul"><a href="#SpringCould中的Zuul" class="headerlink" title="SpringCould中的Zuul"></a>SpringCould中的Zuul</h2><p>SpringCould对Zuul进行了整合与增强。目前，Zuul使用的默认HTTP客户端是<code>ApacheHTTPClient</code>，也可以使用<code>RestClient</code>或者<code>okhttp3.OkHttpClient</code>。可以通过设置文件修改HTTP客户端。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon.restclient.enabled</span>=<span class="string">true;</span></span><br><span class="line"><span class="attr">ribbon.okhttp.enabled</span>=<span class="string">true;</span></span><br></pre></td></tr></table></figure>





<h2 id="Zuul加入后的架构"><a href="#Zuul加入后的架构" class="headerlink" title="Zuul加入后的架构"></a>Zuul加入后的架构</h2><p><img src="/2020/11/07/Zuul/1525675648881.png" alt="1525675648881"></p>
<ul>
<li><strong>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关</strong>，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</li>
</ul>
<hr>
<h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><ul>
<li><p>映射规则</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 当前服务的端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">api-gateway</span> <span class="comment"># 当前服务实例名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  	<span class="attr">user-service:</span>	<span class="comment"># 这里是自定义的路由ID</span></span><br><span class="line">  	<span class="attr">path:</span> <span class="string">/user-service/**</span> 	<span class="comment"># 定义访问路径</span></span><br><span class="line">  	<span class="attr">url:</span> <span class="string">http://127.0.0.1:8081</span>	<span class="comment"># 访问路径映射到的实际url地址</span></span><br></pre></td></tr></table></figure>

<p>我们将符合<code>path</code>规则的一切请求，都代理到<code>url</code>参数指定的地址。</p>
<p>本例中，我们将<code>/user-service/**</code>开头的请求，代理到<code>http://127.0.0.1:8081</code>。</p>
<p>此时：<code>http://localhost:10010/user-service/user/1</code> 等价于 <code>http://127.0.0.1:8081/user/1</code></p>
</li>
</ul>
<h3 id="5-1-2-面向服务的路由"><a href="#5-1-2-面向服务的路由" class="headerlink" title="5.1.2    面向服务的路由"></a>5.1.2    面向服务的路由</h3><ul>
<li>在刚才的路由规则中，我们把路径对应的服务地址写死了！如果一个服务有多个实例的话，这样做显然是不合理的。</li>
<li>我们应该根据服务的名称，去Eureka注册中心查找服务对应的所有实例列表，然后进行动态路由才对。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加Eureka配置，拉取服务列表</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">	<span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s</span></span><br><span class="line">  	<span class="attr">service-url:</span></span><br><span class="line">	  <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">	<span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment"># 修改路由映射规则，通过服务名称获取路由地址</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  	<span class="attr">user-service:</span>	<span class="comment"># 路由ID，随意写</span></span><br><span class="line">  	  <span class="attr">path:</span>	<span class="string">/user-service/**</span>	<span class="comment"># 映射路径</span></span><br><span class="line">  	  <span class="attr">serviceId:</span> <span class="string">user-service</span>	<span class="comment"># 指定服务名称</span></span><br></pre></td></tr></table></figure>

<h4 id="1、简化的路由配置"><a href="#1、简化的路由配置" class="headerlink" title="1、简化的路由配置"></a>1、简化的路由配置</h4><ol>
<li><p>在上面的配置中，我们的规则是这样的：</p>
<ul>
<li><code>zuul.routes.&lt;routes&gt;.path=/xxx/**</code>：来指定映射路径。<code>&lt;routes&gt;</code>是自定义的路由名。</li>
<li><code>zuul.routes.&lt;routes&gt;.serviceId=/user-service</code>：来指定服务名。</li>
</ul>
</li>
<li><p>而大多数情况下，我们的<code>&lt;routes&gt;</code>路由名往往和服务名会定义成一样的，因此Zuul就提供了一种简化的配置语法：</p>
<ul>
<li><code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  	<span class="attr">user-service:</span> <span class="string">/user-service/**</span>	<span class="comment"># 服务名称&amp;映射路径[省去了对服务名称的配置]	</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2、默认的路由规则"><a href="#2、默认的路由规则" class="headerlink" title="2、默认的路由规则"></a>2、默认的路由规则</h4><ul>
<li>在使用Zuul的过程中，上述的规则已经大大简化了配置。但是当服务较多时，配置仍是比较繁琐的，因此Zuul就指定了默认的路由规则：<ul>
<li>默认情况下，一切服务的映射路径就是服务名本身。<ul>
<li>例如服务名为：<code>user-service</code>，则默认的映射路径就是：<code>/user-service/**</code></li>
</ul>
</li>
</ul>
</li>
<li>也就是说，上面的映射规则我们完全不配置也是OK的。</li>
</ul>
<h4 id="4、路由前缀"><a href="#4、路由前缀" class="headerlink" title="4、路由前缀"></a>4、路由前缀</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/api</span>	<span class="comment"># 添加路由前缀</span></span><br><span class="line">  <span class="attr">routes:</span> </span><br><span class="line">  	<span class="attr">user-service:</span>	<span class="comment"># 路由ID</span></span><br><span class="line">  	  <span class="attr">path:</span> <span class="string">/user-service/**</span></span><br><span class="line">  	  <span class="attr">serviceId:</span> <span class="string">user-service</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以<code>/api</code>开头</li>
</ul>
<h2 id="5-2-过滤器"><a href="#5-2-过滤器" class="headerlink" title="5.2    过滤器"></a>5.2    过滤器</h2><ul>
<li>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个工作往往是通过Zuul提供的过滤器来实现的。</li>
</ul>
<h2 id="5-3-负载均衡-amp-熔断"><a href="#5-3-负载均衡-amp-熔断" class="headerlink" title="5.3    负载均衡  &amp;  熔断"></a>5.3    负载均衡  &amp;  熔断</h2><ul>
<li>Zuul中默认已经集成了Ribbon负载均衡和Hystrix熔断机制。但所有的超时策略走的都是默认值，比如熔断超时时间只有1s，很容易就触发了，因此建议手动配置。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">retryable:</span> <span class="literal">true</span>	<span class="comment"># 开启重试机制</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># 连接超时时间(ms)</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">2000</span> <span class="comment"># 通信超时时间(ms)</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作重试</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">2</span> <span class="comment"># 同一服务不同实例的重试次数</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 同一实例的重试次数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">	<span class="attr">default:</span></span><br><span class="line">	  <span class="attr">execution:</span></span><br><span class="line">		<span class="attr">isolation:</span></span><br><span class="line">		  <span class="attr">thread:</span></span><br><span class="line">			<span class="attr">timeoutInMillisecond:</span> <span class="number">6000</span> <span class="comment"># 熔断超时时长：6000ms</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/07/Eureka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/07/Eureka/" class="post-title-link" itemprop="url">Eureka</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-07 21:52:34" itemprop="dateCreated datePublished" datetime="2020-11-07T21:52:34+08:00">2020-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-03 12:39:25" itemprop="dateModified" datetime="2021-09-03T12:39:25+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringCould/" itemprop="url" rel="index"><span itemprop="name">SpringCould</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><blockquote>
<ul>
<li>  Eureka只是注册中心的一种；</li>
<li>  目前常用的还有 Nacos</li>
</ul>
</blockquote>
<h2 id="为什么要使用注册中心（Eureka能做什么）？"><a href="#为什么要使用注册中心（Eureka能做什么）？" class="headerlink" title="为什么要使用注册中心（Eureka能做什么）？"></a>为什么要使用注册中心（Eureka能做什么）？</h2><blockquote>
<p>  <strong>Before</strong></p>
</blockquote>
<ul>
<li>在微服务架构中，<code>服务提供者</code> 对外提供服务，需要对外暴露自己的地址。</li>
<li><code>服务调用者</code>需要记录<code>服务提供者</code>的地址来进行数据交互，将来地址出现变更，还需要及时更新。</li>
<li>这在服务数量较少的时候并不觉得有什么，如果一个项目中包含几十上百个微服务，此时如果还人为管理地址，将会非常麻烦。</li>
</ul>
<blockquote>
<p>  <strong>After</strong></p>
</blockquote>
<ul>
<li><code>Eureka</code>负责管理、记录<code>服务提供者</code>的信息。</li>
<li><code>服务调用者</code>无需自己寻找服务，而是把自己的需求告诉<code>Eureka</code>，然后<code>Eureka</code>会把符合需求的服务的 IP 地址告诉<code>服务调用者</code>。</li>
<li><code>服务提供者</code>与<code>Eureka</code>之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。</li>
<li>这就实现了服务的自动注册、发现、状态监控。</li>
</ul>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<ul>
<li>  注册中心就相当于一个总控，一个“中间人”，维护一张服务列表。没有注册中心之前，<code>服务提供者</code> 和 <code>服务调用者</code> 之间是直接联系的，所以 <code>服务调用者</code> 必须知道 <code>服务提供者</code> 的IP地址，当需要调用很多个服务的时候，记录 <code>服务提供者</code> 的 IP 地址本身就是一项非常复杂的工作。而有了总控（注册中心）后，<code>服务调用者</code> 只需要记住一个 IP 地址，即“总控”的 IP 地址，并定期的从“总控”拉取最新的服务列表，然后 <code>服务调用者</code> 就可以从服务列表中选择合适的 IP 地址去调用 <code>服务提供者</code> 进行业务请求了。</li>
</ul>
<hr>
<h2 id="Eureka架构"><a href="#Eureka架构" class="headerlink" title="Eureka架构"></a>Eureka架构</h2><p><img src="/2020/11/07/Eureka/Eureka%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.png"></p>
<blockquote>
<p>Eureka架构中的三个核心角色</p>
<ul>
<li><p><strong>EurekaServer：服务注册中心</strong></p>
<p>服务注册中心可以是单点的，也可以是一个集群，对外暴露自己的地址。</p>
</li>
<li><p><strong>服务提供者</strong></p>
<p>启动后向<code>EurekaServer</code>注册自己的信息（包括地址、提供什么服务等），这些信息保存在<code>EurekaServer</code>的服务列表中。</p>
</li>
<li><p><strong>服务调用者</strong></p>
<p><code>服务调用者</code>从<code>EurekaServer</code>拉取服务列表，从中获得每个<code>服务提供者</code>的信息。就可以知道要去哪里调用<code>服务提供者</code>，并且定义定期从<code>EurekaServer</code>中更新服务列表。</p>
</li>
<li><p><strong>心跳（续约）</strong></p>
<p><code>服务提供者</code>定期通过HTTP方式向<code>EurekaServer</code>刷新自己的状态。</p>
</li>
</ul>
</blockquote>
<h2 id="Eureka组件"><a href="#Eureka组件" class="headerlink" title="Eureka组件"></a>Eureka组件</h2><h3 id="Eureka-Server：服务注册中心"><a href="#Eureka-Server：服务注册中心" class="headerlink" title="Eureka Server：服务注册中心"></a>Eureka Server：服务注册中心</h3><blockquote>
<ul>
<li>Eureka的服务端应用，提供服务注册（针对服务提供者）和发现（针对服务调用者）功能。</li>
<li>EurekaServer可以是一个集群，形成高可用的Eureka中心。</li>
</ul>
</blockquote>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li><strong>服务同步</strong>（EurekaServer）</li>
</ul>
<blockquote>
<p>为了避免单点故障，我们一般会搭建一个Eureka集群，让多个EurekaServer之间也会互相注册为服务，当<code>服务提供者</code>注册到EurekaServer集群中的某个节点时，该节点会把服务器的信息同步给集群中的每个节点，从而实现<strong>数据同步</strong>。此时，无论客户端访问到EurekaServer集群中的哪一个节点，都可以获取到完整的服务列表信息。</p>
</blockquote>
<ul>
<li><strong>失效剔除</strong>（EurekaServer）</li>
</ul>
<blockquote>
<p>有些时候，我们的<code>服务提供者</code>并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。</p>
<p>可以通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒，生产环境不要修改。</p>
<p>这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当减小。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">  	<span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">60</span><span class="string">*1000</span>	<span class="comment"># 失效剔除时间</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>自我保护</strong>（EurekaServer）</li>
</ul>
<p>我们关停一个服务，就会在Eureka面板看到一条警告：这是触发了Eureka的自我保护机制。</p>
<p><img src="/2020/11/07/Eureka/1525618396076.png"></p>
<blockquote>
<p>当一个<code>服务提供者</code>未按时心跳续约时，Eureka会统计该服务实例最近15分钟心跳失败的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败的比例很有可能超标，但此时直接把服务剔除并不妥当，因为服务可能没有宕机。Eureka就把当前实例的注册信心保护起来，不予剔除。生产环境下这很有用，保证了大多数服务依然可用。</p>
<p>但是这给我们的开发带来了麻烦，因此开发阶段我们都会关闭自我保护模式：</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">  	<span class="attr">enable-self-preservation:</span> <span class="literal">false</span>	<span class="comment"># 关闭自我保护模式（缺省为true）</span></span><br></pre></td></tr></table></figure>





<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><blockquote>
<ul>
<li><p>提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供Rest风格服务（接口）即可。</p>
</li>
<li><p>服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。</p>
</li>
</ul>
</blockquote>
<h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><ul>
<li><p><strong>服务注册</strong>（服务提供者）</p>
<blockquote>
<p><code>服务提供者</code>在启动时，会检测配置属性中的：<code>eureka.client.register-with-eureka=true</code>参数是否为true（默认为true）。如果值为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息。EurekaServer会把这些信息保存到一个双层的Map结构中，第一层Map的key就是服务名称，第二层Map的key是服务的实例ID。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>服务续约</strong>（服务提供者）</p>
<blockquote>
<p>在注册完成以后，<code>服务提供者</code>与<code>Eureka</code>之间会维持一个”心跳”（定时向EurekaServer发送Rest请求），告诉EurekaServer：“我还活着”。我们将这个过程称为<strong>服务续约（renew）</strong>。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span> </span><br><span class="line">  	<span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span>	<span class="comment"># 服务失效时间，默认为90s</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span>	<span class="comment"># 服务续约时间，默认为30s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。</p>
<p>但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">10</span> <span class="comment"># 10秒即过期</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 5秒一次心跳</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>实例ID</strong></p>
<p>先来看一下服务状态信息：</p>
<p>在Eureka监控页面，查看服务注册信息：</p>
<p><img src="/2020/11/07/Eureka/1525617060656.png" alt="1525617060656"></p>
<p>在status一列中，显示以下信息：</p>
<ul>
<li>UP(1)：代表现在是启动了1个服务器实例，没有形成集群</li>
<li>DESKTOP-2MVEC12:user-service:8081：是实例的名称（instance-id），<ul>
<li>默认格式是：<code>$&#123;hostname&#125; + $&#123;spring.application.name&#125; + $&#123;server.port&#125;</code></li>
<li>instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。</li>
</ul>
</li>
</ul>
<p>我们可以通过instance-id属性来修改它的构成：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启服务再试试看：</p>
<p><img src="/2020/11/07/Eureka/1525617542081.png" alt="1525617542081"></p>
</li>
</ul>
<h3 id="服务调用者"><a href="#服务调用者" class="headerlink" title="服务调用者"></a>服务调用者</h3><blockquote>
<p><code>服务调用者</code>从<code>服务注册中心</code>获取服务列表，从而得知每个 <code>服务提供者</code> 的信息，知道去哪里调用服务方。</p>
</blockquote>
<h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><ul>
<li><strong>获取服务列表</strong>（服务消费者）</li>
</ul>
<blockquote>
<p>当<code>服务消费者</code>启动时，会检测<code>eureka.client.fetch-registry=true</code>参数的值，如果为true（默认为true），则会从EurekaServer中拉取服务列表缓存在本地，并且每隔 30s 会重新获取最新的数据。我们可以通过下面的参数来进行修改：</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">  	<span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span>		<span class="comment"># 默认值是30s</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>生产环境中，我们不需要修改这个值。</p>
<p>但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。</p>
</blockquote>
<hr>
<h2 id="Eureka中常见的配置信息"><a href="#Eureka中常见的配置信息" class="headerlink" title="Eureka中常见的配置信息"></a>Eureka中常见的配置信息</h2><h3 id="Eureka服务端"><a href="#Eureka服务端" class="headerlink" title="Eureka服务端"></a>Eureka服务端</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 当前服务的端口号</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 当前服务的名称（ID），会在Eureka中显示</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">	<span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 是否注册自己的信息到EurekaServer，默认是true</span></span><br><span class="line">	<span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 是否拉取其它服务的信息，默认是true</span></span><br><span class="line">	<span class="attr">service-url:</span> <span class="comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。</span></span><br><span class="line">	  <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>

<h3 id="Eureka客户端"><a href="#Eureka客户端" class="headerlink" title="Eureka客户端"></a>Eureka客户端</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span>	<span class="comment"># 当前服务器的端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">	<span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mydb01</span></span><br><span class="line">	<span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">	<span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">	<span class="attr">hikari:</span></span><br><span class="line">	  <span class="attr">maximum-pool-size:</span> <span class="number">20</span>		<span class="comment"># 最大连接池数量</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 应用名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.leyou.userservice.pojo</span>	<span class="comment"># mybatis实体类包扫描并起别名[用于封装查询到的数据]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">	<span class="attr">service-url:</span> <span class="comment"># EurekaServer服务器的地址，多个地址以 [，] 隔开</span></span><br><span class="line">	  <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">	<span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 当调用getHostname获取实例的hostname时，返回ip而不是host名称</span></span><br><span class="line">	<span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>   <span class="comment"># 指定自己的ip信息，不指定的话会自己寻找</span></span><br><span class="line">	<span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span>	<span class="comment"># 默认值，服务失效时间</span></span><br><span class="line">	<span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span>	<span class="comment"># 默认值，服务续约间隔时间</span></span><br><span class="line">	<span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span> 	<span class="comment"># 默认值，注册列表拉取时间间隔</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">	<span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 自我保护（缺省为打开）</span></span><br><span class="line">	<span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 失效剔除（缺省为60*1000ms）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不用指定<code>register-with-eureka</code>和<code>fetch-registry</code>，因为默认是true。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/07/Hystrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/07/Hystrix/" class="post-title-link" itemprop="url">Hystrix</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-07 18:35:19" itemprop="dateCreated datePublished" datetime="2020-11-07T18:35:19+08:00">2020-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-03 15:29:32" itemprop="dateModified" datetime="2021-09-03T15:29:32+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringCould/" itemprop="url" rel="index"><span itemprop="name">SpringCould</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">Hystrix官方文档</a></li>
</ul>
<h1 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h1><p>分布式系统环境下，<strong>服务间的依赖</strong>非常常见，一个服务调用通常依赖多个基础服务。</p>
<p>如下图，当库存服务不可用时，商品服务的请求库存服务的线程就会被阻塞，当有大批量请求调用库存服务时，这些所有的请求就都会被阻塞，最终可能导致整个商品服务的资源被耗尽（主要是线程池资源，虽然库存服务不可用，但是每个商品服务的请求还会占用一个线程，并且因为不会获取到响应，也就不会归还线程，这样当线程池资源耗尽时商品服务就会被阻塞），无法继续对外提供服务。并且这种不可用可能沿请求调用链向上传递，这种现象称为<strong>雪崩效应</strong>。</p>
<p><img src="/2020/11/07/Hystrix/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94.png"></p>
<h2 id="雪崩效应的常见场景"><a href="#雪崩效应的常见场景" class="headerlink" title="雪崩效应的常见场景"></a>雪崩效应的常见场景</h2><blockquote>
<ul>
<li>硬件故障</li>
<li>流量激增</li>
<li>缓存穿透</li>
<li>程序BUG</li>
<li>同步等待</li>
</ul>
</blockquote>
<h2 id="雪崩效应的应对策略"><a href="#雪崩效应的应对策略" class="headerlink" title="雪崩效应的应对策略"></a>雪崩效应的应对策略</h2><p>针对造成雪崩效应的不同场景，可以使用不同的应对策略，没有一种通用所有场景的策略。</p>
<blockquote>
<p>  <strong>小总结</strong></p>
</blockquote>
<ul>
<li>  <strong>如果一个应用不能对（服务间的）依赖故障进行隔离，那该应用本身就处在被拖垮的风险中。</strong>            </li>
<li>  因此，为了构建稳定、可靠的分布式系统，我们的服务应当具有自我保护能力，当依赖的服务不可用时，当前服务启动自我保护功能，从而避免发生雪崩效应。</li>
</ul>
<hr>
<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>Hystrix，中文含义是豪猪。因其背上长满棘刺，从而有了自我保护能力。            SpringCould中的Hystrix是Netflix一款开源的容错框架，同样具有自我保护能力。</p>
<p>Hystrix的设计目标：</p>
<blockquote>
<ul>
<li>对来自依赖的延迟和故障进行防护和控制（这些依赖通常是通过网络访问的）</li>
<li>阻止故障的连锁反应</li>
<li>快速失败并迅速恢复</li>
<li>回退并优雅降级</li>
<li>提供实时的监控与示警</li>
</ul>
</blockquote>
<p>Hystrix遵循的设计原则：</p>
<blockquote>
<ul>
<li>防止任何单独的依赖耗尽资源（主要是线程资源）</li>
<li>过载立即切断并快速失败，防止排队</li>
<li>尽可能提供回退以保护用户免受故障</li>
<li>使用隔离技术来限制一个依赖的影响</li>
<li>通过近实时的指标、监控和示警，确保故障被及时发现</li>
<li>通过动态修改配置属性，确保故障及时恢复</li>
<li>防止整个依赖客户端执行失败，而不仅仅是网络通信</li>
</ul>
</blockquote>
<p>Hystrix如何实现这些设计目标？</p>
<blockquote>
<ul>
<li>使用命令模式将所有对外部服务（或依赖关系）的调用包装在<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象中，并将该对象放在单独的线程中执行；[没看懂…]</li>
<li>每个依赖关系都维护着一个线程池，线程池被耗尽则拒绝请求（而不是让请求排队）</li>
<li>记录请求成功、失败、超时和线程拒绝</li>
<li>服务错误百分比超过了阈值，熔断器开关自动打开，一段时间内停止对该服务的所有请求</li>
<li>请求失败、被拒绝、超时或熔断时执行降级逻辑</li>
<li>近实时的监控指标和配置的修改</li>
</ul>
</blockquote>
<h1 id="Hystrix处理流程"><a href="#Hystrix处理流程" class="headerlink" title="Hystrix处理流程"></a>Hystrix处理流程</h1><p><img src="/2020/11/07/Hystrix/hystrix%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<p>Hystrix的整个工作流程如下：</p>
<blockquote>
<ol>
<li>构造一个<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象，用于封装请求，并在构造方法中配置请求被执行需要的参数；</li>
<li>执行命令，Hystrix提供了4种执行命令的方法，后面详述；</li>
<li>判断是否要使用缓存响应请求，若启动了缓存且缓存可用，则直接使用缓存响应请求。[Hystrix支持请求缓存，但需要用户自定义启动]</li>
<li>判断熔断器是否打开，如果打开，则跳到第8步；</li>
<li>判断线程池/队列/信号量是否已满，已满则跳到第8步；</li>
<li>执行<code>HystrixCommand.run()</code>或<code>HystrixObservableCommand.construct()</code>，如果执行失败或超时，跳到第8步，否则跳到第9步；</li>
<li>统计熔断器监控指标；</li>
<li>执行FallBack备用逻辑；</li>
<li>返回请求响应。</li>
</ol>
<p>从流程图上可知，第5步线程池/队列/信号量已满时，还会执行第7步逻辑，更新熔断器的统计信息，而第6步无论成功与否，都会执行第7步逻辑，更新熔断器统计信息。</p>
</blockquote>
<h1 id="Hystrix容错"><a href="#Hystrix容错" class="headerlink" title="Hystrix容错"></a>Hystrix容错</h1><p>Hystrix的容错主要是通过添加允许延迟和容错方法，帮助控制这些分布式服务之间的交互。            还通过隔离服务之间的访问点，阻止它们之间的级联故障以及回退选项来实现这一点，从而提高系统的整体弹性。            Hystrix主要提供了以下几种容错方法：</p>
<ul>
<li>资源隔离</li>
<li>熔断</li>
<li>降级</li>
</ul>
<p>下面我们详细了解一下这几种容错机制。</p>
<hr>
<h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><blockquote>
<p>资源隔离主要指对线程的隔离。Hystrix提供了2种线程隔离方式：线程池和信号量</p>
</blockquote>
<h3 id="线程隔离——线程池"><a href="#线程隔离——线程池" class="headerlink" title="线程隔离——线程池"></a>线程隔离——线程池</h3><h3 id="线程隔离——信号量"><a href="#线程隔离——信号量" class="headerlink" title="线程隔离——信号量"></a>线程隔离——信号量</h3><hr>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><h3 id="熔断器简介"><a href="#熔断器简介" class="headerlink" title="熔断器简介"></a>熔断器简介</h3><p>在现实生活中，家用电路中都会安装一个保险盒，当负载过载时，保险盒中的保险丝就会自动熔断，保护下游部件不被烧毁。            Hystrix中的熔断器（Circuit Breaker）也是起类似作用。Hystrix在运行过程中回向每个CommandKey对应的熔断器报告成功、失败、超时和拒绝的状态，熔断器维护并统计这些数据，并根据这些信息来决策熔断器是否打开。如果打开，则熔断后续请求，快速返回。            隔一段时间后熔断器尝试半开，放一部分流量请求进来，相当于对依赖服务做一次健康检查，如果请求成功熔断器关闭。</p>
<h3 id="熔断器配置"><a href="#熔断器配置" class="headerlink" title="熔断器配置"></a>熔断器配置</h3><p>熔断器主要包括以下6个参数：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>circuitBreaker.enabled</code></td>
<td align="center">是否启用熔断器，默认true</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>circuitBreaker.forceOpen</code></td>
<td align="center">强制打开熔断器，默认false</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>circuitBreaker.forceClosed</code></td>
<td align="center">强制关闭熔断器，默认false</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>circuitBreaker.errorThresholdPercentage</code></td>
<td align="center">错误率阈值，默认值是50%</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>circuitBreaker.requestVolumeThreshold</code></td>
<td align="center">统计请求的最小数量，默认值是20</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><code>circuitBreaker.sleepWindowMillseconds</code></td>
<td align="center">半开状态试探睡眠时间，默认值5000ms</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li><code>circuitBreaker.errorThresholdPercentage</code>是错误率的阈值，例如一段时间内有100个请求，其中有54个超时或异常，那么这段时间内的错误率就是54%，大于阈值50%，这种情况下就会触发熔断器打开。</li>
<li><code>circuitBreaker.requestVolumeThreshold</code>的含义是：一段时间内至少有20个请求才能进行<code>errorThresholdPercentage</code>计算，如果一段时间内只有19个请求，并且这些请求全都失败了，错误率是100%，但是熔断器仍不会打开，因为总请求数不满20。</li>
<li><code>circuitBreaker.sleepWindowMillseconds</code>的含义是：当熔断器开启5000s之后，会尝试放一部分流量过去进行试探，确定依赖服务是否恢复。</li>
</ul>
</blockquote>
<h3 id="熔断器工作原理"><a href="#熔断器工作原理" class="headerlink" title="熔断器工作原理"></a>熔断器工作原理</h3><p><img src="/2020/11/07/Hystrix/%E7%86%94%E6%96%AD%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<p>熔断器的工作流程如下：</p>
<blockquote>
<ol>
<li>调用<code>allowRequest()</code>判断是否允许将请求提交到线程池：<ul>
<li>如果熔断器强制打开，不允许放行，返回；</li>
<li>如果熔断器强制关闭，允许放行。此外不需要再关注熔断器的实际状态，也就是说熔断器仍会维护统计数据和开关状态，但是不生效。</li>
</ul>
</li>
<li>调用<code>isOpen()</code>判断熔断器开关是否打开：<ul>
<li>1）如果熔断器打开，进入第3步，否则继续；</li>
<li>2）如果一个周期内总的请求数小于<code>circuitBreaker.requestVolumeThreshold</code>的值，允许请求放行，否则进入3)；</li>
<li>3）如果一个周期内错误率小于<code>circuitBreaker.errorThresholdPercentage</code>的值，允许请求放行。否则，打开熔断器开关，进入第3步。</li>
</ul>
</li>
<li>调用<code>allowSingleTest()</code>判断是否允许单个请求通行，检查依赖服务是否恢复。<ul>
<li>1）如果熔断器打开，且距离熔断器打开的时间或上一次试探请求放行的时间超过<code>circuitBreaker.sleepWindowMillseconds</code>，熔断器进入半开状态，允许放行一个试探请求；否则，不允许放行。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="回退降级"><a href="#回退降级" class="headerlink" title="回退降级"></a>回退降级</h2><p>降级，通常是指服务高峰期，为了保证核心服务的正常运行，需要停掉一些不太重要的业务，或者某些服务不可用时，执行备用逻辑从故障服务中快速失败或快速返回，以保障主体业务不受影响。            Hystrix提供的降级服务主要是为了容错，保证当前服务不受依赖服务故障的影响，从而提高服务的健壮性。            要支持回退或降级处理，可以重写<code>HystrixCommand</code>中的<code>getFallBack()</code>方法或<code>HystrixObservableCommand</code>中的<code>resumeWithFallBack()</code>方法。</p>
<p>Hystrix会在以下几种情况下执行降级逻辑：</p>
<blockquote>
<ul>
<li>执行<code>construct()</code>或<code>run()</code>抛出异常</li>
<li>熔断器打开导致命令断路</li>
<li>命令的线程池或信号量的容量超额，命令被拒绝</li>
<li>命令执行超时</li>
</ul>
</blockquote>
<ol>
<li>正常工作的情况下，客户端请求调用服务API接口：</li>
</ol>
<p><img src="/2020/11/07/Hystrix/1525658906255.png" alt="1525658906255"></p>
<ol start="2">
<li>当有服务出现异常时，直接进行失败回滚，服务降级处理：</li>
</ol>
<p><img src="/2020/11/07/Hystrix/1525658983518.png" alt="1525658983518"></p>
<blockquote>
<p>当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。</p>
<p>这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。</p>
<p>系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。</p>
</blockquote>
<h3 id="降级回退方式"><a href="#降级回退方式" class="headerlink" title="降级回退方式"></a>降级回退方式</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">HTTP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-03 21:56:34" itemprop="dateCreated datePublished" datetime="2020-11-03T21:56:34+08:00">2020-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-10-13 09:15:03" itemprop="dateModified" datetime="2021-10-13T09:15:03+08:00">2021-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h1><blockquote>
<p>  什么是协议？</p>
</blockquote>
<p>协议是指双方或多方相互约定好，大家都需要遵循的规则。</p>
<blockquote>
<p>  HTTP：<code>Hyper Text Transfer Protocol</code>     超文本传输协议</p>
</blockquote>
<p>所谓 HTTP 协议，就是指：两台或多台计算机通信时，传输数据时需要遵守的规则。</p>
<p>HTTP协议中的数据又叫做报文。</p>
<blockquote>
<p>  HTTP协议的特点：</p>
</blockquote>
<ol>
<li>HTTP 协议是基于 TCP/IP 的高级协议</li>
<li>默认端口号：80</li>
<li>基于<strong>请求/响应模型</strong>：一次请求对应一次响应。<ul>
<li>客户端浏览器访问服务器端的网页，假设一个页面上有很多内容，如图片、CSS 样式、HTML静态资源、JS样式等。这些内容不是一次请求就全部响应加载出来的，而是多次请求多次响应的过程。</li>
</ul>
</li>
<li>无状态的：<ul>
<li>每次请求之间相互独立，不能交互数据。</li>
</ul>
</li>
</ol>
<blockquote>
<p>  HTTP 协议的历史版本</p>
</blockquote>
<ul>
<li>HTTP 1.0 ：每次请求都会建立新的连接。(这里的连接指的是 TCP 连接，因为 HTTP 底层是 TCP 协议)<ul>
<li>  每次请求得到响应，获取资源后，都会将连接释放，下次请求会建立新的连接，周而复始。</li>
</ul>
</li>
<li>HTTP 1.1 ：复用连接<ul>
<li>  第一次请求得到响应后，在计时器未超时之前，保持与该网页服务器的连接，继续访问无需重新建立连接。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2、请求"><a href="#2、请求" class="headerlink" title="2、请求"></a>2、请求</h1><p>客户端给服务器发送数据叫请求。服务器给客户端回传数据叫做响应。</p>
<p>HTTP有 9 种请求方式，常用的有2种：</p>
<table>
<thead>
<tr>
<th align="center">请求方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>GET</strong></td>
<td>查</td>
</tr>
<tr>
<td align="center"><strong>POST</strong></td>
<td>改</td>
</tr>
<tr>
<td align="center"><strong>PUT</strong></td>
<td>增</td>
</tr>
<tr>
<td align="center"><strong>DELETE</strong></td>
<td>删</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td></td>
</tr>
<tr>
<td align="center">PATCH</td>
<td></td>
</tr>
<tr>
<td align="center">OPTIONS</td>
<td></td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td></td>
</tr>
<tr>
<td align="center">TRACE</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>GET</strong>：</p>
</blockquote>
<ol>
<li>请求参数在请求行中，位置在 URL 之后【请求参数是请求消息的一部分，比如登录界面的账号、密码信息等】</li>
<li>请求参数是有长度限制的【因为把请求参数都算作 URL 长度】</li>
<li>安全性较差。</li>
</ol>
<blockquote>
<p>  <strong>POST</strong>：</p>
</blockquote>
<ol>
<li>请求参数被封装在请求体中。</li>
<li>请求参数没有长度限制。</li>
<li>相对安全。</li>
</ol>
<p><strong>GET 和 POST 请求的区别：</strong></p>
<ul>
<li><p>使用上的区别</p>
<ol>
<li> GET 请求使用 URL 或 Cookie 传参，而 POST 一般将请求数据放在请求体中（当然也可以放在 cookie 中）。</li>
<li> GET 请求将请求参数放在请求行中，而请求行是有长度限制的，所以说请求参数也是有长度限制的，而 POST 请求将请求数据放在请求体中，容量非常大。</li>
<li> POST 比 GET 安全，因为数据在地址栏上不可见。</li>
</ol>
</li>
<li><p>本质区别：</p>
<ol>
<li> GET 和 POST 最大的区别在于 GET 请求是<strong>幂等性</strong>的，而 POST 请求不是。</li>
</ol>
<blockquote>
<p>  幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的效果。即一个方法重复执行多次，产生的效果是一样的。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="2-1、GET请求格式"><a href="#2-1、GET请求格式" class="headerlink" title="2.1、GET请求格式"></a>2.1、GET请求格式</h2><ol>
<li><p>请求行</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET	/demo.html HTTP/1.1</span><br><span class="line">	- GET：请求方式</span><br><span class="line">	- demo.html：请求路径[+?+请求参数]	// 与POST请求不同，请求参数直接拼接在请求路径上</span><br><span class="line">	- HTTP/1.1：协议/版本号</span><br></pre></td></tr></table></figure></li>
<li><p>请求头</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：[key:value]</span><br><span class="line">	不同的键值对，表示不同的含义</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<p><img src="/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/image-20200519085300180-1597652154013.png" alt="image-20200519085300180"></p>
</li>
</ol>
<h2 id="2-2、POST请求格式"><a href="#2-2、POST请求格式" class="headerlink" title="2.2、POST请求格式"></a>2.2、POST请求格式</h2><ol>
<li><p><strong>请求行</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST/demo.html HTTP/1.1</span><br><span class="line">	- POST：请求方式</span><br><span class="line">	- demo.html：请求路径</span><br><span class="line">	- HTTP/1.1：协议/版本号</span><br></pre></td></tr></table></figure></li>
<li><p><strong>请求头</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：[key:value]</span><br><span class="line">	不同的键值对，表示不同的含义</span><br></pre></td></tr></table></figure></li>
<li><p>请求空行</p>
<ul>
<li>功能：用于分隔POST请求的请求头和请求体。</li>
</ul>
</li>
<li><p>请求体（正文）</p>
<ul>
<li>功能：用于封装请求参数，里面保存着发送给服务器的数据</li>
</ul>
</li>
<li><p>示例</p>
<p><img src="/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/image-20200519091906540-1597652154013.png" alt="image-20200519091906540"></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost/login.html</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"># 请求空行</span><br><span class="line"># 请求体</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-3、常用的请求头说明"><a href="#2-3、常用的请求头说明" class="headerlink" title="2.3、常用的请求头说明"></a>2.3、常用的请求头说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.Host: &quot;发起请求的浏览器所在的主机的IP地址&quot;</span><br><span class="line">    </span><br><span class="line">2.User-Agent：&quot;发起请求的浏览器的版本信息[包括浏览器的名称、版本等]&quot;</span><br><span class="line">    -- 在服务器端获取该信息，可以针对不同的浏览器的进行不同的适配处理</span><br><span class="line">    </span><br><span class="line">3.Accept: &quot;告诉服务器可以接收的返回值的数据类型有哪些&quot;</span><br><span class="line">    </span><br><span class="line">4.Accept-Language: &quot;告诉服务器可以接收的语言类型有哪些&quot;</span><br><span class="line"></span><br><span class="line">5.Accept-Encoding: &quot;告诉服务器可以解析哪些压缩/编码格式&quot;</span><br><span class="line">    </span><br><span class="line">6.Referer：&quot;告诉服务器，当前请求从哪里来？[请求发起时，浏览器地址栏中的地址]&quot;</span><br><span class="line">    -- 作用：1、防盗链		2、统计工作</span><br><span class="line">    </span><br><span class="line">7.Connection: keep-alive 	-- 告诉服务器：当前的状态是每次响应后保持连接状态</span><br><span class="line">  </span><br><span class="line">8.Upgrade-Insecure-Requests: 1		-- 升级相关</span><br><span class="line"></span><br><span class="line">9.Content-Type：&quot;表示发送的数据类型（MIME类型）&quot;</span><br><span class="line">    -- application/x-www-form-urlencoded</span><br><span class="line">    	# 表示以键值对的格式发送请求数据（数据封装在请求体中）。如：name1=value1&amp;name2=value2，然后对其进行url编码</span><br><span class="line">    	# url编码是把非英文的内容转换为：%xx%xxx 的格式</span><br><span class="line">    -- multipart/form-data</span><br><span class="line">    	# 表示以多段的形式提交数据给服务器（以流的形式提交，用于上传）</span><br><span class="line">    </span><br><span class="line">10.Content-Length：&quot;表示发送的数据的长度&quot;</span><br><span class="line">    </span><br><span class="line">11.Cache-Control：&quot;表示如何控制缓存&quot; </span><br><span class="line">	-- no-cache 不缓存</span><br></pre></td></tr></table></figure>







<h2 id="2-4、常见的GET-POST请求方式？"><a href="#2-4、常见的GET-POST请求方式？" class="headerlink" title="2.4、常见的GET/POST请求方式？"></a>2.4、常见的GET/POST请求方式？</h2><blockquote>
<p>GET请求：</p>
<ol>
<li><code>&lt;form&gt;</code>标签中 method=get</li>
<li><code>&lt;a&gt;</code>标签</li>
<li><code>&lt;link&gt;</code>标签引入CSS</li>
<li><code>&lt;Script&gt;</code>标签引入JS文件</li>
<li><code>&lt;img&gt;</code>标签引入图片</li>
<li><code>iframe</code>引入HTML页面</li>
<li>在浏览器地址栏中输入地址后敲回车</li>
</ol>
<p>POST请求：</p>
<ol>
<li><code>&lt;form&gt;</code>标签中 method=post</li>
</ol>
</blockquote>
<hr>
<h1 id="3、响应"><a href="#3、响应" class="headerlink" title="3、响应"></a>3、响应</h1><h2 id="3-1、HTTP-协议响应消息的格式"><a href="#3-1、HTTP-协议响应消息的格式" class="headerlink" title="3.1、HTTP 协议响应消息的格式"></a>3.1、HTTP 协议响应消息的格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>响应行</span><br><span class="line">    （<span class="number">1</span>）响应的协议/版本号	<span class="comment">// HTTP/1.1</span></span><br><span class="line">    （<span class="number">2</span>）响应状态码		<span class="comment">// 200(成功)</span></span><br><span class="line">    （<span class="number">3</span>）响应状态描述符		<span class="comment">// OK</span></span><br><span class="line"><span class="number">2.</span>响应头</span><br><span class="line">    [key：value]		<span class="comment">// 不同的响应头，有不同的含义</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>响应空行</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>响应体		<span class="comment">// 就是回传给客户端的数据</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/03/HTTP%E5%8D%8F%E8%AE%AE/image-20200519100620160-1597652154014.png" alt="image-20200519100620160"></p>
<h2 id="3-2、常见的响应状态码"><a href="#3-2、常见的响应状态码" class="headerlink" title="3.2、常见的响应状态码"></a>3.2、常见的响应状态码</h2><p><strong>状态码分类（5大类）：</strong></p>
<blockquote>
<p><strong>1xx：</strong></p>
</blockquote>
<ul>
<li>服务器接收到了客户端的请求，但是没有接收完整，等待一段时间之后，发送1xx状态码给客户端。</li>
<li>客户端发送的请求数据不完整或者在传输过程中部分数据丢失，导致服务器一直处于等待请求数据的状态。直到等待的时间大于超时时间后，就会给向客户端响应 1xx 状态码表示请求数据不完整。</li>
</ul>
<blockquote>
<p><strong>2xx：</strong></p>
</blockquote>
<ul>
<li>客户端请求消息和服务器端响应消息都成功时返回2xx状态码表示成功。</li>
</ul>
<blockquote>
<p><strong>3xx</strong></p>
</blockquote>
<ul>
<li>重定向：<ul>
<li>301（永久重定向）：请求的网页已经永久移动到了新位置，当返回 301 状态码时请求者应该将请求 URL 改为新的 URL。</li>
<li>302（临时重定向）：服务器目前从新的网页响应请求，但是请求者接下来的请求应该继续使用原 URL。</li>
</ul>
</li>
<li>304（访问缓存）</li>
</ul>
<blockquote>
<p><strong>4xx</strong></p>
</blockquote>
<ul>
<li>客户端请求发生了错误</li>
<li>400：客户端请求语法错误</li>
<li>403：服务器收到请求，但拒绝提供服务。</li>
<li>404：（未找到）服务器找不到请求的资源</li>
<li>405：客户端发送请求的方式与服务器规定的请求方式不一致！    如：在服务器中规定某个请求的请求方式是 POST 请求，而客户端却已 GET 的方式提交请求，这时就会出现405错误。</li>
</ul>
<blockquote>
<p><strong>5xx</strong></p>
</blockquote>
<ul>
<li>服务器内部错误</li>
</ul>
<h3 id="301-和-302-的区别"><a href="#301-和-302-的区别" class="headerlink" title="301 和 302 的区别"></a>301 和 302 的区别</h3><hr>
<h2 id="3-3、常见的响应头"><a href="#3-3、常见的响应头" class="headerlink" title="3.3、常见的响应头"></a>3.3、常见的响应头</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.Content-Type: &quot;服务器告诉客户端本次响应体的响应数据类型（MIME类型）&quot;</span><br><span class="line"></span><br><span class="line">2.Content-Length: &quot;服务器告诉客户端本次响应体的长度&quot;</span><br><span class="line"></span><br><span class="line">3.Content-disposition: &quot;服务器告诉客户端以什么格式打开响应体数据&quot;</span><br><span class="line">  -- props:</span><br><span class="line">  -- 	1. in-line	：默认值，在当前页面打开</span><br><span class="line">  -- 	2. attachment；filename=xxx	：以附件形式打开响应体。【文件下载】</span><br></pre></td></tr></table></figure>





<h2 id="3-4、响应体"><a href="#3-4、响应体" class="headerlink" title="3.4、响应体"></a>3.4、响应体</h2><ul>
<li><p>传输的数据【最终被浏览器解析展示在页面上】</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    	hello , response</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="4、HTTP-长连接和短连接"><a href="#4、HTTP-长连接和短连接" class="headerlink" title="4、HTTP 长连接和短连接"></a>4、HTTP 长连接和短连接</h1><p><strong>短连接</strong></p>
<ul>
<li>  在 <code>HTTP/1.0</code> 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 请求，就建立一次 TCP 连接，任务结束就释放连接。</li>
<li>  如果客户端浏览器访问的某个页面中包含有其它 Web 资源，如 JavaScript 文件、图像文件、CSS文件等，当浏览器每遇到这样一个Web 资源，就会新发起一个 HTTP 请求，新建一个 TCP 连接。</li>
</ul>
<p><strong>长连接</strong></p>
<ul>
<li>  从 <code>HTTP/1.1</code> 起，默认使用长连接，用以保持连接特性。</li>
<li>  使用长连接的 HTTP 协议，会在响应头有加入一行代码：<strong>Connection:keep-alive</strong></li>
<li>  在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</li>
<li>  实现长连接要客户端和服务端都支持长连接。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>  HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</li>
</ul>
<hr>
<h1 id="5、HTTP1-0-和-HTTP1-1-的区别"><a href="#5、HTTP1-0-和-HTTP1-1-的区别" class="headerlink" title="5、HTTP1.0 和 HTTP1.1 的区别"></a>5、HTTP1.0 和 HTTP1.1 的区别</h1><ol>
<li> <strong>支持长连接</strong></li>
</ol>
<p><code>HTTP/1.1</code> 支持长连接（Persistent Connection），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<p><code>HTTP/1.1</code> 中默认开启长连接 <code>Connection: keep-alive</code>，一定程度上弥补了 <code>HTTP/1.0</code> 每次请求都要创建连接的缺点。</p>
<ol start="2">
<li> <strong>错误通知的管理</strong></li>
</ol>
<p>在 <code>HTTP/1.1</code> 中新增了 24 个错误状态响应码。如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<ol start="3">
<li> <strong>Host 头处理</strong></li>
</ol>
<p>在 <code>HTTP/1.0</code> 中认为每台服务器都绑定一个唯一的 IP 地址，因此请求消息中的 URL 并没有传递主机名（<strong>hostname</strong>）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。所以 <code>HTTP/1.1</code> 的请求消息和响应消息都支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</p>
<hr>
<h1 id="6、MINE-类型数据"><a href="#6、MINE-类型数据" class="headerlink" title="6、MINE 类型数据"></a>6、MINE 类型数据</h1><blockquote>
<p>通过上面的学习，我们会发现无论是在请求头中还是响应头中都有一个 <strong>Content-Type</strong> 属性，这个属性在开发中非常有用。比较常见的文件上传就是利用这个属性来实现的。[文件下载则通过响应头中的另一个属性 <strong>Content-disposition</strong> 来实现。]</p>
</blockquote>
<blockquote>
<p>请求头/响应头都是通过键值对来保存数据的，<code>Content-Type</code> 作为一个键值对的 Key ，而它对应的 Value 就是我们下面要讲的 MIME 类型数据！！！</p>
</blockquote>
<h2 id="MIME类型说明"><a href="#MIME类型说明" class="headerlink" title="MIME类型说明"></a>MIME类型说明</h2><blockquote>
<p>MIME：</p>
</blockquote>
<p>Multipurpose Internet Mail Extensions</p>
<blockquote>
<p>概念：</p>
</blockquote>
<p>MIME 是<strong>描述消息内容类型的因特网标准</strong>。MIME 消息类型包含文本、图像、音频、视频以及其他应用程序专用的数据。</p>
<blockquote>
<p>格式：</p>
</blockquote>
<p>MIME类型的格式：<strong>大类型/小类型</strong>，并与某一种文件扩展名相对应。</p>
<blockquote>
<p>常见的MIME类型：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">文件</th>
<th align="center">文件后缀名</th>
<th align="center">MIME类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">超文本标记语言</td>
<td align="center">.html || .htm</td>
<td align="center">text/html</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">普通文本</td>
<td align="center">.txt</td>
<td align="center">text/plain</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">RTF文本（类似于Word文档）</td>
<td align="center">.rtf</td>
<td align="center">application/rtf</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">GIF图形</td>
<td align="center">.gif</td>
<td align="center">image/img</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">JPEG图形</td>
<td align="center">.jpeg || .jpg</td>
<td align="center">image/jpeg</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">au声音文件</td>
<td align="center">.au</td>
<td align="center">auto/basic</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">MIDI音乐文件</td>
<td align="center">.mid || .midi</td>
<td align="center">audio/midi || audio/x-midi</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">RealAudio音乐文件</td>
<td align="center">.ra || .ram</td>
<td align="center">video/mpeg</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">MPEG文件</td>
<td align="center">.mpg || .mpeg</td>
<td align="center">video/mpeg</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">AVI文件</td>
<td align="center">.avi</td>
<td align="center">video/x-msvideo</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">GZIP文件</td>
<td align="center">.gz</td>
<td align="center">application/x-gzip</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">TAR文件</td>
<td align="center">.tar</td>
<td align="center">application/x-tar</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-29 10:21:52" itemprop="dateCreated datePublished" datetime="2020-10-29T10:21:52+08:00">2020-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-02 10:18:44" itemprop="dateModified" datetime="2021-09-02T10:18:44+08:00">2021-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h2><blockquote>
<p>将<code>多个计算机系统</code>通过<code>通信设备</code>连接起来，由<code>软件</code>实现<code>资源共享和信息传递</code>的系统。</p>
</blockquote>
<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><blockquote>
<p><strong>硬件 + 软件 + 协议</strong></p>
</blockquote>
<ol>
<li>硬件：<ul>
<li>主机</li>
<li>通信链路（双绞线、光纤等）</li>
<li>交换设备（路由器、交换机等）</li>
<li>……</li>
</ul>
</li>
<li>软件：实现资源共享的软件。</li>
<li>协议：规定了通过网络传输数据时需要遵循的规范。<ul>
<li>是两个(或多个)<strong>对等实体</strong>间通信的规则的集合，不对等的实体间是没有协议的。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><blockquote>
<p><strong>数据通信 + 资源共享 + 分布式处理 + 提高可靠性 + 负载均衡</strong></p>
</blockquote>
<ol>
<li>数据通信</li>
<li>资源共享</li>
<li>分布式处理：<ul>
<li>当计算机网络中的某个计算机负荷过重时，可以将其处理的任务分配给其它计算机系统，从而提高整个系统的利用率。</li>
</ul>
</li>
<li>提高可靠性：<ul>
<li>整个计算机网络系统就是一个大的集群，计算机网络中的各台计算机可以互为替代机。</li>
</ul>
</li>
<li>负载均衡<ul>
<li>将工作任务均衡的分配给计算机网络中的各台计算机。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><blockquote>
<ol>
<li><strong>WAN + MAN + LAN + PAN</strong></li>
<li><strong>广播式网络 + 点对点网络</strong></li>
<li><strong>有线网络 + 无线网络</strong></li>
</ol>
</blockquote>
<h3 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h3><ol>
<li>广域网（WAN）</li>
<li>城域网（MAN）</li>
<li>局域网（LAN）</li>
<li>个人区域网（PAN）</li>
</ol>
<h3 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h3><ol>
<li>广播式网络</li>
<li>点对点网络</li>
</ol>
<h3 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h3><ol>
<li>有线网络</li>
<li>无线网络</li>
</ol>
<h2 id="协议数据单元-PDU"><a href="#协议数据单元-PDU" class="headerlink" title="协议数据单元(PDU)"></a>协议数据单元(PDU)</h2><ul>
<li><code>PDU（Protocol Data Unit）</code>：协议数据单元</li>
<li><code>PCI（Protocol Control Information）</code>：协议控制信息</li>
<li><code>SDU（Service Data Unit）</code>：服务数据单元</li>
</ul>
<blockquote>
<p>对等层之间传递数据的单位称为该层的 PDU。</p>
</blockquote>
<p>在实际的网络中，每层的PDU都有一个别名，分别是：</p>
<table>
<thead>
<tr>
<th align="center">层</th>
<th align="center">PDU的别名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物理层</td>
<td align="center">比特</td>
</tr>
<tr>
<td align="center">数据链路层</td>
<td align="center">帧</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">分组(/IP数据报)</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">报文段(TCP)/用户数据报(UDP)</td>
</tr>
</tbody></table>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><blockquote>
<p><code>服务</code>是垂直的，是指：<strong>下层为<u>紧邻的</u>上层提供的功能调用。</strong></p>
</blockquote>
<h3 id="服务原语"><a href="#服务原语" class="headerlink" title="服务原语"></a>服务原语</h3><p>上层要使用下层所提供的服务，必须和下层进行交互，这些交互的命令在OSI中被称为<strong>服务原语</strong>。OSI将服务原语划分为4类：</p>
<blockquote>
<ol>
<li><code>请求(Request)</code>：服务用户–&gt;&gt;服务提供者，请求完成某项工作。</li>
<li><code>指示(Indication)</code>：服务提供者–&gt;&gt;服务用户，指示用户做某事。</li>
<li><code>响应(Response)</code>：服务用户–&gt;&gt;服务提供者，作为对<code>指示</code>的响应。</li>
<li><code>证实(Conformation)</code>：服务提供者–&gt;&gt;服务用户，作为对<code>请求</code>的证实。</li>
</ol>
</blockquote>
<h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><blockquote>
<ol>
<li><strong>面向连接服务&amp;无连接服务</strong></li>
<li><strong>可靠服务&amp;不可靠服务</strong></li>
<li><strong>有应答服务&amp;无应答服务</strong></li>
</ol>
</blockquote>
<h4 id="1、面向连接服务-amp-无连接服务"><a href="#1、面向连接服务-amp-无连接服务" class="headerlink" title="1、面向连接服务&amp;无连接服务"></a>1、面向连接服务&amp;无连接服务</h4><blockquote>
<ul>
<li>面向连接服务：<code>建立连接 --&gt;&gt;数据传输 --&gt;&gt; 连接释放 </code></li>
<li>无连接服务：尽最大努力交付，是不可靠的服务</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th align="center">面向连接服务</th>
<th align="center">无连接服务</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1. 通信前是否建立连接</td>
<td align="center">是</td>
<td align="center">否</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 通信前是否分配相应的资源（如内存空间）</td>
<td align="center">是</td>
<td align="center">否</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. 传输结束后是否释放连接</td>
<td align="center">是</td>
<td align="center">否</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4. 常见的例子</td>
<td align="center">TCP</td>
<td align="center">IP/UDP</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2、可靠服务-amp-不可靠服务"><a href="#2、可靠服务-amp-不可靠服务" class="headerlink" title="2、可靠服务&amp;不可靠服务"></a>2、可靠服务&amp;不可靠服务</h4><blockquote>
<ul>
<li><p>可靠服务：网络具有纠错、检错、应答机制，能保证数据正确、可靠的传送到目的地。</p>
</li>
<li><p>不可靠服务：网络只是尽量正确、可靠的传送，但不能保证数据正确、完整地传送到目的地。</p>
<p>对于不可靠服务，其数据的正确性只能靠用户来保障。</p>
</li>
</ul>
</blockquote>
<h4 id="3、有应答服务-amp-无应答服务"><a href="#3、有应答服务-amp-无应答服务" class="headerlink" title="3、有应答服务&amp;无应答服务"></a>3、有应答服务&amp;无应答服务</h4><blockquote>
<ul>
<li>有应答服务：接收方在收到数据后向发送方给出相应的应答。</li>
<li>无应答服务：接收方收到数据后不自动给出应答。若需要应答，则交给高层实现。</li>
</ul>
</blockquote>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h2><blockquote>
<p>提供<code>点到点(不同IP地址之间)</code>的通信</p>
<ol>
<li>为网络层提供服务。</li>
<li><strong>成帧</strong>：将网络层传下来的 IP 数据报封装成帧。(为上层提供服务)</li>
<li><strong>差错控制</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>链路管理</strong></li>
</ol>
</blockquote>
<h3 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h3><blockquote>
<p>对网络层而言，数据链路层的功能就是将源机器中来自网络层的数据传送到目标机器的网络层中去。</p>
</blockquote>
<p>数据链路层为网络层提供的服务有：</p>
<ol>
<li>无确认的无连接服务</li>
<li>有确认的无连接服务</li>
<li>有确认的面向连接服务</li>
</ol>
<h3 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h3><blockquote>
<p>数据链路层连接的建立、维持和释放过程就称为<code>链路管理</code>。</p>
</blockquote>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><blockquote>
<p>差错控制是通信的2个节点之间约定好的特定的检错规则。如奇偶校验码，接收方根据约定好的规则去检测接收到的数据是否正确。如果出了差错，能纠错就纠错，不能纠错就丢弃，确保向上层提交的数据都是无误的。</p>
</blockquote>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><blockquote>
<p>在2个节点之间传送数据时，由于2个节点的性能不同，可能节点A的发送速度远大于B节点的接收速度，如果不加以控制，那么节点B就会丢弃很多来不及接收的数据。流量控制就是想办法协调2个节点的速度，使A节点的发送速度与B节点的接收速度达到一个平衡状态。</p>
</blockquote>
<h4 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h4><h5 id="1、停止-等待协议"><a href="#1、停止-等待协议" class="headerlink" title="1、停止-等待协议"></a>1、停止-等待协议</h5><h5 id="2、后退N帧协议"><a href="#2、后退N帧协议" class="headerlink" title="2、后退N帧协议"></a>2、后退N帧协议</h5><h5 id="3、选择重传协议"><a href="#3、选择重传协议" class="headerlink" title="3、选择重传协议"></a>3、选择重传协议</h5><hr>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><ul>
<li>  网络层传输的 PDU 叫做<strong>分组（或 IP 数据报）</strong>。</li>
<li>  网络层的主要任务是将网络层的数据报从源端传递到目的端，为网络上的不同主机提供通信服务。</li>
<li>  分层结构中下层服务对于上层是“不可见”的，所以网络层的功能是描述两个对等层之间的，不考虑物理层和数据链路层。</li>
</ul>
<h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><blockquote>
<ol>
<li>为传输层提供服务</li>
<li>数据通信</li>
<li><strong>异构网络互联</strong></li>
<li><strong>路由与转发</strong></li>
<li><strong>拥塞控制</strong></li>
<li>流量控制</li>
<li>差错控制</li>
<li>…</li>
</ol>
</blockquote>
<h3 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h3><blockquote>
<p>  <strong>什么叫异构网络互联？</strong></p>
</blockquote>
<ul>
<li>  我们通常使用的互联网，它就是一个由无数个异构网络互联形成的大型计算机网络。</li>
<li>  所谓的<strong>计算机网络</strong>，通俗来讲就是一个网络连接了多台计算机，这多台计算机之间可以通过网络进行通信、数据共享等功能。</li>
<li>  而<strong>异构网络</strong>的意思就是：计算机网络是一个概念，其具体的落地实现可以有多种，使用不同的寻址方案、不同的网络接入机制、不同的差错处理机制、不同的路由选择机制等实现的计算机网络是不同的，它们互相之间就是异构网络。</li>
<li>  每种异构网络都有其擅长的应用场景，没有一种统一的网络能适应所有用户的需求。<strong>异构网络互联</strong>就是让这些异构的网络之间实现相互通信。</li>
<li>  举个例子就是：某公司内部有自己的内网，而它同时又想可以连接到公网（外网）上去，这就涉及到了异构网络的互联。</li>
<li>  <strong>定义</strong>：所谓<code>网络的互联</code>就是指：将2个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备（即中间设备）连接起来，以构成更大的网络系统。中间设备又称为<strong>中间系统</strong>或中继系统。</li>
</ul>
<blockquote>
<p>  <strong>什么是中继系统？</strong></p>
</blockquote>
<ul>
<li>中继系统就是两个（或多个）异构网络之间进行通信的转发器。即一个网络内所有计算机发出的消息的都会先发送到中继系统，再由中继系统传递给别的网络；同理，接收消息时也是先由中继系统接收，再转发中该网络内某个具体的计算机上。</li>
</ul>
<blockquote>
<p>  <strong>中继系统分类：</strong></p>
</blockquote>
<p>根据中继系统所在的层次，有以下4种不同的中继系统：</p>
<ol>
<li>物理层中的中继系统：<strong>中继器、集线器</strong></li>
<li>数据链路层中的中继系统：<strong>网桥、交换机</strong></li>
<li>网络层中的中继系统：<strong>路由器</strong></li>
<li>网络层以上的中继系统：<strong>网关</strong></li>
</ol>
<p><strong>例子</strong>：要实现网络的互联，每层的中继系统都必不可少。比如，我们在计算机 A 的浏览器上通过 <strong>网关</strong> 访问了 X 资源，首先要把我们的请求信息由上到下一层层封装，最后封装为比特流，通过电信号的形式一层层的传递给存放 A 资源的计算机 B，计算机 B 再把接收到的比特流逐级解封装为请求信息，作出响应。这一过程中，我们在每一层都可能使用了中继系统。</p>
<hr>
<h3 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h3><p>在上面的学习中，我们知道了<strong>路由器是多个计算机网络相互联系的中继系统</strong>。那么路由器做了哪些事情呢？</p>
<p>路由器主要完成 2 个功能：</p>
<blockquote>
<ol>
<li>路由选择：</li>
<li>分组转发：路由器根据转发表将用户的IP数据报从合适的端口转发出去。</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li> <strong>什么是路由选择？</strong></li>
</ol>
</blockquote>
<ul>
<li>  路由选择就是选择路径。每个路由器都维护了一张路由表，这张路由表记录了该路由器可以到达的其它所有的路由器。</li>
<li>  比如计算机 A 在网 1 内，计算机 B 在网 9 中，从网 1 到 网 9 有多条路径可以到达，如何选择路径就是路由选择。</li>
<li>  路由选择是由路由选择算法决定的。</li>
<li>  路由转发是从一个路由器转发到另一个路由器，而不是从一个路由器下的计算机到另一路由器下的计算机。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>什么是分组转发？</strong></li>
</ol>
</blockquote>
<ul>
<li>  分组转发也是使用路由表进行转发，只不过路由选择重点在于选择，分组转发重点在于数据传输。也就是根据选择好的路径进行数据传输。</li>
<li>  <strong>路由器仅根据目的主机所在的网络号来转发分组（IP数据报）</strong>，从而减少了路由表所占的存储空间。（即路由表中记录的是网络号）</li>
<li>  意思就是：一个网络内一般会有很多台计算机，但是这些计算机都同属于一个网络号。</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><blockquote>
<p>  <strong>什么是网络拥塞？</strong></p>
</blockquote>
<p>网络中的数据传输一般要经过多个路由器，如果某个路由器接收的数据量远大于该节点的最大接收范围，接收数据的能力而言），那么就说网络处于<strong>拥塞状态</strong>。</p>
<blockquote>
<p>  <strong>什么是拥塞控制？</strong></p>
</blockquote>
<ul>
<li>  拥塞控制就是确保子网络只承载其能承受的最大数据流量。</li>
</ul>
<blockquote>
<p>  <strong>拥塞控制的方法？</strong></p>
</blockquote>
<ul>
<li>  <strong>开环控制</strong>：事先考虑好所有的情况，运行时不再更改。</li>
<li>  <strong>闭环控制</strong>：运行时监控，哪里出现拥塞就进行分流。</li>
</ul>
<blockquote>
<p>  分类IP地址</p>
</blockquote>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101552003.png" alt="image-20210820101552003"></p>
<hr>
<h2 id="网络层常见的协议"><a href="#网络层常见的协议" class="headerlink" title="网络层常见的协议"></a>网络层常见的协议</h2><blockquote>
<ol>
<li>IP</li>
<li>ICMP</li>
<li>IGMP</li>
</ol>
</blockquote>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><blockquote>
<p>版本为4的IP协议</p>
</blockquote>
<h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><h4 id="IP数据报的分片"><a href="#IP数据报的分片" class="headerlink" title="IP数据报的分片"></a>IP数据报的分片</h4><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><blockquote>
<ul>
<li><p>连接在Internet中的每一台主机（或路由器）都分配一个<code>32位</code>的全球唯一的标识符，即IP地址。</p>
</li>
<li><p>IP地址可分为5类：ABCDE</p>
</li>
<li><p><code>IP地址 = &#123;&lt;网络号&gt;, &lt;主机号&gt;&#125;</code></p>
<p>其中，网络号标志主机(或路由器)连接到的网络，一个网络号在因特网范围内必须是唯一的；</p>
<p>主机号标志该主机(或路由器)，一个主机号在网络号所指明的网络范围内是唯一的。</p>
</li>
</ul>
</blockquote>
<ol>
<li>IP地址分为5类，这5类分别对应着5种网络号的开头</li>
</ol>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">网络号中对应的标示</th>
<th align="center">网络号在IP地址中占的位数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">10</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">110</td>
<td align="center">24</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">1110</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">1111</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>在各类IP地址中，有一些IP地址表示特殊用途，不可以当做某台主机的的IP地址。</p>
<blockquote>
<ul>
<li>主机号全为0表示本网络本身</li>
<li>主机号全为1表示本网络的广播地址</li>
<li>127.0.0.0表示主机本身</li>
<li>32为全为0表示本网络上的本主机。</li>
<li>32位全为1表示整个网络的广播地址。</li>
</ul>
</blockquote>
</li>
<li></li>
</ol>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><hr>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><blockquote>
<ol>
<li>传输层为运行在不同主机上的进程之间提供了<strong>逻辑通信</strong>（即端到端的通信）。</li>
<li>流量控制</li>
<li>差错控制</li>
<li>服务治理</li>
<li>数据传输管理</li>
</ol>
</blockquote>
<blockquote>
<p>  <strong>核心功能</strong></p>
</blockquote>
<ul>
<li>  传输层提供<strong>进程间的逻辑通信</strong>；网络层提供主机间的逻辑通信。</li>
<li>  传输层实现进程间的逻辑通信依赖的是<strong>套接字</strong>，在网络通信中，主机 A 发送给主机 B 的报文段包含目的端口号和源端口号，目的端口号用于找到主机 B 的进程，源端口号则用于主机 B 返回响应消息。</li>
</ul>
<blockquote>
<p>  <strong>传输协议（TCP / UDP）</strong></p>
</blockquote>
<ul>
<li>  传输层提供两种不同的传输协议，即 ①面向连接的 TCP；  ②无连接的 UDP</li>
<li>  <strong>网络层的 IP 协议是不可靠的。</strong></li>
<li>  当传输层采用<strong>面向连接</strong>的 TCP 协议时，尽管下面的网络层是不可靠的，但是由于 TCP 具有可靠性，所以建立的逻辑信道就相当于是一条<strong>全双工</strong>的可靠信道；而当传输层采用无连接的 UDP 时，建立的逻辑信道仍然是一条不可靠信道。</li>
</ul>
<blockquote>
<p>  <strong>面向连接 vs. 无连接</strong></p>
</blockquote>
<ul>
<li><strong>面向连接</strong>就是，通信的双方在：<ol>
<li> 正式通信前，要先建立连接，</li>
<li> 通信过程中，要一直监控连接的情况；</li>
<li> 通信结束后，要释放连接。</li>
</ol>
</li>
<li>  <strong>无连接</strong>是：通信的双方无需提前建立连接，需通信的时候，直接将“数据”发送到网络上，尽可能地往目的地输送，但不保证一定成功。</li>
</ul>
<blockquote>
<p>  <strong>单工、全双工、半双工</strong></p>
</blockquote>
<ul>
<li>  <strong>单工：</strong>一条信道，只有一个方向通信。即 A 可以给 B 发，但 B 不能给 A 发。如果 A 想发给 B，则需要新建一条 B 到 A 的信道。</li>
<li>  <strong>半双工：</strong>两条信道，A 可以给 B 发，B 也可以给 A 发，但 A 给 B 发和 B 给 A 发不能同时进行。即 A 不能同时接收和发送，B 也一样。</li>
<li>  <strong>全双工：</strong>两条信道，A 和 B 都可以同时接收和发送。</li>
</ul>
<blockquote>
<p>  <strong>端口的作用：</strong></p>
</blockquote>
<ul>
<li>  <strong>端口就是应用层和传输层之间进行数据传输的通道</strong>。</li>
<li>  应用层的各种应用进程需要通过端口才能将其数据向下交付给传输层；以及传输层可以将其报文段中的数据通过端口向上交付给应用层的进程。</li>
</ul>
<blockquote>
<p>  <strong>端口号</strong></p>
</blockquote>
<ul>
<li>  端口号用于在一台计算机上唯一标识一个端口。</li>
</ul>
<blockquote>
<p>  <strong>套接字（Socket）</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">套接字 = （主机IP地址，端口号）</span><br></pre></td></tr></table></figure>

<ul>
<li>  套接字唯一地标识了一个主机和其上的一个应用（进程）。</li>
<li>  叫进程更为合适一点，因为客户机上一些应用使用的端口号是动态的，只有在运行时作为一个进程才能知道。</li>
</ul>
<hr>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote>
<p>  <strong>UDP 优点</strong></p>
</blockquote>
<ol>
<li> UDP 是无连接的，即不会引入建立连接的时延；</li>
<li> 不需要维护连接状态，即不需要消耗资源去跟踪连接状态的相关参数，消耗的系统资源更少，即同样的软、硬件条件下能支持更多的服务。</li>
<li> 分组首部开销小。TCP 首部需要 20Byte，而 UDP 仅需 8Byte。（TCP由于要建立、维护、释放连接，所以首部需要的信息多一点）</li>
<li> UDP 没有拥塞控制，允许丢弃部分数据，对于要求控制发送时间的应用友好。即允许发送失败，但不允许发送超时的应用。</li>
</ol>
<blockquote>
<p>  <strong>UDP 首部格式</strong></p>
</blockquote>
<ul>
<li>  <strong>目的端口号</strong></li>
<li>  <strong>源端口号</strong>：在需要对方回信时使用，不需要时全选 0 即可。</li>
<li>  <strong>长度</strong>：UDP 数据报的包括（首部长度+数据长度）。最短为 8Byte，即只有首部无数据。</li>
<li><strong>校验和</strong>：<ul>
<li>  接收方使用，用于检验 UDP 数据在传输中是否出错了，<strong>有错就丢弃</strong>。</li>
<li>  该字段是可选的，如果源主机不想计算校验和，直接令该字段全为 0  即可。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20171019224629112" alt="img"></p>
<ul>
<li>  如果接收方传输层的 UDP 发现报文中的端口号不存在，就丢弃该报文。</li>
<li>  UDP 首部 8Byte 是四部分平均分配的，每一部分占 2Byte。</li>
<li>  UDP 校验和可以校验数据报的首部部分和数据部分，发送方 UDP 将校验和保存在 UDP 首部中，接收方 UDP 通过破解校验和得到的结果，确定发送的消息是否正确，如果正确就接收，不正确就丢弃。</li>
</ul>
<hr>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h3><ul>
<li>  TCP 传送的数据单元叫做<strong>TCP报文段</strong>。</li>
<li>  <code>TCP报文段 = TCP 首部 + TCP 数据部分</code></li>
<li>  <strong>TCP 首部长度是可变的，至少占 20Byte ，最多占 60Byte</strong>。允许扩充，每次扩充必须是 4Byte 的整数倍，即 <code>(4*N) Byte</code>。</li>
<li>  整个 TCP 报文段作为 IP 数据报的的数据部分封装在 IP 数据报中。</li>
</ul>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20181130165347546.png" alt="img" style="zoom:150%;">



<blockquote>
<p>  <strong>TCP 首部各成员的含义：</strong></p>
</blockquote>
<ol>
<li><p> <strong>源端口号</strong></p>
</li>
<li><p> <strong>目的端口号</strong></p>
</li>
<li><p><strong>序号</strong>：TCP 传输的是字节流（即一个一个字节的集合），即一个 TCP 报文段包含几百几千个 Byte，TCP 会为每个 Byte 都建立一个编号，而<strong>序号</strong>指的就是当前报文段所发送的字节流数据中第一个字节的序号。</p>
<p> 例如：一个报文段的序号值为 301，携带的数据共有 100Byte，这就表明当前报文段数据的最后一个字节的序号是 400，故希望下一个报文段的数据序号应该从 401 开始。</p>
</li>
<li><p><strong>数据偏移</strong>：数据偏移指的就是首部长度。因为 TCP 首部是变长的，所以要使用数据偏移记录 TCP 报文段的首部长度。</p>
<p> <code>数据偏移 = | TCP报文段的起始位置 - TCP报文段数据部分的起始位置 |</code></p>
</li>
<li><p> <strong>保留字段</strong>：保留为今后使用</p>
</li>
<li><p> <strong>URG（紧急位）</strong>：Urgency，当某一报文段中包含紧急数据时可以声明为紧急报文段，其对应的优先级会被提高。URG 需要和<strong>紧急指针</strong>配套使用，<code>URG=1</code> 表示紧急指针字段有效。</p>
</li>
<li><p> <strong>紧急指针</strong>：紧急指针指出在本报文段中紧急数据共有多个字节。紧急数据需放在数据部分的最前面，数据从第一个字节开始到紧急指针所指的字节就是紧急数据。</p>
</li>
<li><p> <strong>确认号</strong>：是接收方的 TCP 期望收到的下一个报文段的第一个字节的序号。若确认号为 N，则表明接收方前 N-1 个字节全部正确接收到了。确认号需要和<strong>确认位（ACK）</strong>配合使用【确认号是接收方在响应信息的确认报文段中使用的】</p>
</li>
<li><p><strong>ACK（确认位）</strong>：只有当 ACK=1 时确认号字段才有效；当 ACK=0 时，确认号无效。</p>
<p> TCP 规定，在建立连接之后所有传送的报文段都必须把 ACK 置为 1。</p>
</li>
<li><p> <strong>PSH（推送位）</strong>：相当于强制刷新到上层协议的内存中。一般情况下，接收方接收到的数据会先保存在缓存中，等缓存填满之后再向上交付，但是收到 <strong>PSH=1</strong> 的报文段后，不管缓存是否填满，会立即执行一个数据的向上交付。</p>
</li>
<li><p> <strong>RST（复位位）</strong>：Reset，当 <strong>RST=1</strong> 时，表名 TCP 连接中出现了严重错误，必须释放连接，重新建立建立。</p>
</li>
<li><p><strong>SYN（同步位）</strong>：<strong>SYN=1</strong> 表示这是一个<strong>连接请求</strong>或<strong>连接接收</strong>报文。</p>
<ul>
<li>  当 <strong>SYN=1，ACK=0</strong> 时，表明这是一个连接请求报文；[TCP 规定连接建立后，确认位 ACK=1 恒成立，但是第一次请求建立连接时连接还尚未建立，所以 ACK=0 。]</li>
<li>  若对方同意建立，则在响应报文中使用 <strong>SYN=1，ACK=1</strong> ，此时连接已经建立了。</li>
</ul>
</li>
<li><p> <strong>FIN（终止位）</strong>：<strong>FIN=1</strong> 表示此报文段的发送方数据已经发送完毕，并要求释放连接。</p>
</li>
<li><p> <strong>窗口</strong>：指出了<strong>当前</strong>还允许对方发送的最大数据量。这个值在不断地变化，接收方的缓存空间是有限的，假设接收方缓存大小为 1000Byte，当已经使用了 300Byte 后，这时候窗口的大小就是 700Byte，即当前允许对方发送的最大数据量。</p>
</li>
<li><p> <strong>校验和</strong>：用于校验 TCP 报文段首部和数据两部分。</p>
</li>
<li><p> <strong>选项</strong>：长度可变，TCP 最初只规定了一种选项。即最大报文长度。</p>
</li>
<li><p> <strong>填充</strong>：为了使整个首部的长度是 4Byte 的整数倍。</p>
</li>
</ol>
<hr>
<h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><p>每一条 TCP 连接有两个端点，分别是两个套接字。</p>
<p>TCP连接的建立要经过3个步骤，通常称为“三次握手”。</p>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20180714120413411" alt="img"></p>
<blockquote>
<p>  <strong>step1：</strong></p>
</blockquote>
<ul>
<li>  客户机的 TCP 首先向服务器的 TCP 发送一个连接请求报文段。</li>
<li>  这个特殊的报文段中不包含应用层数据，但其首部的 SYN 标志位被置为 1，ACK 仍为 0（因为 ACK=1 标识着确认号有效，但是第一次请求建立连接时并没有确认号，所以确认位置为 0 即可）</li>
<li>  另外，客户机会随机选择一个起始序号 seq=x (连接请求报文中不携带数据，但是会消耗掉一个序号)。</li>
</ul>
<blockquote>
<p>  <strong>step2：</strong></p>
</blockquote>
<ul>
<li>  服务器的 TCP 接收到连接请求报文段后，<strong>如果同意建立连接</strong>，就向客户机发回确认报文段，<strong>并为该 TCP 连接分配 TCP 缓存和变量</strong>。</li>
<li>  如果服务器同意建立，此时对于服务器而言，连接就已经建立了，处于<strong>“半连接状态”</strong>。</li>
<li>  在确认报文段中，<strong>SYN=1，ACK=1</strong>，确认号字段的值为 <code>x+1</code>，并且服务器会随机选择一个起始序号 <code>seq=y</code>。确认报文段同样不携带数据，但也要消耗掉一个序号。（因为服务器要发送确认号给客户端，所以确认位 SYN 必须为 1）</li>
</ul>
<blockquote>
<p>  <strong>step3：</strong></p>
</blockquote>
<ul>
<li>  当客户机收到确认报文段后，还要向服务器给出确认报文段，并且也要<strong>给该连接分配缓存和变量</strong>。</li>
<li>  这个报文段的<strong>确认位 ACK=1，序号 seq=x+1，确认号 ack=y+1</strong>。</li>
<li>  <strong>该报文段可以携带数据，如果不携带数据则不消耗序列号。</strong></li>
</ul>
<p>在成功进行了以上三步后，TCP 连接就建立了，接下来就可以传递应用层数据了。</p>
<p>TCP 提供的是全双工通信，因此通信双方的应用层任何时候都能发送数据。</p>
<p>由于服务器端的资源是在第二次握手时分配的，而客户端的资源是在第三次握手时才分配的。所以客户端可以利用这一特性在发送大量的请求去攻击服务器，这叫做 <strong>SYN洪泛攻击</strong>。</p>
<blockquote>
<p>  <strong>SYN 洪泛攻击</strong></p>
</blockquote>
<p>SYN 洪泛攻击发生在传输层的 TCP 协议建立连接的“三次握手”中。</p>
<ol>
<li> 攻击者发送 TCP SYN ，SYN 是TCP 三次握手中的第一个数据包。当服务器返回 ACK 后，该攻击者就不对其再进行确认，那么这个 TCP 就处于挂起状态，也就是所谓的半连接状态。</li>
<li> 服务器收不到确认的话，还会重复发送 ACK 给攻击者，这样会更加浪费服务器的资源。</li>
<li> 攻击者对服务器发送大量的这种 TCP 连接，，由于每一个都无法完成三次握手，所以在服务器上，这些 TCP 会因为挂起状态而消耗 CPU 内存，最终导致服务器宕机。</li>
</ol>
<hr>
<h3 id="TCP连接的释放"><a href="#TCP连接的释放" class="headerlink" title="TCP连接的释放"></a>TCP连接的释放</h3><p>参与 TCP 连接的<strong>两个进程中的任何一个都能终止该连接</strong>，TCP连接的释放过程通常称为“四次挥手”。</p>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20180714120426323" alt="img"></p>
<blockquote>
<p>  <strong>step1：</strong></p>
</blockquote>
<ul>
<li>  客户机如果打算关闭连接，就向服务器 TCP 发送一个释放连接报文段，并停止再发送数据，主动关闭 TCP 连接。</li>
<li>  该报文段的 <strong>FIN=1</strong>，序列号 <strong>seq=u</strong>（它等于前面已经传送过的数据的最后一个字节的序号+1）。FIN 报文段即使不携带数据，也要消耗掉一个序列号。</li>
<li>  这个 FIN 报文段是客户机发送给服务器的倒数第二个报文段。</li>
</ul>
<blockquote>
<p>  <strong>step2：</strong></p>
</blockquote>
<ul>
<li>  服务器收到连接释放报文段后发出确认。确认号是 <strong>ack=u+1</strong>，而这个报文段自己的序列号 <strong>seq=v</strong>（即前面已经传送过的数据的最后一个字节的序列号+1）。</li>
<li>  此时，从客户端向服务器端已经不能发送含有数据的报文段了，但是还有最后一个不含数据的确认消息报文段还是要发送的。</li>
<li>  但是服务器如果还有数据的话，客户端仍要接收。但是此时服务器发送的含有数据部分的报文段，客户机不再对其响应，直到遇到 FIN 报文段。</li>
</ul>
<blockquote>
<p>  <strong>step3：</strong></p>
</blockquote>
<ul>
<li>  若服务器已经没有要向客户机发送的数据，就发送 FIN 报文段通知 TCP 释放连接，发出 <strong>FIN=1</strong> 的连接释放报文段。</li>
</ul>
<blockquote>
<p>  <strong>step4：</strong></p>
</blockquote>
<ul>
<li>  客户机收到连接释放报文段后，向服务器发出确认报文段。</li>
<li>  这个确认报文段是客户机发送给服务器的最后一个报文段。</li>
<li>  在确认报文段中，确认位 ACK=1，确认号 ack=w+1，序列号 seq=u+1。</li>
<li>  此时 TCP 连接还尚未释放掉，必须经过时间等待计时器设置的时间 2MSL 后，才会真正地断开 TCP 连接。</li>
</ul>
<hr>
<h1 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h1><blockquote>
<p>会话层利用传输层提供的端到端的服务，并对该服务进行增强。</p>
</blockquote>
<h1 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h1><blockquote>
<p><code>表示层</code>主要用于处理2个系统中交换信息的表示方式。</p>
</blockquote>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><blockquote>
<p>面向用户，是用户与计算机网络的界面</p>
</blockquote>
<h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><ul>
<li>  <strong>C/S</strong>：一台服务器（集群），多台用户机</li>
<li>  <strong>P2P</strong>：每台计算机，既可以是服务器，也可以是用户</li>
</ul>
<blockquote>
<p>  <strong>P2P模型</strong></p>
</blockquote>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101819591.png" alt="image-20210820101819591" style="zoom:50%;">



<blockquote>
</blockquote>
<h2 id="DNS-系统"><a href="#DNS-系统" class="headerlink" title="DNS 系统"></a>DNS 系统</h2><blockquote>
<p>  DNS（Domain Name System）；域名系统</p>
</blockquote>
<ul>
<li>  作用：将域名映射为 IP 地址</li>
<li>  架构：C/S</li>
<li>  底层协议：UDP</li>
<li>  使用端口号：53</li>
</ul>
<h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101741899.png" alt="image-20210820101741899" style="zoom:50%;">



<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><ul>
<li>  域名服务器是一个联机的的分布式数据库系统。也就是说分布式数据库中保存了所有域名到 IP 地址的映射，如果能在这个分布式数据库找到域名对应的 IP 地址，在联网的情况下就可以进行访问，如果找不到，就会访问失败。</li>
</ul>
<blockquote>
<p>  <strong>本地域名服务器</strong></p>
</blockquote>
<ul>
<li>  本地域名服务器就是一台运行着的计算机，当一台主机发出 DNS 解析请求时，这个请求首先会发送给该主机的本地域名服务器，在本地域名服务器中找不到时才会继续发送给根域名服务器。</li>
<li>  本地域名服务器中保存了根域名服务器的 IP 地址。</li>
<li>  本地域名服务器可以在 Windows 的系统配置中手动填写，也可以由计算机根据当前连接自动获取。</li>
</ul>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820104859100.png" alt="image-20210820104859100" style="zoom: 67%;">



<blockquote>
<p>  <strong>根域名服务器</strong></p>
</blockquote>
<ul>
<li>  根域名服务器用来管辖顶级域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的 IP 地址。</li>
<li>  当在本地域名服务器中找不到客户计算机发送的域名解析请求时，首先会求助于根域名服务器。</li>
<li>  因特网上有 13 个根域名服务器（每个都以集群的形式存在）。</li>
</ul>
<blockquote>
<p>  <strong>顶级域名服务器</strong></p>
</blockquote>
<ul>
<li>  顶级域名服务器用来管理在该顶级域名服务器下注册的所有二级域名。如 <code>.com</code> 下的所有二级域名。</li>
<li>当收到 DNS 解析请求时，给出相应的回答：<ul>
<li>  可能是最后的结果；如 <code>baidu.com</code></li>
<li>  也可能是下一步要查找的服务器的 IP 地址。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>权限域名服务器</strong></p>
</blockquote>
<ul>
<li>  即管理二级、三级、四级域名的服务器</li>
</ul>
<hr>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><blockquote>
<p>  <strong>域名解析包括：</strong></p>
</blockquote>
<ul>
<li>  反向解析：将 IP 地址映射成域名；</li>
<li>  正向解析：将域名映射成 IP 地址。</li>
</ul>
<blockquote>
<p>  <strong>域名解析有两种方式：</strong></p>
</blockquote>
<ul>
<li>  递归查询</li>
<li>  递归 + 迭代（结合）：常用</li>
</ul>
<blockquote>
<p>  <strong>纯递归查询的缺点</strong>：</p>
</blockquote>
<p>对根域名服务器造成的负载过大。显然本地域名服务器的数量远大于根域名服务器的数量，当有大量的本地域名服务器向根域名服务器发送了大量域名解析请求后，由于全世界范围内根域名服务器只有 13 个集群，很有可能承担不了如此大的流量冲击。</p>
<blockquote>
<p>  <strong>递归+迭代的域名解析流程</strong></p>
</blockquote>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820102550685.png" alt="image-20210820102550685"></p>
<ol>
<li> 主机向本地域名服务器的查询采用的是递归。即主机发出要解析的域名给本地域名服务器，本地域名解析完后后再交付给主机。中间的其它过程主机不管。</li>
<li> 本地域名服务器向根域名服务器 / 顶级域名服务器 / 权限域名服务器 的查询采用的是迭代查询。即本地域名服务器先向根域名服务器查询域名的映射，若没找到的话，根域名服务器会返回一个顶级域名服务器的地址，本地域名服务器就会再向顶级域名服务器发送 DNS 解析请求。</li>
<li> 以此类推。</li>
</ol>
<h3 id="DNS域名解析流程小结"><a href="#DNS域名解析流程小结" class="headerlink" title="DNS域名解析流程小结"></a>DNS域名解析流程小结</h3><p>假设某客户机通过浏览器请求访问 <code>map.baidu.com</code>，域名解析的过程如下： </p>
<ol>
<li> 首先，客户机会在本机的 <strong>host</strong> 文件中查找是否存在  <code>map.baidu.com</code> 映射的 IP 地址。（当然一般情况下是没有的，本机的 <code>host</code> 文件默认只保存了 <strong>localhost</strong> 的 IP 映射，当然也可以自己添加其它的）</li>
<li> 如果本机找不到域名的映射，就会发送 DNS 请求报文到本地域名服务器。</li>
<li> 本地域名服务器收到请求后，查询本地缓存中是否存在域名映射的 IP 地址，若没有，则以 DNS 客户的身份向根域名服务器发出解析请求；</li>
<li> 根域名服务器收到请求后，判断该域名属于 <code>.com</code> 域，将对应的顶级域名服务器 <code>dns.com</code> 的 IP 地址返回给本地域名服务器；</li>
<li> 本地域名服务器向顶级域名服务器 <code>dns.com</code> 发出域名解析请求；</li>
<li> 顶级域名服务器 <code>dns.com</code> 收到请求后，判断该域名属于 <code>baidu.com</code> 域，故将对应的授权域名服务器 <code>dns.baidu.com</code> 的 IP 地址返回给本地域名服务器。</li>
<li> 本地域名服务器向授权域名服务器 <code>dns.baidu.com</code> 发出域名解析请求；</li>
<li> 授权域名服务器 <code>dns.baidu.com</code> 收到请求后，将查询结果 <code>map.baidu.com</code> 的 IP 地址返回给本地域名服务器；</li>
<li> 本地域名服务器将查询结果保存到本地缓存，同时返回给客户机。</li>
</ol>
<p>为提高 DNS 的查询效率，在域名服务器中广泛地使用了告诉缓存。不仅仅是本地域名服务器、包括权限域名服务器、顶级域名服务器等都使用了高速缓存。减少了因特网上 DNS 查询报文的数量。</p>
<hr>
<blockquote>
<p>  TCP连接释放</p>
</blockquote>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820102127185.png" alt="image-20210820102127185"></p>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820102054682.png" alt="image-20210820102054682"></p>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101950283.png" alt="image-20210820101950283"></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210820101643523.png" alt="image-20210820101643523"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/28/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/28/Linux/" class="post-title-link" itemprop="url">Linux</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-28 11:46:51" itemprop="dateCreated datePublished" datetime="2020-10-28T11:46:51+08:00">2020-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-06 17:54:11" itemprop="dateModified" datetime="2022-06-06T17:54:11+08:00">2022-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<ol>
<li>Linux的远程访问原理</li>
<li>Linux目录结构</li>
<li>Linux命令-文件列表-目录切换-目录的创建和删除</li>
<li>Linux命令-文件查看-文件拷贝,删除</li>
<li>Linux命令-压缩解压缩-文件查找</li>
<li>Linux命令-vim编辑器</li>
<li>Linux命令-定向输出-管道</li>
<li>Linux命令-权限控制</li>
<li>Linux命令-IP修改-域名映射</li>
</ol>
</blockquote>
<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h2><ul>
<li>  内核版本</li>
<li>  发行版本</li>
</ul>
<blockquote>
<p>  什么是 Linux 的“发行版”？</p>
</blockquote>
<p>因为 Linux 是开源（开放源代码）的，因此很多厂商都会根据自己的需求对 Linux 系统进行定制化开发，基于此衍生出了多种 Linux 系统的发行版。</p>
<blockquote>
<p>  目前国内主流的 Linux 发行版系统有哪些？</p>
</blockquote>
<ul>
<li>  RedHat</li>
<li>  Fedora</li>
<li>  CentOS</li>
<li>  Debian</li>
<li>  Ubuntu</li>
</ul>
<h2 id="终端的使用"><a href="#终端的使用" class="headerlink" title="终端的使用"></a>终端的使用</h2><ul>
<li>终端<ul>
<li>  图形终端</li>
<li>  命令行终端</li>
<li>  远程终端（SSH、VNC）</li>
</ul>
</li>
</ul>
<h1 id="Linux的远程访问"><a href="#Linux的远程访问" class="headerlink" title="Linux的远程访问"></a>Linux的远程访问</h1><p><img src="/2020/10/28/Linux/Linux%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE.png"></p>
<ol>
<li>Linux 服务器放在机房，可以被很多人访问。</li>
<li>这些访问大都不是直接访问，而是在个人 PC 上进行远程访问</li>
<li>CRT就是一款用于在个人PC上访问Linux服务器的软件。</li>
<li>在PC端使用CRT命令窗口来操作远程Linux服务器。</li>
</ol>
<h2 id="1-1-CRT初始化界面"><a href="#1-1-CRT初始化界面" class="headerlink" title="1.1    CRT初始化界面"></a>1.1    CRT初始化界面</h2><p><img src="/2020/10/28/Linux/image-20200812232446845.png" alt="image-20200812232446845"></p>
<ol>
<li><code>root</code>表示：以超级管理员身份登录并进行操作。</li>
<li><code>lnd</code>表示：当前登录的主机名称是<code>lnd</code>。</li>
<li><code>~</code>表示：家目录。<ul>
<li>如果是以root管理员身份登录的，那么<code>~</code>就表示<code>/root</code>目录。</li>
<li>如果是以普通用户的身份登录的，那么<code>~</code>就表示<code>/home</code>目录。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="文件和目录结构"><a href="#文件和目录结构" class="headerlink" title="文件和目录结构"></a>文件和目录结构</h1><p><a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/11/20/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/">超链接</a></p>
<hr>
<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p><a href>超链接</a></p>
<hr>
<h1 id="网络配置和系统管理操作"><a href="#网络配置和系统管理操作" class="headerlink" title="网络配置和系统管理操作"></a>网络配置和系统管理操作</h1><p><a href>超链接</a></p>
<hr>
<h1 id="Vi-amp-Vim-编辑器"><a href="#Vi-amp-Vim-编辑器" class="headerlink" title="Vi &amp; Vim 编辑器"></a>Vi &amp; Vim 编辑器</h1><p><a href>超链接</a></p>
<hr>
<h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><p><a href>超链接</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/14/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/14/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">MyBatis面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-10-14 21:51:25 / Modified: 21:53:36" itemprop="dateCreated datePublished" datetime="2020-10-14T21:51:25+08:00">2020-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p><strong><code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>的区别是什么？</strong></p>
<p><code>#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符串替换。</p>
<ul>
<li>Mybatis 在处理<code>#&#123;&#125;</code>时，会将sql中的<code>#&#123;&#125;</code>替换为<code>?</code>号，调用<code>PreparedStatement</code> 的<code>set()</code>方法来赋值；</li>
<li>Mybatis 在处理<code>$&#123;&#125;</code>时，就是直接把<code>$&#123;&#125;</code>替换成变量的值，也就是说有可能在这一步进行SQL注入。</li>
<li>使用<code>#&#123;&#125;</code>可以有效的防止SQL 注入，提高系统安全性。</li>
</ul>
</li>
<li><p><strong>通常一个Xml 映射文件，都会写一个Dao 接口与之对应，请问，这个Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</strong></p>
<p>​    Dao接口的全限定类名，就是映射文件中<code>MappedStatement</code>的<code>namespace</code>的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的<code>id</code>值，接口方法内的参数，就是传递给sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，<code>接口全限名+方法名</code>拼接字符串作为key 值，可唯一定位一个<code>MappedStatement</code>。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到<code>namespace </code>为<code>com.mybatis3.mappers.StudentDao</code> 下面<code>id = findStudentById</code> 的<code>MappedStatement</code>。在Mybatis 中，每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。<br>​    <em>Dao 接口里的方法，是不能重载的，因为每一个<code>全限名+方法名</code>的拼接字符串需要映射一个唯一的<code>MappedStatement</code>。</em><br>​    Dao 接口的工作原理是JDK 动态代理，Mybatis 运行时会使用JDK 动态代理为Dao接口生成代理proxy 对象， 代理对象proxy 会拦截接口方法， 转而执行MappedStatement 所代表的sql，然后将sql 执行结果返回。</p>
</li>
<li><p><strong>Mybatis 是如何进行分页的？分页插件的原理是什么？</strong></p>
<p>​    Mybatis 使用<code>RowBounds</code> 对象进行分页，它是针对<code>ResultSet</code> 结果集执行的内存分页，而非物理分页，可以在sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。分页插件的基本原理是使用Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect 方言，添加对应的物理分<br>页语句和物理分页参数。</p>
</li>
<li><p><strong>Mybatis 是如何将sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</strong></p>
<ul>
<li><p>在Java中完成：</p>
<ol>
<li>使用<code>&lt;resultType&gt;</code>标签，前提是JavaBean类中的属性和数据库中表的列名一致。</li>
<li>使用<code>&lt;resultMap&gt;</code>标签，逐一定义数据库中表的列名和JavaBean类中的属性名之间的映射关系。</li>
</ol>
</li>
<li><p>在数据库中完成：</p>
<p>​    使用SQL的别名功能，将列名的别名改为为JavaBean对象的属性名，比如在数据库中设置<code>T_NAME AS NAME</code>，JavaBean对象属性名一般是<code>name</code>，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名。</p>
</li>
</ul>
<p>​    有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
</li>
<li><p><strong>Xml 映射文件中，除了常见的<code>select|insert|update|delete</code>标签之外，还有哪些标签？</strong></p>
<p>​    还有很多其他的标签， 加上动态sql 的9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等。</p>
</li>
<li><p><strong>简述Mybatis 的插件运行原理，以及如何编写一个插件？</strong></p>
<p>​    Mybatis 仅可以编写针对<code>ParameterHandler 、ResultSetHandler 、StatementHandler、Executor</code> 这4 种接口的插件，Mybatis 使用JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4 种接口对象<br>的方法时，就会进入拦截方法，具体就是<code>InvocationHandler</code> 的<code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis 的<code>Interceptor接口</code>并复写<code>intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</p>
</li>
<li><p><strong>一级、二级缓存</strong></p>
<ul>
<li>一级缓存: 基于PerpetualCache 的HashMap 本地缓存， 其存储作用域为Session，当Session flush 或close 之后，该Session 中的所有Cache 就将清空。</li>
<li>二级缓存与一级缓存其机制相同，默认也是采用<code>PerpetualCache</code>，HashMap 存储， 不同在于其存储作用域为Mapper(Namespace)， 并且可自定义存储源， 如Ehcache。要开启二级缓存，你需要在你的SQL 映射文件中添加一行：<code>&lt;cache/&gt;</code>。</li>
<li>对于缓存数据更新机制， 当某一个作用域( 一级缓存Session/ 二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有select 中的缓存将被clear。</li>
</ul>
</li>
<li><p><strong>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</strong></p>
<p>​    Mybatis 仅支持<code>association</code>关联对象和<code>collection</code>关联集合对象的延迟加载，<code>association</code> 指的就是一对一，<code>collection</code> 指的就是一对多查询。在Mybatis 配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true|false</code>。<br>​    它的原理是，使用CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B 对象的sql，把B 查询上来，然后调<br>用a.setB(b)，于是a 的对象b 属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
</li>
<li><p><strong>Mybatis 映射文件中，如果A 标签通过<code>include</code>引用了B 标签的内容，请问，B 标签能否定义在A 标签的后面，还是说必须定义在A 标签的前面？</strong></p>
<p>​    虽然Mybatis 解析Xml 映射文件是按照顺序解析的，但是，被引用的B 标签依然<strong>可以定义在任何地方</strong>，Mybatis 都可以正确识别。<br>​    原理是，Mybatis 解析A 标签，发现A 标签引用了B 标签，但是B 标签尚未解析到，尚不存在，此时，Mybatis 会将A 标签标记为未解析状态，然后继续解析余下的标签（包含B 标签），待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
</li>
<li><p><strong>简述Mybatis 的Xml 映射文件和Mybatis 内部数据结构之间的映射关系？</strong></p>
<p>​    Mybatis 将所有Xml 配置信息都封装到All-In-One 重量级对象Configuration 内部。在Xml 映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为ParameterMap 对象，其每个子元素会被解析为ParameterMapping 对象。<code>&lt;resultMap&gt;</code>标签会被解析<code>ResultMap</code> 对象，其每个子元素会被解析为ResultMapping 对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为MappedStatement 对象，标签内的sql 会被解析为BoundSql 对象。</p>
</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/13/IO%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">IO流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-13 09:45:28" itemprop="dateCreated datePublished" datetime="2020-10-13T09:45:28+08:00">2020-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-22 13:12:27" itemprop="dateModified" datetime="2022-06-22T13:12:27+08:00">2022-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1 是什么"></a>1 是什么</h2><ul>
<li><code>java.io.File</code></li>
<li><strong>File 类的每个实例对象，代表一个文件或一个目录。</strong></li>
<li>File 类中涉及到的关于文件或目录的创建、删除、重命名、修改时间、文件大小等方法，<strong>并未涉及到写入或读取文件内容的操作</strong>。如果需要读取或写入文件内容，必须使用IO流来完成。【总之就是文件和文件夹的除了读写之外的其它相关方法】</li>
<li>File 类的对象常会作为参数传递到流的构造器中，指明读取或写入的”目的地”。</li>
<li>我们能利用 File 类实现的操作跟我们平时使用可视化界面操作文件/文件夹的操作大致上是相同的，只不过是使用代码实现而已。所以可以理解为：<strong>File 类就是利用代码操作文件/文件夹</strong>。</li>
</ul>
<blockquote>
<p>  <strong>类结构</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span> </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Comparable&lt;File&gt;	<span class="comment">// 可序列化；可比较</span></span><br></pre></td></tr></table></figure>





<h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2 构造方法"></a>2 构造方法</h2><blockquote>
<p>  <strong>常用构造方法</strong></p>
</blockquote>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507091527611-1627738403443.png" alt="image-20210507091527611"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>File(File parent, String child)</code></td>
<td align="left">根据 parent 抽象路径名和 child 路径名字符串创建一个新 <code>File</code> 实例。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>File(String parent, String child)</code></td>
<td align="left">根据 parent 路径名字符串和 child 路径名字符串创建一个新 <code>File</code> 实例</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>File(String pathname)</code></td>
<td align="left">通过将给定路径名字符串转换为抽象路径名来创建一个新 <code>File</code> 实例。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>File(URL uri)</code></td>
<td align="left">通过将给定的 <code>file: URI</code> 转换为一个抽象路径名来创建一个新的 <code>File</code> 实例</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname2</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, child);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>File 类没有无参构造方法(因为有重载的构造方法，JVM 就不再提供无参构造器了)。也就是说<strong>创建 File 实例必须指定文件/目录要保存的位置</strong>。</li>
<li>File 实例可以是一个文件或一个目录。</li>
<li><strong>创建File实例并不等价于创建了文件/目录。</strong> 创建 File 实例只是在内存中开辟了一块空间保存这个实例对象，并不会在硬盘上创建一个真实的文件或文件夹，只有进一步调用这个实例对象的 <code>mkdir()</code>、<code>mkdirs()</code> 或 <code>createNewFile()</code> 方法时才会在硬盘上创建出真正的文件/目录。</li>
</ul>
<blockquote>
<p>  <strong>路径：</strong></p>
</blockquote>
<ul>
<li>  相对路径：相较于某个路径下的路径。</li>
<li>  绝对路径：包含盘符在内的文件或文件目录的路径。</li>
</ul>
<p><strong>说明：</strong></p>
<p>在 IDEA中：</p>
<ul>
<li>  如果使用 JUnit 中的单元测试方法测试，相对路径即为当前 Module 下。</li>
<li>  如果使用 main() 测试，相对路径即为当前的Project下。</li>
</ul>
<p><strong>路径分隔符：</strong></p>
<ul>
<li>  Windows 和 DOS 系统默认使用 <code>\</code> 来表示；</li>
<li>  UNIX 和 URL 使用 <code>/</code> 来表示。</li>
</ul>
<h2 id="3-常用成员方法"><a href="#3-常用成员方法" class="headerlink" title="3 常用成员方法"></a>3 常用成员方法</h2><blockquote>
<p>  <strong>获取功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>getAbsolutePath()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取绝对路径</td>
</tr>
<tr>
<td align="left"><code>getPath()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取路径（获取的路径与创建File对象时传入的路径一致，即创建时传入相对路径此时就获取相对路径）</td>
</tr>
<tr>
<td align="left"><code>getName()</code></td>
<td align="left"><code>String</code></td>
<td align="left">返回此文件或目录名称</td>
</tr>
<tr>
<td align="left"><code>length()</code></td>
<td align="left"><code>long</code></td>
<td align="left">获取文件的长度(字节)；<strong>不能获取目录的长度</strong></td>
</tr>
<tr>
<td align="left"><code>getParent()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取上层目录，若无则返回null。</td>
</tr>
<tr>
<td align="left"><code>lastModified()</code></td>
<td align="left"><code>long</code></td>
<td align="left">获取最后一次修改时间（毫秒值）</td>
</tr>
<tr>
<td align="left"><strong>目录的遍历</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>list()</code></td>
<td align="left"><code>String[]</code></td>
<td align="left">获取指定目录下的所有文件或目录的<strong>名称数组</strong></td>
</tr>
<tr>
<td align="left"><code>listFiles()</code></td>
<td align="left"><code>File[]</code></td>
<td align="left">获取指定目录下的所有文件或目录的<strong>File数组</strong></td>
</tr>
</tbody></table>
<ul>
<li>调用<code>list</code>或<code>listFiles</code>方法遍历File对象，此时File对象必须是<strong>目录</strong>，且<strong>真实存在</strong>，否则会返回空指针异常，无法进行遍历。</li>
</ul>
<blockquote>
<p>  <strong>判断功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exists()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否存在</td>
</tr>
<tr>
<td align="center"><code>isDirectory()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否为目录。</td>
</tr>
<tr>
<td align="center"><code>isFile()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否为文件</td>
</tr>
<tr>
<td align="center"><code>canRead()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否可读</td>
</tr>
<tr>
<td align="center"><code>canWrite</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否可写</td>
</tr>
<tr>
<td align="center"><code>isHidden</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">判断是否隐藏</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>创建功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>createNewFile()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">当文件不存在时创建<strong>文件</strong>。</td>
</tr>
<tr>
<td align="center"><code>mkdir()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">创建<strong>目录</strong>。如果目录存在，不创建；如果上层目录不存在也不创建。</td>
</tr>
<tr>
<td align="center"><code>mkdirs()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">创建目录，包括任何必需但不存在的父目录。</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>注意</strong>：如果你创建的目录或文件没有写盘符路径，那么默认在项目路径下。</li>
</ul>
<blockquote>
<p><strong>mkdir()</strong> 、<strong>mkdirs()</strong> 和 <strong>createNewFile()</strong> 的区别</p>
</blockquote>
<ul>
<li><code>mkdir() / mkdirs()</code> 方法用于创建目录，<code>createNewFile()</code> 方法用于创建文件。</li>
<li>也就是说，在使用<code>mkdir() / mkdirs()</code> 方法时，即使开发人员指定名称为 <code>aaa.txt</code> ，它也不会创建出一个 <code>aaa.txt</code> 文件，而只是会创建出一个名为 <code>aaa.txt</code> 的目录。</li>
<li><code>mkdirs()</code> 方法可用于一次性创建多级目录，而 <code>mkdir()</code> 方法每次只能创建单层目录。</li>
<li>比如，要求的创建一个文件，这个文件保存在一个多层目录下，且这个多层目录中间的部分目录不存在，则创建文件和目录的方法都不会执行成功。不同的是 <strong><code>mkdir()</code> 方法即使执行不成功也不会报错，而 <code>createNewFile()</code> 方法会直接报错</strong>。报错信息如下：</li>
</ul>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507094900445.png"></p>
<blockquote>
<p>  <strong>删除功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>delete()</code></td>
<td align="center"><code>boolean</code></td>
<td align="left">删除文件或目录。删除时目录必须为空才能被删除</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>注意：</strong>Java 中的删除不走回收站。</li>
</ul>
<blockquote>
<p>  <strong>重命名功能：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>renameTo(File dest)</code></td>
<td align="center"><code>boolea</code></td>
<td align="center">文件重命名</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4 代码演示"></a>4 代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*  构造方法1   */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA&quot;</span>);</span><br><span class="line">        <span class="comment">/*  构造方法2   */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file01, <span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        <span class="comment">/*  构造方法3   */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多级目录</span></span><br><span class="line">        file02.mkdirs();</span><br><span class="line">        <span class="comment">// 创建文件（创建文件前必须先创建好文件保存的目录）</span></span><br><span class="line">        file03.createNewFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  1、获取 文件/目录 的绝对路径 */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">absoluteFile</span> <span class="operator">=</span> file03.getAbsoluteFile();</span><br><span class="line">        System.out.println(absoluteFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2、获取 文件/目录 的路径</span></span><br><span class="line"><span class="comment">        （如果创建File对象时使用的是相对路径就得到相对路径，使用的是的绝对路径就得到绝对路径） */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> file03.getPath();</span><br><span class="line">        System.out.println(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  3、获取 文件名/目录名    */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file03.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  4、获取 文件/目录 的字节长度（目录的长度为0）*/</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> file03.length();</span><br><span class="line">        System.out.println(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  5、返回该file对象目录中的所有子文件或目录的 String[] 格式 */</span></span><br><span class="line">        String[] list = file01.list();</span><br><span class="line">        Arrays.toString(list)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  6、返回该file对象目录中的所有子文件或目录的 File[] 格式  */</span></span><br><span class="line">        File[] listFiles = file01.listFiles();</span><br><span class="line">        System.out.println(listFiles);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  返回结果：</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *      G:\AAA\BBB\1.txt</span></span><br><span class="line"><span class="comment">     *      G:\AAA\BBB\1.txt</span></span><br><span class="line"><span class="comment">     *      1.txt</span></span><br><span class="line"><span class="comment">     *      0</span></span><br><span class="line"><span class="comment">     *      BBB</span></span><br><span class="line"><span class="comment">     *      [Ljava.io.File;@4c3e4790</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Path类（JDK7-）"><a href="#Path类（JDK7-）" class="headerlink" title="Path类（JDK7+）"></a>Path类（JDK7+）</h1><blockquote>
<p><strong>Path 的说明：</strong></p>
</blockquote>
<p>Path 用于替换原来的 File 类。所以说在大多数情况下，Path 和 File 的用法都是非常相似的。</p>
<blockquote>
<p><strong>如何实例化：</strong></p>
</blockquote>
<p>通过 Path 的工具类 Paths 提供的静态 get() 方法来获取 Path 实例对象。[工厂模式]</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static Path get(String first, String... more)</code></td>
<td>将多个字符串连接成文件路径</td>
</tr>
<tr>
<td><code>public static Path get(URI uri)</code></td>
<td>返回uri对应的path路径</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>常用方法：</strong></p>
</blockquote>
<p><img src="file://E:/blog/source/_posts/IO%E7%B3%BB%E7%BB%9F/image-20220622124503038.png?lastModify=1655874635" alt="image-20220622124503038"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean startsWith(String other);</code></td>
<td>判断是否以 other 路径开始</td>
</tr>
<tr>
<td><code>boolean endsWith(Path other);</code></td>
<td>判断是否以 other 路径结束</td>
</tr>
<tr>
<td><code>boolean isAbsolute();</code></td>
<td>判断是否是绝对路径</td>
</tr>
<tr>
<td><code>Path getParent();</code></td>
<td>返回的Path对象包含整个路径，但不包含Path对象指定的文件路径</td>
</tr>
<tr>
<td><code>Path getRoot();</code></td>
<td>返回调用对象的路径</td>
</tr>
<tr>
<td><code>Path getFileName();</code></td>
<td>返回与调用对象关联的文件名</td>
</tr>
<tr>
<td><code>int getNameCount();</code></td>
<td>返回Path根目录后面的元素数量(文件和文件夹的个数)</td>
</tr>
<tr>
<td><code>Path getName(int index);</code></td>
<td>返回指定索引位置index的路径名称</td>
</tr>
<tr>
<td><code>Path toAbsolutePath();</code></td>
<td>返回调用对象的绝对路径。</td>
</tr>
<tr>
<td><code>Path resolve(Path other);</code></td>
<td>合并两个路径，返回合并后的路径对应的Path对象</td>
</tr>
<tr>
<td><code>File toFile();</code></td>
<td>把Path对象转为File对象</td>
</tr>
</tbody></table>
<hr>
<h1 id="Files工具类（JDK7-）"><a href="#Files工具类（JDK7-）" class="headerlink" title="Files工具类（JDK7+）"></a>Files工具类（JDK7+）</h1><blockquote>
<p><strong>作用：</strong></p>
</blockquote>
<ul>
<li>操作文件或文件目录的工具类</li>
</ul>
<blockquote>
<p><strong>常用方法：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Path copy(Path source, Path target, CopyOption... options)</code></td>
<td>文件的复制</td>
</tr>
<tr>
<td><code>Path createDirectory(Path dir, FileAttribute&lt;?&gt;... attrs)</code></td>
<td>创建单级目录</td>
</tr>
<tr>
<td><code>Path createDirectories(Path dir, FileAttribute&lt;?&gt;... attrs)</code></td>
<td>创建多级目录</td>
</tr>
<tr>
<td><code>Path createFile(Path path, FileAttribute&lt;?&gt;... attrs)</code></td>
<td>创建一个文件</td>
</tr>
<tr>
<td><code>void delete(Path path)</code></td>
<td>删除一个文件/目录</td>
</tr>
<tr>
<td><code>deleteIfExists(Path path)</code></td>
<td></td>
</tr>
<tr>
<td><code>Path move(Path source, Path target, CopyOption... options)</code></td>
<td>移动文件/目录</td>
</tr>
<tr>
<td><code>long size(Path path)</code></td>
<td>返回path指定文件的大小</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>用于判断的方法</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean exists(Path path, LinkOption... options)</code></td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td><code>boolean isDirectory(Path path, LinkOption... options)</code></td>
<td>判断是否为目录</td>
</tr>
<tr>
<td><code>boolean isRegularFile(Path path, LinkOption... options)</code></td>
<td>判断是否为文件</td>
</tr>
<tr>
<td><code>boolean isHidden(Path path)</code></td>
<td>判断是否为隐藏文件</td>
</tr>
<tr>
<td><code>boolean isReadable(Path path)</code></td>
<td>判断文件是否可读</td>
</tr>
<tr>
<td><code>boolean isWritable(Path path)</code></td>
<td>判断文件是否可写</td>
</tr>
<tr>
<td><code>boolean notExists(Path path, LinkOption... options)</code></td>
<td>判断文件是否不存在</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>用于操作内容的方法</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SeekableByteChannel newByteChannel(Path path, OpenOption... options)</code></td>
<td>获取与指定文件的Channel通道，options指定打开方式</td>
</tr>
<tr>
<td><code>DirectoryStream&lt;Path&gt; newDirectoryStream(Path dir)</code></td>
<td>打开dir指定的目录</td>
</tr>
<tr>
<td><code>InputStream newInputStream(Path path, OpenOption... options)</code></td>
<td>获取InputStream对象</td>
</tr>
<tr>
<td><code>OutputStream newOutputStream(Path path, OpenOption... options)</code></td>
<td>获取OutputStream对象</td>
</tr>
</tbody></table>
<hr>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1. 是什么？"></a>1. 是什么？</h2><ul>
<li><strong>IO 流就是数据的流动。</strong></li>
<li>我们把数据的传输，看做是一种数据的流动，按照流动的方向，以<strong>内存为基准</strong>，可分为输入流和输出流。即流向内存为输入流，流出内存为输出流。</li>
<li>输入也叫做<strong>读取数据</strong>，输出也叫做<strong>写出数据</strong>。</li>
</ul>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/IO.png" alt="IO"></p>
<h2 id="2-IO的分类"><a href="#2-IO的分类" class="headerlink" title="2. IO的分类"></a>2. IO的分类</h2><ol>
<li> 按数据流向分类：<strong>输入流</strong>、<strong>输出流</strong></li>
<li> 按操作数据的单位分类：<strong>字节流</strong>、<strong>字符流</strong></li>
</ol>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/IO%E5%88%86%E7%B1%BB.png"></p>
<hr>
<h2 id="3-流的体系结构"><a href="#3-流的体系结构" class="headerlink" title="3. 流的体系结构"></a>3. 流的体系结构</h2><blockquote>
<p>  <strong>顶级父类</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center"><code>InputStream</code></td>
<td align="center"><code>OutputStream</code></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center"><code>Reader</code></td>
<td align="center"><code>Writer</code></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>体系结构</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td><strong>抽象基类</strong></td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td><strong>访问文件</strong></td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td><strong>缓冲流</strong></td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td><strong>访问数组</strong></td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td><strong>访问管道</strong></td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td><strong>访问字符串</strong></td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td><strong>转换流</strong></td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td><strong>对象流</strong></td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>打印流</strong></td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td><strong>推回输入流</strong></td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td><strong>特殊流</strong></td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>常用结构</strong></p>
<ul>
<li>顶级父类：<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code></li>
<li>文件流：<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>、<code>FileWriter</code></li>
<li>缓冲流：<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code></li>
<li>转换流：InputStreamReader  OutputStreamWriter</li>
<li>对象流：ObjectInputStream  ObjectOutputStream</li>
</ul>
<hr>
<h2 id="4-输入-输出的标准化过程"><a href="#4-输入-输出的标准化过程" class="headerlink" title="4. 输入/输出的标准化过程"></a>4. 输入/输出的标准化过程</h2><h3 id="输入过程"><a href="#输入过程" class="headerlink" title="输入过程"></a>输入过程</h3><ol>
<li><p> 创建 File 类对象，指明读取的数据的来源（要求此文件一定要存在）；</p>
</li>
<li><p> 创建相应的输入流，将 File 类的对象作为参数，传入流的构造器中</p>
</li>
<li><p> 具体的读入过程；</p>
</li>
<li><p> 关闭流资源。</p>
</li>
</ol>
<p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理。</p>
<h3 id="输出过程"><a href="#输出过程" class="headerlink" title="输出过程"></a>输出过程</h3><ol>
<li><p> 创建 File 类对象，指明写出的数据的位置（不要求此文件一定要存在，如不存在在写出前会自动创建）；</p>
</li>
<li><p> 创建相应的输出流，将 File 类的对象作为参数传入流的构造器中；</p>
</li>
<li><p> 具体的写出过程；</p>
</li>
<li><p> 关闭流资源。</p>
</li>
</ol>
<p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>  <strong>流的关闭原则：</strong></p>
</blockquote>
<ul>
<li>  <strong>先开后关，后开先关。</strong></li>
<li>  <strong>先关闭外层的流，再关闭内层的流。</strong></li>
<li>  说明：关闭外层流的同时，内层流也会自动的进行关闭。</li>
</ul>
<hr>
<h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="1-一切皆为字节流"><a href="#1-一切皆为字节流" class="headerlink" title="1. 一切皆为字节流"></a>1. 一切皆为字节流</h2><ul>
<li>  所有文件（文本、图片、视频等）底层都是以二进制形式保存在计算机中的，可以看做一个个的字节，传输时同样如此。</li>
<li>  所以，字节流可以传输任意文件数据。    </li>
<li>  在操作流时，我们要时刻明确，无论使用什么样的流对象，底层传输的始终是二进制数据。</li>
</ul>
<h2 id="2-OutputStream"><a href="#2-OutputStream" class="headerlink" title="2. OutputStream"></a>2. OutputStream</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul>
<li><code>java.io.OutputStream</code>是<strong>抽象类</strong>，表示所有字节输出流类的超类。</li>
<li> 作用：将指定的字节信息写出到目的地。</li>
<li> 类中声明了所有字节输出流子类要实现的公共方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.io.OutputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	OutputStream  	*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	FileOutputStream	*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><ul>
<li>OutputStream 是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>OutputStream 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="2-3-成员方法"><a href="#2-3-成员方法" class="headerlink" title="2.3 成员方法"></a>2.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507104001127.png" alt="image-20210507104001127"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="left">关闭输出流，释放系统资源。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>flush()</code></td>
<td align="center"><code>void</code></td>
<td align="left">刷新此输出流并强制任何缓冲的输出字节流被写出。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>write(byte[] b)</code></td>
<td align="center"><code>void</code></td>
<td align="left">将字节数组b的内容写出到指定的文件中</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>write(byte[] b, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">将字节数组b中的指定内容写出到指定的文件中</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>write()[abstract]</code></td>
<td align="center"><code>void</code></td>
<td align="left">将该字节输出流写出到目的地。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：当完成流的操作时，必须调用<code>close()</code>方法，释放系统资源。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	源码中的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    write(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">               ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">        write(b[off + i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-InputStream"><a href="#3-InputStream" class="headerlink" title="3. InputStream"></a>3. InputStream</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.io.InputStream</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>java.io.InputStream</code>是抽象类，是所有字节输入流的类的超类。</li>
<li>作用：读取字节信息到内存中。</li>
<li>类中声明了所有字节输入流子类要实现的公共方法。</li>
<li>当完成了流的操作时，必须调用<code>close()</code>方法，释放系统资源。</li>
</ul>
<h3 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h3><ul>
<li>InputStream 是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>InputStream 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="3-3-成员方法"><a href="#3-3-成员方法" class="headerlink" title="3.3 成员方法"></a>3.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507135331635.png" alt="image-20210507135331635"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="left">关闭流，释放相关资源</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>read()[abstract]</code></td>
<td align="center"><code>int</code></td>
<td align="left">从输入流中读取数据的下一个字节</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>read(byte[] b)</code></td>
<td align="center"><code>int</code></td>
<td align="left">从输入流中读取一些字节数，并把它们存储到字节数组b中</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>read(byte b[], int off, int len)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h2 id="1-Reader"><a href="#1-Reader" class="headerlink" title="1. Reader"></a>1. Reader</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Readable</span>, Closeable</span><br></pre></td></tr></table></figure>

<ol>
<li> <code>java.io.Reader</code>是抽象类，是所有字符输入流类的超类。可以读取字符信息到内存中。</li>
<li> 类中定义了所有字符输入流子类要实现的公共方法。</li>
<li> <strong>字符流只能操作文本文件，不能操作图片、视频等非文本文件。</strong></li>
</ol>
<blockquote>
<p>  <strong>字节流操作文本文件可能存在的问题及解决方案：</strong></p>
</blockquote>
<p>当使用字节流读取文本文件时，在遇到中文字符时，可能不会显示完整的字符。因为一个中文字符根据不同的编码规则可能占 2~3 个字节不等，而字节流读取是以单个字节为单位的，会出现一种情况就是：一个中文字符占了 3 个字节，使用字节流读取时会把这 3 个字节分开来展示，这样就会出现乱码。</p>
<p>所以 Java 提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h3 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><ul>
<li>Reader 是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>Reader 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="1-3-成员方法"><a href="#1-3-成员方法" class="headerlink" title="1.3 成员方法"></a>1.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141214703.png" alt="image-20210507141214703"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>read()</code></td>
<td align="center"><code>int</code></td>
<td align="center">从输入流中读取一个<strong>字符</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>read(char[] cbuf)</code></td>
<td align="center"><code>int</code></td>
<td align="center">从输入流中读取一些字符，并将它们存储到字符数组<code>cbuf</code>中。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-Writer"><a href="#2-Writer" class="headerlink" title="2. Writer"></a>2. Writer</h2><h3 id="2-1-概述-1"><a href="#2-1-概述-1" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Writer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable, Flushable</span><br></pre></td></tr></table></figure>

<ol>
<li> <code>java.io.Writer</code>是抽象类，是所有写出字符流类的超类。负责将指定的字符信息写出到目的地。</li>
<li> 类中定义了所有字符输出流子类要实现的公共方法。</li>
</ol>
<h3 id="2-2-构造方法-1"><a href="#2-2-构造方法-1" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><ul>
<li>  Writer 类是一个抽象类，不能直接 new 一个对象，但可以接收 new 出来的子类对象（多态）。</li>
<li>  Writer 类中没有重载构造方法，使用 JVM 提供的默认无参构造器！</li>
</ul>
<h3 id="2-3-成员方法-1"><a href="#2-3-成员方法-1" class="headerlink" title="2.3 成员方法"></a>2.3 成员方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141914198.png" alt="image-20210507141914198"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>write(int c)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入单个字符</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>write(char[] cbuf)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符数组</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>write(char[] cbuf, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符数组的某一部分</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>write(String str)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符串</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>write(String str, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写入字符串的某一部分</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><code>flush()</code></td>
<td align="center"><code>void</code></td>
<td align="left">刷新该流的缓冲</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left"><code>close()</code></td>
<td align="center"><code>void</code></td>
<td align="left">关闭此流，关闭前先刷新一次</td>
</tr>
</tbody></table>
<hr>
<h1 id="文件流-FileStream"><a href="#文件流-FileStream" class="headerlink" title="文件流(FileStream)"></a>文件流(FileStream)</h1><blockquote>
<p><strong>总纲：</strong></p>
<ul>
<li>凡是数据传输，必然涉及到两个端点（一个出发点 <code>src</code>，一个目的地 <code>dest</code>），一个管道（用于传输数据）。</li>
<li>File 是出发点/目的地，流(Stream) 是管道。</li>
</ul>
</blockquote>
<h2 id="1-FileOutputStream"><a href="#1-FileOutputStream" class="headerlink" title="1. FileOutputStream"></a>1. FileOutputStream</h2><h3 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><blockquote>
<p>  <strong>作用：</strong></p>
</blockquote>
<p><code>FileOutputStream</code> 是文件输出流类，用于<strong>将内存中的数据写出到磁盘中的文件上</strong>。</p>
<blockquote>
<p>  <strong>体系结构：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="1-2-构造方法-1"><a href="#1-2-构造方法-1" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507113455730.png" alt="image-20210507113455730"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>FileOutputStream(File file)</code></td>
<td align="left">创建文件输出流对象，并指定写出到哪个文件中。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>FileOutputStream(String name)</code></td>
<td align="left">创建文件输出流对象，并指定写出到哪个文件中。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>FileOutputStream(File file, boolean append)</code></td>
<td align="left">数据是否可追加续写</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>FileOutputStream(String name, boolean append)</code></td>
<td align="left">数据是否可追加续写</td>
</tr>
</tbody></table>
<p><strong>总结：</strong>在创建字节输出流对象 <code>FileOutputStream</code> 时，必须指定该流对象写出数据的目的地（可以是一个 File 对象，也可以是一个 String 类型的路径）。 <strong>在该路径下，如果没有这个文件，会自动创建该文件</strong>。</p>
<hr>
<h3 id="1-3-成员方法-1"><a href="#1-3-成员方法-1" class="headerlink" title="1.3 成员方法"></a>1.3 成员方法</h3><p><strong>作用：</strong>将字节数据写出到磁盘的文件上</p>
<ul>
<li>  根据编码表把待输出的数据转换成字节数据，再使用<code>write()</code>方法写出到指定文件中。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>write(int b)</code></td>
<td align="center"><code>void</code></td>
<td align="left">通过编码表将<code>int</code>类型的数据转换为字节数据<br>并写出到指定文件中，每次写出一个字节数据。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>write(byte[] b)</code></td>
<td align="center"><code>void</code></td>
<td align="left">将整个<code>byte</code>数组中的字节数据写出到指定文件中。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>write(byte[] b, int off, int len)</code></td>
<td align="center"><code>void</code></td>
<td align="left">写出<code>byte</code>数组中指定范围的子数组</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*  1、创建一个 File 对象，当做字节输出流写出数据的目的地  */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        file.createNewFile(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2、创建字节输出流对象，并指定输出的目的地 */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        fos.write(<span class="number">97</span>);	<span class="comment">// 十进制的整型数据会被转换为byte类型数据写出到指定文件中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  3、关闭字节输出流对象 */</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  输出结果为：</li>
</ul>
<img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507134152996.png" alt="image-20210507134152996">



<blockquote>
<p>  <strong>写出换行</strong></p>
</blockquote>
<ul>
<li>Windows 中，换行符号是 <code>/r/n</code>；<ul>
<li>  分析：<code>/r</code> 是回车符，回到一行的开头（<strong>return</strong>）；<code>/n</code> 是换行符，进入下一行（<strong>newline</strong>）</li>
</ul>
</li>
<li>  Unix 中，换行符是 <code>/n</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*  1、创建一个 File 对象，当做字节输出流写出数据的目的地  */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        file.createNewFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2、创建字节输出流对象，并指定输出的目的地 */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        <span class="type">byte</span>[] br = <span class="string">&quot;\r\n&quot;</span>.getBytes();  <span class="comment">// 换行符的byte类型表示</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> aByte : bytes) &#123;</span><br><span class="line">            fos.write(aByte);</span><br><span class="line">            fos.write(br);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  3、关闭字节输出流对象 */</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507134827165.png" alt="image-20210507134827165">







<hr>
<h2 id="2-FileInputStream"><a href="#2-FileInputStream" class="headerlink" title="2. FileInputStream"></a>2. FileInputStream</h2><h3 id="2-1-概述-2"><a href="#2-1-概述-2" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><blockquote>
<p>  <strong>作用：</strong></p>
</blockquote>
<ul>
<li>  FileInputStream 是文件输入流，用于从文件中读取数据写到内存中。</li>
</ul>
<blockquote>
<p>  <strong>体系结构：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-构造方法-2"><a href="#2-2-构造方法-2" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507135646091.png" alt="image-20210507135646091"></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>FileInputStream(File file)</code></td>
<td align="left">通过建立与实际文件的连接来创建一个 FileInputStream 对象</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>FileInputStream(String name)</code></td>
<td align="left">通过建立与实际文件的连接来创建一个 FileInputStream 对象</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>  当你<strong>创建 <code>FileInputStream</code> 流对象时，必须传入一个文件路径。</strong></li>
<li>  该路径下，如果没有该文件，会抛出 <code>FileNotFoundException</code> 异常。</li>
</ul>
<h3 id="2-3-成员方法-2"><a href="#2-3-成员方法-2" class="headerlink" title="2.3 成员方法"></a>2.3 成员方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>read()</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次从文件中读取一个字节的数据，并自动提升为<code>int</code>类型，<strong>读取到文件末尾，返回-1</strong></td>
</tr>
<tr>
<td align="left"><code>read(byte[] b)</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次从文件中读取<code>b.length</code>个字节的数据到数组 b 中，并返回读取到的有效字节<strong>个数</strong>，<br><strong>读取到末尾时，返回-1</strong></td>
</tr>
</tbody></table>
<h3 id="2-4-代码演示"><a href="#2-4-代码演示" class="headerlink" title="2.4 代码演示"></a>2.4 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\AAA\\BBB&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*  1、创建字节输入流对象 */</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2.1、读取文件内容    */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();  <span class="comment">// read() 方法每次只能读取一个字节的数据，读取到文件末尾，返回-1</span></span><br><span class="line">        System.out.println(read);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  2.2、读取多个字节数据(一个一个读)    */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (fis.read() != -<span class="number">1</span>)&#123;</span><br><span class="line">            result.add(fis.read());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  3、关闭字节输入流   */</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-练习：图片复制"><a href="#3-练习：图片复制" class="headerlink" title="3. 练习：图片复制"></a>3. 练习：图片复制</h2><blockquote>
<p>  <strong>分析：</strong></p>
</blockquote>
<ul>
<li>step1：通过 InputStream 流将源图片的字节码数据读到内存中；</li>
<li>setp2：通过 OutputStream 流将内存中的图片数据写到目的文件中。</li>
</ul>
<blockquote>
<p>  <strong>代码实现：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建 File 对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;demo.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;demo_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.建流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);	<span class="comment">// 最后一次读取到的数据长度可能小于5</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="4-FileReader"><a href="#4-FileReader" class="headerlink" title="4. FileReader"></a>4. FileReader</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote>
<p>  <strong>体系结构</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |- java.io.Reader</span><br><span class="line">      |- java.io.InputStreamReader</span><br><span class="line">          |- java.io.FileReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span></span><br></pre></td></tr></table></figure>

<p>创建 FileReader 实例对象时使用系统默认的字符编码和默认字节缓冲区。</p>
<ul>
<li>字符编码：字节与字符的对应规则。Windows 系统的中文编码默认是GBK编码表；IDEA中默认<code>UTF-8</code>。</li>
<li>字节缓冲区：一个字节数组，用来临时存储字节数据。</li>
</ul>
<h3 id="4-2-构造方法"><a href="#4-2-构造方法" class="headerlink" title="4.2 构造方法"></a>4.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141402352.png" alt="image-20210507141402352"></p>
<table>
<thead>
<tr>
<th align="left">构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FileReader(File file)</code></td>
</tr>
<tr>
<td align="left"><code>FileReader(String fileName)</code></td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ul>
<li>  当你创建一个<code>FileReader</code>流对象时，必须传入一个文件路径。</li>
</ul>
<hr>
<h3 id="4-3-成员方法"><a href="#4-3-成员方法" class="headerlink" title="4.3 成员方法"></a>4.3 成员方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>read()</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次读取<strong>一个字符</strong>的数据，提升为 <code>int</code> 型，读到文件末尾返回-1</td>
</tr>
<tr>
<td align="left"><code>read(char[] cbuf)</code></td>
<td align="center"><code>int</code></td>
<td align="left">每次读取<code>cbuf.length</code>个字符到数组中，返回读取到的字符个数，读取到末尾时返回-1.</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-4-代码演示"><a href="#4-4-代码演示" class="headerlink" title="4.4 代码演示"></a>4.4 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</span></span><br><span class="line"><span class="comment">	2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">	3. 读的文件一定要存在，否则就会报 FileNotFoundException。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.File类的实例化</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.读入的操作</span></span><br><span class="line">        <span class="comment">// read(char[] cbuf)：返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">            <span class="comment">// 错误的写法，最后一次读到的数据可能小于 cbuf.length</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; cbuf.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正确的写法</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                System.out.print(cbuf[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">// 错误的写法,对应着方式一的错误的写法</span></span><br><span class="line"><span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line">            <span class="comment">//正确的写法</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.资源的关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="5-FileWriter"><a href="#5-FileWriter" class="headerlink" title="5. FileWriter"></a>5. FileWriter</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><blockquote>
<p>  <strong>作用</strong></p>
</blockquote>
<p><code>java.io.FileWriter</code> 是从内存中写出字符数据到文件中的类，构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>  <strong>体系结构</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |- java.io.Writer</span><br><span class="line">      |- java.io.OutputStreamWriter  </span><br><span class="line">          |- java.io.FileWriter</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-2-构造方法"><a href="#5-2-构造方法" class="headerlink" title="5.2 构造方法"></a>5.2 构造方法</h3><p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210507141942042.png" alt="image-20210507141942042"></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FileWriter(File file)</code></td>
</tr>
<tr>
<td align="left"><code>FileWriter(String fileName)</code></td>
</tr>
<tr>
<td align="left"><code>FileWriter(File file, boolean append)</code></td>
</tr>
<tr>
<td align="left"><code>FileWriter(String fileName, boolean append)</code></td>
</tr>
</tbody></table>
<h3 id="5-3-成员方法"><a href="#5-3-成员方法" class="headerlink" title="5.3 成员方法"></a>5.3 成员方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>写出数据</strong></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>write(int b)</code></td>
<td align="center"></td>
<td align="left">每次写一个字符大小的数据</td>
</tr>
<tr>
<td align="left"><code>write(char[] cbuf)</code></td>
<td align="center"></td>
<td align="left">每次最多可以写出<code>cbuf.length</code>个字符的数据</td>
</tr>
<tr>
<td align="left"><code>write(char[] cbuf, int off, int len)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>write(String str)</code></td>
<td align="center"></td>
<td align="left">底层会先将 String 转换为 char[] 数组，再写出</td>
</tr>
<tr>
<td align="left"><code>write(String str, int off, int len)</code></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>关闭和刷新</strong></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>flush()</code></td>
<td align="center"></td>
<td align="left">将缓冲区中的数据强制刷写到文件中</td>
</tr>
<tr>
<td align="left"><code>close()</code></td>
<td align="center"></td>
<td align="left">先刷新缓冲区，然后通知系统释放资源</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>关闭和刷新</strong></p>
</blockquote>
<p>因为 <strong><code>FileWriter</code>类内置缓冲区</strong>的原因，写出数据时首先会被写出到缓冲区中，如果不进行刷新的话，是无法写入到文件中的。</p>
<ul>
<li><code>flush()</code>：将缓冲区中的数据强制刷写到文件中；</li>
<li><code>close()</code>：先刷新缓冲区，然后通知系统释放资源。</li>
</ul>
<hr>
<h3 id="5-4-代码演示"><a href="#5-4-代码演示" class="headerlink" title="5.4 代码演示"></a>5.4 代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从内存中写出数据到硬盘的文件里。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	1. 输出操作，目的地的File可以不存在。并不会报异常</span></span><br><span class="line"><span class="comment">	2. </span></span><br><span class="line"><span class="comment">	File对应的文件如果不存在，FileWriter 在写出数据时，会自动创建此文件。</span></span><br><span class="line"><span class="comment">	File对应的硬盘中的文件如果存在：</span></span><br><span class="line"><span class="comment">		如果输出流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原文件的覆盖</span></span><br><span class="line"><span class="comment">		如果输出流使用的构造器是：FileWriter(file,true):不会对原文件覆盖，而是在原文件基础上追加内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="6-练习：文本文件复制"><a href="#6-练习：文本文件复制" class="headerlink" title="6. 练习：文本文件复制"></a>6. 练习：文本文件复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能使用字符流来处理图片等字节数据</span></span><br><span class="line"><span class="comment">//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span></span><br><span class="line"><span class="comment">//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.数据的读入和写出操作</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 每次写出len个字符</span></span><br><span class="line">            fw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.关闭流资源</span></span><br><span class="line">        <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                if(fw != null)</span></span><br><span class="line"><span class="comment">//                    fw.close();</span></span><br><span class="line"><span class="comment">//            &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;finally&#123;</span></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    if(fr != null)</span></span><br><span class="line"><span class="comment">//                        fr.close();</span></span><br><span class="line"><span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>  对于文本文件(<code>.txt</code>、<code>.java</code>、<code>.c</code>、<code>.cpp</code> 等)，使用字符流处理</li>
<li>  对于非文本文件(<code>.jpg</code> 、<code>.mp3</code>、<code>.mp4</code>、<code>.avi</code>、<code>.doc</code>、<code>.ppt </code>等)，使用字节流处理</li>
</ul>
<hr>
<h1 id="缓冲流-BufferStream"><a href="#缓冲流-BufferStream" class="headerlink" title="缓冲流(BufferStream)"></a>缓冲流(BufferStream)</h1><blockquote>
<p><strong>缓冲流涉及到的类</strong></p>
</blockquote>
<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
<blockquote>
<p><strong>作用</strong></p>
</blockquote>
<ul>
<li>  提高流的读取、写入的速度；</li>
<li>  提高读写速度的<strong>原因</strong>：内部提供了一个缓冲区。默认情况下是 <strong>8kb</strong>。</li>
</ul>
<img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210801152442138.png" alt="image-20210801152442138" style="zoom: 67%;">

<p><strong>Tip：</strong>不光是 BufferedInputStream，包括 BufferedOutputStream、BufferedWriter、BufferedReader 在内的所有缓冲流类的默认缓冲区大小都是 <code>8192 Byte</code>。</p>
<blockquote>
<p><strong>使用 BufferedInputStream 和 BufferedOutputStream 处理非文本文件（字节流）</strong></p>
</blockquote>
<p>需求：实现文件复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.造流</span></span><br><span class="line">        <span class="comment">// 2.1 造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">// 2.2 造缓冲流【缓冲流是对文件流的又一层包装，这里采用了装饰器模式】</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.复制的细节：读取、写入</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">//字节</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.资源关闭</span></span><br><span class="line">        <span class="comment">// 要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span></span><br><span class="line">        <span class="comment">//        fos.close();</span></span><br><span class="line">        <span class="comment">//        fis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用BufferedReader和BufferedWriter 处理文本文件(字符流)</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建文件和相应的流</span></span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读写操作</span></span><br><span class="line">        <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line"><span class="comment">//            char[] cbuf = new char[1024]; //字符</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line"><span class="comment">//    //            bw.flush();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 方法一：</span></span><br><span class="line"><span class="comment">//                bw.write(data + &quot;\n&quot;); // data中不包含换行符</span></span><br><span class="line">            <span class="comment">// 方法二：</span></span><br><span class="line">            bw.write(data);		<span class="comment">// data中不包含换行符</span></span><br><span class="line">            bw.newLine();	<span class="comment">// 提供换行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="转换流-TransferStream"><a href="#转换流-TransferStream" class="headerlink" title="转换流(TransferStream)"></a>转换流(TransferStream)</h1><p>转换流的作用就是提供<strong>字节流与字符流之间的转换功能</strong>。</p>
<blockquote>
<p><strong>转换流涉及到的类：</strong></p>
</blockquote>
<ul>
<li>  OutputStreamWriter</li>
<li>  InputStreamReader</li>
</ul>
<p><strong>这两个转换流都属于字符流！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> </span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>InputStreamReader：</strong></p>
</blockquote>
<ul>
<li>  顾名思义，就是 InputStream To Reader；</li>
<li>  <strong>作用：</strong>将一个字节的输入流转换为字符的输入流</li>
<li>  <strong>解码：</strong><code>字节、字节数组 ---&gt; 字符数组、字符串</code></li>
<li>  字节流是我们不能识别的，字符流是我们很容易识别的。将不认识的转为认识的叫<strong>解码</strong>，将认识的转为不认识的叫<strong>编码</strong>。</li>
</ul>
<blockquote>
<p>  <strong>OutputStreamWriter：</strong></p>
</blockquote>
<ul>
<li>  <strong>作用：</strong>是从字符流到字节流的桥梁，作用是将一个字符的输出流转换为字节的输出流</li>
<li>  <strong>编码：</strong><code>字符数组、字符串 ---&gt; 字节、字节数组</code></li>
</ul>
<blockquote>
<p>  <strong>作用：</strong></p>
</blockquote>
<p>提供字节流与字符流之间的转换。</p>
<p><img src="/2020/10/13/IO%E7%B3%BB%E7%BB%9F/image-20210801154712518.png" alt="image-20210801154712518"></p>
<blockquote>
<p>  <strong>说明：</strong></p>
</blockquote>
<ul>
<li>  编码方式决定了解码的方式。</li>
<li>  文件编码的方式（比如：GBK），决定了解析时使用的字符集（也只能是GBK）。</li>
</ul>
<blockquote>
<p>  <strong>Demo1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取到内存中的 fis 保存了字节流数据</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用系统默认的字符集（GBK）解码</span></span><br><span class="line"><span class="comment">//        InputStreamReader isr = new InputStreamReader(fis);	</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);	<span class="comment">// 使用指定字符集解码</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        System.out.print(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Demo2</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1.造文件、造流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.读写过程</span></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.关闭资源</span></span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="对象流-ObjectStream"><a href="#对象流-ObjectStream" class="headerlink" title="对象流(ObjectStream)"></a>对象流(ObjectStream)</h1><blockquote>
<p><strong>对象流涉及的类</strong></p>
</blockquote>
<ul>
<li>ObjectInputStream<ul>
<li>  <strong>序列化：</strong>内存中的 Java 对象 <code>--&gt;</code> 磁盘上的文件 / 通过网络传输出去</li>
</ul>
</li>
<li>ObjectOutputStream<ul>
<li>  <strong>反序列化：</strong>磁盘上的文件/通过网络接收的文件 <code>--&gt;</code> 内存中的对象</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>对象的序列化/反序列化机制</strong></p>
</blockquote>
<ul>
<li>  对象序列化机制允许把内存中的 Java 对象转换成平台无关的二进制流，从而把这种二进制流持久地保存在磁盘（文件）上，或通过网络将这种二进制流传输到另一个网络节点。</li>
<li>  当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。【反序列化】</li>
</ul>
<blockquote>
<p><strong>实现序列化的对象需要满足的条件</strong></p>
</blockquote>
<ul>
<li>需要实现接口 Serializable；</li>
<li>当前类提供一个全局常量：serialVersionUID；</li>
<li><strong>除了当前类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。</strong><ul>
<li>默认情况下，基本数据类型都是可序列化的。</li>
<li>如果属性中包含了另外的类，则要求也必须是可序列化的。</li>
</ul>
</li>
</ul>
<p><strong>补充：</strong><code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> <strong>不能序列化 static 和 transient 修饰的成员变量</strong>。</p>
<blockquote>
<p>  <strong>序列化代码实现：</strong></p>
<ul>
<li>将内存中的 Java 对象保存到磁盘中或通过网络传输出去。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出 String 对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出自定义对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王路飞&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;黄猿&quot;</span>, <span class="number">48</span>, <span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>反序列化代码实现：</strong></p>
<ul>
<li>将磁盘文件中的对象还原为内存中的一个Java对象</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="随机存取文件流-RandomAccessFile"><a href="#随机存取文件流-RandomAccessFile" class="headerlink" title="随机存取文件流(RandomAccessFile)"></a>随机存取文件流(RandomAccessFile)</h1><blockquote>
<p>  <strong>随机存取文件流：RandomAccessFile</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFile</span> <span class="keyword">implements</span> <span class="title class_">DataOutput</span>, DataInput, Closeable &#123;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>使用说明：</strong></p>
</blockquote>
<ul>
<li><code>RandomAccessFile</code> 直接继承于 <code>java.lang.Object</code> 类，实现了 <code>DataInput</code> 和 <code>DataOutput</code> 接口；</li>
<li><code>RandomAccessFile</code> <strong>既可以作为一个输入流，又可以作为一个输出流</strong>；<ul>
<li>所以，在大多数情况下，RandomAccessFile 和 InputStream/OutputStream 的用法是类似的。</li>
</ul>
</li>
<li><code>RandomAccessFile</code> 作为输出流时，如果写出到的文件不存在，则在执行过程中自动创建。</li>
<li>如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</li>
<li>可以通过相关的操作，使用 <code>RandomAccessFile</code> 的 API 实现 “<strong>插入</strong>”数据的效果。<code>seek(int pos)</code></li>
</ul>
<blockquote>
<p>  <strong>Demo1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;	</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         </span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf2.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Demo2：使用RandomAccessFile实现数据的插入效果</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);	<span class="comment">// &quot;rw&quot; 是一种模式，表示读写</span></span><br><span class="line"></span><br><span class="line">    raf1.seek(<span class="number">3</span>);	<span class="comment">// 将指针调到角标为3的位置</span></span><br><span class="line">    <span class="comment">// 保存指针3后面的所数据到StringBuilder中</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调回指针，写入“xyz”</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 StringBuilder 中的数据写入到文件中</span></span><br><span class="line">    raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">    raf1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="其它流"><a href="#其它流" class="headerlink" title="其它流"></a>其它流</h1><h2 id="1-标准的输入输出流"><a href="#1-标准的输入输出流" class="headerlink" title="1 标准的输入输出流"></a>1 标准的输入输出流</h2><blockquote>
<p>  <strong>System.in</strong></p>
</blockquote>
<p>标准的输入流，默认从键盘输入（从键盘输入的数据传输到内存中）</p>
<blockquote>
<p>  <strong>System.out</strong></p>
</blockquote>
<p>标准的输出流，默认从控制台输出（内存中的数据输出到控制台上显示）</p>
<blockquote>
<p>  <strong>修改默认的输入和输出行为：</strong></p>
</blockquote>
<p>通过 System 类的 <code>setIn(InputStream is) / setOut(PrintStream ps)</code>方式重新指定输入流和输出流的行为。</p>
<h2 id="2-打印流"><a href="#2-打印流" class="headerlink" title="2 打印流"></a>2 打印流</h2><ul>
<li>  <strong>PrintStream</strong></li>
<li>  <strong>PrintWriter</strong></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>  提供了一系列重载的 <code>print()</code> 和 <code>println()</code> 方法，用于多种数据类型的输出。</li>
<li>  <code>System.out</code> 返回的是 PrintStream 的实例</li>
</ul>
<h2 id="3-数据流"><a href="#3-数据流" class="headerlink" title="3 数据流"></a>3 数据流</h2><ul>
<li>  <strong>DataInputStream</strong></li>
<li>  <strong>DataOutputStream</strong></li>
</ul>
<p><strong>作用：</strong>用于读取或写出基本数据类型的变量或字符串。</p>
<blockquote>
<p>  <strong>Demo1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	练习：将内存中的字符串、基本数据类型的变量写出到(文件)中。</span></span><br><span class="line"><span class="comment">	注意：处理异常的话，仍然应该使用try-catch-finally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    dos.writeUTF(<span class="string">&quot;圣诞树&quot;</span>);</span><br><span class="line">    dos.flush();	<span class="comment">// 刷新操作，将内存中的数据写入文件</span></span><br><span class="line">    dos.writeInt(<span class="number">23</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Demo2</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment">	注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">    System.out.println(<span class="string">&quot;isMale = &quot;</span> + isMale);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.Dictionary&lt;K,V&gt;</span><br><span class="line">    继承者 java.util.Hashtable&lt;Object,Object&gt;		<span class="comment">// !!!</span></span><br><span class="line">    	继承者 java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Properties</code> 类表示一个持久的<strong>属性集</strong>。</li>
<li>它使用<strong>键值对</strong>结构存储数据，每个键及其对应的值都是一个字符串。</li>
<li><strong>总结：</strong>Properties 可以当做一个 HashMap 来使用，只不过其内部定义了一些特有的方法要比 HashMap 操作更丰富。</li>
</ol>
<h2 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2 构造方法"></a>2 构造方法</h2><table>
<thead>
<tr>
<th align="left">构造方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Properties()</code></td>
<td align="left">创建一个空的属性列表</td>
</tr>
<tr>
<td align="left"><code>Properties(Properties default)</code></td>
<td align="left">创建一个带有指定默认值的空属性列表</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">(Properties defaults)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaults = defaults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3 成员方法"></a>3 成员方法</h2><table>
<thead>
<tr>
<th align="center">ID</th>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><code>setProperties(String key, String value)</code></td>
<td align="center"><code>Object</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>getProperties(String key)</code></td>
<td align="center"><code>String</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><code>stringPropertyNames()</code></td>
<td align="center"><code>Set&lt;String&gt;</code></td>
<td align="left">获取所有键的名称的集合</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>load(InputStream inStream)</code></td>
<td align="center"><code>void</code></td>
<td align="left">从字节输入流中获取键值对</td>
</tr>
</tbody></table>
<h3 id="3-1-与流相关的方法"><a href="#3-1-与流相关的方法" class="headerlink" title="3.1 与流相关的方法"></a>3.1 与流相关的方法</h3><blockquote>
<p>  <strong>public void load(InputStream inputStream)</strong></p>
</blockquote>
<ul>
<li>  字节流中的数据都是从外部存储设备读取到内存中的，而 <code>Properties</code> 类又可以读取 <code>InputStream</code> 中的数据，这样 <code>Properties</code> 就可以间接的加载外部存储设备中的文本数据了。</li>
<li>  但是 <strong>Properties 类只能加载文本数据格式为键值对的形式</strong>，常见的有 <code>.properties</code>或<code>.yml</code> 文件。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-10 21:35:12" itemprop="dateCreated datePublished" datetime="2020-10-10T21:35:12+08:00">2020-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-09-27 21:08:59" itemprop="dateModified" datetime="2021-09-27T21:08:59+08:00">2021-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-程序-amp-线程-amp-进程-amp-并发-amp-并行"><a href="#1-程序-amp-线程-amp-进程-amp-并发-amp-并行" class="headerlink" title="1    程序 &amp; 线程 &amp; 进程 &amp; 并发 &amp; 并行"></a>1    程序 &amp; 线程 &amp; 进程 &amp; 并发 &amp; 并行</h1><h2 id="1-1-进程、线程产生的背景"><a href="#1-1-进程、线程产生的背景" class="headerlink" title="1.1    进程、线程产生的背景"></a>1.1    进程、线程产生的背景</h2><blockquote>
<ol>
<li> <strong>单指令操作系统</strong></li>
</ol>
</blockquote>
<p>最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在输入的时候，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。</p>
<blockquote>
<ol start="2">
<li> <strong>批处理（指令）操作系统</strong></li>
</ol>
</blockquote>
<p>后来有了批处理操作系统，把一系列需要操作的指令写下来，形成一个清单，一次性交给计算机。用户将多条需要执行的指令写在磁带上，然后交由计算机去读取并逐个执行这些指令，并将输出结果写在另一个磁带上。</p>
<p>批处理操作系统由于可一次不间断地执行多条指令，解决了用户输入速度对执行效率的桎梏，在一定程度上提高了计算机的效率，但是由于批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一条指令在运行，后⾯的指令需要等待前面的指令执行完成后才能开始执行，而前面的指令操作可能会由于 I/O 操作、网络等原因阻塞，所以批处理操作效率也不高。</p>
<p><strong>Tip：</strong></p>
<ul>
<li>  I/O 操作（或网络操作）导致阻塞：当执行某一条指令（比如指令A）时，这条指令要求去访问磁盘上的（或网络中的）资源，那么 CPU 就会去获取磁盘（或网络）中的资源，由于只有一个 CPU，当 I/O（或者网络）操作被阻塞时，CPU 就会一直死等从磁盘（或网络）中获取资源完成，所以就不会去执行指令A之后的指令，所以指令A之后的指令就全部被阻塞了。</li>
</ul>
<blockquote>
<ol start="3">
<li> <strong>进程的提出</strong></li>
</ol>
</blockquote>
<ul>
<li>  人们对于计算机的性能要求越来越高，而<strong>批处理操作系统的瓶颈在于内存中只能同时运行一个程序</strong>，那么内存中能不能存在多个程序呢？</li>
<li>  于是，科学家们提出了进程的概念。</li>
<li>  <strong>进程就是正在运行着的程序</strong>，多个进程可“同时”运行，各个进程之间互不⼲扰。</li>
<li>  此时，CPU 采用时间片轮转的方式运行进程：CPU 为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并将 CPU 分配给另一个进程（这个过程叫做<strong>上下文切换</strong>）。<strong>如果进程在时间片结束前阻塞或结束，则CPU 立即进行切换，不用等待时间片用完。</strong></li>
<li>  当进程暂停时，它会保存当前进程的状态，在下一次切换回来时根据之前保存的状态进行恢复，接着继续行。</li>
<li>  使用 <code>进程 + CPU时间片</code> 轮转方式的操作系统，在宏观上看起来同一时间段执行多个任务，换句话说，进程让操作系统的并发成为了可能。虽然并发从宏观上看有多个任务在执行，但在事实上，对于单核CPU来说，任意具体时刻都只有一个任务在占用 CPU 资源。</li>
</ul>
<blockquote>
<p>  <strong>程序：</strong></p>
</blockquote>
<p>程序是指用某种编程语言（Java / Python等）编写，能够完成一定任务或者功能的代码集合，是指令和数据的有序集合，是一段静态代码。</p>
<blockquote>
<ol start="4">
<li> <strong>对操作系统的要求进一步提高</strong></li>
</ol>
</blockquote>
<p>虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，<strong>人们并不满足一个进程在一段时间只能做一件事情</strong>，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。</p>
<p>比如杀毒软件在检测用户电脑时，如果在某一项检测中卡住了，那么后面的检测项也无法进行下去。或者说当你使用杀毒软件中的扫描病毒功能时，在扫描病毒结束之前，无法使用杀毒软件中清理垃圾的功能，这显然无法满足人们的要求。</p>
<blockquote>
<ol start="5">
<li> <strong>线程的提出</strong></li>
</ol>
</blockquote>
<p>为了让同一线程的子任务可以同时执行，于是人们⼜提出了线程的概念，让<strong>一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p>
<p>在有了线程之后，当用户使用扫描病毒功能时，就让扫描病毒这个线程去执行。同时，如果用户又想使用清理垃圾功能，那么可以先<br>暂停扫描病毒线程，先响应用户的清理垃圾的操作，让清理垃圾这个线程去执行。响应完后再切换回来，接着执行扫描病毒线程。</p>
<hr>
<h2 id="1-2-进程和线程的区别"><a href="#1-2-进程和线程的区别" class="headerlink" title="1.2    进程和线程的区别"></a>1.2    进程和线程的区别</h2><blockquote>
<ol>
<li> <strong>进程</strong></li>
</ol>
</blockquote>
<ul>
<li>运行中的应用程序，每个进程都有一个独立的内存空间；</li>
<li>系统运行一个程序即是一个进程从创建、运行、到消亡的过程。</li>
</ul>
<blockquote>
<ol start="2">
<li> <strong>线程</strong></li>
</ol>
</blockquote>
<ul>
<li>线程是进程中的一个执行单元，负责当前线程任务（进程中的子任务）的执行；</li>
<li>一个进程中至少有一个线程；</li>
<li>一个进程中是可以有多个线程的，这样的程序被称为多线程程序。</li>
</ul>
<p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.png"></p>
<p>一个程序从创建到死亡的过程就是一个进程的生命周期，所以说进程就是运行中的程序。</p>
<p>那么线程又是什么呢？在上图的谷歌浏览器中，我们看一看到运行这一进程我们使用了4个线程，这4个线程或者是并行或者是并发运行，可以充分利用计算机的性能。再举一个简单的例子就是IDM下载器，我们使用了多线程下载来提高下载速度，每个线程只负责一部分的下载任务。多线程是可选的，因为我们执行一个进程最少情况下一个线程也能完成，但是为了提高效率、防止阻塞等原因，我们往往使用多线程来完成。</p>
<p>其实，<strong>多线程程序并不能够提高程序的运行速度，但能够提高程序运行效率，让 CPU 的利用率更高，最常见的就是当某个线程发生 IO 或网络操作时切换到其它线程去利用 CPU 而不是让 CPU 处于空闲等待状态</strong>。</p>
<blockquote>
<ol start="3">
<li> <strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></li>
</ol>
</blockquote>
<p>多进程方式确实可以实现并发，在某些场景下也确实是使用多进程来实现并发的，但使用多线程主要有以下几个好处：</p>
<ol>
<li> 进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，如果我们需要使用共享资源，这些资源在线程间的通信比较容易实现。</li>
<li> 进程是重量级的，而线程是轻量级的。故多线程的创建、销毁开销、上下文切换开销要小于多进程。</li>
</ol>
<blockquote>
<ol start="3">
<li> <strong>进程和线程的区别：</strong></li>
</ol>
</blockquote>
<p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。<strong>它们两个本质的区别是是否单独占有内存空间及其它系统资源（比如I/O）</strong>：</p>
<ul>
<li>  单个进程占有独立的内存空间，所以<strong>进程间存在内存隔离</strong>，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程的内存空间和资源，数据共享简单，但是同步复杂。</li>
<li>  由于进程占有独立的内存空间，一个进程出现问题不会影响其他进程，可靠性高；而一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li>
<li>  进程占有单独的内存空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要进行对分配资源的回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li>
<li>  另一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即 CPU 分配时间的单位 。</strong></li>
</ul>
<hr>
<h2 id="1-3-上下文切换"><a href="#1-3-上下文切换" class="headerlink" title="1.3    上下文切换"></a>1.3    上下文切换</h2><blockquote>
<p>  <strong>概念：</strong></p>
</blockquote>
<p><strong>上下文切换是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。</strong>上下文是指某一时间点 CPU 寄存器和程序计数器<br>的内容。</p>
<blockquote>
<p>  寄存器是 CPU 内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。</p>
<p>  <strong>程序计数器是一个专用的寄存器</strong>，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。</p>
<p>  举例说明：线程 A -&gt; B</p>
<ol>
<li> 先挂起线程 A，将其在 CPU 中的状态保存在内存中。（就是保存当前线程A执行到了哪一条指令了）</li>
<li> 在内存中检索下一个线程 B 的上下文并将其在 CPU 的寄存器中恢复，执行 B 线程。</li>
<li> 当 B 执行完，根据程序计数器中指向的位置恢复线程 A。</li>
</ol>
</blockquote>
<p>CPU 通过为每个线程分配时间片来实现多线程机制。CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p>
<p>但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以继续从上次任务断开的地方继续执行这个任务。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换会消耗⼤量的 CPU 时间，故线程也不是越多越好。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ol>
<li><strong>分时调度</strong>：所有线程轮流使用 CPU ，平均分配每个线程占用 CPU 的时间。</li>
<li><strong>抢占式调度</strong>：优先让优先级高的线程使用 CPU。如果线程的优先级相同，那么会随机选择一个使用CPU。</li>
</ol>
<hr>
<h2 id="1-4-并发-amp-并行"><a href="#1-4-并发-amp-并行" class="headerlink" title="1.4    并发 &amp; 并行"></a>1.4    并发 &amp; 并行</h2><blockquote>
<p>  <strong>并发：</strong></p>
</blockquote>
<ul>
<li>  指两个或多个事件在<strong>同一个时间段</strong>内发生。</li>
<li>  一个 CPU（采用时间片）同时执行多个任务。</li>
</ul>
<blockquote>
<p>  <strong>并行</strong></p>
</blockquote>
<ul>
<li>  指两个或多个事件在<strong>同一时刻</strong>发生。（同时发生）</li>
<li>  即多个 CPU 同时执行多个任务。</li>
</ul>
<hr>
<h1 id="2-Java中创建线程的4种方法"><a href="#2-Java中创建线程的4种方法" class="headerlink" title="2    Java中创建线程的4种方法"></a>2    Java中创建线程的4种方法</h1><blockquote>
<ol>
<li> <strong>继承 Thread 类</strong></li>
<li> <strong>实现 Runnable 接口</strong></li>
<li> <strong>实现 Callable 接口</strong></li>
<li> <strong>线程池</strong></li>
</ol>
</blockquote>
<h2 id="2-1-Thread-类"><a href="#2-1-Thread-类" class="headerlink" title="2.1    Thread 类"></a>2.1    Thread 类</h2><blockquote>
<p>  <strong>步骤：</strong></p>
</blockquote>
<ol>
<li> 创建一个继承于 Thread 类的子类；</li>
<li> 重写 Thread 类中的 <code>run()</code> 方法，在方法中声明此线程要执行的任务；</li>
<li> 创建 Thread 类的子类的对象；</li>
<li> 调用子类对象的 <code>start()</code> 方法。</li>
</ol>
<blockquote>
<p>   <strong>代码实现</strong></p>
</blockquote>
<ol>
<li> 定义 Thread 类的子类 MyThread</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1正在执行任务A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>注意：</strong></p>
</blockquote>
<ol>
<li>我们启动一个新线程，必须调用 <code>start()</code>，不能通过调用 <code>run()</code> 的方式启动线程。<ul>
<li>  <strong>我们在程序中调用了 <code>start()</code> 方法后，虚拟机会先为我们创建一个新的线程，然后等到这个线程第一次得到时间片时再调用 <code>run()</code> 方法。</strong></li>
<li>  注意不可多次调用 <code>start()</code> 方法。在第一次调用 <code>start()</code> 方法后，再次调用 <code>start()</code> 方法会<strong>抛出异常</strong>。</li>
</ul>
</li>
<li> 如果再启动一个线程，必须重新创建一个 Thread 子类的对象，调用此对象的 <code>start()</code></li>
</ol>
<hr>
<h2 id="2-2-Runnable-接口"><a href="#2-2-Runnable-接口" class="headerlink" title="2.2    Runnable 接口"></a>2.2    Runnable 接口</h2><blockquote>
<p>  <strong>实现步骤：</strong></p>
</blockquote>
<ol>
<li>定义 Runnable 接口的实现类，重写接口中的 <code>run()</code> 方法，在方法中声明此线程要执行的任务；</li>
<li>创建实现类的实例对象，并将此对象传递到 Thread 类的构造器中，创建 Thread 类实例对象；</li>
<li>通过 Thread 类的实例对象的<code>start()</code>方法启动线程。</li>
</ol>
<blockquote>
<p>  <strong>代码实现</strong></p>
</blockquote>
<ol>
<li> 定义 Runnable 接口的实现类 RunnableImpl</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行体，子线程1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.开启子线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>  <strong>Runnable 接口(JDK 1.8 +)</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Runnable 是一个函数式接口，这意味着我们可以使用 Java8 的函数式编程来简化代码。</p>
<hr>
<h2 id="2-3-Thread-vs-Runnable"><a href="#2-3-Thread-vs-Runnable" class="headerlink" title="2.3    Thread vs. Runnable"></a>2.3    Thread vs. Runnable</h2><blockquote>
<p>  <strong>联系：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>所以本质上，Thread 类中的 run() 也是从 Runnable 接口中继承过来然后重写的。而我们通过继承 Thread 类创建线程对象时又重写了 Thread 类中的 run() 方法</strong></li>
</ul>
<blockquote>
<p>  <strong>相同点：</strong></p>
</blockquote>
<ul>
<li>  两种方式都需要重写 <code>run()</code>，将新线程要执行的任务声明在 <code>run()</code> 中。</li>
<li>  实际上所有的多线程代码都是通过 <code>Thread</code> 类的 <code>start()</code> 方法来运行的。因此，不管是通过继承 <code>Thread</code> 类还是实现 <code>Runnable</code> 接口来实现多线程，最终都要通过<code>Thread</code>类的实例对象来开启线程的。</li>
</ul>
<blockquote>
<p>  <strong>使用：</strong></p>
</blockquote>
<ul>
<li>  开发时，在这两者之中，优先选择实现 Runnable 接口的方式；</li>
<li>  实际开发中，用的最多的还是通过线程池创建线程的方式。而且使用的线程池也不是 JDK 提供的线程的线程池，一般都是使用自定义的线程池。【阿里巴巴开发手册】</li>
</ul>
<blockquote>
<p>  <strong>继承 Thread 类的线程存在的缺陷（实现 Runnable 的线程的优势）：</strong></p>
</blockquote>
<ol>
<li> <strong>类单继承的局限性</strong>：由于单继承的局限性，如果一个类继承了<code>Thread</code>，就不能再继承其它父类了；换句话说，如果一个类已经继承了其它父类，就不能再通过继承 Thread 来实现多线程了，这时候就只能通过实现接口的方式来实现多线程。</li>
<li> <strong>Runnable 接口降低了线程对象和线程任务的耦合性，任务可被多个线程共享</strong>：实现 <code>Runnable</code> 接口的方式，任务和线程独立，任务可被多个线程共享。如果通过继承 Thread 的方式，线程和任务是绑定的，如果某个任务需要被多个线程执行的话就要声明多次。</li>
<li> <strong>线程池只能放入 Runnable 或 Callable 类型的线程，不能直接放入继承 Thread 类型的线程</strong>。</li>
<li> <strong>Runnable 接口更轻量级</strong>，如果使用线程时不需要使用 Thread 类中的诸多方法，显然使用 Runnable 接口更为轻量。</li>
</ol>
<hr>
<h2 id="2-4-Callable-接口"><a href="#2-4-Callable-接口" class="headerlink" title="2.4    Callable 接口"></a>2.4    Callable 接口</h2><ul>
<li>  <code>Callable</code> 与 <code>Runnable</code> 类似，同样是只有一个抽象方法的函数式接口。</li>
<li>  不同的是， <code>Callable</code> 提供的方法是有返回值的，而且支持泛型。</li>
</ul>
<blockquote>
<p>  <strong>Callable 接口源码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>Callable</code> 一般是配合线程池工具 <strong>ExecutorService</strong> 来使用的。</li>
<li>  <code>ExecutorService</code> 可以使用 <code>submit()</code> 方法来执行 Callable 接口中的 <code>call()</code> 方法。【不可以使用 <code>execute()</code> 执行 Callable 类型的任务】</li>
<li>  它会返回一个 <strong>Future</strong> ，我们后续的程序可以通过这个 Future 的 <code>get()</code> 方法得到结果。</li>
</ul>
<blockquote>
<p>  <strong>代码演示</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⾃定义 Callable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟计算需要5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="comment">// 使用线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        System.out.println(result.get());	<span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 注意：调⽤get方法会阻塞当前线程，直到得到结果。【线程资源用于死等返回结果，而不会去处理下一行的代码逻辑】</span></span><br><span class="line">        <span class="comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阻塞结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="3-Thread-类"><a href="#3-Thread-类" class="headerlink" title="3    Thread 类"></a>3    Thread 类</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1    概述"></a>3.1    概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Object</span> </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java 使用<code>java.lang.Thread</code> 类代表线程。</li>
<li>所有的线程对象必须是 Thread 类或其子类的实例对象。</li>
<li>每个线程的作用是完成一个<strong>任务</strong>。Java使用<strong>线程执行体</strong>来代表这个任务。</li>
</ul>
<h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2    方法"></a>3.2    方法</h2><h3 id="3-2-1-构造方法（部分）"><a href="#3-2-1-构造方法（部分）" class="headerlink" title="3.2.1    构造方法（部分）"></a>3.2.1    构造方法（部分）</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Thread()</code></td>
<td align="left">创建一个默认名字的新的线程对象</td>
</tr>
<tr>
<td align="left"><code>Thread(String name)</code></td>
<td align="left">分配一个指定名字的新的线程对象</td>
</tr>
<tr>
<td align="left"><code>Thread(Runnable target)</code></td>
<td align="left">分配一个带有指定目标的新的线程对象</td>
</tr>
<tr>
<td align="left"><code>Thread(Runnable target, String name)</code></td>
<td align="left">分配一个带有指定目标的新的线程对象并指定线程名字</td>
</tr>
</tbody></table>
<ul>
<li><code>Runnable target</code> 是一个接口类型，该参数实际使用时接收的是 Runnable 接口的实现类。</li>
<li><code>Runnable</code> 接口的实现类对象中包含了<code>run()</code> 方法作为线程执行体，而实际的线程对象依然是<code>Thread</code>实例，只是该<code>Thread</code>线程负责执行<code>target</code>对象(即<code>Runnable</code>接口的实现类)中的<code>run()</code>方法。</li>
</ul>
<hr>
<h3 id="3-2-2-常用方法"><a href="#3-2-2-常用方法" class="headerlink" title="3.2.2    常用方法"></a>3.2.2    常用方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">返回值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>thread.getName()</code></td>
<td align="center"><code>String</code></td>
<td align="left">获取当前线程的名称</td>
</tr>
<tr>
<td align="left"><code>thread.start()</code></td>
<td align="center"><code>void</code></td>
<td align="left">创建一个新的线程，并在轮询到CPU资源后开始执行线程指定的任务</td>
</tr>
<tr>
<td align="left"><code>run()</code></td>
<td align="center"><code>void</code></td>
<td align="left">此线程要执行的任务代码</td>
</tr>
<tr>
<td align="left"><code>Thread.sleep(long millis)</code></td>
<td align="center"><code>void</code></td>
<td align="left">静态方法，使当前正在执行的线程暂停x毫秒</td>
</tr>
<tr>
<td align="left"><code>Thread.currentThread()</code></td>
<td align="center"><code>Thread</code></td>
<td align="left">静态方法，返回当前正在执行的线程对象的引用</td>
</tr>
<tr>
<td align="left"><code>Thread.yield()</code></td>
<td align="center"><code>void</code></td>
<td align="left"><code>static native</code>，当前线程愿意让出对当前处理器的占用</td>
</tr>
<tr>
<td align="left"><code>thread.join()</code></td>
<td align="center"><code>void</code></td>
<td align="left">当前线程等待另一个线程执行完毕之后再执行</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>yield</strong></p>
</blockquote>
<p>yield 在英语里有放弃的意思，同样，这里的 <code>yield()</code> 指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了 <code>yield()</code> 方法，程序在调度的时候，也还有可能继续运行这个线程的；</p>
<blockquote>
<p>  <strong>join</strong></p>
</blockquote>
<p><code>join()</code> 方法是通过一个 thread 对象实例来调用的，作用是让外部线程进入“等待”状态，直到调用 <code>join</code> 方法的线程执行完成后，再继续执行外部线程。内部是通过 Object 类的 <code>wait()</code> 方法实现的。</p>
<p>🌰：比如，在 main 线程中创建并启动了子线程 threadA，如果 threadA 中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。如果 main 线程想等到子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到 <code>join()</code> 方法了。<code>join()</code> 方法会暂停当前正在执行的线程（即 main 线程），直到 threadA 线程执行结束之后再继续执行 main 线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/27 12:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务耗时3s</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行成功&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        threadA.start();</span><br><span class="line">        </span><br><span class="line">        threadA.join(); <span class="comment">// 让threadA线程得以执行，但是不让外部的 main 线程执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阻塞结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>  <strong>sleep 和 wait 方法的区别：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">sleep</th>
<th align="left">wait</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">Thread 对象中的方法</td>
<td align="left">Object 对象中的方法</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><code>sleep</code> 释放 CPU 资源，但是不释放锁</td>
<td align="left"><code>wait</code> 释放 CPU 资源，同时释放锁</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">不需要被唤醒（休眠之后退出阻塞）</td>
<td align="left">需要被唤醒（不指定时间时需要被唤醒）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><code>sleep</code> 可以在任意位置</td>
<td align="left"><code>wait</code> 必须放在同步块或同步方法中</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><code>sleep</code> 必须指定时间</td>
<td align="left"><code>wait</code> 可以指定时间，也可以不指定</td>
</tr>
</tbody></table>
<ul>
<li>  由于 <code>sleep</code> 方法不释放锁，所以当线程醒来之后直接进入 Runnable 状态，当轮询到 CPU 资源后直接可以执行；而 <code>wait</code> 方法释放锁对象，当线程醒来后处于 Blocked 状态，只有再次获得锁之后才会进入 Runnable 状态。</li>
</ul>
<hr>
<h2 id="3-3-Thread-类构造方法源码分析"><a href="#3-3-Thread-类构造方法源码分析" class="headerlink" title="3.3    Thread 类构造方法源码分析"></a>3.3    Thread 类构造方法源码分析</h2><ul>
<li>  Thread 类是 Runnable 接口的一个实现类。</li>
<li>  查看 Thread 类的构造方法，发现 Thread 类的多个重载方法底层都是通过调用了一个私有的 <strong>init</strong> 方法来实现初始化的。 </li>
<li>  init 方法也是一个重载方法，其中参数最多的一个如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段1：init 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                  <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> inheritThreadLocals)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段2：Thread类的构造函数调⽤init⽅法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">    init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段3：使用在init⽅法里初始化AccessControlContext类型的私有属性</span></span><br><span class="line"><span class="built_in">this</span>.inheritedAccessControlContext = acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段4：两个对用于支持ThreadLocal的私有属性</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>init 方法中的参数详解：</strong></p>
<ul>
<li><p>  <strong>ThreadGroup g</strong>：线程组，指定这个线程是在哪个线程组下；</p>
</li>
<li><p>  <strong>Runnable target</strong>：指定要执行的任务；</p>
</li>
<li><p>  <strong>String name</strong>：线程的名字，多个线程的名字是可以重复的。如果不指定名字，默认会自动生成一个名字，见片段2；</p>
</li>
<li><p><strong>AccessControlContext acc</strong>：见片段3，用于初始化私有变量 <code>inheritedAccessControlContext</code>。</p>
<blockquote>
<p>  它是一个私有变量，但是在 Thread 类里只有 <code>init</code> 方法会对它进行初始化，在 exit 方法中把它设为 null 。一般不会使用到它。</p>
</blockquote>
</li>
<li><p>  <strong>inheritThreadLocals：</strong>可继承的 ThreadLocal ，见片段4， Thread 类里面有两个私有属性来⽀持 ThreadLocal 。</p>
</li>
</ul>
</blockquote>
<hr>
<h1 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4    线程状态"></a>4    线程状态</h1><h2 id="4-1-操作系统中的线程五态"><a href="#4-1-操作系统中的线程五态" class="headerlink" title="4.1    操作系统中的线程五态"></a>4.1    操作系统中的线程五态</h2><p>在现代操作系统中，<strong>线程被视为轻量级的进程，所以操作系统线程的状态和操作系统进程的状态是一致的</strong>。</p>
<p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/7462071-955b1ef86b257315.png" alt="img"></p>
<p>操作系统线程主要有以下三个状态：</p>
<ul>
<li>  **就绪状态(ready)**：线程正在等待 CPU，获得 CPU 之后可进入 running 状态。</li>
<li>  **执行状态(running)**：线程正在使用 CPU。</li>
<li>  **等待状态(waiting)**：线程被等待事件的调用或者正在等待其他资源（如 I/O）。</li>
</ul>
<hr>
<h2 id="4-2-Java-中的线程六态"><a href="#4-2-Java-中的线程六态" class="headerlink" title="4.2    Java 中的线程六态"></a>4.2    Java 中的线程六态</h2><p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB.png"></p>
<blockquote>
<p>  <strong>Thread.State 源码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="left">线程状态</th>
<th align="left">发生的条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>New</code></td>
<td align="left">线程刚被创建，但是<strong>还没有调用<code>start()</code>方法</strong>。</td>
</tr>
<tr>
<td align="left"><code>Runnable</code></td>
<td align="left">线程可以在 Java 虚拟机中运行，但不一定正在运行，什么时候运行取决于底层的操作系统。</td>
</tr>
<tr>
<td align="left"><code>Blocked</code></td>
<td align="left">当一个线程试图获取一个锁对象，而该锁对象被其它线程持有，则该线程进入<code>Blocked</code>状态，当该线程持有锁时，该线程将变成<code>Runnable</code>状态。</td>
</tr>
<tr>
<td align="left"><code>Waiting</code></td>
<td align="left">一个线程在等待另一个线程执行唤醒动作时，该线程进入<code>Waiting</code>状态。进入这个状态时不能自动唤醒的，必须等待另一个线程调用<code>notify</code>或<code>notifyAll</code>方法才能唤醒。</td>
</tr>
<tr>
<td align="left"><code>TimedWaiting</code></td>
<td align="left">有几个方法有超时参数，调用它们将进入<code>TimedWaiting</code>状态，这一状态将一直保持到超时期满或者接收到唤醒通知。    常用的带有超时参数的方法有**<code>Thread.sleep()</code>、<code>Object.wait()</code>**</td>
</tr>
<tr>
<td align="left"><code>Teminated</code></td>
<td align="left">因<code>run()</code>方法的正常退出而死亡，或者因为没有捕获的异常终止了<code>run()</code>方法而死亡。</td>
</tr>
</tbody></table>
<ul>
<li>  阻塞是不持有锁资源，但可能占用 CPU 资源，比如一个线程一直在以自旋的方式尝试获取锁对象，这时它自身是没有锁对象的，但是使用了CPU资源，这就是一种阻塞的状态。并且阻塞状态到 Runnable 状态是不需要被唤醒的。</li>
<li>  等待则是既不持有锁资源，也不占用 CPU 资源。在 Java 中，等待则是长时间阻塞后的最终结果。比如：当一个线程自旋次数达到一定的阈值后，为了避免线程继续自旋浪费 CPU 资源，就会让线程进入 Waiting 状态，不再使用 CPU 资源。</li>
</ul>
<hr>
<h2 id="4-3-NEW"><a href="#4-3-NEW" class="headerlink" title="4.3    NEW"></a>4.3    NEW</h2><p>处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的 <code>start()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testStateNew</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;&#125;);</span><br><span class="line">    System.out.println(thread.getState()); <span class="comment">// NEW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，只是创建了线程而并没有调用 <code>start()</code> 方法，此时线程处于 NEW 状态。</p>
<h2 id="4-4-RUNNABLE"><a href="#4-4-RUNNABLE" class="headerlink" title="4.4    RUNNABLE"></a>4.4    RUNNABLE</h2><ul>
<li><code>Runnable</code> 是一种可运行的状态。表示线程可以在 Java 虚拟机中运行，但不一定正在运行。处于 RUNNABLE 状态的线程可能在 Java 虚拟机中运行，也有可能在等待 CPU 资源。</li>
<li>多线程的多个线程在没有进行到争夺同一锁对象之前都是<code>Runnable</code>状态，但是一旦涉及到争夺锁对象，就会分为<code>Runnable</code>和<code>Blocked</code>两种状态。</li>
</ul>
<blockquote>
<p>  <strong>Java 中线程的 RUNNABLE 状态：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread 源码里对 RUNNABLE 状态的定义：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Thread state for a runnable thread. A thread in the runnable</span></span><br><span class="line"><span class="comment">* state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">* be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">* such as processor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">翻译：处于Runnable状态下的线程可能正在Java虚拟机中执行，也有可能正在等待来自于操作系统的其它资源，比如处理器。</span><br></pre></td></tr></table></figure>

<p>显然，<strong>Java 线程的 RUNNABLE 状态其实是包括了传统操作系统线程的 ready 和 running 两个状态的</strong>。</p>
<h2 id="4-5-BLOCKED"><a href="#4-5-BLOCKED" class="headerlink" title="4.5    BLOCKED"></a>4.5    BLOCKED</h2><ul>
<li>阻塞状态。<ul>
<li>  处于 BLOCKED 状态的线程正等待锁的释放以进入同步区。</li>
<li>  处于 BLOCKED 状态的线程依然占用 CPU 资源。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>Blocked 线程状态图</strong></p>
</blockquote>
<ul>
<li>  当多个线程协作时，比如线程 A 和线程 B 争夺同一锁对象，如果线程 A 先获取到锁对象，那么线程 A 就进入到<code>Runnable</code>状态，而线程 B 进入到<code>Blocked</code><strong>锁阻塞</strong>状态，注意仅仅是锁阻塞，在自旋状态下线程B还会不停地尝试获取锁对象，直到进入 Waiting 状态后才释放对 CPU 的占用。</li>
</ul>
<p><img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012170616241.png" alt="image-20201012170616241"></p>
<h2 id="4-6-WAITING"><a href="#4-6-WAITING" class="headerlink" title="4.6    WAITING"></a>4.6    WAITING</h2><ul>
<li>等待状态。<ul>
<li>  处于等待状态的线程变成 RUNNABLE 状态需要通过其它线程唤醒[，而处于 BLOCKED 状态的线程变成 RUNNABLE 状态时不需要通过其它线程唤醒。]</li>
<li>  处于等待状态的线程既不占用 CPU 资源，也不持有锁对象。</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <strong>Waiting线程状态图</strong></p>
</blockquote>
<ul>
<li>当多个线程协作时，如果线程 A 在 <code>running</code> 状态下调用了 <strong>Object#wait()</strong> 方法，那么线程 A 就进入了<code>Waiting</code>状态，<strong>同时失去了锁对象（Tip：Thread#sleep() 方法不会释放锁对象）</strong>。<ul>
<li>  如果处于阻塞状态下的线程，在自旋次数达到了一个阈值之后，也会通过 <strong>LockSupport#lock()</strong> 方法进入阻塞状态。</li>
</ul>
</li>
<li>  如果此时线程 B 获取到了同一锁对象，并在 <code>running</code> 状态下调用了 <code>notify()</code> 方法，那么就会将<code>Waiting</code>状态的线程 A 唤醒。<strong>注意仅仅只是唤醒，如果线程 A 被唤醒后获取到了锁对象，那么就进入<code>Runnable</code>状态，如果没有获取到锁对象，则进入<code>Blocked</code>状态。</strong></li>
</ul>
<img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012171420707.png" alt="image-20201012171420707" style="zoom:80%;">



<h3 id="调用以下-3-个方法会使线程进入等待状态："><a href="#调用以下-3-个方法会使线程进入等待状态：" class="headerlink" title="调用以下 3 个方法会使线程进入等待状态："></a>调用以下 3 个方法会使线程进入等待状态：</h3><ul>
<li>  **Object.wait()**：使当前线程立即进入等待状态，直到另一个线程唤醒它；</li>
<li>  **Thread.join()**：是当前线程进入等待状态，直到调用 join 方法的线程中的任务执行完毕，底层调用的是 Object 实例的 wait 方法；</li>
<li>  **LockSupport.park()**：除非获得调用许可，否则禁用当前线程进行线程调度。</li>
</ul>
<blockquote>
<p>  <strong>Object.wait()</strong></p>
</blockquote>
<ul>
<li>  调用 <code>wait()</code> 方法前线程必须持有对象的锁。</li>
<li>  线程调用 <code>wait()</code> 方法时，会释放当前的锁，直到有其他线程调用 <code>notify()/notifyAll()</code> 方法唤醒等待锁的线程。</li>
<li>  <strong>需要注意的是，其他线程调用 <code>notify()</code> 方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用 <code>wait()</code> 方法的线程。</strong></li>
<li>  <strong>同样，调用 <code>notifyAll()</code> 方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</strong></li>
</ul>
<blockquote>
<p>  <strong>Thread.join()</strong></p>
</blockquote>
<ul>
<li>  调用 <code>join()</code> 方法不会立即释放锁，会一直等待当前线程执行完毕（转换为 TERMINATED 状态）。</li>
<li>  举例说明：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockedTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        testMethod();</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        testMethod();</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.start();</span><br><span class="line">    a.join();</span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">&quot;:&quot;</span> + a.getState()); </span><br><span class="line">    System.out.println(b.getName() + <span class="string">&quot;:&quot;</span> + b.getState()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法争夺锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  要是没有调用 <code>join()</code> 方法，main 线程不管 a 线程是否执行完毕都会继续往下走。</li>
<li>  a 线程启动之后马上调用了 <code>join()</code> 方法，这时 main 线程就会等到 a 线程执行完毕才能继续向下执行，所以这里 a 线程打印的状态固定是TERMIATED。</li>
<li>  至于 b 线程的状态，有可能打印 RUNNABLE（尚未进入同步方法），也有可能打印 TIMED_WAITING（进入了同步方法）。</li>
</ul>
<hr>
<h2 id="4-7-TIMED-WAITING"><a href="#4-7-TIMED-WAITING" class="headerlink" title="4.7    TIMED_WAITING"></a>4.7    TIMED_WAITING</h2><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<ul>
<li>进入<code>TimedWaiting</code>状态的一种方法是调用<code>Thread.sleep()</code>方法，单线程也可以调用。</li>
<li>为了让其它线程也有机会执行，可以将<code>Thread.sleep()</code>的调用放入线程执行体<code>run()</code>之内，这样才能保证该线程执行过程中会睡眠。[睡眠是在线程已经执行了一部分的情况下进入的，我们一般会把<code>sleep()</code>方法写在线程执行体的前面几行代码中，使当前线程进入睡眠]</li>
<li><code>sleep()</code>中指定的时间是线程不会运行的最短时间。因为 <code>sleep()</code> 方法在休眠时不会释放锁对象，所以该线程睡眠时间到期后没有重新争夺锁的过程，而是会直接进入<code>Runnable</code>状态。</li>
</ul>
<blockquote>
<p>  <strong>TimeWaiting 线程状态图</strong></p>
</blockquote>
<img src="/2020/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20201012165955497.png" alt="image-20201012165955497" style="zoom:80%;">



<h3 id="调用如下方法会使线程进入超时等待状态："><a href="#调用如下方法会使线程进入超时等待状态：" class="headerlink" title="调用如下方法会使线程进入超时等待状态："></a>调用如下方法会使线程进入超时等待状态：</h3><blockquote>
<ul>
<li>  <strong>Thread.sleep(long millis)</strong></li>
<li>  <strong>Object.wait(long timeout)</strong></li>
<li>  <strong>Thread.join(long millis)</strong></li>
<li>  <strong>LockSupport.parkNanos(long nanos)</strong></li>
<li>  <strong>LockSupport.parkUntil(long deadline)</strong></li>
</ul>
</blockquote>
<blockquote>
<p>  <strong>Thread.sleep(long millis)</strong></p>
</blockquote>
<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入 RUNNABLE 状态。</p>
<blockquote>
<p>  <strong>Object.wait(long timeout)</strong></p>
</blockquote>
<p>线程休眠指定时间，等待期间可以通过 <code>notify()/notifyAll()</code> 唤醒，被唤醒后重新拥有争夺锁的资格。</p>
<blockquote>
<p>  <strong>Thread.join(long millis)</strong></p>
</blockquote>
<p>使当前线程执行指定时间，如果 millis 为 0，则会一直执行。</p>
<ul>
<li>  修改一下刚才的示例:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockedTest</span><span class="params">()</span> &#123;</span><br><span class="line">    ······</span><br><span class="line">    a.start();</span><br><span class="line">    a.join(<span class="number">1000L</span>);</span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">&quot;:&quot;</span> + a.getState()); <span class="comment">// 输出 TIEMD_WAITING</span></span><br><span class="line">    System.out.println(b.getName() + <span class="string">&quot;:&quot;</span> + b.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  这里调用 <code>a.join(1000L)</code>，因为是指定了具体 a 线程执行的时间的，并且执行时间是小于 a 线程 sleep 的时间，所以 a 线程状态输出为 TIMED_WAITING。</li>
<li>  b 线程状态仍然不固定（RUNNABLE或BLOCKED）。</li>
</ul>
<hr>
<h2 id="4-8-TERMINATED"><a href="#4-8-TERMINATED" class="headerlink" title="4.8    TERMINATED"></a>4.8    TERMINATED</h2><p>终⽌状态。此时线程已执行完毕。</p>
<hr>
<h2 id="4-9-线程中断"><a href="#4-9-线程中断" class="headerlink" title="4.9    线程中断"></a>4.9    线程中断</h2><ul>
<li>  在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。</li>
<li>  目前在 Java 中还没有安全直接的方法来停止线程，但是 Java 提供了线程中断机制来处理需要中断线程的情况。</li>
<li>  线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。</li>
</ul>
<blockquote>
<p>  Thread 类中提供了几个关于线程中断的方法：</p>
</blockquote>
<ul>
<li>  **Thread.interrupt()**：中断线程。这里的中断线程并不会立即停止线程，⽽是设置线程的中断状态为 true（默认是flase）；</li>
<li>  **Thread.interrupted()**：测试当前线程是否被中断。线程的中断状态受这个方法的影响，调用一次会使线程中断状态设置为 true，连续调用两次会使得这个线程的中断状态重新转为 false；</li>
<li>  **Thread.isInterrupted()**：测试当前线程是否被中断。与上面放法不同的是调用这个方法并不会影响线程的中断状态。</li>
</ul>
<blockquote>
<p>  <strong>Tip：</strong></p>
</blockquote>
<p>在线程中断机制中，当其他线程通知需要被中断的线程后，线程中断的状态被设置为 true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己决定，可以在合适的实际处理中断请求，也可以完全不处理继续执行下去。</p>
<hr>
<h1 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5    线程安全"></a>5    线程安全</h1><h2 id="5-1-线程安全"><a href="#5-1-线程安全" class="headerlink" title="5.1    线程安全"></a>5.1    线程安全</h2><ul>
<li>  如果有多个线程在同时运行，而且这些线程可能会同时运行某段代码。<strong>如果多线程程序每次运行这段代码的结果和单线程运行的结果是一样的，而且其他变量的值也和预期的是一样的，就说线程是安全的。</strong></li>
<li>  <strong>线程安全问题都是由全局变量和静态变量引起的</strong>。    <em>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的</em>。    若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li>
</ul>
<h2 id="5-2-案例演示"><a href="#5-2-案例演示" class="headerlink" title="5.2    案例演示"></a>5.2    案例演示</h2><blockquote>
<p>  电影院卖票，假设共有100张票，多个窗口同时卖票。</p>
</blockquote>
<ol>
<li><p><code>Runnable</code>的实现类<code>RunnableImpl</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 模拟出票时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> tickets--;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;正在卖：&quot;</span>+now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>测试类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.总共有100张票</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.三个窗口同时卖票</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">win1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">win2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">win3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>(), <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        win1.start();</span><br><span class="line">        win2.start();</span><br><span class="line">        win3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Thread[窗口1,5,main]正在卖：100</span></span><br><span class="line"><span class="comment">    Thread[窗口2,5,main]正在卖：99</span></span><br><span class="line"><span class="comment">    Thread[窗口3,5,main]正在卖：99</span></span><br><span class="line"><span class="comment">    Thread[窗口1,5,main]正在卖：98</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">    线程不安全</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-3-线程同步"><a href="#5-3-线程同步" class="headerlink" title="5.3    线程同步"></a>5.3    线程同步</h2><ul>
<li><p>  当我们使用多个线程访问同一资源，且存在多个线程对资源有写的操作时，就可能会出现线程安全问题。</p>
</li>
<li><p>要解决上述多线程的并发访问一个资源的安全性问题：也就是解决重复票与不存在票的问题，Java提供了<strong>同步机制（synchronize）</strong>来解决。</p>
<blockquote>
<ol>
<li> 窗口1线程执行卖票操作的时候，窗口2和窗口3线程只能在外面等着。 </li>
<li> 窗口1操作结束，窗口1、窗口2、和窗口3才有机会进入代码去执行卖票操作。</li>
<li> 也就是说某个线程在修改共享资源的时候，其它线程不能修改该资源，等待修改完毕资源同步之后，才能去抢夺 CPU 资源，完成对应的操作，保证了数据的同步性。解决了线程的不安全问题。</li>
</ol>
</blockquote>
</li>
<li><p>如何完成同步操作？3种方式</p>
<ol>
<li> <strong>同步代码块</strong></li>
<li> <strong>同步方法</strong></li>
<li> <strong>锁机制</strong></li>
</ol>
</li>
</ul>
<h2 id="5-3-同步代码块"><a href="#5-3-同步代码块" class="headerlink" title="5.3    同步代码块"></a>5.3    同步代码块</h2><ul>
<li><p>  <strong>同步代码块</strong>：<code>synchronized</code>关键字可以用于<code>run()</code>方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p>
</li>
<li><p>格式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    需要同步操作的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>同步锁</strong>：同步锁对象只是一个概念，可以想象为在对象上标记了一把锁。</p>
<ol>
<li> 锁对象，可以是任意类型。</li>
<li> 多个线程对象，要使用同一把锁<code>（--&gt;&gt;单例）可以是static或final修饰的对象</code>。</li>
<li> 在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其它线程只能在外面等着。<code>（--&gt;&gt;BLOCKED）</code></li>
</ol>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int tickets = 100;</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">            while (tickets&gt;0)&#123;</span><br><span class="line">                // 模拟出票时间</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    tickets--;</span><br><span class="line">                    System.out.println(Thread.currentThread()+&quot;正在卖：&quot;+tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    使用了同步代码块后，上述的线程安全问题就解决了。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>





<h2 id="5-4-同步方法"><a href="#5-4-同步方法" class="headerlink" title="5.4    同步方法"></a>5.4    同步方法</h2><ul>
<li><p>  同步方法：使用<code>synchronized</code>修饰的方法，就叫做同步方法，保证A线程执行该方法的时候，其它线程只能在方法外等着。</p>
</li>
<li><p>格式：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method()&#123;</span><br><span class="line">    // 可能会产生线程安全的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int tickets = 100;</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            sellTickets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     public synchronized void sellTickets()&#123;</span><br><span class="line">            if (tickets&gt;0)&#123;</span><br><span class="line">                // 模拟出票时间</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    tickets--;</span><br><span class="line">                    System.out.println(Thread.currentThread()+&quot;正在卖：&quot;+tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <em>同步方法中，隐藏了同步锁对象。如果同步方法是一个非静态方法，那么它的同步锁对象就是<code>this</code>对象；若果同步方法是静态方法，同步锁对象就是当前方法所在类的字节码对象。</em></p>
<h3 id="4-2-3、Lock锁（同步锁）"><a href="#4-2-3、Lock锁（同步锁）" class="headerlink" title="4.2.3、Lock锁（同步锁）"></a>4.2.3、Lock锁（同步锁）</h3><h4 id="Lock类介绍"><a href="#Lock类介绍" class="headerlink" title="Lock类介绍"></a>Lock类介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.Lock;</span><br><span class="line">public interface Lock;</span><br><span class="line">// 常用的实现类</span><br><span class="line">ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock </span><br></pre></td></tr></table></figure>

<p>​    <code>Lock接口</code>提供了比使用 <code>synchronized</code> 方法和代码块更广泛的锁定操作，同步代码块/同步方法具有的功能<code>Lock</code>都由，而且更加强大，更体现面向对象。</p>
<h4 id="Lock接口中常用的方法"><a href="#Lock接口中常用的方法" class="headerlink" title="Lock接口中常用的方法"></a>Lock接口中常用的方法</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public void lock()</code></td>
<td align="center">加同步锁</td>
</tr>
<tr>
<td align="center"><code>public void unlock()</code></td>
<td align="center">释放同步锁</td>
</tr>
</tbody></table>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 模拟出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    tickets--;</span><br><span class="line">                    System.out.println(Thread.currentThread()+<span class="string">&quot;正在卖：&quot;</span>+tickets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="6-线程间通信（等待-唤醒机制）"><a href="#6-线程间通信（等待-唤醒机制）" class="headerlink" title="6    线程间通信（等待/唤醒机制）"></a>6    线程间通信（等待/唤醒机制）</h1><h2 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1    概念"></a>6.1    概念</h2><blockquote>
<p>  <strong>什么是线程同步？</strong></p>
</blockquote>
<p>线程同步是线程之间按照<strong>一定的顺序</strong>执行。</p>
<blockquote>
<p>  <strong>为什么要处理线程间通信？</strong></p>
</blockquote>
<p>多个线程并发执行时，默认情况下 CPU 是随机切换线程的。当我们需要多个线程来共同完成一件任务，并且<strong>希望这些线程能有规律的执行</strong>，那么多个线程之间就需要进行通信来协调任务，以此来帮助我们达到多线程共同操作一份数据。</p>
<ul>
<li>  比如，线程A是生产包子的线程，线程B是消耗包子的线程，那么我们希望线程A每生产100个包子就通知线程B开始吃包子，线程B吃完包子后就通知线程A再开始生产包子，这时我们就必须通过线程通信来达到这一目的。    对于线程A，设置一个阀值，当包子数量达到阀值后线程A进入睡眠状态；此时线程B开始吃包子，当包子数量为0时线程B进入睡眠状态，并唤醒线程A让线程A继续生产包子。</li>
<li>  再比如，线程 A 和 B 的任务都是打印 1~100 之间的整数，但是要求线程 A 全部打印完毕后线程 B 才能开始打印，这也需要线程间通信来进行协调。</li>
</ul>
<blockquote>
<p>  <strong>如何保证线程间通信能有效利用资源？</strong></p>
</blockquote>
<ul>
<li>  多个线程在处理同一资源，并且任务不相同时，需要通过线程通信来帮助解决多个线程操作同一变量可能引发的冲突。</li>
<li>  如果是简单的基于“锁”的方式，在线程 A 持有锁对象，线程 B 进入阻塞而没有进入休眠，会不断地尝试去获取锁，这很消耗服务器资源；</li>
<li>  所以，我们一般采用的手段是——<strong>等待/唤醒机制</strong>。</li>
</ul>
<hr>
<h2 id="6-2-wait-notify-机制"><a href="#6-2-wait-notify-机制" class="headerlink" title="6.2    wait/notify 机制"></a>6.2    wait/notify 机制</h2><p>Java 多线程的 <strong>等待/通知机制</strong> 是基于 Object 类的 <code>wait()</code> 方法和 <code>notify()</code>、<code>notifyAll()</code> 方法来实现的。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Object#wait()</strong></td>
<td align="left">让当前线程进入等待队列中，<strong>并释放当前持有的锁对象</strong></td>
</tr>
<tr>
<td align="left"><strong>Object#notify()</strong></td>
<td align="left">随机唤醒等待队列中的一个线程，让其重新进入到调度队列中</td>
</tr>
<tr>
<td align="left"><strong>Object#notifyAll()</strong></td>
<td align="left">唤醒等待队列中的全部线程</td>
</tr>
</tbody></table>
<blockquote>
<p>  <strong>调用wait()和notify()方法需要注意的细节</strong></p>
</blockquote>
<ol>
<li><code>wait()</code>和<code>notify()</code>方法必须要由同一个对象（即锁对象）调用。只有锁对象的<code>notify()</code>方法才能唤醒由该锁对象调用<code>wait()</code>方法后挂起的线程。</li>
<li><code>wait()</code>和<code>notify()</code>方法是属于<code>Object</code>类的方法。因此，锁对象可以是任意对象。</li>
<li><code>wait()</code>和<code>notify()</code>方法必须要在同步代码块或同步函数中使用。因为，必须通过锁对象调用这2个方法。</li>
</ol>
<h2 id="6-3-代码演示"><a href="#6-3-代码演示" class="headerlink" title="6.3    代码演示"></a>6.3    代码演示</h2><ul>
<li><p>  假如线程A现在持有了一个锁 lock 并开始执行，它可以使用 <code>lock.wait()</code> 让自己进入等待状态。这个时候， lock 这个锁是被释放了的。</p>
</li>
<li><p>这时，线程B获得了 lock 这个锁并开始执行，它可以在某一时刻，使用 <code>lock.notify()</code> ，通知之前持有 lock 锁并进入等待状态的线程A，说“线程A你不用等了，可以往下执行了”。</p>
<blockquote>
<p>  <strong>需要注意的是，这个时候线程B并没有释放锁 lock ，除非线程B这个时候使用 <code>lock.wait()</code> 释放锁，或者线程B执行结束自行释放锁，线程A才能得到 lock 锁。</strong></p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitAndNotify</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadA: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadB: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadA</span>()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadB</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">ThreadA: <span class="number">0</span></span><br><span class="line">ThreadB: <span class="number">0</span></span><br><span class="line">ThreadA: <span class="number">1</span></span><br><span class="line">ThreadB: <span class="number">1</span></span><br><span class="line">ThreadA: <span class="number">2</span></span><br><span class="line">ThreadB: <span class="number">2</span></span><br><span class="line">ThreadA: <span class="number">3</span></span><br><span class="line">ThreadB: <span class="number">3</span></span><br><span class="line">ThreadA: <span class="number">4</span></span><br><span class="line">ThreadB: <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>​    </p>
<hr>
<h1 id="7-Java内存模型（JMM）"><a href="#7-Java内存模型（JMM）" class="headerlink" title="7    Java内存模型（JMM）"></a>7    Java内存模型（JMM）</h1><ul>
<li>  <a target="_blank" rel="noopener" href="https://lvnengdong.github.io/2021/07/08/JMM/">超链接：JMM</a></li>
</ul>
<hr>
<h1 id="8-线程池"><a href="#8-线程池" class="headerlink" title="8    线程池"></a>8    线程池</h1><p><a href>超链接</a></p>
<h2 id="7-1、概念"><a href="#7-1、概念" class="headerlink" title="7.1、概念"></a>7.1、概念</h2><ul>
<li><strong>线程池：</strong>一个可以容纳多个线程对象的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程对象而消耗过多的资源。</li>
</ul>
<h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ol>
<li><p>降低资源消耗。</p>
<p>​    减少了创建和销毁线程的次数，每个线程都可以被反复利用。</p>
</li>
<li><p>提高响应速度。</p>
<p>​    当任务到达时，任务可以不需要等待线程的创建就能立即执行。[直接从线程池中调用线程对象]</p>
</li>
<li><p>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线程的数据，防止因为消耗过多的内存而导致服务器奔溃。(每个线程大约需要1MB的内存，线程开的越多，消耗的内存也就越大，最后死机)</p>
<p><em>线程池会事先设置好该池内会有多少个线程，假设某一时刻线程池中的线程全部处于运行状态，这时如果还有新的任务需要申请新的线程，该任务不会创建新的线程，而是进入等待状态，直到线程池中的某个线程处于空闲状态，再调用该线程去执行任务。</em></p>
</li>
</ol>
<h2 id="7-2、线程池的使用"><a href="#7-2、线程池的使用" class="headerlink" title="7.2、线程池的使用"></a>7.2、线程池的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executor;	<span class="comment">// 线程池的顶级接口</span></span><br><span class="line">java.util.concurrent.ExecutorService；	<span class="comment">// 真正的线程池接口</span></span><br><span class="line">java.util.concurrent.Executors	<span class="comment">// 线程工厂类，提供了一些静态方法用于生成常用的线程池</span></span><br></pre></td></tr></table></figure>

<p>Java中线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而是一个线程池执行工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，因此官方提供了一个工具类<code>java.util.concurrent.Executors</code>线程工厂类，里面提供了一些静态工厂，生成一些常用的线程池。</p>
<ul>
<li><p><strong>Executors类中创建线程池的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个可重用的固定线程数的线程池对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>线程池对象ExecutorService中的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取线程池中某一个线程对象，并执行</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task)</span><br><span class="line">    <span class="comment">// Future接口：用来记录线程任务执行完毕后产生的结果。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用线程池对象的步骤"><a href="#使用线程池对象的步骤" class="headerlink" title="使用线程池对象的步骤"></a>使用线程池对象的步骤</h3><ol>
<li>创建线程池对象；</li>
<li>创建Runnable接口的子类对象。(task)</li>
<li>提交Runnable接口子类对象。</li>
<li>关闭线程池。(一般不做)</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
